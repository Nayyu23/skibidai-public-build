{"ast":null,"code":"import _objectSpread from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _classCallCheck from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _get from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/get.js\";\nimport _getPrototypeOf from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js\";\nimport _inherits from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = function __defNormalProp(obj, key, value) {\n  return key in obj ? __defProp(obj, key, {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: value\n  }) : obj[key] = value;\n};\nvar __publicField = function __publicField(obj, key, value) {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nimport { Loader, FileLoader, ShapePath } from \"three\";\nvar FontLoader = /*#__PURE__*/function (_Loader) {\n  _inherits(FontLoader, _Loader);\n  var _super = _createSuper(FontLoader);\n  function FontLoader(manager) {\n    _classCallCheck(this, FontLoader);\n    return _super.call(this, manager);\n  }\n  _createClass(FontLoader, [{\n    key: \"load\",\n    value: function load(url, onLoad, onProgress, onError) {\n      var _this = this;\n      var loader = new FileLoader(this.manager);\n      loader.setPath(this.path);\n      loader.setRequestHeader(this.requestHeader);\n      loader.setWithCredentials(this.withCredentials);\n      loader.load(url, function (response) {\n        if (typeof response !== \"string\") throw new Error(\"unsupported data type\");\n        var json = JSON.parse(response);\n        var font = _this.parse(json);\n        if (onLoad) onLoad(font);\n      }, onProgress, onError);\n    }\n  }, {\n    key: \"loadAsync\",\n    value: function loadAsync(url, onProgress) {\n      return _get(_getPrototypeOf(FontLoader.prototype), \"loadAsync\", this).call(this, url, onProgress);\n    }\n  }, {\n    key: \"parse\",\n    value: function parse(json) {\n      return new Font(json);\n    }\n  }]);\n  return FontLoader;\n}(Loader);\nvar Font = /*#__PURE__*/function () {\n  function Font(data) {\n    _classCallCheck(this, Font);\n    __publicField(this, \"data\");\n    this.data = data;\n  }\n  _createClass(Font, [{\n    key: \"generateShapes\",\n    value: function generateShapes(text) {\n      var size = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 100;\n      var _options = arguments.length > 2 ? arguments[2] : undefined;\n      var shapes = [];\n      var options = _objectSpread({\n        letterSpacing: 0,\n        lineHeight: 1\n      }, _options);\n      var paths = createPaths(text, size, this.data, options);\n      for (var p = 0, pl = paths.length; p < pl; p++) {\n        Array.prototype.push.apply(shapes, paths[p].toShapes(false));\n      }\n      return shapes;\n    }\n  }]);\n  return Font;\n}();\n__publicField(Font, \"isFont\");\n__publicField(Font, \"type\");\nfunction createPaths(text, size, data, options) {\n  var chars = Array.from(text);\n  var scale = size / data.resolution;\n  var line_height = (data.boundingBox.yMax - data.boundingBox.yMin + data.underlineThickness) * scale;\n  var paths = [];\n  var offsetX = 0,\n    offsetY = 0;\n  for (var i = 0; i < chars.length; i++) {\n    var char = chars[i];\n    if (char === \"\\n\") {\n      offsetX = 0;\n      offsetY -= line_height * options.lineHeight;\n    } else {\n      var ret = createPath(char, scale, offsetX, offsetY, data);\n      if (ret) {\n        offsetX += ret.offsetX + options.letterSpacing;\n        paths.push(ret.path);\n      }\n    }\n  }\n  return paths;\n}\nfunction createPath(char, scale, offsetX, offsetY, data) {\n  var glyph = data.glyphs[char] || data.glyphs[\"?\"];\n  if (!glyph) {\n    console.error('THREE.Font: character \"' + char + '\" does not exists in font family ' + data.familyName + \".\");\n    return;\n  }\n  var path = new ShapePath();\n  var x, y, cpx, cpy, cpx1, cpy1, cpx2, cpy2;\n  if (glyph.o) {\n    var outline = glyph._cachedOutline || (glyph._cachedOutline = glyph.o.split(\" \"));\n    for (var i = 0, l = outline.length; i < l;) {\n      var action = outline[i++];\n      switch (action) {\n        case \"m\":\n          x = parseInt(outline[i++]) * scale + offsetX;\n          y = parseInt(outline[i++]) * scale + offsetY;\n          path.moveTo(x, y);\n          break;\n        case \"l\":\n          x = parseInt(outline[i++]) * scale + offsetX;\n          y = parseInt(outline[i++]) * scale + offsetY;\n          path.lineTo(x, y);\n          break;\n        case \"q\":\n          cpx = parseInt(outline[i++]) * scale + offsetX;\n          cpy = parseInt(outline[i++]) * scale + offsetY;\n          cpx1 = parseInt(outline[i++]) * scale + offsetX;\n          cpy1 = parseInt(outline[i++]) * scale + offsetY;\n          path.quadraticCurveTo(cpx1, cpy1, cpx, cpy);\n          break;\n        case \"b\":\n          cpx = parseInt(outline[i++]) * scale + offsetX;\n          cpy = parseInt(outline[i++]) * scale + offsetY;\n          cpx1 = parseInt(outline[i++]) * scale + offsetX;\n          cpy1 = parseInt(outline[i++]) * scale + offsetY;\n          cpx2 = parseInt(outline[i++]) * scale + offsetX;\n          cpy2 = parseInt(outline[i++]) * scale + offsetY;\n          path.bezierCurveTo(cpx1, cpy1, cpx2, cpy2, cpx, cpy);\n          break;\n      }\n    }\n  }\n  return {\n    offsetX: glyph.ha * scale,\n    path: path\n  };\n}\nexport { Font, FontLoader };","map":{"version":3,"names":["FontLoader","_Loader","_inherits","_super","_createSuper","manager","_classCallCheck","call","_createClass","key","value","load","url","onLoad","onProgress","onError","_this","loader","FileLoader","setPath","path","setRequestHeader","requestHeader","setWithCredentials","withCredentials","response","Error","json","JSON","parse","font","loadAsync","_get","_getPrototypeOf","prototype","Font","Loader","data","__publicField","generateShapes","text","size","arguments","length","undefined","_options","shapes","options","_objectSpread","letterSpacing","lineHeight","paths","createPaths","p","pl","Array","push","apply","toShapes","chars","from","scale","resolution","line_height","boundingBox","yMax","yMin","underlineThickness","offsetX","offsetY","i","char","ret","createPath","glyph","glyphs","console","error","familyName","ShapePath","x","y","cpx","cpy","cpx1","cpy1","cpx2","cpy2","o","outline","_cachedOutline","split","l","action","parseInt","moveTo","lineTo","quadraticCurveTo","bezierCurveTo","ha"],"sources":["C:\\Users\\Nayyu\\Desktop\\skibidai-public-build\\node_modules\\src\\loaders\\FontLoader.ts"],"sourcesContent":["import { Loader, FileLoader, ShapePath } from 'three'\n\nimport type { LoadingManager, Shape } from 'three'\n\ntype Options = {\n  lineHeight: number\n  letterSpacing: number\n}\n\nexport class FontLoader extends Loader {\n  constructor(manager?: LoadingManager) {\n    super(manager)\n  }\n\n  public load(\n    url: string,\n    onLoad?: (responseFont: Font) => void,\n    onProgress?: (event: ProgressEvent) => void,\n    onError?: (event: ErrorEvent) => void,\n  ): void {\n    const loader = new FileLoader(this.manager)\n\n    loader.setPath(this.path)\n    loader.setRequestHeader(this.requestHeader)\n    loader.setWithCredentials(this.withCredentials)\n\n    loader.load(\n      url,\n      (response) => {\n        if (typeof response !== 'string') throw new Error('unsupported data type')\n\n        const json = JSON.parse(response)\n\n        const font = this.parse(json)\n\n        if (onLoad) onLoad(font)\n      },\n      onProgress,\n      onError as (event: unknown) => void,\n    )\n  }\n\n  loadAsync(url: string, onProgress?: (event: ProgressEvent) => void): Promise<Font> {\n    // @ts-ignore\n    return super.loadAsync(url, onProgress)\n  }\n\n  public parse(json: FontData): Font {\n    return new Font(json)\n  }\n}\n\ntype Glyph = {\n  _cachedOutline: string[]\n  ha: number\n  o: string\n}\n\ntype FontData = {\n  boundingBox: { yMax: number; yMin: number }\n  familyName: string\n  glyphs: { [k: string]: Glyph }\n  resolution: number\n  underlineThickness: number\n}\n\nexport class Font {\n  public data: FontData\n  public static isFont: true\n  public static type: 'Font'\n\n  constructor(data: FontData) {\n    this.data = data\n  }\n\n  public generateShapes(text: string, size = 100, _options?: Partial<Options>): Shape[] {\n    const shapes: Shape[] = []\n    const options = { letterSpacing: 0, lineHeight: 1, ..._options }\n    const paths = createPaths(text, size, this.data, options)\n    for (let p = 0, pl = paths.length; p < pl; p++) {\n      Array.prototype.push.apply(shapes, paths[p].toShapes(false))\n    }\n    return shapes\n  }\n}\n\nfunction createPaths(text: string, size: number, data: FontData, options: Options): ShapePath[] {\n  const chars = Array.from(text)\n  const scale = size / data.resolution\n  const line_height = (data.boundingBox.yMax - data.boundingBox.yMin + data.underlineThickness) * scale\n\n  const paths: ShapePath[] = []\n\n  let offsetX = 0,\n    offsetY = 0\n\n  for (let i = 0; i < chars.length; i++) {\n    const char = chars[i]\n\n    if (char === '\\n') {\n      offsetX = 0\n      offsetY -= line_height * options.lineHeight\n    } else {\n      const ret = createPath(char, scale, offsetX, offsetY, data)\n      if (ret) {\n        offsetX += ret.offsetX + options.letterSpacing\n        paths.push(ret.path)\n      }\n    }\n  }\n\n  return paths\n}\n\nfunction createPath(\n  char: string,\n  scale: number,\n  offsetX: number,\n  offsetY: number,\n  data: FontData,\n): { offsetX: number; path: ShapePath } | undefined {\n  const glyph = data.glyphs[char] || data.glyphs['?']\n\n  if (!glyph) {\n    console.error('THREE.Font: character \"' + char + '\" does not exists in font family ' + data.familyName + '.')\n    return\n  }\n\n  const path = new ShapePath()\n\n  let x, y, cpx, cpy, cpx1, cpy1, cpx2, cpy2\n\n  if (glyph.o) {\n    const outline = glyph._cachedOutline || (glyph._cachedOutline = glyph.o.split(' '))\n\n    for (let i = 0, l = outline.length; i < l; ) {\n      const action = outline[i++]\n\n      switch (action) {\n        case 'm': // moveTo\n          x = parseInt(outline[i++]) * scale + offsetX\n          y = parseInt(outline[i++]) * scale + offsetY\n\n          path.moveTo(x, y)\n\n          break\n\n        case 'l': // lineTo\n          x = parseInt(outline[i++]) * scale + offsetX\n          y = parseInt(outline[i++]) * scale + offsetY\n\n          path.lineTo(x, y)\n\n          break\n\n        case 'q': // quadraticCurveTo\n          cpx = parseInt(outline[i++]) * scale + offsetX\n          cpy = parseInt(outline[i++]) * scale + offsetY\n          cpx1 = parseInt(outline[i++]) * scale + offsetX\n          cpy1 = parseInt(outline[i++]) * scale + offsetY\n\n          path.quadraticCurveTo(cpx1, cpy1, cpx, cpy)\n\n          break\n\n        case 'b': // bezierCurveTo\n          cpx = parseInt(outline[i++]) * scale + offsetX\n          cpy = parseInt(outline[i++]) * scale + offsetY\n          cpx1 = parseInt(outline[i++]) * scale + offsetX\n          cpy1 = parseInt(outline[i++]) * scale + offsetY\n          cpx2 = parseInt(outline[i++]) * scale + offsetX\n          cpy2 = parseInt(outline[i++]) * scale + offsetY\n\n          path.bezierCurveTo(cpx1, cpy1, cpx2, cpy2, cpx, cpy)\n\n          break\n      }\n    }\n  }\n\n  return { offsetX: glyph.ha * scale, path }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}