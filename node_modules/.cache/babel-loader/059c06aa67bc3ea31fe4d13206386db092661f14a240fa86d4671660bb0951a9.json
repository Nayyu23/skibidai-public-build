{"ast":null,"code":"import _classCallCheck from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _inherits from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport { Loader, FileLoader } from \"three\";\nimport { parse as parseBuffer } from \"../libs/opentype.js\";\nvar TTFLoader = /*#__PURE__*/function (_Loader) {\n  _inherits(TTFLoader, _Loader);\n  var _super = _createSuper(TTFLoader);\n  function TTFLoader(manager) {\n    var _this;\n    _classCallCheck(this, TTFLoader);\n    _this = _super.call(this, manager);\n    _this.reversed = false;\n    return _this;\n  }\n  _createClass(TTFLoader, [{\n    key: \"load\",\n    value: function load(url, onLoad, onProgress, onError) {\n      var scope = this;\n      var loader = new FileLoader(this.manager);\n      loader.setPath(this.path);\n      loader.setResponseType(\"arraybuffer\");\n      loader.setRequestHeader(this.requestHeader);\n      loader.setWithCredentials(this.withCredentials);\n      loader.load(url, function (buffer) {\n        try {\n          onLoad(parseBuffer(buffer));\n        } catch (e) {\n          if (onError) {\n            onError(e);\n          } else {\n            console.error(e);\n          }\n          scope.manager.itemError(url);\n        }\n      }, onProgress, onError);\n    }\n  }, {\n    key: \"parse\",\n    value: function parse(arraybuffer) {\n      function convert(font, reversed) {\n        var round = Math.round;\n        var glyphs = {};\n        var scale = 1e5 / ((font.unitsPerEm || 2048) * 72);\n        var glyphIndexMap = font.encoding.cmap.glyphIndexMap;\n        var unicodes = Object.keys(glyphIndexMap);\n        var _loop = function _loop() {\n          var unicode = unicodes[i];\n          var glyph = font.glyphs.glyphs[glyphIndexMap[unicode]];\n          if (unicode !== void 0) {\n            var token = {\n              ha: round(glyph.advanceWidth * scale),\n              x_min: round(glyph.xMin * scale),\n              x_max: round(glyph.xMax * scale),\n              o: \"\"\n            };\n            if (reversed) {\n              glyph.path.commands = reverseCommands(glyph.path.commands);\n            }\n            glyph.path.commands.forEach(function (command) {\n              if (command.type.toLowerCase() === \"c\") {\n                command.type = \"b\";\n              }\n              token.o += command.type.toLowerCase() + \" \";\n              if (command.x !== void 0 && command.y !== void 0) {\n                token.o += round(command.x * scale) + \" \" + round(command.y * scale) + \" \";\n              }\n              if (command.x1 !== void 0 && command.y1 !== void 0) {\n                token.o += round(command.x1 * scale) + \" \" + round(command.y1 * scale) + \" \";\n              }\n              if (command.x2 !== void 0 && command.y2 !== void 0) {\n                token.o += round(command.x2 * scale) + \" \" + round(command.y2 * scale) + \" \";\n              }\n            });\n            glyphs[String.fromCodePoint(glyph.unicode)] = token;\n          }\n        };\n        for (var i = 0; i < unicodes.length; i++) {\n          _loop();\n        }\n        return {\n          glyphs: glyphs,\n          familyName: font.getEnglishName(\"fullName\"),\n          ascender: round(font.ascender * scale),\n          descender: round(font.descender * scale),\n          underlinePosition: font.tables.post.underlinePosition,\n          underlineThickness: font.tables.post.underlineThickness,\n          boundingBox: {\n            xMin: font.tables.head.xMin,\n            xMax: font.tables.head.xMax,\n            yMin: font.tables.head.yMin,\n            yMax: font.tables.head.yMax\n          },\n          resolution: 1e3,\n          original_font_information: font.tables.name\n        };\n      }\n      function reverseCommands(commands) {\n        var paths = [];\n        var path;\n        commands.forEach(function (c) {\n          if (c.type.toLowerCase() === \"m\") {\n            path = [c];\n            paths.push(path);\n          } else if (c.type.toLowerCase() !== \"z\") {\n            path.push(c);\n          }\n        });\n        var reversed = [];\n        paths.forEach(function (p) {\n          var result = {\n            type: \"m\",\n            x: p[p.length - 1].x,\n            y: p[p.length - 1].y\n          };\n          reversed.push(result);\n          for (var i = p.length - 1; i > 0; i--) {\n            var command = p[i];\n            var result2 = {\n              type: command.type\n            };\n            if (command.x2 !== void 0 && command.y2 !== void 0) {\n              result2.x1 = command.x2;\n              result2.y1 = command.y2;\n              result2.x2 = command.x1;\n              result2.y2 = command.y1;\n            } else if (command.x1 !== void 0 && command.y1 !== void 0) {\n              result2.x1 = command.x1;\n              result2.y1 = command.y1;\n            }\n            result2.x = p[i - 1].x;\n            result2.y = p[i - 1].y;\n            reversed.push(result2);\n          }\n        });\n        return reversed;\n      }\n      return convert(parseBuffer(arraybuffer), this.reversed);\n    }\n  }]);\n  return TTFLoader;\n}(Loader);\nexport { TTFLoader };","map":{"version":3,"names":["TTFLoader","_Loader","_inherits","_super","_createSuper","manager","_this","_classCallCheck","call","reversed","_createClass","key","value","load","url","onLoad","onProgress","onError","scope","loader","FileLoader","setPath","path","setResponseType","setRequestHeader","requestHeader","setWithCredentials","withCredentials","buffer","parseBuffer","e","console","error","itemError","parse","arraybuffer","convert","font","round","Math","glyphs","scale","unitsPerEm","glyphIndexMap","encoding","cmap","unicodes","Object","keys","_loop","unicode","i","glyph","token","ha","advanceWidth","x_min","xMin","x_max","xMax","o","commands","reverseCommands","forEach","command","type","toLowerCase","x","y","x1","y1","x2","y2","String","fromCodePoint","length","familyName","getEnglishName","ascender","descender","underlinePosition","tables","post","underlineThickness","boundingBox","head","yMin","yMax","resolution","original_font_information","name","paths","c","push","p","result","result2","Loader"],"sources":["C:\\Users\\Nayyu\\Desktop\\skibidai-public-build\\node_modules\\src\\loaders\\TTFLoader.js"],"sourcesContent":["import { FileLoader, Loader } from 'three'\nimport { parse } from '../libs/opentype.js'\n\n/**\n * Requires opentype.js to be included in the project.\n * Loads TTF files and converts them into typeface JSON that can be used directly\n * to create THREE.Font objects.\n */\n\nclass TTFLoader extends Loader {\n  constructor(manager) {\n    super(manager)\n\n    this.reversed = false\n  }\n\n  load(url, onLoad, onProgress, onError) {\n    const scope = this\n\n    const loader = new FileLoader(this.manager)\n    loader.setPath(this.path)\n    loader.setResponseType('arraybuffer')\n    loader.setRequestHeader(this.requestHeader)\n    loader.setWithCredentials(this.withCredentials)\n    loader.load(\n      url,\n      function (buffer) {\n        try {\n          onLoad(parse(buffer))\n        } catch (e) {\n          if (onError) {\n            onError(e)\n          } else {\n            console.error(e)\n          }\n\n          scope.manager.itemError(url)\n        }\n      },\n      onProgress,\n      onError,\n    )\n  }\n\n  parse(arraybuffer) {\n    function convert(font, reversed) {\n      const round = Math.round\n\n      const glyphs = {}\n      const scale = 100000 / ((font.unitsPerEm || 2048) * 72)\n\n      const glyphIndexMap = font.encoding.cmap.glyphIndexMap\n      const unicodes = Object.keys(glyphIndexMap)\n\n      for (let i = 0; i < unicodes.length; i++) {\n        const unicode = unicodes[i]\n        const glyph = font.glyphs.glyphs[glyphIndexMap[unicode]]\n\n        if (unicode !== undefined) {\n          const token = {\n            ha: round(glyph.advanceWidth * scale),\n            x_min: round(glyph.xMin * scale),\n            x_max: round(glyph.xMax * scale),\n            o: '',\n          }\n\n          if (reversed) {\n            glyph.path.commands = reverseCommands(glyph.path.commands)\n          }\n\n          glyph.path.commands.forEach(function (command) {\n            if (command.type.toLowerCase() === 'c') {\n              command.type = 'b'\n            }\n\n            token.o += command.type.toLowerCase() + ' '\n\n            if (command.x !== undefined && command.y !== undefined) {\n              token.o += round(command.x * scale) + ' ' + round(command.y * scale) + ' '\n            }\n\n            if (command.x1 !== undefined && command.y1 !== undefined) {\n              token.o += round(command.x1 * scale) + ' ' + round(command.y1 * scale) + ' '\n            }\n\n            if (command.x2 !== undefined && command.y2 !== undefined) {\n              token.o += round(command.x2 * scale) + ' ' + round(command.y2 * scale) + ' '\n            }\n          })\n\n          glyphs[String.fromCodePoint(glyph.unicode)] = token\n        }\n      }\n\n      return {\n        glyphs: glyphs,\n        familyName: font.getEnglishName('fullName'),\n        ascender: round(font.ascender * scale),\n        descender: round(font.descender * scale),\n        underlinePosition: font.tables.post.underlinePosition,\n        underlineThickness: font.tables.post.underlineThickness,\n        boundingBox: {\n          xMin: font.tables.head.xMin,\n          xMax: font.tables.head.xMax,\n          yMin: font.tables.head.yMin,\n          yMax: font.tables.head.yMax,\n        },\n        resolution: 1000,\n        original_font_information: font.tables.name,\n      }\n    }\n\n    function reverseCommands(commands) {\n      const paths = []\n      let path\n\n      commands.forEach(function (c) {\n        if (c.type.toLowerCase() === 'm') {\n          path = [c]\n          paths.push(path)\n        } else if (c.type.toLowerCase() !== 'z') {\n          path.push(c)\n        }\n      })\n\n      const reversed = []\n\n      paths.forEach(function (p) {\n        const result = {\n          type: 'm',\n          x: p[p.length - 1].x,\n          y: p[p.length - 1].y,\n        }\n\n        reversed.push(result)\n\n        for (let i = p.length - 1; i > 0; i--) {\n          const command = p[i]\n          const result = { type: command.type }\n\n          if (command.x2 !== undefined && command.y2 !== undefined) {\n            result.x1 = command.x2\n            result.y1 = command.y2\n            result.x2 = command.x1\n            result.y2 = command.y1\n          } else if (command.x1 !== undefined && command.y1 !== undefined) {\n            result.x1 = command.x1\n            result.y1 = command.y1\n          }\n\n          result.x = p[i - 1].x\n          result.y = p[i - 1].y\n          reversed.push(result)\n        }\n      })\n\n      return reversed\n    }\n\n    return convert(parse(arraybuffer), this.reversed)\n  }\n}\n\nexport { TTFLoader }\n"],"mappings":";;;;;;IASMA,SAAA,0BAAAC,OAAA;EAAAC,SAAA,CAAAF,SAAA,EAAAC,OAAA;EAAA,IAAAE,MAAA,GAAAC,YAAA,CAAAJ,SAAA;EACJ,SAAAA,UAAYK,OAAA,EAAS;IAAA,IAAAC,KAAA;IAAAC,eAAA,OAAAP,SAAA;IACnBM,KAAA,GAAAH,MAAA,CAAAK,IAAA,OAAMH,OAAO;IAEbC,KAAA,CAAKG,QAAA,GAAW;IAAA,OAAAH,KAAA;EACjB;EAAAI,YAAA,CAAAV,SAAA;IAAAW,GAAA;IAAAC,KAAA,EAED,SAAAC,KAAKC,GAAA,EAAKC,MAAA,EAAQC,UAAA,EAAYC,OAAA,EAAS;MACrC,IAAMC,KAAA,GAAQ;MAEd,IAAMC,MAAA,GAAS,IAAIC,UAAA,CAAW,KAAKf,OAAO;MAC1Cc,MAAA,CAAOE,OAAA,CAAQ,KAAKC,IAAI;MACxBH,MAAA,CAAOI,eAAA,CAAgB,aAAa;MACpCJ,MAAA,CAAOK,gBAAA,CAAiB,KAAKC,aAAa;MAC1CN,MAAA,CAAOO,kBAAA,CAAmB,KAAKC,eAAe;MAC9CR,MAAA,CAAON,IAAA,CACLC,GAAA,EACA,UAAUc,MAAA,EAAQ;QAChB,IAAI;UACFb,MAAA,CAAOc,WAAA,CAAMD,MAAM,CAAC;QACrB,SAAQE,CAAA,EAAP;UACA,IAAIb,OAAA,EAAS;YACXA,OAAA,CAAQa,CAAC;UACrB,OAAiB;YACLC,OAAA,CAAQC,KAAA,CAAMF,CAAC;UAChB;UAEDZ,KAAA,CAAMb,OAAA,CAAQ4B,SAAA,CAAUnB,GAAG;QAC5B;MACF,GACDE,UAAA,EACAC,OACD;IACF;EAAA;IAAAN,GAAA;IAAAC,KAAA,EAED,SAAAsB,MAAMC,WAAA,EAAa;MACjB,SAASC,QAAQC,IAAA,EAAM5B,QAAA,EAAU;QAC/B,IAAM6B,KAAA,GAAQC,IAAA,CAAKD,KAAA;QAEnB,IAAME,MAAA,GAAS,CAAE;QACjB,IAAMC,KAAA,GAAQ,QAAWJ,IAAA,CAAKK,UAAA,IAAc,QAAQ;QAEpD,IAAMC,aAAA,GAAgBN,IAAA,CAAKO,QAAA,CAASC,IAAA,CAAKF,aAAA;QACzC,IAAMG,QAAA,GAAWC,MAAA,CAAOC,IAAA,CAAKL,aAAa;QAAA,IAAAM,KAAA,YAAAA,MAAA,EAEA;UACxC,IAAMC,OAAA,GAAUJ,QAAA,CAASK,CAAC;UAC1B,IAAMC,KAAA,GAAQf,IAAA,CAAKG,MAAA,CAAOA,MAAA,CAAOG,aAAA,CAAcO,OAAO,CAAC;UAEvD,IAAIA,OAAA,KAAY,QAAW;YACzB,IAAMG,KAAA,GAAQ;cACZC,EAAA,EAAIhB,KAAA,CAAMc,KAAA,CAAMG,YAAA,GAAed,KAAK;cACpCe,KAAA,EAAOlB,KAAA,CAAMc,KAAA,CAAMK,IAAA,GAAOhB,KAAK;cAC/BiB,KAAA,EAAOpB,KAAA,CAAMc,KAAA,CAAMO,IAAA,GAAOlB,KAAK;cAC/BmB,CAAA,EAAG;YACJ;YAED,IAAInD,QAAA,EAAU;cACZ2C,KAAA,CAAM9B,IAAA,CAAKuC,QAAA,GAAWC,eAAA,CAAgBV,KAAA,CAAM9B,IAAA,CAAKuC,QAAQ;YAC1D;YAEDT,KAAA,CAAM9B,IAAA,CAAKuC,QAAA,CAASE,OAAA,CAAQ,UAAUC,OAAA,EAAS;cAC7C,IAAIA,OAAA,CAAQC,IAAA,CAAKC,WAAA,CAAW,MAAO,KAAK;gBACtCF,OAAA,CAAQC,IAAA,GAAO;cAChB;cAEDZ,KAAA,CAAMO,CAAA,IAAKI,OAAA,CAAQC,IAAA,CAAKC,WAAA,CAAa,IAAG;cAExC,IAAIF,OAAA,CAAQG,CAAA,KAAM,UAAaH,OAAA,CAAQI,CAAA,KAAM,QAAW;gBACtDf,KAAA,CAAMO,CAAA,IAAKtB,KAAA,CAAM0B,OAAA,CAAQG,CAAA,GAAI1B,KAAK,IAAI,MAAMH,KAAA,CAAM0B,OAAA,CAAQI,CAAA,GAAI3B,KAAK,IAAI;cACxE;cAED,IAAIuB,OAAA,CAAQK,EAAA,KAAO,UAAaL,OAAA,CAAQM,EAAA,KAAO,QAAW;gBACxDjB,KAAA,CAAMO,CAAA,IAAKtB,KAAA,CAAM0B,OAAA,CAAQK,EAAA,GAAK5B,KAAK,IAAI,MAAMH,KAAA,CAAM0B,OAAA,CAAQM,EAAA,GAAK7B,KAAK,IAAI;cAC1E;cAED,IAAIuB,OAAA,CAAQO,EAAA,KAAO,UAAaP,OAAA,CAAQQ,EAAA,KAAO,QAAW;gBACxDnB,KAAA,CAAMO,CAAA,IAAKtB,KAAA,CAAM0B,OAAA,CAAQO,EAAA,GAAK9B,KAAK,IAAI,MAAMH,KAAA,CAAM0B,OAAA,CAAQQ,EAAA,GAAK/B,KAAK,IAAI;cAC1E;YACb,CAAW;YAEDD,MAAA,CAAOiC,MAAA,CAAOC,aAAA,CAActB,KAAA,CAAMF,OAAO,CAAC,IAAIG,KAAA;UAC/C;QACF;QAtCD,SAASF,CAAA,GAAI,GAAGA,CAAA,GAAIL,QAAA,CAAS6B,MAAA,EAAQxB,CAAA;UAAAF,KAAA;QAAA;QAwCrC,OAAO;UACLT,MAAA,EAAAA,MAAA;UACAoC,UAAA,EAAYvC,IAAA,CAAKwC,cAAA,CAAe,UAAU;UAC1CC,QAAA,EAAUxC,KAAA,CAAMD,IAAA,CAAKyC,QAAA,GAAWrC,KAAK;UACrCsC,SAAA,EAAWzC,KAAA,CAAMD,IAAA,CAAK0C,SAAA,GAAYtC,KAAK;UACvCuC,iBAAA,EAAmB3C,IAAA,CAAK4C,MAAA,CAAOC,IAAA,CAAKF,iBAAA;UACpCG,kBAAA,EAAoB9C,IAAA,CAAK4C,MAAA,CAAOC,IAAA,CAAKC,kBAAA;UACrCC,WAAA,EAAa;YACX3B,IAAA,EAAMpB,IAAA,CAAK4C,MAAA,CAAOI,IAAA,CAAK5B,IAAA;YACvBE,IAAA,EAAMtB,IAAA,CAAK4C,MAAA,CAAOI,IAAA,CAAK1B,IAAA;YACvB2B,IAAA,EAAMjD,IAAA,CAAK4C,MAAA,CAAOI,IAAA,CAAKC,IAAA;YACvBC,IAAA,EAAMlD,IAAA,CAAK4C,MAAA,CAAOI,IAAA,CAAKE;UACxB;UACDC,UAAA,EAAY;UACZC,yBAAA,EAA2BpD,IAAA,CAAK4C,MAAA,CAAOS;QACxC;MACF;MAED,SAAS5B,gBAAgBD,QAAA,EAAU;QACjC,IAAM8B,KAAA,GAAQ,EAAE;QAChB,IAAIrE,IAAA;QAEJuC,QAAA,CAASE,OAAA,CAAQ,UAAU6B,CAAA,EAAG;UAC5B,IAAIA,CAAA,CAAE3B,IAAA,CAAKC,WAAA,CAAW,MAAO,KAAK;YAChC5C,IAAA,GAAO,CAACsE,CAAC;YACTD,KAAA,CAAME,IAAA,CAAKvE,IAAI;UAChB,WAAUsE,CAAA,CAAE3B,IAAA,CAAKC,WAAA,CAAW,MAAO,KAAK;YACvC5C,IAAA,CAAKuE,IAAA,CAAKD,CAAC;UACZ;QACT,CAAO;QAED,IAAMnF,QAAA,GAAW,EAAE;QAEnBkF,KAAA,CAAM5B,OAAA,CAAQ,UAAU+B,CAAA,EAAG;UACzB,IAAMC,MAAA,GAAS;YACb9B,IAAA,EAAM;YACNE,CAAA,EAAG2B,CAAA,CAAEA,CAAA,CAAEnB,MAAA,GAAS,CAAC,EAAER,CAAA;YACnBC,CAAA,EAAG0B,CAAA,CAAEA,CAAA,CAAEnB,MAAA,GAAS,CAAC,EAAEP;UACpB;UAED3D,QAAA,CAASoF,IAAA,CAAKE,MAAM;UAEpB,SAAS5C,CAAA,GAAI2C,CAAA,CAAEnB,MAAA,GAAS,GAAGxB,CAAA,GAAI,GAAGA,CAAA,IAAK;YACrC,IAAMa,OAAA,GAAU8B,CAAA,CAAE3C,CAAC;YACnB,IAAM6C,OAAA,GAAS;cAAE/B,IAAA,EAAMD,OAAA,CAAQC;YAAM;YAErC,IAAID,OAAA,CAAQO,EAAA,KAAO,UAAaP,OAAA,CAAQQ,EAAA,KAAO,QAAW;cACxDwB,OAAA,CAAO3B,EAAA,GAAKL,OAAA,CAAQO,EAAA;cACpByB,OAAA,CAAO1B,EAAA,GAAKN,OAAA,CAAQQ,EAAA;cACpBwB,OAAA,CAAOzB,EAAA,GAAKP,OAAA,CAAQK,EAAA;cACpB2B,OAAA,CAAOxB,EAAA,GAAKR,OAAA,CAAQM,EAAA;YAChC,WAAqBN,OAAA,CAAQK,EAAA,KAAO,UAAaL,OAAA,CAAQM,EAAA,KAAO,QAAW;cAC/D0B,OAAA,CAAO3B,EAAA,GAAKL,OAAA,CAAQK,EAAA;cACpB2B,OAAA,CAAO1B,EAAA,GAAKN,OAAA,CAAQM,EAAA;YACrB;YAED0B,OAAA,CAAO7B,CAAA,GAAI2B,CAAA,CAAE3C,CAAA,GAAI,CAAC,EAAEgB,CAAA;YACpB6B,OAAA,CAAO5B,CAAA,GAAI0B,CAAA,CAAE3C,CAAA,GAAI,CAAC,EAAEiB,CAAA;YACpB3D,QAAA,CAASoF,IAAA,CAAKG,OAAM;UACrB;QACT,CAAO;QAED,OAAOvF,QAAA;MACR;MAED,OAAO2B,OAAA,CAAQP,WAAA,CAAMM,WAAW,GAAG,KAAK1B,QAAQ;IACjD;EAAA;EAAA,OAAAT,SAAA;AAAA,EAvJqBiG,MAAA"},"metadata":{},"sourceType":"module","externalDependencies":[]}