{"ast":null,"code":"import _classCallCheck from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _inherits from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport { Matrix4, Object3D, Vector3, EventDispatcher, BufferGeometry, Float32BufferAttribute, MathUtils, Matrix3, Color, Box3, Sphere, BufferAttribute, Vector2 } from \"three\";\nvar _m1 = new Matrix4();\nvar _obj = new Object3D();\nvar _offset = new Vector3();\nvar Geometry = /*#__PURE__*/function (_EventDispatcher) {\n  _inherits(Geometry, _EventDispatcher);\n  var _super = _createSuper(Geometry);\n  function Geometry() {\n    var _this;\n    _classCallCheck(this, Geometry);\n    _this = _super.call(this);\n    _this.isGeometry = true;\n    _this.uuid = MathUtils.generateUUID();\n    _this.name = \"\";\n    _this.type = \"Geometry\";\n    _this.vertices = [];\n    _this.colors = [];\n    _this.faces = [];\n    _this.faceVertexUvs = [[]];\n    _this.morphTargets = [];\n    _this.morphNormals = [];\n    _this.skinWeights = [];\n    _this.skinIndices = [];\n    _this.lineDistances = [];\n    _this.boundingBox = null;\n    _this.boundingSphere = null;\n    _this.elementsNeedUpdate = false;\n    _this.verticesNeedUpdate = false;\n    _this.uvsNeedUpdate = false;\n    _this.normalsNeedUpdate = false;\n    _this.colorsNeedUpdate = false;\n    _this.lineDistancesNeedUpdate = false;\n    _this.groupsNeedUpdate = false;\n    return _this;\n  }\n  _createClass(Geometry, [{\n    key: \"applyMatrix4\",\n    value: function applyMatrix4(matrix) {\n      var normalMatrix = new Matrix3().getNormalMatrix(matrix);\n      for (var i = 0, il = this.vertices.length; i < il; i++) {\n        var vertex = this.vertices[i];\n        vertex.applyMatrix4(matrix);\n      }\n      for (var _i = 0, _il = this.faces.length; _i < _il; _i++) {\n        var face = this.faces[_i];\n        face.normal.applyMatrix3(normalMatrix).normalize();\n        for (var j = 0, jl = face.vertexNormals.length; j < jl; j++) {\n          face.vertexNormals[j].applyMatrix3(normalMatrix).normalize();\n        }\n      }\n      if (this.boundingBox !== null) {\n        this.computeBoundingBox();\n      }\n      if (this.boundingSphere !== null) {\n        this.computeBoundingSphere();\n      }\n      this.verticesNeedUpdate = true;\n      this.normalsNeedUpdate = true;\n      return this;\n    }\n  }, {\n    key: \"rotateX\",\n    value: function rotateX(angle) {\n      _m1.makeRotationX(angle);\n      this.applyMatrix4(_m1);\n      return this;\n    }\n  }, {\n    key: \"rotateY\",\n    value: function rotateY(angle) {\n      _m1.makeRotationY(angle);\n      this.applyMatrix4(_m1);\n      return this;\n    }\n  }, {\n    key: \"rotateZ\",\n    value: function rotateZ(angle) {\n      _m1.makeRotationZ(angle);\n      this.applyMatrix4(_m1);\n      return this;\n    }\n  }, {\n    key: \"translate\",\n    value: function translate(x, y, z) {\n      _m1.makeTranslation(x, y, z);\n      this.applyMatrix4(_m1);\n      return this;\n    }\n  }, {\n    key: \"scale\",\n    value: function scale(x, y, z) {\n      _m1.makeScale(x, y, z);\n      this.applyMatrix4(_m1);\n      return this;\n    }\n  }, {\n    key: \"lookAt\",\n    value: function lookAt(vector) {\n      _obj.lookAt(vector);\n      _obj.updateMatrix();\n      this.applyMatrix4(_obj.matrix);\n      return this;\n    }\n  }, {\n    key: \"fromBufferGeometry\",\n    value: function fromBufferGeometry(geometry) {\n      var scope = this;\n      var index = geometry.index !== null ? geometry.index : void 0;\n      var attributes = geometry.attributes;\n      if (attributes.position === void 0) {\n        console.error(\"THREE.Geometry.fromBufferGeometry(): Position attribute required for conversion.\");\n        return this;\n      }\n      var position = attributes.position;\n      var normal = attributes.normal;\n      var color = attributes.color;\n      var uv = attributes.uv;\n      var uv2 = attributes.uv2;\n      if (uv2 !== void 0) this.faceVertexUvs[1] = [];\n      for (var i = 0; i < position.count; i++) {\n        scope.vertices.push(new Vector3().fromBufferAttribute(position, i));\n        if (color !== void 0) {\n          scope.colors.push(new Color().fromBufferAttribute(color, i));\n        }\n      }\n      function addFace(a, b, c, materialIndex) {\n        var vertexColors = color === void 0 ? [] : [scope.colors[a].clone(), scope.colors[b].clone(), scope.colors[c].clone()];\n        var vertexNormals = normal === void 0 ? [] : [new Vector3().fromBufferAttribute(normal, a), new Vector3().fromBufferAttribute(normal, b), new Vector3().fromBufferAttribute(normal, c)];\n        var face = new Face3(a, b, c, vertexNormals, vertexColors, materialIndex);\n        scope.faces.push(face);\n        if (uv !== void 0) {\n          scope.faceVertexUvs[0].push([new Vector2().fromBufferAttribute(uv, a), new Vector2().fromBufferAttribute(uv, b), new Vector2().fromBufferAttribute(uv, c)]);\n        }\n        if (uv2 !== void 0) {\n          scope.faceVertexUvs[1].push([new Vector2().fromBufferAttribute(uv2, a), new Vector2().fromBufferAttribute(uv2, b), new Vector2().fromBufferAttribute(uv2, c)]);\n        }\n      }\n      var groups = geometry.groups;\n      if (groups.length > 0) {\n        for (var _i2 = 0; _i2 < groups.length; _i2++) {\n          var group = groups[_i2];\n          var start = group.start;\n          var count = group.count;\n          for (var j = start, jl = start + count; j < jl; j += 3) {\n            if (index !== void 0) {\n              addFace(index.getX(j), index.getX(j + 1), index.getX(j + 2), group.materialIndex);\n            } else {\n              addFace(j, j + 1, j + 2, group.materialIndex);\n            }\n          }\n        }\n      } else {\n        if (index !== void 0) {\n          for (var _i3 = 0; _i3 < index.count; _i3 += 3) {\n            addFace(index.getX(_i3), index.getX(_i3 + 1), index.getX(_i3 + 2));\n          }\n        } else {\n          for (var _i4 = 0; _i4 < position.count; _i4 += 3) {\n            addFace(_i4, _i4 + 1, _i4 + 2);\n          }\n        }\n      }\n      this.computeFaceNormals();\n      if (geometry.boundingBox !== null) {\n        this.boundingBox = geometry.boundingBox.clone();\n      }\n      if (geometry.boundingSphere !== null) {\n        this.boundingSphere = geometry.boundingSphere.clone();\n      }\n      return this;\n    }\n  }, {\n    key: \"center\",\n    value: function center() {\n      this.computeBoundingBox();\n      this.boundingBox.getCenter(_offset).negate();\n      this.translate(_offset.x, _offset.y, _offset.z);\n      return this;\n    }\n  }, {\n    key: \"normalize\",\n    value: function normalize() {\n      this.computeBoundingSphere();\n      var center = this.boundingSphere.center;\n      var radius = this.boundingSphere.radius;\n      var s = radius === 0 ? 1 : 1 / radius;\n      var matrix = new Matrix4();\n      matrix.set(s, 0, 0, -s * center.x, 0, s, 0, -s * center.y, 0, 0, s, -s * center.z, 0, 0, 0, 1);\n      this.applyMatrix4(matrix);\n      return this;\n    }\n  }, {\n    key: \"computeFaceNormals\",\n    value: function computeFaceNormals() {\n      var cb = new Vector3(),\n        ab = new Vector3();\n      for (var f = 0, fl = this.faces.length; f < fl; f++) {\n        var face = this.faces[f];\n        var vA = this.vertices[face.a];\n        var vB = this.vertices[face.b];\n        var vC = this.vertices[face.c];\n        cb.subVectors(vC, vB);\n        ab.subVectors(vA, vB);\n        cb.cross(ab);\n        cb.normalize();\n        face.normal.copy(cb);\n      }\n    }\n  }, {\n    key: \"computeVertexNormals\",\n    value: function computeVertexNormals() {\n      var areaWeighted = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n      var vertices = new Array(this.vertices.length);\n      for (var v = 0, vl = this.vertices.length; v < vl; v++) {\n        vertices[v] = new Vector3();\n      }\n      if (areaWeighted) {\n        var cb = new Vector3(),\n          ab = new Vector3();\n        for (var f = 0, fl = this.faces.length; f < fl; f++) {\n          var face = this.faces[f];\n          var vA = this.vertices[face.a];\n          var vB = this.vertices[face.b];\n          var vC = this.vertices[face.c];\n          cb.subVectors(vC, vB);\n          ab.subVectors(vA, vB);\n          cb.cross(ab);\n          vertices[face.a].add(cb);\n          vertices[face.b].add(cb);\n          vertices[face.c].add(cb);\n        }\n      } else {\n        this.computeFaceNormals();\n        for (var _f = 0, _fl = this.faces.length; _f < _fl; _f++) {\n          var _face = this.faces[_f];\n          vertices[_face.a].add(_face.normal);\n          vertices[_face.b].add(_face.normal);\n          vertices[_face.c].add(_face.normal);\n        }\n      }\n      for (var _v = 0, _vl = this.vertices.length; _v < _vl; _v++) {\n        vertices[_v].normalize();\n      }\n      for (var _f2 = 0, _fl2 = this.faces.length; _f2 < _fl2; _f2++) {\n        var _face2 = this.faces[_f2];\n        var vertexNormals = _face2.vertexNormals;\n        if (vertexNormals.length === 3) {\n          vertexNormals[0].copy(vertices[_face2.a]);\n          vertexNormals[1].copy(vertices[_face2.b]);\n          vertexNormals[2].copy(vertices[_face2.c]);\n        } else {\n          vertexNormals[0] = vertices[_face2.a].clone();\n          vertexNormals[1] = vertices[_face2.b].clone();\n          vertexNormals[2] = vertices[_face2.c].clone();\n        }\n      }\n      if (this.faces.length > 0) {\n        this.normalsNeedUpdate = true;\n      }\n    }\n  }, {\n    key: \"computeFlatVertexNormals\",\n    value: function computeFlatVertexNormals() {\n      this.computeFaceNormals();\n      for (var f = 0, fl = this.faces.length; f < fl; f++) {\n        var face = this.faces[f];\n        var vertexNormals = face.vertexNormals;\n        if (vertexNormals.length === 3) {\n          vertexNormals[0].copy(face.normal);\n          vertexNormals[1].copy(face.normal);\n          vertexNormals[2].copy(face.normal);\n        } else {\n          vertexNormals[0] = face.normal.clone();\n          vertexNormals[1] = face.normal.clone();\n          vertexNormals[2] = face.normal.clone();\n        }\n      }\n      if (this.faces.length > 0) {\n        this.normalsNeedUpdate = true;\n      }\n    }\n  }, {\n    key: \"computeMorphNormals\",\n    value: function computeMorphNormals() {\n      for (var f = 0, fl = this.faces.length; f < fl; f++) {\n        var face = this.faces[f];\n        if (!face.__originalFaceNormal) {\n          face.__originalFaceNormal = face.normal.clone();\n        } else {\n          face.__originalFaceNormal.copy(face.normal);\n        }\n        if (!face.__originalVertexNormals) face.__originalVertexNormals = [];\n        for (var i = 0, il = face.vertexNormals.length; i < il; i++) {\n          if (!face.__originalVertexNormals[i]) {\n            face.__originalVertexNormals[i] = face.vertexNormals[i].clone();\n          } else {\n            face.__originalVertexNormals[i].copy(face.vertexNormals[i]);\n          }\n        }\n      }\n      var tmpGeo = new Geometry();\n      tmpGeo.faces = this.faces;\n      for (var _i5 = 0, _il2 = this.morphTargets.length; _i5 < _il2; _i5++) {\n        if (!this.morphNormals[_i5]) {\n          this.morphNormals[_i5] = {};\n          this.morphNormals[_i5].faceNormals = [];\n          this.morphNormals[_i5].vertexNormals = [];\n          var dstNormalsFace = this.morphNormals[_i5].faceNormals;\n          var dstNormalsVertex = this.morphNormals[_i5].vertexNormals;\n          for (var _f3 = 0, _fl3 = this.faces.length; _f3 < _fl3; _f3++) {\n            var faceNormal = new Vector3();\n            var vertexNormals = {\n              a: new Vector3(),\n              b: new Vector3(),\n              c: new Vector3()\n            };\n            dstNormalsFace.push(faceNormal);\n            dstNormalsVertex.push(vertexNormals);\n          }\n        }\n        var morphNormals = this.morphNormals[_i5];\n        tmpGeo.vertices = this.morphTargets[_i5].vertices;\n        tmpGeo.computeFaceNormals();\n        tmpGeo.computeVertexNormals();\n        for (var _f4 = 0, _fl4 = this.faces.length; _f4 < _fl4; _f4++) {\n          var _face3 = this.faces[_f4];\n          var _faceNormal = morphNormals.faceNormals[_f4];\n          var _vertexNormals = morphNormals.vertexNormals[_f4];\n          _faceNormal.copy(_face3.normal);\n          _vertexNormals.a.copy(_face3.vertexNormals[0]);\n          _vertexNormals.b.copy(_face3.vertexNormals[1]);\n          _vertexNormals.c.copy(_face3.vertexNormals[2]);\n        }\n      }\n      for (var _f5 = 0, _fl5 = this.faces.length; _f5 < _fl5; _f5++) {\n        var _face4 = this.faces[_f5];\n        _face4.normal = _face4.__originalFaceNormal;\n        _face4.vertexNormals = _face4.__originalVertexNormals;\n      }\n    }\n  }, {\n    key: \"computeBoundingBox\",\n    value: function computeBoundingBox() {\n      if (this.boundingBox === null) {\n        this.boundingBox = new Box3();\n      }\n      this.boundingBox.setFromPoints(this.vertices);\n    }\n  }, {\n    key: \"computeBoundingSphere\",\n    value: function computeBoundingSphere() {\n      if (this.boundingSphere === null) {\n        this.boundingSphere = new Sphere();\n      }\n      this.boundingSphere.setFromPoints(this.vertices);\n    }\n  }, {\n    key: \"merge\",\n    value: function merge(geometry, matrix) {\n      var materialIndexOffset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n      if (!(geometry && geometry.isGeometry)) {\n        console.error(\"THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.\", geometry);\n        return;\n      }\n      var normalMatrix;\n      var vertexOffset = this.vertices.length,\n        vertices1 = this.vertices,\n        vertices2 = geometry.vertices,\n        faces1 = this.faces,\n        faces2 = geometry.faces,\n        colors1 = this.colors,\n        colors2 = geometry.colors;\n      if (matrix !== void 0) {\n        normalMatrix = new Matrix3().getNormalMatrix(matrix);\n      }\n      for (var i = 0, il = vertices2.length; i < il; i++) {\n        var vertex = vertices2[i];\n        var vertexCopy = vertex.clone();\n        if (matrix !== void 0) vertexCopy.applyMatrix4(matrix);\n        vertices1.push(vertexCopy);\n      }\n      for (var _i6 = 0, _il3 = colors2.length; _i6 < _il3; _i6++) {\n        colors1.push(colors2[_i6].clone());\n      }\n      for (var _i7 = 0, _il4 = faces2.length; _i7 < _il4; _i7++) {\n        var face = faces2[_i7];\n        var normal = void 0,\n          color = void 0;\n        var faceVertexNormals = face.vertexNormals,\n          faceVertexColors = face.vertexColors;\n        var faceCopy = new Face3(face.a + vertexOffset, face.b + vertexOffset, face.c + vertexOffset);\n        faceCopy.normal.copy(face.normal);\n        if (normalMatrix !== void 0) {\n          faceCopy.normal.applyMatrix3(normalMatrix).normalize();\n        }\n        for (var j = 0, jl = faceVertexNormals.length; j < jl; j++) {\n          normal = faceVertexNormals[j].clone();\n          if (normalMatrix !== void 0) {\n            normal.applyMatrix3(normalMatrix).normalize();\n          }\n          faceCopy.vertexNormals.push(normal);\n        }\n        faceCopy.color.copy(face.color);\n        for (var _j = 0, _jl = faceVertexColors.length; _j < _jl; _j++) {\n          color = faceVertexColors[_j];\n          faceCopy.vertexColors.push(color.clone());\n        }\n        faceCopy.materialIndex = face.materialIndex + materialIndexOffset;\n        faces1.push(faceCopy);\n      }\n      for (var _i8 = 0, _il5 = geometry.faceVertexUvs.length; _i8 < _il5; _i8++) {\n        var faceVertexUvs2 = geometry.faceVertexUvs[_i8];\n        if (this.faceVertexUvs[_i8] === void 0) this.faceVertexUvs[_i8] = [];\n        for (var _j2 = 0, _jl2 = faceVertexUvs2.length; _j2 < _jl2; _j2++) {\n          var uvs2 = faceVertexUvs2[_j2],\n            uvsCopy = [];\n          for (var k = 0, kl = uvs2.length; k < kl; k++) {\n            uvsCopy.push(uvs2[k].clone());\n          }\n          this.faceVertexUvs[_i8].push(uvsCopy);\n        }\n      }\n    }\n  }, {\n    key: \"mergeMesh\",\n    value: function mergeMesh(mesh) {\n      if (!(mesh && mesh.isMesh)) {\n        console.error(\"THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.\", mesh);\n        return;\n      }\n      if (mesh.matrixAutoUpdate) mesh.updateMatrix();\n      this.merge(mesh.geometry, mesh.matrix);\n    }\n    /*\n     * Checks for duplicate vertices with hashmap.\n     * Duplicated vertices are removed\n     * and faces' vertices are updated.\n     */\n  }, {\n    key: \"mergeVertices\",\n    value: function mergeVertices() {\n      var precisionPoints = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 4;\n      var verticesMap = {};\n      var unique = [],\n        changes = [];\n      var precision = Math.pow(10, precisionPoints);\n      for (var i = 0, il = this.vertices.length; i < il; i++) {\n        var v = this.vertices[i];\n        var key = \"\".concat(Math.round(v.x * precision), \"_\").concat(Math.round(v.y * precision), \"_\").concat(Math.round(v.z * precision));\n        if (verticesMap[key] === void 0) {\n          verticesMap[key] = i;\n          unique.push(this.vertices[i]);\n          changes[i] = unique.length - 1;\n        } else {\n          changes[i] = changes[verticesMap[key]];\n        }\n      }\n      var faceIndicesToRemove = [];\n      for (var _i9 = 0, _il6 = this.faces.length; _i9 < _il6; _i9++) {\n        var face = this.faces[_i9];\n        face.a = changes[face.a];\n        face.b = changes[face.b];\n        face.c = changes[face.c];\n        var indices = [face.a, face.b, face.c];\n        for (var n = 0; n < 3; n++) {\n          if (indices[n] === indices[(n + 1) % 3]) {\n            faceIndicesToRemove.push(_i9);\n            break;\n          }\n        }\n      }\n      for (var _i10 = faceIndicesToRemove.length - 1; _i10 >= 0; _i10--) {\n        var idx = faceIndicesToRemove[_i10];\n        this.faces.splice(idx, 1);\n        for (var j = 0, jl = this.faceVertexUvs.length; j < jl; j++) {\n          this.faceVertexUvs[j].splice(idx, 1);\n        }\n      }\n      var diff = this.vertices.length - unique.length;\n      this.vertices = unique;\n      return diff;\n    }\n  }, {\n    key: \"setFromPoints\",\n    value: function setFromPoints(points) {\n      this.vertices = [];\n      for (var i = 0, l = points.length; i < l; i++) {\n        var point = points[i];\n        this.vertices.push(new Vector3(point.x, point.y, point.z || 0));\n      }\n      return this;\n    }\n  }, {\n    key: \"sortFacesByMaterialIndex\",\n    value: function sortFacesByMaterialIndex() {\n      var faces = this.faces;\n      var length = faces.length;\n      for (var i = 0; i < length; i++) {\n        faces[i]._id = i;\n      }\n      function materialIndexSort(a, b) {\n        return a.materialIndex - b.materialIndex;\n      }\n      faces.sort(materialIndexSort);\n      var uvs1 = this.faceVertexUvs[0];\n      var uvs2 = this.faceVertexUvs[1];\n      var newUvs1, newUvs2;\n      if (uvs1 && uvs1.length === length) newUvs1 = [];\n      if (uvs2 && uvs2.length === length) newUvs2 = [];\n      for (var _i11 = 0; _i11 < length; _i11++) {\n        var id = faces[_i11]._id;\n        if (newUvs1) newUvs1.push(uvs1[id]);\n        if (newUvs2) newUvs2.push(uvs2[id]);\n      }\n      if (newUvs1) this.faceVertexUvs[0] = newUvs1;\n      if (newUvs2) this.faceVertexUvs[1] = newUvs2;\n    }\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      var data = {\n        metadata: {\n          version: 4.5,\n          type: \"Geometry\",\n          generator: \"Geometry.toJSON\"\n        }\n      };\n      data.uuid = this.uuid;\n      data.type = this.type;\n      if (this.name !== \"\") data.name = this.name;\n      if (this.parameters !== void 0) {\n        var parameters = this.parameters;\n        for (var key in parameters) {\n          if (parameters[key] !== void 0) data[key] = parameters[key];\n        }\n        return data;\n      }\n      var vertices = [];\n      for (var i = 0; i < this.vertices.length; i++) {\n        var vertex = this.vertices[i];\n        vertices.push(vertex.x, vertex.y, vertex.z);\n      }\n      var faces = [];\n      var normals = [];\n      var normalsHash = {};\n      var colors = [];\n      var colorsHash = {};\n      var uvs = [];\n      var uvsHash = {};\n      for (var _i12 = 0; _i12 < this.faces.length; _i12++) {\n        var face = this.faces[_i12];\n        var hasMaterial = true;\n        var hasFaceUv = false;\n        var hasFaceVertexUv = this.faceVertexUvs[0][_i12] !== void 0;\n        var hasFaceNormal = face.normal.length() > 0;\n        var hasFaceVertexNormal = face.vertexNormals.length > 0;\n        var hasFaceColor = face.color.r !== 1 || face.color.g !== 1 || face.color.b !== 1;\n        var hasFaceVertexColor = face.vertexColors.length > 0;\n        var faceType = 0;\n        faceType = setBit(faceType, 0, 0);\n        faceType = setBit(faceType, 1, hasMaterial);\n        faceType = setBit(faceType, 2, hasFaceUv);\n        faceType = setBit(faceType, 3, hasFaceVertexUv);\n        faceType = setBit(faceType, 4, hasFaceNormal);\n        faceType = setBit(faceType, 5, hasFaceVertexNormal);\n        faceType = setBit(faceType, 6, hasFaceColor);\n        faceType = setBit(faceType, 7, hasFaceVertexColor);\n        faces.push(faceType);\n        faces.push(face.a, face.b, face.c);\n        faces.push(face.materialIndex);\n        if (hasFaceVertexUv) {\n          var faceVertexUvs = this.faceVertexUvs[0][_i12];\n          faces.push(getUvIndex(faceVertexUvs[0]), getUvIndex(faceVertexUvs[1]), getUvIndex(faceVertexUvs[2]));\n        }\n        if (hasFaceNormal) {\n          faces.push(getNormalIndex(face.normal));\n        }\n        if (hasFaceVertexNormal) {\n          var vertexNormals = face.vertexNormals;\n          faces.push(getNormalIndex(vertexNormals[0]), getNormalIndex(vertexNormals[1]), getNormalIndex(vertexNormals[2]));\n        }\n        if (hasFaceColor) {\n          faces.push(getColorIndex(face.color));\n        }\n        if (hasFaceVertexColor) {\n          var vertexColors = face.vertexColors;\n          faces.push(getColorIndex(vertexColors[0]), getColorIndex(vertexColors[1]), getColorIndex(vertexColors[2]));\n        }\n      }\n      function setBit(value, position, enabled) {\n        return enabled ? value | 1 << position : value & ~(1 << position);\n      }\n      function getNormalIndex(normal) {\n        var hash = normal.x.toString() + normal.y.toString() + normal.z.toString();\n        if (normalsHash[hash] !== void 0) {\n          return normalsHash[hash];\n        }\n        normalsHash[hash] = normals.length / 3;\n        normals.push(normal.x, normal.y, normal.z);\n        return normalsHash[hash];\n      }\n      function getColorIndex(color) {\n        var hash = color.r.toString() + color.g.toString() + color.b.toString();\n        if (colorsHash[hash] !== void 0) {\n          return colorsHash[hash];\n        }\n        colorsHash[hash] = colors.length;\n        colors.push(color.getHex());\n        return colorsHash[hash];\n      }\n      function getUvIndex(uv) {\n        var hash = uv.x.toString() + uv.y.toString();\n        if (uvsHash[hash] !== void 0) {\n          return uvsHash[hash];\n        }\n        uvsHash[hash] = uvs.length / 2;\n        uvs.push(uv.x, uv.y);\n        return uvsHash[hash];\n      }\n      data.data = {};\n      data.data.vertices = vertices;\n      data.data.normals = normals;\n      if (colors.length > 0) data.data.colors = colors;\n      if (uvs.length > 0) data.data.uvs = [uvs];\n      data.data.faces = faces;\n      return data;\n    }\n  }, {\n    key: \"clone\",\n    value: function clone() {\n      return new Geometry().copy(this);\n    }\n  }, {\n    key: \"copy\",\n    value: function copy(source) {\n      this.vertices = [];\n      this.colors = [];\n      this.faces = [];\n      this.faceVertexUvs = [[]];\n      this.morphTargets = [];\n      this.morphNormals = [];\n      this.skinWeights = [];\n      this.skinIndices = [];\n      this.lineDistances = [];\n      this.boundingBox = null;\n      this.boundingSphere = null;\n      this.name = source.name;\n      var vertices = source.vertices;\n      for (var i = 0, il = vertices.length; i < il; i++) {\n        this.vertices.push(vertices[i].clone());\n      }\n      var colors = source.colors;\n      for (var _i13 = 0, _il7 = colors.length; _i13 < _il7; _i13++) {\n        this.colors.push(colors[_i13].clone());\n      }\n      var faces = source.faces;\n      for (var _i14 = 0, _il8 = faces.length; _i14 < _il8; _i14++) {\n        this.faces.push(faces[_i14].clone());\n      }\n      for (var _i15 = 0, _il9 = source.faceVertexUvs.length; _i15 < _il9; _i15++) {\n        var faceVertexUvs = source.faceVertexUvs[_i15];\n        if (this.faceVertexUvs[_i15] === void 0) {\n          this.faceVertexUvs[_i15] = [];\n        }\n        for (var j = 0, jl = faceVertexUvs.length; j < jl; j++) {\n          var uvs = faceVertexUvs[j],\n            uvsCopy = [];\n          for (var k = 0, kl = uvs.length; k < kl; k++) {\n            var uv = uvs[k];\n            uvsCopy.push(uv.clone());\n          }\n          this.faceVertexUvs[_i15].push(uvsCopy);\n        }\n      }\n      var morphTargets = source.morphTargets;\n      for (var _i16 = 0, _il10 = morphTargets.length; _i16 < _il10; _i16++) {\n        var morphTarget = {};\n        morphTarget.name = morphTargets[_i16].name;\n        if (morphTargets[_i16].vertices !== void 0) {\n          morphTarget.vertices = [];\n          for (var _j3 = 0, _jl3 = morphTargets[_i16].vertices.length; _j3 < _jl3; _j3++) {\n            morphTarget.vertices.push(morphTargets[_i16].vertices[_j3].clone());\n          }\n        }\n        if (morphTargets[_i16].normals !== void 0) {\n          morphTarget.normals = [];\n          for (var _j4 = 0, _jl4 = morphTargets[_i16].normals.length; _j4 < _jl4; _j4++) {\n            morphTarget.normals.push(morphTargets[_i16].normals[_j4].clone());\n          }\n        }\n        this.morphTargets.push(morphTarget);\n      }\n      var morphNormals = source.morphNormals;\n      for (var _i17 = 0, _il11 = morphNormals.length; _i17 < _il11; _i17++) {\n        var morphNormal = {};\n        if (morphNormals[_i17].vertexNormals !== void 0) {\n          morphNormal.vertexNormals = [];\n          for (var _j5 = 0, _jl5 = morphNormals[_i17].vertexNormals.length; _j5 < _jl5; _j5++) {\n            var srcVertexNormal = morphNormals[_i17].vertexNormals[_j5];\n            var destVertexNormal = {};\n            destVertexNormal.a = srcVertexNormal.a.clone();\n            destVertexNormal.b = srcVertexNormal.b.clone();\n            destVertexNormal.c = srcVertexNormal.c.clone();\n            morphNormal.vertexNormals.push(destVertexNormal);\n          }\n        }\n        if (morphNormals[_i17].faceNormals !== void 0) {\n          morphNormal.faceNormals = [];\n          for (var _j6 = 0, _jl6 = morphNormals[_i17].faceNormals.length; _j6 < _jl6; _j6++) {\n            morphNormal.faceNormals.push(morphNormals[_i17].faceNormals[_j6].clone());\n          }\n        }\n        this.morphNormals.push(morphNormal);\n      }\n      var skinWeights = source.skinWeights;\n      for (var _i18 = 0, _il12 = skinWeights.length; _i18 < _il12; _i18++) {\n        this.skinWeights.push(skinWeights[_i18].clone());\n      }\n      var skinIndices = source.skinIndices;\n      for (var _i19 = 0, _il13 = skinIndices.length; _i19 < _il13; _i19++) {\n        this.skinIndices.push(skinIndices[_i19].clone());\n      }\n      var lineDistances = source.lineDistances;\n      for (var _i20 = 0, _il14 = lineDistances.length; _i20 < _il14; _i20++) {\n        this.lineDistances.push(lineDistances[_i20]);\n      }\n      var boundingBox = source.boundingBox;\n      if (boundingBox !== null) {\n        this.boundingBox = boundingBox.clone();\n      }\n      var boundingSphere = source.boundingSphere;\n      if (boundingSphere !== null) {\n        this.boundingSphere = boundingSphere.clone();\n      }\n      this.elementsNeedUpdate = source.elementsNeedUpdate;\n      this.verticesNeedUpdate = source.verticesNeedUpdate;\n      this.uvsNeedUpdate = source.uvsNeedUpdate;\n      this.normalsNeedUpdate = source.normalsNeedUpdate;\n      this.colorsNeedUpdate = source.colorsNeedUpdate;\n      this.lineDistancesNeedUpdate = source.lineDistancesNeedUpdate;\n      this.groupsNeedUpdate = source.groupsNeedUpdate;\n      return this;\n    }\n  }, {\n    key: \"toBufferGeometry\",\n    value: function toBufferGeometry() {\n      var geometry = new DirectGeometry().fromGeometry(this);\n      var buffergeometry = new BufferGeometry();\n      var positions = new Float32Array(geometry.vertices.length * 3);\n      buffergeometry.setAttribute(\"position\", new BufferAttribute(positions, 3).copyVector3sArray(geometry.vertices));\n      if (geometry.normals.length > 0) {\n        var normals = new Float32Array(geometry.normals.length * 3);\n        buffergeometry.setAttribute(\"normal\", new BufferAttribute(normals, 3).copyVector3sArray(geometry.normals));\n      }\n      if (geometry.colors.length > 0) {\n        var colors = new Float32Array(geometry.colors.length * 3);\n        buffergeometry.setAttribute(\"color\", new BufferAttribute(colors, 3).copyColorsArray(geometry.colors));\n      }\n      if (geometry.uvs.length > 0) {\n        var uvs = new Float32Array(geometry.uvs.length * 2);\n        buffergeometry.setAttribute(\"uv\", new BufferAttribute(uvs, 2).copyVector2sArray(geometry.uvs));\n      }\n      if (geometry.uvs2.length > 0) {\n        var uvs2 = new Float32Array(geometry.uvs2.length * 2);\n        buffergeometry.setAttribute(\"uv2\", new BufferAttribute(uvs2, 2).copyVector2sArray(geometry.uvs2));\n      }\n      buffergeometry.groups = geometry.groups;\n      for (var name in geometry.morphTargets) {\n        var array = [];\n        var morphTargets = geometry.morphTargets[name];\n        for (var i = 0, l = morphTargets.length; i < l; i++) {\n          var morphTarget = morphTargets[i];\n          var attribute = new Float32BufferAttribute(morphTarget.data.length * 3, 3);\n          attribute.name = morphTarget.name;\n          array.push(attribute.copyVector3sArray(morphTarget.data));\n        }\n        buffergeometry.morphAttributes[name] = array;\n      }\n      if (geometry.skinIndices.length > 0) {\n        var skinIndices = new Float32BufferAttribute(geometry.skinIndices.length * 4, 4);\n        buffergeometry.setAttribute(\"skinIndex\", skinIndices.copyVector4sArray(geometry.skinIndices));\n      }\n      if (geometry.skinWeights.length > 0) {\n        var skinWeights = new Float32BufferAttribute(geometry.skinWeights.length * 4, 4);\n        buffergeometry.setAttribute(\"skinWeight\", skinWeights.copyVector4sArray(geometry.skinWeights));\n      }\n      if (geometry.boundingSphere !== null) {\n        buffergeometry.boundingSphere = geometry.boundingSphere.clone();\n      }\n      if (geometry.boundingBox !== null) {\n        buffergeometry.boundingBox = geometry.boundingBox.clone();\n      }\n      return buffergeometry;\n    }\n  }, {\n    key: \"computeTangents\",\n    value: function computeTangents() {\n      console.error(\"THREE.Geometry: .computeTangents() has been removed.\");\n    }\n  }, {\n    key: \"computeLineDistances\",\n    value: function computeLineDistances() {\n      console.error(\"THREE.Geometry: .computeLineDistances() has been removed. Use THREE.Line.computeLineDistances() instead.\");\n    }\n  }, {\n    key: \"applyMatrix\",\n    value: function applyMatrix(matrix) {\n      console.warn(\"THREE.Geometry: .applyMatrix() has been renamed to .applyMatrix4().\");\n      return this.applyMatrix4(matrix);\n    }\n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      this.dispatchEvent({\n        type: \"dispose\"\n      });\n    }\n  }], [{\n    key: \"createBufferGeometryFromObject\",\n    value: function createBufferGeometryFromObject(object) {\n      var buffergeometry = new BufferGeometry();\n      var geometry = object.geometry;\n      if (object.isPoints || object.isLine) {\n        var positions = new Float32BufferAttribute(geometry.vertices.length * 3, 3);\n        var colors = new Float32BufferAttribute(geometry.colors.length * 3, 3);\n        buffergeometry.setAttribute(\"position\", positions.copyVector3sArray(geometry.vertices));\n        buffergeometry.setAttribute(\"color\", colors.copyColorsArray(geometry.colors));\n        if (geometry.lineDistances && geometry.lineDistances.length === geometry.vertices.length) {\n          var lineDistances = new Float32BufferAttribute(geometry.lineDistances.length, 1);\n          buffergeometry.setAttribute(\"lineDistance\", lineDistances.copyArray(geometry.lineDistances));\n        }\n        if (geometry.boundingSphere !== null) {\n          buffergeometry.boundingSphere = geometry.boundingSphere.clone();\n        }\n        if (geometry.boundingBox !== null) {\n          buffergeometry.boundingBox = geometry.boundingBox.clone();\n        }\n      } else if (object.isMesh) {\n        buffergeometry = geometry.toBufferGeometry();\n      }\n      return buffergeometry;\n    }\n  }]);\n  return Geometry;\n}(EventDispatcher);\nvar DirectGeometry = /*#__PURE__*/function () {\n  function DirectGeometry() {\n    _classCallCheck(this, DirectGeometry);\n    this.vertices = [];\n    this.normals = [];\n    this.colors = [];\n    this.uvs = [];\n    this.uvs2 = [];\n    this.groups = [];\n    this.morphTargets = {};\n    this.skinWeights = [];\n    this.skinIndices = [];\n    this.boundingBox = null;\n    this.boundingSphere = null;\n    this.verticesNeedUpdate = false;\n    this.normalsNeedUpdate = false;\n    this.colorsNeedUpdate = false;\n    this.uvsNeedUpdate = false;\n    this.groupsNeedUpdate = false;\n  }\n  _createClass(DirectGeometry, [{\n    key: \"computeGroups\",\n    value: function computeGroups(geometry) {\n      var groups = [];\n      var group, i;\n      var materialIndex = void 0;\n      var faces = geometry.faces;\n      for (i = 0; i < faces.length; i++) {\n        var face = faces[i];\n        if (face.materialIndex !== materialIndex) {\n          materialIndex = face.materialIndex;\n          if (group !== void 0) {\n            group.count = i * 3 - group.start;\n            groups.push(group);\n          }\n          group = {\n            start: i * 3,\n            materialIndex: materialIndex\n          };\n        }\n      }\n      if (group !== void 0) {\n        group.count = i * 3 - group.start;\n        groups.push(group);\n      }\n      this.groups = groups;\n    }\n  }, {\n    key: \"fromGeometry\",\n    value: function fromGeometry(geometry) {\n      var faces = geometry.faces;\n      var vertices = geometry.vertices;\n      var faceVertexUvs = geometry.faceVertexUvs;\n      var hasFaceVertexUv = faceVertexUvs[0] && faceVertexUvs[0].length > 0;\n      var hasFaceVertexUv2 = faceVertexUvs[1] && faceVertexUvs[1].length > 0;\n      var morphTargets = geometry.morphTargets;\n      var morphTargetsLength = morphTargets.length;\n      var morphTargetsPosition;\n      if (morphTargetsLength > 0) {\n        morphTargetsPosition = [];\n        for (var i = 0; i < morphTargetsLength; i++) {\n          morphTargetsPosition[i] = {\n            name: morphTargets[i].name,\n            data: []\n          };\n        }\n        this.morphTargets.position = morphTargetsPosition;\n      }\n      var morphNormals = geometry.morphNormals;\n      var morphNormalsLength = morphNormals.length;\n      var morphTargetsNormal;\n      if (morphNormalsLength > 0) {\n        morphTargetsNormal = [];\n        for (var _i21 = 0; _i21 < morphNormalsLength; _i21++) {\n          morphTargetsNormal[_i21] = {\n            name: morphNormals[_i21].name,\n            data: []\n          };\n        }\n        this.morphTargets.normal = morphTargetsNormal;\n      }\n      var skinIndices = geometry.skinIndices;\n      var skinWeights = geometry.skinWeights;\n      var hasSkinIndices = skinIndices.length === vertices.length;\n      var hasSkinWeights = skinWeights.length === vertices.length;\n      if (vertices.length > 0 && faces.length === 0) {\n        console.error(\"THREE.DirectGeometry: Faceless geometries are not supported.\");\n      }\n      for (var _i22 = 0; _i22 < faces.length; _i22++) {\n        var face = faces[_i22];\n        this.vertices.push(vertices[face.a], vertices[face.b], vertices[face.c]);\n        var vertexNormals = face.vertexNormals;\n        if (vertexNormals.length === 3) {\n          this.normals.push(vertexNormals[0], vertexNormals[1], vertexNormals[2]);\n        } else {\n          var normal = face.normal;\n          this.normals.push(normal, normal, normal);\n        }\n        var vertexColors = face.vertexColors;\n        if (vertexColors.length === 3) {\n          this.colors.push(vertexColors[0], vertexColors[1], vertexColors[2]);\n        } else {\n          var color = face.color;\n          this.colors.push(color, color, color);\n        }\n        if (hasFaceVertexUv === true) {\n          var vertexUvs = faceVertexUvs[0][_i22];\n          if (vertexUvs !== void 0) {\n            this.uvs.push(vertexUvs[0], vertexUvs[1], vertexUvs[2]);\n          } else {\n            console.warn(\"THREE.DirectGeometry.fromGeometry(): Undefined vertexUv \", _i22);\n            this.uvs.push(new Vector2(), new Vector2(), new Vector2());\n          }\n        }\n        if (hasFaceVertexUv2 === true) {\n          var _vertexUvs = faceVertexUvs[1][_i22];\n          if (_vertexUvs !== void 0) {\n            this.uvs2.push(_vertexUvs[0], _vertexUvs[1], _vertexUvs[2]);\n          } else {\n            console.warn(\"THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 \", _i22);\n            this.uvs2.push(new Vector2(), new Vector2(), new Vector2());\n          }\n        }\n        for (var j = 0; j < morphTargetsLength; j++) {\n          var morphTarget = morphTargets[j].vertices;\n          morphTargetsPosition[j].data.push(morphTarget[face.a], morphTarget[face.b], morphTarget[face.c]);\n        }\n        for (var _j7 = 0; _j7 < morphNormalsLength; _j7++) {\n          var morphNormal = morphNormals[_j7].vertexNormals[_i22];\n          morphTargetsNormal[_j7].data.push(morphNormal.a, morphNormal.b, morphNormal.c);\n        }\n        if (hasSkinIndices) {\n          this.skinIndices.push(skinIndices[face.a], skinIndices[face.b], skinIndices[face.c]);\n        }\n        if (hasSkinWeights) {\n          this.skinWeights.push(skinWeights[face.a], skinWeights[face.b], skinWeights[face.c]);\n        }\n      }\n      this.computeGroups(geometry);\n      this.verticesNeedUpdate = geometry.verticesNeedUpdate;\n      this.normalsNeedUpdate = geometry.normalsNeedUpdate;\n      this.colorsNeedUpdate = geometry.colorsNeedUpdate;\n      this.uvsNeedUpdate = geometry.uvsNeedUpdate;\n      this.groupsNeedUpdate = geometry.groupsNeedUpdate;\n      if (geometry.boundingSphere !== null) {\n        this.boundingSphere = geometry.boundingSphere.clone();\n      }\n      if (geometry.boundingBox !== null) {\n        this.boundingBox = geometry.boundingBox.clone();\n      }\n      return this;\n    }\n  }]);\n  return DirectGeometry;\n}();\nvar Face3 = /*#__PURE__*/function () {\n  function Face3(a, b, c, normal, color) {\n    var materialIndex = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;\n    _classCallCheck(this, Face3);\n    this.a = a;\n    this.b = b;\n    this.c = c;\n    this.normal = normal && normal.isVector3 ? normal : new Vector3();\n    this.vertexNormals = Array.isArray(normal) ? normal : [];\n    this.color = color && color.isColor ? color : new Color();\n    this.vertexColors = Array.isArray(color) ? color : [];\n    this.materialIndex = materialIndex;\n  }\n  _createClass(Face3, [{\n    key: \"clone\",\n    value: function clone() {\n      return new this.constructor().copy(this);\n    }\n  }, {\n    key: \"copy\",\n    value: function copy(source) {\n      this.a = source.a;\n      this.b = source.b;\n      this.c = source.c;\n      this.normal.copy(source.normal);\n      this.color.copy(source.color);\n      this.materialIndex = source.materialIndex;\n      for (var i = 0, il = source.vertexNormals.length; i < il; i++) {\n        this.vertexNormals[i] = source.vertexNormals[i].clone();\n      }\n      for (var _i23 = 0, _il15 = source.vertexColors.length; _i23 < _il15; _i23++) {\n        this.vertexColors[_i23] = source.vertexColors[_i23].clone();\n      }\n      return this;\n    }\n  }]);\n  return Face3;\n}();\nexport { Face3, Geometry };","map":{"version":3,"names":["_m1","Matrix4","_obj","Object3D","_offset","Vector3","Geometry","_EventDispatcher","_inherits","_super","_createSuper","_this","_classCallCheck","call","isGeometry","uuid","MathUtils","generateUUID","name","type","vertices","colors","faces","faceVertexUvs","morphTargets","morphNormals","skinWeights","skinIndices","lineDistances","boundingBox","boundingSphere","elementsNeedUpdate","verticesNeedUpdate","uvsNeedUpdate","normalsNeedUpdate","colorsNeedUpdate","lineDistancesNeedUpdate","groupsNeedUpdate","_createClass","key","value","applyMatrix4","matrix","normalMatrix","Matrix3","getNormalMatrix","i","il","length","vertex","face","normal","applyMatrix3","normalize","j","jl","vertexNormals","computeBoundingBox","computeBoundingSphere","rotateX","angle","makeRotationX","rotateY","makeRotationY","rotateZ","makeRotationZ","translate","x","y","z","makeTranslation","scale","makeScale","lookAt","vector","updateMatrix","fromBufferGeometry","geometry","scope","index","attributes","position","console","error","color","uv","uv2","count","push","fromBufferAttribute","Color","addFace","a","b","c","materialIndex","vertexColors","clone","Face3","Vector2","groups","group","start","getX","computeFaceNormals","center","getCenter","negate","radius","s","set","cb","ab","f","fl","vA","vB","vC","subVectors","cross","copy","computeVertexNormals","areaWeighted","arguments","undefined","Array","v","vl","add","computeFlatVertexNormals","computeMorphNormals","__originalFaceNormal","__originalVertexNormals","tmpGeo","faceNormals","dstNormalsFace","dstNormalsVertex","faceNormal","Box3","setFromPoints","Sphere","merge","materialIndexOffset","vertexOffset","vertices1","vertices2","faces1","faces2","colors1","colors2","vertexCopy","faceVertexNormals","faceVertexColors","faceCopy","faceVertexUvs2","uvs2","uvsCopy","k","kl","mergeMesh","mesh","isMesh","matrixAutoUpdate","mergeVertices","precisionPoints","verticesMap","unique","changes","precision","Math","pow","concat","round","faceIndicesToRemove","indices","n","idx","splice","diff","points","l","point","sortFacesByMaterialIndex","_id","materialIndexSort","sort","uvs1","newUvs1","newUvs2","id","toJSON","data","metadata","version","generator","parameters","normals","normalsHash","colorsHash","uvs","uvsHash","hasMaterial","hasFaceUv","hasFaceVertexUv","hasFaceNormal","hasFaceVertexNormal","hasFaceColor","r","g","hasFaceVertexColor","faceType","setBit","getUvIndex","getNormalIndex","getColorIndex","enabled","hash","toString","getHex","source","morphTarget","morphNormal","srcVertexNormal","destVertexNormal","toBufferGeometry","DirectGeometry","fromGeometry","buffergeometry","BufferGeometry","positions","Float32Array","setAttribute","BufferAttribute","copyVector3sArray","copyColorsArray","copyVector2sArray","array","attribute","Float32BufferAttribute","morphAttributes","copyVector4sArray","computeTangents","computeLineDistances","applyMatrix","warn","dispose","dispatchEvent","createBufferGeometryFromObject","object","isPoints","isLine","copyArray","EventDispatcher","computeGroups","hasFaceVertexUv2","morphTargetsLength","morphTargetsPosition","morphNormalsLength","morphTargetsNormal","hasSkinIndices","hasSkinWeights","vertexUvs","isVector3","isArray","isColor","constructor"],"sources":["C:\\Users\\Nayyu\\Desktop\\skibidai-public-build\\node_modules\\src\\deprecated\\Geometry.js"],"sourcesContent":["import {\n  Box3,\n  BufferAttribute,\n  BufferGeometry,\n  Color,\n  EventDispatcher,\n  Float32BufferAttribute,\n  Matrix3,\n  Matrix4,\n  MathUtils,\n  Object3D,\n  Sphere,\n  Vector2,\n  Vector3,\n} from 'three'\n\nconst _m1 = new Matrix4()\nconst _obj = new Object3D()\nconst _offset = new Vector3()\n\nclass Geometry extends EventDispatcher {\n  static createBufferGeometryFromObject(object) {\n    let buffergeometry = new BufferGeometry()\n\n    const geometry = object.geometry\n\n    if (object.isPoints || object.isLine) {\n      const positions = new Float32BufferAttribute(geometry.vertices.length * 3, 3)\n      const colors = new Float32BufferAttribute(geometry.colors.length * 3, 3)\n\n      buffergeometry.setAttribute('position', positions.copyVector3sArray(geometry.vertices))\n      buffergeometry.setAttribute('color', colors.copyColorsArray(geometry.colors))\n\n      if (geometry.lineDistances && geometry.lineDistances.length === geometry.vertices.length) {\n        const lineDistances = new Float32BufferAttribute(geometry.lineDistances.length, 1)\n\n        buffergeometry.setAttribute('lineDistance', lineDistances.copyArray(geometry.lineDistances))\n      }\n\n      if (geometry.boundingSphere !== null) {\n        buffergeometry.boundingSphere = geometry.boundingSphere.clone()\n      }\n\n      if (geometry.boundingBox !== null) {\n        buffergeometry.boundingBox = geometry.boundingBox.clone()\n      }\n    } else if (object.isMesh) {\n      buffergeometry = geometry.toBufferGeometry()\n    }\n\n    return buffergeometry\n  }\n\n  constructor() {\n    super()\n    this.isGeometry = true\n    this.uuid = MathUtils.generateUUID()\n\n    this.name = ''\n    this.type = 'Geometry'\n\n    this.vertices = []\n    this.colors = []\n    this.faces = []\n    this.faceVertexUvs = [[]]\n\n    this.morphTargets = []\n    this.morphNormals = []\n\n    this.skinWeights = []\n    this.skinIndices = []\n\n    this.lineDistances = []\n\n    this.boundingBox = null\n    this.boundingSphere = null\n\n    // update flags\n\n    this.elementsNeedUpdate = false\n    this.verticesNeedUpdate = false\n    this.uvsNeedUpdate = false\n    this.normalsNeedUpdate = false\n    this.colorsNeedUpdate = false\n    this.lineDistancesNeedUpdate = false\n    this.groupsNeedUpdate = false\n  }\n\n  applyMatrix4(matrix) {\n    const normalMatrix = new Matrix3().getNormalMatrix(matrix)\n\n    for (let i = 0, il = this.vertices.length; i < il; i++) {\n      const vertex = this.vertices[i]\n      vertex.applyMatrix4(matrix)\n    }\n\n    for (let i = 0, il = this.faces.length; i < il; i++) {\n      const face = this.faces[i]\n      face.normal.applyMatrix3(normalMatrix).normalize()\n\n      for (let j = 0, jl = face.vertexNormals.length; j < jl; j++) {\n        face.vertexNormals[j].applyMatrix3(normalMatrix).normalize()\n      }\n    }\n\n    if (this.boundingBox !== null) {\n      this.computeBoundingBox()\n    }\n\n    if (this.boundingSphere !== null) {\n      this.computeBoundingSphere()\n    }\n\n    this.verticesNeedUpdate = true\n    this.normalsNeedUpdate = true\n\n    return this\n  }\n\n  rotateX(angle) {\n    // rotate geometry around world x-axis\n\n    _m1.makeRotationX(angle)\n\n    this.applyMatrix4(_m1)\n\n    return this\n  }\n\n  rotateY(angle) {\n    // rotate geometry around world y-axis\n\n    _m1.makeRotationY(angle)\n\n    this.applyMatrix4(_m1)\n\n    return this\n  }\n\n  rotateZ(angle) {\n    // rotate geometry around world z-axis\n\n    _m1.makeRotationZ(angle)\n\n    this.applyMatrix4(_m1)\n\n    return this\n  }\n\n  translate(x, y, z) {\n    // translate geometry\n\n    _m1.makeTranslation(x, y, z)\n\n    this.applyMatrix4(_m1)\n\n    return this\n  }\n\n  scale(x, y, z) {\n    // scale geometry\n\n    _m1.makeScale(x, y, z)\n\n    this.applyMatrix4(_m1)\n\n    return this\n  }\n\n  lookAt(vector) {\n    _obj.lookAt(vector)\n\n    _obj.updateMatrix()\n\n    this.applyMatrix4(_obj.matrix)\n\n    return this\n  }\n\n  fromBufferGeometry(geometry) {\n    const scope = this\n\n    const index = geometry.index !== null ? geometry.index : undefined\n    const attributes = geometry.attributes\n\n    if (attributes.position === undefined) {\n      console.error('THREE.Geometry.fromBufferGeometry(): Position attribute required for conversion.')\n      return this\n    }\n\n    const position = attributes.position\n    const normal = attributes.normal\n    const color = attributes.color\n    const uv = attributes.uv\n    const uv2 = attributes.uv2\n\n    if (uv2 !== undefined) this.faceVertexUvs[1] = []\n\n    for (let i = 0; i < position.count; i++) {\n      scope.vertices.push(new Vector3().fromBufferAttribute(position, i))\n\n      if (color !== undefined) {\n        scope.colors.push(new Color().fromBufferAttribute(color, i))\n      }\n    }\n\n    function addFace(a, b, c, materialIndex) {\n      const vertexColors =\n        color === undefined ? [] : [scope.colors[a].clone(), scope.colors[b].clone(), scope.colors[c].clone()]\n\n      const vertexNormals =\n        normal === undefined\n          ? []\n          : [\n              new Vector3().fromBufferAttribute(normal, a),\n              new Vector3().fromBufferAttribute(normal, b),\n              new Vector3().fromBufferAttribute(normal, c),\n            ]\n\n      const face = new Face3(a, b, c, vertexNormals, vertexColors, materialIndex)\n\n      scope.faces.push(face)\n\n      if (uv !== undefined) {\n        scope.faceVertexUvs[0].push([\n          new Vector2().fromBufferAttribute(uv, a),\n          new Vector2().fromBufferAttribute(uv, b),\n          new Vector2().fromBufferAttribute(uv, c),\n        ])\n      }\n\n      if (uv2 !== undefined) {\n        scope.faceVertexUvs[1].push([\n          new Vector2().fromBufferAttribute(uv2, a),\n          new Vector2().fromBufferAttribute(uv2, b),\n          new Vector2().fromBufferAttribute(uv2, c),\n        ])\n      }\n    }\n\n    const groups = geometry.groups\n\n    if (groups.length > 0) {\n      for (let i = 0; i < groups.length; i++) {\n        const group = groups[i]\n\n        const start = group.start\n        const count = group.count\n\n        for (let j = start, jl = start + count; j < jl; j += 3) {\n          if (index !== undefined) {\n            addFace(index.getX(j), index.getX(j + 1), index.getX(j + 2), group.materialIndex)\n          } else {\n            addFace(j, j + 1, j + 2, group.materialIndex)\n          }\n        }\n      }\n    } else {\n      if (index !== undefined) {\n        for (let i = 0; i < index.count; i += 3) {\n          addFace(index.getX(i), index.getX(i + 1), index.getX(i + 2))\n        }\n      } else {\n        for (let i = 0; i < position.count; i += 3) {\n          addFace(i, i + 1, i + 2)\n        }\n      }\n    }\n\n    this.computeFaceNormals()\n\n    if (geometry.boundingBox !== null) {\n      this.boundingBox = geometry.boundingBox.clone()\n    }\n\n    if (geometry.boundingSphere !== null) {\n      this.boundingSphere = geometry.boundingSphere.clone()\n    }\n\n    return this\n  }\n\n  center() {\n    this.computeBoundingBox()\n\n    this.boundingBox.getCenter(_offset).negate()\n\n    this.translate(_offset.x, _offset.y, _offset.z)\n\n    return this\n  }\n\n  normalize() {\n    this.computeBoundingSphere()\n\n    const center = this.boundingSphere.center\n    const radius = this.boundingSphere.radius\n\n    const s = radius === 0 ? 1 : 1.0 / radius\n\n    const matrix = new Matrix4()\n    matrix.set(s, 0, 0, -s * center.x, 0, s, 0, -s * center.y, 0, 0, s, -s * center.z, 0, 0, 0, 1)\n\n    this.applyMatrix4(matrix)\n\n    return this\n  }\n\n  computeFaceNormals() {\n    const cb = new Vector3(),\n      ab = new Vector3()\n\n    for (let f = 0, fl = this.faces.length; f < fl; f++) {\n      const face = this.faces[f]\n\n      const vA = this.vertices[face.a]\n      const vB = this.vertices[face.b]\n      const vC = this.vertices[face.c]\n\n      cb.subVectors(vC, vB)\n      ab.subVectors(vA, vB)\n      cb.cross(ab)\n\n      cb.normalize()\n\n      face.normal.copy(cb)\n    }\n  }\n\n  computeVertexNormals(areaWeighted = true) {\n    const vertices = new Array(this.vertices.length)\n\n    for (let v = 0, vl = this.vertices.length; v < vl; v++) {\n      vertices[v] = new Vector3()\n    }\n\n    if (areaWeighted) {\n      // vertex normals weighted by triangle areas\n      // http://www.iquilezles.org/www/articles/normals/normals.htm\n\n      const cb = new Vector3(),\n        ab = new Vector3()\n\n      for (let f = 0, fl = this.faces.length; f < fl; f++) {\n        const face = this.faces[f]\n\n        const vA = this.vertices[face.a]\n        const vB = this.vertices[face.b]\n        const vC = this.vertices[face.c]\n\n        cb.subVectors(vC, vB)\n        ab.subVectors(vA, vB)\n        cb.cross(ab)\n\n        vertices[face.a].add(cb)\n        vertices[face.b].add(cb)\n        vertices[face.c].add(cb)\n      }\n    } else {\n      this.computeFaceNormals()\n\n      for (let f = 0, fl = this.faces.length; f < fl; f++) {\n        const face = this.faces[f]\n\n        vertices[face.a].add(face.normal)\n        vertices[face.b].add(face.normal)\n        vertices[face.c].add(face.normal)\n      }\n    }\n\n    for (let v = 0, vl = this.vertices.length; v < vl; v++) {\n      vertices[v].normalize()\n    }\n\n    for (let f = 0, fl = this.faces.length; f < fl; f++) {\n      const face = this.faces[f]\n\n      const vertexNormals = face.vertexNormals\n\n      if (vertexNormals.length === 3) {\n        vertexNormals[0].copy(vertices[face.a])\n        vertexNormals[1].copy(vertices[face.b])\n        vertexNormals[2].copy(vertices[face.c])\n      } else {\n        vertexNormals[0] = vertices[face.a].clone()\n        vertexNormals[1] = vertices[face.b].clone()\n        vertexNormals[2] = vertices[face.c].clone()\n      }\n    }\n\n    if (this.faces.length > 0) {\n      this.normalsNeedUpdate = true\n    }\n  }\n\n  computeFlatVertexNormals() {\n    this.computeFaceNormals()\n\n    for (let f = 0, fl = this.faces.length; f < fl; f++) {\n      const face = this.faces[f]\n\n      const vertexNormals = face.vertexNormals\n\n      if (vertexNormals.length === 3) {\n        vertexNormals[0].copy(face.normal)\n        vertexNormals[1].copy(face.normal)\n        vertexNormals[2].copy(face.normal)\n      } else {\n        vertexNormals[0] = face.normal.clone()\n        vertexNormals[1] = face.normal.clone()\n        vertexNormals[2] = face.normal.clone()\n      }\n    }\n\n    if (this.faces.length > 0) {\n      this.normalsNeedUpdate = true\n    }\n  }\n\n  computeMorphNormals() {\n    // save original normals\n    // - create temp variables on first access\n    //   otherwise just copy (for faster repeated calls)\n\n    for (let f = 0, fl = this.faces.length; f < fl; f++) {\n      const face = this.faces[f]\n\n      if (!face.__originalFaceNormal) {\n        face.__originalFaceNormal = face.normal.clone()\n      } else {\n        face.__originalFaceNormal.copy(face.normal)\n      }\n\n      if (!face.__originalVertexNormals) face.__originalVertexNormals = []\n\n      for (let i = 0, il = face.vertexNormals.length; i < il; i++) {\n        if (!face.__originalVertexNormals[i]) {\n          face.__originalVertexNormals[i] = face.vertexNormals[i].clone()\n        } else {\n          face.__originalVertexNormals[i].copy(face.vertexNormals[i])\n        }\n      }\n    }\n\n    // use temp geometry to compute face and vertex normals for each morph\n\n    const tmpGeo = new Geometry()\n    tmpGeo.faces = this.faces\n\n    for (let i = 0, il = this.morphTargets.length; i < il; i++) {\n      // create on first access\n\n      if (!this.morphNormals[i]) {\n        this.morphNormals[i] = {}\n        this.morphNormals[i].faceNormals = []\n        this.morphNormals[i].vertexNormals = []\n\n        const dstNormalsFace = this.morphNormals[i].faceNormals\n        const dstNormalsVertex = this.morphNormals[i].vertexNormals\n\n        for (let f = 0, fl = this.faces.length; f < fl; f++) {\n          const faceNormal = new Vector3()\n          const vertexNormals = {\n            a: new Vector3(),\n            b: new Vector3(),\n            c: new Vector3(),\n          }\n\n          dstNormalsFace.push(faceNormal)\n          dstNormalsVertex.push(vertexNormals)\n        }\n      }\n\n      const morphNormals = this.morphNormals[i]\n\n      // set vertices to morph target\n\n      tmpGeo.vertices = this.morphTargets[i].vertices\n\n      // compute morph normals\n\n      tmpGeo.computeFaceNormals()\n      tmpGeo.computeVertexNormals()\n\n      // store morph normals\n\n      for (let f = 0, fl = this.faces.length; f < fl; f++) {\n        const face = this.faces[f]\n\n        const faceNormal = morphNormals.faceNormals[f]\n        const vertexNormals = morphNormals.vertexNormals[f]\n\n        faceNormal.copy(face.normal)\n\n        vertexNormals.a.copy(face.vertexNormals[0])\n        vertexNormals.b.copy(face.vertexNormals[1])\n        vertexNormals.c.copy(face.vertexNormals[2])\n      }\n    }\n\n    // restore original normals\n\n    for (let f = 0, fl = this.faces.length; f < fl; f++) {\n      const face = this.faces[f]\n\n      face.normal = face.__originalFaceNormal\n      face.vertexNormals = face.__originalVertexNormals\n    }\n  }\n\n  computeBoundingBox() {\n    if (this.boundingBox === null) {\n      this.boundingBox = new Box3()\n    }\n\n    this.boundingBox.setFromPoints(this.vertices)\n  }\n\n  computeBoundingSphere() {\n    if (this.boundingSphere === null) {\n      this.boundingSphere = new Sphere()\n    }\n\n    this.boundingSphere.setFromPoints(this.vertices)\n  }\n\n  merge(geometry, matrix, materialIndexOffset = 0) {\n    if (!(geometry && geometry.isGeometry)) {\n      console.error('THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.', geometry)\n      return\n    }\n\n    let normalMatrix\n    const vertexOffset = this.vertices.length,\n      vertices1 = this.vertices,\n      vertices2 = geometry.vertices,\n      faces1 = this.faces,\n      faces2 = geometry.faces,\n      colors1 = this.colors,\n      colors2 = geometry.colors\n\n    if (matrix !== undefined) {\n      normalMatrix = new Matrix3().getNormalMatrix(matrix)\n    }\n\n    // vertices\n\n    for (let i = 0, il = vertices2.length; i < il; i++) {\n      const vertex = vertices2[i]\n\n      const vertexCopy = vertex.clone()\n\n      if (matrix !== undefined) vertexCopy.applyMatrix4(matrix)\n\n      vertices1.push(vertexCopy)\n    }\n\n    // colors\n\n    for (let i = 0, il = colors2.length; i < il; i++) {\n      colors1.push(colors2[i].clone())\n    }\n\n    // faces\n\n    for (let i = 0, il = faces2.length; i < il; i++) {\n      const face = faces2[i]\n      let normal, color\n      const faceVertexNormals = face.vertexNormals,\n        faceVertexColors = face.vertexColors\n\n      const faceCopy = new Face3(face.a + vertexOffset, face.b + vertexOffset, face.c + vertexOffset)\n      faceCopy.normal.copy(face.normal)\n\n      if (normalMatrix !== undefined) {\n        faceCopy.normal.applyMatrix3(normalMatrix).normalize()\n      }\n\n      for (let j = 0, jl = faceVertexNormals.length; j < jl; j++) {\n        normal = faceVertexNormals[j].clone()\n\n        if (normalMatrix !== undefined) {\n          normal.applyMatrix3(normalMatrix).normalize()\n        }\n\n        faceCopy.vertexNormals.push(normal)\n      }\n\n      faceCopy.color.copy(face.color)\n\n      for (let j = 0, jl = faceVertexColors.length; j < jl; j++) {\n        color = faceVertexColors[j]\n        faceCopy.vertexColors.push(color.clone())\n      }\n\n      faceCopy.materialIndex = face.materialIndex + materialIndexOffset\n\n      faces1.push(faceCopy)\n    }\n\n    // uvs\n\n    for (let i = 0, il = geometry.faceVertexUvs.length; i < il; i++) {\n      const faceVertexUvs2 = geometry.faceVertexUvs[i]\n\n      if (this.faceVertexUvs[i] === undefined) this.faceVertexUvs[i] = []\n\n      for (let j = 0, jl = faceVertexUvs2.length; j < jl; j++) {\n        const uvs2 = faceVertexUvs2[j],\n          uvsCopy = []\n\n        for (let k = 0, kl = uvs2.length; k < kl; k++) {\n          uvsCopy.push(uvs2[k].clone())\n        }\n\n        this.faceVertexUvs[i].push(uvsCopy)\n      }\n    }\n  }\n\n  mergeMesh(mesh) {\n    if (!(mesh && mesh.isMesh)) {\n      console.error('THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.', mesh)\n      return\n    }\n\n    if (mesh.matrixAutoUpdate) mesh.updateMatrix()\n\n    this.merge(mesh.geometry, mesh.matrix)\n  }\n\n  /*\n   * Checks for duplicate vertices with hashmap.\n   * Duplicated vertices are removed\n   * and faces' vertices are updated.\n   */\n\n  mergeVertices(precisionPoints = 4) {\n    const verticesMap = {} // Hashmap for looking up vertices by position coordinates (and making sure they are unique)\n    const unique = [],\n      changes = []\n\n    const precision = Math.pow(10, precisionPoints)\n\n    for (let i = 0, il = this.vertices.length; i < il; i++) {\n      const v = this.vertices[i]\n      const key = `${Math.round(v.x * precision)}_${Math.round(v.y * precision)}_${Math.round(v.z * precision)}`\n\n      if (verticesMap[key] === undefined) {\n        verticesMap[key] = i\n        unique.push(this.vertices[i])\n        changes[i] = unique.length - 1\n      } else {\n        //console.log('Duplicate vertex found. ', i, ' could be using ', verticesMap[key]);\n        changes[i] = changes[verticesMap[key]]\n      }\n    }\n\n    // if faces are completely degenerate after merging vertices, we\n    // have to remove them from the geometry.\n    const faceIndicesToRemove = []\n\n    for (let i = 0, il = this.faces.length; i < il; i++) {\n      const face = this.faces[i]\n\n      face.a = changes[face.a]\n      face.b = changes[face.b]\n      face.c = changes[face.c]\n\n      const indices = [face.a, face.b, face.c]\n\n      // if any duplicate vertices are found in a Face3\n      // we have to remove the face as nothing can be saved\n      for (let n = 0; n < 3; n++) {\n        if (indices[n] === indices[(n + 1) % 3]) {\n          faceIndicesToRemove.push(i)\n          break\n        }\n      }\n    }\n\n    for (let i = faceIndicesToRemove.length - 1; i >= 0; i--) {\n      const idx = faceIndicesToRemove[i]\n\n      this.faces.splice(idx, 1)\n\n      for (let j = 0, jl = this.faceVertexUvs.length; j < jl; j++) {\n        this.faceVertexUvs[j].splice(idx, 1)\n      }\n    }\n\n    // Use unique set of vertices\n\n    const diff = this.vertices.length - unique.length\n    this.vertices = unique\n    return diff\n  }\n\n  setFromPoints(points) {\n    this.vertices = []\n\n    for (let i = 0, l = points.length; i < l; i++) {\n      const point = points[i]\n      this.vertices.push(new Vector3(point.x, point.y, point.z || 0))\n    }\n\n    return this\n  }\n\n  sortFacesByMaterialIndex() {\n    const faces = this.faces\n    const length = faces.length\n\n    // tag faces\n\n    for (let i = 0; i < length; i++) {\n      faces[i]._id = i\n    }\n\n    // sort faces\n\n    function materialIndexSort(a, b) {\n      return a.materialIndex - b.materialIndex\n    }\n\n    faces.sort(materialIndexSort)\n\n    // sort uvs\n\n    const uvs1 = this.faceVertexUvs[0]\n    const uvs2 = this.faceVertexUvs[1]\n\n    let newUvs1, newUvs2\n\n    if (uvs1 && uvs1.length === length) newUvs1 = []\n    if (uvs2 && uvs2.length === length) newUvs2 = []\n\n    for (let i = 0; i < length; i++) {\n      const id = faces[i]._id\n\n      if (newUvs1) newUvs1.push(uvs1[id])\n      if (newUvs2) newUvs2.push(uvs2[id])\n    }\n\n    if (newUvs1) this.faceVertexUvs[0] = newUvs1\n    if (newUvs2) this.faceVertexUvs[1] = newUvs2\n  }\n\n  toJSON() {\n    const data = {\n      metadata: {\n        version: 4.5,\n        type: 'Geometry',\n        generator: 'Geometry.toJSON',\n      },\n    }\n\n    // standard Geometry serialization\n\n    data.uuid = this.uuid\n    data.type = this.type\n    if (this.name !== '') data.name = this.name\n\n    if (this.parameters !== undefined) {\n      const parameters = this.parameters\n\n      for (let key in parameters) {\n        if (parameters[key] !== undefined) data[key] = parameters[key]\n      }\n\n      return data\n    }\n\n    const vertices = []\n\n    for (let i = 0; i < this.vertices.length; i++) {\n      const vertex = this.vertices[i]\n      vertices.push(vertex.x, vertex.y, vertex.z)\n    }\n\n    const faces = []\n    const normals = []\n    const normalsHash = {}\n    const colors = []\n    const colorsHash = {}\n    const uvs = []\n    const uvsHash = {}\n\n    for (let i = 0; i < this.faces.length; i++) {\n      const face = this.faces[i]\n\n      const hasMaterial = true\n      const hasFaceUv = false // deprecated\n      const hasFaceVertexUv = this.faceVertexUvs[0][i] !== undefined\n      const hasFaceNormal = face.normal.length() > 0\n      const hasFaceVertexNormal = face.vertexNormals.length > 0\n      const hasFaceColor = face.color.r !== 1 || face.color.g !== 1 || face.color.b !== 1\n      const hasFaceVertexColor = face.vertexColors.length > 0\n\n      let faceType = 0\n\n      faceType = setBit(faceType, 0, 0) // isQuad\n      faceType = setBit(faceType, 1, hasMaterial)\n      faceType = setBit(faceType, 2, hasFaceUv)\n      faceType = setBit(faceType, 3, hasFaceVertexUv)\n      faceType = setBit(faceType, 4, hasFaceNormal)\n      faceType = setBit(faceType, 5, hasFaceVertexNormal)\n      faceType = setBit(faceType, 6, hasFaceColor)\n      faceType = setBit(faceType, 7, hasFaceVertexColor)\n\n      faces.push(faceType)\n      faces.push(face.a, face.b, face.c)\n      faces.push(face.materialIndex)\n\n      if (hasFaceVertexUv) {\n        const faceVertexUvs = this.faceVertexUvs[0][i]\n\n        faces.push(getUvIndex(faceVertexUvs[0]), getUvIndex(faceVertexUvs[1]), getUvIndex(faceVertexUvs[2]))\n      }\n\n      if (hasFaceNormal) {\n        faces.push(getNormalIndex(face.normal))\n      }\n\n      if (hasFaceVertexNormal) {\n        const vertexNormals = face.vertexNormals\n\n        faces.push(getNormalIndex(vertexNormals[0]), getNormalIndex(vertexNormals[1]), getNormalIndex(vertexNormals[2]))\n      }\n\n      if (hasFaceColor) {\n        faces.push(getColorIndex(face.color))\n      }\n\n      if (hasFaceVertexColor) {\n        const vertexColors = face.vertexColors\n\n        faces.push(getColorIndex(vertexColors[0]), getColorIndex(vertexColors[1]), getColorIndex(vertexColors[2]))\n      }\n    }\n\n    function setBit(value, position, enabled) {\n      return enabled ? value | (1 << position) : value & ~(1 << position)\n    }\n\n    function getNormalIndex(normal) {\n      const hash = normal.x.toString() + normal.y.toString() + normal.z.toString()\n\n      if (normalsHash[hash] !== undefined) {\n        return normalsHash[hash]\n      }\n\n      normalsHash[hash] = normals.length / 3\n      normals.push(normal.x, normal.y, normal.z)\n\n      return normalsHash[hash]\n    }\n\n    function getColorIndex(color) {\n      const hash = color.r.toString() + color.g.toString() + color.b.toString()\n\n      if (colorsHash[hash] !== undefined) {\n        return colorsHash[hash]\n      }\n\n      colorsHash[hash] = colors.length\n      colors.push(color.getHex())\n\n      return colorsHash[hash]\n    }\n\n    function getUvIndex(uv) {\n      const hash = uv.x.toString() + uv.y.toString()\n\n      if (uvsHash[hash] !== undefined) {\n        return uvsHash[hash]\n      }\n\n      uvsHash[hash] = uvs.length / 2\n      uvs.push(uv.x, uv.y)\n\n      return uvsHash[hash]\n    }\n\n    data.data = {}\n\n    data.data.vertices = vertices\n    data.data.normals = normals\n    if (colors.length > 0) data.data.colors = colors\n    if (uvs.length > 0) data.data.uvs = [uvs] // temporal backward compatibility\n    data.data.faces = faces\n\n    return data\n  }\n\n  clone() {\n    /*\n\t\t // Handle primitives\n\n\t\t const parameters = this.parameters;\n\n\t\t if ( parameters !== undefined ) {\n\n\t\t const values = [];\n\n\t\t for ( const key in parameters ) {\n\n\t\t values.push( parameters[ key ] );\n\n\t\t }\n\n\t\t const geometry = Object.create( this.constructor.prototype );\n\t\t this.constructor.apply( geometry, values );\n\t\t return geometry;\n\n\t\t }\n\n\t\t return new this.constructor().copy( this );\n\t\t */\n\n    return new Geometry().copy(this)\n  }\n\n  copy(source) {\n    // reset\n\n    this.vertices = []\n    this.colors = []\n    this.faces = []\n    this.faceVertexUvs = [[]]\n    this.morphTargets = []\n    this.morphNormals = []\n    this.skinWeights = []\n    this.skinIndices = []\n    this.lineDistances = []\n    this.boundingBox = null\n    this.boundingSphere = null\n\n    // name\n\n    this.name = source.name\n\n    // vertices\n\n    const vertices = source.vertices\n\n    for (let i = 0, il = vertices.length; i < il; i++) {\n      this.vertices.push(vertices[i].clone())\n    }\n\n    // colors\n\n    const colors = source.colors\n\n    for (let i = 0, il = colors.length; i < il; i++) {\n      this.colors.push(colors[i].clone())\n    }\n\n    // faces\n\n    const faces = source.faces\n\n    for (let i = 0, il = faces.length; i < il; i++) {\n      this.faces.push(faces[i].clone())\n    }\n\n    // face vertex uvs\n\n    for (let i = 0, il = source.faceVertexUvs.length; i < il; i++) {\n      const faceVertexUvs = source.faceVertexUvs[i]\n\n      if (this.faceVertexUvs[i] === undefined) {\n        this.faceVertexUvs[i] = []\n      }\n\n      for (let j = 0, jl = faceVertexUvs.length; j < jl; j++) {\n        const uvs = faceVertexUvs[j],\n          uvsCopy = []\n\n        for (let k = 0, kl = uvs.length; k < kl; k++) {\n          const uv = uvs[k]\n\n          uvsCopy.push(uv.clone())\n        }\n\n        this.faceVertexUvs[i].push(uvsCopy)\n      }\n    }\n\n    // morph targets\n\n    const morphTargets = source.morphTargets\n\n    for (let i = 0, il = morphTargets.length; i < il; i++) {\n      const morphTarget = {}\n      morphTarget.name = morphTargets[i].name\n\n      // vertices\n\n      if (morphTargets[i].vertices !== undefined) {\n        morphTarget.vertices = []\n\n        for (let j = 0, jl = morphTargets[i].vertices.length; j < jl; j++) {\n          morphTarget.vertices.push(morphTargets[i].vertices[j].clone())\n        }\n      }\n\n      // normals\n\n      if (morphTargets[i].normals !== undefined) {\n        morphTarget.normals = []\n\n        for (let j = 0, jl = morphTargets[i].normals.length; j < jl; j++) {\n          morphTarget.normals.push(morphTargets[i].normals[j].clone())\n        }\n      }\n\n      this.morphTargets.push(morphTarget)\n    }\n\n    // morph normals\n\n    const morphNormals = source.morphNormals\n\n    for (let i = 0, il = morphNormals.length; i < il; i++) {\n      const morphNormal = {}\n\n      // vertex normals\n\n      if (morphNormals[i].vertexNormals !== undefined) {\n        morphNormal.vertexNormals = []\n\n        for (let j = 0, jl = morphNormals[i].vertexNormals.length; j < jl; j++) {\n          const srcVertexNormal = morphNormals[i].vertexNormals[j]\n          const destVertexNormal = {}\n\n          destVertexNormal.a = srcVertexNormal.a.clone()\n          destVertexNormal.b = srcVertexNormal.b.clone()\n          destVertexNormal.c = srcVertexNormal.c.clone()\n\n          morphNormal.vertexNormals.push(destVertexNormal)\n        }\n      }\n\n      // face normals\n\n      if (morphNormals[i].faceNormals !== undefined) {\n        morphNormal.faceNormals = []\n\n        for (let j = 0, jl = morphNormals[i].faceNormals.length; j < jl; j++) {\n          morphNormal.faceNormals.push(morphNormals[i].faceNormals[j].clone())\n        }\n      }\n\n      this.morphNormals.push(morphNormal)\n    }\n\n    // skin weights\n\n    const skinWeights = source.skinWeights\n\n    for (let i = 0, il = skinWeights.length; i < il; i++) {\n      this.skinWeights.push(skinWeights[i].clone())\n    }\n\n    // skin indices\n\n    const skinIndices = source.skinIndices\n\n    for (let i = 0, il = skinIndices.length; i < il; i++) {\n      this.skinIndices.push(skinIndices[i].clone())\n    }\n\n    // line distances\n\n    const lineDistances = source.lineDistances\n\n    for (let i = 0, il = lineDistances.length; i < il; i++) {\n      this.lineDistances.push(lineDistances[i])\n    }\n\n    // bounding box\n\n    const boundingBox = source.boundingBox\n\n    if (boundingBox !== null) {\n      this.boundingBox = boundingBox.clone()\n    }\n\n    // bounding sphere\n\n    const boundingSphere = source.boundingSphere\n\n    if (boundingSphere !== null) {\n      this.boundingSphere = boundingSphere.clone()\n    }\n\n    // update flags\n\n    this.elementsNeedUpdate = source.elementsNeedUpdate\n    this.verticesNeedUpdate = source.verticesNeedUpdate\n    this.uvsNeedUpdate = source.uvsNeedUpdate\n    this.normalsNeedUpdate = source.normalsNeedUpdate\n    this.colorsNeedUpdate = source.colorsNeedUpdate\n    this.lineDistancesNeedUpdate = source.lineDistancesNeedUpdate\n    this.groupsNeedUpdate = source.groupsNeedUpdate\n\n    return this\n  }\n\n  toBufferGeometry() {\n    const geometry = new DirectGeometry().fromGeometry(this)\n\n    const buffergeometry = new BufferGeometry()\n\n    const positions = new Float32Array(geometry.vertices.length * 3)\n    buffergeometry.setAttribute('position', new BufferAttribute(positions, 3).copyVector3sArray(geometry.vertices))\n\n    if (geometry.normals.length > 0) {\n      const normals = new Float32Array(geometry.normals.length * 3)\n      buffergeometry.setAttribute('normal', new BufferAttribute(normals, 3).copyVector3sArray(geometry.normals))\n    }\n\n    if (geometry.colors.length > 0) {\n      const colors = new Float32Array(geometry.colors.length * 3)\n      buffergeometry.setAttribute('color', new BufferAttribute(colors, 3).copyColorsArray(geometry.colors))\n    }\n\n    if (geometry.uvs.length > 0) {\n      const uvs = new Float32Array(geometry.uvs.length * 2)\n      buffergeometry.setAttribute('uv', new BufferAttribute(uvs, 2).copyVector2sArray(geometry.uvs))\n    }\n\n    if (geometry.uvs2.length > 0) {\n      const uvs2 = new Float32Array(geometry.uvs2.length * 2)\n      buffergeometry.setAttribute('uv2', new BufferAttribute(uvs2, 2).copyVector2sArray(geometry.uvs2))\n    }\n\n    // groups\n\n    buffergeometry.groups = geometry.groups\n\n    // morphs\n\n    for (let name in geometry.morphTargets) {\n      const array = []\n      const morphTargets = geometry.morphTargets[name]\n\n      for (let i = 0, l = morphTargets.length; i < l; i++) {\n        const morphTarget = morphTargets[i]\n\n        const attribute = new Float32BufferAttribute(morphTarget.data.length * 3, 3)\n        attribute.name = morphTarget.name\n\n        array.push(attribute.copyVector3sArray(morphTarget.data))\n      }\n\n      buffergeometry.morphAttributes[name] = array\n    }\n\n    // skinning\n\n    if (geometry.skinIndices.length > 0) {\n      const skinIndices = new Float32BufferAttribute(geometry.skinIndices.length * 4, 4)\n      buffergeometry.setAttribute('skinIndex', skinIndices.copyVector4sArray(geometry.skinIndices))\n    }\n\n    if (geometry.skinWeights.length > 0) {\n      const skinWeights = new Float32BufferAttribute(geometry.skinWeights.length * 4, 4)\n      buffergeometry.setAttribute('skinWeight', skinWeights.copyVector4sArray(geometry.skinWeights))\n    }\n\n    //\n\n    if (geometry.boundingSphere !== null) {\n      buffergeometry.boundingSphere = geometry.boundingSphere.clone()\n    }\n\n    if (geometry.boundingBox !== null) {\n      buffergeometry.boundingBox = geometry.boundingBox.clone()\n    }\n\n    return buffergeometry\n  }\n\n  computeTangents() {\n    console.error('THREE.Geometry: .computeTangents() has been removed.')\n  }\n\n  computeLineDistances() {\n    console.error(\n      'THREE.Geometry: .computeLineDistances() has been removed. Use THREE.Line.computeLineDistances() instead.',\n    )\n  }\n\n  applyMatrix(matrix) {\n    console.warn('THREE.Geometry: .applyMatrix() has been renamed to .applyMatrix4().')\n    return this.applyMatrix4(matrix)\n  }\n\n  dispose() {\n    this.dispatchEvent({ type: 'dispose' })\n  }\n}\n\nclass DirectGeometry {\n  constructor() {\n    this.vertices = []\n    this.normals = []\n    this.colors = []\n    this.uvs = []\n    this.uvs2 = []\n\n    this.groups = []\n\n    this.morphTargets = {}\n\n    this.skinWeights = []\n    this.skinIndices = []\n\n    // this.lineDistances = [];\n\n    this.boundingBox = null\n    this.boundingSphere = null\n\n    // update flags\n\n    this.verticesNeedUpdate = false\n    this.normalsNeedUpdate = false\n    this.colorsNeedUpdate = false\n    this.uvsNeedUpdate = false\n    this.groupsNeedUpdate = false\n  }\n\n  computeGroups(geometry) {\n    const groups = []\n\n    let group, i\n    let materialIndex = undefined\n\n    const faces = geometry.faces\n\n    for (i = 0; i < faces.length; i++) {\n      const face = faces[i]\n\n      // materials\n\n      if (face.materialIndex !== materialIndex) {\n        materialIndex = face.materialIndex\n\n        if (group !== undefined) {\n          group.count = i * 3 - group.start\n          groups.push(group)\n        }\n\n        group = {\n          start: i * 3,\n          materialIndex,\n        }\n      }\n    }\n\n    if (group !== undefined) {\n      group.count = i * 3 - group.start\n      groups.push(group)\n    }\n\n    this.groups = groups\n  }\n\n  fromGeometry(geometry) {\n    const faces = geometry.faces\n    const vertices = geometry.vertices\n    const faceVertexUvs = geometry.faceVertexUvs\n\n    const hasFaceVertexUv = faceVertexUvs[0] && faceVertexUvs[0].length > 0\n    const hasFaceVertexUv2 = faceVertexUvs[1] && faceVertexUvs[1].length > 0\n\n    // morphs\n\n    const morphTargets = geometry.morphTargets\n    const morphTargetsLength = morphTargets.length\n\n    let morphTargetsPosition\n\n    if (morphTargetsLength > 0) {\n      morphTargetsPosition = []\n\n      for (let i = 0; i < morphTargetsLength; i++) {\n        morphTargetsPosition[i] = {\n          name: morphTargets[i].name,\n          data: [],\n        }\n      }\n\n      this.morphTargets.position = morphTargetsPosition\n    }\n\n    const morphNormals = geometry.morphNormals\n    const morphNormalsLength = morphNormals.length\n\n    let morphTargetsNormal\n\n    if (morphNormalsLength > 0) {\n      morphTargetsNormal = []\n\n      for (let i = 0; i < morphNormalsLength; i++) {\n        morphTargetsNormal[i] = {\n          name: morphNormals[i].name,\n          data: [],\n        }\n      }\n\n      this.morphTargets.normal = morphTargetsNormal\n    }\n\n    // skins\n\n    const skinIndices = geometry.skinIndices\n    const skinWeights = geometry.skinWeights\n\n    const hasSkinIndices = skinIndices.length === vertices.length\n    const hasSkinWeights = skinWeights.length === vertices.length\n\n    //\n\n    if (vertices.length > 0 && faces.length === 0) {\n      console.error('THREE.DirectGeometry: Faceless geometries are not supported.')\n    }\n\n    for (let i = 0; i < faces.length; i++) {\n      const face = faces[i]\n\n      this.vertices.push(vertices[face.a], vertices[face.b], vertices[face.c])\n\n      const vertexNormals = face.vertexNormals\n\n      if (vertexNormals.length === 3) {\n        this.normals.push(vertexNormals[0], vertexNormals[1], vertexNormals[2])\n      } else {\n        const normal = face.normal\n\n        this.normals.push(normal, normal, normal)\n      }\n\n      const vertexColors = face.vertexColors\n\n      if (vertexColors.length === 3) {\n        this.colors.push(vertexColors[0], vertexColors[1], vertexColors[2])\n      } else {\n        const color = face.color\n\n        this.colors.push(color, color, color)\n      }\n\n      if (hasFaceVertexUv === true) {\n        const vertexUvs = faceVertexUvs[0][i]\n\n        if (vertexUvs !== undefined) {\n          this.uvs.push(vertexUvs[0], vertexUvs[1], vertexUvs[2])\n        } else {\n          console.warn('THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ', i)\n\n          this.uvs.push(new Vector2(), new Vector2(), new Vector2())\n        }\n      }\n\n      if (hasFaceVertexUv2 === true) {\n        const vertexUvs = faceVertexUvs[1][i]\n\n        if (vertexUvs !== undefined) {\n          this.uvs2.push(vertexUvs[0], vertexUvs[1], vertexUvs[2])\n        } else {\n          console.warn('THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ', i)\n\n          this.uvs2.push(new Vector2(), new Vector2(), new Vector2())\n        }\n      }\n\n      // morphs\n\n      for (let j = 0; j < morphTargetsLength; j++) {\n        const morphTarget = morphTargets[j].vertices\n\n        morphTargetsPosition[j].data.push(morphTarget[face.a], morphTarget[face.b], morphTarget[face.c])\n      }\n\n      for (let j = 0; j < morphNormalsLength; j++) {\n        const morphNormal = morphNormals[j].vertexNormals[i]\n\n        morphTargetsNormal[j].data.push(morphNormal.a, morphNormal.b, morphNormal.c)\n      }\n\n      // skins\n\n      if (hasSkinIndices) {\n        this.skinIndices.push(skinIndices[face.a], skinIndices[face.b], skinIndices[face.c])\n      }\n\n      if (hasSkinWeights) {\n        this.skinWeights.push(skinWeights[face.a], skinWeights[face.b], skinWeights[face.c])\n      }\n    }\n\n    this.computeGroups(geometry)\n\n    this.verticesNeedUpdate = geometry.verticesNeedUpdate\n    this.normalsNeedUpdate = geometry.normalsNeedUpdate\n    this.colorsNeedUpdate = geometry.colorsNeedUpdate\n    this.uvsNeedUpdate = geometry.uvsNeedUpdate\n    this.groupsNeedUpdate = geometry.groupsNeedUpdate\n\n    if (geometry.boundingSphere !== null) {\n      this.boundingSphere = geometry.boundingSphere.clone()\n    }\n\n    if (geometry.boundingBox !== null) {\n      this.boundingBox = geometry.boundingBox.clone()\n    }\n\n    return this\n  }\n}\n\nclass Face3 {\n  constructor(a, b, c, normal, color, materialIndex = 0) {\n    this.a = a\n    this.b = b\n    this.c = c\n\n    this.normal = normal && normal.isVector3 ? normal : new Vector3()\n    this.vertexNormals = Array.isArray(normal) ? normal : []\n\n    this.color = color && color.isColor ? color : new Color()\n    this.vertexColors = Array.isArray(color) ? color : []\n\n    this.materialIndex = materialIndex\n  }\n\n  clone() {\n    return new this.constructor().copy(this)\n  }\n\n  copy(source) {\n    this.a = source.a\n    this.b = source.b\n    this.c = source.c\n\n    this.normal.copy(source.normal)\n    this.color.copy(source.color)\n\n    this.materialIndex = source.materialIndex\n\n    for (let i = 0, il = source.vertexNormals.length; i < il; i++) {\n      this.vertexNormals[i] = source.vertexNormals[i].clone()\n    }\n\n    for (let i = 0, il = source.vertexColors.length; i < il; i++) {\n      this.vertexColors[i] = source.vertexColors[i].clone()\n    }\n\n    return this\n  }\n}\n\nexport { Face3, Geometry }\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}