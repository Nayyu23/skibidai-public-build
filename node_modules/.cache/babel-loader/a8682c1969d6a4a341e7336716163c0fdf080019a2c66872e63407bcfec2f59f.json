{"ast":null,"code":"import _createClass from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _classCallCheck from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _assertThisInitialized from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js\";\nimport _inherits from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = function __defNormalProp(obj, key, value) {\n  return key in obj ? __defProp(obj, key, {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: value\n  }) : obj[key] = value;\n};\nvar __publicField = function __publicField(obj, key, value) {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nimport { Mesh, PerspectiveCamera, Color, Plane, Matrix4, WebGLRenderTarget, HalfFloatType, ShaderMaterial, UniformsUtils, Vector3, Quaternion, Vector4, NoToneMapping } from \"three\";\nimport { version } from \"../_polyfill/constants.js\";\nvar _Refractor = /*#__PURE__*/function (_Mesh) {\n  _inherits(_Refractor, _Mesh);\n  var _super = _createSuper(_Refractor);\n  function _Refractor(geometry) {\n    var _this;\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    _classCallCheck(this, _Refractor);\n    _this = _super.call(this, geometry);\n    _this.isRefractor = true;\n    _this.type = \"Refractor\";\n    _this.camera = new PerspectiveCamera();\n    var scope = _assertThisInitialized(_this);\n    var color = options.color !== void 0 ? new Color(options.color) : new Color(8355711);\n    var textureWidth = options.textureWidth || 512;\n    var textureHeight = options.textureHeight || 512;\n    var clipBias = options.clipBias || 0;\n    var shader = options.shader || _Refractor.RefractorShader;\n    var multisample = options.multisample !== void 0 ? options.multisample : 4;\n    var virtualCamera = _this.camera;\n    virtualCamera.matrixAutoUpdate = false;\n    virtualCamera.userData.refractor = true;\n    var refractorPlane = new Plane();\n    var textureMatrix = new Matrix4();\n    var renderTarget = new WebGLRenderTarget(textureWidth, textureHeight, {\n      samples: multisample,\n      type: HalfFloatType\n    });\n    _this.material = new ShaderMaterial({\n      uniforms: UniformsUtils.clone(shader.uniforms),\n      vertexShader: shader.vertexShader,\n      fragmentShader: shader.fragmentShader,\n      transparent: true\n      // ensures, refractors are drawn from farthest to closest\n    });\n\n    _this.material.uniforms[\"color\"].value = color;\n    _this.material.uniforms[\"tDiffuse\"].value = renderTarget.texture;\n    _this.material.uniforms[\"textureMatrix\"].value = textureMatrix;\n    var visible = function () {\n      var refractorWorldPosition = new Vector3();\n      var cameraWorldPosition = new Vector3();\n      var rotationMatrix = new Matrix4();\n      var view = new Vector3();\n      var normal = new Vector3();\n      return function visible2(camera) {\n        refractorWorldPosition.setFromMatrixPosition(scope.matrixWorld);\n        cameraWorldPosition.setFromMatrixPosition(camera.matrixWorld);\n        view.subVectors(refractorWorldPosition, cameraWorldPosition);\n        rotationMatrix.extractRotation(scope.matrixWorld);\n        normal.set(0, 0, 1);\n        normal.applyMatrix4(rotationMatrix);\n        return view.dot(normal) < 0;\n      };\n    }();\n    var updateRefractorPlane = function () {\n      var normal = new Vector3();\n      var position = new Vector3();\n      var quaternion = new Quaternion();\n      var scale = new Vector3();\n      return function updateRefractorPlane2() {\n        scope.matrixWorld.decompose(position, quaternion, scale);\n        normal.set(0, 0, 1).applyQuaternion(quaternion).normalize();\n        normal.negate();\n        refractorPlane.setFromNormalAndCoplanarPoint(normal, position);\n      };\n    }();\n    var updateVirtualCamera = function () {\n      var clipPlane = new Plane();\n      var clipVector = new Vector4();\n      var q = new Vector4();\n      return function updateVirtualCamera2(camera) {\n        virtualCamera.matrixWorld.copy(camera.matrixWorld);\n        virtualCamera.matrixWorldInverse.copy(virtualCamera.matrixWorld).invert();\n        virtualCamera.projectionMatrix.copy(camera.projectionMatrix);\n        virtualCamera.far = camera.far;\n        clipPlane.copy(refractorPlane);\n        clipPlane.applyMatrix4(virtualCamera.matrixWorldInverse);\n        clipVector.set(clipPlane.normal.x, clipPlane.normal.y, clipPlane.normal.z, clipPlane.constant);\n        var projectionMatrix = virtualCamera.projectionMatrix;\n        q.x = (Math.sign(clipVector.x) + projectionMatrix.elements[8]) / projectionMatrix.elements[0];\n        q.y = (Math.sign(clipVector.y) + projectionMatrix.elements[9]) / projectionMatrix.elements[5];\n        q.z = -1;\n        q.w = (1 + projectionMatrix.elements[10]) / projectionMatrix.elements[14];\n        clipVector.multiplyScalar(2 / clipVector.dot(q));\n        projectionMatrix.elements[2] = clipVector.x;\n        projectionMatrix.elements[6] = clipVector.y;\n        projectionMatrix.elements[10] = clipVector.z + 1 - clipBias;\n        projectionMatrix.elements[14] = clipVector.w;\n      };\n    }();\n    function updateTextureMatrix(camera) {\n      textureMatrix.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1);\n      textureMatrix.multiply(camera.projectionMatrix);\n      textureMatrix.multiply(camera.matrixWorldInverse);\n      textureMatrix.multiply(scope.matrixWorld);\n    }\n    function render(renderer, scene, camera) {\n      scope.visible = false;\n      var currentRenderTarget = renderer.getRenderTarget();\n      var currentXrEnabled = renderer.xr.enabled;\n      var currentShadowAutoUpdate = renderer.shadowMap.autoUpdate;\n      var currentToneMapping = renderer.toneMapping;\n      var isSRGB = false;\n      if (\"outputColorSpace\" in renderer) isSRGB = renderer.outputColorSpace === \"srgb\";else isSRGB = renderer.outputEncoding === 3001;\n      renderer.xr.enabled = false;\n      renderer.shadowMap.autoUpdate = false;\n      if (\"outputColorSpace\" in renderer) renderer.outputColorSpace = \"srgb-linear\";else renderer.outputEncoding = 3e3;\n      renderer.toneMapping = NoToneMapping;\n      renderer.setRenderTarget(renderTarget);\n      if (renderer.autoClear === false) renderer.clear();\n      renderer.render(scene, virtualCamera);\n      renderer.xr.enabled = currentXrEnabled;\n      renderer.shadowMap.autoUpdate = currentShadowAutoUpdate;\n      renderer.toneMapping = currentToneMapping;\n      renderer.setRenderTarget(currentRenderTarget);\n      if (\"outputColorSpace\" in renderer) renderer.outputColorSpace = isSRGB ? \"srgb\" : \"srgb-linear\";else renderer.outputEncoding = isSRGB ? 3001 : 3e3;\n      var viewport = camera.viewport;\n      if (viewport !== void 0) {\n        renderer.state.viewport(viewport);\n      }\n      scope.visible = true;\n    }\n    _this.onBeforeRender = function (renderer, scene, camera) {\n      if (camera.userData.refractor === true) return;\n      if (!visible(camera) === true) return;\n      updateRefractorPlane();\n      updateTextureMatrix(camera);\n      updateVirtualCamera(camera);\n      render(renderer, scene, camera);\n    };\n    _this.getRenderTarget = function () {\n      return renderTarget;\n    };\n    _this.dispose = function () {\n      renderTarget.dispose();\n      scope.material.dispose();\n    };\n    return _this;\n  }\n  return _createClass(_Refractor);\n}(Mesh);\nvar Refractor = _Refractor;\n__publicField(Refractor, \"RefractorShader\", {\n  uniforms: {\n    color: {\n      value: null\n    },\n    tDiffuse: {\n      value: null\n    },\n    textureMatrix: {\n      value: null\n    }\n  },\n  vertexShader: /* glsl */\"\\n\\n\\t\\tuniform mat4 textureMatrix;\\n\\n\\t\\tvarying vec4 vUv;\\n\\n\\t\\tvoid main() {\\n\\n\\t\\t\\tvUv = textureMatrix * vec4( position, 1.0 );\\n\\t\\t\\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n\\n\\t\\t}\",\n  fragmentShader: /* glsl */\"\\n\\n\\t\\tuniform vec3 color;\\n\\t\\tuniform sampler2D tDiffuse;\\n\\n\\t\\tvarying vec4 vUv;\\n\\n\\t\\tfloat blendOverlay( float base, float blend ) {\\n\\n\\t\\t\\treturn( base < 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );\\n\\n\\t\\t}\\n\\n\\t\\tvec3 blendOverlay( vec3 base, vec3 blend ) {\\n\\n\\t\\t\\treturn vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ), blendOverlay( base.b, blend.b ) );\\n\\n\\t\\t}\\n\\n\\t\\tvoid main() {\\n\\n\\t\\t\\tvec4 base = texture2DProj( tDiffuse, vUv );\\n\\t\\t\\tgl_FragColor = vec4( blendOverlay( base.rgb, color ), 1.0 );\\n\\n\\t\\t\\t#include <tonemapping_fragment>\\n\\t\\t\\t#include <\".concat(version >= 154 ? \"colorspace_fragment\" : \"encodings_fragment\", \">\\n\\n\\t\\t}\")\n});\nexport { Refractor };","map":{"version":3,"names":["_Refractor","_Mesh","_inherits","_super","_createSuper","geometry","_this","options","arguments","length","undefined","_classCallCheck","call","isRefractor","type","camera","PerspectiveCamera","scope","_assertThisInitialized","color","Color","textureWidth","textureHeight","clipBias","shader","RefractorShader","multisample","virtualCamera","matrixAutoUpdate","userData","refractor","refractorPlane","Plane","textureMatrix","Matrix4","renderTarget","WebGLRenderTarget","samples","HalfFloatType","material","ShaderMaterial","uniforms","UniformsUtils","clone","vertexShader","fragmentShader","transparent","value","texture","visible","refractorWorldPosition","Vector3","cameraWorldPosition","rotationMatrix","view","normal","visible2","setFromMatrixPosition","matrixWorld","subVectors","extractRotation","set","applyMatrix4","dot","updateRefractorPlane","position","quaternion","Quaternion","scale","updateRefractorPlane2","decompose","applyQuaternion","normalize","negate","setFromNormalAndCoplanarPoint","updateVirtualCamera","clipPlane","clipVector","Vector4","q","updateVirtualCamera2","copy","matrixWorldInverse","invert","projectionMatrix","far","x","y","z","constant","Math","sign","elements","w","multiplyScalar","updateTextureMatrix","multiply","render","renderer","scene","currentRenderTarget","getRenderTarget","currentXrEnabled","xr","enabled","currentShadowAutoUpdate","shadowMap","autoUpdate","currentToneMapping","toneMapping","isSRGB","outputColorSpace","outputEncoding","NoToneMapping","setRenderTarget","autoClear","clear","viewport","state","onBeforeRender","dispose","_createClass","Mesh","Refractor","__publicField","tDiffuse","concat","version"],"sources":["C:\\Users\\Nayyu\\Desktop\\skibidai-public-build\\node_modules\\src\\objects\\Refractor.js"],"sourcesContent":["import {\n  Color,\n  Matrix4,\n  Mesh,\n  PerspectiveCamera,\n  Plane,\n  Quaternion,\n  ShaderMaterial,\n  UniformsUtils,\n  Vector3,\n  Vector4,\n  WebGLRenderTarget,\n  NoToneMapping,\n  HalfFloatType,\n} from 'three'\nimport { version } from '../_polyfill/constants'\n\nclass Refractor extends Mesh {\n  static RefractorShader = {\n    uniforms: {\n      color: {\n        value: null,\n      },\n\n      tDiffuse: {\n        value: null,\n      },\n\n      textureMatrix: {\n        value: null,\n      },\n    },\n\n    vertexShader: /* glsl */ `\n\n\t\tuniform mat4 textureMatrix;\n\n\t\tvarying vec4 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvUv = textureMatrix * vec4( position, 1.0 );\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t}`,\n\n    fragmentShader: /* glsl */ `\n\n\t\tuniform vec3 color;\n\t\tuniform sampler2D tDiffuse;\n\n\t\tvarying vec4 vUv;\n\n\t\tfloat blendOverlay( float base, float blend ) {\n\n\t\t\treturn( base < 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );\n\n\t\t}\n\n\t\tvec3 blendOverlay( vec3 base, vec3 blend ) {\n\n\t\t\treturn vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ), blendOverlay( base.b, blend.b ) );\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvec4 base = texture2DProj( tDiffuse, vUv );\n\t\t\tgl_FragColor = vec4( blendOverlay( base.rgb, color ), 1.0 );\n\n\t\t\t#include <tonemapping_fragment>\n\t\t\t#include <${version >= 154 ? 'colorspace_fragment' : 'encodings_fragment'}>\n\n\t\t}`,\n  }\n\n  constructor(geometry, options = {}) {\n    super(geometry)\n\n    this.isRefractor = true\n\n    this.type = 'Refractor'\n    this.camera = new PerspectiveCamera()\n\n    const scope = this\n\n    const color = options.color !== undefined ? new Color(options.color) : new Color(0x7f7f7f)\n    const textureWidth = options.textureWidth || 512\n    const textureHeight = options.textureHeight || 512\n    const clipBias = options.clipBias || 0\n    const shader = options.shader || Refractor.RefractorShader\n    const multisample = options.multisample !== undefined ? options.multisample : 4\n\n    //\n\n    const virtualCamera = this.camera\n    virtualCamera.matrixAutoUpdate = false\n    virtualCamera.userData.refractor = true\n\n    //\n\n    const refractorPlane = new Plane()\n    const textureMatrix = new Matrix4()\n\n    // render target\n\n    const renderTarget = new WebGLRenderTarget(textureWidth, textureHeight, {\n      samples: multisample,\n      type: HalfFloatType,\n    })\n\n    // material\n\n    this.material = new ShaderMaterial({\n      uniforms: UniformsUtils.clone(shader.uniforms),\n      vertexShader: shader.vertexShader,\n      fragmentShader: shader.fragmentShader,\n      transparent: true, // ensures, refractors are drawn from farthest to closest\n    })\n\n    this.material.uniforms['color'].value = color\n    this.material.uniforms['tDiffuse'].value = renderTarget.texture\n    this.material.uniforms['textureMatrix'].value = textureMatrix\n\n    // functions\n\n    const visible = (function () {\n      const refractorWorldPosition = new Vector3()\n      const cameraWorldPosition = new Vector3()\n      const rotationMatrix = new Matrix4()\n\n      const view = new Vector3()\n      const normal = new Vector3()\n\n      return function visible(camera) {\n        refractorWorldPosition.setFromMatrixPosition(scope.matrixWorld)\n        cameraWorldPosition.setFromMatrixPosition(camera.matrixWorld)\n\n        view.subVectors(refractorWorldPosition, cameraWorldPosition)\n\n        rotationMatrix.extractRotation(scope.matrixWorld)\n\n        normal.set(0, 0, 1)\n        normal.applyMatrix4(rotationMatrix)\n\n        return view.dot(normal) < 0\n      }\n    })()\n\n    const updateRefractorPlane = (function () {\n      const normal = new Vector3()\n      const position = new Vector3()\n      const quaternion = new Quaternion()\n      const scale = new Vector3()\n\n      return function updateRefractorPlane() {\n        scope.matrixWorld.decompose(position, quaternion, scale)\n        normal.set(0, 0, 1).applyQuaternion(quaternion).normalize()\n\n        // flip the normal because we want to cull everything above the plane\n\n        normal.negate()\n\n        refractorPlane.setFromNormalAndCoplanarPoint(normal, position)\n      }\n    })()\n\n    const updateVirtualCamera = (function () {\n      const clipPlane = new Plane()\n      const clipVector = new Vector4()\n      const q = new Vector4()\n\n      return function updateVirtualCamera(camera) {\n        virtualCamera.matrixWorld.copy(camera.matrixWorld)\n        virtualCamera.matrixWorldInverse.copy(virtualCamera.matrixWorld).invert()\n        virtualCamera.projectionMatrix.copy(camera.projectionMatrix)\n        virtualCamera.far = camera.far // used in WebGLBackground\n\n        // The following code creates an oblique view frustum for clipping.\n        // see: Lengyel, Eric. “Oblique View Frustum Depth Projection and Clipping”.\n        // Journal of Game Development, Vol. 1, No. 2 (2005), Charles River Media, pp. 5–16\n\n        clipPlane.copy(refractorPlane)\n        clipPlane.applyMatrix4(virtualCamera.matrixWorldInverse)\n\n        clipVector.set(clipPlane.normal.x, clipPlane.normal.y, clipPlane.normal.z, clipPlane.constant)\n\n        // calculate the clip-space corner point opposite the clipping plane and\n        // transform it into camera space by multiplying it by the inverse of the projection matrix\n\n        const projectionMatrix = virtualCamera.projectionMatrix\n\n        q.x = (Math.sign(clipVector.x) + projectionMatrix.elements[8]) / projectionMatrix.elements[0]\n        q.y = (Math.sign(clipVector.y) + projectionMatrix.elements[9]) / projectionMatrix.elements[5]\n        q.z = -1.0\n        q.w = (1.0 + projectionMatrix.elements[10]) / projectionMatrix.elements[14]\n\n        // calculate the scaled plane vector\n\n        clipVector.multiplyScalar(2.0 / clipVector.dot(q))\n\n        // replacing the third row of the projection matrix\n\n        projectionMatrix.elements[2] = clipVector.x\n        projectionMatrix.elements[6] = clipVector.y\n        projectionMatrix.elements[10] = clipVector.z + 1.0 - clipBias\n        projectionMatrix.elements[14] = clipVector.w\n      }\n    })()\n\n    // This will update the texture matrix that is used for projective texture mapping in the shader.\n    // see: http://developer.download.nvidia.com/assets/gamedev/docs/projective_texture_mapping.pdf\n\n    function updateTextureMatrix(camera) {\n      // this matrix does range mapping to [ 0, 1 ]\n\n      textureMatrix.set(0.5, 0.0, 0.0, 0.5, 0.0, 0.5, 0.0, 0.5, 0.0, 0.0, 0.5, 0.5, 0.0, 0.0, 0.0, 1.0)\n\n      // we use \"Object Linear Texgen\", so we need to multiply the texture matrix T\n      // (matrix above) with the projection and view matrix of the virtual camera\n      // and the model matrix of the refractor\n\n      textureMatrix.multiply(camera.projectionMatrix)\n      textureMatrix.multiply(camera.matrixWorldInverse)\n      textureMatrix.multiply(scope.matrixWorld)\n    }\n\n    //\n\n    function render(renderer, scene, camera) {\n      scope.visible = false\n\n      const currentRenderTarget = renderer.getRenderTarget()\n      const currentXrEnabled = renderer.xr.enabled\n      const currentShadowAutoUpdate = renderer.shadowMap.autoUpdate\n      const currentToneMapping = renderer.toneMapping\n\n      let isSRGB = false\n      if ('outputColorSpace' in renderer) isSRGB = renderer.outputColorSpace === 'srgb'\n      else isSRGB = renderer.outputEncoding === 3001 // sRGBEncoding\n\n      renderer.xr.enabled = false // avoid camera modification\n      renderer.shadowMap.autoUpdate = false // avoid re-computing shadows\n      if ('outputColorSpace' in renderer) renderer.outputColorSpace = 'srgb-linear'\n      else renderer.outputEncoding = 3000 // LinearEncoding\n      renderer.toneMapping = NoToneMapping\n\n      renderer.setRenderTarget(renderTarget)\n      if (renderer.autoClear === false) renderer.clear()\n      renderer.render(scene, virtualCamera)\n\n      renderer.xr.enabled = currentXrEnabled\n      renderer.shadowMap.autoUpdate = currentShadowAutoUpdate\n      renderer.toneMapping = currentToneMapping\n      renderer.setRenderTarget(currentRenderTarget)\n\n      if ('outputColorSpace' in renderer) renderer.outputColorSpace = isSRGB ? 'srgb' : 'srgb-linear'\n      else renderer.outputEncoding = isSRGB ? 3001 : 3000\n\n      // restore viewport\n\n      const viewport = camera.viewport\n\n      if (viewport !== undefined) {\n        renderer.state.viewport(viewport)\n      }\n\n      scope.visible = true\n    }\n\n    //\n\n    this.onBeforeRender = function (renderer, scene, camera) {\n      // ensure refractors are rendered only once per frame\n\n      if (camera.userData.refractor === true) return\n\n      // avoid rendering when the refractor is viewed from behind\n\n      if (!visible(camera) === true) return\n\n      // update\n\n      updateRefractorPlane()\n\n      updateTextureMatrix(camera)\n\n      updateVirtualCamera(camera)\n\n      render(renderer, scene, camera)\n    }\n\n    this.getRenderTarget = function () {\n      return renderTarget\n    }\n\n    this.dispose = function () {\n      renderTarget.dispose()\n      scope.material.dispose()\n    }\n  }\n}\n\nexport { Refractor }\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}