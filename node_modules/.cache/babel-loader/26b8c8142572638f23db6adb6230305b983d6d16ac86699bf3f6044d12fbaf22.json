{"ast":null,"code":"import _objectSpread from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _createForOfIteratorHelper from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _slicedToArray from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport * as THREE from 'three';\nimport { TextureLoader } from 'three';\nimport { useThree, useLoader } from '@react-three/fiber';\nimport * as React from 'react';\nimport { useState } from 'react';\n\n// utils\nvar getFirstItem = function getFirstItem(param) {\n  if (Array.isArray(param)) {\n    return param[0];\n  } else if (typeof param === 'object' && param !== null) {\n    var keys = Object.keys(param);\n    return param[keys[0]][0];\n  } else {\n    return {\n      w: 0,\n      h: 0\n    };\n  }\n};\nvar checkIfFrameIsEmpty = function checkIfFrameIsEmpty(frameData) {\n  for (var i = 3; i < frameData.length; i += 4) {\n    if (frameData[i] !== 0) {\n      return false;\n    }\n  }\n  return true;\n};\nvar calculateAspectRatio = function calculateAspectRatio(width, height, factor, v) {\n  var adaptedHeight = height * (v.aspect > width / height ? v.width / width : v.height / height);\n  var adaptedWidth = width * (v.aspect > width / height ? v.width / width : v.height / height);\n  var scaleX = adaptedWidth * factor;\n  var scaleY = adaptedHeight * factor;\n  var currentMaxScale = 1;\n  // Calculate the maximum scale based on the aspect ratio and max scale limit\n  var finalMaxScaleW = Math.min(currentMaxScale, scaleX);\n  var finalMaxScaleH = Math.min(currentMaxScale, scaleY);\n\n  // Ensure that scaleX and scaleY do not exceed the max scale while maintaining aspect ratio\n  if (scaleX > currentMaxScale) {\n    finalMaxScaleW = currentMaxScale;\n    finalMaxScaleH = scaleY / scaleX * currentMaxScale;\n  }\n  return new THREE.Vector3(finalMaxScaleW, finalMaxScaleH, 1);\n};\nfunction useSpriteLoader(input, json, animationNames, numberOfFrames, onLoad) {\n  var v = useThree(function (state) {\n    return state.viewport;\n  });\n  var spriteDataRef = React.useRef(null);\n  var totalFrames = React.useRef(0);\n  var aspectFactor = 0.1;\n  var _useState = useState(null),\n    _useState2 = _slicedToArray(_useState, 2),\n    spriteData = _useState2[0],\n    setSpriteData = _useState2[1];\n  var _React$useState = React.useState(new THREE.Texture()),\n    _React$useState2 = _slicedToArray(_React$useState, 2),\n    spriteTexture = _React$useState2[0],\n    setSpriteTexture = _React$useState2[1];\n  var textureLoader = new THREE.TextureLoader();\n  var _useState3 = useState(null),\n    _useState4 = _slicedToArray(_useState3, 2),\n    spriteObj = _useState4[0],\n    setSpriteObj = _useState4[1];\n  React.useLayoutEffect(function () {\n    if (json && input) {\n      loadJsonAndTextureAndExecuteCallback(json, input, parseSpriteData);\n    } else if (input) {\n      // only load the texture, this is an image sprite only\n      loadStandaloneSprite();\n    }\n    return function () {\n      if (input) {\n        useLoader.clear(TextureLoader, input);\n      }\n    };\n  }, []);\n  function loadJsonAndTexture(textureUrl, jsonUrl) {\n    if (jsonUrl && textureUrl) {\n      loadJsonAndTextureAndExecuteCallback(jsonUrl, textureUrl, parseSpriteData);\n    } else {\n      loadStandaloneSprite(textureUrl);\n    }\n  }\n  function loadStandaloneSprite(textureUrl) {\n    if (textureUrl || input) {\n      new Promise(function (resolve) {\n        textureLoader.load(textureUrl !== null && textureUrl !== void 0 ? textureUrl : input, resolve);\n      }).then(function (texture) {\n        parseSpriteData(null, texture);\n      });\n    }\n  }\n\n  /**\r\n   *\r\n   */\n  function loadJsonAndTextureAndExecuteCallback(jsonUrl, textureUrl, callback) {\n    var jsonPromise = fetch(jsonUrl).then(function (response) {\n      return response.json();\n    });\n    var texturePromise = new Promise(function (resolve) {\n      textureLoader.load(textureUrl, resolve);\n    });\n    Promise.all([jsonPromise, texturePromise]).then(function (response) {\n      callback(response[0], response[1]);\n    });\n  }\n  var parseSpriteData = function parseSpriteData(json, _spriteTexture) {\n    var aspect = new THREE.Vector3(1, 1, 1);\n    // sprite only case\n    if (json === null) {\n      if (_spriteTexture && numberOfFrames) {\n        //get size from texture\n        var width = _spriteTexture.image.width;\n        var height = _spriteTexture.image.height;\n        totalFrames.current = numberOfFrames;\n        var _getRowsAndColumns = getRowsAndColumns(_spriteTexture, numberOfFrames),\n          rows = _getRowsAndColumns.rows,\n          columns = _getRowsAndColumns.columns,\n          frameWidth = _getRowsAndColumns.frameWidth,\n          frameHeight = _getRowsAndColumns.frameHeight,\n          emptyFrames = _getRowsAndColumns.emptyFrames;\n        spriteDataRef.current = {\n          frames: [],\n          meta: {\n            version: '1.0',\n            size: {\n              w: width,\n              h: height\n            },\n            rows: rows,\n            columns: columns,\n            frameWidth: frameWidth,\n            frameHeight: frameHeight,\n            scale: '1'\n          }\n        };\n        var _loop = function _loop(row) {\n          var _loop2 = function _loop2(col) {\n            var isExcluded = (emptyFrames !== null && emptyFrames !== void 0 ? emptyFrames : []).some(function (coord) {\n              return coord.row === row && coord.col === col;\n            });\n            if (isExcluded) {\n              return 1; // continue\n            }\n            spriteDataRef.current.frames.push({\n              frame: {\n                x: col * frameWidth,\n                y: row * frameHeight,\n                w: frameWidth,\n                h: frameHeight\n              },\n              rotated: false,\n              trimmed: false,\n              spriteSourceSize: {\n                x: 0,\n                y: 0,\n                w: frameWidth,\n                h: frameHeight\n              },\n              sourceSize: {\n                w: frameWidth,\n                h: frameHeight\n              }\n            });\n          };\n          for (var col = 0; col < columns; col++) {\n            if (_loop2(col)) continue;\n          }\n        };\n        for (var row = 0; row < rows; row++) {\n          _loop(row);\n        }\n        aspect = calculateAspectRatio(frameWidth, frameHeight, aspectFactor, v);\n      }\n\n      //scale ratio for stadalone sprite\n      spriteDataRef.current.frames = calculateScaleRatio(spriteDataRef.current.frames);\n    } else if (_spriteTexture) {\n      spriteDataRef.current = json;\n      spriteDataRef.current.frames = parseFrames();\n      totalFrames.current = Array.isArray(json.frames) ? json.frames.length : Object.keys(json.frames).length;\n      var _getFirstItem$sourceS = getFirstItem(json.frames).sourceSize,\n        w = _getFirstItem$sourceS.w,\n        h = _getFirstItem$sourceS.h;\n      aspect = calculateAspectRatio(w, h, aspectFactor, v);\n    }\n    setSpriteData(spriteDataRef.current);\n    // @ts-ignore\n    if ('encoding' in _spriteTexture) _spriteTexture.encoding = 3001; // sRGBEncoding\n    // @ts-ignore\n    else _spriteTexture.colorSpace = THREE.SRGBColorSpace;\n    setSpriteTexture(_spriteTexture);\n    setSpriteObj({\n      spriteTexture: _spriteTexture,\n      spriteData: spriteDataRef.current,\n      aspect: aspect\n    });\n  };\n  var getRowsAndColumns = function getRowsAndColumns(texture, totalFrames) {\n    if (texture.image) {\n      var canvas = document.createElement('canvas');\n      var ctx = canvas.getContext('2d');\n      canvas.width = texture.image.width;\n      canvas.height = texture.image.height;\n      ctx.drawImage(texture.image, 0, 0);\n      var width = texture.image.width;\n      var height = texture.image.height;\n\n      // Calculate rows and columns based on the number of frames and image dimensions\n      var cols = Math.round(Math.sqrt(totalFrames * (width / height)));\n      var rows = Math.round(totalFrames / cols);\n      var frameWidth = width / cols;\n      var frameHeight = height / rows;\n      var emptyFrames = [];\n      for (var row = 0; row < rows; row++) {\n        for (var col = 0; col < cols; col++) {\n          var frameIndex = row * cols + col;\n          if (frameIndex >= totalFrames) {\n            emptyFrames.push({\n              row: row,\n              col: col\n            });\n            continue;\n          }\n          var frameData = ctx.getImageData(col * frameWidth, row * frameHeight, frameWidth, frameHeight).data;\n          var isEmpty = checkIfFrameIsEmpty(frameData);\n          if (isEmpty) {\n            emptyFrames.push({\n              row: row,\n              col: col\n            });\n          }\n        }\n      }\n      return {\n        rows: rows,\n        columns: cols,\n        frameWidth: frameWidth,\n        frameHeight: frameHeight,\n        emptyFrames: emptyFrames\n      };\n    } else {\n      return {\n        rows: 0,\n        columns: 0,\n        frameWidth: 0,\n        frameHeight: 0,\n        emptyFrames: []\n      };\n    }\n  };\n\n  // for frame based JSON Hash sprite data\n  var parseFrames = function parseFrames() {\n    var sprites = {};\n    var data = spriteDataRef.current;\n    var delimiters = animationNames;\n    if (delimiters && Array.isArray(data['frames'])) {\n      for (var i = 0; i < delimiters.length; i++) {\n        // we convert each named animation group into an array\n        sprites[delimiters[i]] = [];\n        var _iterator = _createForOfIteratorHelper(data['frames']),\n          _step;\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var value = _step.value;\n            var frameData = value['frame'];\n            var x = frameData['x'];\n            var y = frameData['y'];\n            var width = frameData['w'];\n            var height = frameData['h'];\n            var sourceWidth = value['sourceSize']['w'];\n            var sourceHeight = value['sourceSize']['h'];\n            if (typeof value['filename'] === 'string' && value['filename'].toLowerCase().indexOf(delimiters[i].toLowerCase()) !== -1) {\n              sprites[delimiters[i]].push({\n                x: x,\n                y: y,\n                w: width,\n                h: height,\n                frame: frameData,\n                sourceSize: {\n                  w: sourceWidth,\n                  h: sourceHeight\n                }\n              });\n            }\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n      }\n      for (var frame in sprites) {\n        sprites[frame].frame = calculateScaleRatio(sprites[frame]);\n      }\n      return sprites;\n    } else if (delimiters && typeof data['frames'] === 'object') {\n      for (var _i = 0; _i < delimiters.length; _i++) {\n        // we convert each named animation group into an array\n        sprites[delimiters[_i]] = [];\n        for (var innerKey in data['frames']) {\n          var _value = data['frames'][innerKey];\n          var _frameData = _value['frame'];\n          var _x = _frameData['x'];\n          var _y = _frameData['y'];\n          var _width = _frameData['w'];\n          var _height = _frameData['h'];\n          var _sourceWidth = _value['sourceSize']['w'];\n          var _sourceHeight = _value['sourceSize']['h'];\n          if (typeof innerKey === 'string' && innerKey.toLowerCase().indexOf(delimiters[_i].toLowerCase()) !== -1) {\n            sprites[delimiters[_i]].push({\n              x: _x,\n              y: _y,\n              w: _width,\n              h: _height,\n              frame: _frameData,\n              sourceSize: {\n                w: _sourceWidth,\n                h: _sourceHeight\n              }\n            });\n          }\n        }\n      }\n      for (var _frame in sprites) {\n        sprites[_frame].frame = calculateScaleRatio(sprites[_frame]);\n      }\n      return sprites;\n    } else {\n      // we need to convert it into an array\n      var spritesArr = [];\n      for (var key in data.frames) {\n        spritesArr.push(data.frames[key]);\n      }\n      spritesArr = calculateScaleRatio(spritesArr);\n      return spritesArr;\n    }\n  };\n\n  // calculate scale ratio for the frames\n  var calculateScaleRatio = function calculateScaleRatio(frames) {\n    // Find the largest frame\n    var largestFrame = null;\n    var _iterator2 = _createForOfIteratorHelper(frames),\n      _step2;\n    try {\n      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n        var frame = _step2.value;\n        var _frame$frame = frame.frame,\n          w = _frame$frame.w,\n          h = _frame$frame.h;\n        var area = w * h;\n        if (!largestFrame || area > largestFrame.area) {\n          largestFrame = _objectSpread(_objectSpread({}, frame.frame), {}, {\n            area: area\n          });\n        }\n      }\n\n      // Set scaleRatio property on each frame\n    } catch (err) {\n      _iterator2.e(err);\n    } finally {\n      _iterator2.f();\n    }\n    var _iterator3 = _createForOfIteratorHelper(frames),\n      _step3;\n    try {\n      for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n        var _frame2 = _step3.value;\n        var _largestFrame;\n        var _frame2$frame = _frame2.frame,\n          _w = _frame2$frame.w,\n          _h = _frame2$frame.h;\n        var _area = _w * _h;\n        if (_area === ((_largestFrame = largestFrame) == null ? void 0 : _largestFrame.area)) {\n          _frame2.scaleRatio = 1;\n        } else {\n          var _largestFrame2;\n          _frame2.scaleRatio = Math.sqrt(_area / ((_largestFrame2 = largestFrame) == null ? void 0 : _largestFrame2.area));\n        }\n      }\n    } catch (err) {\n      _iterator3.e(err);\n    } finally {\n      _iterator3.f();\n    }\n    return frames;\n  };\n  React.useLayoutEffect(function () {\n    onLoad == null || onLoad(spriteTexture, spriteData);\n  }, [spriteTexture, spriteData]);\n  return {\n    spriteObj: spriteObj,\n    loadJsonAndTexture: loadJsonAndTexture\n  };\n}\nuseSpriteLoader.preload = function (url) {\n  return useLoader.preload(TextureLoader, url);\n};\nuseSpriteLoader.clear = function (input) {\n  return useLoader.clear(TextureLoader, input);\n};\nexport { calculateAspectRatio, checkIfFrameIsEmpty, getFirstItem, useSpriteLoader };","map":{"version":3,"names":["THREE","TextureLoader","useThree","useLoader","React","useState","getFirstItem","param","Array","isArray","keys","Object","w","h","checkIfFrameIsEmpty","frameData","i","length","calculateAspectRatio","width","height","factor","v","adaptedHeight","aspect","adaptedWidth","scaleX","scaleY","currentMaxScale","finalMaxScaleW","Math","min","finalMaxScaleH","Vector3","useSpriteLoader","input","json","animationNames","numberOfFrames","onLoad","state","viewport","spriteDataRef","useRef","totalFrames","aspectFactor","_useState","_useState2","_slicedToArray","spriteData","setSpriteData","_React$useState","Texture","_React$useState2","spriteTexture","setSpriteTexture","textureLoader","_useState3","_useState4","spriteObj","setSpriteObj","useLayoutEffect","loadJsonAndTextureAndExecuteCallback","parseSpriteData","loadStandaloneSprite","clear","loadJsonAndTexture","textureUrl","jsonUrl","Promise","resolve","load","then","texture","callback","jsonPromise","fetch","response","texturePromise","all","_spriteTexture","image","current","_getRowsAndColumns","getRowsAndColumns","rows","columns","frameWidth","frameHeight","emptyFrames","frames","meta","version","size","scale","_loop","row","_loop2","col","isExcluded","some","coord","push","frame","x","y","rotated","trimmed","spriteSourceSize","sourceSize","calculateScaleRatio","parseFrames","_getFirstItem$sourceS","encoding","colorSpace","SRGBColorSpace","canvas","document","createElement","ctx","getContext","drawImage","cols","round","sqrt","frameIndex","getImageData","data","isEmpty","sprites","delimiters","_iterator","_createForOfIteratorHelper","_step","s","n","done","value","sourceWidth","sourceHeight","toLowerCase","indexOf","err","e","f","innerKey","spritesArr","key","largestFrame","_iterator2","_step2","_frame$frame","area","_objectSpread","_iterator3","_step3","_largestFrame","_frame2$frame","scaleRatio","_largestFrame2","preload","url"],"sources":["C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@react-three/drei/core/useSpriteLoader.js"],"sourcesContent":["import * as THREE from 'three';\nimport { TextureLoader } from 'three';\nimport { useThree, useLoader } from '@react-three/fiber';\nimport * as React from 'react';\nimport { useState } from 'react';\n\n// utils\nconst getFirstItem = param => {\n  if (Array.isArray(param)) {\n    return param[0];\n  } else if (typeof param === 'object' && param !== null) {\n    const keys = Object.keys(param);\n    return param[keys[0]][0];\n  } else {\n    return {\n      w: 0,\n      h: 0\n    };\n  }\n};\nconst checkIfFrameIsEmpty = frameData => {\n  for (let i = 3; i < frameData.length; i += 4) {\n    if (frameData[i] !== 0) {\n      return false;\n    }\n  }\n  return true;\n};\nconst calculateAspectRatio = (width, height, factor, v) => {\n  const adaptedHeight = height * (v.aspect > width / height ? v.width / width : v.height / height);\n  const adaptedWidth = width * (v.aspect > width / height ? v.width / width : v.height / height);\n  const scaleX = adaptedWidth * factor;\n  const scaleY = adaptedHeight * factor;\n  const currentMaxScale = 1;\n  // Calculate the maximum scale based on the aspect ratio and max scale limit\n  let finalMaxScaleW = Math.min(currentMaxScale, scaleX);\n  let finalMaxScaleH = Math.min(currentMaxScale, scaleY);\n\n  // Ensure that scaleX and scaleY do not exceed the max scale while maintaining aspect ratio\n  if (scaleX > currentMaxScale) {\n    finalMaxScaleW = currentMaxScale;\n    finalMaxScaleH = scaleY / scaleX * currentMaxScale;\n  }\n  return new THREE.Vector3(finalMaxScaleW, finalMaxScaleH, 1);\n};\nfunction useSpriteLoader(input, json, animationNames, numberOfFrames, onLoad) {\n  const v = useThree(state => state.viewport);\n  const spriteDataRef = React.useRef(null);\n  const totalFrames = React.useRef(0);\n  const aspectFactor = 0.1;\n  const [spriteData, setSpriteData] = useState(null);\n  const [spriteTexture, setSpriteTexture] = React.useState(new THREE.Texture());\n  const textureLoader = new THREE.TextureLoader();\n  const [spriteObj, setSpriteObj] = useState(null);\n  React.useLayoutEffect(() => {\n    if (json && input) {\n      loadJsonAndTextureAndExecuteCallback(json, input, parseSpriteData);\n    } else if (input) {\n      // only load the texture, this is an image sprite only\n      loadStandaloneSprite();\n    }\n    return () => {\n      if (input) {\n        useLoader.clear(TextureLoader, input);\n      }\n    };\n  }, []);\n  function loadJsonAndTexture(textureUrl, jsonUrl) {\n    if (jsonUrl && textureUrl) {\n      loadJsonAndTextureAndExecuteCallback(jsonUrl, textureUrl, parseSpriteData);\n    } else {\n      loadStandaloneSprite(textureUrl);\n    }\n  }\n  function loadStandaloneSprite(textureUrl) {\n    if (textureUrl || input) {\n      new Promise(resolve => {\n        textureLoader.load(textureUrl !== null && textureUrl !== void 0 ? textureUrl : input, resolve);\n      }).then(texture => {\n        parseSpriteData(null, texture);\n      });\n    }\n  }\n\n  /**\r\n   *\r\n   */\n  function loadJsonAndTextureAndExecuteCallback(jsonUrl, textureUrl, callback) {\n    const jsonPromise = fetch(jsonUrl).then(response => response.json());\n    const texturePromise = new Promise(resolve => {\n      textureLoader.load(textureUrl, resolve);\n    });\n    Promise.all([jsonPromise, texturePromise]).then(response => {\n      callback(response[0], response[1]);\n    });\n  }\n  const parseSpriteData = (json, _spriteTexture) => {\n    let aspect = new THREE.Vector3(1, 1, 1);\n    // sprite only case\n    if (json === null) {\n      if (_spriteTexture && numberOfFrames) {\n        //get size from texture\n        const width = _spriteTexture.image.width;\n        const height = _spriteTexture.image.height;\n        totalFrames.current = numberOfFrames;\n        const {\n          rows,\n          columns,\n          frameWidth,\n          frameHeight,\n          emptyFrames\n        } = getRowsAndColumns(_spriteTexture, numberOfFrames);\n        spriteDataRef.current = {\n          frames: [],\n          meta: {\n            version: '1.0',\n            size: {\n              w: width,\n              h: height\n            },\n            rows,\n            columns,\n            frameWidth,\n            frameHeight,\n            scale: '1'\n          }\n        };\n        for (let row = 0; row < rows; row++) {\n          for (let col = 0; col < columns; col++) {\n            const isExcluded = (emptyFrames !== null && emptyFrames !== void 0 ? emptyFrames : []).some(coord => coord.row === row && coord.col === col);\n            if (isExcluded) {\n              continue;\n            }\n            spriteDataRef.current.frames.push({\n              frame: {\n                x: col * frameWidth,\n                y: row * frameHeight,\n                w: frameWidth,\n                h: frameHeight\n              },\n              rotated: false,\n              trimmed: false,\n              spriteSourceSize: {\n                x: 0,\n                y: 0,\n                w: frameWidth,\n                h: frameHeight\n              },\n              sourceSize: {\n                w: frameWidth,\n                h: frameHeight\n              }\n            });\n          }\n        }\n        aspect = calculateAspectRatio(frameWidth, frameHeight, aspectFactor, v);\n      }\n\n      //scale ratio for stadalone sprite\n      spriteDataRef.current.frames = calculateScaleRatio(spriteDataRef.current.frames);\n    } else if (_spriteTexture) {\n      spriteDataRef.current = json;\n      spriteDataRef.current.frames = parseFrames();\n      totalFrames.current = Array.isArray(json.frames) ? json.frames.length : Object.keys(json.frames).length;\n      const {\n        w,\n        h\n      } = getFirstItem(json.frames).sourceSize;\n      aspect = calculateAspectRatio(w, h, aspectFactor, v);\n    }\n    setSpriteData(spriteDataRef.current);\n    // @ts-ignore\n    if ('encoding' in _spriteTexture) _spriteTexture.encoding = 3001; // sRGBEncoding\n    // @ts-ignore\n    else _spriteTexture.colorSpace = THREE.SRGBColorSpace;\n    setSpriteTexture(_spriteTexture);\n    setSpriteObj({\n      spriteTexture: _spriteTexture,\n      spriteData: spriteDataRef.current,\n      aspect: aspect\n    });\n  };\n  const getRowsAndColumns = (texture, totalFrames) => {\n    if (texture.image) {\n      const canvas = document.createElement('canvas');\n      const ctx = canvas.getContext('2d');\n      canvas.width = texture.image.width;\n      canvas.height = texture.image.height;\n      ctx.drawImage(texture.image, 0, 0);\n      const width = texture.image.width;\n      const height = texture.image.height;\n\n      // Calculate rows and columns based on the number of frames and image dimensions\n      const cols = Math.round(Math.sqrt(totalFrames * (width / height)));\n      const rows = Math.round(totalFrames / cols);\n      const frameWidth = width / cols;\n      const frameHeight = height / rows;\n      const emptyFrames = [];\n      for (let row = 0; row < rows; row++) {\n        for (let col = 0; col < cols; col++) {\n          const frameIndex = row * cols + col;\n          if (frameIndex >= totalFrames) {\n            emptyFrames.push({\n              row,\n              col\n            });\n            continue;\n          }\n          const frameData = ctx.getImageData(col * frameWidth, row * frameHeight, frameWidth, frameHeight).data;\n          const isEmpty = checkIfFrameIsEmpty(frameData);\n          if (isEmpty) {\n            emptyFrames.push({\n              row,\n              col\n            });\n          }\n        }\n      }\n      return {\n        rows,\n        columns: cols,\n        frameWidth,\n        frameHeight,\n        emptyFrames\n      };\n    } else {\n      return {\n        rows: 0,\n        columns: 0,\n        frameWidth: 0,\n        frameHeight: 0,\n        emptyFrames: []\n      };\n    }\n  };\n\n  // for frame based JSON Hash sprite data\n  const parseFrames = () => {\n    const sprites = {};\n    const data = spriteDataRef.current;\n    const delimiters = animationNames;\n    if (delimiters && Array.isArray(data['frames'])) {\n      for (let i = 0; i < delimiters.length; i++) {\n        // we convert each named animation group into an array\n        sprites[delimiters[i]] = [];\n        for (const value of data['frames']) {\n          const frameData = value['frame'];\n          const x = frameData['x'];\n          const y = frameData['y'];\n          const width = frameData['w'];\n          const height = frameData['h'];\n          const sourceWidth = value['sourceSize']['w'];\n          const sourceHeight = value['sourceSize']['h'];\n          if (typeof value['filename'] === 'string' && value['filename'].toLowerCase().indexOf(delimiters[i].toLowerCase()) !== -1) {\n            sprites[delimiters[i]].push({\n              x: x,\n              y: y,\n              w: width,\n              h: height,\n              frame: frameData,\n              sourceSize: {\n                w: sourceWidth,\n                h: sourceHeight\n              }\n            });\n          }\n        }\n      }\n      for (const frame in sprites) {\n        sprites[frame].frame = calculateScaleRatio(sprites[frame]);\n      }\n      return sprites;\n    } else if (delimiters && typeof data['frames'] === 'object') {\n      for (let i = 0; i < delimiters.length; i++) {\n        // we convert each named animation group into an array\n        sprites[delimiters[i]] = [];\n        for (const innerKey in data['frames']) {\n          const value = data['frames'][innerKey];\n          const frameData = value['frame'];\n          const x = frameData['x'];\n          const y = frameData['y'];\n          const width = frameData['w'];\n          const height = frameData['h'];\n          const sourceWidth = value['sourceSize']['w'];\n          const sourceHeight = value['sourceSize']['h'];\n          if (typeof innerKey === 'string' && innerKey.toLowerCase().indexOf(delimiters[i].toLowerCase()) !== -1) {\n            sprites[delimiters[i]].push({\n              x: x,\n              y: y,\n              w: width,\n              h: height,\n              frame: frameData,\n              sourceSize: {\n                w: sourceWidth,\n                h: sourceHeight\n              }\n            });\n          }\n        }\n      }\n      for (const frame in sprites) {\n        sprites[frame].frame = calculateScaleRatio(sprites[frame]);\n      }\n      return sprites;\n    } else {\n      // we need to convert it into an array\n      let spritesArr = [];\n      for (const key in data.frames) {\n        spritesArr.push(data.frames[key]);\n      }\n      spritesArr = calculateScaleRatio(spritesArr);\n      return spritesArr;\n    }\n  };\n\n  // calculate scale ratio for the frames\n  const calculateScaleRatio = frames => {\n    // Find the largest frame\n    let largestFrame = null;\n    for (const frame of frames) {\n      const {\n        w,\n        h\n      } = frame.frame;\n      const area = w * h;\n      if (!largestFrame || area > largestFrame.area) {\n        largestFrame = {\n          ...frame.frame,\n          area\n        };\n      }\n    }\n\n    // Set scaleRatio property on each frame\n    for (const frame of frames) {\n      var _largestFrame;\n      const {\n        w,\n        h\n      } = frame.frame;\n      const area = w * h;\n      if (area === ((_largestFrame = largestFrame) == null ? void 0 : _largestFrame.area)) {\n        frame.scaleRatio = 1;\n      } else {\n        var _largestFrame2;\n        frame.scaleRatio = Math.sqrt(area / ((_largestFrame2 = largestFrame) == null ? void 0 : _largestFrame2.area));\n      }\n    }\n    return frames;\n  };\n  React.useLayoutEffect(() => {\n    onLoad == null || onLoad(spriteTexture, spriteData);\n  }, [spriteTexture, spriteData]);\n  return {\n    spriteObj,\n    loadJsonAndTexture\n  };\n}\nuseSpriteLoader.preload = url => useLoader.preload(TextureLoader, url);\nuseSpriteLoader.clear = input => useLoader.clear(TextureLoader, input);\n\nexport { calculateAspectRatio, checkIfFrameIsEmpty, getFirstItem, useSpriteLoader };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}