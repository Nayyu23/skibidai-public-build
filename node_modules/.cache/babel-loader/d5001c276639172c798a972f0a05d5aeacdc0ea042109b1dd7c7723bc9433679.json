{"ast":null,"code":"import _classCallCheck from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport { Color, MathUtils } from \"three\";\nvar Lut = /*#__PURE__*/function () {\n  function Lut(colormap) {\n    var count = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 32;\n    _classCallCheck(this, Lut);\n    this.isLut = true;\n    this.lut = [];\n    this.map = [];\n    this.n = 0;\n    this.minV = 0;\n    this.maxV = 1;\n    this.setColorMap(colormap, count);\n  }\n  _createClass(Lut, [{\n    key: \"set\",\n    value: function set(value) {\n      if (value.isLut === true) {\n        this.copy(value);\n      }\n      return this;\n    }\n  }, {\n    key: \"setMin\",\n    value: function setMin(min) {\n      this.minV = min;\n      return this;\n    }\n  }, {\n    key: \"setMax\",\n    value: function setMax(max) {\n      this.maxV = max;\n      return this;\n    }\n  }, {\n    key: \"setColorMap\",\n    value: function setColorMap(colormap) {\n      var count = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 32;\n      this.map = ColorMapKeywords[colormap] || ColorMapKeywords.rainbow;\n      this.n = count;\n      var step = 1 / this.n;\n      var minColor = new Color();\n      var maxColor = new Color();\n      this.lut.length = 0;\n      this.lut.push(new Color(this.map[0][1]));\n      for (var i = 1; i < count; i++) {\n        var alpha = i * step;\n        for (var j = 0; j < this.map.length - 1; j++) {\n          if (alpha > this.map[j][0] && alpha <= this.map[j + 1][0]) {\n            var min = this.map[j][0];\n            var max = this.map[j + 1][0];\n            minColor.setHex(this.map[j][1], \"srgb-linear\");\n            maxColor.setHex(this.map[j + 1][1], \"srgb-linear\");\n            var color = new Color().lerpColors(minColor, maxColor, (alpha - min) / (max - min));\n            this.lut.push(color);\n          }\n        }\n      }\n      this.lut.push(new Color(this.map[this.map.length - 1][1]));\n      return this;\n    }\n  }, {\n    key: \"copy\",\n    value: function copy(lut) {\n      this.lut = lut.lut;\n      this.map = lut.map;\n      this.n = lut.n;\n      this.minV = lut.minV;\n      this.maxV = lut.maxV;\n      return this;\n    }\n  }, {\n    key: \"getColor\",\n    value: function getColor(alpha) {\n      alpha = MathUtils.clamp(alpha, this.minV, this.maxV);\n      alpha = (alpha - this.minV) / (this.maxV - this.minV);\n      var colorPosition = Math.round(alpha * this.n);\n      return this.lut[colorPosition];\n    }\n  }, {\n    key: \"addColorMap\",\n    value: function addColorMap(name, arrayOfColors) {\n      ColorMapKeywords[name] = arrayOfColors;\n      return this;\n    }\n  }, {\n    key: \"createCanvas\",\n    value: function createCanvas() {\n      var canvas = document.createElement(\"canvas\");\n      canvas.width = 1;\n      canvas.height = this.n;\n      this.updateCanvas(canvas);\n      return canvas;\n    }\n  }, {\n    key: \"updateCanvas\",\n    value: function updateCanvas(canvas) {\n      var ctx = canvas.getContext(\"2d\", {\n        alpha: false\n      });\n      var imageData = ctx.getImageData(0, 0, 1, this.n);\n      var data = imageData.data;\n      var k = 0;\n      var step = 1 / this.n;\n      var minColor = new Color();\n      var maxColor = new Color();\n      var finalColor = new Color();\n      for (var i = 1; i >= 0; i -= step) {\n        for (var j = this.map.length - 1; j >= 0; j--) {\n          if (i < this.map[j][0] && i >= this.map[j - 1][0]) {\n            var min = this.map[j - 1][0];\n            var max = this.map[j][0];\n            minColor.setHex(this.map[j - 1][1], \"srgb-linear\");\n            maxColor.setHex(this.map[j][1], \"srgb-linear\");\n            finalColor.lerpColors(minColor, maxColor, (i - min) / (max - min));\n            data[k * 4] = Math.round(finalColor.r * 255);\n            data[k * 4 + 1] = Math.round(finalColor.g * 255);\n            data[k * 4 + 2] = Math.round(finalColor.b * 255);\n            data[k * 4 + 3] = 255;\n            k += 1;\n          }\n        }\n      }\n      ctx.putImageData(imageData, 0, 0);\n      return canvas;\n    }\n  }]);\n  return Lut;\n}();\nvar ColorMapKeywords = {\n  rainbow: [[0, 255], [0.2, 65535], [0.5, 65280], [0.8, 16776960], [1, 16711680]],\n  cooltowarm: [[0, 3952322], [0.2, 10206463], [0.5, 14474460], [0.8, 16163717], [1, 11797542]],\n  blackbody: [[0, 0], [0.2, 7864320], [0.5, 15086080], [0.8, 16776960], [1, 16777215]],\n  grayscale: [[0, 0], [0.2, 4210752], [0.5, 8355712], [0.8, 12566463], [1, 16777215]]\n};\nexport { ColorMapKeywords, Lut };","map":{"version":3,"names":["Lut","colormap","count","arguments","length","undefined","_classCallCheck","isLut","lut","map","n","minV","maxV","setColorMap","_createClass","key","value","set","copy","setMin","min","setMax","max","ColorMapKeywords","rainbow","step","minColor","Color","maxColor","push","i","alpha","j","setHex","color","lerpColors","getColor","MathUtils","clamp","colorPosition","Math","round","addColorMap","name","arrayOfColors","createCanvas","canvas","document","createElement","width","height","updateCanvas","ctx","getContext","imageData","getImageData","data","k","finalColor","r","g","b","putImageData","cooltowarm","blackbody","grayscale"],"sources":["C:\\Users\\Nayyu\\Desktop\\skibidai-public-build\\node_modules\\src\\math\\Lut.js"],"sourcesContent":["import { Color, MathUtils } from 'three'\n\nclass Lut {\n  constructor(colormap, count = 32) {\n    this.isLut = true\n\n    this.lut = []\n    this.map = []\n    this.n = 0\n    this.minV = 0\n    this.maxV = 1\n\n    this.setColorMap(colormap, count)\n  }\n\n  set(value) {\n    if (value.isLut === true) {\n      this.copy(value)\n    }\n\n    return this\n  }\n\n  setMin(min) {\n    this.minV = min\n\n    return this\n  }\n\n  setMax(max) {\n    this.maxV = max\n\n    return this\n  }\n\n  setColorMap(colormap, count = 32) {\n    this.map = ColorMapKeywords[colormap] || ColorMapKeywords.rainbow\n    this.n = count\n\n    const step = 1.0 / this.n\n    const minColor = new Color()\n    const maxColor = new Color()\n\n    this.lut.length = 0\n\n    // sample at 0\n\n    this.lut.push(new Color(this.map[0][1]))\n\n    // sample at 1/n, ..., (n-1)/n\n\n    for (let i = 1; i < count; i++) {\n      const alpha = i * step\n\n      for (let j = 0; j < this.map.length - 1; j++) {\n        if (alpha > this.map[j][0] && alpha <= this.map[j + 1][0]) {\n          const min = this.map[j][0]\n          const max = this.map[j + 1][0]\n\n          minColor.setHex(this.map[j][1], 'srgb-linear')\n          maxColor.setHex(this.map[j + 1][1], 'srgb-linear')\n\n          const color = new Color().lerpColors(minColor, maxColor, (alpha - min) / (max - min))\n\n          this.lut.push(color)\n        }\n      }\n    }\n\n    // sample at 1\n\n    this.lut.push(new Color(this.map[this.map.length - 1][1]))\n\n    return this\n  }\n\n  copy(lut) {\n    this.lut = lut.lut\n    this.map = lut.map\n    this.n = lut.n\n    this.minV = lut.minV\n    this.maxV = lut.maxV\n\n    return this\n  }\n\n  getColor(alpha) {\n    alpha = MathUtils.clamp(alpha, this.minV, this.maxV)\n\n    alpha = (alpha - this.minV) / (this.maxV - this.minV)\n\n    const colorPosition = Math.round(alpha * this.n)\n\n    return this.lut[colorPosition]\n  }\n\n  addColorMap(name, arrayOfColors) {\n    ColorMapKeywords[name] = arrayOfColors\n\n    return this\n  }\n\n  createCanvas() {\n    const canvas = document.createElement('canvas')\n    canvas.width = 1\n    canvas.height = this.n\n\n    this.updateCanvas(canvas)\n\n    return canvas\n  }\n\n  updateCanvas(canvas) {\n    const ctx = canvas.getContext('2d', { alpha: false })\n\n    const imageData = ctx.getImageData(0, 0, 1, this.n)\n\n    const data = imageData.data\n\n    let k = 0\n\n    const step = 1.0 / this.n\n\n    const minColor = new Color()\n    const maxColor = new Color()\n    const finalColor = new Color()\n\n    for (let i = 1; i >= 0; i -= step) {\n      for (let j = this.map.length - 1; j >= 0; j--) {\n        if (i < this.map[j][0] && i >= this.map[j - 1][0]) {\n          const min = this.map[j - 1][0]\n          const max = this.map[j][0]\n\n          minColor.setHex(this.map[j - 1][1], 'srgb-linear')\n          maxColor.setHex(this.map[j][1], 'srgb-linear')\n\n          finalColor.lerpColors(minColor, maxColor, (i - min) / (max - min))\n\n          data[k * 4] = Math.round(finalColor.r * 255)\n          data[k * 4 + 1] = Math.round(finalColor.g * 255)\n          data[k * 4 + 2] = Math.round(finalColor.b * 255)\n          data[k * 4 + 3] = 255\n\n          k += 1\n        }\n      }\n    }\n\n    ctx.putImageData(imageData, 0, 0)\n\n    return canvas\n  }\n}\n\nconst ColorMapKeywords = {\n  rainbow: [\n    [0.0, 0x0000ff],\n    [0.2, 0x00ffff],\n    [0.5, 0x00ff00],\n    [0.8, 0xffff00],\n    [1.0, 0xff0000],\n  ],\n  cooltowarm: [\n    [0.0, 0x3c4ec2],\n    [0.2, 0x9bbcff],\n    [0.5, 0xdcdcdc],\n    [0.8, 0xf6a385],\n    [1.0, 0xb40426],\n  ],\n  blackbody: [\n    [0.0, 0x000000],\n    [0.2, 0x780000],\n    [0.5, 0xe63200],\n    [0.8, 0xffff00],\n    [1.0, 0xffffff],\n  ],\n  grayscale: [\n    [0.0, 0x000000],\n    [0.2, 0x404040],\n    [0.5, 0x7f7f80],\n    [0.8, 0xbfbfbf],\n    [1.0, 0xffffff],\n  ],\n}\n\nexport { Lut, ColorMapKeywords }\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}