{"ast":null,"code":"import _classCallCheck from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _inherits from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport { Loader, FileLoader, LineBasicMaterial, Group, Euler, BufferGeometry, Float32BufferAttribute, LineSegments } from \"three\";\nvar GCodeLoader = /*#__PURE__*/function (_Loader) {\n  _inherits(GCodeLoader, _Loader);\n  var _super = _createSuper(GCodeLoader);\n  function GCodeLoader(manager) {\n    var _this;\n    _classCallCheck(this, GCodeLoader);\n    _this = _super.call(this, manager);\n    _this.splitLayer = false;\n    return _this;\n  }\n  _createClass(GCodeLoader, [{\n    key: \"load\",\n    value: function load(url, onLoad, onProgress, onError) {\n      var scope = this;\n      var loader = new FileLoader(scope.manager);\n      loader.setPath(scope.path);\n      loader.setRequestHeader(scope.requestHeader);\n      loader.setWithCredentials(scope.withCredentials);\n      loader.load(url, function (text) {\n        try {\n          onLoad(scope.parse(text));\n        } catch (e) {\n          if (onError) {\n            onError(e);\n          } else {\n            console.error(e);\n          }\n          scope.manager.itemError(url);\n        }\n      }, onProgress, onError);\n    }\n  }, {\n    key: \"parse\",\n    value: function parse(data) {\n      var state = {\n        x: 0,\n        y: 0,\n        z: 0,\n        e: 0,\n        f: 0,\n        extruding: false,\n        relative: false\n      };\n      var layers = [];\n      var currentLayer = void 0;\n      var pathMaterial = new LineBasicMaterial({\n        color: 16711680\n      });\n      pathMaterial.name = \"path\";\n      var extrudingMaterial = new LineBasicMaterial({\n        color: 65280\n      });\n      extrudingMaterial.name = \"extruded\";\n      function newLayer(line) {\n        currentLayer = {\n          vertex: [],\n          pathVertex: [],\n          z: line.z\n        };\n        layers.push(currentLayer);\n      }\n      function addSegment(p1, p2) {\n        if (currentLayer === void 0) {\n          newLayer(p1);\n        }\n        if (state.extruding) {\n          currentLayer.vertex.push(p1.x, p1.y, p1.z);\n          currentLayer.vertex.push(p2.x, p2.y, p2.z);\n        } else {\n          currentLayer.pathVertex.push(p1.x, p1.y, p1.z);\n          currentLayer.pathVertex.push(p2.x, p2.y, p2.z);\n        }\n      }\n      function delta(v1, v2) {\n        return state.relative ? v2 : v2 - v1;\n      }\n      function absolute(v1, v2) {\n        return state.relative ? v1 + v2 : v2;\n      }\n      var lines = data.replace(/;.+/g, \"\").split(\"\\n\");\n      var _loop = function _loop() {\n        var tokens = lines[i].split(\" \");\n        var cmd = tokens[0].toUpperCase();\n        var args = {};\n        tokens.splice(1).forEach(function (token) {\n          if (token[0] !== void 0) {\n            var key = token[0].toLowerCase();\n            var value = parseFloat(token.substring(1));\n            args[key] = value;\n          }\n        });\n        if (cmd === \"G0\" || cmd === \"G1\") {\n          var line = {\n            x: args.x !== void 0 ? absolute(state.x, args.x) : state.x,\n            y: args.y !== void 0 ? absolute(state.y, args.y) : state.y,\n            z: args.z !== void 0 ? absolute(state.z, args.z) : state.z,\n            e: args.e !== void 0 ? absolute(state.e, args.e) : state.e,\n            f: args.f !== void 0 ? absolute(state.f, args.f) : state.f\n          };\n          if (delta(state.e, line.e) > 0) {\n            line.extruding = delta(state.e, line.e) > 0;\n            if (currentLayer == void 0 || line.z != currentLayer.z) {\n              newLayer(line);\n            }\n          }\n          addSegment(state, line);\n          state = line;\n        } else if (cmd === \"G2\" || cmd === \"G3\") ;else if (cmd === \"G90\") {\n          state.relative = false;\n        } else if (cmd === \"G91\") {\n          state.relative = true;\n        } else if (cmd === \"G92\") {\n          var _line = state;\n          _line.x = args.x !== void 0 ? args.x : _line.x;\n          _line.y = args.y !== void 0 ? args.y : _line.y;\n          _line.z = args.z !== void 0 ? args.z : _line.z;\n          _line.e = args.e !== void 0 ? args.e : _line.e;\n          state = _line;\n        } else ;\n      };\n      for (var i = 0; i < lines.length; i++) {\n        _loop();\n      }\n      function addObject(vertex, extruding, i) {\n        var geometry = new BufferGeometry();\n        geometry.setAttribute(\"position\", new Float32BufferAttribute(vertex, 3));\n        var segments = new LineSegments(geometry, extruding ? extrudingMaterial : pathMaterial);\n        segments.name = \"layer\" + i;\n        object.add(segments);\n      }\n      var object = new Group();\n      object.name = \"gcode\";\n      if (this.splitLayer) {\n        for (var _i = 0; _i < layers.length; _i++) {\n          var layer = layers[_i];\n          addObject(layer.vertex, true, _i);\n          addObject(layer.pathVertex, false, _i);\n        }\n      } else {\n        var vertex = [],\n          pathVertex = [];\n        for (var _i2 = 0; _i2 < layers.length; _i2++) {\n          var _layer = layers[_i2];\n          var layerVertex = _layer.vertex;\n          var layerPathVertex = _layer.pathVertex;\n          for (var j = 0; j < layerVertex.length; j++) {\n            vertex.push(layerVertex[j]);\n          }\n          for (var _j = 0; _j < layerPathVertex.length; _j++) {\n            pathVertex.push(layerPathVertex[_j]);\n          }\n        }\n        addObject(vertex, true, layers.length);\n        addObject(pathVertex, false, layers.length);\n      }\n      object.quaternion.setFromEuler(new Euler(-Math.PI / 2, 0, 0));\n      return object;\n    }\n  }]);\n  return GCodeLoader;\n}(Loader);\nexport { GCodeLoader };","map":{"version":3,"names":["GCodeLoader","_Loader","_inherits","_super","_createSuper","manager","_this","_classCallCheck","call","splitLayer","_createClass","key","value","load","url","onLoad","onProgress","onError","scope","loader","FileLoader","setPath","path","setRequestHeader","requestHeader","setWithCredentials","withCredentials","text","parse","e","console","error","itemError","data","state","x","y","z","f","extruding","relative","layers","currentLayer","pathMaterial","LineBasicMaterial","color","name","extrudingMaterial","newLayer","line","vertex","pathVertex","push","addSegment","p1","p2","delta","v1","v2","absolute","lines","replace","split","_loop","tokens","i","cmd","toUpperCase","args","splice","forEach","token","toLowerCase","parseFloat","substring","length","addObject","geometry","BufferGeometry","setAttribute","Float32BufferAttribute","segments","LineSegments","object","add","Group","layer","layerVertex","layerPathVertex","j","quaternion","setFromEuler","Euler","Math","PI","Loader"],"sources":["C:\\Users\\Nayyu\\Desktop\\skibidai-public-build\\node_modules\\src\\loaders\\GCodeLoader.js"],"sourcesContent":["import {\n  BufferGeometry,\n  Euler,\n  FileLoader,\n  Float32BufferAttribute,\n  Group,\n  LineBasicMaterial,\n  LineSegments,\n  Loader,\n} from 'three'\n\n/**\n * GCodeLoader is used to load gcode files usually used for 3D printing or CNC applications.\n *\n * Gcode files are composed by commands used by machines to create objects.\n *\n * @class GCodeLoader\n * @param {Manager} manager Loading manager.\n */\n\nclass GCodeLoader extends Loader {\n  constructor(manager) {\n    super(manager)\n\n    this.splitLayer = false\n  }\n\n  load(url, onLoad, onProgress, onError) {\n    const scope = this\n\n    const loader = new FileLoader(scope.manager)\n    loader.setPath(scope.path)\n    loader.setRequestHeader(scope.requestHeader)\n    loader.setWithCredentials(scope.withCredentials)\n    loader.load(\n      url,\n      function (text) {\n        try {\n          onLoad(scope.parse(text))\n        } catch (e) {\n          if (onError) {\n            onError(e)\n          } else {\n            console.error(e)\n          }\n\n          scope.manager.itemError(url)\n        }\n      },\n      onProgress,\n      onError,\n    )\n  }\n\n  parse(data) {\n    let state = { x: 0, y: 0, z: 0, e: 0, f: 0, extruding: false, relative: false }\n    let layers = []\n\n    let currentLayer = undefined\n\n    const pathMaterial = new LineBasicMaterial({ color: 0xff0000 })\n    pathMaterial.name = 'path'\n\n    const extrudingMaterial = new LineBasicMaterial({ color: 0x00ff00 })\n    extrudingMaterial.name = 'extruded'\n\n    function newLayer(line) {\n      currentLayer = { vertex: [], pathVertex: [], z: line.z }\n      layers.push(currentLayer)\n    }\n\n    //Create lie segment between p1 and p2\n    function addSegment(p1, p2) {\n      if (currentLayer === undefined) {\n        newLayer(p1)\n      }\n\n      if (state.extruding) {\n        currentLayer.vertex.push(p1.x, p1.y, p1.z)\n        currentLayer.vertex.push(p2.x, p2.y, p2.z)\n      } else {\n        currentLayer.pathVertex.push(p1.x, p1.y, p1.z)\n        currentLayer.pathVertex.push(p2.x, p2.y, p2.z)\n      }\n    }\n\n    function delta(v1, v2) {\n      return state.relative ? v2 : v2 - v1\n    }\n\n    function absolute(v1, v2) {\n      return state.relative ? v1 + v2 : v2\n    }\n\n    let lines = data.replace(/;.+/g, '').split('\\n')\n\n    for (let i = 0; i < lines.length; i++) {\n      let tokens = lines[i].split(' ')\n      let cmd = tokens[0].toUpperCase()\n\n      //Argumments\n      let args = {}\n      tokens.splice(1).forEach(function (token) {\n        if (token[0] !== undefined) {\n          let key = token[0].toLowerCase()\n          let value = parseFloat(token.substring(1))\n          args[key] = value\n        }\n      })\n\n      //Process commands\n      //G0/G1 – Linear Movement\n      if (cmd === 'G0' || cmd === 'G1') {\n        let line = {\n          x: args.x !== undefined ? absolute(state.x, args.x) : state.x,\n          y: args.y !== undefined ? absolute(state.y, args.y) : state.y,\n          z: args.z !== undefined ? absolute(state.z, args.z) : state.z,\n          e: args.e !== undefined ? absolute(state.e, args.e) : state.e,\n          f: args.f !== undefined ? absolute(state.f, args.f) : state.f,\n        }\n\n        //Layer change detection is or made by watching Z, it's made by watching when we extrude at a new Z position\n        if (delta(state.e, line.e) > 0) {\n          line.extruding = delta(state.e, line.e) > 0\n\n          if (currentLayer == undefined || line.z != currentLayer.z) {\n            newLayer(line)\n          }\n        }\n\n        addSegment(state, line)\n        state = line\n      } else if (cmd === 'G2' || cmd === 'G3') {\n        //G2/G3 - Arc Movement ( G2 clock wise and G3 counter clock wise )\n        //console.warn( 'THREE.GCodeLoader: Arc command not supported' );\n      } else if (cmd === 'G90') {\n        //G90: Set to Absolute Positioning\n        state.relative = false\n      } else if (cmd === 'G91') {\n        //G91: Set to state.relative Positioning\n        state.relative = true\n      } else if (cmd === 'G92') {\n        //G92: Set Position\n        let line = state\n        line.x = args.x !== undefined ? args.x : line.x\n        line.y = args.y !== undefined ? args.y : line.y\n        line.z = args.z !== undefined ? args.z : line.z\n        line.e = args.e !== undefined ? args.e : line.e\n        state = line\n      } else {\n        //console.warn( 'THREE.GCodeLoader: Command not supported:' + cmd );\n      }\n    }\n\n    function addObject(vertex, extruding, i) {\n      let geometry = new BufferGeometry()\n      geometry.setAttribute('position', new Float32BufferAttribute(vertex, 3))\n      let segments = new LineSegments(geometry, extruding ? extrudingMaterial : pathMaterial)\n      segments.name = 'layer' + i\n      object.add(segments)\n    }\n\n    const object = new Group()\n    object.name = 'gcode'\n\n    if (this.splitLayer) {\n      for (let i = 0; i < layers.length; i++) {\n        let layer = layers[i]\n        addObject(layer.vertex, true, i)\n        addObject(layer.pathVertex, false, i)\n      }\n    } else {\n      const vertex = [],\n        pathVertex = []\n\n      for (let i = 0; i < layers.length; i++) {\n        let layer = layers[i]\n        let layerVertex = layer.vertex\n        let layerPathVertex = layer.pathVertex\n\n        for (let j = 0; j < layerVertex.length; j++) {\n          vertex.push(layerVertex[j])\n        }\n\n        for (let j = 0; j < layerPathVertex.length; j++) {\n          pathVertex.push(layerPathVertex[j])\n        }\n      }\n\n      addObject(vertex, true, layers.length)\n      addObject(pathVertex, false, layers.length)\n    }\n\n    object.quaternion.setFromEuler(new Euler(-Math.PI / 2, 0, 0))\n\n    return object\n  }\n}\n\nexport { GCodeLoader }\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}