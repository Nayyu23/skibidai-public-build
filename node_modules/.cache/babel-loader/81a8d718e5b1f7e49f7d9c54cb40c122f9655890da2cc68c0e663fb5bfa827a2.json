{"ast":null,"code":"import _classCallCheck from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport { Object3D, Vector3, Quaternion, AnimationMixer } from \"three\";\nimport { CCDIKSolver } from \"./CCDIKSolver.js\";\nimport { MMDPhysics } from \"./MMDPhysics.js\";\nvar MMDAnimationHelper = /*#__PURE__*/function () {\n  /**\n   * @param {Object} params - (optional)\n   * @param {boolean} params.sync - Whether animation durations of added objects are synched. Default is true.\n   * @param {Number} params.afterglow - Default is 0.0.\n   * @param {boolean} params.resetPhysicsOnLoop - Default is true.\n   */\n  function MMDAnimationHelper() {\n    var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    _classCallCheck(this, MMDAnimationHelper);\n    this.meshes = [];\n    this.camera = null;\n    this.cameraTarget = new Object3D();\n    this.cameraTarget.name = \"target\";\n    this.audio = null;\n    this.audioManager = null;\n    this.objects = /* @__PURE__ */new WeakMap();\n    this.configuration = {\n      sync: params.sync !== void 0 ? params.sync : true,\n      afterglow: params.afterglow !== void 0 ? params.afterglow : 0,\n      resetPhysicsOnLoop: params.resetPhysicsOnLoop !== void 0 ? params.resetPhysicsOnLoop : true,\n      pmxAnimation: params.pmxAnimation !== void 0 ? params.pmxAnimation : false\n    };\n    this.enabled = {\n      animation: true,\n      ik: true,\n      grant: true,\n      physics: true,\n      cameraAnimation: true\n    };\n    this.onBeforePhysics = function () {};\n    this.sharedPhysics = false;\n    this.masterPhysics = null;\n  }\n  /**\n   * Adds an Three.js Object to helper and setups animation.\n   * The anmation durations of added objects are synched\n   * if this.configuration.sync is true.\n   *\n   * @param {THREE.SkinnedMesh|THREE.Camera|THREE.Audio} object\n   * @param {Object} params - (optional)\n   * @param {THREE.AnimationClip|Array<THREE.AnimationClip>} params.animation - Only for THREE.SkinnedMesh and THREE.Camera. Default is undefined.\n   * @param {boolean} params.physics - Only for THREE.SkinnedMesh. Default is true.\n   * @param {Integer} params.warmup - Only for THREE.SkinnedMesh and physics is true. Default is 60.\n   * @param {Number} params.unitStep - Only for THREE.SkinnedMesh and physics is true. Default is 1 / 65.\n   * @param {Integer} params.maxStepNum - Only for THREE.SkinnedMesh and physics is true. Default is 3.\n   * @param {Vector3} params.gravity - Only for THREE.SkinnedMesh and physics is true. Default ( 0, - 9.8 * 10, 0 ).\n   * @param {Number} params.delayTime - Only for THREE.Audio. Default is 0.0.\n   * @return {MMDAnimationHelper}\n   */\n  _createClass(MMDAnimationHelper, [{\n    key: \"add\",\n    value: function add(object) {\n      var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      if (object.isSkinnedMesh) {\n        this._addMesh(object, params);\n      } else if (object.isCamera) {\n        this._setupCamera(object, params);\n      } else if (object.type === \"Audio\") {\n        this._setupAudio(object, params);\n      } else {\n        throw new Error(\"THREE.MMDAnimationHelper.add: accepts only THREE.SkinnedMesh or THREE.Camera or THREE.Audio instance.\");\n      }\n      if (this.configuration.sync) this._syncDuration();\n      return this;\n    }\n    /**\n     * Removes an Three.js Object from helper.\n     *\n     * @param {THREE.SkinnedMesh|THREE.Camera|THREE.Audio} object\n     * @return {MMDAnimationHelper}\n     */\n  }, {\n    key: \"remove\",\n    value: function remove(object) {\n      if (object.isSkinnedMesh) {\n        this._removeMesh(object);\n      } else if (object.isCamera) {\n        this._clearCamera(object);\n      } else if (object.type === \"Audio\") {\n        this._clearAudio(object);\n      } else {\n        throw new Error(\"THREE.MMDAnimationHelper.remove: accepts only THREE.SkinnedMesh or THREE.Camera or THREE.Audio instance.\");\n      }\n      if (this.configuration.sync) this._syncDuration();\n      return this;\n    }\n    /**\n     * Updates the animation.\n     *\n     * @param {Number} delta\n     * @return {MMDAnimationHelper}\n     */\n  }, {\n    key: \"update\",\n    value: function update(delta) {\n      if (this.audioManager !== null) this.audioManager.control(delta);\n      for (var i = 0; i < this.meshes.length; i++) {\n        this._animateMesh(this.meshes[i], delta);\n      }\n      if (this.sharedPhysics) this._updateSharedPhysics(delta);\n      if (this.camera !== null) this._animateCamera(this.camera, delta);\n      return this;\n    }\n    /**\n     * Changes the pose of SkinnedMesh as VPD specifies.\n     *\n     * @param {THREE.SkinnedMesh} mesh\n     * @param {Object} vpd - VPD content parsed MMDParser\n     * @param {Object} params - (optional)\n     * @param {boolean} params.resetPose - Default is true.\n     * @param {boolean} params.ik - Default is true.\n     * @param {boolean} params.grant - Default is true.\n     * @return {MMDAnimationHelper}\n     */\n  }, {\n    key: \"pose\",\n    value: function pose(mesh, vpd) {\n      var params = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      if (params.resetPose !== false) mesh.pose();\n      var bones = mesh.skeleton.bones;\n      var boneParams = vpd.bones;\n      var boneNameDictionary = {};\n      for (var i = 0, il = bones.length; i < il; i++) {\n        boneNameDictionary[bones[i].name] = i;\n      }\n      var vector = new Vector3();\n      var quaternion = new Quaternion();\n      for (var _i = 0, _il = boneParams.length; _i < _il; _i++) {\n        var boneParam = boneParams[_i];\n        var boneIndex = boneNameDictionary[boneParam.name];\n        if (boneIndex === void 0) continue;\n        var bone = bones[boneIndex];\n        bone.position.add(vector.fromArray(boneParam.translation));\n        bone.quaternion.multiply(quaternion.fromArray(boneParam.quaternion));\n      }\n      mesh.updateMatrixWorld(true);\n      if (this.configuration.pmxAnimation && mesh.geometry.userData.MMD && mesh.geometry.userData.MMD.format === \"pmx\") {\n        var sortedBonesData = this._sortBoneDataArray(mesh.geometry.userData.MMD.bones.slice());\n        var ikSolver = params.ik !== false ? this._createCCDIKSolver(mesh) : null;\n        var grantSolver = params.grant !== false ? this.createGrantSolver(mesh) : null;\n        this._animatePMXMesh(mesh, sortedBonesData, ikSolver, grantSolver);\n      } else {\n        if (params.ik !== false) {\n          this._createCCDIKSolver(mesh).update();\n        }\n        if (params.grant !== false) {\n          this.createGrantSolver(mesh).update();\n        }\n      }\n      return this;\n    }\n    /**\n     * Enabes/Disables an animation feature.\n     *\n     * @param {string} key\n     * @param {boolean} enabled\n     * @return {MMDAnimationHelper}\n     */\n  }, {\n    key: \"enable\",\n    value: function enable(key, enabled) {\n      if (this.enabled[key] === void 0) {\n        throw new Error(\"THREE.MMDAnimationHelper.enable: unknown key \" + key);\n      }\n      this.enabled[key] = enabled;\n      if (key === \"physics\") {\n        for (var i = 0, il = this.meshes.length; i < il; i++) {\n          this._optimizeIK(this.meshes[i], enabled);\n        }\n      }\n      return this;\n    }\n    /**\n     * Creates an GrantSolver instance.\n     *\n     * @param {THREE.SkinnedMesh} mesh\n     * @return {GrantSolver}\n     */\n  }, {\n    key: \"createGrantSolver\",\n    value: function createGrantSolver(mesh) {\n      return new GrantSolver(mesh, mesh.geometry.userData.MMD.grants);\n    }\n    // private methods\n  }, {\n    key: \"_addMesh\",\n    value: function _addMesh(mesh, params) {\n      if (this.meshes.indexOf(mesh) >= 0) {\n        throw new Error(\"THREE.MMDAnimationHelper._addMesh: SkinnedMesh '\" + mesh.name + \"' has already been added.\");\n      }\n      this.meshes.push(mesh);\n      this.objects.set(mesh, {\n        looped: false\n      });\n      this._setupMeshAnimation(mesh, params.animation);\n      if (params.physics !== false) {\n        this._setupMeshPhysics(mesh, params);\n      }\n      return this;\n    }\n  }, {\n    key: \"_setupCamera\",\n    value: function _setupCamera(camera, params) {\n      if (this.camera === camera) {\n        throw new Error(\"THREE.MMDAnimationHelper._setupCamera: Camera '\" + camera.name + \"' has already been set.\");\n      }\n      if (this.camera) this.clearCamera(this.camera);\n      this.camera = camera;\n      camera.add(this.cameraTarget);\n      this.objects.set(camera, {});\n      if (params.animation !== void 0) {\n        this._setupCameraAnimation(camera, params.animation);\n      }\n      return this;\n    }\n  }, {\n    key: \"_setupAudio\",\n    value: function _setupAudio(audio, params) {\n      if (this.audio === audio) {\n        throw new Error(\"THREE.MMDAnimationHelper._setupAudio: Audio '\" + audio.name + \"' has already been set.\");\n      }\n      if (this.audio) this.clearAudio(this.audio);\n      this.audio = audio;\n      this.audioManager = new AudioManager(audio, params);\n      this.objects.set(this.audioManager, {\n        duration: this.audioManager.duration\n      });\n      return this;\n    }\n  }, {\n    key: \"_removeMesh\",\n    value: function _removeMesh(mesh) {\n      var found = false;\n      var writeIndex = 0;\n      for (var i = 0, il = this.meshes.length; i < il; i++) {\n        if (this.meshes[i] === mesh) {\n          this.objects.delete(mesh);\n          found = true;\n          continue;\n        }\n        this.meshes[writeIndex++] = this.meshes[i];\n      }\n      if (!found) {\n        throw new Error(\"THREE.MMDAnimationHelper._removeMesh: SkinnedMesh '\" + mesh.name + \"' has not been added yet.\");\n      }\n      this.meshes.length = writeIndex;\n      return this;\n    }\n  }, {\n    key: \"_clearCamera\",\n    value: function _clearCamera(camera) {\n      if (camera !== this.camera) {\n        throw new Error(\"THREE.MMDAnimationHelper._clearCamera: Camera '\" + camera.name + \"' has not been set yet.\");\n      }\n      this.camera.remove(this.cameraTarget);\n      this.objects.delete(this.camera);\n      this.camera = null;\n      return this;\n    }\n  }, {\n    key: \"_clearAudio\",\n    value: function _clearAudio(audio) {\n      if (audio !== this.audio) {\n        throw new Error(\"THREE.MMDAnimationHelper._clearAudio: Audio '\" + audio.name + \"' has not been set yet.\");\n      }\n      this.objects.delete(this.audioManager);\n      this.audio = null;\n      this.audioManager = null;\n      return this;\n    }\n  }, {\n    key: \"_setupMeshAnimation\",\n    value: function _setupMeshAnimation(mesh, animation) {\n      var objects = this.objects.get(mesh);\n      if (animation !== void 0) {\n        var animations = Array.isArray(animation) ? animation : [animation];\n        objects.mixer = new AnimationMixer(mesh);\n        for (var i = 0, il = animations.length; i < il; i++) {\n          objects.mixer.clipAction(animations[i]).play();\n        }\n        objects.mixer.addEventListener(\"loop\", function (event) {\n          var tracks = event.action._clip.tracks;\n          if (tracks.length > 0 && tracks[0].name.slice(0, 6) !== \".bones\") return;\n          objects.looped = true;\n        });\n      }\n      objects.ikSolver = this._createCCDIKSolver(mesh);\n      objects.grantSolver = this.createGrantSolver(mesh);\n      return this;\n    }\n  }, {\n    key: \"_setupCameraAnimation\",\n    value: function _setupCameraAnimation(camera, animation) {\n      var animations = Array.isArray(animation) ? animation : [animation];\n      var objects = this.objects.get(camera);\n      objects.mixer = new AnimationMixer(camera);\n      for (var i = 0, il = animations.length; i < il; i++) {\n        objects.mixer.clipAction(animations[i]).play();\n      }\n    }\n  }, {\n    key: \"_setupMeshPhysics\",\n    value: function _setupMeshPhysics(mesh, params) {\n      var objects = this.objects.get(mesh);\n      if (params.world === void 0 && this.sharedPhysics) {\n        var masterPhysics = this._getMasterPhysics();\n        if (masterPhysics !== null) world = masterPhysics.world;\n      }\n      objects.physics = this._createMMDPhysics(mesh, params);\n      if (objects.mixer && params.animationWarmup !== false) {\n        this._animateMesh(mesh, 0);\n        objects.physics.reset();\n      }\n      objects.physics.warmup(params.warmup !== void 0 ? params.warmup : 60);\n      this._optimizeIK(mesh, true);\n    }\n  }, {\n    key: \"_animateMesh\",\n    value: function _animateMesh(mesh, delta) {\n      var objects = this.objects.get(mesh);\n      var mixer = objects.mixer;\n      var ikSolver = objects.ikSolver;\n      var grantSolver = objects.grantSolver;\n      var physics = objects.physics;\n      var looped = objects.looped;\n      if (mixer && this.enabled.animation) {\n        this._restoreBones(mesh);\n        mixer.update(delta);\n        this._saveBones(mesh);\n        if (this.configuration.pmxAnimation && mesh.geometry.userData.MMD && mesh.geometry.userData.MMD.format === \"pmx\") {\n          if (!objects.sortedBonesData) objects.sortedBonesData = this._sortBoneDataArray(mesh.geometry.userData.MMD.bones.slice());\n          this._animatePMXMesh(mesh, objects.sortedBonesData, ikSolver && this.enabled.ik ? ikSolver : null, grantSolver && this.enabled.grant ? grantSolver : null);\n        } else {\n          if (ikSolver && this.enabled.ik) {\n            mesh.updateMatrixWorld(true);\n            ikSolver.update();\n          }\n          if (grantSolver && this.enabled.grant) {\n            grantSolver.update();\n          }\n        }\n      }\n      if (looped === true && this.enabled.physics) {\n        if (physics && this.configuration.resetPhysicsOnLoop) physics.reset();\n        objects.looped = false;\n      }\n      if (physics && this.enabled.physics && !this.sharedPhysics) {\n        this.onBeforePhysics(mesh);\n        physics.update(delta);\n      }\n    }\n    // Sort bones in order by 1. transformationClass and 2. bone index.\n    // In PMX animation system, bone transformations should be processed\n    // in this order.\n  }, {\n    key: \"_sortBoneDataArray\",\n    value: function _sortBoneDataArray(boneDataArray) {\n      return boneDataArray.sort(function (a, b) {\n        if (a.transformationClass !== b.transformationClass) {\n          return a.transformationClass - b.transformationClass;\n        } else {\n          return a.index - b.index;\n        }\n      });\n    }\n    // PMX Animation system is a bit too complex and doesn't great match to\n    // Three.js Animation system. This method attempts to simulate it as much as\n    // possible but doesn't perfectly simulate.\n    // This method is more costly than the regular one so\n    // you are recommended to set constructor parameter \"pmxAnimation: true\"\n    // only if your PMX model animation doesn't work well.\n    // If you need better method you would be required to write your own.\n  }, {\n    key: \"_animatePMXMesh\",\n    value: function _animatePMXMesh(mesh, sortedBonesData, ikSolver, grantSolver) {\n      _quaternionIndex = 0;\n      _grantResultMap.clear();\n      for (var i = 0, il = sortedBonesData.length; i < il; i++) {\n        updateOne(mesh, sortedBonesData[i].index, ikSolver, grantSolver);\n      }\n      mesh.updateMatrixWorld(true);\n      return this;\n    }\n  }, {\n    key: \"_animateCamera\",\n    value: function _animateCamera(camera, delta) {\n      var mixer = this.objects.get(camera).mixer;\n      if (mixer && this.enabled.cameraAnimation) {\n        mixer.update(delta);\n        camera.updateProjectionMatrix();\n        camera.up.set(0, 1, 0);\n        camera.up.applyQuaternion(camera.quaternion);\n        camera.lookAt(this.cameraTarget.position);\n      }\n    }\n  }, {\n    key: \"_optimizeIK\",\n    value: function _optimizeIK(mesh, physicsEnabled) {\n      var iks = mesh.geometry.userData.MMD.iks;\n      var bones = mesh.geometry.userData.MMD.bones;\n      for (var i = 0, il = iks.length; i < il; i++) {\n        var ik = iks[i];\n        var links = ik.links;\n        for (var j = 0, jl = links.length; j < jl; j++) {\n          var link = links[j];\n          if (physicsEnabled === true) {\n            link.enabled = bones[link.index].rigidBodyType > 0 ? false : true;\n          } else {\n            link.enabled = true;\n          }\n        }\n      }\n    }\n  }, {\n    key: \"_createCCDIKSolver\",\n    value: function _createCCDIKSolver(mesh) {\n      if (CCDIKSolver === void 0) {\n        throw new Error(\"THREE.MMDAnimationHelper: Import CCDIKSolver.\");\n      }\n      return new CCDIKSolver(mesh, mesh.geometry.userData.MMD.iks);\n    }\n  }, {\n    key: \"_createMMDPhysics\",\n    value: function _createMMDPhysics(mesh, params) {\n      if (MMDPhysics === void 0) {\n        throw new Error(\"THREE.MMDPhysics: Import MMDPhysics.\");\n      }\n      return new MMDPhysics(mesh, mesh.geometry.userData.MMD.rigidBodies, mesh.geometry.userData.MMD.constraints, params);\n    }\n    /*\n     * Detects the longest duration and then sets it to them to sync.\n     * TODO: Not to access private properties ( ._actions and ._clip )\n     */\n  }, {\n    key: \"_syncDuration\",\n    value: function _syncDuration() {\n      var max = 0;\n      var objects = this.objects;\n      var meshes = this.meshes;\n      var camera = this.camera;\n      var audioManager = this.audioManager;\n      for (var i = 0, il = meshes.length; i < il; i++) {\n        var mixer = this.objects.get(meshes[i]).mixer;\n        if (mixer === void 0) continue;\n        for (var j = 0; j < mixer._actions.length; j++) {\n          var clip = mixer._actions[j]._clip;\n          if (!objects.has(clip)) {\n            objects.set(clip, {\n              duration: clip.duration\n            });\n          }\n          max = Math.max(max, objects.get(clip).duration);\n        }\n      }\n      if (camera !== null) {\n        var _mixer = this.objects.get(camera).mixer;\n        if (_mixer !== void 0) {\n          for (var _i2 = 0, _il2 = _mixer._actions.length; _i2 < _il2; _i2++) {\n            var _clip = _mixer._actions[_i2]._clip;\n            if (!objects.has(_clip)) {\n              objects.set(_clip, {\n                duration: _clip.duration\n              });\n            }\n            max = Math.max(max, objects.get(_clip).duration);\n          }\n        }\n      }\n      if (audioManager !== null) {\n        max = Math.max(max, objects.get(audioManager).duration);\n      }\n      max += this.configuration.afterglow;\n      for (var _i3 = 0, _il3 = this.meshes.length; _i3 < _il3; _i3++) {\n        var _mixer2 = this.objects.get(this.meshes[_i3]).mixer;\n        if (_mixer2 === void 0) continue;\n        for (var _j = 0, jl = _mixer2._actions.length; _j < jl; _j++) {\n          _mixer2._actions[_j]._clip.duration = max;\n        }\n      }\n      if (camera !== null) {\n        var _mixer3 = this.objects.get(camera).mixer;\n        if (_mixer3 !== void 0) {\n          for (var _i4 = 0, _il4 = _mixer3._actions.length; _i4 < _il4; _i4++) {\n            _mixer3._actions[_i4]._clip.duration = max;\n          }\n        }\n      }\n      if (audioManager !== null) {\n        audioManager.duration = max;\n      }\n    }\n    // workaround\n  }, {\n    key: \"_updatePropertyMixersBuffer\",\n    value: function _updatePropertyMixersBuffer(mesh) {\n      var mixer = this.objects.get(mesh).mixer;\n      var propertyMixers = mixer._bindings;\n      var accuIndex = mixer._accuIndex;\n      for (var i = 0, il = propertyMixers.length; i < il; i++) {\n        var propertyMixer = propertyMixers[i];\n        var buffer = propertyMixer.buffer;\n        var stride = propertyMixer.valueSize;\n        var offset = (accuIndex + 1) * stride;\n        propertyMixer.binding.getValue(buffer, offset);\n      }\n    }\n    /*\n     * Avoiding these two issues by restore/save bones before/after mixer animation.\n     *\n     * 1. PropertyMixer used by AnimationMixer holds cache value in .buffer.\n     *    Calculating IK, Grant, and Physics after mixer animation can break\n     *    the cache coherency.\n     *\n     * 2. Applying Grant two or more times without reset the posing breaks model.\n     */\n  }, {\n    key: \"_saveBones\",\n    value: function _saveBones(mesh) {\n      var objects = this.objects.get(mesh);\n      var bones = mesh.skeleton.bones;\n      var backupBones = objects.backupBones;\n      if (backupBones === void 0) {\n        backupBones = new Float32Array(bones.length * 7);\n        objects.backupBones = backupBones;\n      }\n      for (var i = 0, il = bones.length; i < il; i++) {\n        var bone = bones[i];\n        bone.position.toArray(backupBones, i * 7);\n        bone.quaternion.toArray(backupBones, i * 7 + 3);\n      }\n    }\n  }, {\n    key: \"_restoreBones\",\n    value: function _restoreBones(mesh) {\n      var objects = this.objects.get(mesh);\n      var backupBones = objects.backupBones;\n      if (backupBones === void 0) return;\n      var bones = mesh.skeleton.bones;\n      for (var i = 0, il = bones.length; i < il; i++) {\n        var bone = bones[i];\n        bone.position.fromArray(backupBones, i * 7);\n        bone.quaternion.fromArray(backupBones, i * 7 + 3);\n      }\n    }\n    // experimental\n  }, {\n    key: \"_getMasterPhysics\",\n    value: function _getMasterPhysics() {\n      if (this.masterPhysics !== null) return this.masterPhysics;\n      for (var i = 0, il = this.meshes.length; i < il; i++) {\n        var physics = this.meshes[i].physics;\n        if (physics !== void 0 && physics !== null) {\n          this.masterPhysics = physics;\n          return this.masterPhysics;\n        }\n      }\n      return null;\n    }\n  }, {\n    key: \"_updateSharedPhysics\",\n    value: function _updateSharedPhysics(delta) {\n      if (this.meshes.length === 0 || !this.enabled.physics || !this.sharedPhysics) return;\n      var physics = this._getMasterPhysics();\n      if (physics === null) return;\n      for (var i = 0, il = this.meshes.length; i < il; i++) {\n        var p = this.meshes[i].physics;\n        if (p !== null && p !== void 0) {\n          p.updateRigidBodies();\n        }\n      }\n      physics.stepSimulation(delta);\n      for (var _i5 = 0, _il5 = this.meshes.length; _i5 < _il5; _i5++) {\n        var _p = this.meshes[_i5].physics;\n        if (_p !== null && _p !== void 0) {\n          _p.updateBones();\n        }\n      }\n    }\n  }]);\n  return MMDAnimationHelper;\n}();\nvar _quaternions = [];\nvar _quaternionIndex = 0;\nfunction getQuaternion() {\n  if (_quaternionIndex >= _quaternions.length) {\n    _quaternions.push(new Quaternion());\n  }\n  return _quaternions[_quaternionIndex++];\n}\nvar _grantResultMap = /* @__PURE__ */new Map();\nfunction updateOne(mesh, boneIndex, ikSolver, grantSolver) {\n  var bones = mesh.skeleton.bones;\n  var bonesData = mesh.geometry.userData.MMD.bones;\n  var boneData = bonesData[boneIndex];\n  var bone = bones[boneIndex];\n  if (_grantResultMap.has(boneIndex)) return;\n  var quaternion = getQuaternion();\n  _grantResultMap.set(boneIndex, quaternion.copy(bone.quaternion));\n  if (grantSolver && boneData.grant && !boneData.grant.isLocal && boneData.grant.affectRotation) {\n    var parentIndex = boneData.grant.parentIndex;\n    var ratio = boneData.grant.ratio;\n    if (!_grantResultMap.has(parentIndex)) {\n      updateOne(mesh, parentIndex, ikSolver, grantSolver);\n    }\n    grantSolver.addGrantRotation(bone, _grantResultMap.get(parentIndex), ratio);\n  }\n  if (ikSolver && boneData.ik) {\n    mesh.updateMatrixWorld(true);\n    ikSolver.updateOne(boneData.ik);\n    var links = boneData.ik.links;\n    for (var i = 0, il = links.length; i < il; i++) {\n      var link = links[i];\n      if (link.enabled === false) continue;\n      var linkIndex = link.index;\n      if (_grantResultMap.has(linkIndex)) {\n        _grantResultMap.set(linkIndex, _grantResultMap.get(linkIndex).copy(bones[linkIndex].quaternion));\n      }\n    }\n  }\n  quaternion.copy(bone.quaternion);\n}\nvar AudioManager = /*#__PURE__*/function () {\n  /**\n   * @param {THREE.Audio} audio\n   * @param {Object} params - (optional)\n   * @param {Nuumber} params.delayTime\n   */\n  function AudioManager(audio) {\n    var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    _classCallCheck(this, AudioManager);\n    this.audio = audio;\n    this.elapsedTime = 0;\n    this.currentTime = 0;\n    this.delayTime = params.delayTime !== void 0 ? params.delayTime : 0;\n    this.audioDuration = this.audio.buffer.duration;\n    this.duration = this.audioDuration + this.delayTime;\n  }\n  /**\n   * @param {Number} delta\n   * @return {AudioManager}\n   */\n  _createClass(AudioManager, [{\n    key: \"control\",\n    value: function control(delta) {\n      this.elapsed += delta;\n      this.currentTime += delta;\n      if (this._shouldStopAudio()) this.audio.stop();\n      if (this._shouldStartAudio()) this.audio.play();\n      return this;\n    }\n    // private methods\n  }, {\n    key: \"_shouldStartAudio\",\n    value: function _shouldStartAudio() {\n      if (this.audio.isPlaying) return false;\n      while (this.currentTime >= this.duration) {\n        this.currentTime -= this.duration;\n      }\n      if (this.currentTime < this.delayTime) return false;\n      if (this.currentTime - this.delayTime > this.audioDuration) return false;\n      return true;\n    }\n  }, {\n    key: \"_shouldStopAudio\",\n    value: function _shouldStopAudio() {\n      return this.audio.isPlaying && this.currentTime >= this.duration;\n    }\n  }]);\n  return AudioManager;\n}();\nvar _q = new Quaternion();\nvar GrantSolver = /*#__PURE__*/function () {\n  function GrantSolver(mesh) {\n    var grants = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    _classCallCheck(this, GrantSolver);\n    this.mesh = mesh;\n    this.grants = grants;\n  }\n  /**\n   * Solve all the grant bones\n   * @return {GrantSolver}\n   */\n  _createClass(GrantSolver, [{\n    key: \"update\",\n    value: function update() {\n      var grants = this.grants;\n      for (var i = 0, il = grants.length; i < il; i++) {\n        this.updateOne(grants[i]);\n      }\n      return this;\n    }\n    /**\n     * Solve a grant bone\n     * @param {Object} grant - grant parameter\n     * @return {GrantSolver}\n     */\n  }, {\n    key: \"updateOne\",\n    value: function updateOne(grant) {\n      var bones = this.mesh.skeleton.bones;\n      var bone = bones[grant.index];\n      var parentBone = bones[grant.parentIndex];\n      if (grant.isLocal) {\n        if (grant.affectPosition) ;\n        if (grant.affectRotation) ;\n      } else {\n        if (grant.affectPosition) ;\n        if (grant.affectRotation) {\n          this.addGrantRotation(bone, parentBone.quaternion, grant.ratio);\n        }\n      }\n      return this;\n    }\n  }, {\n    key: \"addGrantRotation\",\n    value: function addGrantRotation(bone, q, ratio) {\n      _q.set(0, 0, 0, 1);\n      _q.slerp(q, ratio);\n      bone.quaternion.multiply(_q);\n      return this;\n    }\n  }]);\n  return GrantSolver;\n}();\nexport { MMDAnimationHelper };","map":{"version":3,"names":["MMDAnimationHelper","params","arguments","length","undefined","_classCallCheck","meshes","camera","cameraTarget","Object3D","name","audio","audioManager","objects","WeakMap","configuration","sync","afterglow","resetPhysicsOnLoop","pmxAnimation","enabled","animation","ik","grant","physics","cameraAnimation","onBeforePhysics","sharedPhysics","masterPhysics","_createClass","key","value","add","object","isSkinnedMesh","_addMesh","isCamera","_setupCamera","type","_setupAudio","Error","_syncDuration","remove","_removeMesh","_clearCamera","_clearAudio","update","delta","control","i","_animateMesh","_updateSharedPhysics","_animateCamera","pose","mesh","vpd","resetPose","bones","skeleton","boneParams","boneNameDictionary","il","vector","Vector3","quaternion","Quaternion","boneParam","boneIndex","bone","position","fromArray","translation","multiply","updateMatrixWorld","geometry","userData","MMD","format","sortedBonesData","_sortBoneDataArray","slice","ikSolver","_createCCDIKSolver","grantSolver","createGrantSolver","_animatePMXMesh","enable","_optimizeIK","GrantSolver","grants","indexOf","push","set","looped","_setupMeshAnimation","_setupMeshPhysics","clearCamera","_setupCameraAnimation","clearAudio","AudioManager","duration","found","writeIndex","delete","get","animations","Array","isArray","mixer","AnimationMixer","clipAction","play","addEventListener","event","tracks","action","_clip","world","_getMasterPhysics","_createMMDPhysics","animationWarmup","reset","warmup","_restoreBones","_saveBones","boneDataArray","sort","a","b","transformationClass","index","_quaternionIndex","_grantResultMap","clear","updateOne","updateProjectionMatrix","up","applyQuaternion","lookAt","physicsEnabled","iks","links","j","jl","link","rigidBodyType","CCDIKSolver","MMDPhysics","rigidBodies","constraints","max","_actions","clip","has","Math","_updatePropertyMixersBuffer","propertyMixers","_bindings","accuIndex","_accuIndex","propertyMixer","buffer","stride","valueSize","offset","binding","getValue","backupBones","Float32Array","toArray","p","updateRigidBodies","stepSimulation","updateBones","_quaternions","getQuaternion","Map","bonesData","boneData","copy","isLocal","affectRotation","parentIndex","ratio","addGrantRotation","linkIndex","elapsedTime","currentTime","delayTime","audioDuration","elapsed","_shouldStopAudio","stop","_shouldStartAudio","isPlaying","_q","parentBone","affectPosition","q","slerp"],"sources":["C:\\Users\\Nayyu\\Desktop\\skibidai-public-build\\node_modules\\src\\animation\\MMDAnimationHelper.js"],"sourcesContent":["import { AnimationMixer, Object3D, Quaternion, Vector3 } from 'three'\nimport { CCDIKSolver } from '../animation/CCDIKSolver'\nimport { MMDPhysics } from '../animation/MMDPhysics'\n\n/**\n * MMDAnimationHelper handles animation of MMD assets loaded by MMDLoader\n * with MMD special features as IK, Grant, and Physics.\n *\n * Dependencies\n *  - ammo.js https://github.com/kripken/ammo.js\n *  - MMDPhysics\n *  - CCDIKSolver\n *\n * TODO\n *  - more precise grant skinning support.\n */\nclass MMDAnimationHelper {\n  /**\n   * @param {Object} params - (optional)\n   * @param {boolean} params.sync - Whether animation durations of added objects are synched. Default is true.\n   * @param {Number} params.afterglow - Default is 0.0.\n   * @param {boolean} params.resetPhysicsOnLoop - Default is true.\n   */\n  constructor(params = {}) {\n    this.meshes = []\n\n    this.camera = null\n    this.cameraTarget = new Object3D()\n    this.cameraTarget.name = 'target'\n\n    this.audio = null\n    this.audioManager = null\n\n    this.objects = new WeakMap()\n\n    this.configuration = {\n      sync: params.sync !== undefined ? params.sync : true,\n      afterglow: params.afterglow !== undefined ? params.afterglow : 0.0,\n      resetPhysicsOnLoop: params.resetPhysicsOnLoop !== undefined ? params.resetPhysicsOnLoop : true,\n      pmxAnimation: params.pmxAnimation !== undefined ? params.pmxAnimation : false,\n    }\n\n    this.enabled = {\n      animation: true,\n      ik: true,\n      grant: true,\n      physics: true,\n      cameraAnimation: true,\n    }\n\n    this.onBeforePhysics = function (/* mesh */) {}\n\n    // experimental\n    this.sharedPhysics = false\n    this.masterPhysics = null\n  }\n\n  /**\n   * Adds an Three.js Object to helper and setups animation.\n   * The anmation durations of added objects are synched\n   * if this.configuration.sync is true.\n   *\n   * @param {THREE.SkinnedMesh|THREE.Camera|THREE.Audio} object\n   * @param {Object} params - (optional)\n   * @param {THREE.AnimationClip|Array<THREE.AnimationClip>} params.animation - Only for THREE.SkinnedMesh and THREE.Camera. Default is undefined.\n   * @param {boolean} params.physics - Only for THREE.SkinnedMesh. Default is true.\n   * @param {Integer} params.warmup - Only for THREE.SkinnedMesh and physics is true. Default is 60.\n   * @param {Number} params.unitStep - Only for THREE.SkinnedMesh and physics is true. Default is 1 / 65.\n   * @param {Integer} params.maxStepNum - Only for THREE.SkinnedMesh and physics is true. Default is 3.\n   * @param {Vector3} params.gravity - Only for THREE.SkinnedMesh and physics is true. Default ( 0, - 9.8 * 10, 0 ).\n   * @param {Number} params.delayTime - Only for THREE.Audio. Default is 0.0.\n   * @return {MMDAnimationHelper}\n   */\n  add(object, params = {}) {\n    if (object.isSkinnedMesh) {\n      this._addMesh(object, params)\n    } else if (object.isCamera) {\n      this._setupCamera(object, params)\n    } else if (object.type === 'Audio') {\n      this._setupAudio(object, params)\n    } else {\n      throw new Error(\n        'THREE.MMDAnimationHelper.add: ' +\n          'accepts only ' +\n          'THREE.SkinnedMesh or ' +\n          'THREE.Camera or ' +\n          'THREE.Audio instance.',\n      )\n    }\n\n    if (this.configuration.sync) this._syncDuration()\n\n    return this\n  }\n\n  /**\n   * Removes an Three.js Object from helper.\n   *\n   * @param {THREE.SkinnedMesh|THREE.Camera|THREE.Audio} object\n   * @return {MMDAnimationHelper}\n   */\n  remove(object) {\n    if (object.isSkinnedMesh) {\n      this._removeMesh(object)\n    } else if (object.isCamera) {\n      this._clearCamera(object)\n    } else if (object.type === 'Audio') {\n      this._clearAudio(object)\n    } else {\n      throw new Error(\n        'THREE.MMDAnimationHelper.remove: ' +\n          'accepts only ' +\n          'THREE.SkinnedMesh or ' +\n          'THREE.Camera or ' +\n          'THREE.Audio instance.',\n      )\n    }\n\n    if (this.configuration.sync) this._syncDuration()\n\n    return this\n  }\n\n  /**\n   * Updates the animation.\n   *\n   * @param {Number} delta\n   * @return {MMDAnimationHelper}\n   */\n  update(delta) {\n    if (this.audioManager !== null) this.audioManager.control(delta)\n\n    for (let i = 0; i < this.meshes.length; i++) {\n      this._animateMesh(this.meshes[i], delta)\n    }\n\n    if (this.sharedPhysics) this._updateSharedPhysics(delta)\n\n    if (this.camera !== null) this._animateCamera(this.camera, delta)\n\n    return this\n  }\n\n  /**\n   * Changes the pose of SkinnedMesh as VPD specifies.\n   *\n   * @param {THREE.SkinnedMesh} mesh\n   * @param {Object} vpd - VPD content parsed MMDParser\n   * @param {Object} params - (optional)\n   * @param {boolean} params.resetPose - Default is true.\n   * @param {boolean} params.ik - Default is true.\n   * @param {boolean} params.grant - Default is true.\n   * @return {MMDAnimationHelper}\n   */\n  pose(mesh, vpd, params = {}) {\n    if (params.resetPose !== false) mesh.pose()\n\n    const bones = mesh.skeleton.bones\n    const boneParams = vpd.bones\n\n    const boneNameDictionary = {}\n\n    for (let i = 0, il = bones.length; i < il; i++) {\n      boneNameDictionary[bones[i].name] = i\n    }\n\n    const vector = new Vector3()\n    const quaternion = new Quaternion()\n\n    for (let i = 0, il = boneParams.length; i < il; i++) {\n      const boneParam = boneParams[i]\n      const boneIndex = boneNameDictionary[boneParam.name]\n\n      if (boneIndex === undefined) continue\n\n      const bone = bones[boneIndex]\n      bone.position.add(vector.fromArray(boneParam.translation))\n      bone.quaternion.multiply(quaternion.fromArray(boneParam.quaternion))\n    }\n\n    mesh.updateMatrixWorld(true)\n\n    // PMX animation system special path\n    if (this.configuration.pmxAnimation && mesh.geometry.userData.MMD && mesh.geometry.userData.MMD.format === 'pmx') {\n      const sortedBonesData = this._sortBoneDataArray(mesh.geometry.userData.MMD.bones.slice())\n      const ikSolver = params.ik !== false ? this._createCCDIKSolver(mesh) : null\n      const grantSolver = params.grant !== false ? this.createGrantSolver(mesh) : null\n      this._animatePMXMesh(mesh, sortedBonesData, ikSolver, grantSolver)\n    } else {\n      if (params.ik !== false) {\n        this._createCCDIKSolver(mesh).update()\n      }\n\n      if (params.grant !== false) {\n        this.createGrantSolver(mesh).update()\n      }\n    }\n\n    return this\n  }\n\n  /**\n   * Enabes/Disables an animation feature.\n   *\n   * @param {string} key\n   * @param {boolean} enabled\n   * @return {MMDAnimationHelper}\n   */\n  enable(key, enabled) {\n    if (this.enabled[key] === undefined) {\n      throw new Error('THREE.MMDAnimationHelper.enable: ' + 'unknown key ' + key)\n    }\n\n    this.enabled[key] = enabled\n\n    if (key === 'physics') {\n      for (let i = 0, il = this.meshes.length; i < il; i++) {\n        this._optimizeIK(this.meshes[i], enabled)\n      }\n    }\n\n    return this\n  }\n\n  /**\n   * Creates an GrantSolver instance.\n   *\n   * @param {THREE.SkinnedMesh} mesh\n   * @return {GrantSolver}\n   */\n  createGrantSolver(mesh) {\n    return new GrantSolver(mesh, mesh.geometry.userData.MMD.grants)\n  }\n\n  // private methods\n\n  _addMesh(mesh, params) {\n    if (this.meshes.indexOf(mesh) >= 0) {\n      throw new Error('THREE.MMDAnimationHelper._addMesh: ' + \"SkinnedMesh '\" + mesh.name + \"' has already been added.\")\n    }\n\n    this.meshes.push(mesh)\n    this.objects.set(mesh, { looped: false })\n\n    this._setupMeshAnimation(mesh, params.animation)\n\n    if (params.physics !== false) {\n      this._setupMeshPhysics(mesh, params)\n    }\n\n    return this\n  }\n\n  _setupCamera(camera, params) {\n    if (this.camera === camera) {\n      throw new Error('THREE.MMDAnimationHelper._setupCamera: ' + \"Camera '\" + camera.name + \"' has already been set.\")\n    }\n\n    if (this.camera) this.clearCamera(this.camera)\n\n    this.camera = camera\n\n    camera.add(this.cameraTarget)\n\n    this.objects.set(camera, {})\n\n    if (params.animation !== undefined) {\n      this._setupCameraAnimation(camera, params.animation)\n    }\n\n    return this\n  }\n\n  _setupAudio(audio, params) {\n    if (this.audio === audio) {\n      throw new Error('THREE.MMDAnimationHelper._setupAudio: ' + \"Audio '\" + audio.name + \"' has already been set.\")\n    }\n\n    if (this.audio) this.clearAudio(this.audio)\n\n    this.audio = audio\n    this.audioManager = new AudioManager(audio, params)\n\n    this.objects.set(this.audioManager, {\n      duration: this.audioManager.duration,\n    })\n\n    return this\n  }\n\n  _removeMesh(mesh) {\n    let found = false\n    let writeIndex = 0\n\n    for (let i = 0, il = this.meshes.length; i < il; i++) {\n      if (this.meshes[i] === mesh) {\n        this.objects.delete(mesh)\n        found = true\n\n        continue\n      }\n\n      this.meshes[writeIndex++] = this.meshes[i]\n    }\n\n    if (!found) {\n      throw new Error(\n        'THREE.MMDAnimationHelper._removeMesh: ' + \"SkinnedMesh '\" + mesh.name + \"' has not been added yet.\",\n      )\n    }\n\n    this.meshes.length = writeIndex\n\n    return this\n  }\n\n  _clearCamera(camera) {\n    if (camera !== this.camera) {\n      throw new Error('THREE.MMDAnimationHelper._clearCamera: ' + \"Camera '\" + camera.name + \"' has not been set yet.\")\n    }\n\n    this.camera.remove(this.cameraTarget)\n\n    this.objects.delete(this.camera)\n    this.camera = null\n\n    return this\n  }\n\n  _clearAudio(audio) {\n    if (audio !== this.audio) {\n      throw new Error('THREE.MMDAnimationHelper._clearAudio: ' + \"Audio '\" + audio.name + \"' has not been set yet.\")\n    }\n\n    this.objects.delete(this.audioManager)\n\n    this.audio = null\n    this.audioManager = null\n\n    return this\n  }\n\n  _setupMeshAnimation(mesh, animation) {\n    const objects = this.objects.get(mesh)\n\n    if (animation !== undefined) {\n      const animations = Array.isArray(animation) ? animation : [animation]\n\n      objects.mixer = new AnimationMixer(mesh)\n\n      for (let i = 0, il = animations.length; i < il; i++) {\n        objects.mixer.clipAction(animations[i]).play()\n      }\n\n      // TODO: find a workaround not to access ._clip looking like a private property\n      objects.mixer.addEventListener('loop', function (event) {\n        const tracks = event.action._clip.tracks\n\n        if (tracks.length > 0 && tracks[0].name.slice(0, 6) !== '.bones') return\n\n        objects.looped = true\n      })\n    }\n\n    objects.ikSolver = this._createCCDIKSolver(mesh)\n    objects.grantSolver = this.createGrantSolver(mesh)\n\n    return this\n  }\n\n  _setupCameraAnimation(camera, animation) {\n    const animations = Array.isArray(animation) ? animation : [animation]\n\n    const objects = this.objects.get(camera)\n\n    objects.mixer = new AnimationMixer(camera)\n\n    for (let i = 0, il = animations.length; i < il; i++) {\n      objects.mixer.clipAction(animations[i]).play()\n    }\n  }\n\n  _setupMeshPhysics(mesh, params) {\n    const objects = this.objects.get(mesh)\n\n    // shared physics is experimental\n\n    if (params.world === undefined && this.sharedPhysics) {\n      const masterPhysics = this._getMasterPhysics()\n\n      if (masterPhysics !== null) world = masterPhysics.world // eslint-disable-line no-undef\n    }\n\n    objects.physics = this._createMMDPhysics(mesh, params)\n\n    if (objects.mixer && params.animationWarmup !== false) {\n      this._animateMesh(mesh, 0)\n      objects.physics.reset()\n    }\n\n    objects.physics.warmup(params.warmup !== undefined ? params.warmup : 60)\n\n    this._optimizeIK(mesh, true)\n  }\n\n  _animateMesh(mesh, delta) {\n    const objects = this.objects.get(mesh)\n\n    const mixer = objects.mixer\n    const ikSolver = objects.ikSolver\n    const grantSolver = objects.grantSolver\n    const physics = objects.physics\n    const looped = objects.looped\n\n    if (mixer && this.enabled.animation) {\n      // alternate solution to save/restore bones but less performant?\n      //mesh.pose();\n      //this._updatePropertyMixersBuffer( mesh );\n\n      this._restoreBones(mesh)\n\n      mixer.update(delta)\n\n      this._saveBones(mesh)\n\n      // PMX animation system special path\n      if (\n        this.configuration.pmxAnimation &&\n        mesh.geometry.userData.MMD &&\n        mesh.geometry.userData.MMD.format === 'pmx'\n      ) {\n        if (!objects.sortedBonesData)\n          objects.sortedBonesData = this._sortBoneDataArray(mesh.geometry.userData.MMD.bones.slice())\n\n        this._animatePMXMesh(\n          mesh,\n          objects.sortedBonesData,\n          ikSolver && this.enabled.ik ? ikSolver : null,\n          grantSolver && this.enabled.grant ? grantSolver : null,\n        )\n      } else {\n        if (ikSolver && this.enabled.ik) {\n          mesh.updateMatrixWorld(true)\n          ikSolver.update()\n        }\n\n        if (grantSolver && this.enabled.grant) {\n          grantSolver.update()\n        }\n      }\n    }\n\n    if (looped === true && this.enabled.physics) {\n      if (physics && this.configuration.resetPhysicsOnLoop) physics.reset()\n\n      objects.looped = false\n    }\n\n    if (physics && this.enabled.physics && !this.sharedPhysics) {\n      this.onBeforePhysics(mesh)\n      physics.update(delta)\n    }\n  }\n\n  // Sort bones in order by 1. transformationClass and 2. bone index.\n  // In PMX animation system, bone transformations should be processed\n  // in this order.\n  _sortBoneDataArray(boneDataArray) {\n    return boneDataArray.sort(function (a, b) {\n      if (a.transformationClass !== b.transformationClass) {\n        return a.transformationClass - b.transformationClass\n      } else {\n        return a.index - b.index\n      }\n    })\n  }\n\n  // PMX Animation system is a bit too complex and doesn't great match to\n  // Three.js Animation system. This method attempts to simulate it as much as\n  // possible but doesn't perfectly simulate.\n  // This method is more costly than the regular one so\n  // you are recommended to set constructor parameter \"pmxAnimation: true\"\n  // only if your PMX model animation doesn't work well.\n  // If you need better method you would be required to write your own.\n  _animatePMXMesh(mesh, sortedBonesData, ikSolver, grantSolver) {\n    _quaternionIndex = 0\n    _grantResultMap.clear()\n\n    for (let i = 0, il = sortedBonesData.length; i < il; i++) {\n      updateOne(mesh, sortedBonesData[i].index, ikSolver, grantSolver)\n    }\n\n    mesh.updateMatrixWorld(true)\n    return this\n  }\n\n  _animateCamera(camera, delta) {\n    const mixer = this.objects.get(camera).mixer\n\n    if (mixer && this.enabled.cameraAnimation) {\n      mixer.update(delta)\n\n      camera.updateProjectionMatrix()\n\n      camera.up.set(0, 1, 0)\n      camera.up.applyQuaternion(camera.quaternion)\n      camera.lookAt(this.cameraTarget.position)\n    }\n  }\n\n  _optimizeIK(mesh, physicsEnabled) {\n    const iks = mesh.geometry.userData.MMD.iks\n    const bones = mesh.geometry.userData.MMD.bones\n\n    for (let i = 0, il = iks.length; i < il; i++) {\n      const ik = iks[i]\n      const links = ik.links\n\n      for (let j = 0, jl = links.length; j < jl; j++) {\n        const link = links[j]\n\n        if (physicsEnabled === true) {\n          // disable IK of the bone the corresponding rigidBody type of which is 1 or 2\n          // because its rotation will be overriden by physics\n          link.enabled = bones[link.index].rigidBodyType > 0 ? false : true\n        } else {\n          link.enabled = true\n        }\n      }\n    }\n  }\n\n  _createCCDIKSolver(mesh) {\n    if (CCDIKSolver === undefined) {\n      throw new Error('THREE.MMDAnimationHelper: Import CCDIKSolver.')\n    }\n\n    return new CCDIKSolver(mesh, mesh.geometry.userData.MMD.iks)\n  }\n\n  _createMMDPhysics(mesh, params) {\n    if (MMDPhysics === undefined) {\n      throw new Error('THREE.MMDPhysics: Import MMDPhysics.')\n    }\n\n    return new MMDPhysics(mesh, mesh.geometry.userData.MMD.rigidBodies, mesh.geometry.userData.MMD.constraints, params)\n  }\n\n  /*\n   * Detects the longest duration and then sets it to them to sync.\n   * TODO: Not to access private properties ( ._actions and ._clip )\n   */\n  _syncDuration() {\n    let max = 0.0\n\n    const objects = this.objects\n    const meshes = this.meshes\n    const camera = this.camera\n    const audioManager = this.audioManager\n\n    // get the longest duration\n\n    for (let i = 0, il = meshes.length; i < il; i++) {\n      const mixer = this.objects.get(meshes[i]).mixer\n\n      if (mixer === undefined) continue\n\n      for (let j = 0; j < mixer._actions.length; j++) {\n        const clip = mixer._actions[j]._clip\n\n        if (!objects.has(clip)) {\n          objects.set(clip, {\n            duration: clip.duration,\n          })\n        }\n\n        max = Math.max(max, objects.get(clip).duration)\n      }\n    }\n\n    if (camera !== null) {\n      const mixer = this.objects.get(camera).mixer\n\n      if (mixer !== undefined) {\n        for (let i = 0, il = mixer._actions.length; i < il; i++) {\n          const clip = mixer._actions[i]._clip\n\n          if (!objects.has(clip)) {\n            objects.set(clip, {\n              duration: clip.duration,\n            })\n          }\n\n          max = Math.max(max, objects.get(clip).duration)\n        }\n      }\n    }\n\n    if (audioManager !== null) {\n      max = Math.max(max, objects.get(audioManager).duration)\n    }\n\n    max += this.configuration.afterglow\n\n    // update the duration\n\n    for (let i = 0, il = this.meshes.length; i < il; i++) {\n      const mixer = this.objects.get(this.meshes[i]).mixer\n\n      if (mixer === undefined) continue\n\n      for (let j = 0, jl = mixer._actions.length; j < jl; j++) {\n        mixer._actions[j]._clip.duration = max\n      }\n    }\n\n    if (camera !== null) {\n      const mixer = this.objects.get(camera).mixer\n\n      if (mixer !== undefined) {\n        for (let i = 0, il = mixer._actions.length; i < il; i++) {\n          mixer._actions[i]._clip.duration = max\n        }\n      }\n    }\n\n    if (audioManager !== null) {\n      audioManager.duration = max\n    }\n  }\n\n  // workaround\n\n  _updatePropertyMixersBuffer(mesh) {\n    const mixer = this.objects.get(mesh).mixer\n\n    const propertyMixers = mixer._bindings\n    const accuIndex = mixer._accuIndex\n\n    for (let i = 0, il = propertyMixers.length; i < il; i++) {\n      const propertyMixer = propertyMixers[i]\n      const buffer = propertyMixer.buffer\n      const stride = propertyMixer.valueSize\n      const offset = (accuIndex + 1) * stride\n\n      propertyMixer.binding.getValue(buffer, offset)\n    }\n  }\n\n  /*\n   * Avoiding these two issues by restore/save bones before/after mixer animation.\n   *\n   * 1. PropertyMixer used by AnimationMixer holds cache value in .buffer.\n   *    Calculating IK, Grant, and Physics after mixer animation can break\n   *    the cache coherency.\n   *\n   * 2. Applying Grant two or more times without reset the posing breaks model.\n   */\n  _saveBones(mesh) {\n    const objects = this.objects.get(mesh)\n\n    const bones = mesh.skeleton.bones\n\n    let backupBones = objects.backupBones\n\n    if (backupBones === undefined) {\n      backupBones = new Float32Array(bones.length * 7)\n      objects.backupBones = backupBones\n    }\n\n    for (let i = 0, il = bones.length; i < il; i++) {\n      const bone = bones[i]\n      bone.position.toArray(backupBones, i * 7)\n      bone.quaternion.toArray(backupBones, i * 7 + 3)\n    }\n  }\n\n  _restoreBones(mesh) {\n    const objects = this.objects.get(mesh)\n\n    const backupBones = objects.backupBones\n\n    if (backupBones === undefined) return\n\n    const bones = mesh.skeleton.bones\n\n    for (let i = 0, il = bones.length; i < il; i++) {\n      const bone = bones[i]\n      bone.position.fromArray(backupBones, i * 7)\n      bone.quaternion.fromArray(backupBones, i * 7 + 3)\n    }\n  }\n\n  // experimental\n\n  _getMasterPhysics() {\n    if (this.masterPhysics !== null) return this.masterPhysics\n\n    for (let i = 0, il = this.meshes.length; i < il; i++) {\n      const physics = this.meshes[i].physics\n\n      if (physics !== undefined && physics !== null) {\n        this.masterPhysics = physics\n        return this.masterPhysics\n      }\n    }\n\n    return null\n  }\n\n  _updateSharedPhysics(delta) {\n    if (this.meshes.length === 0 || !this.enabled.physics || !this.sharedPhysics) return\n\n    const physics = this._getMasterPhysics()\n\n    if (physics === null) return\n\n    for (let i = 0, il = this.meshes.length; i < il; i++) {\n      const p = this.meshes[i].physics\n\n      if (p !== null && p !== undefined) {\n        p.updateRigidBodies()\n      }\n    }\n\n    physics.stepSimulation(delta)\n\n    for (let i = 0, il = this.meshes.length; i < il; i++) {\n      const p = this.meshes[i].physics\n\n      if (p !== null && p !== undefined) {\n        p.updateBones()\n      }\n    }\n  }\n}\n\n// Keep working quaternions for less GC\nconst _quaternions = []\nlet _quaternionIndex = 0\n\nfunction getQuaternion() {\n  if (_quaternionIndex >= _quaternions.length) {\n    _quaternions.push(new Quaternion())\n  }\n\n  return _quaternions[_quaternionIndex++]\n}\n\n// Save rotation whose grant and IK are already applied\n// used by grant children\nconst _grantResultMap = new Map()\n\nfunction updateOne(mesh, boneIndex, ikSolver, grantSolver) {\n  const bones = mesh.skeleton.bones\n  const bonesData = mesh.geometry.userData.MMD.bones\n  const boneData = bonesData[boneIndex]\n  const bone = bones[boneIndex]\n\n  // Return if already updated by being referred as a grant parent.\n  if (_grantResultMap.has(boneIndex)) return\n\n  const quaternion = getQuaternion()\n\n  // Initialize grant result here to prevent infinite loop.\n  // If it's referred before updating with actual result later\n  // result without applyting IK or grant is gotten\n  // but better than composing of infinite loop.\n  _grantResultMap.set(boneIndex, quaternion.copy(bone.quaternion))\n\n  // @TODO: Support global grant and grant position\n  if (grantSolver && boneData.grant && !boneData.grant.isLocal && boneData.grant.affectRotation) {\n    const parentIndex = boneData.grant.parentIndex\n    const ratio = boneData.grant.ratio\n\n    if (!_grantResultMap.has(parentIndex)) {\n      updateOne(mesh, parentIndex, ikSolver, grantSolver)\n    }\n\n    grantSolver.addGrantRotation(bone, _grantResultMap.get(parentIndex), ratio)\n  }\n\n  if (ikSolver && boneData.ik) {\n    // @TODO: Updating world matrices every time solving an IK bone is\n    // costly. Optimize if possible.\n    mesh.updateMatrixWorld(true)\n    ikSolver.updateOne(boneData.ik)\n\n    // No confident, but it seems the grant results with ik links should be updated?\n    const links = boneData.ik.links\n\n    for (let i = 0, il = links.length; i < il; i++) {\n      const link = links[i]\n\n      if (link.enabled === false) continue\n\n      const linkIndex = link.index\n\n      if (_grantResultMap.has(linkIndex)) {\n        _grantResultMap.set(linkIndex, _grantResultMap.get(linkIndex).copy(bones[linkIndex].quaternion))\n      }\n    }\n  }\n\n  // Update with the actual result here\n  quaternion.copy(bone.quaternion)\n}\n\n//\n\nclass AudioManager {\n  /**\n   * @param {THREE.Audio} audio\n   * @param {Object} params - (optional)\n   * @param {Nuumber} params.delayTime\n   */\n  constructor(audio, params = {}) {\n    this.audio = audio\n\n    this.elapsedTime = 0.0\n    this.currentTime = 0.0\n    this.delayTime = params.delayTime !== undefined ? params.delayTime : 0.0\n\n    this.audioDuration = this.audio.buffer.duration\n    this.duration = this.audioDuration + this.delayTime\n  }\n\n  /**\n   * @param {Number} delta\n   * @return {AudioManager}\n   */\n  control(delta) {\n    this.elapsed += delta\n    this.currentTime += delta\n\n    if (this._shouldStopAudio()) this.audio.stop()\n    if (this._shouldStartAudio()) this.audio.play()\n\n    return this\n  }\n\n  // private methods\n\n  _shouldStartAudio() {\n    if (this.audio.isPlaying) return false\n\n    while (this.currentTime >= this.duration) {\n      this.currentTime -= this.duration\n    }\n\n    if (this.currentTime < this.delayTime) return false\n\n    // 'duration' can be bigger than 'audioDuration + delayTime' because of sync configuration\n    if (this.currentTime - this.delayTime > this.audioDuration) return false\n\n    return true\n  }\n\n  _shouldStopAudio() {\n    return this.audio.isPlaying && this.currentTime >= this.duration\n  }\n}\n\nconst _q = new Quaternion()\n\n/**\n * Solver for Grant (Fuyo in Japanese. I just google translated because\n * Fuyo may be MMD specific term and may not be common word in 3D CG terms.)\n * Grant propagates a bone's transform to other bones transforms even if\n * they are not children.\n * @param {THREE.SkinnedMesh} mesh\n * @param {Array<Object>} grants\n */\nclass GrantSolver {\n  constructor(mesh, grants = []) {\n    this.mesh = mesh\n    this.grants = grants\n  }\n\n  /**\n   * Solve all the grant bones\n   * @return {GrantSolver}\n   */\n  update() {\n    const grants = this.grants\n\n    for (let i = 0, il = grants.length; i < il; i++) {\n      this.updateOne(grants[i])\n    }\n\n    return this\n  }\n\n  /**\n   * Solve a grant bone\n   * @param {Object} grant - grant parameter\n   * @return {GrantSolver}\n   */\n  updateOne(grant) {\n    const bones = this.mesh.skeleton.bones\n    const bone = bones[grant.index]\n    const parentBone = bones[grant.parentIndex]\n\n    if (grant.isLocal) {\n      // TODO: implement\n      if (grant.affectPosition) {\n      }\n\n      // TODO: implement\n      if (grant.affectRotation) {\n      }\n    } else {\n      // TODO: implement\n      if (grant.affectPosition) {\n      }\n\n      if (grant.affectRotation) {\n        this.addGrantRotation(bone, parentBone.quaternion, grant.ratio)\n      }\n    }\n\n    return this\n  }\n\n  addGrantRotation(bone, q, ratio) {\n    _q.set(0, 0, 0, 1)\n    _q.slerp(q, ratio)\n    bone.quaternion.multiply(_q)\n\n    return this\n  }\n}\n\nexport { MMDAnimationHelper }\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}