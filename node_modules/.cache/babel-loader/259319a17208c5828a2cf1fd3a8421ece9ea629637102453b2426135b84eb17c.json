{"ast":null,"code":"import _classCallCheck from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _inherits from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport { Loader, FileLoader, TextureLoader, Points, LineSegments, Mesh, PointsMaterial, LineBasicMaterial, BufferAttribute, MeshPhongMaterial, BackSide, DoubleSide, FrontSide, Vector2, Color, AddOperation, EquirectangularRefractionMapping, EquirectangularReflectionMapping, ClampToEdgeWrapping, MirroredRepeatWrapping, RepeatWrapping, MeshPhysicalMaterial, MeshStandardMaterial, BufferGeometry, Float32BufferAttribute } from \"three\";\nimport { IFFParser } from \"./lwo/IFFParser.js\";\nimport { UV1 } from \"../_polyfill/uv1.js\";\nvar _lwoTree;\nvar LWOLoader = /*#__PURE__*/function (_Loader) {\n  _inherits(LWOLoader, _Loader);\n  var _super = _createSuper(LWOLoader);\n  function LWOLoader(manager) {\n    var _this;\n    var parameters = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    _classCallCheck(this, LWOLoader);\n    _this = _super.call(this, manager);\n    _this.resourcePath = parameters.resourcePath !== void 0 ? parameters.resourcePath : \"\";\n    return _this;\n  }\n  _createClass(LWOLoader, [{\n    key: \"load\",\n    value: function load(url, onLoad, onProgress, onError) {\n      var scope = this;\n      var path = scope.path === \"\" ? extractParentUrl(url, \"Objects\") : scope.path;\n      var modelName = url.split(path).pop().split(\".\")[0];\n      var loader = new FileLoader(this.manager);\n      loader.setPath(scope.path);\n      loader.setResponseType(\"arraybuffer\");\n      loader.load(url, function (buffer) {\n        try {\n          onLoad(scope.parse(buffer, path, modelName));\n        } catch (e) {\n          if (onError) {\n            onError(e);\n          } else {\n            console.error(e);\n          }\n          scope.manager.itemError(url);\n        }\n      }, onProgress, onError);\n    }\n  }, {\n    key: \"parse\",\n    value: function parse(iffBuffer, path, modelName) {\n      _lwoTree = new IFFParser().parse(iffBuffer);\n      var textureLoader = new TextureLoader(this.manager).setPath(this.resourcePath || path).setCrossOrigin(this.crossOrigin);\n      return new LWOTreeParser(textureLoader).parse(modelName);\n    }\n  }]);\n  return LWOLoader;\n}(Loader);\nvar LWOTreeParser = /*#__PURE__*/function () {\n  function LWOTreeParser(textureLoader) {\n    _classCallCheck(this, LWOTreeParser);\n    this.textureLoader = textureLoader;\n  }\n  _createClass(LWOTreeParser, [{\n    key: \"parse\",\n    value: function parse(modelName) {\n      this.materials = new MaterialParser(this.textureLoader).parse();\n      this.defaultLayerName = modelName;\n      this.meshes = this.parseLayers();\n      return {\n        materials: this.materials,\n        meshes: this.meshes\n      };\n    }\n  }, {\n    key: \"parseLayers\",\n    value: function parseLayers() {\n      var meshes = [];\n      var finalMeshes = [];\n      var geometryParser = new GeometryParser();\n      var scope = this;\n      _lwoTree.layers.forEach(function (layer) {\n        var geometry = geometryParser.parse(layer.geometry, layer);\n        var mesh = scope.parseMesh(geometry, layer);\n        meshes[layer.number] = mesh;\n        if (layer.parent === -1) finalMeshes.push(mesh);else meshes[layer.parent].add(mesh);\n      });\n      this.applyPivots(finalMeshes);\n      return finalMeshes;\n    }\n  }, {\n    key: \"parseMesh\",\n    value: function parseMesh(geometry, layer) {\n      var mesh;\n      var materials = this.getMaterials(geometry.userData.matNames, layer.geometry.type);\n      if (UV1 === \"uv2\") this.duplicateUVs(geometry, materials);\n      if (layer.geometry.type === \"points\") mesh = new Points(geometry, materials);else if (layer.geometry.type === \"lines\") mesh = new LineSegments(geometry, materials);else mesh = new Mesh(geometry, materials);\n      if (layer.name) mesh.name = layer.name;else mesh.name = this.defaultLayerName + \"_layer_\" + layer.number;\n      mesh.userData.pivot = layer.pivot;\n      return mesh;\n    }\n    // TODO: may need to be reversed in z to convert LWO to three.js coordinates\n  }, {\n    key: \"applyPivots\",\n    value: function applyPivots(meshes) {\n      meshes.forEach(function (mesh) {\n        mesh.traverse(function (child) {\n          var pivot = child.userData.pivot;\n          child.position.x += pivot[0];\n          child.position.y += pivot[1];\n          child.position.z += pivot[2];\n          if (child.parent) {\n            var parentPivot = child.parent.userData.pivot;\n            child.position.x -= parentPivot[0];\n            child.position.y -= parentPivot[1];\n            child.position.z -= parentPivot[2];\n          }\n        });\n      });\n    }\n  }, {\n    key: \"getMaterials\",\n    value: function getMaterials(namesArray, type) {\n      var materials = [];\n      var scope = this;\n      namesArray.forEach(function (name, i) {\n        materials[i] = scope.getMaterialByName(name);\n      });\n      if (type === \"points\" || type === \"lines\") {\n        materials.forEach(function (mat, i) {\n          var spec = {\n            color: mat.color\n          };\n          if (type === \"points\") {\n            spec.size = 0.1;\n            spec.map = mat.map;\n            spec.morphTargets = mat.morphTargets;\n            materials[i] = new PointsMaterial(spec);\n          } else if (type === \"lines\") {\n            materials[i] = new LineBasicMaterial(spec);\n          }\n        });\n      }\n      var filtered = materials.filter(Boolean);\n      if (filtered.length === 1) return filtered[0];\n      return materials;\n    }\n  }, {\n    key: \"getMaterialByName\",\n    value: function getMaterialByName(name) {\n      return this.materials.filter(function (m) {\n        return m.name === name;\n      })[0];\n    }\n    // If the material has an aoMap, duplicate UVs\n  }, {\n    key: \"duplicateUVs\",\n    value: function duplicateUVs(geometry, materials) {\n      var duplicateUVs = false;\n      if (!Array.isArray(materials)) {\n        if (materials.aoMap) duplicateUVs = true;\n      } else {\n        materials.forEach(function (material) {\n          if (material.aoMap) duplicateUVs = true;\n        });\n      }\n      if (!duplicateUVs) return;\n      geometry.setAttribute(\"uv2\", new BufferAttribute(geometry.attributes.uv.array, 2));\n    }\n  }]);\n  return LWOTreeParser;\n}();\nvar MaterialParser = /*#__PURE__*/function () {\n  function MaterialParser(textureLoader) {\n    _classCallCheck(this, MaterialParser);\n    this.textureLoader = textureLoader;\n  }\n  _createClass(MaterialParser, [{\n    key: \"parse\",\n    value: function parse() {\n      var materials = [];\n      this.textures = {};\n      for (var name in _lwoTree.materials) {\n        if (_lwoTree.format === \"LWO3\") {\n          materials.push(this.parseMaterial(_lwoTree.materials[name], name, _lwoTree.textures));\n        } else if (_lwoTree.format === \"LWO2\") {\n          materials.push(this.parseMaterialLwo2(_lwoTree.materials[name], name, _lwoTree.textures));\n        }\n      }\n      return materials;\n    }\n  }, {\n    key: \"parseMaterial\",\n    value: function parseMaterial(materialData, name, textures) {\n      var params = {\n        name: name,\n        side: this.getSide(materialData.attributes),\n        flatShading: this.getSmooth(materialData.attributes)\n      };\n      var connections = this.parseConnections(materialData.connections, materialData.nodes);\n      var maps = this.parseTextureNodes(connections.maps);\n      this.parseAttributeImageMaps(connections.attributes, textures, maps, materialData.maps);\n      var attributes = this.parseAttributes(connections.attributes, maps);\n      this.parseEnvMap(connections, maps, attributes);\n      params = Object.assign(maps, params);\n      params = Object.assign(params, attributes);\n      var materialType = this.getMaterialType(connections.attributes);\n      return new materialType(params);\n    }\n  }, {\n    key: \"parseMaterialLwo2\",\n    value: function parseMaterialLwo2(materialData, name) {\n      var params = {\n        name: name,\n        side: this.getSide(materialData.attributes),\n        flatShading: this.getSmooth(materialData.attributes)\n      };\n      var attributes = this.parseAttributes(materialData.attributes, {});\n      params = Object.assign(params, attributes);\n      return new MeshPhongMaterial(params);\n    }\n    // Note: converting from left to right handed coords by switching x -> -x in vertices, and\n    // then switching mat FrontSide -> BackSide\n    // NB: this means that FrontSide and BackSide have been switched!\n  }, {\n    key: \"getSide\",\n    value: function getSide(attributes) {\n      if (!attributes.side) return BackSide;\n      switch (attributes.side) {\n        case 0:\n        case 1:\n          return BackSide;\n        case 2:\n          return FrontSide;\n        case 3:\n          return DoubleSide;\n      }\n    }\n  }, {\n    key: \"getSmooth\",\n    value: function getSmooth(attributes) {\n      if (!attributes.smooth) return true;\n      return !attributes.smooth;\n    }\n  }, {\n    key: \"parseConnections\",\n    value: function parseConnections(connections, nodes) {\n      var materialConnections = {\n        maps: {}\n      };\n      var inputName = connections.inputName;\n      var inputNodeName = connections.inputNodeName;\n      var nodeName = connections.nodeName;\n      var scope = this;\n      inputName.forEach(function (name, index) {\n        if (name === \"Material\") {\n          var matNode = scope.getNodeByRefName(inputNodeName[index], nodes);\n          materialConnections.attributes = matNode.attributes;\n          materialConnections.envMap = matNode.fileName;\n          materialConnections.name = inputNodeName[index];\n        }\n      });\n      nodeName.forEach(function (name, index) {\n        if (name === materialConnections.name) {\n          materialConnections.maps[inputName[index]] = scope.getNodeByRefName(inputNodeName[index], nodes);\n        }\n      });\n      return materialConnections;\n    }\n  }, {\n    key: \"getNodeByRefName\",\n    value: function getNodeByRefName(refName, nodes) {\n      for (var name in nodes) {\n        if (nodes[name].refName === refName) return nodes[name];\n      }\n    }\n  }, {\n    key: \"parseTextureNodes\",\n    value: function parseTextureNodes(textureNodes) {\n      var maps = {};\n      for (var name in textureNodes) {\n        var node = textureNodes[name];\n        var path = node.fileName;\n        if (!path) return;\n        var texture = this.loadTexture(path);\n        if (node.widthWrappingMode !== void 0) texture.wrapS = this.getWrappingType(node.widthWrappingMode);\n        if (node.heightWrappingMode !== void 0) texture.wrapT = this.getWrappingType(node.heightWrappingMode);\n        switch (name) {\n          case \"Color\":\n            maps.map = texture;\n            break;\n          case \"Roughness\":\n            maps.roughnessMap = texture;\n            maps.roughness = 0.5;\n            break;\n          case \"Specular\":\n            maps.specularMap = texture;\n            maps.specular = 16777215;\n            break;\n          case \"Luminous\":\n            maps.emissiveMap = texture;\n            maps.emissive = 8421504;\n            break;\n          case \"Luminous Color\":\n            maps.emissive = 8421504;\n            break;\n          case \"Metallic\":\n            maps.metalnessMap = texture;\n            maps.metalness = 0.5;\n            break;\n          case \"Transparency\":\n          case \"Alpha\":\n            maps.alphaMap = texture;\n            maps.transparent = true;\n            break;\n          case \"Normal\":\n            maps.normalMap = texture;\n            if (node.amplitude !== void 0) maps.normalScale = new Vector2(node.amplitude, node.amplitude);\n            break;\n          case \"Bump\":\n            maps.bumpMap = texture;\n            break;\n        }\n      }\n      if (maps.roughnessMap && maps.specularMap) delete maps.specularMap;\n      return maps;\n    }\n    // maps can also be defined on individual material attributes, parse those here\n    // This occurs on Standard (Phong) surfaces\n  }, {\n    key: \"parseAttributeImageMaps\",\n    value: function parseAttributeImageMaps(attributes, textures, maps) {\n      for (var name in attributes) {\n        var attribute = attributes[name];\n        if (attribute.maps) {\n          var mapData = attribute.maps[0];\n          var path = this.getTexturePathByIndex(mapData.imageIndex, textures);\n          if (!path) return;\n          var texture = this.loadTexture(path);\n          if (mapData.wrap !== void 0) texture.wrapS = this.getWrappingType(mapData.wrap.w);\n          if (mapData.wrap !== void 0) texture.wrapT = this.getWrappingType(mapData.wrap.h);\n          switch (name) {\n            case \"Color\":\n              maps.map = texture;\n              break;\n            case \"Diffuse\":\n              maps.aoMap = texture;\n              break;\n            case \"Roughness\":\n              maps.roughnessMap = texture;\n              maps.roughness = 1;\n              break;\n            case \"Specular\":\n              maps.specularMap = texture;\n              maps.specular = 16777215;\n              break;\n            case \"Luminosity\":\n              maps.emissiveMap = texture;\n              maps.emissive = 8421504;\n              break;\n            case \"Metallic\":\n              maps.metalnessMap = texture;\n              maps.metalness = 1;\n              break;\n            case \"Transparency\":\n            case \"Alpha\":\n              maps.alphaMap = texture;\n              maps.transparent = true;\n              break;\n            case \"Normal\":\n              maps.normalMap = texture;\n              break;\n            case \"Bump\":\n              maps.bumpMap = texture;\n              break;\n          }\n        }\n      }\n    }\n  }, {\n    key: \"parseAttributes\",\n    value: function parseAttributes(attributes, maps) {\n      var params = {};\n      if (attributes.Color && !maps.map) {\n        params.color = new Color().fromArray(attributes.Color.value);\n      } else {\n        params.color = new Color();\n      }\n      if (attributes.Transparency && attributes.Transparency.value !== 0) {\n        params.opacity = 1 - attributes.Transparency.value;\n        params.transparent = true;\n      }\n      if (attributes[\"Bump Height\"]) params.bumpScale = attributes[\"Bump Height\"].value * 0.1;\n      if (attributes[\"Refraction Index\"]) params.refractionRatio = 1 / attributes[\"Refraction Index\"].value;\n      this.parsePhysicalAttributes(params, attributes, maps);\n      this.parseStandardAttributes(params, attributes, maps);\n      this.parsePhongAttributes(params, attributes, maps);\n      return params;\n    }\n  }, {\n    key: \"parsePhysicalAttributes\",\n    value: function parsePhysicalAttributes(params, attributes) {\n      if (attributes.Clearcoat && attributes.Clearcoat.value > 0) {\n        params.clearcoat = attributes.Clearcoat.value;\n        if (attributes[\"Clearcoat Gloss\"]) {\n          params.clearcoatRoughness = 0.5 * (1 - attributes[\"Clearcoat Gloss\"].value);\n        }\n      }\n    }\n  }, {\n    key: \"parseStandardAttributes\",\n    value: function parseStandardAttributes(params, attributes, maps) {\n      if (attributes.Luminous) {\n        params.emissiveIntensity = attributes.Luminous.value;\n        if (attributes[\"Luminous Color\"] && !maps.emissive) {\n          params.emissive = new Color().fromArray(attributes[\"Luminous Color\"].value);\n        } else {\n          params.emissive = new Color(8421504);\n        }\n      }\n      if (attributes.Roughness && !maps.roughnessMap) params.roughness = attributes.Roughness.value;\n      if (attributes.Metallic && !maps.metalnessMap) params.metalness = attributes.Metallic.value;\n    }\n  }, {\n    key: \"parsePhongAttributes\",\n    value: function parsePhongAttributes(params, attributes, maps) {\n      if (attributes.Diffuse) params.color.multiplyScalar(attributes.Diffuse.value);\n      if (attributes.Reflection) {\n        params.reflectivity = attributes.Reflection.value;\n        params.combine = AddOperation;\n      }\n      if (attributes.Luminosity) {\n        params.emissiveIntensity = attributes.Luminosity.value;\n        if (!maps.emissiveMap && !maps.map) {\n          params.emissive = params.color;\n        } else {\n          params.emissive = new Color(8421504);\n        }\n      }\n      if (!attributes.Roughness && attributes.Specular && !maps.specularMap) {\n        if (attributes[\"Color Highlight\"]) {\n          params.specular = new Color().setScalar(attributes.Specular.value).lerp(params.color.clone().multiplyScalar(attributes.Specular.value), attributes[\"Color Highlight\"].value);\n        } else {\n          params.specular = new Color().setScalar(attributes.Specular.value);\n        }\n      }\n      if (params.specular && attributes.Glossiness) {\n        params.shininess = 7 + Math.pow(2, attributes.Glossiness.value * 12 + 2);\n      }\n    }\n  }, {\n    key: \"parseEnvMap\",\n    value: function parseEnvMap(connections, maps, attributes) {\n      if (connections.envMap) {\n        var envMap = this.loadTexture(connections.envMap);\n        if (attributes.transparent && attributes.opacity < 0.999) {\n          envMap.mapping = EquirectangularRefractionMapping;\n          if (attributes.reflectivity !== void 0) {\n            delete attributes.reflectivity;\n            delete attributes.combine;\n          }\n          if (attributes.metalness !== void 0) {\n            delete attributes.metalness;\n          }\n        } else {\n          envMap.mapping = EquirectangularReflectionMapping;\n        }\n        maps.envMap = envMap;\n      }\n    }\n    // get texture defined at top level by its index\n  }, {\n    key: \"getTexturePathByIndex\",\n    value: function getTexturePathByIndex(index) {\n      var fileName = \"\";\n      if (!_lwoTree.textures) return fileName;\n      _lwoTree.textures.forEach(function (texture) {\n        if (texture.index === index) fileName = texture.fileName;\n      });\n      return fileName;\n    }\n  }, {\n    key: \"loadTexture\",\n    value: function loadTexture(path) {\n      if (!path) return null;\n      var texture = this.textureLoader.load(path, void 0, void 0, function () {\n        console.warn(\"LWOLoader: non-standard resource hierarchy. Use `resourcePath` parameter to specify root content directory.\");\n      });\n      return texture;\n    }\n    // 0 = Reset, 1 = Repeat, 2 = Mirror, 3 = Edge\n  }, {\n    key: \"getWrappingType\",\n    value: function getWrappingType(num) {\n      switch (num) {\n        case 0:\n          console.warn('LWOLoader: \"Reset\" texture wrapping type is not supported in three.js');\n          return ClampToEdgeWrapping;\n        case 1:\n          return RepeatWrapping;\n        case 2:\n          return MirroredRepeatWrapping;\n        case 3:\n          return ClampToEdgeWrapping;\n      }\n    }\n  }, {\n    key: \"getMaterialType\",\n    value: function getMaterialType(nodeData) {\n      if (nodeData.Clearcoat && nodeData.Clearcoat.value > 0) return MeshPhysicalMaterial;\n      if (nodeData.Roughness) return MeshStandardMaterial;\n      return MeshPhongMaterial;\n    }\n  }]);\n  return MaterialParser;\n}();\nvar GeometryParser = /*#__PURE__*/function () {\n  function GeometryParser() {\n    _classCallCheck(this, GeometryParser);\n  }\n  _createClass(GeometryParser, [{\n    key: \"parse\",\n    value: function parse(geoData, layer) {\n      var geometry = new BufferGeometry();\n      geometry.setAttribute(\"position\", new Float32BufferAttribute(geoData.points, 3));\n      var indices = this.splitIndices(geoData.vertexIndices, geoData.polygonDimensions);\n      geometry.setIndex(indices);\n      this.parseGroups(geometry, geoData);\n      geometry.computeVertexNormals();\n      this.parseUVs(geometry, layer, indices);\n      this.parseMorphTargets(geometry, layer, indices);\n      geometry.translate(-layer.pivot[0], -layer.pivot[1], -layer.pivot[2]);\n      return geometry;\n    }\n    // split quads into tris\n  }, {\n    key: \"splitIndices\",\n    value: function splitIndices(indices, polygonDimensions) {\n      var remappedIndices = [];\n      var i = 0;\n      polygonDimensions.forEach(function (dim) {\n        if (dim < 4) {\n          for (var k = 0; k < dim; k++) remappedIndices.push(indices[i + k]);\n        } else if (dim === 4) {\n          remappedIndices.push(indices[i], indices[i + 1], indices[i + 2], indices[i], indices[i + 2], indices[i + 3]);\n        } else if (dim > 4) {\n          for (var _k = 1; _k < dim - 1; _k++) {\n            remappedIndices.push(indices[i], indices[i + _k], indices[i + _k + 1]);\n          }\n          console.warn(\"LWOLoader: polygons with greater than 4 sides are not supported\");\n        }\n        i += dim;\n      });\n      return remappedIndices;\n    }\n    // NOTE: currently ignoring poly indices and assuming that they are intelligently ordered\n  }, {\n    key: \"parseGroups\",\n    value: function parseGroups(geometry, geoData) {\n      var tags = _lwoTree.tags;\n      var matNames = [];\n      var elemSize = 3;\n      if (geoData.type === \"lines\") elemSize = 2;\n      if (geoData.type === \"points\") elemSize = 1;\n      var remappedIndices = this.splitMaterialIndices(geoData.polygonDimensions, geoData.materialIndices);\n      var indexNum = 0;\n      var indexPairs = {};\n      var prevMaterialIndex;\n      var materialIndex;\n      var prevStart = 0;\n      var currentCount = 0;\n      for (var i = 0; i < remappedIndices.length; i += 2) {\n        materialIndex = remappedIndices[i + 1];\n        if (i === 0) matNames[indexNum] = tags[materialIndex];\n        if (prevMaterialIndex === void 0) prevMaterialIndex = materialIndex;\n        if (materialIndex !== prevMaterialIndex) {\n          var currentIndex = void 0;\n          if (indexPairs[tags[prevMaterialIndex]]) {\n            currentIndex = indexPairs[tags[prevMaterialIndex]];\n          } else {\n            currentIndex = indexNum;\n            indexPairs[tags[prevMaterialIndex]] = indexNum;\n            matNames[indexNum] = tags[prevMaterialIndex];\n            indexNum++;\n          }\n          geometry.addGroup(prevStart, currentCount, currentIndex);\n          prevStart += currentCount;\n          prevMaterialIndex = materialIndex;\n          currentCount = 0;\n        }\n        currentCount += elemSize;\n      }\n      if (geometry.groups.length > 0) {\n        var _currentIndex;\n        if (indexPairs[tags[materialIndex]]) {\n          _currentIndex = indexPairs[tags[materialIndex]];\n        } else {\n          _currentIndex = indexNum;\n          indexPairs[tags[materialIndex]] = indexNum;\n          matNames[indexNum] = tags[materialIndex];\n        }\n        geometry.addGroup(prevStart, currentCount, _currentIndex);\n      }\n      geometry.userData.matNames = matNames;\n    }\n  }, {\n    key: \"splitMaterialIndices\",\n    value: function splitMaterialIndices(polygonDimensions, indices) {\n      var remappedIndices = [];\n      polygonDimensions.forEach(function (dim, i) {\n        if (dim <= 3) {\n          remappedIndices.push(indices[i * 2], indices[i * 2 + 1]);\n        } else if (dim === 4) {\n          remappedIndices.push(indices[i * 2], indices[i * 2 + 1], indices[i * 2], indices[i * 2 + 1]);\n        } else {\n          for (var k = 0; k < dim - 2; k++) {\n            remappedIndices.push(indices[i * 2], indices[i * 2 + 1]);\n          }\n        }\n      });\n      return remappedIndices;\n    }\n    // UV maps:\n    // 1: are defined via index into an array of points, not into a geometry\n    // - the geometry is also defined by an index into this array, but the indexes may not match\n    // 2: there can be any number of UV maps for a single geometry. Here these are combined,\n    // \twith preference given to the first map encountered\n    // 3: UV maps can be partial - that is, defined for only a part of the geometry\n    // 4: UV maps can be VMAP or VMAD (discontinuous, to allow for seams). In practice, most\n    // UV maps are defined as partially VMAP and partially VMAD\n    // VMADs are currently not supported\n  }, {\n    key: \"parseUVs\",\n    value: function parseUVs(geometry, layer) {\n      var remappedUVs = Array.from(Array(geometry.attributes.position.count * 2), function () {\n        return 0;\n      });\n      var _loop = function _loop() {\n        var uvs = layer.uvs[name].uvs;\n        var uvIndices = layer.uvs[name].uvIndices;\n        uvIndices.forEach(function (i, j) {\n          remappedUVs[i * 2] = uvs[j * 2];\n          remappedUVs[i * 2 + 1] = uvs[j * 2 + 1];\n        });\n      };\n      for (var name in layer.uvs) {\n        _loop();\n      }\n      geometry.setAttribute(\"uv\", new Float32BufferAttribute(remappedUVs, 2));\n    }\n  }, {\n    key: \"parseMorphTargets\",\n    value: function parseMorphTargets(geometry, layer) {\n      var num = 0;\n      var _loop2 = function _loop2() {\n        var remappedPoints = geometry.attributes.position.array.slice();\n        if (!geometry.morphAttributes.position) geometry.morphAttributes.position = [];\n        var morphPoints = layer.morphTargets[name].points;\n        var morphIndices = layer.morphTargets[name].indices;\n        var type = layer.morphTargets[name].type;\n        morphIndices.forEach(function (i, j) {\n          if (type === \"relative\") {\n            remappedPoints[i * 3] += morphPoints[j * 3];\n            remappedPoints[i * 3 + 1] += morphPoints[j * 3 + 1];\n            remappedPoints[i * 3 + 2] += morphPoints[j * 3 + 2];\n          } else {\n            remappedPoints[i * 3] = morphPoints[j * 3];\n            remappedPoints[i * 3 + 1] = morphPoints[j * 3 + 1];\n            remappedPoints[i * 3 + 2] = morphPoints[j * 3 + 2];\n          }\n        });\n        geometry.morphAttributes.position[num] = new Float32BufferAttribute(remappedPoints, 3);\n        geometry.morphAttributes.position[num].name = name;\n        num++;\n      };\n      for (var name in layer.morphTargets) {\n        _loop2();\n      }\n      geometry.morphTargetsRelative = false;\n    }\n  }]);\n  return GeometryParser;\n}();\nfunction extractParentUrl(url, dir) {\n  var index = url.indexOf(dir);\n  if (index === -1) return \"./\";\n  return url.substr(0, index);\n}\nexport { LWOLoader };","map":{"version":3,"names":["_lwoTree","LWOLoader","_Loader","_inherits","_super","_createSuper","manager","_this","parameters","arguments","length","undefined","_classCallCheck","call","resourcePath","_createClass","key","value","load","url","onLoad","onProgress","onError","scope","path","extractParentUrl","modelName","split","pop","loader","FileLoader","setPath","setResponseType","buffer","parse","e","console","error","itemError","iffBuffer","IFFParser","textureLoader","TextureLoader","setCrossOrigin","crossOrigin","LWOTreeParser","Loader","materials","MaterialParser","defaultLayerName","meshes","parseLayers","finalMeshes","geometryParser","GeometryParser","layers","forEach","layer","geometry","mesh","parseMesh","number","parent","push","add","applyPivots","getMaterials","userData","matNames","type","UV1","duplicateUVs","Points","LineSegments","Mesh","name","pivot","traverse","child","position","x","y","z","parentPivot","namesArray","i","getMaterialByName","mat","spec","color","size","map","morphTargets","PointsMaterial","LineBasicMaterial","filtered","filter","Boolean","m","Array","isArray","aoMap","material","setAttribute","BufferAttribute","attributes","uv","array","textures","format","parseMaterial","parseMaterialLwo2","materialData","params","side","getSide","flatShading","getSmooth","connections","parseConnections","nodes","maps","parseTextureNodes","parseAttributeImageMaps","parseAttributes","parseEnvMap","Object","assign","materialType","getMaterialType","MeshPhongMaterial","BackSide","FrontSide","DoubleSide","smooth","materialConnections","inputName","inputNodeName","nodeName","index","matNode","getNodeByRefName","envMap","fileName","refName","textureNodes","node","texture","loadTexture","widthWrappingMode","wrapS","getWrappingType","heightWrappingMode","wrapT","roughnessMap","roughness","specularMap","specular","emissiveMap","emissive","metalnessMap","metalness","alphaMap","transparent","normalMap","amplitude","normalScale","Vector2","bumpMap","attribute","mapData","getTexturePathByIndex","imageIndex","wrap","w","h","Color","fromArray","Transparency","opacity","bumpScale","refractionRatio","parsePhysicalAttributes","parseStandardAttributes","parsePhongAttributes","Clearcoat","clearcoat","clearcoatRoughness","Luminous","emissiveIntensity","Roughness","Metallic","Diffuse","multiplyScalar","Reflection","reflectivity","combine","AddOperation","Luminosity","Specular","setScalar","lerp","clone","Glossiness","shininess","Math","pow","mapping","EquirectangularRefractionMapping","EquirectangularReflectionMapping","warn","num","ClampToEdgeWrapping","RepeatWrapping","MirroredRepeatWrapping","nodeData","MeshPhysicalMaterial","MeshStandardMaterial","geoData","BufferGeometry","Float32BufferAttribute","points","indices","splitIndices","vertexIndices","polygonDimensions","setIndex","parseGroups","computeVertexNormals","parseUVs","parseMorphTargets","translate","remappedIndices","dim","k","tags","elemSize","splitMaterialIndices","materialIndices","indexNum","indexPairs","prevMaterialIndex","materialIndex","prevStart","currentCount","currentIndex","addGroup","groups","remappedUVs","from","count","_loop","uvs","uvIndices","j","_loop2","remappedPoints","slice","morphAttributes","morphPoints","morphIndices","morphTargetsRelative","dir","indexOf","substr"],"sources":["C:\\Users\\Nayyu\\Desktop\\skibidai-public-build\\node_modules\\src\\loaders\\LWOLoader.js"],"sourcesContent":["/**\n * @version 1.1.1\n *\n * @desc Load files in LWO3 and LWO2 format on Three.js\n *\n * LWO3 format specification:\n * \thttp://static.lightwave3d.com/sdk/2018/html/filefmts/lwo3.html\n *\n * LWO2 format specification:\n * \thttp://static.lightwave3d.com/sdk/2018/html/filefmts/lwo2.html\n *\n **/\n\nimport {\n  AddOperation,\n  BackSide,\n  BufferAttribute,\n  BufferGeometry,\n  ClampToEdgeWrapping,\n  Color,\n  DoubleSide,\n  EquirectangularReflectionMapping,\n  EquirectangularRefractionMapping,\n  FileLoader,\n  Float32BufferAttribute,\n  FrontSide,\n  LineBasicMaterial,\n  LineSegments,\n  Loader,\n  Mesh,\n  MeshPhongMaterial,\n  MeshPhysicalMaterial,\n  MeshStandardMaterial,\n  MirroredRepeatWrapping,\n  Points,\n  PointsMaterial,\n  RepeatWrapping,\n  TextureLoader,\n  Vector2,\n} from 'three'\n\nimport { IFFParser } from './lwo/IFFParser.js'\nimport { UV1 } from '../_polyfill/uv1.ts'\n\nlet _lwoTree\n\nclass LWOLoader extends Loader {\n  constructor(manager, parameters = {}) {\n    super(manager)\n\n    this.resourcePath = parameters.resourcePath !== undefined ? parameters.resourcePath : ''\n  }\n\n  load(url, onLoad, onProgress, onError) {\n    const scope = this\n\n    const path = scope.path === '' ? extractParentUrl(url, 'Objects') : scope.path\n\n    // give the mesh a default name based on the filename\n    const modelName = url.split(path).pop().split('.')[0]\n\n    const loader = new FileLoader(this.manager)\n    loader.setPath(scope.path)\n    loader.setResponseType('arraybuffer')\n\n    loader.load(\n      url,\n      function (buffer) {\n        // console.time( 'Total parsing: ' );\n\n        try {\n          onLoad(scope.parse(buffer, path, modelName))\n        } catch (e) {\n          if (onError) {\n            onError(e)\n          } else {\n            console.error(e)\n          }\n\n          scope.manager.itemError(url)\n        }\n\n        // console.timeEnd( 'Total parsing: ' );\n      },\n      onProgress,\n      onError,\n    )\n  }\n\n  parse(iffBuffer, path, modelName) {\n    _lwoTree = new IFFParser().parse(iffBuffer)\n\n    // console.log( 'lwoTree', lwoTree );\n\n    const textureLoader = new TextureLoader(this.manager)\n      .setPath(this.resourcePath || path)\n      .setCrossOrigin(this.crossOrigin)\n\n    return new LWOTreeParser(textureLoader).parse(modelName)\n  }\n}\n\n// Parse the lwoTree object\nclass LWOTreeParser {\n  constructor(textureLoader) {\n    this.textureLoader = textureLoader\n  }\n\n  parse(modelName) {\n    this.materials = new MaterialParser(this.textureLoader).parse()\n    this.defaultLayerName = modelName\n\n    this.meshes = this.parseLayers()\n\n    return {\n      materials: this.materials,\n      meshes: this.meshes,\n    }\n  }\n\n  parseLayers() {\n    // array of all meshes for building hierarchy\n    const meshes = []\n\n    // final array containing meshes with scene graph hierarchy set up\n    const finalMeshes = []\n\n    const geometryParser = new GeometryParser()\n\n    const scope = this\n    _lwoTree.layers.forEach(function (layer) {\n      const geometry = geometryParser.parse(layer.geometry, layer)\n\n      const mesh = scope.parseMesh(geometry, layer)\n\n      meshes[layer.number] = mesh\n\n      if (layer.parent === -1) finalMeshes.push(mesh)\n      else meshes[layer.parent].add(mesh)\n    })\n\n    this.applyPivots(finalMeshes)\n\n    return finalMeshes\n  }\n\n  parseMesh(geometry, layer) {\n    let mesh\n\n    const materials = this.getMaterials(geometry.userData.matNames, layer.geometry.type)\n\n    if (UV1 === 'uv2') this.duplicateUVs(geometry, materials)\n\n    if (layer.geometry.type === 'points') mesh = new Points(geometry, materials)\n    else if (layer.geometry.type === 'lines') mesh = new LineSegments(geometry, materials)\n    else mesh = new Mesh(geometry, materials)\n\n    if (layer.name) mesh.name = layer.name\n    else mesh.name = this.defaultLayerName + '_layer_' + layer.number\n\n    mesh.userData.pivot = layer.pivot\n\n    return mesh\n  }\n\n  // TODO: may need to be reversed in z to convert LWO to three.js coordinates\n  applyPivots(meshes) {\n    meshes.forEach(function (mesh) {\n      mesh.traverse(function (child) {\n        const pivot = child.userData.pivot\n\n        child.position.x += pivot[0]\n        child.position.y += pivot[1]\n        child.position.z += pivot[2]\n\n        if (child.parent) {\n          const parentPivot = child.parent.userData.pivot\n\n          child.position.x -= parentPivot[0]\n          child.position.y -= parentPivot[1]\n          child.position.z -= parentPivot[2]\n        }\n      })\n    })\n  }\n\n  getMaterials(namesArray, type) {\n    const materials = []\n\n    const scope = this\n\n    namesArray.forEach(function (name, i) {\n      materials[i] = scope.getMaterialByName(name)\n    })\n\n    // convert materials to line or point mats if required\n    if (type === 'points' || type === 'lines') {\n      materials.forEach(function (mat, i) {\n        const spec = {\n          color: mat.color,\n        }\n\n        if (type === 'points') {\n          spec.size = 0.1\n          spec.map = mat.map\n          spec.morphTargets = mat.morphTargets\n          materials[i] = new PointsMaterial(spec)\n        } else if (type === 'lines') {\n          materials[i] = new LineBasicMaterial(spec)\n        }\n      })\n    }\n\n    // if there is only one material, return that directly instead of array\n    const filtered = materials.filter(Boolean)\n    if (filtered.length === 1) return filtered[0]\n\n    return materials\n  }\n\n  getMaterialByName(name) {\n    return this.materials.filter(function (m) {\n      return m.name === name\n    })[0]\n  }\n\n  // If the material has an aoMap, duplicate UVs\n  duplicateUVs(geometry, materials) {\n    let duplicateUVs = false\n\n    if (!Array.isArray(materials)) {\n      if (materials.aoMap) duplicateUVs = true\n    } else {\n      materials.forEach(function (material) {\n        if (material.aoMap) duplicateUVs = true\n      })\n    }\n\n    if (!duplicateUVs) return\n\n    geometry.setAttribute('uv2', new BufferAttribute(geometry.attributes.uv.array, 2))\n  }\n}\n\nclass MaterialParser {\n  constructor(textureLoader) {\n    this.textureLoader = textureLoader\n  }\n\n  parse() {\n    const materials = []\n    this.textures = {}\n\n    for (const name in _lwoTree.materials) {\n      if (_lwoTree.format === 'LWO3') {\n        materials.push(this.parseMaterial(_lwoTree.materials[name], name, _lwoTree.textures))\n      } else if (_lwoTree.format === 'LWO2') {\n        materials.push(this.parseMaterialLwo2(_lwoTree.materials[name], name, _lwoTree.textures))\n      }\n    }\n\n    return materials\n  }\n\n  parseMaterial(materialData, name, textures) {\n    let params = {\n      name: name,\n      side: this.getSide(materialData.attributes),\n      flatShading: this.getSmooth(materialData.attributes),\n    }\n\n    const connections = this.parseConnections(materialData.connections, materialData.nodes)\n\n    const maps = this.parseTextureNodes(connections.maps)\n\n    this.parseAttributeImageMaps(connections.attributes, textures, maps, materialData.maps)\n\n    const attributes = this.parseAttributes(connections.attributes, maps)\n\n    this.parseEnvMap(connections, maps, attributes)\n\n    params = Object.assign(maps, params)\n    params = Object.assign(params, attributes)\n\n    const materialType = this.getMaterialType(connections.attributes)\n\n    return new materialType(params)\n  }\n\n  parseMaterialLwo2(materialData, name /*, textures*/) {\n    let params = {\n      name: name,\n      side: this.getSide(materialData.attributes),\n      flatShading: this.getSmooth(materialData.attributes),\n    }\n\n    const attributes = this.parseAttributes(materialData.attributes, {})\n    params = Object.assign(params, attributes)\n    return new MeshPhongMaterial(params)\n  }\n\n  // Note: converting from left to right handed coords by switching x -> -x in vertices, and\n  // then switching mat FrontSide -> BackSide\n  // NB: this means that FrontSide and BackSide have been switched!\n  getSide(attributes) {\n    if (!attributes.side) return BackSide\n\n    switch (attributes.side) {\n      case 0:\n      case 1:\n        return BackSide\n      case 2:\n        return FrontSide\n      case 3:\n        return DoubleSide\n    }\n  }\n\n  getSmooth(attributes) {\n    if (!attributes.smooth) return true\n    return !attributes.smooth\n  }\n\n  parseConnections(connections, nodes) {\n    const materialConnections = {\n      maps: {},\n    }\n\n    const inputName = connections.inputName\n    const inputNodeName = connections.inputNodeName\n    const nodeName = connections.nodeName\n\n    const scope = this\n    inputName.forEach(function (name, index) {\n      if (name === 'Material') {\n        const matNode = scope.getNodeByRefName(inputNodeName[index], nodes)\n        materialConnections.attributes = matNode.attributes\n        materialConnections.envMap = matNode.fileName\n        materialConnections.name = inputNodeName[index]\n      }\n    })\n\n    nodeName.forEach(function (name, index) {\n      if (name === materialConnections.name) {\n        materialConnections.maps[inputName[index]] = scope.getNodeByRefName(inputNodeName[index], nodes)\n      }\n    })\n\n    return materialConnections\n  }\n\n  getNodeByRefName(refName, nodes) {\n    for (const name in nodes) {\n      if (nodes[name].refName === refName) return nodes[name]\n    }\n  }\n\n  parseTextureNodes(textureNodes) {\n    const maps = {}\n\n    for (const name in textureNodes) {\n      const node = textureNodes[name]\n      const path = node.fileName\n\n      if (!path) return\n\n      const texture = this.loadTexture(path)\n\n      if (node.widthWrappingMode !== undefined) texture.wrapS = this.getWrappingType(node.widthWrappingMode)\n      if (node.heightWrappingMode !== undefined) texture.wrapT = this.getWrappingType(node.heightWrappingMode)\n\n      switch (name) {\n        case 'Color':\n          maps.map = texture\n          break\n        case 'Roughness':\n          maps.roughnessMap = texture\n          maps.roughness = 0.5\n          break\n        case 'Specular':\n          maps.specularMap = texture\n          maps.specular = 0xffffff\n          break\n        case 'Luminous':\n          maps.emissiveMap = texture\n          maps.emissive = 0x808080\n          break\n        case 'Luminous Color':\n          maps.emissive = 0x808080\n          break\n        case 'Metallic':\n          maps.metalnessMap = texture\n          maps.metalness = 0.5\n          break\n        case 'Transparency':\n        case 'Alpha':\n          maps.alphaMap = texture\n          maps.transparent = true\n          break\n        case 'Normal':\n          maps.normalMap = texture\n          if (node.amplitude !== undefined) maps.normalScale = new Vector2(node.amplitude, node.amplitude)\n          break\n        case 'Bump':\n          maps.bumpMap = texture\n          break\n      }\n    }\n\n    // LWO BSDF materials can have both spec and rough, but this is not valid in three\n    if (maps.roughnessMap && maps.specularMap) delete maps.specularMap\n\n    return maps\n  }\n\n  // maps can also be defined on individual material attributes, parse those here\n  // This occurs on Standard (Phong) surfaces\n  parseAttributeImageMaps(attributes, textures, maps) {\n    for (const name in attributes) {\n      const attribute = attributes[name]\n\n      if (attribute.maps) {\n        const mapData = attribute.maps[0]\n\n        const path = this.getTexturePathByIndex(mapData.imageIndex, textures)\n        if (!path) return\n\n        const texture = this.loadTexture(path)\n\n        if (mapData.wrap !== undefined) texture.wrapS = this.getWrappingType(mapData.wrap.w)\n        if (mapData.wrap !== undefined) texture.wrapT = this.getWrappingType(mapData.wrap.h)\n\n        switch (name) {\n          case 'Color':\n            maps.map = texture\n            break\n          case 'Diffuse':\n            maps.aoMap = texture\n            break\n          case 'Roughness':\n            maps.roughnessMap = texture\n            maps.roughness = 1\n            break\n          case 'Specular':\n            maps.specularMap = texture\n            maps.specular = 0xffffff\n            break\n          case 'Luminosity':\n            maps.emissiveMap = texture\n            maps.emissive = 0x808080\n            break\n          case 'Metallic':\n            maps.metalnessMap = texture\n            maps.metalness = 1\n            break\n          case 'Transparency':\n          case 'Alpha':\n            maps.alphaMap = texture\n            maps.transparent = true\n            break\n          case 'Normal':\n            maps.normalMap = texture\n            break\n          case 'Bump':\n            maps.bumpMap = texture\n            break\n        }\n      }\n    }\n  }\n\n  parseAttributes(attributes, maps) {\n    const params = {}\n\n    // don't use color data if color map is present\n    if (attributes.Color && !maps.map) {\n      params.color = new Color().fromArray(attributes.Color.value)\n    } else {\n      params.color = new Color()\n    }\n\n    if (attributes.Transparency && attributes.Transparency.value !== 0) {\n      params.opacity = 1 - attributes.Transparency.value\n      params.transparent = true\n    }\n\n    if (attributes['Bump Height']) params.bumpScale = attributes['Bump Height'].value * 0.1\n\n    if (attributes['Refraction Index']) params.refractionRatio = 1 / attributes['Refraction Index'].value\n\n    this.parsePhysicalAttributes(params, attributes, maps)\n    this.parseStandardAttributes(params, attributes, maps)\n    this.parsePhongAttributes(params, attributes, maps)\n\n    return params\n  }\n\n  parsePhysicalAttributes(params, attributes /*, maps*/) {\n    if (attributes.Clearcoat && attributes.Clearcoat.value > 0) {\n      params.clearcoat = attributes.Clearcoat.value\n\n      if (attributes['Clearcoat Gloss']) {\n        params.clearcoatRoughness = 0.5 * (1 - attributes['Clearcoat Gloss'].value)\n      }\n    }\n  }\n\n  parseStandardAttributes(params, attributes, maps) {\n    if (attributes.Luminous) {\n      params.emissiveIntensity = attributes.Luminous.value\n\n      if (attributes['Luminous Color'] && !maps.emissive) {\n        params.emissive = new Color().fromArray(attributes['Luminous Color'].value)\n      } else {\n        params.emissive = new Color(0x808080)\n      }\n    }\n\n    if (attributes.Roughness && !maps.roughnessMap) params.roughness = attributes.Roughness.value\n    if (attributes.Metallic && !maps.metalnessMap) params.metalness = attributes.Metallic.value\n  }\n\n  parsePhongAttributes(params, attributes, maps) {\n    if (attributes.Diffuse) params.color.multiplyScalar(attributes.Diffuse.value)\n\n    if (attributes.Reflection) {\n      params.reflectivity = attributes.Reflection.value\n      params.combine = AddOperation\n    }\n\n    if (attributes.Luminosity) {\n      params.emissiveIntensity = attributes.Luminosity.value\n\n      if (!maps.emissiveMap && !maps.map) {\n        params.emissive = params.color\n      } else {\n        params.emissive = new Color(0x808080)\n      }\n    }\n\n    // parse specular if there is no roughness - we will interpret the material as 'Phong' in this case\n    if (!attributes.Roughness && attributes.Specular && !maps.specularMap) {\n      if (attributes['Color Highlight']) {\n        params.specular = new Color()\n          .setScalar(attributes.Specular.value)\n          .lerp(params.color.clone().multiplyScalar(attributes.Specular.value), attributes['Color Highlight'].value)\n      } else {\n        params.specular = new Color().setScalar(attributes.Specular.value)\n      }\n    }\n\n    if (params.specular && attributes.Glossiness) {\n      params.shininess = 7 + Math.pow(2, attributes.Glossiness.value * 12 + 2)\n    }\n  }\n\n  parseEnvMap(connections, maps, attributes) {\n    if (connections.envMap) {\n      const envMap = this.loadTexture(connections.envMap)\n\n      if (attributes.transparent && attributes.opacity < 0.999) {\n        envMap.mapping = EquirectangularRefractionMapping\n\n        // Reflectivity and refraction mapping don't work well together in Phong materials\n        if (attributes.reflectivity !== undefined) {\n          delete attributes.reflectivity\n          delete attributes.combine\n        }\n\n        if (attributes.metalness !== undefined) {\n          delete attributes.metalness\n        }\n      } else {\n        envMap.mapping = EquirectangularReflectionMapping\n      }\n\n      maps.envMap = envMap\n    }\n  }\n\n  // get texture defined at top level by its index\n  getTexturePathByIndex(index) {\n    let fileName = ''\n\n    if (!_lwoTree.textures) return fileName\n\n    _lwoTree.textures.forEach(function (texture) {\n      if (texture.index === index) fileName = texture.fileName\n    })\n\n    return fileName\n  }\n\n  loadTexture(path) {\n    if (!path) return null\n\n    const texture = this.textureLoader.load(path, undefined, undefined, function () {\n      console.warn(\n        'LWOLoader: non-standard resource hierarchy. Use `resourcePath` parameter to specify root content directory.',\n      )\n    })\n\n    return texture\n  }\n\n  // 0 = Reset, 1 = Repeat, 2 = Mirror, 3 = Edge\n  getWrappingType(num) {\n    switch (num) {\n      case 0:\n        console.warn('LWOLoader: \"Reset\" texture wrapping type is not supported in three.js')\n        return ClampToEdgeWrapping\n      case 1:\n        return RepeatWrapping\n      case 2:\n        return MirroredRepeatWrapping\n      case 3:\n        return ClampToEdgeWrapping\n    }\n  }\n\n  getMaterialType(nodeData) {\n    if (nodeData.Clearcoat && nodeData.Clearcoat.value > 0) return MeshPhysicalMaterial\n    if (nodeData.Roughness) return MeshStandardMaterial\n    return MeshPhongMaterial\n  }\n}\n\nclass GeometryParser {\n  parse(geoData, layer) {\n    const geometry = new BufferGeometry()\n\n    geometry.setAttribute('position', new Float32BufferAttribute(geoData.points, 3))\n\n    const indices = this.splitIndices(geoData.vertexIndices, geoData.polygonDimensions)\n    geometry.setIndex(indices)\n\n    this.parseGroups(geometry, geoData)\n\n    geometry.computeVertexNormals()\n\n    this.parseUVs(geometry, layer, indices)\n    this.parseMorphTargets(geometry, layer, indices)\n\n    // TODO: z may need to be reversed to account for coordinate system change\n    geometry.translate(-layer.pivot[0], -layer.pivot[1], -layer.pivot[2])\n\n    // let userData = geometry.userData;\n    // geometry = geometry.toNonIndexed()\n    // geometry.userData = userData;\n\n    return geometry\n  }\n\n  // split quads into tris\n  splitIndices(indices, polygonDimensions) {\n    const remappedIndices = []\n\n    let i = 0\n    polygonDimensions.forEach(function (dim) {\n      if (dim < 4) {\n        for (let k = 0; k < dim; k++) remappedIndices.push(indices[i + k])\n      } else if (dim === 4) {\n        remappedIndices.push(\n          indices[i],\n          indices[i + 1],\n          indices[i + 2],\n\n          indices[i],\n          indices[i + 2],\n          indices[i + 3],\n        )\n      } else if (dim > 4) {\n        for (let k = 1; k < dim - 1; k++) {\n          remappedIndices.push(indices[i], indices[i + k], indices[i + k + 1])\n        }\n\n        console.warn('LWOLoader: polygons with greater than 4 sides are not supported')\n      }\n\n      i += dim\n    })\n\n    return remappedIndices\n  }\n\n  // NOTE: currently ignoring poly indices and assuming that they are intelligently ordered\n  parseGroups(geometry, geoData) {\n    const tags = _lwoTree.tags\n    const matNames = []\n\n    let elemSize = 3\n    if (geoData.type === 'lines') elemSize = 2\n    if (geoData.type === 'points') elemSize = 1\n\n    const remappedIndices = this.splitMaterialIndices(geoData.polygonDimensions, geoData.materialIndices)\n\n    let indexNum = 0 // create new indices in numerical order\n    const indexPairs = {} // original indices mapped to numerical indices\n\n    let prevMaterialIndex\n    let materialIndex\n\n    let prevStart = 0\n    let currentCount = 0\n\n    for (let i = 0; i < remappedIndices.length; i += 2) {\n      materialIndex = remappedIndices[i + 1]\n\n      if (i === 0) matNames[indexNum] = tags[materialIndex]\n\n      if (prevMaterialIndex === undefined) prevMaterialIndex = materialIndex\n\n      if (materialIndex !== prevMaterialIndex) {\n        let currentIndex\n        if (indexPairs[tags[prevMaterialIndex]]) {\n          currentIndex = indexPairs[tags[prevMaterialIndex]]\n        } else {\n          currentIndex = indexNum\n          indexPairs[tags[prevMaterialIndex]] = indexNum\n          matNames[indexNum] = tags[prevMaterialIndex]\n          indexNum++\n        }\n\n        geometry.addGroup(prevStart, currentCount, currentIndex)\n\n        prevStart += currentCount\n\n        prevMaterialIndex = materialIndex\n        currentCount = 0\n      }\n\n      currentCount += elemSize\n    }\n\n    // the loop above doesn't add the last group, do that here.\n    if (geometry.groups.length > 0) {\n      let currentIndex\n      if (indexPairs[tags[materialIndex]]) {\n        currentIndex = indexPairs[tags[materialIndex]]\n      } else {\n        currentIndex = indexNum\n        indexPairs[tags[materialIndex]] = indexNum\n        matNames[indexNum] = tags[materialIndex]\n      }\n\n      geometry.addGroup(prevStart, currentCount, currentIndex)\n    }\n\n    // Mat names from TAGS chunk, used to build up an array of materials for this geometry\n    geometry.userData.matNames = matNames\n  }\n\n  splitMaterialIndices(polygonDimensions, indices) {\n    const remappedIndices = []\n\n    polygonDimensions.forEach(function (dim, i) {\n      if (dim <= 3) {\n        remappedIndices.push(indices[i * 2], indices[i * 2 + 1])\n      } else if (dim === 4) {\n        remappedIndices.push(indices[i * 2], indices[i * 2 + 1], indices[i * 2], indices[i * 2 + 1])\n      } else {\n        // ignore > 4 for now\n        for (let k = 0; k < dim - 2; k++) {\n          remappedIndices.push(indices[i * 2], indices[i * 2 + 1])\n        }\n      }\n    })\n\n    return remappedIndices\n  }\n\n  // UV maps:\n  // 1: are defined via index into an array of points, not into a geometry\n  // - the geometry is also defined by an index into this array, but the indexes may not match\n  // 2: there can be any number of UV maps for a single geometry. Here these are combined,\n  // \twith preference given to the first map encountered\n  // 3: UV maps can be partial - that is, defined for only a part of the geometry\n  // 4: UV maps can be VMAP or VMAD (discontinuous, to allow for seams). In practice, most\n  // UV maps are defined as partially VMAP and partially VMAD\n  // VMADs are currently not supported\n  parseUVs(geometry, layer) {\n    // start by creating a UV map set to zero for the whole geometry\n    const remappedUVs = Array.from(Array(geometry.attributes.position.count * 2), function () {\n      return 0\n    })\n\n    for (const name in layer.uvs) {\n      const uvs = layer.uvs[name].uvs\n      const uvIndices = layer.uvs[name].uvIndices\n\n      uvIndices.forEach(function (i, j) {\n        remappedUVs[i * 2] = uvs[j * 2]\n        remappedUVs[i * 2 + 1] = uvs[j * 2 + 1]\n      })\n    }\n\n    geometry.setAttribute('uv', new Float32BufferAttribute(remappedUVs, 2))\n  }\n\n  parseMorphTargets(geometry, layer) {\n    let num = 0\n    for (const name in layer.morphTargets) {\n      const remappedPoints = geometry.attributes.position.array.slice()\n\n      if (!geometry.morphAttributes.position) geometry.morphAttributes.position = []\n\n      const morphPoints = layer.morphTargets[name].points\n      const morphIndices = layer.morphTargets[name].indices\n      const type = layer.morphTargets[name].type\n\n      morphIndices.forEach(function (i, j) {\n        if (type === 'relative') {\n          remappedPoints[i * 3] += morphPoints[j * 3]\n          remappedPoints[i * 3 + 1] += morphPoints[j * 3 + 1]\n          remappedPoints[i * 3 + 2] += morphPoints[j * 3 + 2]\n        } else {\n          remappedPoints[i * 3] = morphPoints[j * 3]\n          remappedPoints[i * 3 + 1] = morphPoints[j * 3 + 1]\n          remappedPoints[i * 3 + 2] = morphPoints[j * 3 + 2]\n        }\n      })\n\n      geometry.morphAttributes.position[num] = new Float32BufferAttribute(remappedPoints, 3)\n      geometry.morphAttributes.position[num].name = name\n\n      num++\n    }\n\n    geometry.morphTargetsRelative = false\n  }\n}\n\n// ************** UTILITY FUNCTIONS **************\n\nfunction extractParentUrl(url, dir) {\n  const index = url.indexOf(dir)\n\n  if (index === -1) return './'\n\n  return url.substr(0, index)\n}\n\nexport { LWOLoader }\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}