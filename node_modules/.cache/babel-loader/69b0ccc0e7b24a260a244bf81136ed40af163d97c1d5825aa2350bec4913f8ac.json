{"ast":null,"code":"import _createClass from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _classCallCheck from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _inherits from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport { BufferGeometry, Vector3, Float32BufferAttribute } from \"three\";\nvar ParametricGeometry = /*#__PURE__*/function (_BufferGeometry) {\n  _inherits(ParametricGeometry, _BufferGeometry);\n  var _super = _createSuper(ParametricGeometry);\n  function ParametricGeometry() {\n    var _this;\n    var func = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : function (u, v, target) {\n      return target.set(u, v, Math.cos(u) * Math.sin(v));\n    };\n    var slices = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 8;\n    var stacks = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 8;\n    _classCallCheck(this, ParametricGeometry);\n    _this = _super.call(this);\n    _this.type = \"ParametricGeometry\";\n    _this.parameters = {\n      func: func,\n      slices: slices,\n      stacks: stacks\n    };\n    var indices = [];\n    var vertices = [];\n    var normals = [];\n    var uvs = [];\n    var EPS = 1e-5;\n    var normal = new Vector3();\n    var p0 = new Vector3(),\n      p1 = new Vector3();\n    var pu = new Vector3(),\n      pv = new Vector3();\n    var sliceCount = slices + 1;\n    for (var i = 0; i <= stacks; i++) {\n      var v = i / stacks;\n      for (var j = 0; j <= slices; j++) {\n        var u = j / slices;\n        func(u, v, p0);\n        vertices.push(p0.x, p0.y, p0.z);\n        if (u - EPS >= 0) {\n          func(u - EPS, v, p1);\n          pu.subVectors(p0, p1);\n        } else {\n          func(u + EPS, v, p1);\n          pu.subVectors(p1, p0);\n        }\n        if (v - EPS >= 0) {\n          func(u, v - EPS, p1);\n          pv.subVectors(p0, p1);\n        } else {\n          func(u, v + EPS, p1);\n          pv.subVectors(p1, p0);\n        }\n        normal.crossVectors(pu, pv).normalize();\n        normals.push(normal.x, normal.y, normal.z);\n        uvs.push(u, v);\n      }\n    }\n    for (var _i = 0; _i < stacks; _i++) {\n      for (var _j = 0; _j < slices; _j++) {\n        var a = _i * sliceCount + _j;\n        var b = _i * sliceCount + _j + 1;\n        var c = (_i + 1) * sliceCount + _j + 1;\n        var d = (_i + 1) * sliceCount + _j;\n        indices.push(a, b, d);\n        indices.push(b, c, d);\n      }\n    }\n    _this.setIndex(indices);\n    _this.setAttribute(\"position\", new Float32BufferAttribute(vertices, 3));\n    _this.setAttribute(\"normal\", new Float32BufferAttribute(normals, 3));\n    _this.setAttribute(\"uv\", new Float32BufferAttribute(uvs, 2));\n    return _this;\n  }\n  return _createClass(ParametricGeometry);\n}(BufferGeometry);\nexport { ParametricGeometry };","map":{"version":3,"names":["ParametricGeometry","_BufferGeometry","_inherits","_super","_createSuper","_this","func","arguments","length","undefined","u","v","target","set","Math","cos","sin","slices","stacks","_classCallCheck","call","type","parameters","indices","vertices","normals","uvs","EPS","normal","Vector3","p0","p1","pu","pv","sliceCount","i","j","push","x","y","z","subVectors","crossVectors","normalize","a","b","c","d","setIndex","setAttribute","Float32BufferAttribute","_createClass","BufferGeometry"],"sources":["C:\\Users\\Nayyu\\Desktop\\skibidai-public-build\\node_modules\\src\\geometries\\ParametricGeometry.js"],"sourcesContent":["import { BufferGeometry, Float32BufferAttribute, Vector3 } from 'three'\n\n/**\n * Parametric Surfaces Geometry\n * based on the brilliant article by @prideout https://prideout.net/blog/old/blog/index.html@p=44.html\n */\nclass ParametricGeometry extends BufferGeometry {\n  constructor(func = (u, v, target) => target.set(u, v, Math.cos(u) * Math.sin(v)), slices = 8, stacks = 8) {\n    super()\n\n    this.type = 'ParametricGeometry'\n\n    this.parameters = {\n      func: func,\n      slices: slices,\n      stacks: stacks,\n    }\n\n    // buffers\n\n    const indices = []\n    const vertices = []\n    const normals = []\n    const uvs = []\n\n    const EPS = 0.00001\n\n    const normal = new Vector3()\n\n    const p0 = new Vector3(),\n      p1 = new Vector3()\n    const pu = new Vector3(),\n      pv = new Vector3()\n\n    // generate vertices, normals and uvs\n\n    const sliceCount = slices + 1\n\n    for (let i = 0; i <= stacks; i++) {\n      const v = i / stacks\n\n      for (let j = 0; j <= slices; j++) {\n        const u = j / slices\n\n        // vertex\n\n        func(u, v, p0)\n        vertices.push(p0.x, p0.y, p0.z)\n\n        // normal\n\n        // approximate tangent vectors via finite differences\n\n        if (u - EPS >= 0) {\n          func(u - EPS, v, p1)\n          pu.subVectors(p0, p1)\n        } else {\n          func(u + EPS, v, p1)\n          pu.subVectors(p1, p0)\n        }\n\n        if (v - EPS >= 0) {\n          func(u, v - EPS, p1)\n          pv.subVectors(p0, p1)\n        } else {\n          func(u, v + EPS, p1)\n          pv.subVectors(p1, p0)\n        }\n\n        // cross product of tangent vectors returns surface normal\n\n        normal.crossVectors(pu, pv).normalize()\n        normals.push(normal.x, normal.y, normal.z)\n\n        // uv\n\n        uvs.push(u, v)\n      }\n    }\n\n    // generate indices\n\n    for (let i = 0; i < stacks; i++) {\n      for (let j = 0; j < slices; j++) {\n        const a = i * sliceCount + j\n        const b = i * sliceCount + j + 1\n        const c = (i + 1) * sliceCount + j + 1\n        const d = (i + 1) * sliceCount + j\n\n        // faces one and two\n\n        indices.push(a, b, d)\n        indices.push(b, c, d)\n      }\n    }\n\n    // build geometry\n\n    this.setIndex(indices)\n    this.setAttribute('position', new Float32BufferAttribute(vertices, 3))\n    this.setAttribute('normal', new Float32BufferAttribute(normals, 3))\n    this.setAttribute('uv', new Float32BufferAttribute(uvs, 2))\n  }\n}\n\nexport { ParametricGeometry }\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}