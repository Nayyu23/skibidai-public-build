{"ast":null,"code":"import _classCallCheck from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = function __defNormalProp(obj, key, value) {\n  return key in obj ? __defProp(obj, key, {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: value\n  }) : obj[key] = value;\n};\nvar __publicField = function __publicField(obj, key, value) {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nimport { OrthographicCamera, PlaneGeometry, Mesh } from \"three\";\nvar Pass = /*#__PURE__*/function () {\n  function Pass() {\n    _classCallCheck(this, Pass);\n    // if set to true, the pass is processed by the composer\n    __publicField(this, \"enabled\", true);\n    // if set to true, the pass indicates to swap read and write buffer after rendering\n    __publicField(this, \"needsSwap\", true);\n    // if set to true, the pass clears its buffer before rendering\n    __publicField(this, \"clear\", false);\n    // if set to true, the result of the pass is rendered to screen. This is set automatically by EffectComposer.\n    __publicField(this, \"renderToScreen\", false);\n  }\n  _createClass(Pass, [{\n    key: \"setSize\",\n    value: function setSize(width, height) {}\n  }, {\n    key: \"render\",\n    value: function render(renderer, writeBuffer, readBuffer, deltaTime, maskActive) {\n      console.error(\"THREE.Pass: .render() must be implemented in derived pass.\");\n    }\n  }]);\n  return Pass;\n}();\nvar FullScreenQuad = /*#__PURE__*/function () {\n  function FullScreenQuad(material) {\n    _classCallCheck(this, FullScreenQuad);\n    __publicField(this, \"camera\", new OrthographicCamera(-1, 1, 1, -1, 0, 1));\n    __publicField(this, \"geometry\", new PlaneGeometry(2, 2));\n    __publicField(this, \"mesh\");\n    this.mesh = new Mesh(this.geometry, material);\n  }\n  _createClass(FullScreenQuad, [{\n    key: \"material\",\n    get: function get() {\n      return this.mesh.material;\n    },\n    set: function set(value) {\n      this.mesh.material = value;\n    }\n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      this.mesh.geometry.dispose();\n    }\n  }, {\n    key: \"render\",\n    value: function render(renderer) {\n      renderer.render(this.mesh, this.camera);\n    }\n  }]);\n  return FullScreenQuad;\n}();\nexport { FullScreenQuad, Pass };","map":{"version":3,"names":["Pass","_classCallCheck","__publicField","_createClass","key","value","setSize","width","height","render","renderer","writeBuffer","readBuffer","deltaTime","maskActive","console","error","FullScreenQuad","material","OrthographicCamera","PlaneGeometry","mesh","Mesh","geometry","get","set","dispose","camera"],"sources":["C:\\Users\\Nayyu\\Desktop\\skibidai-public-build\\node_modules\\src\\postprocessing\\Pass.ts"],"sourcesContent":["import { OrthographicCamera, PlaneGeometry, Mesh, Material, Renderer, WebGLRenderer, WebGLRenderTarget } from 'three'\n\nclass Pass {\n  // if set to true, the pass is processed by the composer\n  public enabled = true\n\n  // if set to true, the pass indicates to swap read and write buffer after rendering\n  public needsSwap = true\n\n  // if set to true, the pass clears its buffer before rendering\n  public clear = false\n\n  // if set to true, the result of the pass is rendered to screen. This is set automatically by EffectComposer.\n  public renderToScreen = false\n\n  public setSize(width: number, height: number): void {}\n\n  public render(\n    renderer: WebGLRenderer,\n    writeBuffer: WebGLRenderTarget,\n    readBuffer: WebGLRenderTarget,\n    deltaTime: number,\n    maskActive?: unknown,\n  ): void {\n    console.error('THREE.Pass: .render() must be implemented in derived pass.')\n  }\n}\n\n// Helper for passes that need to fill the viewport with a single quad.\nclass FullScreenQuad<TMaterial extends Material = Material> {\n  public camera = new OrthographicCamera(-1, 1, 1, -1, 0, 1)\n  public geometry = new PlaneGeometry(2, 2)\n  private mesh: Mesh<PlaneGeometry, TMaterial>\n\n  constructor(material: TMaterial) {\n    this.mesh = new Mesh(this.geometry, material)\n  }\n\n  public get material(): TMaterial {\n    return this.mesh.material\n  }\n\n  public set material(value: TMaterial) {\n    this.mesh.material = value\n  }\n\n  public dispose(): void {\n    this.mesh.geometry.dispose()\n  }\n\n  public render(renderer: Renderer): void {\n    renderer.render(this.mesh, this.camera)\n  }\n}\n\nexport { Pass, FullScreenQuad }\n"],"mappings":";;;;;;;;;;;;;;;;IAEMA,IAAA;EAAN,SAAAA,KAAA;IAAAC,eAAA,OAAAD,IAAA;IAES;IAAAE,aAAA,kBAAU;IAGV;IAAAA,aAAA,oBAAY;IAGZ;IAAAA,aAAA,gBAAQ;IAGR;IAAAA,aAAA,yBAAiB;EAAA;EAAAC,YAAA,CAAAH,IAAA;IAAAI,GAAA;IAAAC,KAAA,EAEjB,SAAAC,QAAQC,KAAA,EAAeC,MAAA,EAAsB,CAAC;EAAA;IAAAJ,GAAA;IAAAC,KAAA,EAE9C,SAAAI,OACLC,QAAA,EACAC,WAAA,EACAC,UAAA,EACAC,SAAA,EACAC,UAAA,EACM;MACNC,OAAA,CAAQC,KAAA,CAAM,4DAA4D;IAC5E;EAAA;EAAA,OAAAhB,IAAA;AAAA;AAAA,IAIIiB,cAAA;EAKJ,SAAAA,eAAYC,QAAA,EAAqB;IAAAjB,eAAA,OAAAgB,cAAA;IAJ1Bf,aAAA,iBAAS,IAAIiB,kBAAA,CAAmB,IAAI,GAAG,GAAG,IAAI,GAAG,CAAC;IAClDjB,aAAA,mBAAW,IAAIkB,aAAA,CAAc,GAAG,CAAC;IAChClB,aAAA;IAGN,KAAKmB,IAAA,GAAO,IAAIC,IAAA,CAAK,KAAKC,QAAA,EAAUL,QAAQ;EAC9C;EAAAf,YAAA,CAAAc,cAAA;IAAAb,GAAA;IAAAoB,GAAA,EAEA,SAAAA,IAAA,EAAiC;MAC/B,OAAO,KAAKH,IAAA,CAAKH,QAAA;IACnB;IAAAO,GAAA,EAEA,SAAAA,IAAoBpB,KAAA,EAAkB;MACpC,KAAKgB,IAAA,CAAKH,QAAA,GAAWb,KAAA;IACvB;EAAA;IAAAD,GAAA;IAAAC,KAAA,EAEO,SAAAqB,QAAA,EAAgB;MAChB,KAAAL,IAAA,CAAKE,QAAA,CAASG,OAAA;IACrB;EAAA;IAAAtB,GAAA;IAAAC,KAAA,EAEO,SAAAI,OAAOC,QAAA,EAA0B;MACtCA,QAAA,CAASD,MAAA,CAAO,KAAKY,IAAA,EAAM,KAAKM,MAAM;IACxC;EAAA;EAAA,OAAAV,cAAA;AAAA"},"metadata":{},"sourceType":"module","externalDependencies":[]}