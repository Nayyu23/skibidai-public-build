{"ast":null,"code":"import _classCallCheck from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _inherits from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = function __defNormalProp(obj, key, value) {\n  return key in obj ? __defProp(obj, key, {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: value\n  }) : obj[key] = value;\n};\nvar __publicField = function __publicField(obj, key, value) {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nimport { Vector2, Color, WebGLRenderTarget, HalfFloatType, UniformsUtils, ShaderMaterial, Vector3, AdditiveBlending, MeshBasicMaterial } from \"three\";\nimport { Pass, FullScreenQuad } from \"./Pass.js\";\nimport { CopyShader } from \"../shaders/CopyShader.js\";\nimport { LuminosityHighPassShader } from \"../shaders/LuminosityHighPassShader.js\";\nvar _UnrealBloomPass = /*#__PURE__*/function (_Pass) {\n  _inherits(_UnrealBloomPass, _Pass);\n  var _super = _createSuper(_UnrealBloomPass);\n  function _UnrealBloomPass(resolution, strength, radius, threshold) {\n    var _this;\n    _classCallCheck(this, _UnrealBloomPass);\n    _this = _super.call(this);\n    _this.strength = strength !== void 0 ? strength : 1;\n    _this.radius = radius;\n    _this.threshold = threshold;\n    _this.resolution = resolution !== void 0 ? new Vector2(resolution.x, resolution.y) : new Vector2(256, 256);\n    _this.clearColor = new Color(0, 0, 0);\n    _this.renderTargetsHorizontal = [];\n    _this.renderTargetsVertical = [];\n    _this.nMips = 5;\n    var resx = Math.round(_this.resolution.x / 2);\n    var resy = Math.round(_this.resolution.y / 2);\n    _this.renderTargetBright = new WebGLRenderTarget(resx, resy, {\n      type: HalfFloatType\n    });\n    _this.renderTargetBright.texture.name = \"UnrealBloomPass.bright\";\n    _this.renderTargetBright.texture.generateMipmaps = false;\n    for (var i = 0; i < _this.nMips; i++) {\n      var renderTargetHorizonal = new WebGLRenderTarget(resx, resy, {\n        type: HalfFloatType\n      });\n      renderTargetHorizonal.texture.name = \"UnrealBloomPass.h\" + i;\n      renderTargetHorizonal.texture.generateMipmaps = false;\n      _this.renderTargetsHorizontal.push(renderTargetHorizonal);\n      var renderTargetVertical = new WebGLRenderTarget(resx, resy, {\n        type: HalfFloatType\n      });\n      renderTargetVertical.texture.name = \"UnrealBloomPass.v\" + i;\n      renderTargetVertical.texture.generateMipmaps = false;\n      _this.renderTargetsVertical.push(renderTargetVertical);\n      resx = Math.round(resx / 2);\n      resy = Math.round(resy / 2);\n    }\n    var highPassShader = LuminosityHighPassShader;\n    _this.highPassUniforms = UniformsUtils.clone(highPassShader.uniforms);\n    _this.highPassUniforms[\"luminosityThreshold\"].value = threshold;\n    _this.highPassUniforms[\"smoothWidth\"].value = 0.01;\n    _this.materialHighPassFilter = new ShaderMaterial({\n      uniforms: _this.highPassUniforms,\n      vertexShader: highPassShader.vertexShader,\n      fragmentShader: highPassShader.fragmentShader,\n      defines: {}\n    });\n    _this.separableBlurMaterials = [];\n    var kernelSizeArray = [3, 5, 7, 9, 11];\n    resx = Math.round(_this.resolution.x / 2);\n    resy = Math.round(_this.resolution.y / 2);\n    for (var _i = 0; _i < _this.nMips; _i++) {\n      _this.separableBlurMaterials.push(_this.getSeperableBlurMaterial(kernelSizeArray[_i]));\n      _this.separableBlurMaterials[_i].uniforms[\"texSize\"].value = new Vector2(resx, resy);\n      resx = Math.round(resx / 2);\n      resy = Math.round(resy / 2);\n    }\n    _this.compositeMaterial = _this.getCompositeMaterial(_this.nMips);\n    _this.compositeMaterial.uniforms[\"blurTexture1\"].value = _this.renderTargetsVertical[0].texture;\n    _this.compositeMaterial.uniforms[\"blurTexture2\"].value = _this.renderTargetsVertical[1].texture;\n    _this.compositeMaterial.uniforms[\"blurTexture3\"].value = _this.renderTargetsVertical[2].texture;\n    _this.compositeMaterial.uniforms[\"blurTexture4\"].value = _this.renderTargetsVertical[3].texture;\n    _this.compositeMaterial.uniforms[\"blurTexture5\"].value = _this.renderTargetsVertical[4].texture;\n    _this.compositeMaterial.uniforms[\"bloomStrength\"].value = strength;\n    _this.compositeMaterial.uniforms[\"bloomRadius\"].value = 0.1;\n    _this.compositeMaterial.needsUpdate = true;\n    var bloomFactors = [1, 0.8, 0.6, 0.4, 0.2];\n    _this.compositeMaterial.uniforms[\"bloomFactors\"].value = bloomFactors;\n    _this.bloomTintColors = [new Vector3(1, 1, 1), new Vector3(1, 1, 1), new Vector3(1, 1, 1), new Vector3(1, 1, 1), new Vector3(1, 1, 1)];\n    _this.compositeMaterial.uniforms[\"bloomTintColors\"].value = _this.bloomTintColors;\n    var copyShader = CopyShader;\n    _this.copyUniforms = UniformsUtils.clone(copyShader.uniforms);\n    _this.copyUniforms[\"opacity\"].value = 1;\n    _this.materialCopy = new ShaderMaterial({\n      uniforms: _this.copyUniforms,\n      vertexShader: copyShader.vertexShader,\n      fragmentShader: copyShader.fragmentShader,\n      blending: AdditiveBlending,\n      depthTest: false,\n      depthWrite: false,\n      transparent: true\n    });\n    _this.enabled = true;\n    _this.needsSwap = false;\n    _this._oldClearColor = new Color();\n    _this.oldClearAlpha = 1;\n    _this.basic = new MeshBasicMaterial();\n    _this.fsQuad = new FullScreenQuad(null);\n    return _this;\n  }\n  _createClass(_UnrealBloomPass, [{\n    key: \"dispose\",\n    value: function dispose() {\n      for (var i = 0; i < this.renderTargetsHorizontal.length; i++) {\n        this.renderTargetsHorizontal[i].dispose();\n      }\n      for (var _i2 = 0; _i2 < this.renderTargetsVertical.length; _i2++) {\n        this.renderTargetsVertical[_i2].dispose();\n      }\n      this.renderTargetBright.dispose();\n      for (var _i3 = 0; _i3 < this.separableBlurMaterials.length; _i3++) {\n        this.separableBlurMaterials[_i3].dispose();\n      }\n      this.compositeMaterial.dispose();\n      this.materialCopy.dispose();\n      this.basic.dispose();\n      this.fsQuad.dispose();\n    }\n  }, {\n    key: \"setSize\",\n    value: function setSize(width, height) {\n      var resx = Math.round(width / 2);\n      var resy = Math.round(height / 2);\n      this.renderTargetBright.setSize(resx, resy);\n      for (var i = 0; i < this.nMips; i++) {\n        this.renderTargetsHorizontal[i].setSize(resx, resy);\n        this.renderTargetsVertical[i].setSize(resx, resy);\n        this.separableBlurMaterials[i].uniforms[\"texSize\"].value = new Vector2(resx, resy);\n        resx = Math.round(resx / 2);\n        resy = Math.round(resy / 2);\n      }\n    }\n  }, {\n    key: \"render\",\n    value: function render(renderer, writeBuffer, readBuffer, deltaTime, maskActive) {\n      renderer.getClearColor(this._oldClearColor);\n      this.oldClearAlpha = renderer.getClearAlpha();\n      var oldAutoClear = renderer.autoClear;\n      renderer.autoClear = false;\n      renderer.setClearColor(this.clearColor, 0);\n      if (maskActive) renderer.state.buffers.stencil.setTest(false);\n      if (this.renderToScreen) {\n        this.fsQuad.material = this.basic;\n        this.basic.map = readBuffer.texture;\n        renderer.setRenderTarget(null);\n        renderer.clear();\n        this.fsQuad.render(renderer);\n      }\n      this.highPassUniforms[\"tDiffuse\"].value = readBuffer.texture;\n      this.highPassUniforms[\"luminosityThreshold\"].value = this.threshold;\n      this.fsQuad.material = this.materialHighPassFilter;\n      renderer.setRenderTarget(this.renderTargetBright);\n      renderer.clear();\n      this.fsQuad.render(renderer);\n      var inputRenderTarget = this.renderTargetBright;\n      for (var i = 0; i < this.nMips; i++) {\n        this.fsQuad.material = this.separableBlurMaterials[i];\n        this.separableBlurMaterials[i].uniforms[\"colorTexture\"].value = inputRenderTarget.texture;\n        this.separableBlurMaterials[i].uniforms[\"direction\"].value = _UnrealBloomPass.BlurDirectionX;\n        renderer.setRenderTarget(this.renderTargetsHorizontal[i]);\n        renderer.clear();\n        this.fsQuad.render(renderer);\n        this.separableBlurMaterials[i].uniforms[\"colorTexture\"].value = this.renderTargetsHorizontal[i].texture;\n        this.separableBlurMaterials[i].uniforms[\"direction\"].value = _UnrealBloomPass.BlurDirectionY;\n        renderer.setRenderTarget(this.renderTargetsVertical[i]);\n        renderer.clear();\n        this.fsQuad.render(renderer);\n        inputRenderTarget = this.renderTargetsVertical[i];\n      }\n      this.fsQuad.material = this.compositeMaterial;\n      this.compositeMaterial.uniforms[\"bloomStrength\"].value = this.strength;\n      this.compositeMaterial.uniforms[\"bloomRadius\"].value = this.radius;\n      this.compositeMaterial.uniforms[\"bloomTintColors\"].value = this.bloomTintColors;\n      renderer.setRenderTarget(this.renderTargetsHorizontal[0]);\n      renderer.clear();\n      this.fsQuad.render(renderer);\n      this.fsQuad.material = this.materialCopy;\n      this.copyUniforms[\"tDiffuse\"].value = this.renderTargetsHorizontal[0].texture;\n      if (maskActive) renderer.state.buffers.stencil.setTest(true);\n      if (this.renderToScreen) {\n        renderer.setRenderTarget(null);\n        this.fsQuad.render(renderer);\n      } else {\n        renderer.setRenderTarget(readBuffer);\n        this.fsQuad.render(renderer);\n      }\n      renderer.setClearColor(this._oldClearColor, this.oldClearAlpha);\n      renderer.autoClear = oldAutoClear;\n    }\n  }, {\n    key: \"getSeperableBlurMaterial\",\n    value: function getSeperableBlurMaterial(kernelRadius) {\n      return new ShaderMaterial({\n        defines: {\n          KERNEL_RADIUS: kernelRadius,\n          SIGMA: kernelRadius\n        },\n        uniforms: {\n          colorTexture: {\n            value: null\n          },\n          texSize: {\n            value: new Vector2(0.5, 0.5)\n          },\n          direction: {\n            value: new Vector2(0.5, 0.5)\n          }\n        },\n        vertexShader: \"varying vec2 vUv;\\n\\t\\t\\t\\tvoid main() {\\n\\t\\t\\t\\t\\tvUv = uv;\\n\\t\\t\\t\\t\\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n\\t\\t\\t\\t}\",\n        fragmentShader: \"#include <common>\\n\\t\\t\\t\\tvarying vec2 vUv;\\n\\t\\t\\t\\tuniform sampler2D colorTexture;\\n\\t\\t\\t\\tuniform vec2 texSize;\\n\\t\\t\\t\\tuniform vec2 direction;\\n\\n\\t\\t\\t\\tfloat gaussianPdf(in float x, in float sigma) {\\n\\t\\t\\t\\t\\treturn 0.39894 * exp( -0.5 * x * x/( sigma * sigma))/sigma;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tvoid main() {\\n\\t\\t\\t\\t\\tvec2 invSize = 1.0 / texSize;\\n\\t\\t\\t\\t\\tfloat fSigma = float(SIGMA);\\n\\t\\t\\t\\t\\tfloat weightSum = gaussianPdf(0.0, fSigma);\\n\\t\\t\\t\\t\\tvec3 diffuseSum = texture2D( colorTexture, vUv).rgb * weightSum;\\n\\t\\t\\t\\t\\tfor( int i = 1; i < KERNEL_RADIUS; i ++ ) {\\n\\t\\t\\t\\t\\t\\tfloat x = float(i);\\n\\t\\t\\t\\t\\t\\tfloat w = gaussianPdf(x, fSigma);\\n\\t\\t\\t\\t\\t\\tvec2 uvOffset = direction * invSize * x;\\n\\t\\t\\t\\t\\t\\tvec3 sample1 = texture2D( colorTexture, vUv + uvOffset).rgb;\\n\\t\\t\\t\\t\\t\\tvec3 sample2 = texture2D( colorTexture, vUv - uvOffset).rgb;\\n\\t\\t\\t\\t\\t\\tdiffuseSum += (sample1 + sample2) * w;\\n\\t\\t\\t\\t\\t\\tweightSum += 2.0 * w;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tgl_FragColor = vec4(diffuseSum/weightSum, 1.0);\\n\\t\\t\\t\\t}\"\n      });\n    }\n  }, {\n    key: \"getCompositeMaterial\",\n    value: function getCompositeMaterial(nMips) {\n      return new ShaderMaterial({\n        defines: {\n          NUM_MIPS: nMips\n        },\n        uniforms: {\n          blurTexture1: {\n            value: null\n          },\n          blurTexture2: {\n            value: null\n          },\n          blurTexture3: {\n            value: null\n          },\n          blurTexture4: {\n            value: null\n          },\n          blurTexture5: {\n            value: null\n          },\n          bloomStrength: {\n            value: 1\n          },\n          bloomFactors: {\n            value: null\n          },\n          bloomTintColors: {\n            value: null\n          },\n          bloomRadius: {\n            value: 0\n          }\n        },\n        vertexShader: \"varying vec2 vUv;\\n\\t\\t\\t\\tvoid main() {\\n\\t\\t\\t\\t\\tvUv = uv;\\n\\t\\t\\t\\t\\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n\\t\\t\\t\\t}\",\n        fragmentShader: \"varying vec2 vUv;\\n\\t\\t\\t\\tuniform sampler2D blurTexture1;\\n\\t\\t\\t\\tuniform sampler2D blurTexture2;\\n\\t\\t\\t\\tuniform sampler2D blurTexture3;\\n\\t\\t\\t\\tuniform sampler2D blurTexture4;\\n\\t\\t\\t\\tuniform sampler2D blurTexture5;\\n\\t\\t\\t\\tuniform float bloomStrength;\\n\\t\\t\\t\\tuniform float bloomRadius;\\n\\t\\t\\t\\tuniform float bloomFactors[NUM_MIPS];\\n\\t\\t\\t\\tuniform vec3 bloomTintColors[NUM_MIPS];\\n\\n\\t\\t\\t\\tfloat lerpBloomFactor(const in float factor) {\\n\\t\\t\\t\\t\\tfloat mirrorFactor = 1.2 - factor;\\n\\t\\t\\t\\t\\treturn mix(factor, mirrorFactor, bloomRadius);\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tvoid main() {\\n\\t\\t\\t\\t\\tgl_FragColor = bloomStrength * ( lerpBloomFactor(bloomFactors[0]) * vec4(bloomTintColors[0], 1.0) * texture2D(blurTexture1, vUv) +\\n\\t\\t\\t\\t\\t\\tlerpBloomFactor(bloomFactors[1]) * vec4(bloomTintColors[1], 1.0) * texture2D(blurTexture2, vUv) +\\n\\t\\t\\t\\t\\t\\tlerpBloomFactor(bloomFactors[2]) * vec4(bloomTintColors[2], 1.0) * texture2D(blurTexture3, vUv) +\\n\\t\\t\\t\\t\\t\\tlerpBloomFactor(bloomFactors[3]) * vec4(bloomTintColors[3], 1.0) * texture2D(blurTexture4, vUv) +\\n\\t\\t\\t\\t\\t\\tlerpBloomFactor(bloomFactors[4]) * vec4(bloomTintColors[4], 1.0) * texture2D(blurTexture5, vUv) );\\n\\t\\t\\t\\t}\"\n      });\n    }\n  }]);\n  return _UnrealBloomPass;\n}(Pass);\nvar UnrealBloomPass = _UnrealBloomPass;\n__publicField(UnrealBloomPass, \"BlurDirectionX\", new Vector2(1, 0));\n__publicField(UnrealBloomPass, \"BlurDirectionY\", new Vector2(0, 1));\nexport { UnrealBloomPass };","map":{"version":3,"names":["_UnrealBloomPass","_Pass","_inherits","_super","_createSuper","resolution","strength","radius","threshold","_this","_classCallCheck","call","Vector2","x","y","clearColor","Color","renderTargetsHorizontal","renderTargetsVertical","nMips","resx","Math","round","resy","renderTargetBright","WebGLRenderTarget","type","HalfFloatType","texture","name","generateMipmaps","i","renderTargetHorizonal","push","renderTargetVertical","highPassShader","LuminosityHighPassShader","highPassUniforms","UniformsUtils","clone","uniforms","value","materialHighPassFilter","ShaderMaterial","vertexShader","fragmentShader","defines","separableBlurMaterials","kernelSizeArray","getSeperableBlurMaterial","compositeMaterial","getCompositeMaterial","needsUpdate","bloomFactors","bloomTintColors","Vector3","copyShader","CopyShader","copyUniforms","materialCopy","blending","AdditiveBlending","depthTest","depthWrite","transparent","enabled","needsSwap","_oldClearColor","oldClearAlpha","basic","MeshBasicMaterial","fsQuad","FullScreenQuad","_createClass","key","dispose","length","setSize","width","height","render","renderer","writeBuffer","readBuffer","deltaTime","maskActive","getClearColor","getClearAlpha","oldAutoClear","autoClear","setClearColor","state","buffers","stencil","setTest","renderToScreen","material","map","setRenderTarget","clear","inputRenderTarget","BlurDirectionX","BlurDirectionY","kernelRadius","KERNEL_RADIUS","SIGMA","colorTexture","texSize","direction","NUM_MIPS","blurTexture1","blurTexture2","blurTexture3","blurTexture4","blurTexture5","bloomStrength","bloomRadius","Pass","UnrealBloomPass","__publicField"],"sources":["C:\\Users\\Nayyu\\Desktop\\skibidai-public-build\\node_modules\\src\\postprocessing\\UnrealBloomPass.js"],"sourcesContent":["import {\n  AdditiveBlending,\n  Color,\n  HalfFloatType,\n  MeshBasicMaterial,\n  ShaderMaterial,\n  UniformsUtils,\n  Vector2,\n  Vector3,\n  WebGLRenderTarget,\n} from 'three'\nimport { Pass, FullScreenQuad } from './Pass'\nimport { CopyShader } from '../shaders/CopyShader'\nimport { LuminosityHighPassShader } from '../shaders/LuminosityHighPassShader'\n\n/**\n * UnrealBloomPass is inspired by the bloom pass of Unreal Engine. It creates a\n * mip map chain of bloom textures and blurs them with different radii. Because\n * of the weighted combination of mips, and because larger blurs are done on\n * higher mips, this effect provides good quality and performance.\n *\n * Reference:\n * - https://docs.unrealengine.com/latest/INT/Engine/Rendering/PostProcessEffects/Bloom/\n */\nclass UnrealBloomPass extends Pass {\n  static BlurDirectionX = new Vector2(1.0, 0.0)\n  static BlurDirectionY = new Vector2(0.0, 1.0)\n\n  constructor(resolution, strength, radius, threshold) {\n    super()\n\n    this.strength = strength !== undefined ? strength : 1\n    this.radius = radius\n    this.threshold = threshold\n    this.resolution = resolution !== undefined ? new Vector2(resolution.x, resolution.y) : new Vector2(256, 256)\n\n    // create color only once here, reuse it later inside the render function\n    this.clearColor = new Color(0, 0, 0)\n\n    // render targets\n    this.renderTargetsHorizontal = []\n    this.renderTargetsVertical = []\n    this.nMips = 5\n    let resx = Math.round(this.resolution.x / 2)\n    let resy = Math.round(this.resolution.y / 2)\n\n    this.renderTargetBright = new WebGLRenderTarget(resx, resy, { type: HalfFloatType })\n    this.renderTargetBright.texture.name = 'UnrealBloomPass.bright'\n    this.renderTargetBright.texture.generateMipmaps = false\n\n    for (let i = 0; i < this.nMips; i++) {\n      const renderTargetHorizonal = new WebGLRenderTarget(resx, resy, { type: HalfFloatType })\n\n      renderTargetHorizonal.texture.name = 'UnrealBloomPass.h' + i\n      renderTargetHorizonal.texture.generateMipmaps = false\n\n      this.renderTargetsHorizontal.push(renderTargetHorizonal)\n\n      const renderTargetVertical = new WebGLRenderTarget(resx, resy, { type: HalfFloatType })\n\n      renderTargetVertical.texture.name = 'UnrealBloomPass.v' + i\n      renderTargetVertical.texture.generateMipmaps = false\n\n      this.renderTargetsVertical.push(renderTargetVertical)\n\n      resx = Math.round(resx / 2)\n\n      resy = Math.round(resy / 2)\n    }\n\n    // luminosity high pass material\n\n    const highPassShader = LuminosityHighPassShader\n    this.highPassUniforms = UniformsUtils.clone(highPassShader.uniforms)\n\n    this.highPassUniforms['luminosityThreshold'].value = threshold\n    this.highPassUniforms['smoothWidth'].value = 0.01\n\n    this.materialHighPassFilter = new ShaderMaterial({\n      uniforms: this.highPassUniforms,\n      vertexShader: highPassShader.vertexShader,\n      fragmentShader: highPassShader.fragmentShader,\n      defines: {},\n    })\n\n    // Gaussian Blur Materials\n    this.separableBlurMaterials = []\n    const kernelSizeArray = [3, 5, 7, 9, 11]\n    resx = Math.round(this.resolution.x / 2)\n    resy = Math.round(this.resolution.y / 2)\n\n    for (let i = 0; i < this.nMips; i++) {\n      this.separableBlurMaterials.push(this.getSeperableBlurMaterial(kernelSizeArray[i]))\n\n      this.separableBlurMaterials[i].uniforms['texSize'].value = new Vector2(resx, resy)\n\n      resx = Math.round(resx / 2)\n\n      resy = Math.round(resy / 2)\n    }\n\n    // Composite material\n    this.compositeMaterial = this.getCompositeMaterial(this.nMips)\n    this.compositeMaterial.uniforms['blurTexture1'].value = this.renderTargetsVertical[0].texture\n    this.compositeMaterial.uniforms['blurTexture2'].value = this.renderTargetsVertical[1].texture\n    this.compositeMaterial.uniforms['blurTexture3'].value = this.renderTargetsVertical[2].texture\n    this.compositeMaterial.uniforms['blurTexture4'].value = this.renderTargetsVertical[3].texture\n    this.compositeMaterial.uniforms['blurTexture5'].value = this.renderTargetsVertical[4].texture\n    this.compositeMaterial.uniforms['bloomStrength'].value = strength\n    this.compositeMaterial.uniforms['bloomRadius'].value = 0.1\n    this.compositeMaterial.needsUpdate = true\n\n    const bloomFactors = [1.0, 0.8, 0.6, 0.4, 0.2]\n    this.compositeMaterial.uniforms['bloomFactors'].value = bloomFactors\n    this.bloomTintColors = [\n      new Vector3(1, 1, 1),\n      new Vector3(1, 1, 1),\n      new Vector3(1, 1, 1),\n      new Vector3(1, 1, 1),\n      new Vector3(1, 1, 1),\n    ]\n    this.compositeMaterial.uniforms['bloomTintColors'].value = this.bloomTintColors\n\n    // copy material\n\n    const copyShader = CopyShader\n\n    this.copyUniforms = UniformsUtils.clone(copyShader.uniforms)\n    this.copyUniforms['opacity'].value = 1.0\n\n    this.materialCopy = new ShaderMaterial({\n      uniforms: this.copyUniforms,\n      vertexShader: copyShader.vertexShader,\n      fragmentShader: copyShader.fragmentShader,\n      blending: AdditiveBlending,\n      depthTest: false,\n      depthWrite: false,\n      transparent: true,\n    })\n\n    this.enabled = true\n    this.needsSwap = false\n\n    this._oldClearColor = new Color()\n    this.oldClearAlpha = 1\n\n    this.basic = new MeshBasicMaterial()\n\n    this.fsQuad = new FullScreenQuad(null)\n  }\n\n  dispose() {\n    for (let i = 0; i < this.renderTargetsHorizontal.length; i++) {\n      this.renderTargetsHorizontal[i].dispose()\n    }\n\n    for (let i = 0; i < this.renderTargetsVertical.length; i++) {\n      this.renderTargetsVertical[i].dispose()\n    }\n\n    this.renderTargetBright.dispose()\n\n    //\n\n    for (let i = 0; i < this.separableBlurMaterials.length; i++) {\n      this.separableBlurMaterials[i].dispose()\n    }\n\n    this.compositeMaterial.dispose()\n    this.materialCopy.dispose()\n    this.basic.dispose()\n\n    //\n\n    this.fsQuad.dispose()\n  }\n\n  setSize(width, height) {\n    let resx = Math.round(width / 2)\n    let resy = Math.round(height / 2)\n\n    this.renderTargetBright.setSize(resx, resy)\n\n    for (let i = 0; i < this.nMips; i++) {\n      this.renderTargetsHorizontal[i].setSize(resx, resy)\n      this.renderTargetsVertical[i].setSize(resx, resy)\n\n      this.separableBlurMaterials[i].uniforms['texSize'].value = new Vector2(resx, resy)\n\n      resx = Math.round(resx / 2)\n      resy = Math.round(resy / 2)\n    }\n  }\n\n  render(renderer, writeBuffer, readBuffer, deltaTime, maskActive) {\n    renderer.getClearColor(this._oldClearColor)\n    this.oldClearAlpha = renderer.getClearAlpha()\n    const oldAutoClear = renderer.autoClear\n    renderer.autoClear = false\n\n    renderer.setClearColor(this.clearColor, 0)\n\n    if (maskActive) renderer.state.buffers.stencil.setTest(false)\n\n    // Render input to screen\n\n    if (this.renderToScreen) {\n      this.fsQuad.material = this.basic\n      this.basic.map = readBuffer.texture\n\n      renderer.setRenderTarget(null)\n      renderer.clear()\n      this.fsQuad.render(renderer)\n    }\n\n    // 1. Extract Bright Areas\n\n    this.highPassUniforms['tDiffuse'].value = readBuffer.texture\n    this.highPassUniforms['luminosityThreshold'].value = this.threshold\n    this.fsQuad.material = this.materialHighPassFilter\n\n    renderer.setRenderTarget(this.renderTargetBright)\n    renderer.clear()\n    this.fsQuad.render(renderer)\n\n    // 2. Blur All the mips progressively\n\n    let inputRenderTarget = this.renderTargetBright\n\n    for (let i = 0; i < this.nMips; i++) {\n      this.fsQuad.material = this.separableBlurMaterials[i]\n\n      this.separableBlurMaterials[i].uniforms['colorTexture'].value = inputRenderTarget.texture\n      this.separableBlurMaterials[i].uniforms['direction'].value = UnrealBloomPass.BlurDirectionX\n      renderer.setRenderTarget(this.renderTargetsHorizontal[i])\n      renderer.clear()\n      this.fsQuad.render(renderer)\n\n      this.separableBlurMaterials[i].uniforms['colorTexture'].value = this.renderTargetsHorizontal[i].texture\n      this.separableBlurMaterials[i].uniforms['direction'].value = UnrealBloomPass.BlurDirectionY\n      renderer.setRenderTarget(this.renderTargetsVertical[i])\n      renderer.clear()\n      this.fsQuad.render(renderer)\n\n      inputRenderTarget = this.renderTargetsVertical[i]\n    }\n\n    // Composite All the mips\n\n    this.fsQuad.material = this.compositeMaterial\n    this.compositeMaterial.uniforms['bloomStrength'].value = this.strength\n    this.compositeMaterial.uniforms['bloomRadius'].value = this.radius\n    this.compositeMaterial.uniforms['bloomTintColors'].value = this.bloomTintColors\n\n    renderer.setRenderTarget(this.renderTargetsHorizontal[0])\n    renderer.clear()\n    this.fsQuad.render(renderer)\n\n    // Blend it additively over the input texture\n\n    this.fsQuad.material = this.materialCopy\n    this.copyUniforms['tDiffuse'].value = this.renderTargetsHorizontal[0].texture\n\n    if (maskActive) renderer.state.buffers.stencil.setTest(true)\n\n    if (this.renderToScreen) {\n      renderer.setRenderTarget(null)\n      this.fsQuad.render(renderer)\n    } else {\n      renderer.setRenderTarget(readBuffer)\n      this.fsQuad.render(renderer)\n    }\n\n    // Restore renderer settings\n\n    renderer.setClearColor(this._oldClearColor, this.oldClearAlpha)\n    renderer.autoClear = oldAutoClear\n  }\n\n  getSeperableBlurMaterial(kernelRadius) {\n    return new ShaderMaterial({\n      defines: {\n        KERNEL_RADIUS: kernelRadius,\n        SIGMA: kernelRadius,\n      },\n\n      uniforms: {\n        colorTexture: { value: null },\n        texSize: { value: new Vector2(0.5, 0.5) },\n        direction: { value: new Vector2(0.5, 0.5) },\n      },\n\n      vertexShader: `varying vec2 vUv;\n\t\t\t\tvoid main() {\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t}`,\n\n      fragmentShader: `#include <common>\n\t\t\t\tvarying vec2 vUv;\n\t\t\t\tuniform sampler2D colorTexture;\n\t\t\t\tuniform vec2 texSize;\n\t\t\t\tuniform vec2 direction;\n\n\t\t\t\tfloat gaussianPdf(in float x, in float sigma) {\n\t\t\t\t\treturn 0.39894 * exp( -0.5 * x * x/( sigma * sigma))/sigma;\n\t\t\t\t}\n\t\t\t\tvoid main() {\n\t\t\t\t\tvec2 invSize = 1.0 / texSize;\n\t\t\t\t\tfloat fSigma = float(SIGMA);\n\t\t\t\t\tfloat weightSum = gaussianPdf(0.0, fSigma);\n\t\t\t\t\tvec3 diffuseSum = texture2D( colorTexture, vUv).rgb * weightSum;\n\t\t\t\t\tfor( int i = 1; i < KERNEL_RADIUS; i ++ ) {\n\t\t\t\t\t\tfloat x = float(i);\n\t\t\t\t\t\tfloat w = gaussianPdf(x, fSigma);\n\t\t\t\t\t\tvec2 uvOffset = direction * invSize * x;\n\t\t\t\t\t\tvec3 sample1 = texture2D( colorTexture, vUv + uvOffset).rgb;\n\t\t\t\t\t\tvec3 sample2 = texture2D( colorTexture, vUv - uvOffset).rgb;\n\t\t\t\t\t\tdiffuseSum += (sample1 + sample2) * w;\n\t\t\t\t\t\tweightSum += 2.0 * w;\n\t\t\t\t\t}\n\t\t\t\t\tgl_FragColor = vec4(diffuseSum/weightSum, 1.0);\n\t\t\t\t}`,\n    })\n  }\n\n  getCompositeMaterial(nMips) {\n    return new ShaderMaterial({\n      defines: {\n        NUM_MIPS: nMips,\n      },\n\n      uniforms: {\n        blurTexture1: { value: null },\n        blurTexture2: { value: null },\n        blurTexture3: { value: null },\n        blurTexture4: { value: null },\n        blurTexture5: { value: null },\n        bloomStrength: { value: 1.0 },\n        bloomFactors: { value: null },\n        bloomTintColors: { value: null },\n        bloomRadius: { value: 0.0 },\n      },\n\n      vertexShader: `varying vec2 vUv;\n\t\t\t\tvoid main() {\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t}`,\n\n      fragmentShader: `varying vec2 vUv;\n\t\t\t\tuniform sampler2D blurTexture1;\n\t\t\t\tuniform sampler2D blurTexture2;\n\t\t\t\tuniform sampler2D blurTexture3;\n\t\t\t\tuniform sampler2D blurTexture4;\n\t\t\t\tuniform sampler2D blurTexture5;\n\t\t\t\tuniform float bloomStrength;\n\t\t\t\tuniform float bloomRadius;\n\t\t\t\tuniform float bloomFactors[NUM_MIPS];\n\t\t\t\tuniform vec3 bloomTintColors[NUM_MIPS];\n\n\t\t\t\tfloat lerpBloomFactor(const in float factor) {\n\t\t\t\t\tfloat mirrorFactor = 1.2 - factor;\n\t\t\t\t\treturn mix(factor, mirrorFactor, bloomRadius);\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\t\t\t\t\tgl_FragColor = bloomStrength * ( lerpBloomFactor(bloomFactors[0]) * vec4(bloomTintColors[0], 1.0) * texture2D(blurTexture1, vUv) +\n\t\t\t\t\t\tlerpBloomFactor(bloomFactors[1]) * vec4(bloomTintColors[1], 1.0) * texture2D(blurTexture2, vUv) +\n\t\t\t\t\t\tlerpBloomFactor(bloomFactors[2]) * vec4(bloomTintColors[2], 1.0) * texture2D(blurTexture3, vUv) +\n\t\t\t\t\t\tlerpBloomFactor(bloomFactors[3]) * vec4(bloomTintColors[3], 1.0) * texture2D(blurTexture4, vUv) +\n\t\t\t\t\t\tlerpBloomFactor(bloomFactors[4]) * vec4(bloomTintColors[4], 1.0) * texture2D(blurTexture5, vUv) );\n\t\t\t\t}`,\n    })\n  }\n}\n\nexport { UnrealBloomPass }\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}