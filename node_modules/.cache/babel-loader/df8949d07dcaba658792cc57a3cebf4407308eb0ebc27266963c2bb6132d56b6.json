{"ast":null,"code":"import { ensureIndex, getFullGeometryRange, getRootIndexRanges, getTriCount, hasGroupGaps } from './geometryUtils.js';\nimport { getBounds, computeTriangleBounds } from './computeBoundsUtils.js';\nimport { getOptimalSplit } from './splitUtils.js';\nimport { MeshBVHNode } from '../MeshBVHNode.js';\nimport { BYTES_PER_NODE } from '../Constants.js';\nimport { partition } from './sortUtils.generated.js';\nimport { partition_indirect } from './sortUtils_indirect.generated.js';\nimport { countNodes, populateBuffer } from './buildUtils.js';\nexport function generateIndirectBuffer(geometry, useSharedArrayBuffer) {\n  var triCount = (geometry.index ? geometry.index.count : geometry.attributes.position.count) / 3;\n  var useUint32 = triCount > Math.pow(2, 16);\n  var byteCount = useUint32 ? 4 : 2;\n  var buffer = useSharedArrayBuffer ? new SharedArrayBuffer(triCount * byteCount) : new ArrayBuffer(triCount * byteCount);\n  var indirectBuffer = useUint32 ? new Uint32Array(buffer) : new Uint16Array(buffer);\n  for (var i = 0, l = indirectBuffer.length; i < l; i++) {\n    indirectBuffer[i] = i;\n  }\n  return indirectBuffer;\n}\nexport function buildTree(bvh, triangleBounds, offset, count, options) {\n  // epxand variables\n  var maxDepth = options.maxDepth,\n    verbose = options.verbose,\n    maxLeafTris = options.maxLeafTris,\n    strategy = options.strategy,\n    onProgress = options.onProgress,\n    indirect = options.indirect;\n  var indirectBuffer = bvh._indirectBuffer;\n  var geometry = bvh.geometry;\n  var indexArray = geometry.index ? geometry.index.array : null;\n  var partionFunc = indirect ? partition_indirect : partition;\n\n  // generate intermediate variables\n  var totalTriangles = getTriCount(geometry);\n  var cacheCentroidBoundingData = new Float32Array(6);\n  var reachedMaxDepth = false;\n  var root = new MeshBVHNode();\n  getBounds(triangleBounds, offset, count, root.boundingData, cacheCentroidBoundingData);\n  splitNode(root, offset, count, cacheCentroidBoundingData);\n  return root;\n  function triggerProgress(trianglesProcessed) {\n    if (onProgress) {\n      onProgress(trianglesProcessed / totalTriangles);\n    }\n  }\n\n  // either recursively splits the given node, creating left and right subtrees for it, or makes it a leaf node,\n  // recording the offset and count of its triangles and writing them into the reordered geometry index.\n  function splitNode(node, offset, count) {\n    var centroidBoundingData = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n    var depth = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;\n    if (!reachedMaxDepth && depth >= maxDepth) {\n      reachedMaxDepth = true;\n      if (verbose) {\n        console.warn(\"MeshBVH: Max depth of \".concat(maxDepth, \" reached when generating BVH. Consider increasing maxDepth.\"));\n        console.warn(geometry);\n      }\n    }\n\n    // early out if we've met our capacity\n    if (count <= maxLeafTris || depth >= maxDepth) {\n      triggerProgress(offset + count);\n      node.offset = offset;\n      node.count = count;\n      return node;\n    }\n\n    // Find where to split the volume\n    var split = getOptimalSplit(node.boundingData, centroidBoundingData, triangleBounds, offset, count, strategy);\n    if (split.axis === -1) {\n      triggerProgress(offset + count);\n      node.offset = offset;\n      node.count = count;\n      return node;\n    }\n    var splitOffset = partionFunc(indirectBuffer, indexArray, triangleBounds, offset, count, split);\n\n    // create the two new child nodes\n    if (splitOffset === offset || splitOffset === offset + count) {\n      triggerProgress(offset + count);\n      node.offset = offset;\n      node.count = count;\n    } else {\n      node.splitAxis = split.axis;\n\n      // create the left child and compute its bounding box\n      var left = new MeshBVHNode();\n      var lstart = offset;\n      var lcount = splitOffset - offset;\n      node.left = left;\n      getBounds(triangleBounds, lstart, lcount, left.boundingData, cacheCentroidBoundingData);\n      splitNode(left, lstart, lcount, cacheCentroidBoundingData, depth + 1);\n\n      // repeat for right\n      var right = new MeshBVHNode();\n      var rstart = splitOffset;\n      var rcount = count - lcount;\n      node.right = right;\n      getBounds(triangleBounds, rstart, rcount, right.boundingData, cacheCentroidBoundingData);\n      splitNode(right, rstart, rcount, cacheCentroidBoundingData, depth + 1);\n    }\n    return node;\n  }\n}\nexport function buildPackedTree(bvh, options) {\n  var geometry = bvh.geometry;\n  if (options.indirect) {\n    bvh._indirectBuffer = generateIndirectBuffer(geometry, options.useSharedArrayBuffer);\n    if (hasGroupGaps(geometry) && !options.verbose) {\n      console.warn('MeshBVH: Provided geometry contains groups that do not fully span the vertex contents while using the \"indirect\" option. ' + 'BVH may incorrectly report intersections on unrendered portions of the geometry.');\n    }\n  }\n  if (!bvh._indirectBuffer) {\n    ensureIndex(geometry, options);\n  }\n  var BufferConstructor = options.useSharedArrayBuffer ? SharedArrayBuffer : ArrayBuffer;\n  var triangleBounds = computeTriangleBounds(geometry);\n  var geometryRanges = options.indirect ? getFullGeometryRange(geometry) : getRootIndexRanges(geometry);\n  bvh._roots = geometryRanges.map(function (range) {\n    var root = buildTree(bvh, triangleBounds, range.offset, range.count, options);\n    var nodeCount = countNodes(root);\n    var buffer = new BufferConstructor(BYTES_PER_NODE * nodeCount);\n    populateBuffer(0, root, buffer);\n    return buffer;\n  });\n}","map":{"version":3,"names":["ensureIndex","getFullGeometryRange","getRootIndexRanges","getTriCount","hasGroupGaps","getBounds","computeTriangleBounds","getOptimalSplit","MeshBVHNode","BYTES_PER_NODE","partition","partition_indirect","countNodes","populateBuffer","generateIndirectBuffer","geometry","useSharedArrayBuffer","triCount","index","count","attributes","position","useUint32","Math","pow","byteCount","buffer","SharedArrayBuffer","ArrayBuffer","indirectBuffer","Uint32Array","Uint16Array","i","l","length","buildTree","bvh","triangleBounds","offset","options","maxDepth","verbose","maxLeafTris","strategy","onProgress","indirect","_indirectBuffer","indexArray","array","partionFunc","totalTriangles","cacheCentroidBoundingData","Float32Array","reachedMaxDepth","root","boundingData","splitNode","triggerProgress","trianglesProcessed","node","centroidBoundingData","arguments","undefined","depth","console","warn","concat","split","axis","splitOffset","splitAxis","left","lstart","lcount","right","rstart","rcount","buildPackedTree","BufferConstructor","geometryRanges","_roots","map","range","nodeCount"],"sources":["C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/three-mesh-bvh/src/core/build/buildTree.js"],"sourcesContent":["import { ensureIndex, getFullGeometryRange, getRootIndexRanges, getTriCount, hasGroupGaps, } from './geometryUtils.js';\nimport { getBounds, computeTriangleBounds } from './computeBoundsUtils.js';\nimport { getOptimalSplit } from './splitUtils.js';\nimport { MeshBVHNode } from '../MeshBVHNode.js';\nimport { BYTES_PER_NODE } from '../Constants.js';\n\nimport { partition } from './sortUtils.generated.js';\nimport { partition_indirect } from './sortUtils_indirect.generated.js';\nimport { countNodes, populateBuffer } from './buildUtils.js';\n\nexport function generateIndirectBuffer( geometry, useSharedArrayBuffer ) {\n\n\tconst triCount = ( geometry.index ? geometry.index.count : geometry.attributes.position.count ) / 3;\n\tconst useUint32 = triCount > 2 ** 16;\n\tconst byteCount = useUint32 ? 4 : 2;\n\n\tconst buffer = useSharedArrayBuffer ? new SharedArrayBuffer( triCount * byteCount ) : new ArrayBuffer( triCount * byteCount );\n\tconst indirectBuffer = useUint32 ? new Uint32Array( buffer ) : new Uint16Array( buffer );\n\tfor ( let i = 0, l = indirectBuffer.length; i < l; i ++ ) {\n\n\t\tindirectBuffer[ i ] = i;\n\n\t}\n\n\treturn indirectBuffer;\n\n}\n\nexport function buildTree( bvh, triangleBounds, offset, count, options ) {\n\n\t// epxand variables\n\tconst {\n\t\tmaxDepth,\n\t\tverbose,\n\t\tmaxLeafTris,\n\t\tstrategy,\n\t\tonProgress,\n\t\tindirect,\n\t} = options;\n\tconst indirectBuffer = bvh._indirectBuffer;\n\tconst geometry = bvh.geometry;\n\tconst indexArray = geometry.index ? geometry.index.array : null;\n\tconst partionFunc = indirect ? partition_indirect : partition;\n\n\t// generate intermediate variables\n\tconst totalTriangles = getTriCount( geometry );\n\tconst cacheCentroidBoundingData = new Float32Array( 6 );\n\tlet reachedMaxDepth = false;\n\n\tconst root = new MeshBVHNode();\n\tgetBounds( triangleBounds, offset, count, root.boundingData, cacheCentroidBoundingData );\n\tsplitNode( root, offset, count, cacheCentroidBoundingData );\n\treturn root;\n\n\tfunction triggerProgress( trianglesProcessed ) {\n\n\t\tif ( onProgress ) {\n\n\t\t\tonProgress( trianglesProcessed / totalTriangles );\n\n\t\t}\n\n\t}\n\n\t// either recursively splits the given node, creating left and right subtrees for it, or makes it a leaf node,\n\t// recording the offset and count of its triangles and writing them into the reordered geometry index.\n\tfunction splitNode( node, offset, count, centroidBoundingData = null, depth = 0 ) {\n\n\t\tif ( ! reachedMaxDepth && depth >= maxDepth ) {\n\n\t\t\treachedMaxDepth = true;\n\t\t\tif ( verbose ) {\n\n\t\t\t\tconsole.warn( `MeshBVH: Max depth of ${ maxDepth } reached when generating BVH. Consider increasing maxDepth.` );\n\t\t\t\tconsole.warn( geometry );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// early out if we've met our capacity\n\t\tif ( count <= maxLeafTris || depth >= maxDepth ) {\n\n\t\t\ttriggerProgress( offset + count );\n\t\t\tnode.offset = offset;\n\t\t\tnode.count = count;\n\t\t\treturn node;\n\n\t\t}\n\n\t\t// Find where to split the volume\n\t\tconst split = getOptimalSplit( node.boundingData, centroidBoundingData, triangleBounds, offset, count, strategy );\n\t\tif ( split.axis === - 1 ) {\n\n\t\t\ttriggerProgress( offset + count );\n\t\t\tnode.offset = offset;\n\t\t\tnode.count = count;\n\t\t\treturn node;\n\n\t\t}\n\n\t\tconst splitOffset = partionFunc( indirectBuffer, indexArray, triangleBounds, offset, count, split );\n\n\t\t// create the two new child nodes\n\t\tif ( splitOffset === offset || splitOffset === offset + count ) {\n\n\t\t\ttriggerProgress( offset + count );\n\t\t\tnode.offset = offset;\n\t\t\tnode.count = count;\n\n\t\t} else {\n\n\t\t\tnode.splitAxis = split.axis;\n\n\t\t\t// create the left child and compute its bounding box\n\t\t\tconst left = new MeshBVHNode();\n\t\t\tconst lstart = offset;\n\t\t\tconst lcount = splitOffset - offset;\n\t\t\tnode.left = left;\n\n\t\t\tgetBounds( triangleBounds, lstart, lcount, left.boundingData, cacheCentroidBoundingData );\n\t\t\tsplitNode( left, lstart, lcount, cacheCentroidBoundingData, depth + 1 );\n\n\t\t\t// repeat for right\n\t\t\tconst right = new MeshBVHNode();\n\t\t\tconst rstart = splitOffset;\n\t\t\tconst rcount = count - lcount;\n\t\t\tnode.right = right;\n\n\t\t\tgetBounds( triangleBounds, rstart, rcount, right.boundingData, cacheCentroidBoundingData );\n\t\t\tsplitNode( right, rstart, rcount, cacheCentroidBoundingData, depth + 1 );\n\n\t\t}\n\n\t\treturn node;\n\n\t}\n\n}\n\nexport function buildPackedTree( bvh, options ) {\n\n\tconst geometry = bvh.geometry;\n\tif ( options.indirect ) {\n\n\t\tbvh._indirectBuffer = generateIndirectBuffer( geometry, options.useSharedArrayBuffer );\n\n\t\tif ( hasGroupGaps( geometry ) && ! options.verbose ) {\n\n\t\t\tconsole.warn(\n\t\t\t\t'MeshBVH: Provided geometry contains groups that do not fully span the vertex contents while using the \"indirect\" option. ' +\n\t\t\t\t'BVH may incorrectly report intersections on unrendered portions of the geometry.'\n\t\t\t);\n\n\t\t}\n\n\t}\n\n\tif ( ! bvh._indirectBuffer ) {\n\n\t\tensureIndex( geometry, options );\n\n\t}\n\n\tconst BufferConstructor = options.useSharedArrayBuffer ? SharedArrayBuffer : ArrayBuffer;\n\n\tconst triangleBounds = computeTriangleBounds( geometry );\n\tconst geometryRanges = options.indirect ? getFullGeometryRange( geometry ) : getRootIndexRanges( geometry );\n\tbvh._roots = geometryRanges.map( range => {\n\n\t\tconst root = buildTree( bvh, triangleBounds, range.offset, range.count, options );\n\t\tconst nodeCount = countNodes( root );\n\t\tconst buffer = new BufferConstructor( BYTES_PER_NODE * nodeCount );\n\t\tpopulateBuffer( 0, root, buffer );\n\t\treturn buffer;\n\n\t} );\n\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}