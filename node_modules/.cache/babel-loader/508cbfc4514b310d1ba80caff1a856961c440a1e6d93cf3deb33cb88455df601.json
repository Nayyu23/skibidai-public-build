{"ast":null,"code":"import _classCallCheck from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport { Mesh, Vector3, Matrix3 } from \"three\";\nvar PLYExporter = /*#__PURE__*/function () {\n  function PLYExporter() {\n    _classCallCheck(this, PLYExporter);\n  }\n  _createClass(PLYExporter, [{\n    key: \"parse\",\n    value: function parse(object, onDone, options) {\n      if (onDone && typeof onDone === \"object\") {\n        console.warn('THREE.PLYExporter: The options parameter is now the third argument to the \"parse\" function. See the documentation for the new API.');\n        options = onDone;\n        onDone = void 0;\n      }\n      var defaultOptions = {\n        binary: false,\n        excludeAttributes: [],\n        // normal, uv, color, index\n        littleEndian: false\n      };\n      options = Object.assign(defaultOptions, options);\n      var excludeAttributes = options.excludeAttributes;\n      var includeNormals = false;\n      var includeColors = false;\n      var includeUVs = false;\n      var vertexCount = 0;\n      var faceCount = 0;\n      object.traverse(function (child) {\n        if (child instanceof Mesh && child.isMesh) {\n          var mesh = child;\n          var geometry = mesh.geometry;\n          if (!geometry.isBufferGeometry) {\n            throw new Error(\"THREE.PLYExporter: Geometry is not of type THREE.BufferGeometry.\");\n          }\n          var vertices = geometry.getAttribute(\"position\");\n          var normals = geometry.getAttribute(\"normal\");\n          var uvs = geometry.getAttribute(\"uv\");\n          var colors = geometry.getAttribute(\"color\");\n          var indices = geometry.getIndex();\n          if (vertices === void 0) {\n            return;\n          }\n          vertexCount += vertices.count;\n          faceCount += indices ? indices.count / 3 : vertices.count / 3;\n          if (normals !== void 0) includeNormals = true;\n          if (uvs !== void 0) includeUVs = true;\n          if (colors !== void 0) includeColors = true;\n        }\n      });\n      var includeIndices = (excludeAttributes == null ? void 0 : excludeAttributes.indexOf(\"index\")) === -1;\n      includeNormals = includeNormals && (excludeAttributes == null ? void 0 : excludeAttributes.indexOf(\"normal\")) === -1;\n      includeColors = includeColors && (excludeAttributes == null ? void 0 : excludeAttributes.indexOf(\"color\")) === -1;\n      includeUVs = includeUVs && (excludeAttributes == null ? void 0 : excludeAttributes.indexOf(\"uv\")) === -1;\n      if (includeIndices && faceCount !== Math.floor(faceCount)) {\n        console.error(\"PLYExporter: Failed to generate a valid PLY file with triangle indices because the number of indices is not divisible by 3.\");\n        return null;\n      }\n      var indexByteCount = 4;\n      var header = \"ply\\nformat \".concat(options.binary ? options.littleEndian ? \"binary_little_endian\" : \"binary_big_endian\" : \"ascii\", \" 1.0\\nelement vertex \").concat(vertexCount, \"\\nproperty float x\\nproperty float y\\nproperty float z\\n\");\n      if (includeNormals) {\n        header += \"property float nx\\nproperty float ny\\nproperty float nz\\n\";\n      }\n      if (includeUVs) {\n        header += \"property float s\\nproperty float t\\n\";\n      }\n      if (includeColors) {\n        header += \"property uchar red\\nproperty uchar green\\nproperty uchar blue\\n\";\n      }\n      if (includeIndices) {\n        header += \"\".concat(\"element face \".concat(faceCount, \"\\n\"), \"property list uchar int vertex_index\\n\");\n      }\n      header += \"end_header\\n\";\n      var vertex = new Vector3();\n      var normalMatrixWorld = new Matrix3();\n      var result = null;\n      if (options.binary) {\n        var headerBin = new TextEncoder().encode(header);\n        var vertexListLength = vertexCount * (4 * 3 + (includeNormals ? 4 * 3 : 0) + (includeColors ? 3 : 0) + (includeUVs ? 4 * 2 : 0));\n        var faceListLength = includeIndices ? faceCount * (indexByteCount * 3 + 1) : 0;\n        var output = new DataView(new ArrayBuffer(headerBin.length + vertexListLength + faceListLength));\n        new Uint8Array(output.buffer).set(headerBin, 0);\n        var vOffset = headerBin.length;\n        var fOffset = headerBin.length + vertexListLength;\n        var writtenVertices = 0;\n        this.traverseMeshes(object, function (mesh, geometry) {\n          var vertices = geometry.getAttribute(\"position\");\n          var normals = geometry.getAttribute(\"normal\");\n          var uvs = geometry.getAttribute(\"uv\");\n          var colors = geometry.getAttribute(\"color\");\n          var indices = geometry.getIndex();\n          normalMatrixWorld.getNormalMatrix(mesh.matrixWorld);\n          for (var i = 0, l = vertices.count; i < l; i++) {\n            vertex.x = vertices.getX(i);\n            vertex.y = vertices.getY(i);\n            vertex.z = vertices.getZ(i);\n            vertex.applyMatrix4(mesh.matrixWorld);\n            output.setFloat32(vOffset, vertex.x, options.littleEndian);\n            vOffset += 4;\n            output.setFloat32(vOffset, vertex.y, options.littleEndian);\n            vOffset += 4;\n            output.setFloat32(vOffset, vertex.z, options.littleEndian);\n            vOffset += 4;\n            if (includeNormals) {\n              if (normals != null) {\n                vertex.x = normals.getX(i);\n                vertex.y = normals.getY(i);\n                vertex.z = normals.getZ(i);\n                vertex.applyMatrix3(normalMatrixWorld).normalize();\n                output.setFloat32(vOffset, vertex.x, options.littleEndian);\n                vOffset += 4;\n                output.setFloat32(vOffset, vertex.y, options.littleEndian);\n                vOffset += 4;\n                output.setFloat32(vOffset, vertex.z, options.littleEndian);\n                vOffset += 4;\n              } else {\n                output.setFloat32(vOffset, 0, options.littleEndian);\n                vOffset += 4;\n                output.setFloat32(vOffset, 0, options.littleEndian);\n                vOffset += 4;\n                output.setFloat32(vOffset, 0, options.littleEndian);\n                vOffset += 4;\n              }\n            }\n            if (includeUVs) {\n              if (uvs != null) {\n                output.setFloat32(vOffset, uvs.getX(i), options.littleEndian);\n                vOffset += 4;\n                output.setFloat32(vOffset, uvs.getY(i), options.littleEndian);\n                vOffset += 4;\n              } else if (!includeUVs) {\n                output.setFloat32(vOffset, 0, options.littleEndian);\n                vOffset += 4;\n                output.setFloat32(vOffset, 0, options.littleEndian);\n                vOffset += 4;\n              }\n            }\n            if (includeColors) {\n              if (colors != null) {\n                output.setUint8(vOffset, Math.floor(colors.getX(i) * 255));\n                vOffset += 1;\n                output.setUint8(vOffset, Math.floor(colors.getY(i) * 255));\n                vOffset += 1;\n                output.setUint8(vOffset, Math.floor(colors.getZ(i) * 255));\n                vOffset += 1;\n              } else {\n                output.setUint8(vOffset, 255);\n                vOffset += 1;\n                output.setUint8(vOffset, 255);\n                vOffset += 1;\n                output.setUint8(vOffset, 255);\n                vOffset += 1;\n              }\n            }\n          }\n          if (includeIndices) {\n            if (indices !== null) {\n              for (var _i = 0, _l = indices.count; _i < _l; _i += 3) {\n                output.setUint8(fOffset, 3);\n                fOffset += 1;\n                output.setUint32(fOffset, indices.getX(_i + 0) + writtenVertices, options.littleEndian);\n                fOffset += indexByteCount;\n                output.setUint32(fOffset, indices.getX(_i + 1) + writtenVertices, options.littleEndian);\n                fOffset += indexByteCount;\n                output.setUint32(fOffset, indices.getX(_i + 2) + writtenVertices, options.littleEndian);\n                fOffset += indexByteCount;\n              }\n            } else {\n              for (var _i2 = 0, _l2 = vertices.count; _i2 < _l2; _i2 += 3) {\n                output.setUint8(fOffset, 3);\n                fOffset += 1;\n                output.setUint32(fOffset, writtenVertices + _i2, options.littleEndian);\n                fOffset += indexByteCount;\n                output.setUint32(fOffset, writtenVertices + _i2 + 1, options.littleEndian);\n                fOffset += indexByteCount;\n                output.setUint32(fOffset, writtenVertices + _i2 + 2, options.littleEndian);\n                fOffset += indexByteCount;\n              }\n            }\n          }\n          writtenVertices += vertices.count;\n        });\n        result = output.buffer;\n      } else {\n        var _writtenVertices = 0;\n        var vertexList = \"\";\n        var faceList = \"\";\n        this.traverseMeshes(object, function (mesh, geometry) {\n          var vertices = geometry.getAttribute(\"position\");\n          var normals = geometry.getAttribute(\"normal\");\n          var uvs = geometry.getAttribute(\"uv\");\n          var colors = geometry.getAttribute(\"color\");\n          var indices = geometry.getIndex();\n          normalMatrixWorld.getNormalMatrix(mesh.matrixWorld);\n          for (var i = 0, l = vertices.count; i < l; i++) {\n            vertex.x = vertices.getX(i);\n            vertex.y = vertices.getY(i);\n            vertex.z = vertices.getZ(i);\n            vertex.applyMatrix4(mesh.matrixWorld);\n            var line = vertex.x + \" \" + vertex.y + \" \" + vertex.z;\n            if (includeNormals) {\n              if (normals != null) {\n                vertex.x = normals.getX(i);\n                vertex.y = normals.getY(i);\n                vertex.z = normals.getZ(i);\n                vertex.applyMatrix3(normalMatrixWorld).normalize();\n                line += \" \" + vertex.x + \" \" + vertex.y + \" \" + vertex.z;\n              } else {\n                line += \" 0 0 0\";\n              }\n            }\n            if (includeUVs) {\n              if (uvs != null) {\n                line += \" \" + uvs.getX(i) + \" \" + uvs.getY(i);\n              } else if (includeUVs) {\n                line += \" 0 0\";\n              }\n            }\n            if (includeColors) {\n              if (colors != null) {\n                line += \" \" + Math.floor(colors.getX(i) * 255) + \" \" + Math.floor(colors.getY(i) * 255) + \" \" + Math.floor(colors.getZ(i) * 255);\n              } else {\n                line += \" 255 255 255\";\n              }\n            }\n            vertexList += line + \"\\n\";\n          }\n          if (includeIndices) {\n            if (indices !== null) {\n              for (var _i3 = 0, _l3 = indices.count; _i3 < _l3; _i3 += 3) {\n                faceList += \"3 \".concat(indices.getX(_i3 + 0) + _writtenVertices);\n                faceList += \" \".concat(indices.getX(_i3 + 1) + _writtenVertices);\n                faceList += \" \".concat(indices.getX(_i3 + 2) + _writtenVertices, \"\\n\");\n              }\n            } else {\n              for (var _i4 = 0, _l4 = vertices.count; _i4 < _l4; _i4 += 3) {\n                faceList += \"3 \".concat(_writtenVertices + _i4, \" \").concat(_writtenVertices + _i4 + 1, \" \").concat(_writtenVertices + _i4 + 2, \"\\n\");\n              }\n            }\n            faceCount += indices ? indices.count / 3 : vertices.count / 3;\n          }\n          _writtenVertices += vertices.count;\n        });\n        result = \"\".concat(header).concat(vertexList).concat(includeIndices ? \"\".concat(faceList, \"\\n\") : \"\\n\");\n      }\n      if (typeof onDone === \"function\") {\n        requestAnimationFrame(function () {\n          return onDone && onDone(typeof result === \"string\" ? result : \"\");\n        });\n      }\n      return result;\n    }\n    // Iterate over the valid meshes in the object\n  }, {\n    key: \"traverseMeshes\",\n    value: function traverseMeshes(object, cb) {\n      object.traverse(function (child) {\n        if (child instanceof Mesh && child.isMesh) {\n          var mesh = child;\n          var geometry = mesh.geometry;\n          if (!geometry.isBufferGeometry) {\n            throw new Error(\"THREE.PLYExporter: Geometry is not of type THREE.BufferGeometry.\");\n          }\n          if (geometry.hasAttribute(\"position\")) {\n            cb(mesh, geometry);\n          }\n        }\n      });\n    }\n  }]);\n  return PLYExporter;\n}();\nexport { PLYExporter };","map":{"version":3,"names":["PLYExporter","_classCallCheck","_createClass","key","value","parse","object","onDone","options","console","warn","defaultOptions","binary","excludeAttributes","littleEndian","Object","assign","includeNormals","includeColors","includeUVs","vertexCount","faceCount","traverse","child","Mesh","isMesh","mesh","geometry","isBufferGeometry","Error","vertices","getAttribute","normals","uvs","colors","indices","getIndex","count","includeIndices","indexOf","Math","floor","error","indexByteCount","header","concat","vertex","Vector3","normalMatrixWorld","Matrix3","result","headerBin","TextEncoder","encode","vertexListLength","faceListLength","output","DataView","ArrayBuffer","length","Uint8Array","buffer","set","vOffset","fOffset","writtenVertices","traverseMeshes","getNormalMatrix","matrixWorld","i","l","x","getX","y","getY","z","getZ","applyMatrix4","setFloat32","applyMatrix3","normalize","setUint8","setUint32","vertexList","faceList","line","requestAnimationFrame","cb","hasAttribute"],"sources":["C:\\Users\\Nayyu\\Desktop\\skibidai-public-build\\node_modules\\src\\exporters\\PLYExporter.ts"],"sourcesContent":["import { BufferGeometry, Matrix3, Mesh, Object3D, Vector3 } from 'three'\n\n/**\n * https://github.com/gkjohnson/ply-exporter-js\n *\n * Usage:\n *  const exporter = new PLYExporter();\n *\n *  // second argument is a list of options\n *  exporter.parse(mesh, data => console.log(data), { binary: true, excludeAttributes: [ 'color' ], littleEndian: true });\n *\n * Format Definition:\n * http://paulbourke.net/dataformats/ply/\n */\n\nexport interface PLYExporterOptions {\n  binary?: boolean\n  excludeAttributes?: string[]\n  littleEndian?: boolean\n}\n\nclass PLYExporter {\n  public parse(\n    object: Object3D,\n    onDone: ((res: string) => void) | undefined,\n    options: PLYExporterOptions,\n  ): string | ArrayBuffer | null {\n    if (onDone && typeof onDone === 'object') {\n      console.warn(\n        'THREE.PLYExporter: The options parameter is now the third argument to the \"parse\" function. See the documentation for the new API.',\n      )\n      options = onDone\n      onDone = undefined\n    }\n\n    // Default options\n    const defaultOptions = {\n      binary: false,\n      excludeAttributes: [], // normal, uv, color, index\n      littleEndian: false,\n    }\n\n    options = Object.assign(defaultOptions, options)\n\n    const excludeAttributes = options.excludeAttributes\n    let includeNormals = false\n    let includeColors = false\n    let includeUVs = false\n\n    // count the vertices, check which properties are used,\n    // and cache the BufferGeometry\n    let vertexCount = 0\n    let faceCount = 0\n    object.traverse(function (child) {\n      if (child instanceof Mesh && child.isMesh) {\n        const mesh = child\n        const geometry = mesh.geometry\n\n        if (!geometry.isBufferGeometry) {\n          throw new Error('THREE.PLYExporter: Geometry is not of type THREE.BufferGeometry.')\n        }\n\n        const vertices = geometry.getAttribute('position')\n        const normals = geometry.getAttribute('normal')\n        const uvs = geometry.getAttribute('uv')\n        const colors = geometry.getAttribute('color')\n        const indices = geometry.getIndex()\n\n        if (vertices === undefined) {\n          return\n        }\n\n        vertexCount += vertices.count\n        faceCount += indices ? indices.count / 3 : vertices.count / 3\n\n        if (normals !== undefined) includeNormals = true\n\n        if (uvs !== undefined) includeUVs = true\n\n        if (colors !== undefined) includeColors = true\n      }\n    })\n\n    const includeIndices = excludeAttributes?.indexOf('index') === -1\n    includeNormals = includeNormals && excludeAttributes?.indexOf('normal') === -1\n    includeColors = includeColors && excludeAttributes?.indexOf('color') === -1\n    includeUVs = includeUVs && excludeAttributes?.indexOf('uv') === -1\n\n    if (includeIndices && faceCount !== Math.floor(faceCount)) {\n      // point cloud meshes will not have an index array and may not have a\n      // number of vertices that is divisble by 3 (and therefore representable\n      // as triangles)\n      console.error(\n        'PLYExporter: Failed to generate a valid PLY file with triangle indices because the ' +\n          'number of indices is not divisible by 3.',\n      )\n\n      return null\n    }\n\n    const indexByteCount = 4\n\n    let header =\n      'ply\\n' +\n      `format ${\n        options.binary ? (options.littleEndian ? 'binary_little_endian' : 'binary_big_endian') : 'ascii'\n      } 1.0\\n` +\n      `element vertex ${vertexCount}\\n` +\n      // position\n      'property float x\\n' +\n      'property float y\\n' +\n      'property float z\\n'\n\n    if (includeNormals) {\n      // normal\n      header += 'property float nx\\n' + 'property float ny\\n' + 'property float nz\\n'\n    }\n\n    if (includeUVs) {\n      // uvs\n      header += 'property float s\\n' + 'property float t\\n'\n    }\n\n    if (includeColors) {\n      // colors\n      header += 'property uchar red\\n' + 'property uchar green\\n' + 'property uchar blue\\n'\n    }\n\n    if (includeIndices) {\n      // faces\n      header += `${`element face ${faceCount}\\n`}property list uchar int vertex_index\\n`\n    }\n\n    header += 'end_header\\n'\n\n    // Generate attribute data\n    const vertex = new Vector3()\n    const normalMatrixWorld = new Matrix3()\n    let result: string | ArrayBuffer | null = null\n\n    if (options.binary) {\n      // Binary File Generation\n      const headerBin = new TextEncoder().encode(header)\n\n      // 3 position values at 4 bytes\n      // 3 normal values at 4 bytes\n      // 3 color channels with 1 byte\n      // 2 uv values at 4 bytes\n      const vertexListLength =\n        vertexCount * (4 * 3 + (includeNormals ? 4 * 3 : 0) + (includeColors ? 3 : 0) + (includeUVs ? 4 * 2 : 0))\n\n      // 1 byte shape desciptor\n      // 3 vertex indices at ${indexByteCount} bytes\n      const faceListLength = includeIndices ? faceCount * (indexByteCount * 3 + 1) : 0\n      const output = new DataView(new ArrayBuffer(headerBin.length + vertexListLength + faceListLength))\n      new Uint8Array(output.buffer).set(headerBin, 0)\n\n      let vOffset = headerBin.length\n      let fOffset = headerBin.length + vertexListLength\n      let writtenVertices = 0\n      this.traverseMeshes(object, function (mesh, geometry) {\n        const vertices = geometry.getAttribute('position')\n        const normals = geometry.getAttribute('normal')\n        const uvs = geometry.getAttribute('uv')\n        const colors = geometry.getAttribute('color')\n        const indices = geometry.getIndex()\n\n        normalMatrixWorld.getNormalMatrix(mesh.matrixWorld)\n\n        for (let i = 0, l = vertices.count; i < l; i++) {\n          vertex.x = vertices.getX(i)\n          vertex.y = vertices.getY(i)\n          vertex.z = vertices.getZ(i)\n\n          vertex.applyMatrix4(mesh.matrixWorld)\n\n          // Position information\n          output.setFloat32(vOffset, vertex.x, options.littleEndian)\n          vOffset += 4\n\n          output.setFloat32(vOffset, vertex.y, options.littleEndian)\n          vOffset += 4\n\n          output.setFloat32(vOffset, vertex.z, options.littleEndian)\n          vOffset += 4\n\n          // Normal information\n          if (includeNormals) {\n            if (normals != null) {\n              vertex.x = normals.getX(i)\n              vertex.y = normals.getY(i)\n              vertex.z = normals.getZ(i)\n\n              vertex.applyMatrix3(normalMatrixWorld).normalize()\n\n              output.setFloat32(vOffset, vertex.x, options.littleEndian)\n              vOffset += 4\n\n              output.setFloat32(vOffset, vertex.y, options.littleEndian)\n              vOffset += 4\n\n              output.setFloat32(vOffset, vertex.z, options.littleEndian)\n              vOffset += 4\n            } else {\n              output.setFloat32(vOffset, 0, options.littleEndian)\n              vOffset += 4\n\n              output.setFloat32(vOffset, 0, options.littleEndian)\n              vOffset += 4\n\n              output.setFloat32(vOffset, 0, options.littleEndian)\n              vOffset += 4\n            }\n          }\n\n          // UV information\n          if (includeUVs) {\n            if (uvs != null) {\n              output.setFloat32(vOffset, uvs.getX(i), options.littleEndian)\n              vOffset += 4\n\n              output.setFloat32(vOffset, uvs.getY(i), options.littleEndian)\n              vOffset += 4\n            } else if (!includeUVs) {\n              output.setFloat32(vOffset, 0, options.littleEndian)\n              vOffset += 4\n\n              output.setFloat32(vOffset, 0, options.littleEndian)\n              vOffset += 4\n            }\n          }\n\n          // Color information\n          if (includeColors) {\n            if (colors != null) {\n              output.setUint8(vOffset, Math.floor(colors.getX(i) * 255))\n              vOffset += 1\n\n              output.setUint8(vOffset, Math.floor(colors.getY(i) * 255))\n              vOffset += 1\n\n              output.setUint8(vOffset, Math.floor(colors.getZ(i) * 255))\n              vOffset += 1\n            } else {\n              output.setUint8(vOffset, 255)\n              vOffset += 1\n\n              output.setUint8(vOffset, 255)\n              vOffset += 1\n\n              output.setUint8(vOffset, 255)\n              vOffset += 1\n            }\n          }\n        }\n\n        if (includeIndices) {\n          // Create the face list\n\n          if (indices !== null) {\n            for (let i = 0, l = indices.count; i < l; i += 3) {\n              output.setUint8(fOffset, 3)\n              fOffset += 1\n\n              output.setUint32(fOffset, indices.getX(i + 0) + writtenVertices, options.littleEndian)\n              fOffset += indexByteCount\n\n              output.setUint32(fOffset, indices.getX(i + 1) + writtenVertices, options.littleEndian)\n              fOffset += indexByteCount\n\n              output.setUint32(fOffset, indices.getX(i + 2) + writtenVertices, options.littleEndian)\n              fOffset += indexByteCount\n            }\n          } else {\n            for (let i = 0, l = vertices.count; i < l; i += 3) {\n              output.setUint8(fOffset, 3)\n              fOffset += 1\n\n              output.setUint32(fOffset, writtenVertices + i, options.littleEndian)\n              fOffset += indexByteCount\n\n              output.setUint32(fOffset, writtenVertices + i + 1, options.littleEndian)\n              fOffset += indexByteCount\n\n              output.setUint32(fOffset, writtenVertices + i + 2, options.littleEndian)\n              fOffset += indexByteCount\n            }\n          }\n        }\n\n        // Save the amount of verts we've already written so we can offset\n        // the face index on the next mesh\n        writtenVertices += vertices.count\n      })\n\n      result = output.buffer\n    } else {\n      // Ascii File Generation\n      // count the number of vertices\n      let writtenVertices = 0\n      let vertexList = ''\n      let faceList = ''\n\n      this.traverseMeshes(object, function (mesh, geometry) {\n        const vertices = geometry.getAttribute('position')\n        const normals = geometry.getAttribute('normal')\n        const uvs = geometry.getAttribute('uv')\n        const colors = geometry.getAttribute('color')\n        const indices = geometry.getIndex()\n\n        normalMatrixWorld.getNormalMatrix(mesh.matrixWorld)\n\n        // form each line\n        for (let i = 0, l = vertices.count; i < l; i++) {\n          vertex.x = vertices.getX(i)\n          vertex.y = vertices.getY(i)\n          vertex.z = vertices.getZ(i)\n\n          vertex.applyMatrix4(mesh.matrixWorld)\n\n          // Position information\n          let line = vertex.x + ' ' + vertex.y + ' ' + vertex.z\n\n          // Normal information\n          if (includeNormals) {\n            if (normals != null) {\n              vertex.x = normals.getX(i)\n              vertex.y = normals.getY(i)\n              vertex.z = normals.getZ(i)\n\n              vertex.applyMatrix3(normalMatrixWorld).normalize()\n\n              line += ' ' + vertex.x + ' ' + vertex.y + ' ' + vertex.z\n            } else {\n              line += ' 0 0 0'\n            }\n          }\n\n          // UV information\n          if (includeUVs) {\n            if (uvs != null) {\n              line += ' ' + uvs.getX(i) + ' ' + uvs.getY(i)\n            } else if (includeUVs) {\n              line += ' 0 0'\n            }\n          }\n\n          // Color information\n          if (includeColors) {\n            if (colors != null) {\n              line +=\n                ' ' +\n                Math.floor(colors.getX(i) * 255) +\n                ' ' +\n                Math.floor(colors.getY(i) * 255) +\n                ' ' +\n                Math.floor(colors.getZ(i) * 255)\n            } else {\n              line += ' 255 255 255'\n            }\n          }\n\n          vertexList += line + '\\n'\n        }\n\n        // Create the face list\n        if (includeIndices) {\n          if (indices !== null) {\n            for (let i = 0, l = indices.count; i < l; i += 3) {\n              faceList += `3 ${indices.getX(i + 0) + writtenVertices}`\n              faceList += ` ${indices.getX(i + 1) + writtenVertices}`\n              faceList += ` ${indices.getX(i + 2) + writtenVertices}\\n`\n            }\n          } else {\n            for (let i = 0, l = vertices.count; i < l; i += 3) {\n              faceList += `3 ${writtenVertices + i} ${writtenVertices + i + 1} ${writtenVertices + i + 2}\\n`\n            }\n          }\n\n          faceCount += indices ? indices.count / 3 : vertices.count / 3\n        }\n\n        writtenVertices += vertices.count\n      })\n\n      result = `${header}${vertexList}${includeIndices ? `${faceList}\\n` : '\\n'}`\n    }\n\n    if (typeof onDone === 'function') {\n      requestAnimationFrame(() => onDone && onDone(typeof result === 'string' ? result : ''))\n    }\n\n    return result\n  }\n\n  // Iterate over the valid meshes in the object\n  private traverseMeshes(object: Object3D, cb: (mesh: Mesh, geometry: BufferGeometry) => void): void {\n    object.traverse(function (child) {\n      if (child instanceof Mesh && child.isMesh) {\n        const mesh = child\n        const geometry = mesh.geometry\n\n        if (!geometry.isBufferGeometry) {\n          throw new Error('THREE.PLYExporter: Geometry is not of type THREE.BufferGeometry.')\n        }\n\n        if (geometry.hasAttribute('position')) {\n          cb(mesh, geometry)\n        }\n      }\n    })\n  }\n}\n\nexport { PLYExporter }\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}