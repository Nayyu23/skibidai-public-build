{"ast":null,"code":"import _get from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/get.js\";\nimport _getPrototypeOf from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js\";\nimport _inherits from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport _classCallCheck from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport { Quaternion, Vector3, Matrix4, Object3D, SphereGeometry, MeshBasicMaterial, Color, LineBasicMaterial, Mesh, Line, BufferGeometry, BufferAttribute } from \"three\";\nvar _q = new Quaternion();\nvar _targetPos = new Vector3();\nvar _targetVec = new Vector3();\nvar _effectorPos = new Vector3();\nvar _effectorVec = new Vector3();\nvar _linkPos = new Vector3();\nvar _invLinkQ = new Quaternion();\nvar _linkScale = new Vector3();\nvar _axis = new Vector3();\nvar _vector = new Vector3();\nvar _matrix = new Matrix4();\nvar CCDIKSolver = /*#__PURE__*/function () {\n  /**\n   * @param {THREE.SkinnedMesh} mesh\n   * @param {Array<Object>} iks\n   */\n  function CCDIKSolver(mesh) {\n    var iks = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    _classCallCheck(this, CCDIKSolver);\n    this.mesh = mesh;\n    this.iks = iks;\n    this._valid();\n  }\n  /**\n   * Update all IK bones.\n   *\n   * @return {CCDIKSolver}\n   */\n  _createClass(CCDIKSolver, [{\n    key: \"update\",\n    value: function update() {\n      var iks = this.iks;\n      for (var i = 0, il = iks.length; i < il; i++) {\n        this.updateOne(iks[i]);\n      }\n      return this;\n    }\n    /**\n     * Update one IK bone\n     *\n     * @param {Object} ik parameter\n     * @return {CCDIKSolver}\n     */\n  }, {\n    key: \"updateOne\",\n    value: function updateOne(ik) {\n      var bones = this.mesh.skeleton.bones;\n      var math = Math;\n      var effector = bones[ik.effector];\n      var target = bones[ik.target];\n      _targetPos.setFromMatrixPosition(target.matrixWorld);\n      var links = ik.links;\n      var iteration = ik.iteration !== void 0 ? ik.iteration : 1;\n      for (var i = 0; i < iteration; i++) {\n        var rotated = false;\n        for (var j = 0, jl = links.length; j < jl; j++) {\n          var link = bones[links[j].index];\n          if (links[j].enabled === false) break;\n          var limitation = links[j].limitation;\n          var rotationMin = links[j].rotationMin;\n          var rotationMax = links[j].rotationMax;\n          link.matrixWorld.decompose(_linkPos, _invLinkQ, _linkScale);\n          _invLinkQ.invert();\n          _effectorPos.setFromMatrixPosition(effector.matrixWorld);\n          _effectorVec.subVectors(_effectorPos, _linkPos);\n          _effectorVec.applyQuaternion(_invLinkQ);\n          _effectorVec.normalize();\n          _targetVec.subVectors(_targetPos, _linkPos);\n          _targetVec.applyQuaternion(_invLinkQ);\n          _targetVec.normalize();\n          var angle = _targetVec.dot(_effectorVec);\n          if (angle > 1) {\n            angle = 1;\n          } else if (angle < -1) {\n            angle = -1;\n          }\n          angle = math.acos(angle);\n          if (angle < 1e-5) continue;\n          if (ik.minAngle !== void 0 && angle < ik.minAngle) {\n            angle = ik.minAngle;\n          }\n          if (ik.maxAngle !== void 0 && angle > ik.maxAngle) {\n            angle = ik.maxAngle;\n          }\n          _axis.crossVectors(_effectorVec, _targetVec);\n          _axis.normalize();\n          _q.setFromAxisAngle(_axis, angle);\n          link.quaternion.multiply(_q);\n          if (limitation !== void 0) {\n            var c = link.quaternion.w;\n            if (c > 1) c = 1;\n            var c2 = math.sqrt(1 - c * c);\n            link.quaternion.set(limitation.x * c2, limitation.y * c2, limitation.z * c2, c);\n          }\n          if (rotationMin !== void 0) {\n            link.rotation.setFromVector3(_vector.setFromEuler(link.rotation).max(rotationMin));\n          }\n          if (rotationMax !== void 0) {\n            link.rotation.setFromVector3(_vector.setFromEuler(link.rotation).min(rotationMax));\n          }\n          link.updateMatrixWorld(true);\n          rotated = true;\n        }\n        if (!rotated) break;\n      }\n      return this;\n    }\n    /**\n     * Creates Helper\n     *\n     * @return {CCDIKHelper}\n     */\n  }, {\n    key: \"createHelper\",\n    value: function createHelper() {\n      return new CCDIKHelper(this.mesh, this.iks);\n    }\n    // private methods\n  }, {\n    key: \"_valid\",\n    value: function _valid() {\n      var iks = this.iks;\n      var bones = this.mesh.skeleton.bones;\n      for (var i = 0, il = iks.length; i < il; i++) {\n        var ik = iks[i];\n        var effector = bones[ik.effector];\n        var links = ik.links;\n        var link0 = void 0,\n          link1 = void 0;\n        link0 = effector;\n        for (var j = 0, jl = links.length; j < jl; j++) {\n          link1 = bones[links[j].index];\n          if (link0.parent !== link1) {\n            console.warn(\"THREE.CCDIKSolver: bone \" + link0.name + \" is not the child of bone \" + link1.name);\n          }\n          link0 = link1;\n        }\n      }\n    }\n  }]);\n  return CCDIKSolver;\n}();\nfunction getPosition(bone, matrixWorldInv) {\n  return _vector.setFromMatrixPosition(bone.matrixWorld).applyMatrix4(matrixWorldInv);\n}\nfunction setPositionOfBoneToAttributeArray(array, index, bone, matrixWorldInv) {\n  var v = getPosition(bone, matrixWorldInv);\n  array[index * 3 + 0] = v.x;\n  array[index * 3 + 1] = v.y;\n  array[index * 3 + 2] = v.z;\n}\nvar CCDIKHelper = /*#__PURE__*/function (_Object3D) {\n  _inherits(CCDIKHelper, _Object3D);\n  var _super = _createSuper(CCDIKHelper);\n  function CCDIKHelper(mesh) {\n    var _this;\n    var iks = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    var sphereSize = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0.25;\n    _classCallCheck(this, CCDIKHelper);\n    _this = _super.call(this);\n    _this.root = mesh;\n    _this.iks = iks;\n    _this.matrix.copy(mesh.matrixWorld);\n    _this.matrixAutoUpdate = false;\n    _this.sphereGeometry = new SphereGeometry(sphereSize, 16, 8);\n    _this.targetSphereMaterial = new MeshBasicMaterial({\n      color: new Color(16746632),\n      depthTest: false,\n      depthWrite: false,\n      transparent: true\n    });\n    _this.effectorSphereMaterial = new MeshBasicMaterial({\n      color: new Color(8978312),\n      depthTest: false,\n      depthWrite: false,\n      transparent: true\n    });\n    _this.linkSphereMaterial = new MeshBasicMaterial({\n      color: new Color(8947967),\n      depthTest: false,\n      depthWrite: false,\n      transparent: true\n    });\n    _this.lineMaterial = new LineBasicMaterial({\n      color: new Color(16711680),\n      depthTest: false,\n      depthWrite: false,\n      transparent: true\n    });\n    _this._init();\n    return _this;\n  }\n  /**\n   * Updates IK bones visualization.\n   */\n  _createClass(CCDIKHelper, [{\n    key: \"updateMatrixWorld\",\n    value: function updateMatrixWorld(force) {\n      var mesh = this.root;\n      if (this.visible) {\n        var offset = 0;\n        var iks = this.iks;\n        var bones = mesh.skeleton.bones;\n        _matrix.copy(mesh.matrixWorld).invert();\n        for (var i = 0, il = iks.length; i < il; i++) {\n          var ik = iks[i];\n          var targetBone = bones[ik.target];\n          var effectorBone = bones[ik.effector];\n          var targetMesh = this.children[offset++];\n          var effectorMesh = this.children[offset++];\n          targetMesh.position.copy(getPosition(targetBone, _matrix));\n          effectorMesh.position.copy(getPosition(effectorBone, _matrix));\n          for (var j = 0, jl = ik.links.length; j < jl; j++) {\n            var link = ik.links[j];\n            var linkBone = bones[link.index];\n            var linkMesh = this.children[offset++];\n            linkMesh.position.copy(getPosition(linkBone, _matrix));\n          }\n          var line = this.children[offset++];\n          var array = line.geometry.attributes.position.array;\n          setPositionOfBoneToAttributeArray(array, 0, targetBone, _matrix);\n          setPositionOfBoneToAttributeArray(array, 1, effectorBone, _matrix);\n          for (var _j = 0, _jl = ik.links.length; _j < _jl; _j++) {\n            var _link = ik.links[_j];\n            var _linkBone = bones[_link.index];\n            setPositionOfBoneToAttributeArray(array, _j + 2, _linkBone, _matrix);\n          }\n          line.geometry.attributes.position.needsUpdate = true;\n        }\n      }\n      this.matrix.copy(mesh.matrixWorld);\n      _get(_getPrototypeOf(CCDIKHelper.prototype), \"updateMatrixWorld\", this).call(this, force);\n    }\n    /**\n     * Frees the GPU-related resources allocated by this instance. Call this method whenever this instance is no longer used in your app.\n     */\n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      this.sphereGeometry.dispose();\n      this.targetSphereMaterial.dispose();\n      this.effectorSphereMaterial.dispose();\n      this.linkSphereMaterial.dispose();\n      this.lineMaterial.dispose();\n      var children = this.children;\n      for (var i = 0; i < children.length; i++) {\n        var child = children[i];\n        if (child.isLine) child.geometry.dispose();\n      }\n    }\n    // private method\n  }, {\n    key: \"_init\",\n    value: function _init() {\n      var scope = this;\n      var iks = this.iks;\n      function createLineGeometry(ik) {\n        var geometry = new BufferGeometry();\n        var vertices = new Float32Array((2 + ik.links.length) * 3);\n        geometry.setAttribute(\"position\", new BufferAttribute(vertices, 3));\n        return geometry;\n      }\n      function createTargetMesh() {\n        return new Mesh(scope.sphereGeometry, scope.targetSphereMaterial);\n      }\n      function createEffectorMesh() {\n        return new Mesh(scope.sphereGeometry, scope.effectorSphereMaterial);\n      }\n      function createLinkMesh() {\n        return new Mesh(scope.sphereGeometry, scope.linkSphereMaterial);\n      }\n      function createLine(ik) {\n        return new Line(createLineGeometry(ik), scope.lineMaterial);\n      }\n      for (var i = 0, il = iks.length; i < il; i++) {\n        var ik = iks[i];\n        this.add(createTargetMesh());\n        this.add(createEffectorMesh());\n        for (var j = 0, jl = ik.links.length; j < jl; j++) {\n          this.add(createLinkMesh());\n        }\n        this.add(createLine(ik));\n      }\n    }\n  }]);\n  return CCDIKHelper;\n}(Object3D);\nexport { CCDIKHelper, CCDIKSolver };","map":{"version":3,"names":["_q","Quaternion","_targetPos","Vector3","_targetVec","_effectorPos","_effectorVec","_linkPos","_invLinkQ","_linkScale","_axis","_vector","_matrix","Matrix4","CCDIKSolver","mesh","iks","arguments","length","undefined","_classCallCheck","_valid","_createClass","key","value","update","i","il","updateOne","ik","bones","skeleton","math","Math","effector","target","setFromMatrixPosition","matrixWorld","links","iteration","rotated","j","jl","link","index","enabled","limitation","rotationMin","rotationMax","decompose","invert","subVectors","applyQuaternion","normalize","angle","dot","acos","minAngle","maxAngle","crossVectors","setFromAxisAngle","quaternion","multiply","c","w","c2","sqrt","set","x","y","z","rotation","setFromVector3","setFromEuler","max","min","updateMatrixWorld","createHelper","CCDIKHelper","link0","link1","parent","console","warn","name","getPosition","bone","matrixWorldInv","applyMatrix4","setPositionOfBoneToAttributeArray","array","v","_Object3D","_inherits","_super","_createSuper","_this","sphereSize","call","root","matrix","copy","matrixAutoUpdate","sphereGeometry","SphereGeometry","targetSphereMaterial","MeshBasicMaterial","color","Color","depthTest","depthWrite","transparent","effectorSphereMaterial","linkSphereMaterial","lineMaterial","LineBasicMaterial","_init","force","visible","offset","targetBone","effectorBone","targetMesh","children","effectorMesh","position","linkBone","linkMesh","line","geometry","attributes","needsUpdate","_get","_getPrototypeOf","prototype","dispose","child","isLine","scope","createLineGeometry","BufferGeometry","vertices","Float32Array","setAttribute","BufferAttribute","createTargetMesh","Mesh","createEffectorMesh","createLinkMesh","createLine","Line","add","Object3D"],"sources":["C:\\Users\\Nayyu\\Desktop\\skibidai-public-build\\node_modules\\src\\animation\\CCDIKSolver.js"],"sourcesContent":["import {\n  BufferAttribute,\n  BufferGeometry,\n  Color,\n  Line,\n  LineBasicMaterial,\n  Matrix4,\n  Mesh,\n  MeshBasicMaterial,\n  Object3D,\n  Quaternion,\n  SphereGeometry,\n  Vector3,\n} from 'three'\n\nconst _q = new Quaternion()\nconst _targetPos = new Vector3()\nconst _targetVec = new Vector3()\nconst _effectorPos = new Vector3()\nconst _effectorVec = new Vector3()\nconst _linkPos = new Vector3()\nconst _invLinkQ = new Quaternion()\nconst _linkScale = new Vector3()\nconst _axis = new Vector3()\nconst _vector = new Vector3()\nconst _matrix = new Matrix4()\n\n/**\n * CCD Algorithm\n *  - https://sites.google.com/site/auraliusproject/ccd-algorithm\n *\n * // ik parameter example\n * //\n * // target, effector, index in links are bone index in skeleton.bones.\n * // the bones relation should be\n * // <-- parent                                  child -->\n * // links[ n ], links[ n - 1 ], ..., links[ 0 ], effector\n * iks = [ {\n *\ttarget: 1,\n *\teffector: 2,\n *\tlinks: [ { index: 5, limitation: new Vector3( 1, 0, 0 ) }, { index: 4, enabled: false }, { index : 3 } ],\n *\titeration: 10,\n *\tminAngle: 0.0,\n *\tmaxAngle: 1.0,\n * } ];\n */\n\nclass CCDIKSolver {\n  /**\n   * @param {THREE.SkinnedMesh} mesh\n   * @param {Array<Object>} iks\n   */\n  constructor(mesh, iks = []) {\n    this.mesh = mesh\n    this.iks = iks\n\n    this._valid()\n  }\n\n  /**\n   * Update all IK bones.\n   *\n   * @return {CCDIKSolver}\n   */\n  update() {\n    const iks = this.iks\n\n    for (let i = 0, il = iks.length; i < il; i++) {\n      this.updateOne(iks[i])\n    }\n\n    return this\n  }\n\n  /**\n   * Update one IK bone\n   *\n   * @param {Object} ik parameter\n   * @return {CCDIKSolver}\n   */\n  updateOne(ik) {\n    const bones = this.mesh.skeleton.bones\n\n    // for reference overhead reduction in loop\n    const math = Math\n\n    const effector = bones[ik.effector]\n    const target = bones[ik.target]\n\n    // don't use getWorldPosition() here for the performance\n    // because it calls updateMatrixWorld( true ) inside.\n    _targetPos.setFromMatrixPosition(target.matrixWorld)\n\n    const links = ik.links\n    const iteration = ik.iteration !== undefined ? ik.iteration : 1\n\n    for (let i = 0; i < iteration; i++) {\n      let rotated = false\n\n      for (let j = 0, jl = links.length; j < jl; j++) {\n        const link = bones[links[j].index]\n\n        // skip this link and following links.\n        // this skip is used for MMD performance optimization.\n        if (links[j].enabled === false) break\n\n        const limitation = links[j].limitation\n        const rotationMin = links[j].rotationMin\n        const rotationMax = links[j].rotationMax\n\n        // don't use getWorldPosition/Quaternion() here for the performance\n        // because they call updateMatrixWorld( true ) inside.\n        link.matrixWorld.decompose(_linkPos, _invLinkQ, _linkScale)\n        _invLinkQ.invert()\n        _effectorPos.setFromMatrixPosition(effector.matrixWorld)\n\n        // work in link world\n        _effectorVec.subVectors(_effectorPos, _linkPos)\n        _effectorVec.applyQuaternion(_invLinkQ)\n        _effectorVec.normalize()\n\n        _targetVec.subVectors(_targetPos, _linkPos)\n        _targetVec.applyQuaternion(_invLinkQ)\n        _targetVec.normalize()\n\n        let angle = _targetVec.dot(_effectorVec)\n\n        if (angle > 1.0) {\n          angle = 1.0\n        } else if (angle < -1.0) {\n          angle = -1.0\n        }\n\n        angle = math.acos(angle)\n\n        // skip if changing angle is too small to prevent vibration of bone\n        if (angle < 1e-5) continue\n\n        if (ik.minAngle !== undefined && angle < ik.minAngle) {\n          angle = ik.minAngle\n        }\n\n        if (ik.maxAngle !== undefined && angle > ik.maxAngle) {\n          angle = ik.maxAngle\n        }\n\n        _axis.crossVectors(_effectorVec, _targetVec)\n        _axis.normalize()\n\n        _q.setFromAxisAngle(_axis, angle)\n        link.quaternion.multiply(_q)\n\n        // TODO: re-consider the limitation specification\n        if (limitation !== undefined) {\n          let c = link.quaternion.w\n\n          if (c > 1.0) c = 1.0\n\n          const c2 = math.sqrt(1 - c * c)\n          link.quaternion.set(limitation.x * c2, limitation.y * c2, limitation.z * c2, c)\n        }\n\n        if (rotationMin !== undefined) {\n          link.rotation.setFromVector3(_vector.setFromEuler(link.rotation).max(rotationMin))\n        }\n\n        if (rotationMax !== undefined) {\n          link.rotation.setFromVector3(_vector.setFromEuler(link.rotation).min(rotationMax))\n        }\n\n        link.updateMatrixWorld(true)\n\n        rotated = true\n      }\n\n      if (!rotated) break\n    }\n\n    return this\n  }\n\n  /**\n   * Creates Helper\n   *\n   * @return {CCDIKHelper}\n   */\n  createHelper() {\n    return new CCDIKHelper(this.mesh, this.iks)\n  }\n\n  // private methods\n\n  _valid() {\n    const iks = this.iks\n    const bones = this.mesh.skeleton.bones\n\n    for (let i = 0, il = iks.length; i < il; i++) {\n      const ik = iks[i]\n      const effector = bones[ik.effector]\n      const links = ik.links\n      let link0, link1\n\n      link0 = effector\n\n      for (let j = 0, jl = links.length; j < jl; j++) {\n        link1 = bones[links[j].index]\n\n        if (link0.parent !== link1) {\n          console.warn('THREE.CCDIKSolver: bone ' + link0.name + ' is not the child of bone ' + link1.name)\n        }\n\n        link0 = link1\n      }\n    }\n  }\n}\n\nfunction getPosition(bone, matrixWorldInv) {\n  return _vector.setFromMatrixPosition(bone.matrixWorld).applyMatrix4(matrixWorldInv)\n}\n\nfunction setPositionOfBoneToAttributeArray(array, index, bone, matrixWorldInv) {\n  const v = getPosition(bone, matrixWorldInv)\n\n  array[index * 3 + 0] = v.x\n  array[index * 3 + 1] = v.y\n  array[index * 3 + 2] = v.z\n}\n\n/**\n * Visualize IK bones\n *\n * @param {SkinnedMesh} mesh\n * @param {Array<Object>} iks\n */\nclass CCDIKHelper extends Object3D {\n  constructor(mesh, iks = [], sphereSize = 0.25) {\n    super()\n\n    this.root = mesh\n    this.iks = iks\n\n    this.matrix.copy(mesh.matrixWorld)\n    this.matrixAutoUpdate = false\n\n    this.sphereGeometry = new SphereGeometry(sphereSize, 16, 8)\n\n    this.targetSphereMaterial = new MeshBasicMaterial({\n      color: new Color(0xff8888),\n      depthTest: false,\n      depthWrite: false,\n      transparent: true,\n    })\n\n    this.effectorSphereMaterial = new MeshBasicMaterial({\n      color: new Color(0x88ff88),\n      depthTest: false,\n      depthWrite: false,\n      transparent: true,\n    })\n\n    this.linkSphereMaterial = new MeshBasicMaterial({\n      color: new Color(0x8888ff),\n      depthTest: false,\n      depthWrite: false,\n      transparent: true,\n    })\n\n    this.lineMaterial = new LineBasicMaterial({\n      color: new Color(0xff0000),\n      depthTest: false,\n      depthWrite: false,\n      transparent: true,\n    })\n\n    this._init()\n  }\n\n  /**\n   * Updates IK bones visualization.\n   */\n  updateMatrixWorld(force) {\n    const mesh = this.root\n\n    if (this.visible) {\n      let offset = 0\n\n      const iks = this.iks\n      const bones = mesh.skeleton.bones\n\n      _matrix.copy(mesh.matrixWorld).invert()\n\n      for (let i = 0, il = iks.length; i < il; i++) {\n        const ik = iks[i]\n\n        const targetBone = bones[ik.target]\n        const effectorBone = bones[ik.effector]\n\n        const targetMesh = this.children[offset++]\n        const effectorMesh = this.children[offset++]\n\n        targetMesh.position.copy(getPosition(targetBone, _matrix))\n        effectorMesh.position.copy(getPosition(effectorBone, _matrix))\n\n        for (let j = 0, jl = ik.links.length; j < jl; j++) {\n          const link = ik.links[j]\n          const linkBone = bones[link.index]\n\n          const linkMesh = this.children[offset++]\n\n          linkMesh.position.copy(getPosition(linkBone, _matrix))\n        }\n\n        const line = this.children[offset++]\n        const array = line.geometry.attributes.position.array\n\n        setPositionOfBoneToAttributeArray(array, 0, targetBone, _matrix)\n        setPositionOfBoneToAttributeArray(array, 1, effectorBone, _matrix)\n\n        for (let j = 0, jl = ik.links.length; j < jl; j++) {\n          const link = ik.links[j]\n          const linkBone = bones[link.index]\n          setPositionOfBoneToAttributeArray(array, j + 2, linkBone, _matrix)\n        }\n\n        line.geometry.attributes.position.needsUpdate = true\n      }\n    }\n\n    this.matrix.copy(mesh.matrixWorld)\n\n    super.updateMatrixWorld(force)\n  }\n\n  /**\n   * Frees the GPU-related resources allocated by this instance. Call this method whenever this instance is no longer used in your app.\n   */\n  dispose() {\n    this.sphereGeometry.dispose()\n\n    this.targetSphereMaterial.dispose()\n    this.effectorSphereMaterial.dispose()\n    this.linkSphereMaterial.dispose()\n    this.lineMaterial.dispose()\n\n    const children = this.children\n\n    for (let i = 0; i < children.length; i++) {\n      const child = children[i]\n\n      if (child.isLine) child.geometry.dispose()\n    }\n  }\n\n  // private method\n\n  _init() {\n    const scope = this\n    const iks = this.iks\n\n    function createLineGeometry(ik) {\n      const geometry = new BufferGeometry()\n      const vertices = new Float32Array((2 + ik.links.length) * 3)\n      geometry.setAttribute('position', new BufferAttribute(vertices, 3))\n\n      return geometry\n    }\n\n    function createTargetMesh() {\n      return new Mesh(scope.sphereGeometry, scope.targetSphereMaterial)\n    }\n\n    function createEffectorMesh() {\n      return new Mesh(scope.sphereGeometry, scope.effectorSphereMaterial)\n    }\n\n    function createLinkMesh() {\n      return new Mesh(scope.sphereGeometry, scope.linkSphereMaterial)\n    }\n\n    function createLine(ik) {\n      return new Line(createLineGeometry(ik), scope.lineMaterial)\n    }\n\n    for (let i = 0, il = iks.length; i < il; i++) {\n      const ik = iks[i]\n\n      this.add(createTargetMesh())\n      this.add(createEffectorMesh())\n\n      for (let j = 0, jl = ik.links.length; j < jl; j++) {\n        this.add(createLinkMesh())\n      }\n\n      this.add(createLine(ik))\n    }\n  }\n}\n\nexport { CCDIKSolver, CCDIKHelper }\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}