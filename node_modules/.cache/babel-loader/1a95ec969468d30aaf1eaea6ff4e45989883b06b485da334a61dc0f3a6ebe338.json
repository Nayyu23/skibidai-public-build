{"ast":null,"code":"import _classCallCheck from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _inherits from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport { Mesh, MathUtils } from \"three\";\nvar MorphBlendMesh = /*#__PURE__*/function (_Mesh) {\n  _inherits(MorphBlendMesh, _Mesh);\n  var _super = _createSuper(MorphBlendMesh);\n  function MorphBlendMesh(geometry, material) {\n    var _this;\n    _classCallCheck(this, MorphBlendMesh);\n    _this = _super.call(this, geometry, material);\n    _this.animationsMap = {};\n    _this.animationsList = [];\n    var numFrames = Object.keys(_this.morphTargetDictionary).length;\n    var name = \"__default\";\n    var startFrame = 0;\n    var endFrame = numFrames - 1;\n    var fps = numFrames / 1;\n    _this.createAnimation(name, startFrame, endFrame, fps);\n    _this.setAnimationWeight(name, 1);\n    return _this;\n  }\n  _createClass(MorphBlendMesh, [{\n    key: \"createAnimation\",\n    value: function createAnimation(name, start, end, fps) {\n      var animation = {\n        start: start,\n        end: end,\n        length: end - start + 1,\n        fps: fps,\n        duration: (end - start) / fps,\n        lastFrame: 0,\n        currentFrame: 0,\n        active: false,\n        time: 0,\n        direction: 1,\n        weight: 1,\n        directionBackwards: false,\n        mirroredLoop: false\n      };\n      this.animationsMap[name] = animation;\n      this.animationsList.push(animation);\n    }\n  }, {\n    key: \"autoCreateAnimations\",\n    value: function autoCreateAnimations(fps) {\n      var pattern = /([a-z]+)_?(\\d+)/i;\n      var firstAnimation;\n      var frameRanges = {};\n      var i = 0;\n      for (var key in this.morphTargetDictionary) {\n        var chunks = key.match(pattern);\n        if (chunks && chunks.length > 1) {\n          var name = chunks[1];\n          if (!frameRanges[name]) frameRanges[name] = {\n            start: Infinity,\n            end: -Infinity\n          };\n          var range = frameRanges[name];\n          if (i < range.start) range.start = i;\n          if (i > range.end) range.end = i;\n          if (!firstAnimation) firstAnimation = name;\n        }\n        i++;\n      }\n      for (var _name in frameRanges) {\n        var _range = frameRanges[_name];\n        this.createAnimation(_name, _range.start, _range.end, fps);\n      }\n      this.firstAnimation = firstAnimation;\n    }\n  }, {\n    key: \"setAnimationDirectionForward\",\n    value: function setAnimationDirectionForward(name) {\n      var animation = this.animationsMap[name];\n      if (animation) {\n        animation.direction = 1;\n        animation.directionBackwards = false;\n      }\n    }\n  }, {\n    key: \"setAnimationDirectionBackward\",\n    value: function setAnimationDirectionBackward(name) {\n      var animation = this.animationsMap[name];\n      if (animation) {\n        animation.direction = -1;\n        animation.directionBackwards = true;\n      }\n    }\n  }, {\n    key: \"setAnimationFPS\",\n    value: function setAnimationFPS(name, fps) {\n      var animation = this.animationsMap[name];\n      if (animation) {\n        animation.fps = fps;\n        animation.duration = (animation.end - animation.start) / animation.fps;\n      }\n    }\n  }, {\n    key: \"setAnimationDuration\",\n    value: function setAnimationDuration(name, duration) {\n      var animation = this.animationsMap[name];\n      if (animation) {\n        animation.duration = duration;\n        animation.fps = (animation.end - animation.start) / animation.duration;\n      }\n    }\n  }, {\n    key: \"setAnimationWeight\",\n    value: function setAnimationWeight(name, weight) {\n      var animation = this.animationsMap[name];\n      if (animation) {\n        animation.weight = weight;\n      }\n    }\n  }, {\n    key: \"setAnimationTime\",\n    value: function setAnimationTime(name, time) {\n      var animation = this.animationsMap[name];\n      if (animation) {\n        animation.time = time;\n      }\n    }\n  }, {\n    key: \"getAnimationTime\",\n    value: function getAnimationTime(name) {\n      var time = 0;\n      var animation = this.animationsMap[name];\n      if (animation) {\n        time = animation.time;\n      }\n      return time;\n    }\n  }, {\n    key: \"getAnimationDuration\",\n    value: function getAnimationDuration(name) {\n      var duration = -1;\n      var animation = this.animationsMap[name];\n      if (animation) {\n        duration = animation.duration;\n      }\n      return duration;\n    }\n  }, {\n    key: \"playAnimation\",\n    value: function playAnimation(name) {\n      var animation = this.animationsMap[name];\n      if (animation) {\n        animation.time = 0;\n        animation.active = true;\n      } else {\n        console.warn(\"THREE.MorphBlendMesh: animation[\" + name + \"] undefined in .playAnimation()\");\n      }\n    }\n  }, {\n    key: \"stopAnimation\",\n    value: function stopAnimation(name) {\n      var animation = this.animationsMap[name];\n      if (animation) {\n        animation.active = false;\n      }\n    }\n  }, {\n    key: \"update\",\n    value: function update(delta) {\n      for (var i = 0, il = this.animationsList.length; i < il; i++) {\n        var animation = this.animationsList[i];\n        if (!animation.active) continue;\n        var frameTime = animation.duration / animation.length;\n        animation.time += animation.direction * delta;\n        if (animation.mirroredLoop) {\n          if (animation.time > animation.duration || animation.time < 0) {\n            animation.direction *= -1;\n            if (animation.time > animation.duration) {\n              animation.time = animation.duration;\n              animation.directionBackwards = true;\n            }\n            if (animation.time < 0) {\n              animation.time = 0;\n              animation.directionBackwards = false;\n            }\n          }\n        } else {\n          animation.time = animation.time % animation.duration;\n          if (animation.time < 0) animation.time += animation.duration;\n        }\n        var keyframe = animation.start + MathUtils.clamp(Math.floor(animation.time / frameTime), 0, animation.length - 1);\n        var weight = animation.weight;\n        if (keyframe !== animation.currentFrame) {\n          this.morphTargetInfluences[animation.lastFrame] = 0;\n          this.morphTargetInfluences[animation.currentFrame] = 1 * weight;\n          this.morphTargetInfluences[keyframe] = 0;\n          animation.lastFrame = animation.currentFrame;\n          animation.currentFrame = keyframe;\n        }\n        var mix = animation.time % frameTime / frameTime;\n        if (animation.directionBackwards) mix = 1 - mix;\n        if (animation.currentFrame !== animation.lastFrame) {\n          this.morphTargetInfluences[animation.currentFrame] = mix * weight;\n          this.morphTargetInfluences[animation.lastFrame] = (1 - mix) * weight;\n        } else {\n          this.morphTargetInfluences[animation.currentFrame] = weight;\n        }\n      }\n    }\n  }]);\n  return MorphBlendMesh;\n}(Mesh);\nexport { MorphBlendMesh };","map":{"version":3,"names":["MorphBlendMesh","_Mesh","_inherits","_super","_createSuper","geometry","material","_this","_classCallCheck","call","animationsMap","animationsList","numFrames","Object","keys","morphTargetDictionary","length","name","startFrame","endFrame","fps","createAnimation","setAnimationWeight","_createClass","key","value","start","end","animation","duration","lastFrame","currentFrame","active","time","direction","weight","directionBackwards","mirroredLoop","push","autoCreateAnimations","pattern","firstAnimation","frameRanges","i","chunks","match","Infinity","range","setAnimationDirectionForward","setAnimationDirectionBackward","setAnimationFPS","setAnimationDuration","setAnimationTime","getAnimationTime","getAnimationDuration","playAnimation","console","warn","stopAnimation","update","delta","il","frameTime","keyframe","MathUtils","clamp","Math","floor","morphTargetInfluences","mix","Mesh"],"sources":["C:\\Users\\Nayyu\\Desktop\\skibidai-public-build\\node_modules\\src\\misc\\MorphBlendMesh.js"],"sourcesContent":["import { MathUtils, Mesh } from 'three'\n\nclass MorphBlendMesh extends Mesh {\n  constructor(geometry, material) {\n    super(geometry, material)\n\n    this.animationsMap = {}\n    this.animationsList = []\n\n    // prepare default animation\n    // (all frames played together in 1 second)\n\n    const numFrames = Object.keys(this.morphTargetDictionary).length\n\n    const name = '__default'\n\n    const startFrame = 0\n    const endFrame = numFrames - 1\n\n    const fps = numFrames / 1\n\n    this.createAnimation(name, startFrame, endFrame, fps)\n    this.setAnimationWeight(name, 1)\n  }\n\n  createAnimation(name, start, end, fps) {\n    const animation = {\n      start: start,\n      end: end,\n\n      length: end - start + 1,\n\n      fps: fps,\n      duration: (end - start) / fps,\n\n      lastFrame: 0,\n      currentFrame: 0,\n\n      active: false,\n\n      time: 0,\n      direction: 1,\n      weight: 1,\n\n      directionBackwards: false,\n      mirroredLoop: false,\n    }\n\n    this.animationsMap[name] = animation\n    this.animationsList.push(animation)\n  }\n\n  autoCreateAnimations(fps) {\n    const pattern = /([a-z]+)_?(\\d+)/i\n\n    let firstAnimation\n\n    const frameRanges = {}\n\n    let i = 0\n\n    for (const key in this.morphTargetDictionary) {\n      const chunks = key.match(pattern)\n\n      if (chunks && chunks.length > 1) {\n        const name = chunks[1]\n\n        if (!frameRanges[name]) frameRanges[name] = { start: Infinity, end: -Infinity }\n\n        const range = frameRanges[name]\n\n        if (i < range.start) range.start = i\n        if (i > range.end) range.end = i\n\n        if (!firstAnimation) firstAnimation = name\n      }\n\n      i++\n    }\n\n    for (const name in frameRanges) {\n      const range = frameRanges[name]\n      this.createAnimation(name, range.start, range.end, fps)\n    }\n\n    this.firstAnimation = firstAnimation\n  }\n\n  setAnimationDirectionForward(name) {\n    const animation = this.animationsMap[name]\n\n    if (animation) {\n      animation.direction = 1\n      animation.directionBackwards = false\n    }\n  }\n\n  setAnimationDirectionBackward(name) {\n    const animation = this.animationsMap[name]\n\n    if (animation) {\n      animation.direction = -1\n      animation.directionBackwards = true\n    }\n  }\n\n  setAnimationFPS(name, fps) {\n    const animation = this.animationsMap[name]\n\n    if (animation) {\n      animation.fps = fps\n      animation.duration = (animation.end - animation.start) / animation.fps\n    }\n  }\n\n  setAnimationDuration(name, duration) {\n    const animation = this.animationsMap[name]\n\n    if (animation) {\n      animation.duration = duration\n      animation.fps = (animation.end - animation.start) / animation.duration\n    }\n  }\n\n  setAnimationWeight(name, weight) {\n    const animation = this.animationsMap[name]\n\n    if (animation) {\n      animation.weight = weight\n    }\n  }\n\n  setAnimationTime(name, time) {\n    const animation = this.animationsMap[name]\n\n    if (animation) {\n      animation.time = time\n    }\n  }\n\n  getAnimationTime(name) {\n    let time = 0\n\n    const animation = this.animationsMap[name]\n\n    if (animation) {\n      time = animation.time\n    }\n\n    return time\n  }\n\n  getAnimationDuration(name) {\n    let duration = -1\n\n    const animation = this.animationsMap[name]\n\n    if (animation) {\n      duration = animation.duration\n    }\n\n    return duration\n  }\n\n  playAnimation(name) {\n    const animation = this.animationsMap[name]\n\n    if (animation) {\n      animation.time = 0\n      animation.active = true\n    } else {\n      console.warn('THREE.MorphBlendMesh: animation[' + name + '] undefined in .playAnimation()')\n    }\n  }\n\n  stopAnimation(name) {\n    const animation = this.animationsMap[name]\n\n    if (animation) {\n      animation.active = false\n    }\n  }\n\n  update(delta) {\n    for (let i = 0, il = this.animationsList.length; i < il; i++) {\n      const animation = this.animationsList[i]\n\n      if (!animation.active) continue\n\n      const frameTime = animation.duration / animation.length\n\n      animation.time += animation.direction * delta\n\n      if (animation.mirroredLoop) {\n        if (animation.time > animation.duration || animation.time < 0) {\n          animation.direction *= -1\n\n          if (animation.time > animation.duration) {\n            animation.time = animation.duration\n            animation.directionBackwards = true\n          }\n\n          if (animation.time < 0) {\n            animation.time = 0\n            animation.directionBackwards = false\n          }\n        }\n      } else {\n        animation.time = animation.time % animation.duration\n\n        if (animation.time < 0) animation.time += animation.duration\n      }\n\n      const keyframe =\n        animation.start + MathUtils.clamp(Math.floor(animation.time / frameTime), 0, animation.length - 1)\n      const weight = animation.weight\n\n      if (keyframe !== animation.currentFrame) {\n        this.morphTargetInfluences[animation.lastFrame] = 0\n        this.morphTargetInfluences[animation.currentFrame] = 1 * weight\n\n        this.morphTargetInfluences[keyframe] = 0\n\n        animation.lastFrame = animation.currentFrame\n        animation.currentFrame = keyframe\n      }\n\n      let mix = (animation.time % frameTime) / frameTime\n\n      if (animation.directionBackwards) mix = 1 - mix\n\n      if (animation.currentFrame !== animation.lastFrame) {\n        this.morphTargetInfluences[animation.currentFrame] = mix * weight\n        this.morphTargetInfluences[animation.lastFrame] = (1 - mix) * weight\n      } else {\n        this.morphTargetInfluences[animation.currentFrame] = weight\n      }\n    }\n  }\n}\n\nexport { MorphBlendMesh }\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}