{"ast":null,"code":"import _classCallCheck from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _inherits from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport { Loader, FileLoader, DataTexture, RGBAFormat, UnsignedByteType, LinearFilter, ClampToEdgeWrapping } from \"three\";\nimport { Data3DTexture } from \"../_polyfill/Data3DTexture.js\";\nvar LUT3dlLoader = /*#__PURE__*/function (_Loader) {\n  _inherits(LUT3dlLoader, _Loader);\n  var _super = _createSuper(LUT3dlLoader);\n  function LUT3dlLoader() {\n    _classCallCheck(this, LUT3dlLoader);\n    return _super.apply(this, arguments);\n  }\n  _createClass(LUT3dlLoader, [{\n    key: \"load\",\n    value: function load(url, onLoad, onProgress, onError) {\n      var _this = this;\n      var loader = new FileLoader(this.manager);\n      loader.setPath(this.path);\n      loader.setResponseType(\"text\");\n      loader.load(url, function (text) {\n        try {\n          onLoad(_this.parse(text));\n        } catch (e) {\n          if (onError) {\n            onError(e);\n          } else {\n            console.error(e);\n          }\n          _this.manager.itemError(url);\n        }\n      }, onProgress, onError);\n    }\n  }, {\n    key: \"parse\",\n    value: function parse(str) {\n      str = str.replace(/^#.*?(\\n|\\r)/gm, \"\").replace(/^\\s*?(\\n|\\r)/gm, \"\").trim();\n      var lines = str.split(/[\\n\\r]+/g);\n      var gridLines = lines[0].trim().split(/\\s+/g).map(function (e) {\n        return parseFloat(e);\n      });\n      var gridStep = gridLines[1] - gridLines[0];\n      var size = gridLines.length;\n      for (var i = 1, l = gridLines.length; i < l; i++) {\n        if (gridStep !== gridLines[i] - gridLines[i - 1]) {\n          throw new Error(\"LUT3dlLoader: Inconsistent grid size not supported.\");\n        }\n      }\n      var dataArray = new Array(size * size * size * 4);\n      var index = 0;\n      var maxOutputValue = 0;\n      for (var _i = 1, _l = lines.length; _i < _l; _i++) {\n        var line = lines[_i].trim();\n        var split = line.split(/\\s/g);\n        var r = parseFloat(split[0]);\n        var g = parseFloat(split[1]);\n        var b = parseFloat(split[2]);\n        maxOutputValue = Math.max(maxOutputValue, r, g, b);\n        var bLayer = index % size;\n        var gLayer = Math.floor(index / size) % size;\n        var rLayer = Math.floor(index / (size * size)) % size;\n        var pixelIndex = bLayer * size * size + gLayer * size + rLayer;\n        dataArray[4 * pixelIndex + 0] = r;\n        dataArray[4 * pixelIndex + 1] = g;\n        dataArray[4 * pixelIndex + 2] = b;\n        dataArray[4 * pixelIndex + 3] = 1;\n        index += 1;\n      }\n      var bits = Math.ceil(Math.log2(maxOutputValue));\n      var maxBitValue = Math.pow(2, bits);\n      for (var _i2 = 0, _l2 = dataArray.length; _i2 < _l2; _i2 += 4) {\n        var _r = dataArray[_i2 + 0];\n        var _g = dataArray[_i2 + 1];\n        var _b = dataArray[_i2 + 2];\n        dataArray[_i2 + 0] = 255 * _r / maxBitValue;\n        dataArray[_i2 + 1] = 255 * _g / maxBitValue;\n        dataArray[_i2 + 2] = 255 * _b / maxBitValue;\n      }\n      var data = new Uint8Array(dataArray);\n      var texture = new DataTexture();\n      texture.image.data = data;\n      texture.image.width = size;\n      texture.image.height = size * size;\n      texture.format = RGBAFormat;\n      texture.type = UnsignedByteType;\n      texture.magFilter = LinearFilter;\n      texture.minFilter = LinearFilter;\n      texture.wrapS = ClampToEdgeWrapping;\n      texture.wrapT = ClampToEdgeWrapping;\n      texture.generateMipmaps = false;\n      texture.needsUpdate = true;\n      var texture3D = new Data3DTexture();\n      texture3D.image.data = data;\n      texture3D.image.width = size;\n      texture3D.image.height = size;\n      texture3D.image.depth = size;\n      texture3D.format = RGBAFormat;\n      texture3D.type = UnsignedByteType;\n      texture3D.magFilter = LinearFilter;\n      texture3D.minFilter = LinearFilter;\n      texture3D.wrapS = ClampToEdgeWrapping;\n      texture3D.wrapT = ClampToEdgeWrapping;\n      texture3D.wrapR = ClampToEdgeWrapping;\n      texture3D.generateMipmaps = false;\n      texture3D.needsUpdate = true;\n      return {\n        size: size,\n        texture: texture,\n        texture3D: texture3D\n      };\n    }\n  }]);\n  return LUT3dlLoader;\n}(Loader);\nexport { LUT3dlLoader };","map":{"version":3,"names":["LUT3dlLoader","_Loader","_inherits","_super","_createSuper","_classCallCheck","apply","arguments","_createClass","key","value","load","url","onLoad","onProgress","onError","_this","loader","FileLoader","manager","setPath","path","setResponseType","text","parse","e","console","error","itemError","str","replace","trim","lines","split","gridLines","map","parseFloat","gridStep","size","length","i","l","Error","dataArray","Array","index","maxOutputValue","line","r","g","b","Math","max","bLayer","gLayer","floor","rLayer","pixelIndex","bits","ceil","log2","maxBitValue","pow","data","Uint8Array","texture","DataTexture","image","width","height","format","RGBAFormat","type","UnsignedByteType","magFilter","LinearFilter","minFilter","wrapS","ClampToEdgeWrapping","wrapT","generateMipmaps","needsUpdate","texture3D","Data3DTexture","depth","wrapR","Loader"],"sources":["C:\\Users\\Nayyu\\Desktop\\skibidai-public-build\\node_modules\\src\\loaders\\LUT3dlLoader.js"],"sourcesContent":["// http://download.autodesk.com/us/systemdocs/help/2011/lustre/index.html?url=./files/WSc4e151a45a3b785a24c3d9a411df9298473-7ffd.htm,topicNumber=d0e9492\n// https://community.foundry.com/discuss/topic/103636/format-spec-for-3dl?mode=Post&postID=895258\nimport { Loader, FileLoader, DataTexture, RGBAFormat, UnsignedByteType, ClampToEdgeWrapping, LinearFilter } from 'three'\nimport { Data3DTexture } from '../_polyfill/Data3DTexture'\n\nexport class LUT3dlLoader extends Loader {\n  load(url, onLoad, onProgress, onError) {\n    const loader = new FileLoader(this.manager)\n    loader.setPath(this.path)\n    loader.setResponseType('text')\n    loader.load(\n      url,\n      (text) => {\n        try {\n          onLoad(this.parse(text))\n        } catch (e) {\n          if (onError) {\n            onError(e)\n          } else {\n            console.error(e)\n          }\n\n          this.manager.itemError(url)\n        }\n      },\n      onProgress,\n      onError,\n    )\n  }\n\n  parse(str) {\n    // remove empty lines and comment lints\n    str = str\n      .replace(/^#.*?(\\n|\\r)/gm, '')\n      .replace(/^\\s*?(\\n|\\r)/gm, '')\n      .trim()\n\n    const lines = str.split(/[\\n\\r]+/g)\n\n    // first line is the positions on the grid that are provided by the LUT\n    const gridLines = lines[0]\n      .trim()\n      .split(/\\s+/g)\n      .map((e) => parseFloat(e))\n    const gridStep = gridLines[1] - gridLines[0]\n    const size = gridLines.length\n\n    for (let i = 1, l = gridLines.length; i < l; i++) {\n      if (gridStep !== gridLines[i] - gridLines[i - 1]) {\n        throw new Error('LUT3dlLoader: Inconsistent grid size not supported.')\n      }\n    }\n\n    const dataArray = new Array(size * size * size * 4)\n    let index = 0\n    let maxOutputValue = 0.0\n    for (let i = 1, l = lines.length; i < l; i++) {\n      const line = lines[i].trim()\n      const split = line.split(/\\s/g)\n\n      const r = parseFloat(split[0])\n      const g = parseFloat(split[1])\n      const b = parseFloat(split[2])\n      maxOutputValue = Math.max(maxOutputValue, r, g, b)\n\n      const bLayer = index % size\n      const gLayer = Math.floor(index / size) % size\n      const rLayer = Math.floor(index / (size * size)) % size\n\n      // b grows first, then g, then r\n      const pixelIndex = bLayer * size * size + gLayer * size + rLayer\n      dataArray[4 * pixelIndex + 0] = r\n      dataArray[4 * pixelIndex + 1] = g\n      dataArray[4 * pixelIndex + 2] = b\n      dataArray[4 * pixelIndex + 3] = 1.0\n      index += 1\n    }\n\n    // Find the apparent bit depth of the stored RGB values and map the\n    // values to [ 0, 255 ].\n    const bits = Math.ceil(Math.log2(maxOutputValue))\n    const maxBitValue = Math.pow(2.0, bits)\n    for (let i = 0, l = dataArray.length; i < l; i += 4) {\n      const r = dataArray[i + 0]\n      const g = dataArray[i + 1]\n      const b = dataArray[i + 2]\n      dataArray[i + 0] = (255 * r) / maxBitValue // r\n      dataArray[i + 1] = (255 * g) / maxBitValue // g\n      dataArray[i + 2] = (255 * b) / maxBitValue // b\n    }\n\n    const data = new Uint8Array(dataArray)\n    const texture = new DataTexture()\n    texture.image.data = data\n    texture.image.width = size\n    texture.image.height = size * size\n    texture.format = RGBAFormat\n    texture.type = UnsignedByteType\n    texture.magFilter = LinearFilter\n    texture.minFilter = LinearFilter\n    texture.wrapS = ClampToEdgeWrapping\n    texture.wrapT = ClampToEdgeWrapping\n    texture.generateMipmaps = false\n    texture.needsUpdate = true\n\n    const texture3D = new Data3DTexture()\n    texture3D.image.data = data\n    texture3D.image.width = size\n    texture3D.image.height = size\n    texture3D.image.depth = size\n    texture3D.format = RGBAFormat\n    texture3D.type = UnsignedByteType\n    texture3D.magFilter = LinearFilter\n    texture3D.minFilter = LinearFilter\n    texture3D.wrapS = ClampToEdgeWrapping\n    texture3D.wrapT = ClampToEdgeWrapping\n    texture3D.wrapR = ClampToEdgeWrapping\n    texture3D.generateMipmaps = false\n    texture3D.needsUpdate = true\n\n    return {\n      size,\n      texture,\n      texture3D,\n    }\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}