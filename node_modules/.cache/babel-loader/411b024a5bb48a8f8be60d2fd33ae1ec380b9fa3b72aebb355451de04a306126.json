{"ast":null,"code":"import _assertThisInitialized from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js\";\nimport _inherits from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport _classCallCheck from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport { Group, LightProbe, DirectionalLight, WebGLCubeRenderTarget } from \"three\";\nvar SessionLightProbe = /*#__PURE__*/function () {\n  function SessionLightProbe(xrLight, renderer, lightProbe, environmentEstimation, estimationStartCallback) {\n    var _this = this;\n    _classCallCheck(this, SessionLightProbe);\n    this.xrLight = xrLight;\n    this.renderer = renderer;\n    this.lightProbe = lightProbe;\n    this.xrWebGLBinding = null;\n    this.estimationStartCallback = estimationStartCallback;\n    this.frameCallback = this.onXRFrame.bind(this);\n    var session = renderer.xr.getSession();\n    if (environmentEstimation && \"XRWebGLBinding\" in window) {\n      var cubeRenderTarget = new WebGLCubeRenderTarget(16);\n      xrLight.environment = cubeRenderTarget.texture;\n      var gl = renderer.getContext();\n      switch (session.preferredReflectionFormat) {\n        case \"srgba8\":\n          gl.getExtension(\"EXT_sRGB\");\n          break;\n        case \"rgba16f\":\n          gl.getExtension(\"OES_texture_half_float\");\n          break;\n      }\n      this.xrWebGLBinding = new XRWebGLBinding(session, gl);\n      this.lightProbe.addEventListener(\"reflectionchange\", function () {\n        _this.updateReflection();\n      });\n    }\n    session.requestAnimationFrame(this.frameCallback);\n  }\n  _createClass(SessionLightProbe, [{\n    key: \"updateReflection\",\n    value: function updateReflection() {\n      var textureProperties = this.renderer.properties.get(this.xrLight.environment);\n      if (textureProperties) {\n        var cubeMap = this.xrWebGLBinding.getReflectionCubeMap(this.lightProbe);\n        if (cubeMap) {\n          textureProperties.__webglTexture = cubeMap;\n          this.xrLight.environment.needsPMREMUpdate = true;\n        }\n      }\n    }\n  }, {\n    key: \"onXRFrame\",\n    value: function onXRFrame(time, xrFrame) {\n      if (!this.xrLight) {\n        return;\n      }\n      var session = xrFrame.session;\n      session.requestAnimationFrame(this.frameCallback);\n      var lightEstimate = xrFrame.getLightEstimate(this.lightProbe);\n      if (lightEstimate) {\n        this.xrLight.lightProbe.sh.fromArray(lightEstimate.sphericalHarmonicsCoefficients);\n        this.xrLight.lightProbe.intensity = 1;\n        var intensityScalar = Math.max(1, Math.max(lightEstimate.primaryLightIntensity.x, Math.max(lightEstimate.primaryLightIntensity.y, lightEstimate.primaryLightIntensity.z)));\n        this.xrLight.directionalLight.color.setRGB(lightEstimate.primaryLightIntensity.x / intensityScalar, lightEstimate.primaryLightIntensity.y / intensityScalar, lightEstimate.primaryLightIntensity.z / intensityScalar);\n        this.xrLight.directionalLight.intensity = intensityScalar;\n        this.xrLight.directionalLight.position.copy(lightEstimate.primaryLightDirection);\n        if (this.estimationStartCallback) {\n          this.estimationStartCallback();\n          this.estimationStartCallback = null;\n        }\n      }\n    }\n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      this.xrLight = null;\n      this.renderer = null;\n      this.lightProbe = null;\n      this.xrWebGLBinding = null;\n    }\n  }]);\n  return SessionLightProbe;\n}();\nvar XREstimatedLight = /*#__PURE__*/function (_Group) {\n  _inherits(XREstimatedLight, _Group);\n  var _super = _createSuper(XREstimatedLight);\n  function XREstimatedLight(renderer) {\n    var _this2;\n    var environmentEstimation = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    _classCallCheck(this, XREstimatedLight);\n    _this2 = _super.call(this);\n    _this2.lightProbe = new LightProbe();\n    _this2.lightProbe.intensity = 0;\n    _this2.add(_this2.lightProbe);\n    _this2.directionalLight = new DirectionalLight();\n    _this2.directionalLight.intensity = 0;\n    _this2.add(_this2.directionalLight);\n    _this2.environment = null;\n    var sessionLightProbe = null;\n    var estimationStarted = false;\n    renderer.xr.addEventListener(\"sessionstart\", function () {\n      var session = renderer.xr.getSession();\n      if (\"requestLightProbe\" in session) {\n        session.requestLightProbe({\n          reflectionFormat: session.preferredReflectionFormat\n        }).then(function (probe) {\n          sessionLightProbe = new SessionLightProbe(_assertThisInitialized(_this2), renderer, probe, environmentEstimation, function () {\n            estimationStarted = true;\n            _this2.dispatchEvent({\n              type: \"estimationstart\"\n            });\n          });\n        });\n      }\n    });\n    renderer.xr.addEventListener(\"sessionend\", function () {\n      if (sessionLightProbe) {\n        sessionLightProbe.dispose();\n        sessionLightProbe = null;\n      }\n      if (estimationStarted) {\n        _this2.dispatchEvent({\n          type: \"estimationend\"\n        });\n      }\n    });\n    _this2.dispose = function () {\n      if (sessionLightProbe) {\n        sessionLightProbe.dispose();\n        sessionLightProbe = null;\n      }\n      _this2.remove(_this2.lightProbe);\n      _this2.lightProbe = null;\n      _this2.remove(_this2.directionalLight);\n      _this2.directionalLight = null;\n      _this2.environment = null;\n    };\n    return _this2;\n  }\n  return _createClass(XREstimatedLight);\n}(Group);\nexport { XREstimatedLight };","map":{"version":3,"names":["SessionLightProbe","xrLight","renderer","lightProbe","environmentEstimation","estimationStartCallback","_this","_classCallCheck","xrWebGLBinding","frameCallback","onXRFrame","bind","session","xr","getSession","window","cubeRenderTarget","WebGLCubeRenderTarget","environment","texture","gl","getContext","preferredReflectionFormat","getExtension","XRWebGLBinding","addEventListener","updateReflection","requestAnimationFrame","_createClass","key","value","textureProperties","properties","get","cubeMap","getReflectionCubeMap","__webglTexture","needsPMREMUpdate","time","xrFrame","lightEstimate","getLightEstimate","sh","fromArray","sphericalHarmonicsCoefficients","intensity","intensityScalar","Math","max","primaryLightIntensity","x","y","z","directionalLight","color","setRGB","position","copy","primaryLightDirection","dispose","XREstimatedLight","_Group","_inherits","_super","_createSuper","_this2","arguments","length","undefined","call","LightProbe","add","DirectionalLight","sessionLightProbe","estimationStarted","requestLightProbe","reflectionFormat","then","probe","_assertThisInitialized","dispatchEvent","type","remove","Group"],"sources":["C:\\Users\\Nayyu\\Desktop\\skibidai-public-build\\node_modules\\src\\webxr\\XREstimatedLight.js"],"sourcesContent":["import { DirectionalLight, Group, LightProbe, WebGLCubeRenderTarget } from 'three'\n\nclass SessionLightProbe {\n  constructor(xrLight, renderer, lightProbe, environmentEstimation, estimationStartCallback) {\n    this.xrLight = xrLight\n    this.renderer = renderer\n    this.lightProbe = lightProbe\n    this.xrWebGLBinding = null\n    this.estimationStartCallback = estimationStartCallback\n    this.frameCallback = this.onXRFrame.bind(this)\n\n    const session = renderer.xr.getSession()\n\n    // If the XRWebGLBinding class is available then we can also query an\n    // estimated reflection cube map.\n    if (environmentEstimation && 'XRWebGLBinding' in window) {\n      // This is the simplest way I know of to initialize a WebGL cubemap in Three.\n      const cubeRenderTarget = new WebGLCubeRenderTarget(16)\n      xrLight.environment = cubeRenderTarget.texture\n\n      const gl = renderer.getContext()\n\n      // Ensure that we have any extensions needed to use the preferred cube map format.\n      switch (session.preferredReflectionFormat) {\n        case 'srgba8':\n          gl.getExtension('EXT_sRGB')\n          break\n\n        case 'rgba16f':\n          gl.getExtension('OES_texture_half_float')\n          break\n      }\n\n      this.xrWebGLBinding = new XRWebGLBinding(session, gl)\n\n      this.lightProbe.addEventListener('reflectionchange', () => {\n        this.updateReflection()\n      })\n    }\n\n    // Start monitoring the XR animation frame loop to look for lighting\n    // estimation changes.\n    session.requestAnimationFrame(this.frameCallback)\n  }\n\n  updateReflection() {\n    const textureProperties = this.renderer.properties.get(this.xrLight.environment)\n\n    if (textureProperties) {\n      const cubeMap = this.xrWebGLBinding.getReflectionCubeMap(this.lightProbe)\n\n      if (cubeMap) {\n        textureProperties.__webglTexture = cubeMap\n\n        this.xrLight.environment.needsPMREMUpdate = true\n      }\n    }\n  }\n\n  onXRFrame(time, xrFrame) {\n    // If either this obejct or the XREstimatedLight has been destroyed, stop\n    // running the frame loop.\n    if (!this.xrLight) {\n      return\n    }\n\n    const session = xrFrame.session\n    session.requestAnimationFrame(this.frameCallback)\n\n    const lightEstimate = xrFrame.getLightEstimate(this.lightProbe)\n    if (lightEstimate) {\n      // We can copy the estimate's spherical harmonics array directly into the light probe.\n      this.xrLight.lightProbe.sh.fromArray(lightEstimate.sphericalHarmonicsCoefficients)\n      this.xrLight.lightProbe.intensity = 1.0\n\n      // For the directional light we have to normalize the color and set the scalar as the\n      // intensity, since WebXR can return color values that exceed 1.0.\n      const intensityScalar = Math.max(\n        1.0,\n        Math.max(\n          lightEstimate.primaryLightIntensity.x,\n          Math.max(lightEstimate.primaryLightIntensity.y, lightEstimate.primaryLightIntensity.z),\n        ),\n      )\n\n      this.xrLight.directionalLight.color.setRGB(\n        lightEstimate.primaryLightIntensity.x / intensityScalar,\n        lightEstimate.primaryLightIntensity.y / intensityScalar,\n        lightEstimate.primaryLightIntensity.z / intensityScalar,\n      )\n      this.xrLight.directionalLight.intensity = intensityScalar\n      this.xrLight.directionalLight.position.copy(lightEstimate.primaryLightDirection)\n\n      if (this.estimationStartCallback) {\n        this.estimationStartCallback()\n        this.estimationStartCallback = null\n      }\n    }\n  }\n\n  dispose() {\n    this.xrLight = null\n    this.renderer = null\n    this.lightProbe = null\n    this.xrWebGLBinding = null\n  }\n}\n\nexport class XREstimatedLight extends Group {\n  constructor(renderer, environmentEstimation = true) {\n    super()\n\n    this.lightProbe = new LightProbe()\n    this.lightProbe.intensity = 0\n    this.add(this.lightProbe)\n\n    this.directionalLight = new DirectionalLight()\n    this.directionalLight.intensity = 0\n    this.add(this.directionalLight)\n\n    // Will be set to a cube map in the SessionLightProbe is environment estimation is\n    // available and requested.\n    this.environment = null\n\n    let sessionLightProbe = null\n    let estimationStarted = false\n    renderer.xr.addEventListener('sessionstart', () => {\n      const session = renderer.xr.getSession()\n\n      if ('requestLightProbe' in session) {\n        session\n          .requestLightProbe({\n            reflectionFormat: session.preferredReflectionFormat,\n          })\n          .then((probe) => {\n            sessionLightProbe = new SessionLightProbe(this, renderer, probe, environmentEstimation, () => {\n              estimationStarted = true\n\n              // Fired to indicate that the estimated lighting values are now being updated.\n              this.dispatchEvent({ type: 'estimationstart' })\n            })\n          })\n      }\n    })\n\n    renderer.xr.addEventListener('sessionend', () => {\n      if (sessionLightProbe) {\n        sessionLightProbe.dispose()\n        sessionLightProbe = null\n      }\n\n      if (estimationStarted) {\n        // Fired to indicate that the estimated lighting values are no longer being updated.\n        this.dispatchEvent({ type: 'estimationend' })\n      }\n    })\n\n    // Done inline to provide access to sessionLightProbe.\n    this.dispose = () => {\n      if (sessionLightProbe) {\n        sessionLightProbe.dispose()\n        sessionLightProbe = null\n      }\n\n      this.remove(this.lightProbe)\n      this.lightProbe = null\n\n      this.remove(this.directionalLight)\n      this.directionalLight = null\n\n      this.environment = null\n    }\n  }\n}\n"],"mappings":";;;;;;IAEMA,iBAAA;EACJ,SAAAA,kBAAYC,OAAA,EAASC,QAAA,EAAUC,UAAA,EAAYC,qBAAA,EAAuBC,uBAAA,EAAyB;IAAA,IAAAC,KAAA;IAAAC,eAAA,OAAAP,iBAAA;IACzF,KAAKC,OAAA,GAAUA,OAAA;IACf,KAAKC,QAAA,GAAWA,QAAA;IAChB,KAAKC,UAAA,GAAaA,UAAA;IAClB,KAAKK,cAAA,GAAiB;IACtB,KAAKH,uBAAA,GAA0BA,uBAAA;IAC/B,KAAKI,aAAA,GAAgB,KAAKC,SAAA,CAAUC,IAAA,CAAK,IAAI;IAE7C,IAAMC,OAAA,GAAUV,QAAA,CAASW,EAAA,CAAGC,UAAA,CAAY;IAIxC,IAAIV,qBAAA,IAAyB,oBAAoBW,MAAA,EAAQ;MAEvD,IAAMC,gBAAA,GAAmB,IAAIC,qBAAA,CAAsB,EAAE;MACrDhB,OAAA,CAAQiB,WAAA,GAAcF,gBAAA,CAAiBG,OAAA;MAEvC,IAAMC,EAAA,GAAKlB,QAAA,CAASmB,UAAA,CAAY;MAGhC,QAAQT,OAAA,CAAQU,yBAAA;QACd,KAAK;UACHF,EAAA,CAAGG,YAAA,CAAa,UAAU;UAC1B;QAEF,KAAK;UACHH,EAAA,CAAGG,YAAA,CAAa,wBAAwB;UACxC;MACH;MAED,KAAKf,cAAA,GAAiB,IAAIgB,cAAA,CAAeZ,OAAA,EAASQ,EAAE;MAEpD,KAAKjB,UAAA,CAAWsB,gBAAA,CAAiB,oBAAoB,YAAM;QACzDnB,KAAA,CAAKoB,gBAAA,CAAkB;MAC/B,CAAO;IACF;IAIDd,OAAA,CAAQe,qBAAA,CAAsB,KAAKlB,aAAa;EACjD;EAAAmB,YAAA,CAAA5B,iBAAA;IAAA6B,GAAA;IAAAC,KAAA,EAED,SAAAJ,iBAAA,EAAmB;MACjB,IAAMK,iBAAA,GAAoB,KAAK7B,QAAA,CAAS8B,UAAA,CAAWC,GAAA,CAAI,KAAKhC,OAAA,CAAQiB,WAAW;MAE/E,IAAIa,iBAAA,EAAmB;QACrB,IAAMG,OAAA,GAAU,KAAK1B,cAAA,CAAe2B,oBAAA,CAAqB,KAAKhC,UAAU;QAExE,IAAI+B,OAAA,EAAS;UACXH,iBAAA,CAAkBK,cAAA,GAAiBF,OAAA;UAEnC,KAAKjC,OAAA,CAAQiB,WAAA,CAAYmB,gBAAA,GAAmB;QAC7C;MACF;IACF;EAAA;IAAAR,GAAA;IAAAC,KAAA,EAED,SAAApB,UAAU4B,IAAA,EAAMC,OAAA,EAAS;MAGvB,IAAI,CAAC,KAAKtC,OAAA,EAAS;QACjB;MACD;MAED,IAAMW,OAAA,GAAU2B,OAAA,CAAQ3B,OAAA;MACxBA,OAAA,CAAQe,qBAAA,CAAsB,KAAKlB,aAAa;MAEhD,IAAM+B,aAAA,GAAgBD,OAAA,CAAQE,gBAAA,CAAiB,KAAKtC,UAAU;MAC9D,IAAIqC,aAAA,EAAe;QAEjB,KAAKvC,OAAA,CAAQE,UAAA,CAAWuC,EAAA,CAAGC,SAAA,CAAUH,aAAA,CAAcI,8BAA8B;QACjF,KAAK3C,OAAA,CAAQE,UAAA,CAAW0C,SAAA,GAAY;QAIpC,IAAMC,eAAA,GAAkBC,IAAA,CAAKC,GAAA,CAC3B,GACAD,IAAA,CAAKC,GAAA,CACHR,aAAA,CAAcS,qBAAA,CAAsBC,CAAA,EACpCH,IAAA,CAAKC,GAAA,CAAIR,aAAA,CAAcS,qBAAA,CAAsBE,CAAA,EAAGX,aAAA,CAAcS,qBAAA,CAAsBG,CAAC,CACtF,CACF;QAED,KAAKnD,OAAA,CAAQoD,gBAAA,CAAiBC,KAAA,CAAMC,MAAA,CAClCf,aAAA,CAAcS,qBAAA,CAAsBC,CAAA,GAAIJ,eAAA,EACxCN,aAAA,CAAcS,qBAAA,CAAsBE,CAAA,GAAIL,eAAA,EACxCN,aAAA,CAAcS,qBAAA,CAAsBG,CAAA,GAAIN,eACzC;QACD,KAAK7C,OAAA,CAAQoD,gBAAA,CAAiBR,SAAA,GAAYC,eAAA;QAC1C,KAAK7C,OAAA,CAAQoD,gBAAA,CAAiBG,QAAA,CAASC,IAAA,CAAKjB,aAAA,CAAckB,qBAAqB;QAE/E,IAAI,KAAKrD,uBAAA,EAAyB;UAChC,KAAKA,uBAAA,CAAyB;UAC9B,KAAKA,uBAAA,GAA0B;QAChC;MACF;IACF;EAAA;IAAAwB,GAAA;IAAAC,KAAA,EAED,SAAA6B,QAAA,EAAU;MACR,KAAK1D,OAAA,GAAU;MACf,KAAKC,QAAA,GAAW;MAChB,KAAKC,UAAA,GAAa;MAClB,KAAKK,cAAA,GAAiB;IACvB;EAAA;EAAA,OAAAR,iBAAA;AAAA;AAAA,IAGU4D,gBAAA,0BAAAC,MAAA;EAAAC,SAAA,CAAAF,gBAAA,EAAAC,MAAA;EAAA,IAAAE,MAAA,GAAAC,YAAA,CAAAJ,gBAAA;EACX,SAAAA,iBAAY1D,QAAA,EAAwC;IAAA,IAAA+D,MAAA;IAAA,IAA9B7D,qBAAA,GAAA8D,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAwB;IAAA3D,eAAA,OAAAqD,gBAAA;IAC5CK,MAAA,GAAAF,MAAA,CAAAM,IAAA;IAEAJ,MAAA,CAAK9D,UAAA,GAAa,IAAImE,UAAA,CAAY;IAClCL,MAAA,CAAK9D,UAAA,CAAW0C,SAAA,GAAY;IAC5BoB,MAAA,CAAKM,GAAA,CAAIN,MAAA,CAAK9D,UAAU;IAExB8D,MAAA,CAAKZ,gBAAA,GAAmB,IAAImB,gBAAA,CAAkB;IAC9CP,MAAA,CAAKZ,gBAAA,CAAiBR,SAAA,GAAY;IAClCoB,MAAA,CAAKM,GAAA,CAAIN,MAAA,CAAKZ,gBAAgB;IAI9BY,MAAA,CAAK/C,WAAA,GAAc;IAEnB,IAAIuD,iBAAA,GAAoB;IACxB,IAAIC,iBAAA,GAAoB;IACxBxE,QAAA,CAASW,EAAA,CAAGY,gBAAA,CAAiB,gBAAgB,YAAM;MACjD,IAAMb,OAAA,GAAUV,QAAA,CAASW,EAAA,CAAGC,UAAA,CAAY;MAExC,IAAI,uBAAuBF,OAAA,EAAS;QAClCA,OAAA,CACG+D,iBAAA,CAAkB;UACjBC,gBAAA,EAAkBhE,OAAA,CAAQU;QACtC,CAAW,EACAuD,IAAA,CAAK,UAACC,KAAA,EAAU;UACfL,iBAAA,GAAoB,IAAIzE,iBAAA,CAAA+E,sBAAA,CAAAd,MAAA,GAAwB/D,QAAA,EAAU4E,KAAA,EAAO1E,qBAAA,EAAuB,YAAM;YAC5FsE,iBAAA,GAAoB;YAGpBT,MAAA,CAAKe,aAAA,CAAc;cAAEC,IAAA,EAAM;YAAiB,CAAE;UAC5D,CAAa;QACb,CAAW;MACJ;IACP,CAAK;IAED/E,QAAA,CAASW,EAAA,CAAGY,gBAAA,CAAiB,cAAc,YAAM;MAC/C,IAAIgD,iBAAA,EAAmB;QACrBA,iBAAA,CAAkBd,OAAA,CAAS;QAC3Bc,iBAAA,GAAoB;MACrB;MAED,IAAIC,iBAAA,EAAmB;QAErBT,MAAA,CAAKe,aAAA,CAAc;UAAEC,IAAA,EAAM;QAAe,CAAE;MAC7C;IACP,CAAK;IAGDhB,MAAA,CAAKN,OAAA,GAAU,YAAM;MACnB,IAAIc,iBAAA,EAAmB;QACrBA,iBAAA,CAAkBd,OAAA,CAAS;QAC3Bc,iBAAA,GAAoB;MACrB;MAEDR,MAAA,CAAKiB,MAAA,CAAOjB,MAAA,CAAK9D,UAAU;MAC3B8D,MAAA,CAAK9D,UAAA,GAAa;MAElB8D,MAAA,CAAKiB,MAAA,CAAOjB,MAAA,CAAKZ,gBAAgB;MACjCY,MAAA,CAAKZ,gBAAA,GAAmB;MAExBY,MAAA,CAAK/C,WAAA,GAAc;IACpB;IAAA,OAAA+C,MAAA;EACF;EAAA,OAAArC,YAAA,CAAAgC,gBAAA;AAAA,EAhEmCuB,KAAA"},"metadata":{},"sourceType":"module","externalDependencies":[]}