{"ast":null,"code":"import _toConsumableArray from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _wrapNativeSuper from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/wrapNativeSuper.js\";\nimport _get from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/get.js\";\nimport _getPrototypeOf from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js\";\nimport _assertThisInitialized from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js\";\nimport _inherits from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport _classCallCheck from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nvar _ref = function () {\n    var freeGlobal = typeof global == \"object\" && global && global.Object === Object && global;\n    var freeGlobal$1 = freeGlobal;\n    var freeSelf = typeof self == \"object\" && self && self.Object === Object && self;\n    var root = freeGlobal$1 || freeSelf || Function(\"return this\")();\n    var root$1 = root;\n    var Symbol$1 = root$1.Symbol;\n    var Symbol$2 = Symbol$1;\n    var objectProto$j = Object.prototype;\n    var hasOwnProperty$g = objectProto$j.hasOwnProperty;\n    var nativeObjectToString$1 = objectProto$j.toString;\n    var symToStringTag$1 = Symbol$2 ? Symbol$2.toStringTag : void 0;\n    function getRawTag(value) {\n      var isOwn = hasOwnProperty$g.call(value, symToStringTag$1),\n        tag = value[symToStringTag$1];\n      try {\n        value[symToStringTag$1] = void 0;\n        var unmasked = true;\n      } catch (e) {}\n      var result = nativeObjectToString$1.call(value);\n      if (unmasked) {\n        if (isOwn) {\n          value[symToStringTag$1] = tag;\n        } else {\n          delete value[symToStringTag$1];\n        }\n      }\n      return result;\n    }\n    var objectProto$i = Object.prototype;\n    var nativeObjectToString = objectProto$i.toString;\n    function objectToString(value) {\n      return nativeObjectToString.call(value);\n    }\n    var nullTag = \"[object Null]\",\n      undefinedTag = \"[object Undefined]\";\n    var symToStringTag = Symbol$2 ? Symbol$2.toStringTag : void 0;\n    function baseGetTag(value) {\n      if (value == null) {\n        return value === void 0 ? undefinedTag : nullTag;\n      }\n      return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);\n    }\n    function isObjectLike(value) {\n      return value != null && typeof value == \"object\";\n    }\n    var symbolTag$3 = \"[object Symbol]\";\n    function isSymbol(value) {\n      return typeof value == \"symbol\" || isObjectLike(value) && baseGetTag(value) == symbolTag$3;\n    }\n    function arrayMap(array, iteratee) {\n      var index = -1,\n        length = array == null ? 0 : array.length,\n        result = Array(length);\n      while (++index < length) {\n        result[index] = iteratee(array[index], index, array);\n      }\n      return result;\n    }\n    var isArray = Array.isArray;\n    var isArray$1 = isArray;\n    var INFINITY$3 = 1 / 0;\n    var symbolProto$2 = Symbol$2 ? Symbol$2.prototype : void 0,\n      symbolToString = symbolProto$2 ? symbolProto$2.toString : void 0;\n    function baseToString(value) {\n      if (typeof value == \"string\") {\n        return value;\n      }\n      if (isArray$1(value)) {\n        return arrayMap(value, baseToString) + \"\";\n      }\n      if (isSymbol(value)) {\n        return symbolToString ? symbolToString.call(value) : \"\";\n      }\n      var result = value + \"\";\n      return result == \"0\" && 1 / value == -INFINITY$3 ? \"-0\" : result;\n    }\n    var reWhitespace = /\\s/;\n    function trimmedEndIndex(string) {\n      var index = string.length;\n      while (index-- && reWhitespace.test(string.charAt(index))) {}\n      return index;\n    }\n    var reTrimStart = /^\\s+/;\n    function baseTrim(string) {\n      return string ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, \"\") : string;\n    }\n    function isObject(value) {\n      var type = typeof value;\n      return value != null && (type == \"object\" || type == \"function\");\n    }\n    var NAN = 0 / 0;\n    var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;\n    var reIsBinary = /^0b[01]+$/i;\n    var reIsOctal = /^0o[0-7]+$/i;\n    var freeParseInt = parseInt;\n    function toNumber(value) {\n      if (typeof value == \"number\") {\n        return value;\n      }\n      if (isSymbol(value)) {\n        return NAN;\n      }\n      if (isObject(value)) {\n        var other = typeof value.valueOf == \"function\" ? value.valueOf() : value;\n        value = isObject(other) ? other + \"\" : other;\n      }\n      if (typeof value != \"string\") {\n        return value === 0 ? value : +value;\n      }\n      value = baseTrim(value);\n      var isBinary = reIsBinary.test(value);\n      return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;\n    }\n    var INFINITY$2 = 1 / 0,\n      MAX_INTEGER = 17976931348623157e292;\n    function toFinite(value) {\n      if (!value) {\n        return value === 0 ? value : 0;\n      }\n      value = toNumber(value);\n      if (value === INFINITY$2 || value === -INFINITY$2) {\n        var sign = value < 0 ? -1 : 1;\n        return sign * MAX_INTEGER;\n      }\n      return value === value ? value : 0;\n    }\n    function toInteger(value) {\n      var result = toFinite(value),\n        remainder = result % 1;\n      return result === result ? remainder ? result - remainder : result : 0;\n    }\n    function identity(value) {\n      return value;\n    }\n    var asyncTag = \"[object AsyncFunction]\",\n      funcTag$2 = \"[object Function]\",\n      genTag$1 = \"[object GeneratorFunction]\",\n      proxyTag = \"[object Proxy]\";\n    function isFunction(value) {\n      if (!isObject(value)) {\n        return false;\n      }\n      var tag = baseGetTag(value);\n      return tag == funcTag$2 || tag == genTag$1 || tag == asyncTag || tag == proxyTag;\n    }\n    var coreJsData = root$1[\"__core-js_shared__\"];\n    var coreJsData$1 = coreJsData;\n    var maskSrcKey = function () {\n      var uid = /[^.]+$/.exec(coreJsData$1 && coreJsData$1.keys && coreJsData$1.keys.IE_PROTO || \"\");\n      return uid ? \"Symbol(src)_1.\" + uid : \"\";\n    }();\n    function isMasked(func) {\n      return !!maskSrcKey && maskSrcKey in func;\n    }\n    var funcProto$1 = Function.prototype;\n    var funcToString$1 = funcProto$1.toString;\n    function toSource(func) {\n      if (func != null) {\n        try {\n          return funcToString$1.call(func);\n        } catch (e) {}\n        try {\n          return func + \"\";\n        } catch (e) {}\n      }\n      return \"\";\n    }\n    var reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g;\n    var reIsHostCtor = /^\\[object .+?Constructor\\]$/;\n    var funcProto = Function.prototype,\n      objectProto$h = Object.prototype;\n    var funcToString = funcProto.toString;\n    var hasOwnProperty$f = objectProto$h.hasOwnProperty;\n    var reIsNative = RegExp(\"^\" + funcToString.call(hasOwnProperty$f).replace(reRegExpChar, \"\\\\$&\").replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, \"$1.*?\") + \"$\");\n    function baseIsNative(value) {\n      if (!isObject(value) || isMasked(value)) {\n        return false;\n      }\n      var pattern = isFunction(value) ? reIsNative : reIsHostCtor;\n      return pattern.test(toSource(value));\n    }\n    function getValue(object, key) {\n      return object == null ? void 0 : object[key];\n    }\n    function getNative(object, key) {\n      var value = getValue(object, key);\n      return baseIsNative(value) ? value : void 0;\n    }\n    var WeakMap = getNative(root$1, \"WeakMap\");\n    var WeakMap$1 = WeakMap;\n    var objectCreate = Object.create;\n    var baseCreate = function () {\n      function object() {}\n      return function (proto) {\n        if (!isObject(proto)) {\n          return {};\n        }\n        if (objectCreate) {\n          return objectCreate(proto);\n        }\n        object.prototype = proto;\n        var result = new object();\n        object.prototype = void 0;\n        return result;\n      };\n    }();\n    var baseCreate$1 = baseCreate;\n    function apply(func, thisArg, args) {\n      switch (args.length) {\n        case 0:\n          return func.call(thisArg);\n        case 1:\n          return func.call(thisArg, args[0]);\n        case 2:\n          return func.call(thisArg, args[0], args[1]);\n        case 3:\n          return func.call(thisArg, args[0], args[1], args[2]);\n      }\n      return func.apply(thisArg, args);\n    }\n    function noop() {}\n    function copyArray(source, array) {\n      var index = -1,\n        length = source.length;\n      array || (array = Array(length));\n      while (++index < length) {\n        array[index] = source[index];\n      }\n      return array;\n    }\n    var HOT_COUNT = 800,\n      HOT_SPAN = 16;\n    var nativeNow = Date.now;\n    function shortOut(func) {\n      var count = 0,\n        lastCalled = 0;\n      return function () {\n        var stamp = nativeNow(),\n          remaining = HOT_SPAN - (stamp - lastCalled);\n        lastCalled = stamp;\n        if (remaining > 0) {\n          if (++count >= HOT_COUNT) {\n            return arguments[0];\n          }\n        } else {\n          count = 0;\n        }\n        return func.apply(void 0, arguments);\n      };\n    }\n    function constant(value) {\n      return function () {\n        return value;\n      };\n    }\n    var defineProperty = function () {\n      try {\n        var func = getNative(Object, \"defineProperty\");\n        func({}, \"\", {});\n        return func;\n      } catch (e) {}\n    }();\n    var defineProperty$1 = defineProperty;\n    var baseSetToString = !defineProperty$1 ? identity : function (func, string) {\n      return defineProperty$1(func, \"toString\", {\n        configurable: true,\n        enumerable: false,\n        value: constant(string),\n        writable: true\n      });\n    };\n    var baseSetToString$1 = baseSetToString;\n    var setToString = shortOut(baseSetToString$1);\n    var setToString$1 = setToString;\n    function arrayEach(array, iteratee) {\n      var index = -1,\n        length = array == null ? 0 : array.length;\n      while (++index < length) {\n        if (iteratee(array[index], index, array) === false) {\n          break;\n        }\n      }\n      return array;\n    }\n    function baseFindIndex(array, predicate, fromIndex, fromRight) {\n      var length = array.length,\n        index = fromIndex + (fromRight ? 1 : -1);\n      while (fromRight ? index-- : ++index < length) {\n        if (predicate(array[index], index, array)) {\n          return index;\n        }\n      }\n      return -1;\n    }\n    function baseIsNaN(value) {\n      return value !== value;\n    }\n    function strictIndexOf(array, value, fromIndex) {\n      var index = fromIndex - 1,\n        length = array.length;\n      while (++index < length) {\n        if (array[index] === value) {\n          return index;\n        }\n      }\n      return -1;\n    }\n    function baseIndexOf(array, value, fromIndex) {\n      return value === value ? strictIndexOf(array, value, fromIndex) : baseFindIndex(array, baseIsNaN, fromIndex);\n    }\n    function arrayIncludes(array, value) {\n      var length = array == null ? 0 : array.length;\n      return !!length && baseIndexOf(array, value, 0) > -1;\n    }\n    var MAX_SAFE_INTEGER$1 = 9007199254740991;\n    var reIsUint = /^(?:0|[1-9]\\d*)$/;\n    function isIndex(value, length) {\n      var type = typeof value;\n      length = length == null ? MAX_SAFE_INTEGER$1 : length;\n      return !!length && (type == \"number\" || type != \"symbol\" && reIsUint.test(value)) && value > -1 && value % 1 == 0 && value < length;\n    }\n    function baseAssignValue(object, key, value) {\n      if (key == \"__proto__\" && defineProperty$1) {\n        defineProperty$1(object, key, {\n          configurable: true,\n          enumerable: true,\n          value: value,\n          writable: true\n        });\n      } else {\n        object[key] = value;\n      }\n    }\n    function eq(value, other) {\n      return value === other || value !== value && other !== other;\n    }\n    var objectProto$g = Object.prototype;\n    var hasOwnProperty$e = objectProto$g.hasOwnProperty;\n    function assignValue(object, key, value) {\n      var objValue = object[key];\n      if (!(hasOwnProperty$e.call(object, key) && eq(objValue, value)) || value === void 0 && !(key in object)) {\n        baseAssignValue(object, key, value);\n      }\n    }\n    function copyObject(source, props, object, customizer) {\n      var isNew = !object;\n      object || (object = {});\n      var index = -1,\n        length = props.length;\n      while (++index < length) {\n        var key = props[index];\n        var newValue = customizer ? customizer(object[key], source[key], key, object, source) : void 0;\n        if (newValue === void 0) {\n          newValue = source[key];\n        }\n        if (isNew) {\n          baseAssignValue(object, key, newValue);\n        } else {\n          assignValue(object, key, newValue);\n        }\n      }\n      return object;\n    }\n    var nativeMax$3 = Math.max;\n    function overRest(func, start, transform) {\n      start = nativeMax$3(start === void 0 ? func.length - 1 : start, 0);\n      return function () {\n        var args = arguments,\n          index = -1,\n          length = nativeMax$3(args.length - start, 0),\n          array = Array(length);\n        while (++index < length) {\n          array[index] = args[start + index];\n        }\n        index = -1;\n        var otherArgs = Array(start + 1);\n        while (++index < start) {\n          otherArgs[index] = args[index];\n        }\n        otherArgs[start] = transform(array);\n        return apply(func, this, otherArgs);\n      };\n    }\n    function baseRest(func, start) {\n      return setToString$1(overRest(func, start, identity), func + \"\");\n    }\n    var MAX_SAFE_INTEGER = 9007199254740991;\n    function isLength(value) {\n      return typeof value == \"number\" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;\n    }\n    function isArrayLike(value) {\n      return value != null && isLength(value.length) && !isFunction(value);\n    }\n    function isIterateeCall(value, index, object) {\n      if (!isObject(object)) {\n        return false;\n      }\n      var type = typeof index;\n      if (type == \"number\" ? isArrayLike(object) && isIndex(index, object.length) : type == \"string\" && index in object) {\n        return eq(object[index], value);\n      }\n      return false;\n    }\n    function createAssigner(assigner) {\n      return baseRest(function (object, sources) {\n        var index = -1,\n          length = sources.length,\n          customizer = length > 1 ? sources[length - 1] : void 0,\n          guard = length > 2 ? sources[2] : void 0;\n        customizer = assigner.length > 3 && typeof customizer == \"function\" ? (length--, customizer) : void 0;\n        if (guard && isIterateeCall(sources[0], sources[1], guard)) {\n          customizer = length < 3 ? void 0 : customizer;\n          length = 1;\n        }\n        object = Object(object);\n        while (++index < length) {\n          var source = sources[index];\n          if (source) {\n            assigner(object, source, index, customizer);\n          }\n        }\n        return object;\n      });\n    }\n    var objectProto$f = Object.prototype;\n    function isPrototype(value) {\n      var Ctor = value && value.constructor,\n        proto = typeof Ctor == \"function\" && Ctor.prototype || objectProto$f;\n      return value === proto;\n    }\n    function baseTimes(n, iteratee) {\n      var index = -1,\n        result = Array(n);\n      while (++index < n) {\n        result[index] = iteratee(index);\n      }\n      return result;\n    }\n    var argsTag$3 = \"[object Arguments]\";\n    function baseIsArguments(value) {\n      return isObjectLike(value) && baseGetTag(value) == argsTag$3;\n    }\n    var objectProto$e = Object.prototype;\n    var hasOwnProperty$d = objectProto$e.hasOwnProperty;\n    var propertyIsEnumerable$1 = objectProto$e.propertyIsEnumerable;\n    var isArguments = baseIsArguments(function () {\n      return arguments;\n    }()) ? baseIsArguments : function (value) {\n      return isObjectLike(value) && hasOwnProperty$d.call(value, \"callee\") && !propertyIsEnumerable$1.call(value, \"callee\");\n    };\n    var isArguments$1 = isArguments;\n    function stubFalse() {\n      return false;\n    }\n    var freeExports$2 = typeof exports == \"object\" && exports && !exports.nodeType && exports;\n    var freeModule$2 = freeExports$2 && typeof module == \"object\" && module && !module.nodeType && module;\n    var moduleExports$2 = freeModule$2 && freeModule$2.exports === freeExports$2;\n    var Buffer$1 = moduleExports$2 ? root$1.Buffer : void 0;\n    var nativeIsBuffer = Buffer$1 ? Buffer$1.isBuffer : void 0;\n    var isBuffer = nativeIsBuffer || stubFalse;\n    var isBuffer$1 = isBuffer;\n    var argsTag$2 = \"[object Arguments]\",\n      arrayTag$2 = \"[object Array]\",\n      boolTag$3 = \"[object Boolean]\",\n      dateTag$3 = \"[object Date]\",\n      errorTag$2 = \"[object Error]\",\n      funcTag$1 = \"[object Function]\",\n      mapTag$6 = \"[object Map]\",\n      numberTag$3 = \"[object Number]\",\n      objectTag$3 = \"[object Object]\",\n      regexpTag$4 = \"[object RegExp]\",\n      setTag$6 = \"[object Set]\",\n      stringTag$4 = \"[object String]\",\n      weakMapTag$2 = \"[object WeakMap]\";\n    var arrayBufferTag$3 = \"[object ArrayBuffer]\",\n      dataViewTag$4 = \"[object DataView]\",\n      float32Tag$2 = \"[object Float32Array]\",\n      float64Tag$2 = \"[object Float64Array]\",\n      int8Tag$2 = \"[object Int8Array]\",\n      int16Tag$2 = \"[object Int16Array]\",\n      int32Tag$2 = \"[object Int32Array]\",\n      uint8Tag$2 = \"[object Uint8Array]\",\n      uint8ClampedTag$2 = \"[object Uint8ClampedArray]\",\n      uint16Tag$2 = \"[object Uint16Array]\",\n      uint32Tag$2 = \"[object Uint32Array]\";\n    var typedArrayTags = {};\n    typedArrayTags[float32Tag$2] = typedArrayTags[float64Tag$2] = typedArrayTags[int8Tag$2] = typedArrayTags[int16Tag$2] = typedArrayTags[int32Tag$2] = typedArrayTags[uint8Tag$2] = typedArrayTags[uint8ClampedTag$2] = typedArrayTags[uint16Tag$2] = typedArrayTags[uint32Tag$2] = true;\n    typedArrayTags[argsTag$2] = typedArrayTags[arrayTag$2] = typedArrayTags[arrayBufferTag$3] = typedArrayTags[boolTag$3] = typedArrayTags[dataViewTag$4] = typedArrayTags[dateTag$3] = typedArrayTags[errorTag$2] = typedArrayTags[funcTag$1] = typedArrayTags[mapTag$6] = typedArrayTags[numberTag$3] = typedArrayTags[objectTag$3] = typedArrayTags[regexpTag$4] = typedArrayTags[setTag$6] = typedArrayTags[stringTag$4] = typedArrayTags[weakMapTag$2] = false;\n    function baseIsTypedArray(value) {\n      return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];\n    }\n    function baseUnary(func) {\n      return function (value) {\n        return func(value);\n      };\n    }\n    var freeExports$1 = typeof exports == \"object\" && exports && !exports.nodeType && exports;\n    var freeModule$1 = freeExports$1 && typeof module == \"object\" && module && !module.nodeType && module;\n    var moduleExports$1 = freeModule$1 && freeModule$1.exports === freeExports$1;\n    var freeProcess = moduleExports$1 && freeGlobal$1.process;\n    var nodeUtil = function () {\n      try {\n        var types = freeModule$1 && freeModule$1.require && freeModule$1.require(\"util\").types;\n        if (types) {\n          return types;\n        }\n        return freeProcess && freeProcess.binding && freeProcess.binding(\"util\");\n      } catch (e) {}\n    }();\n    var nodeUtil$1 = nodeUtil;\n    var nodeIsTypedArray = nodeUtil$1 && nodeUtil$1.isTypedArray;\n    var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;\n    var isTypedArray$1 = isTypedArray;\n    var objectProto$d = Object.prototype;\n    var hasOwnProperty$c = objectProto$d.hasOwnProperty;\n    function arrayLikeKeys(value, inherited) {\n      var isArr = isArray$1(value),\n        isArg = !isArr && isArguments$1(value),\n        isBuff = !isArr && !isArg && isBuffer$1(value),\n        isType = !isArr && !isArg && !isBuff && isTypedArray$1(value),\n        skipIndexes = isArr || isArg || isBuff || isType,\n        result = skipIndexes ? baseTimes(value.length, String) : [],\n        length = result.length;\n      for (var key in value) {\n        if ((inherited || hasOwnProperty$c.call(value, key)) && !(skipIndexes && (\n        // Safari 9 has enumerable `arguments.length` in strict mode.\n        key == \"length\" ||\n        // Node.js 0.10 has enumerable non-index properties on buffers.\n        isBuff && (key == \"offset\" || key == \"parent\") ||\n        // PhantomJS 2 has enumerable non-index properties on typed arrays.\n        isType && (key == \"buffer\" || key == \"byteLength\" || key == \"byteOffset\") ||\n        // Skip index properties.\n        isIndex(key, length)))) {\n          result.push(key);\n        }\n      }\n      return result;\n    }\n    function overArg(func, transform) {\n      return function (arg) {\n        return func(transform(arg));\n      };\n    }\n    var nativeKeys = overArg(Object.keys, Object);\n    var nativeKeys$1 = nativeKeys;\n    var objectProto$c = Object.prototype;\n    var hasOwnProperty$b = objectProto$c.hasOwnProperty;\n    function baseKeys(object) {\n      if (!isPrototype(object)) {\n        return nativeKeys$1(object);\n      }\n      var result = [];\n      for (var key in Object(object)) {\n        if (hasOwnProperty$b.call(object, key) && key != \"constructor\") {\n          result.push(key);\n        }\n      }\n      return result;\n    }\n    function keys(object) {\n      return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);\n    }\n    var objectProto$b = Object.prototype;\n    var hasOwnProperty$a = objectProto$b.hasOwnProperty;\n    var assign = createAssigner(function (object, source) {\n      if (isPrototype(source) || isArrayLike(source)) {\n        copyObject(source, keys(source), object);\n        return;\n      }\n      for (var key in source) {\n        if (hasOwnProperty$a.call(source, key)) {\n          assignValue(object, key, source[key]);\n        }\n      }\n    });\n    var assign$1 = assign;\n    function nativeKeysIn(object) {\n      var result = [];\n      if (object != null) {\n        for (var key in Object(object)) {\n          result.push(key);\n        }\n      }\n      return result;\n    }\n    var objectProto$a = Object.prototype;\n    var hasOwnProperty$9 = objectProto$a.hasOwnProperty;\n    function baseKeysIn(object) {\n      if (!isObject(object)) {\n        return nativeKeysIn(object);\n      }\n      var isProto = isPrototype(object),\n        result = [];\n      for (var key in object) {\n        if (!(key == \"constructor\" && (isProto || !hasOwnProperty$9.call(object, key)))) {\n          result.push(key);\n        }\n      }\n      return result;\n    }\n    function keysIn(object) {\n      return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);\n    }\n    var reIsDeepProp = /\\.|\\[(?:[^[\\]]*|([\"'])(?:(?!\\1)[^\\\\]|\\\\.)*?\\1)\\]/,\n      reIsPlainProp = /^\\w*$/;\n    function isKey(value, object) {\n      if (isArray$1(value)) {\n        return false;\n      }\n      var type = typeof value;\n      if (type == \"number\" || type == \"symbol\" || type == \"boolean\" || value == null || isSymbol(value)) {\n        return true;\n      }\n      return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);\n    }\n    var nativeCreate = getNative(Object, \"create\");\n    var nativeCreate$1 = nativeCreate;\n    function hashClear() {\n      this.__data__ = nativeCreate$1 ? nativeCreate$1(null) : {};\n      this.size = 0;\n    }\n    function hashDelete(key) {\n      var result = this.has(key) && delete this.__data__[key];\n      this.size -= result ? 1 : 0;\n      return result;\n    }\n    var HASH_UNDEFINED$2 = \"__lodash_hash_undefined__\";\n    var objectProto$9 = Object.prototype;\n    var hasOwnProperty$8 = objectProto$9.hasOwnProperty;\n    function hashGet(key) {\n      var data = this.__data__;\n      if (nativeCreate$1) {\n        var result = data[key];\n        return result === HASH_UNDEFINED$2 ? void 0 : result;\n      }\n      return hasOwnProperty$8.call(data, key) ? data[key] : void 0;\n    }\n    var objectProto$8 = Object.prototype;\n    var hasOwnProperty$7 = objectProto$8.hasOwnProperty;\n    function hashHas(key) {\n      var data = this.__data__;\n      return nativeCreate$1 ? data[key] !== void 0 : hasOwnProperty$7.call(data, key);\n    }\n    var HASH_UNDEFINED$1 = \"__lodash_hash_undefined__\";\n    function hashSet(key, value) {\n      var data = this.__data__;\n      this.size += this.has(key) ? 0 : 1;\n      data[key] = nativeCreate$1 && value === void 0 ? HASH_UNDEFINED$1 : value;\n      return this;\n    }\n    function Hash(entries) {\n      var index = -1,\n        length = entries == null ? 0 : entries.length;\n      this.clear();\n      while (++index < length) {\n        var entry = entries[index];\n        this.set(entry[0], entry[1]);\n      }\n    }\n    Hash.prototype.clear = hashClear;\n    Hash.prototype[\"delete\"] = hashDelete;\n    Hash.prototype.get = hashGet;\n    Hash.prototype.has = hashHas;\n    Hash.prototype.set = hashSet;\n    function listCacheClear() {\n      this.__data__ = [];\n      this.size = 0;\n    }\n    function assocIndexOf(array, key) {\n      var length = array.length;\n      while (length--) {\n        if (eq(array[length][0], key)) {\n          return length;\n        }\n      }\n      return -1;\n    }\n    var arrayProto = Array.prototype;\n    var splice = arrayProto.splice;\n    function listCacheDelete(key) {\n      var data = this.__data__,\n        index = assocIndexOf(data, key);\n      if (index < 0) {\n        return false;\n      }\n      var lastIndex = data.length - 1;\n      if (index == lastIndex) {\n        data.pop();\n      } else {\n        splice.call(data, index, 1);\n      }\n      --this.size;\n      return true;\n    }\n    function listCacheGet(key) {\n      var data = this.__data__,\n        index = assocIndexOf(data, key);\n      return index < 0 ? void 0 : data[index][1];\n    }\n    function listCacheHas(key) {\n      return assocIndexOf(this.__data__, key) > -1;\n    }\n    function listCacheSet(key, value) {\n      var data = this.__data__,\n        index = assocIndexOf(data, key);\n      if (index < 0) {\n        ++this.size;\n        data.push([key, value]);\n      } else {\n        data[index][1] = value;\n      }\n      return this;\n    }\n    function ListCache(entries) {\n      var index = -1,\n        length = entries == null ? 0 : entries.length;\n      this.clear();\n      while (++index < length) {\n        var entry = entries[index];\n        this.set(entry[0], entry[1]);\n      }\n    }\n    ListCache.prototype.clear = listCacheClear;\n    ListCache.prototype[\"delete\"] = listCacheDelete;\n    ListCache.prototype.get = listCacheGet;\n    ListCache.prototype.has = listCacheHas;\n    ListCache.prototype.set = listCacheSet;\n    var Map$1 = getNative(root$1, \"Map\");\n    var Map$2 = Map$1;\n    function mapCacheClear() {\n      this.size = 0;\n      this.__data__ = {\n        hash: new Hash(),\n        map: new (Map$2 || ListCache)(),\n        string: new Hash()\n      };\n    }\n    function isKeyable(value) {\n      var type = typeof value;\n      return type == \"string\" || type == \"number\" || type == \"symbol\" || type == \"boolean\" ? value !== \"__proto__\" : value === null;\n    }\n    function getMapData(map2, key) {\n      var data = map2.__data__;\n      return isKeyable(key) ? data[typeof key == \"string\" ? \"string\" : \"hash\"] : data.map;\n    }\n    function mapCacheDelete(key) {\n      var result = getMapData(this, key)[\"delete\"](key);\n      this.size -= result ? 1 : 0;\n      return result;\n    }\n    function mapCacheGet(key) {\n      return getMapData(this, key).get(key);\n    }\n    function mapCacheHas(key) {\n      return getMapData(this, key).has(key);\n    }\n    function mapCacheSet(key, value) {\n      var data = getMapData(this, key),\n        size = data.size;\n      data.set(key, value);\n      this.size += data.size == size ? 0 : 1;\n      return this;\n    }\n    function MapCache(entries) {\n      var index = -1,\n        length = entries == null ? 0 : entries.length;\n      this.clear();\n      while (++index < length) {\n        var entry = entries[index];\n        this.set(entry[0], entry[1]);\n      }\n    }\n    MapCache.prototype.clear = mapCacheClear;\n    MapCache.prototype[\"delete\"] = mapCacheDelete;\n    MapCache.prototype.get = mapCacheGet;\n    MapCache.prototype.has = mapCacheHas;\n    MapCache.prototype.set = mapCacheSet;\n    var FUNC_ERROR_TEXT$1 = \"Expected a function\";\n    function memoize(func, resolver) {\n      if (typeof func != \"function\" || resolver != null && typeof resolver != \"function\") {\n        throw new TypeError(FUNC_ERROR_TEXT$1);\n      }\n      var memoized = function memoized() {\n        var args = arguments,\n          key = resolver ? resolver.apply(this, args) : args[0],\n          cache = memoized.cache;\n        if (cache.has(key)) {\n          return cache.get(key);\n        }\n        var result = func.apply(this, args);\n        memoized.cache = cache.set(key, result) || cache;\n        return result;\n      };\n      memoized.cache = new (memoize.Cache || MapCache)();\n      return memoized;\n    }\n    memoize.Cache = MapCache;\n    var MAX_MEMOIZE_SIZE = 500;\n    function memoizeCapped(func) {\n      var result = memoize(func, function (key) {\n        if (cache.size === MAX_MEMOIZE_SIZE) {\n          cache.clear();\n        }\n        return key;\n      });\n      var cache = result.cache;\n      return result;\n    }\n    var rePropName = /[^.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))/g;\n    var reEscapeChar = /\\\\(\\\\)?/g;\n    var stringToPath = memoizeCapped(function (string) {\n      var result = [];\n      if (string.charCodeAt(0) === 46) {\n        result.push(\"\");\n      }\n      string.replace(rePropName, function (match, number, quote, subString) {\n        result.push(quote ? subString.replace(reEscapeChar, \"$1\") : number || match);\n      });\n      return result;\n    });\n    var stringToPath$1 = stringToPath;\n    function toString(value) {\n      return value == null ? \"\" : baseToString(value);\n    }\n    function castPath(value, object) {\n      if (isArray$1(value)) {\n        return value;\n      }\n      return isKey(value, object) ? [value] : stringToPath$1(toString(value));\n    }\n    var INFINITY$1 = 1 / 0;\n    function toKey(value) {\n      if (typeof value == \"string\" || isSymbol(value)) {\n        return value;\n      }\n      var result = value + \"\";\n      return result == \"0\" && 1 / value == -INFINITY$1 ? \"-0\" : result;\n    }\n    function baseGet(object, path) {\n      path = castPath(path, object);\n      var index = 0,\n        length = path.length;\n      while (object != null && index < length) {\n        object = object[toKey(path[index++])];\n      }\n      return index && index == length ? object : void 0;\n    }\n    function get(object, path, defaultValue) {\n      var result = object == null ? void 0 : baseGet(object, path);\n      return result === void 0 ? defaultValue : result;\n    }\n    function arrayPush(array, values2) {\n      var index = -1,\n        length = values2.length,\n        offset = array.length;\n      while (++index < length) {\n        array[offset + index] = values2[index];\n      }\n      return array;\n    }\n    var spreadableSymbol = Symbol$2 ? Symbol$2.isConcatSpreadable : void 0;\n    function isFlattenable(value) {\n      return isArray$1(value) || isArguments$1(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);\n    }\n    function baseFlatten(array, depth, predicate, isStrict, result) {\n      var index = -1,\n        length = array.length;\n      predicate || (predicate = isFlattenable);\n      result || (result = []);\n      while (++index < length) {\n        var value = array[index];\n        if (depth > 0 && predicate(value)) {\n          if (depth > 1) {\n            baseFlatten(value, depth - 1, predicate, isStrict, result);\n          } else {\n            arrayPush(result, value);\n          }\n        } else if (!isStrict) {\n          result[result.length] = value;\n        }\n      }\n      return result;\n    }\n    function flatten(array) {\n      var length = array == null ? 0 : array.length;\n      return length ? baseFlatten(array, 1) : [];\n    }\n    var getPrototype = overArg(Object.getPrototypeOf, Object);\n    var getPrototype$1 = getPrototype;\n    function baseSlice(array, start, end) {\n      var index = -1,\n        length = array.length;\n      if (start < 0) {\n        start = -start > length ? 0 : length + start;\n      }\n      end = end > length ? length : end;\n      if (end < 0) {\n        end += length;\n      }\n      length = start > end ? 0 : end - start >>> 0;\n      start >>>= 0;\n      var result = Array(length);\n      while (++index < length) {\n        result[index] = array[index + start];\n      }\n      return result;\n    }\n    function arrayReduce(array, iteratee, accumulator, initAccum) {\n      var index = -1,\n        length = array == null ? 0 : array.length;\n      if (initAccum && length) {\n        accumulator = array[++index];\n      }\n      while (++index < length) {\n        accumulator = iteratee(accumulator, array[index], index, array);\n      }\n      return accumulator;\n    }\n    function stackClear() {\n      this.__data__ = new ListCache();\n      this.size = 0;\n    }\n    function stackDelete(key) {\n      var data = this.__data__,\n        result = data[\"delete\"](key);\n      this.size = data.size;\n      return result;\n    }\n    function stackGet(key) {\n      return this.__data__.get(key);\n    }\n    function stackHas(key) {\n      return this.__data__.has(key);\n    }\n    var LARGE_ARRAY_SIZE$2 = 200;\n    function stackSet(key, value) {\n      var data = this.__data__;\n      if (data instanceof ListCache) {\n        var pairs = data.__data__;\n        if (!Map$2 || pairs.length < LARGE_ARRAY_SIZE$2 - 1) {\n          pairs.push([key, value]);\n          this.size = ++data.size;\n          return this;\n        }\n        data = this.__data__ = new MapCache(pairs);\n      }\n      data.set(key, value);\n      this.size = data.size;\n      return this;\n    }\n    function Stack(entries) {\n      var data = this.__data__ = new ListCache(entries);\n      this.size = data.size;\n    }\n    Stack.prototype.clear = stackClear;\n    Stack.prototype[\"delete\"] = stackDelete;\n    Stack.prototype.get = stackGet;\n    Stack.prototype.has = stackHas;\n    Stack.prototype.set = stackSet;\n    function baseAssign(object, source) {\n      return object && copyObject(source, keys(source), object);\n    }\n    function baseAssignIn(object, source) {\n      return object && copyObject(source, keysIn(source), object);\n    }\n    var freeExports = typeof exports == \"object\" && exports && !exports.nodeType && exports;\n    var freeModule = freeExports && typeof module == \"object\" && module && !module.nodeType && module;\n    var moduleExports = freeModule && freeModule.exports === freeExports;\n    var Buffer = moduleExports ? root$1.Buffer : void 0,\n      allocUnsafe = Buffer ? Buffer.allocUnsafe : void 0;\n    function cloneBuffer(buffer, isDeep) {\n      if (isDeep) {\n        return buffer.slice();\n      }\n      var length = buffer.length,\n        result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);\n      buffer.copy(result);\n      return result;\n    }\n    function arrayFilter(array, predicate) {\n      var index = -1,\n        length = array == null ? 0 : array.length,\n        resIndex = 0,\n        result = [];\n      while (++index < length) {\n        var value = array[index];\n        if (predicate(value, index, array)) {\n          result[resIndex++] = value;\n        }\n      }\n      return result;\n    }\n    function stubArray() {\n      return [];\n    }\n    var objectProto$7 = Object.prototype;\n    var propertyIsEnumerable = objectProto$7.propertyIsEnumerable;\n    var nativeGetSymbols$1 = Object.getOwnPropertySymbols;\n    var getSymbols = !nativeGetSymbols$1 ? stubArray : function (object) {\n      if (object == null) {\n        return [];\n      }\n      object = Object(object);\n      return arrayFilter(nativeGetSymbols$1(object), function (symbol) {\n        return propertyIsEnumerable.call(object, symbol);\n      });\n    };\n    var getSymbols$1 = getSymbols;\n    function copySymbols(source, object) {\n      return copyObject(source, getSymbols$1(source), object);\n    }\n    var nativeGetSymbols = Object.getOwnPropertySymbols;\n    var getSymbolsIn = !nativeGetSymbols ? stubArray : function (object) {\n      var result = [];\n      while (object) {\n        arrayPush(result, getSymbols$1(object));\n        object = getPrototype$1(object);\n      }\n      return result;\n    };\n    var getSymbolsIn$1 = getSymbolsIn;\n    function copySymbolsIn(source, object) {\n      return copyObject(source, getSymbolsIn$1(source), object);\n    }\n    function baseGetAllKeys(object, keysFunc, symbolsFunc) {\n      var result = keysFunc(object);\n      return isArray$1(object) ? result : arrayPush(result, symbolsFunc(object));\n    }\n    function getAllKeys(object) {\n      return baseGetAllKeys(object, keys, getSymbols$1);\n    }\n    function getAllKeysIn(object) {\n      return baseGetAllKeys(object, keysIn, getSymbolsIn$1);\n    }\n    var DataView = getNative(root$1, \"DataView\");\n    var DataView$1 = DataView;\n    var Promise$1 = getNative(root$1, \"Promise\");\n    var Promise$2 = Promise$1;\n    var Set = getNative(root$1, \"Set\");\n    var Set$1 = Set;\n    var mapTag$5 = \"[object Map]\",\n      objectTag$2 = \"[object Object]\",\n      promiseTag = \"[object Promise]\",\n      setTag$5 = \"[object Set]\",\n      weakMapTag$1 = \"[object WeakMap]\";\n    var dataViewTag$3 = \"[object DataView]\";\n    var dataViewCtorString = toSource(DataView$1),\n      mapCtorString = toSource(Map$2),\n      promiseCtorString = toSource(Promise$2),\n      setCtorString = toSource(Set$1),\n      weakMapCtorString = toSource(WeakMap$1);\n    var getTag = baseGetTag;\n    if (DataView$1 && getTag(new DataView$1(new ArrayBuffer(1))) != dataViewTag$3 || Map$2 && getTag(new Map$2()) != mapTag$5 || Promise$2 && getTag(Promise$2.resolve()) != promiseTag || Set$1 && getTag(new Set$1()) != setTag$5 || WeakMap$1 && getTag(new WeakMap$1()) != weakMapTag$1) {\n      getTag = function getTag(value) {\n        var result = baseGetTag(value),\n          Ctor = result == objectTag$2 ? value.constructor : void 0,\n          ctorString = Ctor ? toSource(Ctor) : \"\";\n        if (ctorString) {\n          switch (ctorString) {\n            case dataViewCtorString:\n              return dataViewTag$3;\n            case mapCtorString:\n              return mapTag$5;\n            case promiseCtorString:\n              return promiseTag;\n            case setCtorString:\n              return setTag$5;\n            case weakMapCtorString:\n              return weakMapTag$1;\n          }\n        }\n        return result;\n      };\n    }\n    var getTag$1 = getTag;\n    var objectProto$6 = Object.prototype;\n    var hasOwnProperty$6 = objectProto$6.hasOwnProperty;\n    function initCloneArray(array) {\n      var length = array.length,\n        result = new array.constructor(length);\n      if (length && typeof array[0] == \"string\" && hasOwnProperty$6.call(array, \"index\")) {\n        result.index = array.index;\n        result.input = array.input;\n      }\n      return result;\n    }\n    var Uint8Array = root$1.Uint8Array;\n    var Uint8Array$1 = Uint8Array;\n    function cloneArrayBuffer(arrayBuffer) {\n      var result = new arrayBuffer.constructor(arrayBuffer.byteLength);\n      new Uint8Array$1(result).set(new Uint8Array$1(arrayBuffer));\n      return result;\n    }\n    function cloneDataView(dataView, isDeep) {\n      var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;\n      return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);\n    }\n    var reFlags = /\\w*$/;\n    function cloneRegExp(regexp) {\n      var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));\n      result.lastIndex = regexp.lastIndex;\n      return result;\n    }\n    var symbolProto$1 = Symbol$2 ? Symbol$2.prototype : void 0,\n      symbolValueOf$1 = symbolProto$1 ? symbolProto$1.valueOf : void 0;\n    function cloneSymbol(symbol) {\n      return symbolValueOf$1 ? Object(symbolValueOf$1.call(symbol)) : {};\n    }\n    function cloneTypedArray(typedArray, isDeep) {\n      var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;\n      return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);\n    }\n    var boolTag$2 = \"[object Boolean]\",\n      dateTag$2 = \"[object Date]\",\n      mapTag$4 = \"[object Map]\",\n      numberTag$2 = \"[object Number]\",\n      regexpTag$3 = \"[object RegExp]\",\n      setTag$4 = \"[object Set]\",\n      stringTag$3 = \"[object String]\",\n      symbolTag$2 = \"[object Symbol]\";\n    var arrayBufferTag$2 = \"[object ArrayBuffer]\",\n      dataViewTag$2 = \"[object DataView]\",\n      float32Tag$1 = \"[object Float32Array]\",\n      float64Tag$1 = \"[object Float64Array]\",\n      int8Tag$1 = \"[object Int8Array]\",\n      int16Tag$1 = \"[object Int16Array]\",\n      int32Tag$1 = \"[object Int32Array]\",\n      uint8Tag$1 = \"[object Uint8Array]\",\n      uint8ClampedTag$1 = \"[object Uint8ClampedArray]\",\n      uint16Tag$1 = \"[object Uint16Array]\",\n      uint32Tag$1 = \"[object Uint32Array]\";\n    function initCloneByTag(object, tag, isDeep) {\n      var Ctor = object.constructor;\n      switch (tag) {\n        case arrayBufferTag$2:\n          return cloneArrayBuffer(object);\n        case boolTag$2:\n        case dateTag$2:\n          return new Ctor(+object);\n        case dataViewTag$2:\n          return cloneDataView(object, isDeep);\n        case float32Tag$1:\n        case float64Tag$1:\n        case int8Tag$1:\n        case int16Tag$1:\n        case int32Tag$1:\n        case uint8Tag$1:\n        case uint8ClampedTag$1:\n        case uint16Tag$1:\n        case uint32Tag$1:\n          return cloneTypedArray(object, isDeep);\n        case mapTag$4:\n          return new Ctor();\n        case numberTag$2:\n        case stringTag$3:\n          return new Ctor(object);\n        case regexpTag$3:\n          return cloneRegExp(object);\n        case setTag$4:\n          return new Ctor();\n        case symbolTag$2:\n          return cloneSymbol(object);\n      }\n    }\n    function initCloneObject(object) {\n      return typeof object.constructor == \"function\" && !isPrototype(object) ? baseCreate$1(getPrototype$1(object)) : {};\n    }\n    var mapTag$3 = \"[object Map]\";\n    function baseIsMap(value) {\n      return isObjectLike(value) && getTag$1(value) == mapTag$3;\n    }\n    var nodeIsMap = nodeUtil$1 && nodeUtil$1.isMap;\n    var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;\n    var isMap$1 = isMap;\n    var setTag$3 = \"[object Set]\";\n    function baseIsSet(value) {\n      return isObjectLike(value) && getTag$1(value) == setTag$3;\n    }\n    var nodeIsSet = nodeUtil$1 && nodeUtil$1.isSet;\n    var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;\n    var isSet$1 = isSet;\n    var CLONE_DEEP_FLAG = 1,\n      CLONE_FLAT_FLAG = 2,\n      CLONE_SYMBOLS_FLAG$1 = 4;\n    var argsTag$1 = \"[object Arguments]\",\n      arrayTag$1 = \"[object Array]\",\n      boolTag$1 = \"[object Boolean]\",\n      dateTag$1 = \"[object Date]\",\n      errorTag$1 = \"[object Error]\",\n      funcTag = \"[object Function]\",\n      genTag = \"[object GeneratorFunction]\",\n      mapTag$2 = \"[object Map]\",\n      numberTag$1 = \"[object Number]\",\n      objectTag$1 = \"[object Object]\",\n      regexpTag$2 = \"[object RegExp]\",\n      setTag$2 = \"[object Set]\",\n      stringTag$2 = \"[object String]\",\n      symbolTag$1 = \"[object Symbol]\",\n      weakMapTag = \"[object WeakMap]\";\n    var arrayBufferTag$1 = \"[object ArrayBuffer]\",\n      dataViewTag$1 = \"[object DataView]\",\n      float32Tag = \"[object Float32Array]\",\n      float64Tag = \"[object Float64Array]\",\n      int8Tag = \"[object Int8Array]\",\n      int16Tag = \"[object Int16Array]\",\n      int32Tag = \"[object Int32Array]\",\n      uint8Tag = \"[object Uint8Array]\",\n      uint8ClampedTag = \"[object Uint8ClampedArray]\",\n      uint16Tag = \"[object Uint16Array]\",\n      uint32Tag = \"[object Uint32Array]\";\n    var cloneableTags = {};\n    cloneableTags[argsTag$1] = cloneableTags[arrayTag$1] = cloneableTags[arrayBufferTag$1] = cloneableTags[dataViewTag$1] = cloneableTags[boolTag$1] = cloneableTags[dateTag$1] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag$2] = cloneableTags[numberTag$1] = cloneableTags[objectTag$1] = cloneableTags[regexpTag$2] = cloneableTags[setTag$2] = cloneableTags[stringTag$2] = cloneableTags[symbolTag$1] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;\n    cloneableTags[errorTag$1] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;\n    function baseClone(value, bitmask, customizer, key, object, stack) {\n      var result,\n        isDeep = bitmask & CLONE_DEEP_FLAG,\n        isFlat = bitmask & CLONE_FLAT_FLAG,\n        isFull = bitmask & CLONE_SYMBOLS_FLAG$1;\n      if (customizer) {\n        result = object ? customizer(value, key, object, stack) : customizer(value);\n      }\n      if (result !== void 0) {\n        return result;\n      }\n      if (!isObject(value)) {\n        return value;\n      }\n      var isArr = isArray$1(value);\n      if (isArr) {\n        result = initCloneArray(value);\n        if (!isDeep) {\n          return copyArray(value, result);\n        }\n      } else {\n        var tag = getTag$1(value),\n          isFunc = tag == funcTag || tag == genTag;\n        if (isBuffer$1(value)) {\n          return cloneBuffer(value, isDeep);\n        }\n        if (tag == objectTag$1 || tag == argsTag$1 || isFunc && !object) {\n          result = isFlat || isFunc ? {} : initCloneObject(value);\n          if (!isDeep) {\n            return isFlat ? copySymbolsIn(value, baseAssignIn(result, value)) : copySymbols(value, baseAssign(result, value));\n          }\n        } else {\n          if (!cloneableTags[tag]) {\n            return object ? value : {};\n          }\n          result = initCloneByTag(value, tag, isDeep);\n        }\n      }\n      stack || (stack = new Stack());\n      var stacked = stack.get(value);\n      if (stacked) {\n        return stacked;\n      }\n      stack.set(value, result);\n      if (isSet$1(value)) {\n        value.forEach(function (subValue) {\n          result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));\n        });\n      } else if (isMap$1(value)) {\n        value.forEach(function (subValue, key2) {\n          result.set(key2, baseClone(subValue, bitmask, customizer, key2, value, stack));\n        });\n      }\n      var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys;\n      var props = isArr ? void 0 : keysFunc(value);\n      arrayEach(props || value, function (subValue, key2) {\n        if (props) {\n          key2 = subValue;\n          subValue = value[key2];\n        }\n        assignValue(result, key2, baseClone(subValue, bitmask, customizer, key2, value, stack));\n      });\n      return result;\n    }\n    var CLONE_SYMBOLS_FLAG = 4;\n    function clone(value) {\n      return baseClone(value, CLONE_SYMBOLS_FLAG);\n    }\n    function compact(array) {\n      var index = -1,\n        length = array == null ? 0 : array.length,\n        resIndex = 0,\n        result = [];\n      while (++index < length) {\n        var value = array[index];\n        if (value) {\n          result[resIndex++] = value;\n        }\n      }\n      return result;\n    }\n    var HASH_UNDEFINED = \"__lodash_hash_undefined__\";\n    function setCacheAdd(value) {\n      this.__data__.set(value, HASH_UNDEFINED);\n      return this;\n    }\n    function setCacheHas(value) {\n      return this.__data__.has(value);\n    }\n    function SetCache(values2) {\n      var index = -1,\n        length = values2 == null ? 0 : values2.length;\n      this.__data__ = new MapCache();\n      while (++index < length) {\n        this.add(values2[index]);\n      }\n    }\n    SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;\n    SetCache.prototype.has = setCacheHas;\n    function arraySome(array, predicate) {\n      var index = -1,\n        length = array == null ? 0 : array.length;\n      while (++index < length) {\n        if (predicate(array[index], index, array)) {\n          return true;\n        }\n      }\n      return false;\n    }\n    function cacheHas(cache, key) {\n      return cache.has(key);\n    }\n    var COMPARE_PARTIAL_FLAG$5 = 1,\n      COMPARE_UNORDERED_FLAG$3 = 2;\n    function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {\n      var isPartial = bitmask & COMPARE_PARTIAL_FLAG$5,\n        arrLength = array.length,\n        othLength = other.length;\n      if (arrLength != othLength && !(isPartial && othLength > arrLength)) {\n        return false;\n      }\n      var arrStacked = stack.get(array);\n      var othStacked = stack.get(other);\n      if (arrStacked && othStacked) {\n        return arrStacked == other && othStacked == array;\n      }\n      var index = -1,\n        result = true,\n        seen = bitmask & COMPARE_UNORDERED_FLAG$3 ? new SetCache() : void 0;\n      stack.set(array, other);\n      stack.set(other, array);\n      while (++index < arrLength) {\n        var arrValue = array[index],\n          othValue = other[index];\n        if (customizer) {\n          var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);\n        }\n        if (compared !== void 0) {\n          if (compared) {\n            continue;\n          }\n          result = false;\n          break;\n        }\n        if (seen) {\n          if (!arraySome(other, function (othValue2, othIndex) {\n            if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {\n              return seen.push(othIndex);\n            }\n          })) {\n            result = false;\n            break;\n          }\n        } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {\n          result = false;\n          break;\n        }\n      }\n      stack[\"delete\"](array);\n      stack[\"delete\"](other);\n      return result;\n    }\n    function mapToArray(map2) {\n      var index = -1,\n        result = Array(map2.size);\n      map2.forEach(function (value, key) {\n        result[++index] = [key, value];\n      });\n      return result;\n    }\n    function setToArray(set) {\n      var index = -1,\n        result = Array(set.size);\n      set.forEach(function (value) {\n        result[++index] = value;\n      });\n      return result;\n    }\n    var COMPARE_PARTIAL_FLAG$4 = 1,\n      COMPARE_UNORDERED_FLAG$2 = 2;\n    var boolTag = \"[object Boolean]\",\n      dateTag = \"[object Date]\",\n      errorTag = \"[object Error]\",\n      mapTag$1 = \"[object Map]\",\n      numberTag = \"[object Number]\",\n      regexpTag$1 = \"[object RegExp]\",\n      setTag$1 = \"[object Set]\",\n      stringTag$1 = \"[object String]\",\n      symbolTag = \"[object Symbol]\";\n    var arrayBufferTag = \"[object ArrayBuffer]\",\n      dataViewTag = \"[object DataView]\";\n    var symbolProto = Symbol$2 ? Symbol$2.prototype : void 0,\n      symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;\n    function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {\n      switch (tag) {\n        case dataViewTag:\n          if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {\n            return false;\n          }\n          object = object.buffer;\n          other = other.buffer;\n        case arrayBufferTag:\n          if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array$1(object), new Uint8Array$1(other))) {\n            return false;\n          }\n          return true;\n        case boolTag:\n        case dateTag:\n        case numberTag:\n          return eq(+object, +other);\n        case errorTag:\n          return object.name == other.name && object.message == other.message;\n        case regexpTag$1:\n        case stringTag$1:\n          return object == other + \"\";\n        case mapTag$1:\n          var convert = mapToArray;\n        case setTag$1:\n          var isPartial = bitmask & COMPARE_PARTIAL_FLAG$4;\n          convert || (convert = setToArray);\n          if (object.size != other.size && !isPartial) {\n            return false;\n          }\n          var stacked = stack.get(object);\n          if (stacked) {\n            return stacked == other;\n          }\n          bitmask |= COMPARE_UNORDERED_FLAG$2;\n          stack.set(object, other);\n          var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);\n          stack[\"delete\"](object);\n          return result;\n        case symbolTag:\n          if (symbolValueOf) {\n            return symbolValueOf.call(object) == symbolValueOf.call(other);\n          }\n      }\n      return false;\n    }\n    var COMPARE_PARTIAL_FLAG$3 = 1;\n    var objectProto$5 = Object.prototype;\n    var hasOwnProperty$5 = objectProto$5.hasOwnProperty;\n    function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {\n      var isPartial = bitmask & COMPARE_PARTIAL_FLAG$3,\n        objProps = getAllKeys(object),\n        objLength = objProps.length,\n        othProps = getAllKeys(other),\n        othLength = othProps.length;\n      if (objLength != othLength && !isPartial) {\n        return false;\n      }\n      var index = objLength;\n      while (index--) {\n        var key = objProps[index];\n        if (!(isPartial ? key in other : hasOwnProperty$5.call(other, key))) {\n          return false;\n        }\n      }\n      var objStacked = stack.get(object);\n      var othStacked = stack.get(other);\n      if (objStacked && othStacked) {\n        return objStacked == other && othStacked == object;\n      }\n      var result = true;\n      stack.set(object, other);\n      stack.set(other, object);\n      var skipCtor = isPartial;\n      while (++index < objLength) {\n        key = objProps[index];\n        var objValue = object[key],\n          othValue = other[key];\n        if (customizer) {\n          var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);\n        }\n        if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {\n          result = false;\n          break;\n        }\n        skipCtor || (skipCtor = key == \"constructor\");\n      }\n      if (result && !skipCtor) {\n        var objCtor = object.constructor,\n          othCtor = other.constructor;\n        if (objCtor != othCtor && \"constructor\" in object && \"constructor\" in other && !(typeof objCtor == \"function\" && objCtor instanceof objCtor && typeof othCtor == \"function\" && othCtor instanceof othCtor)) {\n          result = false;\n        }\n      }\n      stack[\"delete\"](object);\n      stack[\"delete\"](other);\n      return result;\n    }\n    var COMPARE_PARTIAL_FLAG$2 = 1;\n    var argsTag = \"[object Arguments]\",\n      arrayTag = \"[object Array]\",\n      objectTag = \"[object Object]\";\n    var objectProto$4 = Object.prototype;\n    var hasOwnProperty$4 = objectProto$4.hasOwnProperty;\n    function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {\n      var objIsArr = isArray$1(object),\n        othIsArr = isArray$1(other),\n        objTag = objIsArr ? arrayTag : getTag$1(object),\n        othTag = othIsArr ? arrayTag : getTag$1(other);\n      objTag = objTag == argsTag ? objectTag : objTag;\n      othTag = othTag == argsTag ? objectTag : othTag;\n      var objIsObj = objTag == objectTag,\n        othIsObj = othTag == objectTag,\n        isSameTag = objTag == othTag;\n      if (isSameTag && isBuffer$1(object)) {\n        if (!isBuffer$1(other)) {\n          return false;\n        }\n        objIsArr = true;\n        objIsObj = false;\n      }\n      if (isSameTag && !objIsObj) {\n        stack || (stack = new Stack());\n        return objIsArr || isTypedArray$1(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);\n      }\n      if (!(bitmask & COMPARE_PARTIAL_FLAG$2)) {\n        var objIsWrapped = objIsObj && hasOwnProperty$4.call(object, \"__wrapped__\"),\n          othIsWrapped = othIsObj && hasOwnProperty$4.call(other, \"__wrapped__\");\n        if (objIsWrapped || othIsWrapped) {\n          var objUnwrapped = objIsWrapped ? object.value() : object,\n            othUnwrapped = othIsWrapped ? other.value() : other;\n          stack || (stack = new Stack());\n          return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);\n        }\n      }\n      if (!isSameTag) {\n        return false;\n      }\n      stack || (stack = new Stack());\n      return equalObjects(object, other, bitmask, customizer, equalFunc, stack);\n    }\n    function baseIsEqual(value, other, bitmask, customizer, stack) {\n      if (value === other) {\n        return true;\n      }\n      if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {\n        return value !== value && other !== other;\n      }\n      return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);\n    }\n    var COMPARE_PARTIAL_FLAG$1 = 1,\n      COMPARE_UNORDERED_FLAG$1 = 2;\n    function baseIsMatch(object, source, matchData, customizer) {\n      var index = matchData.length,\n        length = index,\n        noCustomizer = !customizer;\n      if (object == null) {\n        return !length;\n      }\n      object = Object(object);\n      while (index--) {\n        var data = matchData[index];\n        if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {\n          return false;\n        }\n      }\n      while (++index < length) {\n        data = matchData[index];\n        var key = data[0],\n          objValue = object[key],\n          srcValue = data[1];\n        if (noCustomizer && data[2]) {\n          if (objValue === void 0 && !(key in object)) {\n            return false;\n          }\n        } else {\n          var stack = new Stack();\n          if (customizer) {\n            var result = customizer(objValue, srcValue, key, object, source, stack);\n          }\n          if (!(result === void 0 ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG$1 | COMPARE_UNORDERED_FLAG$1, customizer, stack) : result)) {\n            return false;\n          }\n        }\n      }\n      return true;\n    }\n    function isStrictComparable(value) {\n      return value === value && !isObject(value);\n    }\n    function getMatchData(object) {\n      var result = keys(object),\n        length = result.length;\n      while (length--) {\n        var key = result[length],\n          value = object[key];\n        result[length] = [key, value, isStrictComparable(value)];\n      }\n      return result;\n    }\n    function matchesStrictComparable(key, srcValue) {\n      return function (object) {\n        if (object == null) {\n          return false;\n        }\n        return object[key] === srcValue && (srcValue !== void 0 || key in Object(object));\n      };\n    }\n    function baseMatches(source) {\n      var matchData = getMatchData(source);\n      if (matchData.length == 1 && matchData[0][2]) {\n        return matchesStrictComparable(matchData[0][0], matchData[0][1]);\n      }\n      return function (object) {\n        return object === source || baseIsMatch(object, source, matchData);\n      };\n    }\n    function baseHasIn(object, key) {\n      return object != null && key in Object(object);\n    }\n    function hasPath(object, path, hasFunc) {\n      path = castPath(path, object);\n      var index = -1,\n        length = path.length,\n        result = false;\n      while (++index < length) {\n        var key = toKey(path[index]);\n        if (!(result = object != null && hasFunc(object, key))) {\n          break;\n        }\n        object = object[key];\n      }\n      if (result || ++index != length) {\n        return result;\n      }\n      length = object == null ? 0 : object.length;\n      return !!length && isLength(length) && isIndex(key, length) && (isArray$1(object) || isArguments$1(object));\n    }\n    function hasIn(object, path) {\n      return object != null && hasPath(object, path, baseHasIn);\n    }\n    var COMPARE_PARTIAL_FLAG = 1,\n      COMPARE_UNORDERED_FLAG = 2;\n    function baseMatchesProperty(path, srcValue) {\n      if (isKey(path) && isStrictComparable(srcValue)) {\n        return matchesStrictComparable(toKey(path), srcValue);\n      }\n      return function (object) {\n        var objValue = get(object, path);\n        return objValue === void 0 && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);\n      };\n    }\n    function baseProperty(key) {\n      return function (object) {\n        return object == null ? void 0 : object[key];\n      };\n    }\n    function basePropertyDeep(path) {\n      return function (object) {\n        return baseGet(object, path);\n      };\n    }\n    function property(path) {\n      return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);\n    }\n    function baseIteratee(value) {\n      if (typeof value == \"function\") {\n        return value;\n      }\n      if (value == null) {\n        return identity;\n      }\n      if (typeof value == \"object\") {\n        return isArray$1(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);\n      }\n      return property(value);\n    }\n    function arrayAggregator(array, setter, iteratee, accumulator) {\n      var index = -1,\n        length = array == null ? 0 : array.length;\n      while (++index < length) {\n        var value = array[index];\n        setter(accumulator, value, iteratee(value), array);\n      }\n      return accumulator;\n    }\n    function createBaseFor(fromRight) {\n      return function (object, iteratee, keysFunc) {\n        var index = -1,\n          iterable = Object(object),\n          props = keysFunc(object),\n          length = props.length;\n        while (length--) {\n          var key = props[fromRight ? length : ++index];\n          if (iteratee(iterable[key], key, iterable) === false) {\n            break;\n          }\n        }\n        return object;\n      };\n    }\n    var baseFor = createBaseFor();\n    var baseFor$1 = baseFor;\n    function baseForOwn(object, iteratee) {\n      return object && baseFor$1(object, iteratee, keys);\n    }\n    function createBaseEach(eachFunc, fromRight) {\n      return function (collection, iteratee) {\n        if (collection == null) {\n          return collection;\n        }\n        if (!isArrayLike(collection)) {\n          return eachFunc(collection, iteratee);\n        }\n        var length = collection.length,\n          index = fromRight ? length : -1,\n          iterable = Object(collection);\n        while (fromRight ? index-- : ++index < length) {\n          if (iteratee(iterable[index], index, iterable) === false) {\n            break;\n          }\n        }\n        return collection;\n      };\n    }\n    var baseEach = createBaseEach(baseForOwn);\n    var baseEach$1 = baseEach;\n    function baseAggregator(collection, setter, iteratee, accumulator) {\n      baseEach$1(collection, function (value, key, collection2) {\n        setter(accumulator, value, iteratee(value), collection2);\n      });\n      return accumulator;\n    }\n    function createAggregator(setter, initializer) {\n      return function (collection, iteratee) {\n        var func = isArray$1(collection) ? arrayAggregator : baseAggregator,\n          accumulator = initializer ? initializer() : {};\n        return func(collection, setter, baseIteratee(iteratee), accumulator);\n      };\n    }\n    var objectProto$3 = Object.prototype;\n    var hasOwnProperty$3 = objectProto$3.hasOwnProperty;\n    var defaults = baseRest(function (object, sources) {\n      object = Object(object);\n      var index = -1;\n      var length = sources.length;\n      var guard = length > 2 ? sources[2] : void 0;\n      if (guard && isIterateeCall(sources[0], sources[1], guard)) {\n        length = 1;\n      }\n      while (++index < length) {\n        var source = sources[index];\n        var props = keysIn(source);\n        var propsIndex = -1;\n        var propsLength = props.length;\n        while (++propsIndex < propsLength) {\n          var key = props[propsIndex];\n          var value = object[key];\n          if (value === void 0 || eq(value, objectProto$3[key]) && !hasOwnProperty$3.call(object, key)) {\n            object[key] = source[key];\n          }\n        }\n      }\n      return object;\n    });\n    var defaults$1 = defaults;\n    function isArrayLikeObject(value) {\n      return isObjectLike(value) && isArrayLike(value);\n    }\n    function arrayIncludesWith(array, value, comparator) {\n      var index = -1,\n        length = array == null ? 0 : array.length;\n      while (++index < length) {\n        if (comparator(value, array[index])) {\n          return true;\n        }\n      }\n      return false;\n    }\n    var LARGE_ARRAY_SIZE$1 = 200;\n    function baseDifference(array, values2, iteratee, comparator) {\n      var index = -1,\n        includes2 = arrayIncludes,\n        isCommon = true,\n        length = array.length,\n        result = [],\n        valuesLength = values2.length;\n      if (!length) {\n        return result;\n      }\n      if (iteratee) {\n        values2 = arrayMap(values2, baseUnary(iteratee));\n      }\n      if (comparator) {\n        includes2 = arrayIncludesWith;\n        isCommon = false;\n      } else if (values2.length >= LARGE_ARRAY_SIZE$1) {\n        includes2 = cacheHas;\n        isCommon = false;\n        values2 = new SetCache(values2);\n      }\n      outer: while (++index < length) {\n        var value = array[index],\n          computed = iteratee == null ? value : iteratee(value);\n        value = comparator || value !== 0 ? value : 0;\n        if (isCommon && computed === computed) {\n          var valuesIndex = valuesLength;\n          while (valuesIndex--) {\n            if (values2[valuesIndex] === computed) {\n              continue outer;\n            }\n          }\n          result.push(value);\n        } else if (!includes2(values2, computed, comparator)) {\n          result.push(value);\n        }\n      }\n      return result;\n    }\n    var difference = baseRest(function (array, values2) {\n      return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true)) : [];\n    });\n    var difference$1 = difference;\n    function last(array) {\n      var length = array == null ? 0 : array.length;\n      return length ? array[length - 1] : void 0;\n    }\n    function drop(array, n, guard) {\n      var length = array == null ? 0 : array.length;\n      if (!length) {\n        return [];\n      }\n      n = guard || n === void 0 ? 1 : toInteger(n);\n      return baseSlice(array, n < 0 ? 0 : n, length);\n    }\n    function dropRight(array, n, guard) {\n      var length = array == null ? 0 : array.length;\n      if (!length) {\n        return [];\n      }\n      n = guard || n === void 0 ? 1 : toInteger(n);\n      n = length - n;\n      return baseSlice(array, 0, n < 0 ? 0 : n);\n    }\n    function castFunction(value) {\n      return typeof value == \"function\" ? value : identity;\n    }\n    function forEach(collection, iteratee) {\n      var func = isArray$1(collection) ? arrayEach : baseEach$1;\n      return func(collection, castFunction(iteratee));\n    }\n    function arrayEvery(array, predicate) {\n      var index = -1,\n        length = array == null ? 0 : array.length;\n      while (++index < length) {\n        if (!predicate(array[index], index, array)) {\n          return false;\n        }\n      }\n      return true;\n    }\n    function baseEvery(collection, predicate) {\n      var result = true;\n      baseEach$1(collection, function (value, index, collection2) {\n        result = !!predicate(value, index, collection2);\n        return result;\n      });\n      return result;\n    }\n    function every(collection, predicate, guard) {\n      var func = isArray$1(collection) ? arrayEvery : baseEvery;\n      if (guard && isIterateeCall(collection, predicate, guard)) {\n        predicate = void 0;\n      }\n      return func(collection, baseIteratee(predicate));\n    }\n    function baseFilter(collection, predicate) {\n      var result = [];\n      baseEach$1(collection, function (value, index, collection2) {\n        if (predicate(value, index, collection2)) {\n          result.push(value);\n        }\n      });\n      return result;\n    }\n    function filter(collection, predicate) {\n      var func = isArray$1(collection) ? arrayFilter : baseFilter;\n      return func(collection, baseIteratee(predicate));\n    }\n    function createFind(findIndexFunc) {\n      return function (collection, predicate, fromIndex) {\n        var iterable = Object(collection);\n        if (!isArrayLike(collection)) {\n          var iteratee = baseIteratee(predicate);\n          collection = keys(collection);\n          predicate = function predicate(key) {\n            return iteratee(iterable[key], key, iterable);\n          };\n        }\n        var index = findIndexFunc(collection, predicate, fromIndex);\n        return index > -1 ? iterable[iteratee ? collection[index] : index] : void 0;\n      };\n    }\n    var nativeMax$2 = Math.max;\n    function findIndex(array, predicate, fromIndex) {\n      var length = array == null ? 0 : array.length;\n      if (!length) {\n        return -1;\n      }\n      var index = fromIndex == null ? 0 : toInteger(fromIndex);\n      if (index < 0) {\n        index = nativeMax$2(length + index, 0);\n      }\n      return baseFindIndex(array, baseIteratee(predicate), index);\n    }\n    var find = createFind(findIndex);\n    var find$1 = find;\n    function head(array) {\n      return array && array.length ? array[0] : void 0;\n    }\n    function baseMap(collection, iteratee) {\n      var index = -1,\n        result = isArrayLike(collection) ? Array(collection.length) : [];\n      baseEach$1(collection, function (value, key, collection2) {\n        result[++index] = iteratee(value, key, collection2);\n      });\n      return result;\n    }\n    function map(collection, iteratee) {\n      var func = isArray$1(collection) ? arrayMap : baseMap;\n      return func(collection, baseIteratee(iteratee));\n    }\n    function flatMap(collection, iteratee) {\n      return baseFlatten(map(collection, iteratee), 1);\n    }\n    var objectProto$2 = Object.prototype;\n    var hasOwnProperty$2 = objectProto$2.hasOwnProperty;\n    var groupBy = createAggregator(function (result, value, key) {\n      if (hasOwnProperty$2.call(result, key)) {\n        result[key].push(value);\n      } else {\n        baseAssignValue(result, key, [value]);\n      }\n    });\n    var groupBy$1 = groupBy;\n    var objectProto$1 = Object.prototype;\n    var hasOwnProperty$1 = objectProto$1.hasOwnProperty;\n    function baseHas(object, key) {\n      return object != null && hasOwnProperty$1.call(object, key);\n    }\n    function has(object, path) {\n      return object != null && hasPath(object, path, baseHas);\n    }\n    var stringTag = \"[object String]\";\n    function isString(value) {\n      return typeof value == \"string\" || !isArray$1(value) && isObjectLike(value) && baseGetTag(value) == stringTag;\n    }\n    function baseValues(object, props) {\n      return arrayMap(props, function (key) {\n        return object[key];\n      });\n    }\n    function values(object) {\n      return object == null ? [] : baseValues(object, keys(object));\n    }\n    var nativeMax$1 = Math.max;\n    function includes(collection, value, fromIndex, guard) {\n      collection = isArrayLike(collection) ? collection : values(collection);\n      fromIndex = fromIndex && !guard ? toInteger(fromIndex) : 0;\n      var length = collection.length;\n      if (fromIndex < 0) {\n        fromIndex = nativeMax$1(length + fromIndex, 0);\n      }\n      return isString(collection) ? fromIndex <= length && collection.indexOf(value, fromIndex) > -1 : !!length && baseIndexOf(collection, value, fromIndex) > -1;\n    }\n    var nativeMax = Math.max;\n    function indexOf(array, value, fromIndex) {\n      var length = array == null ? 0 : array.length;\n      if (!length) {\n        return -1;\n      }\n      var index = fromIndex == null ? 0 : toInteger(fromIndex);\n      if (index < 0) {\n        index = nativeMax(length + index, 0);\n      }\n      return baseIndexOf(array, value, index);\n    }\n    var mapTag = \"[object Map]\",\n      setTag = \"[object Set]\";\n    var objectProto = Object.prototype;\n    var hasOwnProperty = objectProto.hasOwnProperty;\n    function isEmpty(value) {\n      if (value == null) {\n        return true;\n      }\n      if (isArrayLike(value) && (isArray$1(value) || typeof value == \"string\" || typeof value.splice == \"function\" || isBuffer$1(value) || isTypedArray$1(value) || isArguments$1(value))) {\n        return !value.length;\n      }\n      var tag = getTag$1(value);\n      if (tag == mapTag || tag == setTag) {\n        return !value.size;\n      }\n      if (isPrototype(value)) {\n        return !baseKeys(value).length;\n      }\n      for (var key in value) {\n        if (hasOwnProperty.call(value, key)) {\n          return false;\n        }\n      }\n      return true;\n    }\n    var regexpTag = \"[object RegExp]\";\n    function baseIsRegExp(value) {\n      return isObjectLike(value) && baseGetTag(value) == regexpTag;\n    }\n    var nodeIsRegExp = nodeUtil$1 && nodeUtil$1.isRegExp;\n    var isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;\n    var isRegExp$1 = isRegExp;\n    function isUndefined(value) {\n      return value === void 0;\n    }\n    var FUNC_ERROR_TEXT = \"Expected a function\";\n    function negate(predicate) {\n      if (typeof predicate != \"function\") {\n        throw new TypeError(FUNC_ERROR_TEXT);\n      }\n      return function () {\n        var args = arguments;\n        switch (args.length) {\n          case 0:\n            return !predicate.call(this);\n          case 1:\n            return !predicate.call(this, args[0]);\n          case 2:\n            return !predicate.call(this, args[0], args[1]);\n          case 3:\n            return !predicate.call(this, args[0], args[1], args[2]);\n        }\n        return !predicate.apply(this, args);\n      };\n    }\n    function baseSet(object, path, value, customizer) {\n      if (!isObject(object)) {\n        return object;\n      }\n      path = castPath(path, object);\n      var index = -1,\n        length = path.length,\n        lastIndex = length - 1,\n        nested = object;\n      while (nested != null && ++index < length) {\n        var key = toKey(path[index]),\n          newValue = value;\n        if (key === \"__proto__\" || key === \"constructor\" || key === \"prototype\") {\n          return object;\n        }\n        if (index != lastIndex) {\n          var objValue = nested[key];\n          newValue = customizer ? customizer(objValue, key, nested) : void 0;\n          if (newValue === void 0) {\n            newValue = isObject(objValue) ? objValue : isIndex(path[index + 1]) ? [] : {};\n          }\n        }\n        assignValue(nested, key, newValue);\n        nested = nested[key];\n      }\n      return object;\n    }\n    function basePickBy(object, paths, predicate) {\n      var index = -1,\n        length = paths.length,\n        result = {};\n      while (++index < length) {\n        var path = paths[index],\n          value = baseGet(object, path);\n        if (predicate(value, path)) {\n          baseSet(result, castPath(path, object), value);\n        }\n      }\n      return result;\n    }\n    function pickBy(object, predicate) {\n      if (object == null) {\n        return {};\n      }\n      var props = arrayMap(getAllKeysIn(object), function (prop) {\n        return [prop];\n      });\n      predicate = baseIteratee(predicate);\n      return basePickBy(object, props, function (value, path) {\n        return predicate(value, path[0]);\n      });\n    }\n    function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {\n      eachFunc(collection, function (value, index, collection2) {\n        accumulator = initAccum ? (initAccum = false, value) : iteratee(accumulator, value, index, collection2);\n      });\n      return accumulator;\n    }\n    function reduce(collection, iteratee, accumulator) {\n      var func = isArray$1(collection) ? arrayReduce : baseReduce,\n        initAccum = arguments.length < 3;\n      return func(collection, baseIteratee(iteratee), accumulator, initAccum, baseEach$1);\n    }\n    function reject(collection, predicate) {\n      var func = isArray$1(collection) ? arrayFilter : baseFilter;\n      return func(collection, negate(baseIteratee(predicate)));\n    }\n    function baseSome(collection, predicate) {\n      var result;\n      baseEach$1(collection, function (value, index, collection2) {\n        result = predicate(value, index, collection2);\n        return !result;\n      });\n      return !!result;\n    }\n    function some(collection, predicate, guard) {\n      var func = isArray$1(collection) ? arraySome : baseSome;\n      if (guard && isIterateeCall(collection, predicate, guard)) {\n        predicate = void 0;\n      }\n      return func(collection, baseIteratee(predicate));\n    }\n    var INFINITY = 1 / 0;\n    var createSet = !(Set$1 && 1 / setToArray(new Set$1([, -0]))[1] == INFINITY) ? noop : function (values2) {\n      return new Set$1(values2);\n    };\n    var createSet$1 = createSet;\n    var LARGE_ARRAY_SIZE = 200;\n    function baseUniq(array, iteratee, comparator) {\n      var index = -1,\n        includes2 = arrayIncludes,\n        length = array.length,\n        isCommon = true,\n        result = [],\n        seen = result;\n      if (comparator) {\n        isCommon = false;\n        includes2 = arrayIncludesWith;\n      } else if (length >= LARGE_ARRAY_SIZE) {\n        var set = iteratee ? null : createSet$1(array);\n        if (set) {\n          return setToArray(set);\n        }\n        isCommon = false;\n        includes2 = cacheHas;\n        seen = new SetCache();\n      } else {\n        seen = iteratee ? [] : result;\n      }\n      outer: while (++index < length) {\n        var value = array[index],\n          computed = iteratee ? iteratee(value) : value;\n        value = comparator || value !== 0 ? value : 0;\n        if (isCommon && computed === computed) {\n          var seenIndex = seen.length;\n          while (seenIndex--) {\n            if (seen[seenIndex] === computed) {\n              continue outer;\n            }\n          }\n          if (iteratee) {\n            seen.push(computed);\n          }\n          result.push(value);\n        } else if (!includes2(seen, computed, comparator)) {\n          if (seen !== result) {\n            seen.push(computed);\n          }\n          result.push(value);\n        }\n      }\n      return result;\n    }\n    function uniq(array) {\n      return array && array.length ? baseUniq(array) : [];\n    }\n    function PRINT_ERROR(msg) {\n      if (console && console.error) {\n        console.error(\"Error: \".concat(msg));\n      }\n    }\n    function PRINT_WARNING(msg) {\n      if (console && console.warn) {\n        console.warn(\"Warning: \".concat(msg));\n      }\n    }\n    function timer(func) {\n      var start = /* @__PURE__ */new Date().getTime();\n      var val = func();\n      var end = /* @__PURE__ */new Date().getTime();\n      var total = end - start;\n      return {\n        time: total,\n        value: val\n      };\n    }\n    function toFastProperties(toBecomeFast) {\n      function FakeConstructor() {}\n      FakeConstructor.prototype = toBecomeFast;\n      var fakeInstance = new FakeConstructor();\n      function fakeAccess() {\n        return typeof fakeInstance.bar;\n      }\n      fakeAccess();\n      fakeAccess();\n      return toBecomeFast;\n    }\n    function tokenLabel$1(tokType) {\n      if (hasTokenLabel$1(tokType)) {\n        return tokType.LABEL;\n      } else {\n        return tokType.name;\n      }\n    }\n    function hasTokenLabel$1(obj) {\n      return isString(obj.LABEL) && obj.LABEL !== \"\";\n    }\n    var AbstractProduction = /*#__PURE__*/function () {\n      function AbstractProduction(_definition) {\n        _classCallCheck(this, AbstractProduction);\n        this._definition = _definition;\n      }\n      _createClass(AbstractProduction, [{\n        key: \"definition\",\n        get: function get() {\n          return this._definition;\n        },\n        set: function set(value) {\n          this._definition = value;\n        }\n      }, {\n        key: \"accept\",\n        value: function accept(visitor) {\n          visitor.visit(this);\n          forEach(this.definition, function (prod) {\n            prod.accept(visitor);\n          });\n        }\n      }]);\n      return AbstractProduction;\n    }();\n    var NonTerminal = /*#__PURE__*/function (_AbstractProduction) {\n      _inherits(NonTerminal, _AbstractProduction);\n      var _super = _createSuper(NonTerminal);\n      function NonTerminal(options) {\n        var _this;\n        _classCallCheck(this, NonTerminal);\n        _this = _super.call(this, []);\n        _this.idx = 1;\n        assign$1(_assertThisInitialized(_this), pickBy(options, function (v) {\n          return v !== void 0;\n        }));\n        return _this;\n      }\n      _createClass(NonTerminal, [{\n        key: \"definition\",\n        get: function get() {\n          if (this.referencedRule !== void 0) {\n            return this.referencedRule.definition;\n          }\n          return [];\n        },\n        set: function set(definition) {}\n      }, {\n        key: \"accept\",\n        value: function accept(visitor) {\n          visitor.visit(this);\n        }\n      }]);\n      return NonTerminal;\n    }(AbstractProduction);\n    var Rule = /*#__PURE__*/function (_AbstractProduction2) {\n      _inherits(Rule, _AbstractProduction2);\n      var _super2 = _createSuper(Rule);\n      function Rule(options) {\n        var _this2;\n        _classCallCheck(this, Rule);\n        _this2 = _super2.call(this, options.definition);\n        _this2.orgText = \"\";\n        assign$1(_assertThisInitialized(_this2), pickBy(options, function (v) {\n          return v !== void 0;\n        }));\n        return _this2;\n      }\n      return _createClass(Rule);\n    }(AbstractProduction);\n    var Alternative = /*#__PURE__*/function (_AbstractProduction3) {\n      _inherits(Alternative, _AbstractProduction3);\n      var _super3 = _createSuper(Alternative);\n      function Alternative(options) {\n        var _this3;\n        _classCallCheck(this, Alternative);\n        _this3 = _super3.call(this, options.definition);\n        _this3.ignoreAmbiguities = false;\n        assign$1(_assertThisInitialized(_this3), pickBy(options, function (v) {\n          return v !== void 0;\n        }));\n        return _this3;\n      }\n      return _createClass(Alternative);\n    }(AbstractProduction);\n    var Option = /*#__PURE__*/function (_AbstractProduction4) {\n      _inherits(Option, _AbstractProduction4);\n      var _super4 = _createSuper(Option);\n      function Option(options) {\n        var _this4;\n        _classCallCheck(this, Option);\n        _this4 = _super4.call(this, options.definition);\n        _this4.idx = 1;\n        assign$1(_assertThisInitialized(_this4), pickBy(options, function (v) {\n          return v !== void 0;\n        }));\n        return _this4;\n      }\n      return _createClass(Option);\n    }(AbstractProduction);\n    var RepetitionMandatory = /*#__PURE__*/function (_AbstractProduction5) {\n      _inherits(RepetitionMandatory, _AbstractProduction5);\n      var _super5 = _createSuper(RepetitionMandatory);\n      function RepetitionMandatory(options) {\n        var _this5;\n        _classCallCheck(this, RepetitionMandatory);\n        _this5 = _super5.call(this, options.definition);\n        _this5.idx = 1;\n        assign$1(_assertThisInitialized(_this5), pickBy(options, function (v) {\n          return v !== void 0;\n        }));\n        return _this5;\n      }\n      return _createClass(RepetitionMandatory);\n    }(AbstractProduction);\n    var RepetitionMandatoryWithSeparator = /*#__PURE__*/function (_AbstractProduction6) {\n      _inherits(RepetitionMandatoryWithSeparator, _AbstractProduction6);\n      var _super6 = _createSuper(RepetitionMandatoryWithSeparator);\n      function RepetitionMandatoryWithSeparator(options) {\n        var _this6;\n        _classCallCheck(this, RepetitionMandatoryWithSeparator);\n        _this6 = _super6.call(this, options.definition);\n        _this6.idx = 1;\n        assign$1(_assertThisInitialized(_this6), pickBy(options, function (v) {\n          return v !== void 0;\n        }));\n        return _this6;\n      }\n      return _createClass(RepetitionMandatoryWithSeparator);\n    }(AbstractProduction);\n    var Repetition = /*#__PURE__*/function (_AbstractProduction7) {\n      _inherits(Repetition, _AbstractProduction7);\n      var _super7 = _createSuper(Repetition);\n      function Repetition(options) {\n        var _this7;\n        _classCallCheck(this, Repetition);\n        _this7 = _super7.call(this, options.definition);\n        _this7.idx = 1;\n        assign$1(_assertThisInitialized(_this7), pickBy(options, function (v) {\n          return v !== void 0;\n        }));\n        return _this7;\n      }\n      return _createClass(Repetition);\n    }(AbstractProduction);\n    var RepetitionWithSeparator = /*#__PURE__*/function (_AbstractProduction8) {\n      _inherits(RepetitionWithSeparator, _AbstractProduction8);\n      var _super8 = _createSuper(RepetitionWithSeparator);\n      function RepetitionWithSeparator(options) {\n        var _this8;\n        _classCallCheck(this, RepetitionWithSeparator);\n        _this8 = _super8.call(this, options.definition);\n        _this8.idx = 1;\n        assign$1(_assertThisInitialized(_this8), pickBy(options, function (v) {\n          return v !== void 0;\n        }));\n        return _this8;\n      }\n      return _createClass(RepetitionWithSeparator);\n    }(AbstractProduction);\n    var Alternation = /*#__PURE__*/function (_AbstractProduction9) {\n      _inherits(Alternation, _AbstractProduction9);\n      var _super9 = _createSuper(Alternation);\n      function Alternation(options) {\n        var _this9;\n        _classCallCheck(this, Alternation);\n        _this9 = _super9.call(this, options.definition);\n        _this9.idx = 1;\n        _this9.ignoreAmbiguities = false;\n        _this9.hasPredicates = false;\n        assign$1(_assertThisInitialized(_this9), pickBy(options, function (v) {\n          return v !== void 0;\n        }));\n        return _this9;\n      }\n      _createClass(Alternation, [{\n        key: \"definition\",\n        get: function get() {\n          return this._definition;\n        },\n        set: function set(value) {\n          this._definition = value;\n        }\n      }]);\n      return Alternation;\n    }(AbstractProduction);\n    var Terminal = /*#__PURE__*/function () {\n      function Terminal(options) {\n        _classCallCheck(this, Terminal);\n        this.idx = 1;\n        assign$1(this, pickBy(options, function (v) {\n          return v !== void 0;\n        }));\n      }\n      _createClass(Terminal, [{\n        key: \"accept\",\n        value: function accept(visitor) {\n          visitor.visit(this);\n        }\n      }]);\n      return Terminal;\n    }();\n    function serializeGrammar(topRules) {\n      return map(topRules, serializeProduction);\n    }\n    function serializeProduction(node) {\n      function convertDefinition(definition) {\n        return map(definition, serializeProduction);\n      }\n      if (node instanceof NonTerminal) {\n        var serializedNonTerminal = {\n          type: \"NonTerminal\",\n          name: node.nonTerminalName,\n          idx: node.idx\n        };\n        if (isString(node.label)) {\n          serializedNonTerminal.label = node.label;\n        }\n        return serializedNonTerminal;\n      } else if (node instanceof Alternative) {\n        return {\n          type: \"Alternative\",\n          definition: convertDefinition(node.definition)\n        };\n      } else if (node instanceof Option) {\n        return {\n          type: \"Option\",\n          idx: node.idx,\n          definition: convertDefinition(node.definition)\n        };\n      } else if (node instanceof RepetitionMandatory) {\n        return {\n          type: \"RepetitionMandatory\",\n          idx: node.idx,\n          definition: convertDefinition(node.definition)\n        };\n      } else if (node instanceof RepetitionMandatoryWithSeparator) {\n        return {\n          type: \"RepetitionMandatoryWithSeparator\",\n          idx: node.idx,\n          separator: serializeProduction(new Terminal({\n            terminalType: node.separator\n          })),\n          definition: convertDefinition(node.definition)\n        };\n      } else if (node instanceof RepetitionWithSeparator) {\n        return {\n          type: \"RepetitionWithSeparator\",\n          idx: node.idx,\n          separator: serializeProduction(new Terminal({\n            terminalType: node.separator\n          })),\n          definition: convertDefinition(node.definition)\n        };\n      } else if (node instanceof Repetition) {\n        return {\n          type: \"Repetition\",\n          idx: node.idx,\n          definition: convertDefinition(node.definition)\n        };\n      } else if (node instanceof Alternation) {\n        return {\n          type: \"Alternation\",\n          idx: node.idx,\n          definition: convertDefinition(node.definition)\n        };\n      } else if (node instanceof Terminal) {\n        var serializedTerminal = {\n          type: \"Terminal\",\n          name: node.terminalType.name,\n          label: tokenLabel$1(node.terminalType),\n          idx: node.idx\n        };\n        if (isString(node.label)) {\n          serializedTerminal.terminalLabel = node.label;\n        }\n        var pattern = node.terminalType.PATTERN;\n        if (node.terminalType.PATTERN) {\n          serializedTerminal.pattern = isRegExp$1(pattern) ? pattern.source : pattern;\n        }\n        return serializedTerminal;\n      } else if (node instanceof Rule) {\n        return {\n          type: \"Rule\",\n          name: node.name,\n          orgText: node.orgText,\n          definition: convertDefinition(node.definition)\n        };\n      } else {\n        throw Error(\"non exhaustive match\");\n      }\n    }\n    var GAstVisitor = /*#__PURE__*/function () {\n      function GAstVisitor() {\n        _classCallCheck(this, GAstVisitor);\n      }\n      _createClass(GAstVisitor, [{\n        key: \"visit\",\n        value: function visit(node) {\n          var nodeAny = node;\n          switch (nodeAny.constructor) {\n            case NonTerminal:\n              return this.visitNonTerminal(nodeAny);\n            case Alternative:\n              return this.visitAlternative(nodeAny);\n            case Option:\n              return this.visitOption(nodeAny);\n            case RepetitionMandatory:\n              return this.visitRepetitionMandatory(nodeAny);\n            case RepetitionMandatoryWithSeparator:\n              return this.visitRepetitionMandatoryWithSeparator(nodeAny);\n            case RepetitionWithSeparator:\n              return this.visitRepetitionWithSeparator(nodeAny);\n            case Repetition:\n              return this.visitRepetition(nodeAny);\n            case Alternation:\n              return this.visitAlternation(nodeAny);\n            case Terminal:\n              return this.visitTerminal(nodeAny);\n            case Rule:\n              return this.visitRule(nodeAny);\n            default:\n              throw Error(\"non exhaustive match\");\n          }\n        }\n        /* c8 ignore next */\n      }, {\n        key: \"visitNonTerminal\",\n        value: function visitNonTerminal(node) {}\n        /* c8 ignore next */\n      }, {\n        key: \"visitAlternative\",\n        value: function visitAlternative(node) {}\n        /* c8 ignore next */\n      }, {\n        key: \"visitOption\",\n        value: function visitOption(node) {}\n        /* c8 ignore next */\n      }, {\n        key: \"visitRepetition\",\n        value: function visitRepetition(node) {}\n        /* c8 ignore next */\n      }, {\n        key: \"visitRepetitionMandatory\",\n        value: function visitRepetitionMandatory(node) {}\n        /* c8 ignore next 3 */\n      }, {\n        key: \"visitRepetitionMandatoryWithSeparator\",\n        value: function visitRepetitionMandatoryWithSeparator(node) {}\n        /* c8 ignore next */\n      }, {\n        key: \"visitRepetitionWithSeparator\",\n        value: function visitRepetitionWithSeparator(node) {}\n        /* c8 ignore next */\n      }, {\n        key: \"visitAlternation\",\n        value: function visitAlternation(node) {}\n        /* c8 ignore next */\n      }, {\n        key: \"visitTerminal\",\n        value: function visitTerminal(node) {}\n        /* c8 ignore next */\n      }, {\n        key: \"visitRule\",\n        value: function visitRule(node) {}\n      }]);\n      return GAstVisitor;\n    }();\n    function isSequenceProd(prod) {\n      return prod instanceof Alternative || prod instanceof Option || prod instanceof Repetition || prod instanceof RepetitionMandatory || prod instanceof RepetitionMandatoryWithSeparator || prod instanceof RepetitionWithSeparator || prod instanceof Terminal || prod instanceof Rule;\n    }\n    function isOptionalProd(prod) {\n      var alreadyVisited = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n      var isDirectlyOptional = prod instanceof Option || prod instanceof Repetition || prod instanceof RepetitionWithSeparator;\n      if (isDirectlyOptional) {\n        return true;\n      }\n      if (prod instanceof Alternation) {\n        return some(prod.definition, function (subProd) {\n          return isOptionalProd(subProd, alreadyVisited);\n        });\n      } else if (prod instanceof NonTerminal && includes(alreadyVisited, prod)) {\n        return false;\n      } else if (prod instanceof AbstractProduction) {\n        if (prod instanceof NonTerminal) {\n          alreadyVisited.push(prod);\n        }\n        return every(prod.definition, function (subProd) {\n          return isOptionalProd(subProd, alreadyVisited);\n        });\n      } else {\n        return false;\n      }\n    }\n    function isBranchingProd(prod) {\n      return prod instanceof Alternation;\n    }\n    function getProductionDslName(prod) {\n      if (prod instanceof NonTerminal) {\n        return \"SUBRULE\";\n      } else if (prod instanceof Option) {\n        return \"OPTION\";\n      } else if (prod instanceof Alternation) {\n        return \"OR\";\n      } else if (prod instanceof RepetitionMandatory) {\n        return \"AT_LEAST_ONE\";\n      } else if (prod instanceof RepetitionMandatoryWithSeparator) {\n        return \"AT_LEAST_ONE_SEP\";\n      } else if (prod instanceof RepetitionWithSeparator) {\n        return \"MANY_SEP\";\n      } else if (prod instanceof Repetition) {\n        return \"MANY\";\n      } else if (prod instanceof Terminal) {\n        return \"CONSUME\";\n      } else {\n        throw Error(\"non exhaustive match\");\n      }\n    }\n    var RestWalker = /*#__PURE__*/function () {\n      function RestWalker() {\n        _classCallCheck(this, RestWalker);\n      }\n      _createClass(RestWalker, [{\n        key: \"walk\",\n        value: function walk(prod) {\n          var _this10 = this;\n          var prevRest = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n          forEach(prod.definition, function (subProd, index) {\n            var currRest = drop(prod.definition, index + 1);\n            if (subProd instanceof NonTerminal) {\n              _this10.walkProdRef(subProd, currRest, prevRest);\n            } else if (subProd instanceof Terminal) {\n              _this10.walkTerminal(subProd, currRest, prevRest);\n            } else if (subProd instanceof Alternative) {\n              _this10.walkFlat(subProd, currRest, prevRest);\n            } else if (subProd instanceof Option) {\n              _this10.walkOption(subProd, currRest, prevRest);\n            } else if (subProd instanceof RepetitionMandatory) {\n              _this10.walkAtLeastOne(subProd, currRest, prevRest);\n            } else if (subProd instanceof RepetitionMandatoryWithSeparator) {\n              _this10.walkAtLeastOneSep(subProd, currRest, prevRest);\n            } else if (subProd instanceof RepetitionWithSeparator) {\n              _this10.walkManySep(subProd, currRest, prevRest);\n            } else if (subProd instanceof Repetition) {\n              _this10.walkMany(subProd, currRest, prevRest);\n            } else if (subProd instanceof Alternation) {\n              _this10.walkOr(subProd, currRest, prevRest);\n            } else {\n              throw Error(\"non exhaustive match\");\n            }\n          });\n        }\n      }, {\n        key: \"walkTerminal\",\n        value: function walkTerminal(terminal, currRest, prevRest) {}\n      }, {\n        key: \"walkProdRef\",\n        value: function walkProdRef(refProd, currRest, prevRest) {}\n      }, {\n        key: \"walkFlat\",\n        value: function walkFlat(flatProd, currRest, prevRest) {\n          var fullOrRest = currRest.concat(prevRest);\n          this.walk(flatProd, fullOrRest);\n        }\n      }, {\n        key: \"walkOption\",\n        value: function walkOption(optionProd, currRest, prevRest) {\n          var fullOrRest = currRest.concat(prevRest);\n          this.walk(optionProd, fullOrRest);\n        }\n      }, {\n        key: \"walkAtLeastOne\",\n        value: function walkAtLeastOne(atLeastOneProd, currRest, prevRest) {\n          var fullAtLeastOneRest = [new Option({\n            definition: atLeastOneProd.definition\n          })].concat(currRest, prevRest);\n          this.walk(atLeastOneProd, fullAtLeastOneRest);\n        }\n      }, {\n        key: \"walkAtLeastOneSep\",\n        value: function walkAtLeastOneSep(atLeastOneSepProd, currRest, prevRest) {\n          var fullAtLeastOneSepRest = restForRepetitionWithSeparator(atLeastOneSepProd, currRest, prevRest);\n          this.walk(atLeastOneSepProd, fullAtLeastOneSepRest);\n        }\n      }, {\n        key: \"walkMany\",\n        value: function walkMany(manyProd, currRest, prevRest) {\n          var fullManyRest = [new Option({\n            definition: manyProd.definition\n          })].concat(currRest, prevRest);\n          this.walk(manyProd, fullManyRest);\n        }\n      }, {\n        key: \"walkManySep\",\n        value: function walkManySep(manySepProd, currRest, prevRest) {\n          var fullManySepRest = restForRepetitionWithSeparator(manySepProd, currRest, prevRest);\n          this.walk(manySepProd, fullManySepRest);\n        }\n      }, {\n        key: \"walkOr\",\n        value: function walkOr(orProd, currRest, prevRest) {\n          var _this11 = this;\n          var fullOrRest = currRest.concat(prevRest);\n          forEach(orProd.definition, function (alt) {\n            var prodWrapper = new Alternative({\n              definition: [alt]\n            });\n            _this11.walk(prodWrapper, fullOrRest);\n          });\n        }\n      }]);\n      return RestWalker;\n    }();\n    function restForRepetitionWithSeparator(repSepProd, currRest, prevRest) {\n      var repSepRest = [new Option({\n        definition: [new Terminal({\n          terminalType: repSepProd.separator\n        })].concat(repSepProd.definition)\n      })];\n      var fullRepSepRest = repSepRest.concat(currRest, prevRest);\n      return fullRepSepRest;\n    }\n    function first(prod) {\n      if (prod instanceof NonTerminal) {\n        return first(prod.referencedRule);\n      } else if (prod instanceof Terminal) {\n        return firstForTerminal(prod);\n      } else if (isSequenceProd(prod)) {\n        return firstForSequence(prod);\n      } else if (isBranchingProd(prod)) {\n        return firstForBranching(prod);\n      } else {\n        throw Error(\"non exhaustive match\");\n      }\n    }\n    function firstForSequence(prod) {\n      var firstSet = [];\n      var seq = prod.definition;\n      var nextSubProdIdx = 0;\n      var hasInnerProdsRemaining = seq.length > nextSubProdIdx;\n      var currSubProd;\n      var isLastInnerProdOptional = true;\n      while (hasInnerProdsRemaining && isLastInnerProdOptional) {\n        currSubProd = seq[nextSubProdIdx];\n        isLastInnerProdOptional = isOptionalProd(currSubProd);\n        firstSet = firstSet.concat(first(currSubProd));\n        nextSubProdIdx = nextSubProdIdx + 1;\n        hasInnerProdsRemaining = seq.length > nextSubProdIdx;\n      }\n      return uniq(firstSet);\n    }\n    function firstForBranching(prod) {\n      var allAlternativesFirsts = map(prod.definition, function (innerProd) {\n        return first(innerProd);\n      });\n      return uniq(flatten(allAlternativesFirsts));\n    }\n    function firstForTerminal(terminal) {\n      return [terminal.terminalType];\n    }\n    var IN = \"_~IN~_\";\n    var ResyncFollowsWalker = /*#__PURE__*/function (_RestWalker) {\n      _inherits(ResyncFollowsWalker, _RestWalker);\n      var _super10 = _createSuper(ResyncFollowsWalker);\n      function ResyncFollowsWalker(topProd) {\n        var _this12;\n        _classCallCheck(this, ResyncFollowsWalker);\n        _this12 = _super10.call(this);\n        _this12.topProd = topProd;\n        _this12.follows = {};\n        return _this12;\n      }\n      _createClass(ResyncFollowsWalker, [{\n        key: \"startWalking\",\n        value: function startWalking() {\n          this.walk(this.topProd);\n          return this.follows;\n        }\n      }, {\n        key: \"walkTerminal\",\n        value: function walkTerminal(terminal, currRest, prevRest) {}\n      }, {\n        key: \"walkProdRef\",\n        value: function walkProdRef(refProd, currRest, prevRest) {\n          var followName = buildBetweenProdsFollowPrefix(refProd.referencedRule, refProd.idx) + this.topProd.name;\n          var fullRest = currRest.concat(prevRest);\n          var restProd = new Alternative({\n            definition: fullRest\n          });\n          var t_in_topProd_follows = first(restProd);\n          this.follows[followName] = t_in_topProd_follows;\n        }\n      }]);\n      return ResyncFollowsWalker;\n    }(RestWalker);\n    function computeAllProdsFollows(topProductions) {\n      var reSyncFollows = {};\n      forEach(topProductions, function (topProd) {\n        var currRefsFollow = new ResyncFollowsWalker(topProd).startWalking();\n        assign$1(reSyncFollows, currRefsFollow);\n      });\n      return reSyncFollows;\n    }\n    function buildBetweenProdsFollowPrefix(inner, occurenceInParent) {\n      return inner.name + occurenceInParent + IN;\n    }\n    function cc(char) {\n      return char.charCodeAt(0);\n    }\n    function insertToSet(item, set) {\n      if (Array.isArray(item)) {\n        item.forEach(function (subItem) {\n          set.push(subItem);\n        });\n      } else {\n        set.push(item);\n      }\n    }\n    function addFlag(flagObj, flagKey) {\n      if (flagObj[flagKey] === true) {\n        throw \"duplicate flag \" + flagKey;\n      }\n      flagObj[flagKey];\n      flagObj[flagKey] = true;\n    }\n    function ASSERT_EXISTS(obj) {\n      if (obj === void 0) {\n        throw Error(\"Internal Error - Should never get here!\");\n      }\n      return true;\n    }\n    function ASSERT_NEVER_REACH_HERE() {\n      throw Error(\"Internal Error - Should never get here!\");\n    }\n    function isCharacter(obj) {\n      return obj[\"type\"] === \"Character\";\n    }\n    var digitsCharCodes = [];\n    for (var i = cc(\"0\"); i <= cc(\"9\"); i++) {\n      digitsCharCodes.push(i);\n    }\n    var wordCharCodes = [cc(\"_\")].concat(digitsCharCodes);\n    for (var _i = cc(\"a\"); _i <= cc(\"z\"); _i++) {\n      wordCharCodes.push(_i);\n    }\n    for (var _i2 = cc(\"A\"); _i2 <= cc(\"Z\"); _i2++) {\n      wordCharCodes.push(_i2);\n    }\n    var whitespaceCodes = [cc(\" \"), cc(\"\\f\"), cc(\"\\n\"), cc(\"\\r\"), cc(\"\t\"), cc(\"\\v\"), cc(\"\t\"), cc(\"\"), cc(\"\"), cc(\"\"), cc(\"\"), cc(\"\"), cc(\"\"), cc(\"\"), cc(\"\"), cc(\"\"), cc(\"\"), cc(\"\"), cc(\"\"), cc(\"\"), cc(\"\\u2028\"), cc(\"\\u2029\"), cc(\"\"), cc(\"\"), cc(\"\"), cc(\"\\uFEFF\")];\n    var hexDigitPattern = /[0-9a-fA-F]/;\n    var decimalPattern = /[0-9]/;\n    var decimalPatternNoZero = /[1-9]/;\n    var RegExpParser = /*#__PURE__*/function () {\n      function RegExpParser() {\n        _classCallCheck(this, RegExpParser);\n        this.idx = 0;\n        this.input = \"\";\n        this.groupIdx = 0;\n      }\n      _createClass(RegExpParser, [{\n        key: \"saveState\",\n        value: function saveState() {\n          return {\n            idx: this.idx,\n            input: this.input,\n            groupIdx: this.groupIdx\n          };\n        }\n      }, {\n        key: \"restoreState\",\n        value: function restoreState(newState) {\n          this.idx = newState.idx;\n          this.input = newState.input;\n          this.groupIdx = newState.groupIdx;\n        }\n      }, {\n        key: \"pattern\",\n        value: function pattern(input) {\n          this.idx = 0;\n          this.input = input;\n          this.groupIdx = 0;\n          this.consumeChar(\"/\");\n          var value = this.disjunction();\n          this.consumeChar(\"/\");\n          var flags = {\n            type: \"Flags\",\n            loc: {\n              begin: this.idx,\n              end: input.length\n            },\n            global: false,\n            ignoreCase: false,\n            multiLine: false,\n            unicode: false,\n            sticky: false\n          };\n          while (this.isRegExpFlag()) {\n            switch (this.popChar()) {\n              case \"g\":\n                addFlag(flags, \"global\");\n                break;\n              case \"i\":\n                addFlag(flags, \"ignoreCase\");\n                break;\n              case \"m\":\n                addFlag(flags, \"multiLine\");\n                break;\n              case \"u\":\n                addFlag(flags, \"unicode\");\n                break;\n              case \"y\":\n                addFlag(flags, \"sticky\");\n                break;\n            }\n          }\n          if (this.idx !== this.input.length) {\n            throw Error(\"Redundant input: \" + this.input.substring(this.idx));\n          }\n          return {\n            type: \"Pattern\",\n            flags: flags,\n            value: value,\n            loc: this.loc(0)\n          };\n        }\n      }, {\n        key: \"disjunction\",\n        value: function disjunction() {\n          var alts = [];\n          var begin = this.idx;\n          alts.push(this.alternative());\n          while (this.peekChar() === \"|\") {\n            this.consumeChar(\"|\");\n            alts.push(this.alternative());\n          }\n          return {\n            type: \"Disjunction\",\n            value: alts,\n            loc: this.loc(begin)\n          };\n        }\n      }, {\n        key: \"alternative\",\n        value: function alternative() {\n          var terms = [];\n          var begin = this.idx;\n          while (this.isTerm()) {\n            terms.push(this.term());\n          }\n          return {\n            type: \"Alternative\",\n            value: terms,\n            loc: this.loc(begin)\n          };\n        }\n      }, {\n        key: \"term\",\n        value: function term() {\n          if (this.isAssertion()) {\n            return this.assertion();\n          } else {\n            return this.atom();\n          }\n        }\n      }, {\n        key: \"assertion\",\n        value: function assertion() {\n          var begin = this.idx;\n          switch (this.popChar()) {\n            case \"^\":\n              return {\n                type: \"StartAnchor\",\n                loc: this.loc(begin)\n              };\n            case \"$\":\n              return {\n                type: \"EndAnchor\",\n                loc: this.loc(begin)\n              };\n            case \"\\\\\":\n              switch (this.popChar()) {\n                case \"b\":\n                  return {\n                    type: \"WordBoundary\",\n                    loc: this.loc(begin)\n                  };\n                case \"B\":\n                  return {\n                    type: \"NonWordBoundary\",\n                    loc: this.loc(begin)\n                  };\n              }\n              throw Error(\"Invalid Assertion Escape\");\n            case \"(\":\n              this.consumeChar(\"?\");\n              var type;\n              switch (this.popChar()) {\n                case \"=\":\n                  type = \"Lookahead\";\n                  break;\n                case \"!\":\n                  type = \"NegativeLookahead\";\n                  break;\n              }\n              ASSERT_EXISTS(type);\n              var disjunction = this.disjunction();\n              this.consumeChar(\")\");\n              return {\n                type: type,\n                value: disjunction,\n                loc: this.loc(begin)\n              };\n          }\n          return ASSERT_NEVER_REACH_HERE();\n        }\n      }, {\n        key: \"quantifier\",\n        value: function quantifier() {\n          var isBacktracking = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n          var range = void 0;\n          var begin = this.idx;\n          switch (this.popChar()) {\n            case \"*\":\n              range = {\n                atLeast: 0,\n                atMost: Infinity\n              };\n              break;\n            case \"+\":\n              range = {\n                atLeast: 1,\n                atMost: Infinity\n              };\n              break;\n            case \"?\":\n              range = {\n                atLeast: 0,\n                atMost: 1\n              };\n              break;\n            case \"{\":\n              var atLeast = this.integerIncludingZero();\n              switch (this.popChar()) {\n                case \"}\":\n                  range = {\n                    atLeast: atLeast,\n                    atMost: atLeast\n                  };\n                  break;\n                case \",\":\n                  var atMost;\n                  if (this.isDigit()) {\n                    atMost = this.integerIncludingZero();\n                    range = {\n                      atLeast: atLeast,\n                      atMost: atMost\n                    };\n                  } else {\n                    range = {\n                      atLeast: atLeast,\n                      atMost: Infinity\n                    };\n                  }\n                  this.consumeChar(\"}\");\n                  break;\n              }\n              if (isBacktracking === true && range === void 0) {\n                return void 0;\n              }\n              ASSERT_EXISTS(range);\n              break;\n          }\n          if (isBacktracking === true && range === void 0) {\n            return void 0;\n          }\n          if (ASSERT_EXISTS(range)) {\n            if (this.peekChar(0) === \"?\") {\n              this.consumeChar(\"?\");\n              range.greedy = false;\n            } else {\n              range.greedy = true;\n            }\n            range.type = \"Quantifier\";\n            range.loc = this.loc(begin);\n            return range;\n          }\n        }\n      }, {\n        key: \"atom\",\n        value: function atom() {\n          var atom;\n          var begin = this.idx;\n          switch (this.peekChar()) {\n            case \".\":\n              atom = this.dotAll();\n              break;\n            case \"\\\\\":\n              atom = this.atomEscape();\n              break;\n            case \"[\":\n              atom = this.characterClass();\n              break;\n            case \"(\":\n              atom = this.group();\n              break;\n          }\n          if (atom === void 0 && this.isPatternCharacter()) {\n            atom = this.patternCharacter();\n          }\n          if (ASSERT_EXISTS(atom)) {\n            atom.loc = this.loc(begin);\n            if (this.isQuantifier()) {\n              atom.quantifier = this.quantifier();\n            }\n            return atom;\n          }\n        }\n      }, {\n        key: \"dotAll\",\n        value: function dotAll() {\n          this.consumeChar(\".\");\n          return {\n            type: \"Set\",\n            complement: true,\n            value: [cc(\"\\n\"), cc(\"\\r\"), cc(\"\\u2028\"), cc(\"\\u2029\")]\n          };\n        }\n      }, {\n        key: \"atomEscape\",\n        value: function atomEscape() {\n          this.consumeChar(\"\\\\\");\n          switch (this.peekChar()) {\n            case \"1\":\n            case \"2\":\n            case \"3\":\n            case \"4\":\n            case \"5\":\n            case \"6\":\n            case \"7\":\n            case \"8\":\n            case \"9\":\n              return this.decimalEscapeAtom();\n            case \"d\":\n            case \"D\":\n            case \"s\":\n            case \"S\":\n            case \"w\":\n            case \"W\":\n              return this.characterClassEscape();\n            case \"f\":\n            case \"n\":\n            case \"r\":\n            case \"t\":\n            case \"v\":\n              return this.controlEscapeAtom();\n            case \"c\":\n              return this.controlLetterEscapeAtom();\n            case \"0\":\n              return this.nulCharacterAtom();\n            case \"x\":\n              return this.hexEscapeSequenceAtom();\n            case \"u\":\n              return this.regExpUnicodeEscapeSequenceAtom();\n            default:\n              return this.identityEscapeAtom();\n          }\n        }\n      }, {\n        key: \"decimalEscapeAtom\",\n        value: function decimalEscapeAtom() {\n          var value = this.positiveInteger();\n          return {\n            type: \"GroupBackReference\",\n            value: value\n          };\n        }\n      }, {\n        key: \"characterClassEscape\",\n        value: function characterClassEscape() {\n          var set;\n          var complement = false;\n          switch (this.popChar()) {\n            case \"d\":\n              set = digitsCharCodes;\n              break;\n            case \"D\":\n              set = digitsCharCodes;\n              complement = true;\n              break;\n            case \"s\":\n              set = whitespaceCodes;\n              break;\n            case \"S\":\n              set = whitespaceCodes;\n              complement = true;\n              break;\n            case \"w\":\n              set = wordCharCodes;\n              break;\n            case \"W\":\n              set = wordCharCodes;\n              complement = true;\n              break;\n          }\n          if (ASSERT_EXISTS(set)) {\n            return {\n              type: \"Set\",\n              value: set,\n              complement: complement\n            };\n          }\n        }\n      }, {\n        key: \"controlEscapeAtom\",\n        value: function controlEscapeAtom() {\n          var escapeCode;\n          switch (this.popChar()) {\n            case \"f\":\n              escapeCode = cc(\"\\f\");\n              break;\n            case \"n\":\n              escapeCode = cc(\"\\n\");\n              break;\n            case \"r\":\n              escapeCode = cc(\"\\r\");\n              break;\n            case \"t\":\n              escapeCode = cc(\"\t\");\n              break;\n            case \"v\":\n              escapeCode = cc(\"\\v\");\n              break;\n          }\n          if (ASSERT_EXISTS(escapeCode)) {\n            return {\n              type: \"Character\",\n              value: escapeCode\n            };\n          }\n        }\n      }, {\n        key: \"controlLetterEscapeAtom\",\n        value: function controlLetterEscapeAtom() {\n          this.consumeChar(\"c\");\n          var letter = this.popChar();\n          if (/[a-zA-Z]/.test(letter) === false) {\n            throw Error(\"Invalid \");\n          }\n          var letterCode = letter.toUpperCase().charCodeAt(0) - 64;\n          return {\n            type: \"Character\",\n            value: letterCode\n          };\n        }\n      }, {\n        key: \"nulCharacterAtom\",\n        value: function nulCharacterAtom() {\n          this.consumeChar(\"0\");\n          return {\n            type: \"Character\",\n            value: cc(\"\\0\")\n          };\n        }\n      }, {\n        key: \"hexEscapeSequenceAtom\",\n        value: function hexEscapeSequenceAtom() {\n          this.consumeChar(\"x\");\n          return this.parseHexDigits(2);\n        }\n      }, {\n        key: \"regExpUnicodeEscapeSequenceAtom\",\n        value: function regExpUnicodeEscapeSequenceAtom() {\n          this.consumeChar(\"u\");\n          return this.parseHexDigits(4);\n        }\n      }, {\n        key: \"identityEscapeAtom\",\n        value: function identityEscapeAtom() {\n          var escapedChar = this.popChar();\n          return {\n            type: \"Character\",\n            value: cc(escapedChar)\n          };\n        }\n      }, {\n        key: \"classPatternCharacterAtom\",\n        value: function classPatternCharacterAtom() {\n          switch (this.peekChar()) {\n            case \"\\n\":\n            case \"\\r\":\n            case \"\\u2028\":\n            case \"\\u2029\":\n            case \"\\\\\":\n            case \"]\":\n              throw Error(\"TBD\");\n            default:\n              var nextChar = this.popChar();\n              return {\n                type: \"Character\",\n                value: cc(nextChar)\n              };\n          }\n        }\n      }, {\n        key: \"characterClass\",\n        value: function characterClass() {\n          var set = [];\n          var complement = false;\n          this.consumeChar(\"[\");\n          if (this.peekChar(0) === \"^\") {\n            this.consumeChar(\"^\");\n            complement = true;\n          }\n          while (this.isClassAtom()) {\n            var from = this.classAtom();\n            from.type === \"Character\";\n            if (isCharacter(from) && this.isRangeDash()) {\n              this.consumeChar(\"-\");\n              var to = this.classAtom();\n              to.type === \"Character\";\n              if (isCharacter(to)) {\n                if (to.value < from.value) {\n                  throw Error(\"Range out of order in character class\");\n                }\n                set.push({\n                  from: from.value,\n                  to: to.value\n                });\n              } else {\n                insertToSet(from.value, set);\n                set.push(cc(\"-\"));\n                insertToSet(to.value, set);\n              }\n            } else {\n              insertToSet(from.value, set);\n            }\n          }\n          this.consumeChar(\"]\");\n          return {\n            type: \"Set\",\n            complement: complement,\n            value: set\n          };\n        }\n      }, {\n        key: \"classAtom\",\n        value: function classAtom() {\n          switch (this.peekChar()) {\n            case \"]\":\n            case \"\\n\":\n            case \"\\r\":\n            case \"\\u2028\":\n            case \"\\u2029\":\n              throw Error(\"TBD\");\n            case \"\\\\\":\n              return this.classEscape();\n            default:\n              return this.classPatternCharacterAtom();\n          }\n        }\n      }, {\n        key: \"classEscape\",\n        value: function classEscape() {\n          this.consumeChar(\"\\\\\");\n          switch (this.peekChar()) {\n            case \"b\":\n              this.consumeChar(\"b\");\n              return {\n                type: \"Character\",\n                value: cc(\"\\b\")\n              };\n            case \"d\":\n            case \"D\":\n            case \"s\":\n            case \"S\":\n            case \"w\":\n            case \"W\":\n              return this.characterClassEscape();\n            case \"f\":\n            case \"n\":\n            case \"r\":\n            case \"t\":\n            case \"v\":\n              return this.controlEscapeAtom();\n            case \"c\":\n              return this.controlLetterEscapeAtom();\n            case \"0\":\n              return this.nulCharacterAtom();\n            case \"x\":\n              return this.hexEscapeSequenceAtom();\n            case \"u\":\n              return this.regExpUnicodeEscapeSequenceAtom();\n            default:\n              return this.identityEscapeAtom();\n          }\n        }\n      }, {\n        key: \"group\",\n        value: function group() {\n          var capturing = true;\n          this.consumeChar(\"(\");\n          switch (this.peekChar(0)) {\n            case \"?\":\n              this.consumeChar(\"?\");\n              this.consumeChar(\":\");\n              capturing = false;\n              break;\n            default:\n              this.groupIdx++;\n              break;\n          }\n          var value = this.disjunction();\n          this.consumeChar(\")\");\n          var groupAst = {\n            type: \"Group\",\n            capturing: capturing,\n            value: value\n          };\n          if (capturing) {\n            groupAst[\"idx\"] = this.groupIdx;\n          }\n          return groupAst;\n        }\n      }, {\n        key: \"positiveInteger\",\n        value: function positiveInteger() {\n          var number = this.popChar();\n          if (decimalPatternNoZero.test(number) === false) {\n            throw Error(\"Expecting a positive integer\");\n          }\n          while (decimalPattern.test(this.peekChar(0))) {\n            number += this.popChar();\n          }\n          return parseInt(number, 10);\n        }\n      }, {\n        key: \"integerIncludingZero\",\n        value: function integerIncludingZero() {\n          var number = this.popChar();\n          if (decimalPattern.test(number) === false) {\n            throw Error(\"Expecting an integer\");\n          }\n          while (decimalPattern.test(this.peekChar(0))) {\n            number += this.popChar();\n          }\n          return parseInt(number, 10);\n        }\n      }, {\n        key: \"patternCharacter\",\n        value: function patternCharacter() {\n          var nextChar = this.popChar();\n          switch (nextChar) {\n            case \"\\n\":\n            case \"\\r\":\n            case \"\\u2028\":\n            case \"\\u2029\":\n            case \"^\":\n            case \"$\":\n            case \"\\\\\":\n            case \".\":\n            case \"*\":\n            case \"+\":\n            case \"?\":\n            case \"(\":\n            case \")\":\n            case \"[\":\n            case \"|\":\n              throw Error(\"TBD\");\n            default:\n              return {\n                type: \"Character\",\n                value: cc(nextChar)\n              };\n          }\n        }\n      }, {\n        key: \"isRegExpFlag\",\n        value: function isRegExpFlag() {\n          switch (this.peekChar(0)) {\n            case \"g\":\n            case \"i\":\n            case \"m\":\n            case \"u\":\n            case \"y\":\n              return true;\n            default:\n              return false;\n          }\n        }\n      }, {\n        key: \"isRangeDash\",\n        value: function isRangeDash() {\n          return this.peekChar() === \"-\" && this.isClassAtom(1);\n        }\n      }, {\n        key: \"isDigit\",\n        value: function isDigit() {\n          return decimalPattern.test(this.peekChar(0));\n        }\n      }, {\n        key: \"isClassAtom\",\n        value: function isClassAtom() {\n          var howMuch = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n          switch (this.peekChar(howMuch)) {\n            case \"]\":\n            case \"\\n\":\n            case \"\\r\":\n            case \"\\u2028\":\n            case \"\\u2029\":\n              return false;\n            default:\n              return true;\n          }\n        }\n      }, {\n        key: \"isTerm\",\n        value: function isTerm() {\n          return this.isAtom() || this.isAssertion();\n        }\n      }, {\n        key: \"isAtom\",\n        value: function isAtom() {\n          if (this.isPatternCharacter()) {\n            return true;\n          }\n          switch (this.peekChar(0)) {\n            case \".\":\n            case \"\\\\\":\n            case \"[\":\n            case \"(\":\n              return true;\n            default:\n              return false;\n          }\n        }\n      }, {\n        key: \"isAssertion\",\n        value: function isAssertion() {\n          switch (this.peekChar(0)) {\n            case \"^\":\n            case \"$\":\n              return true;\n            case \"\\\\\":\n              switch (this.peekChar(1)) {\n                case \"b\":\n                case \"B\":\n                  return true;\n                default:\n                  return false;\n              }\n            case \"(\":\n              return this.peekChar(1) === \"?\" && (this.peekChar(2) === \"=\" || this.peekChar(2) === \"!\");\n            default:\n              return false;\n          }\n        }\n      }, {\n        key: \"isQuantifier\",\n        value: function isQuantifier() {\n          var prevState = this.saveState();\n          try {\n            return this.quantifier(true) !== void 0;\n          } catch (e) {\n            return false;\n          } finally {\n            this.restoreState(prevState);\n          }\n        }\n      }, {\n        key: \"isPatternCharacter\",\n        value: function isPatternCharacter() {\n          switch (this.peekChar()) {\n            case \"^\":\n            case \"$\":\n            case \"\\\\\":\n            case \".\":\n            case \"*\":\n            case \"+\":\n            case \"?\":\n            case \"(\":\n            case \")\":\n            case \"[\":\n            case \"|\":\n            case \"/\":\n            case \"\\n\":\n            case \"\\r\":\n            case \"\\u2028\":\n            case \"\\u2029\":\n              return false;\n            default:\n              return true;\n          }\n        }\n      }, {\n        key: \"parseHexDigits\",\n        value: function parseHexDigits(howMany) {\n          var hexString = \"\";\n          for (var _i3 = 0; _i3 < howMany; _i3++) {\n            var hexChar = this.popChar();\n            if (hexDigitPattern.test(hexChar) === false) {\n              throw Error(\"Expecting a HexDecimal digits\");\n            }\n            hexString += hexChar;\n          }\n          var charCode = parseInt(hexString, 16);\n          return {\n            type: \"Character\",\n            value: charCode\n          };\n        }\n      }, {\n        key: \"peekChar\",\n        value: function peekChar() {\n          var howMuch = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n          return this.input[this.idx + howMuch];\n        }\n      }, {\n        key: \"popChar\",\n        value: function popChar() {\n          var nextChar = this.peekChar(0);\n          this.consumeChar(void 0);\n          return nextChar;\n        }\n      }, {\n        key: \"consumeChar\",\n        value: function consumeChar(char) {\n          if (char !== void 0 && this.input[this.idx] !== char) {\n            throw Error(\"Expected: '\" + char + \"' but found: '\" + this.input[this.idx] + \"' at offset: \" + this.idx);\n          }\n          if (this.idx >= this.input.length) {\n            throw Error(\"Unexpected end of input\");\n          }\n          this.idx++;\n        }\n      }, {\n        key: \"loc\",\n        value: function loc(begin) {\n          return {\n            begin: begin,\n            end: this.idx\n          };\n        }\n      }]);\n      return RegExpParser;\n    }();\n    var BaseRegExpVisitor = /*#__PURE__*/function () {\n      function BaseRegExpVisitor() {\n        _classCallCheck(this, BaseRegExpVisitor);\n      }\n      _createClass(BaseRegExpVisitor, [{\n        key: \"visitChildren\",\n        value: function visitChildren(node) {\n          var _this13 = this;\n          for (var key in node) {\n            var child = node[key];\n            if (node.hasOwnProperty(key)) {\n              if (child.type !== void 0) {\n                this.visit(child);\n              } else if (Array.isArray(child)) {\n                child.forEach(function (subChild) {\n                  _this13.visit(subChild);\n                }, this);\n              }\n            }\n          }\n        }\n      }, {\n        key: \"visit\",\n        value: function visit(node) {\n          switch (node.type) {\n            case \"Pattern\":\n              this.visitPattern(node);\n              break;\n            case \"Flags\":\n              this.visitFlags(node);\n              break;\n            case \"Disjunction\":\n              this.visitDisjunction(node);\n              break;\n            case \"Alternative\":\n              this.visitAlternative(node);\n              break;\n            case \"StartAnchor\":\n              this.visitStartAnchor(node);\n              break;\n            case \"EndAnchor\":\n              this.visitEndAnchor(node);\n              break;\n            case \"WordBoundary\":\n              this.visitWordBoundary(node);\n              break;\n            case \"NonWordBoundary\":\n              this.visitNonWordBoundary(node);\n              break;\n            case \"Lookahead\":\n              this.visitLookahead(node);\n              break;\n            case \"NegativeLookahead\":\n              this.visitNegativeLookahead(node);\n              break;\n            case \"Character\":\n              this.visitCharacter(node);\n              break;\n            case \"Set\":\n              this.visitSet(node);\n              break;\n            case \"Group\":\n              this.visitGroup(node);\n              break;\n            case \"GroupBackReference\":\n              this.visitGroupBackReference(node);\n              break;\n            case \"Quantifier\":\n              this.visitQuantifier(node);\n              break;\n          }\n          this.visitChildren(node);\n        }\n      }, {\n        key: \"visitPattern\",\n        value: function visitPattern(node) {}\n      }, {\n        key: \"visitFlags\",\n        value: function visitFlags(node) {}\n      }, {\n        key: \"visitDisjunction\",\n        value: function visitDisjunction(node) {}\n      }, {\n        key: \"visitAlternative\",\n        value: function visitAlternative(node) {}\n        // Assertion\n      }, {\n        key: \"visitStartAnchor\",\n        value: function visitStartAnchor(node) {}\n      }, {\n        key: \"visitEndAnchor\",\n        value: function visitEndAnchor(node) {}\n      }, {\n        key: \"visitWordBoundary\",\n        value: function visitWordBoundary(node) {}\n      }, {\n        key: \"visitNonWordBoundary\",\n        value: function visitNonWordBoundary(node) {}\n      }, {\n        key: \"visitLookahead\",\n        value: function visitLookahead(node) {}\n      }, {\n        key: \"visitNegativeLookahead\",\n        value: function visitNegativeLookahead(node) {}\n        // atoms\n      }, {\n        key: \"visitCharacter\",\n        value: function visitCharacter(node) {}\n      }, {\n        key: \"visitSet\",\n        value: function visitSet(node) {}\n      }, {\n        key: \"visitGroup\",\n        value: function visitGroup(node) {}\n      }, {\n        key: \"visitGroupBackReference\",\n        value: function visitGroupBackReference(node) {}\n      }, {\n        key: \"visitQuantifier\",\n        value: function visitQuantifier(node) {}\n      }]);\n      return BaseRegExpVisitor;\n    }();\n    var regExpAstCache = {};\n    var regExpParser = new RegExpParser();\n    function getRegExpAst(regExp) {\n      var regExpStr = regExp.toString();\n      if (regExpAstCache.hasOwnProperty(regExpStr)) {\n        return regExpAstCache[regExpStr];\n      } else {\n        var regExpAst = regExpParser.pattern(regExpStr);\n        regExpAstCache[regExpStr] = regExpAst;\n        return regExpAst;\n      }\n    }\n    function clearRegExpParserCache() {\n      regExpAstCache = {};\n    }\n    var complementErrorMessage = \"Complement Sets are not supported for first char optimization\";\n    var failedOptimizationPrefixMsg = 'Unable to use \"first char\" lexer optimizations:\\n';\n    function getOptimizedStartCodesIndices(regExp) {\n      var ensureOptimizations = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      try {\n        var ast = getRegExpAst(regExp);\n        var firstChars = firstCharOptimizedIndices(ast.value, {}, ast.flags.ignoreCase);\n        return firstChars;\n      } catch (e) {\n        if (e.message === complementErrorMessage) {\n          if (ensureOptimizations) {\n            PRINT_WARNING(\"\".concat(failedOptimizationPrefixMsg, \"\\tUnable to optimize: < \").concat(regExp.toString(), \" >\\n\\tComplement Sets cannot be automatically optimized.\\n\\tThis will disable the lexer's first char optimizations.\\n\\tSee: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#COMPLEMENT for details.\"));\n          }\n        } else {\n          var msgSuffix = \"\";\n          if (ensureOptimizations) {\n            msgSuffix = \"\\n\tThis will disable the lexer's first char optimizations.\\n\tSee: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#REGEXP_PARSING for details.\";\n          }\n          PRINT_ERROR(\"\".concat(failedOptimizationPrefixMsg, \"\\n\\tFailed parsing: < \").concat(regExp.toString(), \" >\\n\\tUsing the @chevrotain/regexp-to-ast library\\n\\tPlease open an issue at: https://github.com/chevrotain/chevrotain/issues\") + msgSuffix);\n        }\n      }\n      return [];\n    }\n    function firstCharOptimizedIndices(ast, result, ignoreCase) {\n      switch (ast.type) {\n        case \"Disjunction\":\n          for (var _i4 = 0; _i4 < ast.value.length; _i4++) {\n            firstCharOptimizedIndices(ast.value[_i4], result, ignoreCase);\n          }\n          break;\n        case \"Alternative\":\n          var terms = ast.value;\n          for (var _i5 = 0; _i5 < terms.length; _i5++) {\n            var term = terms[_i5];\n            switch (term.type) {\n              case \"EndAnchor\":\n              case \"GroupBackReference\":\n              case \"Lookahead\":\n              case \"NegativeLookahead\":\n              case \"StartAnchor\":\n              case \"WordBoundary\":\n              case \"NonWordBoundary\":\n                continue;\n            }\n            var atom = term;\n            switch (atom.type) {\n              case \"Character\":\n                addOptimizedIdxToResult(atom.value, result, ignoreCase);\n                break;\n              case \"Set\":\n                if (atom.complement === true) {\n                  throw Error(complementErrorMessage);\n                }\n                forEach(atom.value, function (code) {\n                  if (typeof code === \"number\") {\n                    addOptimizedIdxToResult(code, result, ignoreCase);\n                  } else {\n                    var range = code;\n                    if (ignoreCase === true) {\n                      for (var rangeCode = range.from; rangeCode <= range.to; rangeCode++) {\n                        addOptimizedIdxToResult(rangeCode, result, ignoreCase);\n                      }\n                    } else {\n                      for (var _rangeCode = range.from; _rangeCode <= range.to && _rangeCode < minOptimizationVal; _rangeCode++) {\n                        addOptimizedIdxToResult(_rangeCode, result, ignoreCase);\n                      }\n                      if (range.to >= minOptimizationVal) {\n                        var minUnOptVal = range.from >= minOptimizationVal ? range.from : minOptimizationVal;\n                        var maxUnOptVal = range.to;\n                        var minOptIdx = charCodeToOptimizedIndex(minUnOptVal);\n                        var maxOptIdx = charCodeToOptimizedIndex(maxUnOptVal);\n                        for (var currOptIdx = minOptIdx; currOptIdx <= maxOptIdx; currOptIdx++) {\n                          result[currOptIdx] = currOptIdx;\n                        }\n                      }\n                    }\n                  }\n                });\n                break;\n              case \"Group\":\n                firstCharOptimizedIndices(atom.value, result, ignoreCase);\n                break;\n              default:\n                throw Error(\"Non Exhaustive Match\");\n            }\n            var isOptionalQuantifier = atom.quantifier !== void 0 && atom.quantifier.atLeast === 0;\n            if (\n            // A group may be optional due to empty contents /(?:)/\n            // or if everything inside it is optional /((a)?)/\n            atom.type === \"Group\" && isWholeOptional(atom) === false ||\n            // If this term is not a group it may only be optional if it has an optional quantifier\n            atom.type !== \"Group\" && isOptionalQuantifier === false) {\n              break;\n            }\n          }\n          break;\n        default:\n          throw Error(\"non exhaustive match!\");\n      }\n      return values(result);\n    }\n    function addOptimizedIdxToResult(code, result, ignoreCase) {\n      var optimizedCharIdx = charCodeToOptimizedIndex(code);\n      result[optimizedCharIdx] = optimizedCharIdx;\n      if (ignoreCase === true) {\n        handleIgnoreCase(code, result);\n      }\n    }\n    function handleIgnoreCase(code, result) {\n      var char = String.fromCharCode(code);\n      var upperChar = char.toUpperCase();\n      if (upperChar !== char) {\n        var optimizedCharIdx = charCodeToOptimizedIndex(upperChar.charCodeAt(0));\n        result[optimizedCharIdx] = optimizedCharIdx;\n      } else {\n        var lowerChar = char.toLowerCase();\n        if (lowerChar !== char) {\n          var _optimizedCharIdx = charCodeToOptimizedIndex(lowerChar.charCodeAt(0));\n          result[_optimizedCharIdx] = _optimizedCharIdx;\n        }\n      }\n    }\n    function findCode(setNode, targetCharCodes) {\n      return find$1(setNode.value, function (codeOrRange) {\n        if (typeof codeOrRange === \"number\") {\n          return includes(targetCharCodes, codeOrRange);\n        } else {\n          var range = codeOrRange;\n          return find$1(targetCharCodes, function (targetCode) {\n            return range.from <= targetCode && targetCode <= range.to;\n          }) !== void 0;\n        }\n      });\n    }\n    function isWholeOptional(ast) {\n      var quantifier = ast.quantifier;\n      if (quantifier && quantifier.atLeast === 0) {\n        return true;\n      }\n      if (!ast.value) {\n        return false;\n      }\n      return isArray$1(ast.value) ? every(ast.value, isWholeOptional) : isWholeOptional(ast.value);\n    }\n    var CharCodeFinder = /*#__PURE__*/function (_BaseRegExpVisitor) {\n      _inherits(CharCodeFinder, _BaseRegExpVisitor);\n      var _super11 = _createSuper(CharCodeFinder);\n      function CharCodeFinder(targetCharCodes) {\n        var _this14;\n        _classCallCheck(this, CharCodeFinder);\n        _this14 = _super11.call(this);\n        _this14.targetCharCodes = targetCharCodes;\n        _this14.found = false;\n        return _this14;\n      }\n      _createClass(CharCodeFinder, [{\n        key: \"visitChildren\",\n        value: function visitChildren(node) {\n          if (this.found === true) {\n            return;\n          }\n          switch (node.type) {\n            case \"Lookahead\":\n              this.visitLookahead(node);\n              return;\n            case \"NegativeLookahead\":\n              this.visitNegativeLookahead(node);\n              return;\n          }\n          _get(_getPrototypeOf(CharCodeFinder.prototype), \"visitChildren\", this).call(this, node);\n        }\n      }, {\n        key: \"visitCharacter\",\n        value: function visitCharacter(node) {\n          if (includes(this.targetCharCodes, node.value)) {\n            this.found = true;\n          }\n        }\n      }, {\n        key: \"visitSet\",\n        value: function visitSet(node) {\n          if (node.complement) {\n            if (findCode(node, this.targetCharCodes) === void 0) {\n              this.found = true;\n            }\n          } else {\n            if (findCode(node, this.targetCharCodes) !== void 0) {\n              this.found = true;\n            }\n          }\n        }\n      }]);\n      return CharCodeFinder;\n    }(BaseRegExpVisitor);\n    function canMatchCharCode(charCodes, pattern) {\n      if (pattern instanceof RegExp) {\n        var ast = getRegExpAst(pattern);\n        var charCodeFinder = new CharCodeFinder(charCodes);\n        charCodeFinder.visit(ast);\n        return charCodeFinder.found;\n      } else {\n        return find$1(pattern, function (char) {\n          return includes(charCodes, char.charCodeAt(0));\n        }) !== void 0;\n      }\n    }\n    var PATTERN = \"PATTERN\";\n    var DEFAULT_MODE = \"defaultMode\";\n    var MODES = \"modes\";\n    var SUPPORT_STICKY = typeof new RegExp(\"(?:)\").sticky === \"boolean\";\n    function analyzeTokenTypes(tokenTypes, options) {\n      options = defaults$1(options, {\n        useSticky: SUPPORT_STICKY,\n        debug: false,\n        safeMode: false,\n        positionTracking: \"full\",\n        lineTerminatorCharacters: [\"\\r\", \"\\n\"],\n        tracer: function tracer(msg, action) {\n          return action();\n        }\n      });\n      var tracer = options.tracer;\n      tracer(\"initCharCodeToOptimizedIndexMap\", function () {\n        initCharCodeToOptimizedIndexMap();\n      });\n      var onlyRelevantTypes;\n      tracer(\"Reject Lexer.NA\", function () {\n        onlyRelevantTypes = reject(tokenTypes, function (currType) {\n          return currType[PATTERN] === Lexer2.NA;\n        });\n      });\n      var hasCustom = false;\n      var allTransformedPatterns;\n      tracer(\"Transform Patterns\", function () {\n        hasCustom = false;\n        allTransformedPatterns = map(onlyRelevantTypes, function (currType) {\n          var currPattern = currType[PATTERN];\n          if (isRegExp$1(currPattern)) {\n            var regExpSource = currPattern.source;\n            if (regExpSource.length === 1 &&\n            // only these regExp meta characters which can appear in a length one regExp\n            regExpSource !== \"^\" && regExpSource !== \"$\" && regExpSource !== \".\" && !currPattern.ignoreCase) {\n              return regExpSource;\n            } else if (regExpSource.length === 2 && regExpSource[0] === \"\\\\\" &&\n            // not a meta character\n            !includes([\"d\", \"D\", \"s\", \"S\", \"t\", \"r\", \"n\", \"t\", \"0\", \"c\", \"b\", \"B\", \"f\", \"v\", \"w\", \"W\"], regExpSource[1])) {\n              return regExpSource[1];\n            } else {\n              return options.useSticky ? addStickyFlag(currPattern) : addStartOfInput(currPattern);\n            }\n          } else if (isFunction(currPattern)) {\n            hasCustom = true;\n            return {\n              exec: currPattern\n            };\n          } else if (typeof currPattern === \"object\") {\n            hasCustom = true;\n            return currPattern;\n          } else if (typeof currPattern === \"string\") {\n            if (currPattern.length === 1) {\n              return currPattern;\n            } else {\n              var escapedRegExpString = currPattern.replace(/[\\\\^$.*+?()[\\]{}|]/g, \"\\\\$&\");\n              var wrappedRegExp = new RegExp(escapedRegExpString);\n              return options.useSticky ? addStickyFlag(wrappedRegExp) : addStartOfInput(wrappedRegExp);\n            }\n          } else {\n            throw Error(\"non exhaustive match\");\n          }\n        });\n      });\n      var patternIdxToType;\n      var patternIdxToGroup;\n      var patternIdxToLongerAltIdxArr;\n      var patternIdxToPushMode;\n      var patternIdxToPopMode;\n      tracer(\"misc mapping\", function () {\n        patternIdxToType = map(onlyRelevantTypes, function (currType) {\n          return currType.tokenTypeIdx;\n        });\n        patternIdxToGroup = map(onlyRelevantTypes, function (clazz) {\n          var groupName = clazz.GROUP;\n          if (groupName === Lexer2.SKIPPED) {\n            return void 0;\n          } else if (isString(groupName)) {\n            return groupName;\n          } else if (isUndefined(groupName)) {\n            return false;\n          } else {\n            throw Error(\"non exhaustive match\");\n          }\n        });\n        patternIdxToLongerAltIdxArr = map(onlyRelevantTypes, function (clazz) {\n          var longerAltType = clazz.LONGER_ALT;\n          if (longerAltType) {\n            var longerAltIdxArr = isArray$1(longerAltType) ? map(longerAltType, function (type) {\n              return indexOf(onlyRelevantTypes, type);\n            }) : [indexOf(onlyRelevantTypes, longerAltType)];\n            return longerAltIdxArr;\n          }\n        });\n        patternIdxToPushMode = map(onlyRelevantTypes, function (clazz) {\n          return clazz.PUSH_MODE;\n        });\n        patternIdxToPopMode = map(onlyRelevantTypes, function (clazz) {\n          return has(clazz, \"POP_MODE\");\n        });\n      });\n      var patternIdxToCanLineTerminator;\n      tracer(\"Line Terminator Handling\", function () {\n        var lineTerminatorCharCodes = getCharCodes(options.lineTerminatorCharacters);\n        patternIdxToCanLineTerminator = map(onlyRelevantTypes, function (tokType) {\n          return false;\n        });\n        if (options.positionTracking !== \"onlyOffset\") {\n          patternIdxToCanLineTerminator = map(onlyRelevantTypes, function (tokType) {\n            if (has(tokType, \"LINE_BREAKS\")) {\n              return !!tokType.LINE_BREAKS;\n            } else {\n              return checkLineBreaksIssues(tokType, lineTerminatorCharCodes) === false && canMatchCharCode(lineTerminatorCharCodes, tokType.PATTERN);\n            }\n          });\n        }\n      });\n      var patternIdxToIsCustom;\n      var patternIdxToShort;\n      var emptyGroups;\n      var patternIdxToConfig;\n      tracer(\"Misc Mapping #2\", function () {\n        patternIdxToIsCustom = map(onlyRelevantTypes, isCustomPattern);\n        patternIdxToShort = map(allTransformedPatterns, isShortPattern);\n        emptyGroups = reduce(onlyRelevantTypes, function (acc, clazz) {\n          var groupName = clazz.GROUP;\n          if (isString(groupName) && !(groupName === Lexer2.SKIPPED)) {\n            acc[groupName] = [];\n          }\n          return acc;\n        }, {});\n        patternIdxToConfig = map(allTransformedPatterns, function (x, idx) {\n          return {\n            pattern: allTransformedPatterns[idx],\n            longerAlt: patternIdxToLongerAltIdxArr[idx],\n            canLineTerminator: patternIdxToCanLineTerminator[idx],\n            isCustom: patternIdxToIsCustom[idx],\n            short: patternIdxToShort[idx],\n            group: patternIdxToGroup[idx],\n            push: patternIdxToPushMode[idx],\n            pop: patternIdxToPopMode[idx],\n            tokenTypeIdx: patternIdxToType[idx],\n            tokenType: onlyRelevantTypes[idx]\n          };\n        });\n      });\n      var canBeOptimized = true;\n      var charCodeToPatternIdxToConfig = [];\n      if (!options.safeMode) {\n        tracer(\"First Char Optimization\", function () {\n          charCodeToPatternIdxToConfig = reduce(onlyRelevantTypes, function (result, currTokType, idx) {\n            if (typeof currTokType.PATTERN === \"string\") {\n              var charCode = currTokType.PATTERN.charCodeAt(0);\n              var optimizedIdx = charCodeToOptimizedIndex(charCode);\n              addToMapOfArrays(result, optimizedIdx, patternIdxToConfig[idx]);\n            } else if (isArray$1(currTokType.START_CHARS_HINT)) {\n              var lastOptimizedIdx;\n              forEach(currTokType.START_CHARS_HINT, function (charOrInt) {\n                var charCode = typeof charOrInt === \"string\" ? charOrInt.charCodeAt(0) : charOrInt;\n                var currOptimizedIdx = charCodeToOptimizedIndex(charCode);\n                if (lastOptimizedIdx !== currOptimizedIdx) {\n                  lastOptimizedIdx = currOptimizedIdx;\n                  addToMapOfArrays(result, currOptimizedIdx, patternIdxToConfig[idx]);\n                }\n              });\n            } else if (isRegExp$1(currTokType.PATTERN)) {\n              if (currTokType.PATTERN.unicode) {\n                canBeOptimized = false;\n                if (options.ensureOptimizations) {\n                  PRINT_ERROR(\"\".concat(failedOptimizationPrefixMsg, \"\\tUnable to analyze < \").concat(currTokType.PATTERN.toString(), \" > pattern.\\n\\tThe regexp unicode flag is not currently supported by the regexp-to-ast library.\\n\\tThis will disable the lexer's first char optimizations.\\n\\tFor details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#UNICODE_OPTIMIZE\"));\n                }\n              } else {\n                var optimizedCodes = getOptimizedStartCodesIndices(currTokType.PATTERN, options.ensureOptimizations);\n                if (isEmpty(optimizedCodes)) {\n                  canBeOptimized = false;\n                }\n                forEach(optimizedCodes, function (code) {\n                  addToMapOfArrays(result, code, patternIdxToConfig[idx]);\n                });\n              }\n            } else {\n              if (options.ensureOptimizations) {\n                PRINT_ERROR(\"\".concat(failedOptimizationPrefixMsg, \"\\tTokenType: <\").concat(currTokType.name, \"> is using a custom token pattern without providing <start_chars_hint> parameter.\\n\\tThis will disable the lexer's first char optimizations.\\n\\tFor details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#CUSTOM_OPTIMIZE\"));\n              }\n              canBeOptimized = false;\n            }\n            return result;\n          }, []);\n        });\n      }\n      return {\n        emptyGroups: emptyGroups,\n        patternIdxToConfig: patternIdxToConfig,\n        charCodeToPatternIdxToConfig: charCodeToPatternIdxToConfig,\n        hasCustom: hasCustom,\n        canBeOptimized: canBeOptimized\n      };\n    }\n    function validatePatterns(tokenTypes, validModesNames) {\n      var errors = [];\n      var missingResult = findMissingPatterns(tokenTypes);\n      errors = errors.concat(missingResult.errors);\n      var invalidResult = findInvalidPatterns(missingResult.valid);\n      var validTokenTypes = invalidResult.valid;\n      errors = errors.concat(invalidResult.errors);\n      errors = errors.concat(validateRegExpPattern(validTokenTypes));\n      errors = errors.concat(findInvalidGroupType(validTokenTypes));\n      errors = errors.concat(findModesThatDoNotExist(validTokenTypes, validModesNames));\n      errors = errors.concat(findUnreachablePatterns(validTokenTypes));\n      return errors;\n    }\n    function validateRegExpPattern(tokenTypes) {\n      var errors = [];\n      var withRegExpPatterns = filter(tokenTypes, function (currTokType) {\n        return isRegExp$1(currTokType[PATTERN]);\n      });\n      errors = errors.concat(findEndOfInputAnchor(withRegExpPatterns));\n      errors = errors.concat(findStartOfInputAnchor(withRegExpPatterns));\n      errors = errors.concat(findUnsupportedFlags(withRegExpPatterns));\n      errors = errors.concat(findDuplicatePatterns(withRegExpPatterns));\n      errors = errors.concat(findEmptyMatchRegExps(withRegExpPatterns));\n      return errors;\n    }\n    function findMissingPatterns(tokenTypes) {\n      var tokenTypesWithMissingPattern = filter(tokenTypes, function (currType) {\n        return !has(currType, PATTERN);\n      });\n      var errors = map(tokenTypesWithMissingPattern, function (currType) {\n        return {\n          message: \"Token Type: ->\" + currType.name + \"<- missing static 'PATTERN' property\",\n          type: LexerDefinitionErrorType.MISSING_PATTERN,\n          tokenTypes: [currType]\n        };\n      });\n      var valid = difference$1(tokenTypes, tokenTypesWithMissingPattern);\n      return {\n        errors: errors,\n        valid: valid\n      };\n    }\n    function findInvalidPatterns(tokenTypes) {\n      var tokenTypesWithInvalidPattern = filter(tokenTypes, function (currType) {\n        var pattern = currType[PATTERN];\n        return !isRegExp$1(pattern) && !isFunction(pattern) && !has(pattern, \"exec\") && !isString(pattern);\n      });\n      var errors = map(tokenTypesWithInvalidPattern, function (currType) {\n        return {\n          message: \"Token Type: ->\" + currType.name + \"<- static 'PATTERN' can only be a RegExp, a Function matching the {CustomPatternMatcherFunc} type or an Object matching the {ICustomPattern} interface.\",\n          type: LexerDefinitionErrorType.INVALID_PATTERN,\n          tokenTypes: [currType]\n        };\n      });\n      var valid = difference$1(tokenTypes, tokenTypesWithInvalidPattern);\n      return {\n        errors: errors,\n        valid: valid\n      };\n    }\n    var end_of_input = /[^\\\\][$]/;\n    function findEndOfInputAnchor(tokenTypes) {\n      var EndAnchorFinder = /*#__PURE__*/function (_BaseRegExpVisitor2) {\n        _inherits(EndAnchorFinder, _BaseRegExpVisitor2);\n        var _super12 = _createSuper(EndAnchorFinder);\n        function EndAnchorFinder() {\n          var _this15;\n          _classCallCheck(this, EndAnchorFinder);\n          _this15 = _super12.apply(this, arguments);\n          _this15.found = false;\n          return _this15;\n        }\n        _createClass(EndAnchorFinder, [{\n          key: \"visitEndAnchor\",\n          value: function visitEndAnchor(node) {\n            this.found = true;\n          }\n        }]);\n        return EndAnchorFinder;\n      }(BaseRegExpVisitor);\n      var invalidRegex = filter(tokenTypes, function (currType) {\n        var pattern = currType.PATTERN;\n        try {\n          var regexpAst = getRegExpAst(pattern);\n          var endAnchorVisitor = new EndAnchorFinder();\n          endAnchorVisitor.visit(regexpAst);\n          return endAnchorVisitor.found;\n        } catch (e) {\n          return end_of_input.test(pattern.source);\n        }\n      });\n      var errors = map(invalidRegex, function (currType) {\n        return {\n          message: \"Unexpected RegExp Anchor Error:\\n\tToken Type: ->\" + currType.name + \"<- static 'PATTERN' cannot contain end of input anchor '$'\\n\tSee chevrotain.io/docs/guide/resolving_lexer_errors.html#ANCHORS\tfor details.\",\n          type: LexerDefinitionErrorType.EOI_ANCHOR_FOUND,\n          tokenTypes: [currType]\n        };\n      });\n      return errors;\n    }\n    function findEmptyMatchRegExps(tokenTypes) {\n      var matchesEmptyString = filter(tokenTypes, function (currType) {\n        var pattern = currType.PATTERN;\n        return pattern.test(\"\");\n      });\n      var errors = map(matchesEmptyString, function (currType) {\n        return {\n          message: \"Token Type: ->\" + currType.name + \"<- static 'PATTERN' must not match an empty string\",\n          type: LexerDefinitionErrorType.EMPTY_MATCH_PATTERN,\n          tokenTypes: [currType]\n        };\n      });\n      return errors;\n    }\n    var start_of_input = /[^\\\\[][\\^]|^\\^/;\n    function findStartOfInputAnchor(tokenTypes) {\n      var StartAnchorFinder = /*#__PURE__*/function (_BaseRegExpVisitor3) {\n        _inherits(StartAnchorFinder, _BaseRegExpVisitor3);\n        var _super13 = _createSuper(StartAnchorFinder);\n        function StartAnchorFinder() {\n          var _this16;\n          _classCallCheck(this, StartAnchorFinder);\n          _this16 = _super13.apply(this, arguments);\n          _this16.found = false;\n          return _this16;\n        }\n        _createClass(StartAnchorFinder, [{\n          key: \"visitStartAnchor\",\n          value: function visitStartAnchor(node) {\n            this.found = true;\n          }\n        }]);\n        return StartAnchorFinder;\n      }(BaseRegExpVisitor);\n      var invalidRegex = filter(tokenTypes, function (currType) {\n        var pattern = currType.PATTERN;\n        try {\n          var regexpAst = getRegExpAst(pattern);\n          var startAnchorVisitor = new StartAnchorFinder();\n          startAnchorVisitor.visit(regexpAst);\n          return startAnchorVisitor.found;\n        } catch (e) {\n          return start_of_input.test(pattern.source);\n        }\n      });\n      var errors = map(invalidRegex, function (currType) {\n        return {\n          message: \"Unexpected RegExp Anchor Error:\\n\tToken Type: ->\" + currType.name + \"<- static 'PATTERN' cannot contain start of input anchor '^'\\n\tSee https://chevrotain.io/docs/guide/resolving_lexer_errors.html#ANCHORS\tfor details.\",\n          type: LexerDefinitionErrorType.SOI_ANCHOR_FOUND,\n          tokenTypes: [currType]\n        };\n      });\n      return errors;\n    }\n    function findUnsupportedFlags(tokenTypes) {\n      var invalidFlags = filter(tokenTypes, function (currType) {\n        var pattern = currType[PATTERN];\n        return pattern instanceof RegExp && (pattern.multiline || pattern.global);\n      });\n      var errors = map(invalidFlags, function (currType) {\n        return {\n          message: \"Token Type: ->\" + currType.name + \"<- static 'PATTERN' may NOT contain global('g') or multiline('m')\",\n          type: LexerDefinitionErrorType.UNSUPPORTED_FLAGS_FOUND,\n          tokenTypes: [currType]\n        };\n      });\n      return errors;\n    }\n    function findDuplicatePatterns(tokenTypes) {\n      var found = [];\n      var identicalPatterns = map(tokenTypes, function (outerType) {\n        return reduce(tokenTypes, function (result, innerType) {\n          if (outerType.PATTERN.source === innerType.PATTERN.source && !includes(found, innerType) && innerType.PATTERN !== Lexer2.NA) {\n            found.push(innerType);\n            result.push(innerType);\n            return result;\n          }\n          return result;\n        }, []);\n      });\n      identicalPatterns = compact(identicalPatterns);\n      var duplicatePatterns = filter(identicalPatterns, function (currIdenticalSet) {\n        return currIdenticalSet.length > 1;\n      });\n      var errors = map(duplicatePatterns, function (setOfIdentical) {\n        var tokenTypeNames = map(setOfIdentical, function (currType) {\n          return currType.name;\n        });\n        var dupPatternSrc = head(setOfIdentical).PATTERN;\n        return {\n          message: \"The same RegExp pattern ->\".concat(dupPatternSrc, \"<-has been used in all of the following Token Types: \").concat(tokenTypeNames.join(\", \"), \" <-\"),\n          type: LexerDefinitionErrorType.DUPLICATE_PATTERNS_FOUND,\n          tokenTypes: setOfIdentical\n        };\n      });\n      return errors;\n    }\n    function findInvalidGroupType(tokenTypes) {\n      var invalidTypes = filter(tokenTypes, function (clazz) {\n        if (!has(clazz, \"GROUP\")) {\n          return false;\n        }\n        var group = clazz.GROUP;\n        return group !== Lexer2.SKIPPED && group !== Lexer2.NA && !isString(group);\n      });\n      var errors = map(invalidTypes, function (currType) {\n        return {\n          message: \"Token Type: ->\" + currType.name + \"<- static 'GROUP' can only be Lexer.SKIPPED/Lexer.NA/A String\",\n          type: LexerDefinitionErrorType.INVALID_GROUP_TYPE_FOUND,\n          tokenTypes: [currType]\n        };\n      });\n      return errors;\n    }\n    function findModesThatDoNotExist(tokenTypes, validModes) {\n      var invalidModes = filter(tokenTypes, function (clazz) {\n        return clazz.PUSH_MODE !== void 0 && !includes(validModes, clazz.PUSH_MODE);\n      });\n      var errors = map(invalidModes, function (tokType) {\n        var msg = \"Token Type: ->\".concat(tokType.name, \"<- static 'PUSH_MODE' value cannot refer to a Lexer Mode ->\").concat(tokType.PUSH_MODE, \"<-which does not exist\");\n        return {\n          message: msg,\n          type: LexerDefinitionErrorType.PUSH_MODE_DOES_NOT_EXIST,\n          tokenTypes: [tokType]\n        };\n      });\n      return errors;\n    }\n    function findUnreachablePatterns(tokenTypes) {\n      var errors = [];\n      var canBeTested = reduce(tokenTypes, function (result, tokType, idx) {\n        var pattern = tokType.PATTERN;\n        if (pattern === Lexer2.NA) {\n          return result;\n        }\n        if (isString(pattern)) {\n          result.push({\n            str: pattern,\n            idx: idx,\n            tokenType: tokType\n          });\n        } else if (isRegExp$1(pattern) && noMetaChar(pattern)) {\n          result.push({\n            str: pattern.source,\n            idx: idx,\n            tokenType: tokType\n          });\n        }\n        return result;\n      }, []);\n      forEach(tokenTypes, function (tokType, testIdx) {\n        forEach(canBeTested, function (_ref2) {\n          var str = _ref2.str,\n            idx = _ref2.idx,\n            tokenType = _ref2.tokenType;\n          if (testIdx < idx && testTokenType(str, tokType.PATTERN)) {\n            var msg = \"Token: ->\".concat(tokenType.name, \"<- can never be matched.\\nBecause it appears AFTER the Token Type ->\").concat(tokType.name, \"<-in the lexer's definition.\\nSee https://chevrotain.io/docs/guide/resolving_lexer_errors.html#UNREACHABLE\");\n            errors.push({\n              message: msg,\n              type: LexerDefinitionErrorType.UNREACHABLE_PATTERN,\n              tokenTypes: [tokType, tokenType]\n            });\n          }\n        });\n      });\n      return errors;\n    }\n    function testTokenType(str, pattern) {\n      if (isRegExp$1(pattern)) {\n        var regExpArray = pattern.exec(str);\n        return regExpArray !== null && regExpArray.index === 0;\n      } else if (isFunction(pattern)) {\n        return pattern(str, 0, [], {});\n      } else if (has(pattern, \"exec\")) {\n        return pattern.exec(str, 0, [], {});\n      } else if (typeof pattern === \"string\") {\n        return pattern === str;\n      } else {\n        throw Error(\"non exhaustive match\");\n      }\n    }\n    function noMetaChar(regExp) {\n      var metaChars = [\".\", \"\\\\\", \"[\", \"]\", \"|\", \"^\", \"$\", \"(\", \")\", \"?\", \"*\", \"+\", \"{\"];\n      return find$1(metaChars, function (char) {\n        return regExp.source.indexOf(char) !== -1;\n      }) === void 0;\n    }\n    function addStartOfInput(pattern) {\n      var flags = pattern.ignoreCase ? \"i\" : \"\";\n      return new RegExp(\"^(?:\".concat(pattern.source, \")\"), flags);\n    }\n    function addStickyFlag(pattern) {\n      var flags = pattern.ignoreCase ? \"iy\" : \"y\";\n      return new RegExp(\"\".concat(pattern.source), flags);\n    }\n    function performRuntimeChecks(lexerDefinition, trackLines, lineTerminatorCharacters) {\n      var errors = [];\n      if (!has(lexerDefinition, DEFAULT_MODE)) {\n        errors.push({\n          message: \"A MultiMode Lexer cannot be initialized without a <\" + DEFAULT_MODE + \"> property in its definition\\n\",\n          type: LexerDefinitionErrorType.MULTI_MODE_LEXER_WITHOUT_DEFAULT_MODE\n        });\n      }\n      if (!has(lexerDefinition, MODES)) {\n        errors.push({\n          message: \"A MultiMode Lexer cannot be initialized without a <\" + MODES + \"> property in its definition\\n\",\n          type: LexerDefinitionErrorType.MULTI_MODE_LEXER_WITHOUT_MODES_PROPERTY\n        });\n      }\n      if (has(lexerDefinition, MODES) && has(lexerDefinition, DEFAULT_MODE) && !has(lexerDefinition.modes, lexerDefinition.defaultMode)) {\n        errors.push({\n          message: \"A MultiMode Lexer cannot be initialized with a \".concat(DEFAULT_MODE, \": <\").concat(lexerDefinition.defaultMode, \">which does not exist\\n\"),\n          type: LexerDefinitionErrorType.MULTI_MODE_LEXER_DEFAULT_MODE_VALUE_DOES_NOT_EXIST\n        });\n      }\n      if (has(lexerDefinition, MODES)) {\n        forEach(lexerDefinition.modes, function (currModeValue, currModeName) {\n          forEach(currModeValue, function (currTokType, currIdx) {\n            if (isUndefined(currTokType)) {\n              errors.push({\n                message: \"A Lexer cannot be initialized using an undefined Token Type. Mode:<\".concat(currModeName, \"> at index: <\").concat(currIdx, \">\\n\"),\n                type: LexerDefinitionErrorType.LEXER_DEFINITION_CANNOT_CONTAIN_UNDEFINED\n              });\n            } else if (has(currTokType, \"LONGER_ALT\")) {\n              var longerAlt = isArray$1(currTokType.LONGER_ALT) ? currTokType.LONGER_ALT : [currTokType.LONGER_ALT];\n              forEach(longerAlt, function (currLongerAlt) {\n                if (!isUndefined(currLongerAlt) && !includes(currModeValue, currLongerAlt)) {\n                  errors.push({\n                    message: \"A MultiMode Lexer cannot be initialized with a longer_alt <\".concat(currLongerAlt.name, \"> on token <\").concat(currTokType.name, \"> outside of mode <\").concat(currModeName, \">\\n\"),\n                    type: LexerDefinitionErrorType.MULTI_MODE_LEXER_LONGER_ALT_NOT_IN_CURRENT_MODE\n                  });\n                }\n              });\n            }\n          });\n        });\n      }\n      return errors;\n    }\n    function performWarningRuntimeChecks(lexerDefinition, trackLines, lineTerminatorCharacters) {\n      var warnings = [];\n      var hasAnyLineBreak = false;\n      var allTokenTypes = compact(flatten(values(lexerDefinition.modes)));\n      var concreteTokenTypes = reject(allTokenTypes, function (currType) {\n        return currType[PATTERN] === Lexer2.NA;\n      });\n      var terminatorCharCodes = getCharCodes(lineTerminatorCharacters);\n      if (trackLines) {\n        forEach(concreteTokenTypes, function (tokType) {\n          var currIssue = checkLineBreaksIssues(tokType, terminatorCharCodes);\n          if (currIssue !== false) {\n            var message = buildLineBreakIssueMessage(tokType, currIssue);\n            var warningDescriptor = {\n              message: message,\n              type: currIssue.issue,\n              tokenType: tokType\n            };\n            warnings.push(warningDescriptor);\n          } else {\n            if (has(tokType, \"LINE_BREAKS\")) {\n              if (tokType.LINE_BREAKS === true) {\n                hasAnyLineBreak = true;\n              }\n            } else {\n              if (canMatchCharCode(terminatorCharCodes, tokType.PATTERN)) {\n                hasAnyLineBreak = true;\n              }\n            }\n          }\n        });\n      }\n      if (trackLines && !hasAnyLineBreak) {\n        warnings.push({\n          message: \"Warning: No LINE_BREAKS Found.\\n\tThis Lexer has been defined to track line and column information,\\n\tBut none of the Token Types can be identified as matching a line terminator.\\n\tSee https://chevrotain.io/docs/guide/resolving_lexer_errors.html#LINE_BREAKS \\n\tfor details.\",\n          type: LexerDefinitionErrorType.NO_LINE_BREAKS_FLAGS\n        });\n      }\n      return warnings;\n    }\n    function cloneEmptyGroups(emptyGroups) {\n      var clonedResult = {};\n      var groupKeys = keys(emptyGroups);\n      forEach(groupKeys, function (currKey) {\n        var currGroupValue = emptyGroups[currKey];\n        if (isArray$1(currGroupValue)) {\n          clonedResult[currKey] = [];\n        } else {\n          throw Error(\"non exhaustive match\");\n        }\n      });\n      return clonedResult;\n    }\n    function isCustomPattern(tokenType) {\n      var pattern = tokenType.PATTERN;\n      if (isRegExp$1(pattern)) {\n        return false;\n      } else if (isFunction(pattern)) {\n        return true;\n      } else if (has(pattern, \"exec\")) {\n        return true;\n      } else if (isString(pattern)) {\n        return false;\n      } else {\n        throw Error(\"non exhaustive match\");\n      }\n    }\n    function isShortPattern(pattern) {\n      if (isString(pattern) && pattern.length === 1) {\n        return pattern.charCodeAt(0);\n      } else {\n        return false;\n      }\n    }\n    var LineTerminatorOptimizedTester = {\n      // implements /\\n|\\r\\n?/g.test\n      test: function test(text) {\n        var len = text.length;\n        for (var _i6 = this.lastIndex; _i6 < len; _i6++) {\n          var c = text.charCodeAt(_i6);\n          if (c === 10) {\n            this.lastIndex = _i6 + 1;\n            return true;\n          } else if (c === 13) {\n            if (text.charCodeAt(_i6 + 1) === 10) {\n              this.lastIndex = _i6 + 2;\n            } else {\n              this.lastIndex = _i6 + 1;\n            }\n            return true;\n          }\n        }\n        return false;\n      },\n      lastIndex: 0\n    };\n    function checkLineBreaksIssues(tokType, lineTerminatorCharCodes) {\n      if (has(tokType, \"LINE_BREAKS\")) {\n        return false;\n      } else {\n        if (isRegExp$1(tokType.PATTERN)) {\n          try {\n            canMatchCharCode(lineTerminatorCharCodes, tokType.PATTERN);\n          } catch (e) {\n            return {\n              issue: LexerDefinitionErrorType.IDENTIFY_TERMINATOR,\n              errMsg: e.message\n            };\n          }\n          return false;\n        } else if (isString(tokType.PATTERN)) {\n          return false;\n        } else if (isCustomPattern(tokType)) {\n          return {\n            issue: LexerDefinitionErrorType.CUSTOM_LINE_BREAK\n          };\n        } else {\n          throw Error(\"non exhaustive match\");\n        }\n      }\n    }\n    function buildLineBreakIssueMessage(tokType, details) {\n      if (details.issue === LexerDefinitionErrorType.IDENTIFY_TERMINATOR) {\n        return \"Warning: unable to identify line terminator usage in pattern.\\n\\tThe problem is in the <\".concat(tokType.name, \"> Token Type\\n\\t Root cause: \").concat(details.errMsg, \".\\n\\tFor details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#IDENTIFY_TERMINATOR\");\n      } else if (details.issue === LexerDefinitionErrorType.CUSTOM_LINE_BREAK) {\n        return \"Warning: A Custom Token Pattern should specify the <line_breaks> option.\\n\\tThe problem is in the <\".concat(tokType.name, \"> Token Type\\n\\tFor details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#CUSTOM_LINE_BREAK\");\n      } else {\n        throw Error(\"non exhaustive match\");\n      }\n    }\n    function getCharCodes(charsOrCodes) {\n      var charCodes = map(charsOrCodes, function (numOrString) {\n        if (isString(numOrString)) {\n          return numOrString.charCodeAt(0);\n        } else {\n          return numOrString;\n        }\n      });\n      return charCodes;\n    }\n    function addToMapOfArrays(map2, key, value) {\n      if (map2[key] === void 0) {\n        map2[key] = [value];\n      } else {\n        map2[key].push(value);\n      }\n    }\n    var minOptimizationVal = 256;\n    var charCodeToOptimizedIdxMap = [];\n    function charCodeToOptimizedIndex(charCode) {\n      return charCode < minOptimizationVal ? charCode : charCodeToOptimizedIdxMap[charCode];\n    }\n    function initCharCodeToOptimizedIndexMap() {\n      if (isEmpty(charCodeToOptimizedIdxMap)) {\n        charCodeToOptimizedIdxMap = new Array(65536);\n        for (var _i7 = 0; _i7 < 65536; _i7++) {\n          charCodeToOptimizedIdxMap[_i7] = _i7 > 255 ? 255 + ~~(_i7 / 255) : _i7;\n        }\n      }\n    }\n    function tokenStructuredMatcher(tokInstance, tokConstructor) {\n      var instanceType = tokInstance.tokenTypeIdx;\n      if (instanceType === tokConstructor.tokenTypeIdx) {\n        return true;\n      } else {\n        return tokConstructor.isParent === true && tokConstructor.categoryMatchesMap[instanceType] === true;\n      }\n    }\n    function tokenStructuredMatcherNoCategories(token, tokType) {\n      return token.tokenTypeIdx === tokType.tokenTypeIdx;\n    }\n    var tokenShortNameIdx = 1;\n    var tokenIdxToClass = {};\n    function augmentTokenTypes(tokenTypes) {\n      var tokenTypesAndParents = expandCategories(tokenTypes);\n      assignTokenDefaultProps(tokenTypesAndParents);\n      assignCategoriesMapProp(tokenTypesAndParents);\n      assignCategoriesTokensProp(tokenTypesAndParents);\n      forEach(tokenTypesAndParents, function (tokType) {\n        tokType.isParent = tokType.categoryMatches.length > 0;\n      });\n    }\n    function expandCategories(tokenTypes) {\n      var result = clone(tokenTypes);\n      var categories = tokenTypes;\n      var searching = true;\n      while (searching) {\n        categories = compact(flatten(map(categories, function (currTokType) {\n          return currTokType.CATEGORIES;\n        })));\n        var newCategories = difference$1(categories, result);\n        result = result.concat(newCategories);\n        if (isEmpty(newCategories)) {\n          searching = false;\n        } else {\n          categories = newCategories;\n        }\n      }\n      return result;\n    }\n    function assignTokenDefaultProps(tokenTypes) {\n      forEach(tokenTypes, function (currTokType) {\n        if (!hasShortKeyProperty(currTokType)) {\n          tokenIdxToClass[tokenShortNameIdx] = currTokType;\n          currTokType.tokenTypeIdx = tokenShortNameIdx++;\n        }\n        if (hasCategoriesProperty(currTokType) && !isArray$1(currTokType.CATEGORIES)) {\n          currTokType.CATEGORIES = [currTokType.CATEGORIES];\n        }\n        if (!hasCategoriesProperty(currTokType)) {\n          currTokType.CATEGORIES = [];\n        }\n        if (!hasExtendingTokensTypesProperty(currTokType)) {\n          currTokType.categoryMatches = [];\n        }\n        if (!hasExtendingTokensTypesMapProperty(currTokType)) {\n          currTokType.categoryMatchesMap = {};\n        }\n      });\n    }\n    function assignCategoriesTokensProp(tokenTypes) {\n      forEach(tokenTypes, function (currTokType) {\n        currTokType.categoryMatches = [];\n        forEach(currTokType.categoryMatchesMap, function (val, key) {\n          currTokType.categoryMatches.push(tokenIdxToClass[key].tokenTypeIdx);\n        });\n      });\n    }\n    function assignCategoriesMapProp(tokenTypes) {\n      forEach(tokenTypes, function (currTokType) {\n        singleAssignCategoriesToksMap([], currTokType);\n      });\n    }\n    function singleAssignCategoriesToksMap(path, nextNode) {\n      forEach(path, function (pathNode) {\n        nextNode.categoryMatchesMap[pathNode.tokenTypeIdx] = true;\n      });\n      forEach(nextNode.CATEGORIES, function (nextCategory) {\n        var newPath = path.concat(nextNode);\n        if (!includes(newPath, nextCategory)) {\n          singleAssignCategoriesToksMap(newPath, nextCategory);\n        }\n      });\n    }\n    function hasShortKeyProperty(tokType) {\n      return has(tokType, \"tokenTypeIdx\");\n    }\n    function hasCategoriesProperty(tokType) {\n      return has(tokType, \"CATEGORIES\");\n    }\n    function hasExtendingTokensTypesProperty(tokType) {\n      return has(tokType, \"categoryMatches\");\n    }\n    function hasExtendingTokensTypesMapProperty(tokType) {\n      return has(tokType, \"categoryMatchesMap\");\n    }\n    function isTokenType(tokType) {\n      return has(tokType, \"tokenTypeIdx\");\n    }\n    var defaultLexerErrorProvider = {\n      buildUnableToPopLexerModeMessage: function buildUnableToPopLexerModeMessage(token) {\n        return \"Unable to pop Lexer Mode after encountering Token ->\".concat(token.image, \"<- The Mode Stack is empty\");\n      },\n      buildUnexpectedCharactersMessage: function buildUnexpectedCharactersMessage(fullText, startOffset, length, line, column) {\n        return \"unexpected character: ->\".concat(fullText.charAt(startOffset), \"<- at offset: \").concat(startOffset, \", skipped \").concat(length, \" characters.\");\n      }\n    };\n    var LexerDefinitionErrorType;\n    (function (LexerDefinitionErrorType2) {\n      LexerDefinitionErrorType2[LexerDefinitionErrorType2[\"MISSING_PATTERN\"] = 0] = \"MISSING_PATTERN\";\n      LexerDefinitionErrorType2[LexerDefinitionErrorType2[\"INVALID_PATTERN\"] = 1] = \"INVALID_PATTERN\";\n      LexerDefinitionErrorType2[LexerDefinitionErrorType2[\"EOI_ANCHOR_FOUND\"] = 2] = \"EOI_ANCHOR_FOUND\";\n      LexerDefinitionErrorType2[LexerDefinitionErrorType2[\"UNSUPPORTED_FLAGS_FOUND\"] = 3] = \"UNSUPPORTED_FLAGS_FOUND\";\n      LexerDefinitionErrorType2[LexerDefinitionErrorType2[\"DUPLICATE_PATTERNS_FOUND\"] = 4] = \"DUPLICATE_PATTERNS_FOUND\";\n      LexerDefinitionErrorType2[LexerDefinitionErrorType2[\"INVALID_GROUP_TYPE_FOUND\"] = 5] = \"INVALID_GROUP_TYPE_FOUND\";\n      LexerDefinitionErrorType2[LexerDefinitionErrorType2[\"PUSH_MODE_DOES_NOT_EXIST\"] = 6] = \"PUSH_MODE_DOES_NOT_EXIST\";\n      LexerDefinitionErrorType2[LexerDefinitionErrorType2[\"MULTI_MODE_LEXER_WITHOUT_DEFAULT_MODE\"] = 7] = \"MULTI_MODE_LEXER_WITHOUT_DEFAULT_MODE\";\n      LexerDefinitionErrorType2[LexerDefinitionErrorType2[\"MULTI_MODE_LEXER_WITHOUT_MODES_PROPERTY\"] = 8] = \"MULTI_MODE_LEXER_WITHOUT_MODES_PROPERTY\";\n      LexerDefinitionErrorType2[LexerDefinitionErrorType2[\"MULTI_MODE_LEXER_DEFAULT_MODE_VALUE_DOES_NOT_EXIST\"] = 9] = \"MULTI_MODE_LEXER_DEFAULT_MODE_VALUE_DOES_NOT_EXIST\";\n      LexerDefinitionErrorType2[LexerDefinitionErrorType2[\"LEXER_DEFINITION_CANNOT_CONTAIN_UNDEFINED\"] = 10] = \"LEXER_DEFINITION_CANNOT_CONTAIN_UNDEFINED\";\n      LexerDefinitionErrorType2[LexerDefinitionErrorType2[\"SOI_ANCHOR_FOUND\"] = 11] = \"SOI_ANCHOR_FOUND\";\n      LexerDefinitionErrorType2[LexerDefinitionErrorType2[\"EMPTY_MATCH_PATTERN\"] = 12] = \"EMPTY_MATCH_PATTERN\";\n      LexerDefinitionErrorType2[LexerDefinitionErrorType2[\"NO_LINE_BREAKS_FLAGS\"] = 13] = \"NO_LINE_BREAKS_FLAGS\";\n      LexerDefinitionErrorType2[LexerDefinitionErrorType2[\"UNREACHABLE_PATTERN\"] = 14] = \"UNREACHABLE_PATTERN\";\n      LexerDefinitionErrorType2[LexerDefinitionErrorType2[\"IDENTIFY_TERMINATOR\"] = 15] = \"IDENTIFY_TERMINATOR\";\n      LexerDefinitionErrorType2[LexerDefinitionErrorType2[\"CUSTOM_LINE_BREAK\"] = 16] = \"CUSTOM_LINE_BREAK\";\n      LexerDefinitionErrorType2[LexerDefinitionErrorType2[\"MULTI_MODE_LEXER_LONGER_ALT_NOT_IN_CURRENT_MODE\"] = 17] = \"MULTI_MODE_LEXER_LONGER_ALT_NOT_IN_CURRENT_MODE\";\n    })(LexerDefinitionErrorType || (LexerDefinitionErrorType = {}));\n    var DEFAULT_LEXER_CONFIG = {\n      deferDefinitionErrorsHandling: false,\n      positionTracking: \"full\",\n      lineTerminatorsPattern: /\\n|\\r\\n?/g,\n      lineTerminatorCharacters: [\"\\n\", \"\\r\"],\n      ensureOptimizations: false,\n      safeMode: false,\n      errorMessageProvider: defaultLexerErrorProvider,\n      traceInitPerf: false,\n      skipValidations: false,\n      recoveryEnabled: true\n    };\n    Object.freeze(DEFAULT_LEXER_CONFIG);\n    var Lexer2 = /*#__PURE__*/function () {\n      function Lexer2(lexerDefinition) {\n        var _this17 = this;\n        var config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DEFAULT_LEXER_CONFIG;\n        _classCallCheck(this, Lexer2);\n        this.lexerDefinition = lexerDefinition;\n        this.lexerDefinitionErrors = [];\n        this.lexerDefinitionWarning = [];\n        this.patternIdxToConfig = {};\n        this.charCodeToPatternIdxToConfig = {};\n        this.modes = [];\n        this.emptyGroups = {};\n        this.trackStartLines = true;\n        this.trackEndLines = true;\n        this.hasCustom = false;\n        this.canModeBeOptimized = {};\n        this.TRACE_INIT = function (phaseDesc, phaseImpl) {\n          if (_this17.traceInitPerf === true) {\n            _this17.traceInitIndent++;\n            var indent = new Array(_this17.traceInitIndent + 1).join(\"\t\");\n            if (_this17.traceInitIndent < _this17.traceInitMaxIdent) {\n              console.log(\"\".concat(indent, \"--> <\").concat(phaseDesc, \">\"));\n            }\n            var _timer = timer(phaseImpl),\n              time = _timer.time,\n              value = _timer.value;\n            var traceMethod = time > 10 ? console.warn : console.log;\n            if (_this17.traceInitIndent < _this17.traceInitMaxIdent) {\n              traceMethod(\"\".concat(indent, \"<-- <\").concat(phaseDesc, \"> time: \").concat(time, \"ms\"));\n            }\n            _this17.traceInitIndent--;\n            return value;\n          } else {\n            return phaseImpl();\n          }\n        };\n        if (typeof config === \"boolean\") {\n          throw Error(\"The second argument to the Lexer constructor is now an ILexerConfig Object.\\na boolean 2nd argument is no longer supported\");\n        }\n        this.config = assign$1({}, DEFAULT_LEXER_CONFIG, config);\n        var traceInitVal = this.config.traceInitPerf;\n        if (traceInitVal === true) {\n          this.traceInitMaxIdent = Infinity;\n          this.traceInitPerf = true;\n        } else if (typeof traceInitVal === \"number\") {\n          this.traceInitMaxIdent = traceInitVal;\n          this.traceInitPerf = true;\n        }\n        this.traceInitIndent = -1;\n        this.TRACE_INIT(\"Lexer Constructor\", function () {\n          var actualDefinition;\n          var hasOnlySingleMode = true;\n          _this17.TRACE_INIT(\"Lexer Config handling\", function () {\n            if (_this17.config.lineTerminatorsPattern === DEFAULT_LEXER_CONFIG.lineTerminatorsPattern) {\n              _this17.config.lineTerminatorsPattern = LineTerminatorOptimizedTester;\n            } else {\n              if (_this17.config.lineTerminatorCharacters === DEFAULT_LEXER_CONFIG.lineTerminatorCharacters) {\n                throw Error(\"Error: Missing <lineTerminatorCharacters> property on the Lexer config.\\n\tFor details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#MISSING_LINE_TERM_CHARS\");\n              }\n            }\n            if (config.safeMode && config.ensureOptimizations) {\n              throw Error('\"safeMode\" and \"ensureOptimizations\" flags are mutually exclusive.');\n            }\n            _this17.trackStartLines = /full|onlyStart/i.test(_this17.config.positionTracking);\n            _this17.trackEndLines = /full/i.test(_this17.config.positionTracking);\n            if (isArray$1(lexerDefinition)) {\n              actualDefinition = {\n                modes: {\n                  defaultMode: clone(lexerDefinition)\n                },\n                defaultMode: DEFAULT_MODE\n              };\n            } else {\n              hasOnlySingleMode = false;\n              actualDefinition = clone(lexerDefinition);\n            }\n          });\n          if (_this17.config.skipValidations === false) {\n            _this17.TRACE_INIT(\"performRuntimeChecks\", function () {\n              _this17.lexerDefinitionErrors = _this17.lexerDefinitionErrors.concat(performRuntimeChecks(actualDefinition, _this17.trackStartLines, _this17.config.lineTerminatorCharacters));\n            });\n            _this17.TRACE_INIT(\"performWarningRuntimeChecks\", function () {\n              _this17.lexerDefinitionWarning = _this17.lexerDefinitionWarning.concat(performWarningRuntimeChecks(actualDefinition, _this17.trackStartLines, _this17.config.lineTerminatorCharacters));\n            });\n          }\n          actualDefinition.modes = actualDefinition.modes ? actualDefinition.modes : {};\n          forEach(actualDefinition.modes, function (currModeValue, currModeName) {\n            actualDefinition.modes[currModeName] = reject(currModeValue, function (currTokType) {\n              return isUndefined(currTokType);\n            });\n          });\n          var allModeNames = keys(actualDefinition.modes);\n          forEach(actualDefinition.modes, function (currModDef, currModName) {\n            _this17.TRACE_INIT(\"Mode: <\".concat(currModName, \"> processing\"), function () {\n              _this17.modes.push(currModName);\n              if (_this17.config.skipValidations === false) {\n                _this17.TRACE_INIT(\"validatePatterns\", function () {\n                  _this17.lexerDefinitionErrors = _this17.lexerDefinitionErrors.concat(validatePatterns(currModDef, allModeNames));\n                });\n              }\n              if (isEmpty(_this17.lexerDefinitionErrors)) {\n                augmentTokenTypes(currModDef);\n                var currAnalyzeResult;\n                _this17.TRACE_INIT(\"analyzeTokenTypes\", function () {\n                  currAnalyzeResult = analyzeTokenTypes(currModDef, {\n                    lineTerminatorCharacters: _this17.config.lineTerminatorCharacters,\n                    positionTracking: config.positionTracking,\n                    ensureOptimizations: config.ensureOptimizations,\n                    safeMode: config.safeMode,\n                    tracer: _this17.TRACE_INIT\n                  });\n                });\n                _this17.patternIdxToConfig[currModName] = currAnalyzeResult.patternIdxToConfig;\n                _this17.charCodeToPatternIdxToConfig[currModName] = currAnalyzeResult.charCodeToPatternIdxToConfig;\n                _this17.emptyGroups = assign$1({}, _this17.emptyGroups, currAnalyzeResult.emptyGroups);\n                _this17.hasCustom = currAnalyzeResult.hasCustom || _this17.hasCustom;\n                _this17.canModeBeOptimized[currModName] = currAnalyzeResult.canBeOptimized;\n              }\n            });\n          });\n          _this17.defaultMode = actualDefinition.defaultMode;\n          if (!isEmpty(_this17.lexerDefinitionErrors) && !_this17.config.deferDefinitionErrorsHandling) {\n            var allErrMessages = map(_this17.lexerDefinitionErrors, function (error) {\n              return error.message;\n            });\n            var allErrMessagesString = allErrMessages.join(\"-----------------------\\n\");\n            throw new Error(\"Errors detected in definition of Lexer:\\n\" + allErrMessagesString);\n          }\n          forEach(_this17.lexerDefinitionWarning, function (warningDescriptor) {\n            PRINT_WARNING(warningDescriptor.message);\n          });\n          _this17.TRACE_INIT(\"Choosing sub-methods implementations\", function () {\n            if (SUPPORT_STICKY) {\n              _this17.chopInput = identity;\n              _this17.match = _this17.matchWithTest;\n            } else {\n              _this17.updateLastIndex = noop;\n              _this17.match = _this17.matchWithExec;\n            }\n            if (hasOnlySingleMode) {\n              _this17.handleModes = noop;\n            }\n            if (_this17.trackStartLines === false) {\n              _this17.computeNewColumn = identity;\n            }\n            if (_this17.trackEndLines === false) {\n              _this17.updateTokenEndLineColumnLocation = noop;\n            }\n            if (/full/i.test(_this17.config.positionTracking)) {\n              _this17.createTokenInstance = _this17.createFullToken;\n            } else if (/onlyStart/i.test(_this17.config.positionTracking)) {\n              _this17.createTokenInstance = _this17.createStartOnlyToken;\n            } else if (/onlyOffset/i.test(_this17.config.positionTracking)) {\n              _this17.createTokenInstance = _this17.createOffsetOnlyToken;\n            } else {\n              throw Error(\"Invalid <positionTracking> config option: \\\"\".concat(_this17.config.positionTracking, \"\\\"\"));\n            }\n            if (_this17.hasCustom) {\n              _this17.addToken = _this17.addTokenUsingPush;\n              _this17.handlePayload = _this17.handlePayloadWithCustom;\n            } else {\n              _this17.addToken = _this17.addTokenUsingMemberAccess;\n              _this17.handlePayload = _this17.handlePayloadNoCustom;\n            }\n          });\n          _this17.TRACE_INIT(\"Failed Optimization Warnings\", function () {\n            var unOptimizedModes = reduce(_this17.canModeBeOptimized, function (cannotBeOptimized, canBeOptimized, modeName) {\n              if (canBeOptimized === false) {\n                cannotBeOptimized.push(modeName);\n              }\n              return cannotBeOptimized;\n            }, []);\n            if (config.ensureOptimizations && !isEmpty(unOptimizedModes)) {\n              throw Error(\"Lexer Modes: < \".concat(unOptimizedModes.join(\", \"), \" > cannot be optimized.\\n\\t Disable the \\\"ensureOptimizations\\\" lexer config flag to silently ignore this and run the lexer in an un-optimized mode.\\n\\t Or inspect the console log for details on how to resolve these issues.\"));\n            }\n          });\n          _this17.TRACE_INIT(\"clearRegExpParserCache\", function () {\n            clearRegExpParserCache();\n          });\n          _this17.TRACE_INIT(\"toFastProperties\", function () {\n            toFastProperties(_this17);\n          });\n        });\n      }\n      _createClass(Lexer2, [{\n        key: \"tokenize\",\n        value: function tokenize(text) {\n          var initialMode = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.defaultMode;\n          if (!isEmpty(this.lexerDefinitionErrors)) {\n            var allErrMessages = map(this.lexerDefinitionErrors, function (error) {\n              return error.message;\n            });\n            var allErrMessagesString = allErrMessages.join(\"-----------------------\\n\");\n            throw new Error(\"Unable to Tokenize because Errors detected in definition of Lexer:\\n\" + allErrMessagesString);\n          }\n          return this.tokenizeInternal(text, initialMode);\n        }\n        // There is quite a bit of duplication between this and \"tokenizeInternalLazy\"\n        // This is intentional due to performance considerations.\n        // this method also used quite a bit of `!` none null assertions because it is too optimized\n        // for `tsc` to always understand it is \"safe\"\n      }, {\n        key: \"tokenizeInternal\",\n        value: function tokenizeInternal(text, initialMode) {\n          var _this18 = this;\n          var i, j, k, matchAltImage, longerAlt, matchedImage, payload, altPayload, imageLength, group, tokType, newToken, errLength, msg, match;\n          var orgText = text;\n          var orgLength = orgText.length;\n          var offset = 0;\n          var matchedTokensIndex = 0;\n          var guessedNumberOfTokens = this.hasCustom ? 0 : Math.floor(text.length / 10);\n          var matchedTokens = new Array(guessedNumberOfTokens);\n          var errors = [];\n          var line = this.trackStartLines ? 1 : void 0;\n          var column = this.trackStartLines ? 1 : void 0;\n          var groups = cloneEmptyGroups(this.emptyGroups);\n          var trackLines = this.trackStartLines;\n          var lineTerminatorPattern = this.config.lineTerminatorsPattern;\n          var currModePatternsLength = 0;\n          var patternIdxToConfig = [];\n          var currCharCodeToPatternIdxToConfig = [];\n          var modeStack = [];\n          var emptyArray = [];\n          Object.freeze(emptyArray);\n          var getPossiblePatterns;\n          function getPossiblePatternsSlow() {\n            return patternIdxToConfig;\n          }\n          function getPossiblePatternsOptimized(charCode) {\n            var optimizedCharIdx = charCodeToOptimizedIndex(charCode);\n            var possiblePatterns = currCharCodeToPatternIdxToConfig[optimizedCharIdx];\n            if (possiblePatterns === void 0) {\n              return emptyArray;\n            } else {\n              return possiblePatterns;\n            }\n          }\n          var pop_mode = function pop_mode(popToken) {\n            if (modeStack.length === 1 &&\n            // if we have both a POP_MODE and a PUSH_MODE this is in-fact a \"transition\"\n            // So no error should occur.\n            popToken.tokenType.PUSH_MODE === void 0) {\n              var msg2 = _this18.config.errorMessageProvider.buildUnableToPopLexerModeMessage(popToken);\n              errors.push({\n                offset: popToken.startOffset,\n                line: popToken.startLine,\n                column: popToken.startColumn,\n                length: popToken.image.length,\n                message: msg2\n              });\n            } else {\n              modeStack.pop();\n              var newMode = last(modeStack);\n              patternIdxToConfig = _this18.patternIdxToConfig[newMode];\n              currCharCodeToPatternIdxToConfig = _this18.charCodeToPatternIdxToConfig[newMode];\n              currModePatternsLength = patternIdxToConfig.length;\n              var modeCanBeOptimized = _this18.canModeBeOptimized[newMode] && _this18.config.safeMode === false;\n              if (currCharCodeToPatternIdxToConfig && modeCanBeOptimized) {\n                getPossiblePatterns = getPossiblePatternsOptimized;\n              } else {\n                getPossiblePatterns = getPossiblePatternsSlow;\n              }\n            }\n          };\n          function push_mode(newMode) {\n            modeStack.push(newMode);\n            currCharCodeToPatternIdxToConfig = this.charCodeToPatternIdxToConfig[newMode];\n            patternIdxToConfig = this.patternIdxToConfig[newMode];\n            currModePatternsLength = patternIdxToConfig.length;\n            currModePatternsLength = patternIdxToConfig.length;\n            var modeCanBeOptimized = this.canModeBeOptimized[newMode] && this.config.safeMode === false;\n            if (currCharCodeToPatternIdxToConfig && modeCanBeOptimized) {\n              getPossiblePatterns = getPossiblePatternsOptimized;\n            } else {\n              getPossiblePatterns = getPossiblePatternsSlow;\n            }\n          }\n          push_mode.call(this, initialMode);\n          var currConfig;\n          var recoveryEnabled = this.config.recoveryEnabled;\n          while (offset < orgLength) {\n            matchedImage = null;\n            var nextCharCode = orgText.charCodeAt(offset);\n            var chosenPatternIdxToConfig = getPossiblePatterns(nextCharCode);\n            var chosenPatternsLength = chosenPatternIdxToConfig.length;\n            for (i = 0; i < chosenPatternsLength; i++) {\n              currConfig = chosenPatternIdxToConfig[i];\n              var currPattern = currConfig.pattern;\n              payload = null;\n              var singleCharCode = currConfig.short;\n              if (singleCharCode !== false) {\n                if (nextCharCode === singleCharCode) {\n                  matchedImage = currPattern;\n                }\n              } else if (currConfig.isCustom === true) {\n                match = currPattern.exec(orgText, offset, matchedTokens, groups);\n                if (match !== null) {\n                  matchedImage = match[0];\n                  if (match.payload !== void 0) {\n                    payload = match.payload;\n                  }\n                } else {\n                  matchedImage = null;\n                }\n              } else {\n                this.updateLastIndex(currPattern, offset);\n                matchedImage = this.match(currPattern, text, offset);\n              }\n              if (matchedImage !== null) {\n                longerAlt = currConfig.longerAlt;\n                if (longerAlt !== void 0) {\n                  var longerAltLength = longerAlt.length;\n                  for (k = 0; k < longerAltLength; k++) {\n                    var longerAltConfig = patternIdxToConfig[longerAlt[k]];\n                    var longerAltPattern = longerAltConfig.pattern;\n                    altPayload = null;\n                    if (longerAltConfig.isCustom === true) {\n                      match = longerAltPattern.exec(orgText, offset, matchedTokens, groups);\n                      if (match !== null) {\n                        matchAltImage = match[0];\n                        if (match.payload !== void 0) {\n                          altPayload = match.payload;\n                        }\n                      } else {\n                        matchAltImage = null;\n                      }\n                    } else {\n                      this.updateLastIndex(longerAltPattern, offset);\n                      matchAltImage = this.match(longerAltPattern, text, offset);\n                    }\n                    if (matchAltImage && matchAltImage.length > matchedImage.length) {\n                      matchedImage = matchAltImage;\n                      payload = altPayload;\n                      currConfig = longerAltConfig;\n                      break;\n                    }\n                  }\n                }\n                break;\n              }\n            }\n            if (matchedImage !== null) {\n              imageLength = matchedImage.length;\n              group = currConfig.group;\n              if (group !== void 0) {\n                tokType = currConfig.tokenTypeIdx;\n                newToken = this.createTokenInstance(matchedImage, offset, tokType, currConfig.tokenType, line, column, imageLength);\n                this.handlePayload(newToken, payload);\n                if (group === false) {\n                  matchedTokensIndex = this.addToken(matchedTokens, matchedTokensIndex, newToken);\n                } else {\n                  groups[group].push(newToken);\n                }\n              }\n              text = this.chopInput(text, imageLength);\n              offset = offset + imageLength;\n              column = this.computeNewColumn(column, imageLength);\n              if (trackLines === true && currConfig.canLineTerminator === true) {\n                var numOfLTsInMatch = 0;\n                var foundTerminator = void 0;\n                var lastLTEndOffset = void 0;\n                lineTerminatorPattern.lastIndex = 0;\n                do {\n                  foundTerminator = lineTerminatorPattern.test(matchedImage);\n                  if (foundTerminator === true) {\n                    lastLTEndOffset = lineTerminatorPattern.lastIndex - 1;\n                    numOfLTsInMatch++;\n                  }\n                } while (foundTerminator === true);\n                if (numOfLTsInMatch !== 0) {\n                  line = line + numOfLTsInMatch;\n                  column = imageLength - lastLTEndOffset;\n                  this.updateTokenEndLineColumnLocation(newToken, group, lastLTEndOffset, numOfLTsInMatch, line, column, imageLength);\n                }\n              }\n              this.handleModes(currConfig, pop_mode, push_mode, newToken);\n            } else {\n              var errorStartOffset = offset;\n              var errorLine = line;\n              var errorColumn = column;\n              var foundResyncPoint = recoveryEnabled === false;\n              while (foundResyncPoint === false && offset < orgLength) {\n                text = this.chopInput(text, 1);\n                offset++;\n                for (j = 0; j < currModePatternsLength; j++) {\n                  var currConfig2 = patternIdxToConfig[j];\n                  var _currPattern = currConfig2.pattern;\n                  var _singleCharCode = currConfig2.short;\n                  if (_singleCharCode !== false) {\n                    if (orgText.charCodeAt(offset) === _singleCharCode) {\n                      foundResyncPoint = true;\n                    }\n                  } else if (currConfig2.isCustom === true) {\n                    foundResyncPoint = _currPattern.exec(orgText, offset, matchedTokens, groups) !== null;\n                  } else {\n                    this.updateLastIndex(_currPattern, offset);\n                    foundResyncPoint = _currPattern.exec(text) !== null;\n                  }\n                  if (foundResyncPoint === true) {\n                    break;\n                  }\n                }\n              }\n              errLength = offset - errorStartOffset;\n              column = this.computeNewColumn(column, errLength);\n              msg = this.config.errorMessageProvider.buildUnexpectedCharactersMessage(orgText, errorStartOffset, errLength, errorLine, errorColumn);\n              errors.push({\n                offset: errorStartOffset,\n                line: errorLine,\n                column: errorColumn,\n                length: errLength,\n                message: msg\n              });\n              if (recoveryEnabled === false) {\n                break;\n              }\n            }\n          }\n          if (!this.hasCustom) {\n            matchedTokens.length = matchedTokensIndex;\n          }\n          return {\n            tokens: matchedTokens,\n            groups: groups,\n            errors: errors\n          };\n        }\n      }, {\n        key: \"handleModes\",\n        value: function handleModes(config, pop_mode, push_mode, newToken) {\n          if (config.pop === true) {\n            var pushMode = config.push;\n            pop_mode(newToken);\n            if (pushMode !== void 0) {\n              push_mode.call(this, pushMode);\n            }\n          } else if (config.push !== void 0) {\n            push_mode.call(this, config.push);\n          }\n        }\n      }, {\n        key: \"chopInput\",\n        value: function chopInput(text, length) {\n          return text.substring(length);\n        }\n      }, {\n        key: \"updateLastIndex\",\n        value: function updateLastIndex(regExp, newLastIndex) {\n          regExp.lastIndex = newLastIndex;\n        }\n        // TODO: decrease this under 600 characters? inspect stripping comments option in TSC compiler\n      }, {\n        key: \"updateTokenEndLineColumnLocation\",\n        value: function updateTokenEndLineColumnLocation(newToken, group, lastLTIdx, numOfLTsInMatch, line, column, imageLength) {\n          var lastCharIsLT, fixForEndingInLT;\n          if (group !== void 0) {\n            lastCharIsLT = lastLTIdx === imageLength - 1;\n            fixForEndingInLT = lastCharIsLT ? -1 : 0;\n            if (!(numOfLTsInMatch === 1 && lastCharIsLT === true)) {\n              newToken.endLine = line + fixForEndingInLT;\n              newToken.endColumn = column - 1 + -fixForEndingInLT;\n            }\n          }\n        }\n      }, {\n        key: \"computeNewColumn\",\n        value: function computeNewColumn(oldColumn, imageLength) {\n          return oldColumn + imageLength;\n        }\n      }, {\n        key: \"createOffsetOnlyToken\",\n        value: function createOffsetOnlyToken(image, startOffset, tokenTypeIdx, tokenType) {\n          return {\n            image: image,\n            startOffset: startOffset,\n            tokenTypeIdx: tokenTypeIdx,\n            tokenType: tokenType\n          };\n        }\n      }, {\n        key: \"createStartOnlyToken\",\n        value: function createStartOnlyToken(image, startOffset, tokenTypeIdx, tokenType, startLine, startColumn) {\n          return {\n            image: image,\n            startOffset: startOffset,\n            startLine: startLine,\n            startColumn: startColumn,\n            tokenTypeIdx: tokenTypeIdx,\n            tokenType: tokenType\n          };\n        }\n      }, {\n        key: \"createFullToken\",\n        value: function createFullToken(image, startOffset, tokenTypeIdx, tokenType, startLine, startColumn, imageLength) {\n          return {\n            image: image,\n            startOffset: startOffset,\n            endOffset: startOffset + imageLength - 1,\n            startLine: startLine,\n            endLine: startLine,\n            startColumn: startColumn,\n            endColumn: startColumn + imageLength - 1,\n            tokenTypeIdx: tokenTypeIdx,\n            tokenType: tokenType\n          };\n        }\n      }, {\n        key: \"addTokenUsingPush\",\n        value: function addTokenUsingPush(tokenVector, index, tokenToAdd) {\n          tokenVector.push(tokenToAdd);\n          return index;\n        }\n      }, {\n        key: \"addTokenUsingMemberAccess\",\n        value: function addTokenUsingMemberAccess(tokenVector, index, tokenToAdd) {\n          tokenVector[index] = tokenToAdd;\n          index++;\n          return index;\n        }\n      }, {\n        key: \"handlePayloadNoCustom\",\n        value: function handlePayloadNoCustom(token, payload) {}\n      }, {\n        key: \"handlePayloadWithCustom\",\n        value: function handlePayloadWithCustom(token, payload) {\n          if (payload !== null) {\n            token.payload = payload;\n          }\n        }\n      }, {\n        key: \"matchWithTest\",\n        value: function matchWithTest(pattern, text, offset) {\n          var found = pattern.test(text);\n          if (found === true) {\n            return text.substring(offset, pattern.lastIndex);\n          }\n          return null;\n        }\n      }, {\n        key: \"matchWithExec\",\n        value: function matchWithExec(pattern, text) {\n          var regExpArray = pattern.exec(text);\n          return regExpArray !== null ? regExpArray[0] : null;\n        }\n      }]);\n      return Lexer2;\n    }();\n    Lexer2.SKIPPED = \"This marks a skipped Token pattern, this means each token identified by it willbe consumed and then thrown into oblivion, this can be used to for example to completely ignore whitespace.\";\n    Lexer2.NA = /NOT_APPLICABLE/;\n    function tokenLabel(tokType) {\n      if (hasTokenLabel(tokType)) {\n        return tokType.LABEL;\n      } else {\n        return tokType.name;\n      }\n    }\n    function hasTokenLabel(obj) {\n      return isString(obj.LABEL) && obj.LABEL !== \"\";\n    }\n    var PARENT = \"parent\";\n    var CATEGORIES = \"categories\";\n    var LABEL = \"label\";\n    var GROUP = \"group\";\n    var PUSH_MODE = \"push_mode\";\n    var POP_MODE = \"pop_mode\";\n    var LONGER_ALT = \"longer_alt\";\n    var LINE_BREAKS = \"line_breaks\";\n    var START_CHARS_HINT = \"start_chars_hint\";\n    function createToken2(config) {\n      return createTokenInternal(config);\n    }\n    function createTokenInternal(config) {\n      var pattern = config.pattern;\n      var tokenType = {};\n      tokenType.name = config.name;\n      if (!isUndefined(pattern)) {\n        tokenType.PATTERN = pattern;\n      }\n      if (has(config, PARENT)) {\n        throw \"The parent property is no longer supported.\\nSee: https://github.com/chevrotain/chevrotain/issues/564#issuecomment-349062346 for details.\";\n      }\n      if (has(config, CATEGORIES)) {\n        tokenType.CATEGORIES = config[CATEGORIES];\n      }\n      augmentTokenTypes([tokenType]);\n      if (has(config, LABEL)) {\n        tokenType.LABEL = config[LABEL];\n      }\n      if (has(config, GROUP)) {\n        tokenType.GROUP = config[GROUP];\n      }\n      if (has(config, POP_MODE)) {\n        tokenType.POP_MODE = config[POP_MODE];\n      }\n      if (has(config, PUSH_MODE)) {\n        tokenType.PUSH_MODE = config[PUSH_MODE];\n      }\n      if (has(config, LONGER_ALT)) {\n        tokenType.LONGER_ALT = config[LONGER_ALT];\n      }\n      if (has(config, LINE_BREAKS)) {\n        tokenType.LINE_BREAKS = config[LINE_BREAKS];\n      }\n      if (has(config, START_CHARS_HINT)) {\n        tokenType.START_CHARS_HINT = config[START_CHARS_HINT];\n      }\n      return tokenType;\n    }\n    var EOF = createToken2({\n      name: \"EOF\",\n      pattern: Lexer2.NA\n    });\n    augmentTokenTypes([EOF]);\n    function createTokenInstance(tokType, image, startOffset, endOffset, startLine, endLine, startColumn, endColumn) {\n      return {\n        image: image,\n        startOffset: startOffset,\n        endOffset: endOffset,\n        startLine: startLine,\n        endLine: endLine,\n        startColumn: startColumn,\n        endColumn: endColumn,\n        tokenTypeIdx: tokType.tokenTypeIdx,\n        tokenType: tokType\n      };\n    }\n    function tokenMatcher(token, tokType) {\n      return tokenStructuredMatcher(token, tokType);\n    }\n    var defaultParserErrorProvider = {\n      buildMismatchTokenMessage: function buildMismatchTokenMessage(_ref3) {\n        var expected = _ref3.expected,\n          actual = _ref3.actual,\n          previous = _ref3.previous,\n          ruleName = _ref3.ruleName;\n        var hasLabel = hasTokenLabel(expected);\n        var expectedMsg = hasLabel ? \"--> \".concat(tokenLabel(expected), \" <--\") : \"token of type --> \".concat(expected.name, \" <--\");\n        var msg = \"Expecting \".concat(expectedMsg, \" but found --> '\").concat(actual.image, \"' <--\");\n        return msg;\n      },\n      buildNotAllInputParsedMessage: function buildNotAllInputParsedMessage(_ref4) {\n        var firstRedundant = _ref4.firstRedundant,\n          ruleName = _ref4.ruleName;\n        return \"Redundant input, expecting EOF but found: \" + firstRedundant.image;\n      },\n      buildNoViableAltMessage: function buildNoViableAltMessage(_ref5) {\n        var expectedPathsPerAlt = _ref5.expectedPathsPerAlt,\n          actual = _ref5.actual,\n          previous = _ref5.previous,\n          customUserDescription = _ref5.customUserDescription,\n          ruleName = _ref5.ruleName;\n        var errPrefix = \"Expecting: \";\n        var actualText = head(actual).image;\n        var errSuffix = \"\\nbut found: '\" + actualText + \"'\";\n        if (customUserDescription) {\n          return errPrefix + customUserDescription + errSuffix;\n        } else {\n          var allLookAheadPaths = reduce(expectedPathsPerAlt, function (result, currAltPaths) {\n            return result.concat(currAltPaths);\n          }, []);\n          var nextValidTokenSequences = map(allLookAheadPaths, function (currPath) {\n            return \"[\".concat(map(currPath, function (currTokenType) {\n              return tokenLabel(currTokenType);\n            }).join(\", \"), \"]\");\n          });\n          var nextValidSequenceItems = map(nextValidTokenSequences, function (itemMsg, idx) {\n            return \"  \".concat(idx + 1, \". \").concat(itemMsg);\n          });\n          var calculatedDescription = \"one of these possible Token sequences:\\n\".concat(nextValidSequenceItems.join(\"\\n\"));\n          return errPrefix + calculatedDescription + errSuffix;\n        }\n      },\n      buildEarlyExitMessage: function buildEarlyExitMessage(_ref6) {\n        var expectedIterationPaths = _ref6.expectedIterationPaths,\n          actual = _ref6.actual,\n          customUserDescription = _ref6.customUserDescription,\n          ruleName = _ref6.ruleName;\n        var errPrefix = \"Expecting: \";\n        var actualText = head(actual).image;\n        var errSuffix = \"\\nbut found: '\" + actualText + \"'\";\n        if (customUserDescription) {\n          return errPrefix + customUserDescription + errSuffix;\n        } else {\n          var nextValidTokenSequences = map(expectedIterationPaths, function (currPath) {\n            return \"[\".concat(map(currPath, function (currTokenType) {\n              return tokenLabel(currTokenType);\n            }).join(\",\"), \"]\");\n          });\n          var calculatedDescription = \"expecting at least one iteration which starts with one of these possible Token sequences::\\n  <\".concat(nextValidTokenSequences.join(\" ,\"), \">\");\n          return errPrefix + calculatedDescription + errSuffix;\n        }\n      }\n    };\n    Object.freeze(defaultParserErrorProvider);\n    var defaultGrammarResolverErrorProvider = {\n      buildRuleNotFoundError: function buildRuleNotFoundError(topLevelRule, undefinedRule) {\n        var msg = \"Invalid grammar, reference to a rule which is not defined: ->\" + undefinedRule.nonTerminalName + \"<-\\ninside top level rule: ->\" + topLevelRule.name + \"<-\";\n        return msg;\n      }\n    };\n    var defaultGrammarValidatorErrorProvider = {\n      buildDuplicateFoundError: function buildDuplicateFoundError(topLevelRule, duplicateProds) {\n        function getExtraProductionArgument2(prod) {\n          if (prod instanceof Terminal) {\n            return prod.terminalType.name;\n          } else if (prod instanceof NonTerminal) {\n            return prod.nonTerminalName;\n          } else {\n            return \"\";\n          }\n        }\n        var topLevelName = topLevelRule.name;\n        var duplicateProd = head(duplicateProds);\n        var index = duplicateProd.idx;\n        var dslName = getProductionDslName(duplicateProd);\n        var extraArgument = getExtraProductionArgument2(duplicateProd);\n        var hasExplicitIndex = index > 0;\n        var msg = \"->\".concat(dslName).concat(hasExplicitIndex ? index : \"\", \"<- \").concat(extraArgument ? \"with argument: ->\".concat(extraArgument, \"<-\") : \"\", \"\\n                  appears more than once (\").concat(duplicateProds.length, \" times) in the top level rule: ->\").concat(topLevelName, \"<-.                  \\n                  For further details see: https://chevrotain.io/docs/FAQ.html#NUMERICAL_SUFFIXES \\n                  \");\n        msg = msg.replace(/[ \\t]+/g, \" \");\n        msg = msg.replace(/\\s\\s+/g, \"\\n\");\n        return msg;\n      },\n      buildNamespaceConflictError: function buildNamespaceConflictError(rule) {\n        var errMsg = \"Namespace conflict found in grammar.\\nThe grammar has both a Terminal(Token) and a Non-Terminal(Rule) named: <\".concat(rule.name, \">.\\nTo resolve this make sure each Terminal and Non-Terminal names are unique\\nThis is easy to accomplish by using the convention that Terminal names start with an uppercase letter\\nand Non-Terminal names start with a lower case letter.\");\n        return errMsg;\n      },\n      buildAlternationPrefixAmbiguityError: function buildAlternationPrefixAmbiguityError(options) {\n        var pathMsg = map(options.prefixPath, function (currTok) {\n          return tokenLabel(currTok);\n        }).join(\", \");\n        var occurrence = options.alternation.idx === 0 ? \"\" : options.alternation.idx;\n        var errMsg = \"Ambiguous alternatives: <\".concat(options.ambiguityIndices.join(\" ,\"), \"> due to common lookahead prefix\\nin <OR\").concat(occurrence, \"> inside <\").concat(options.topLevelRule.name, \"> Rule,\\n<\").concat(pathMsg, \"> may appears as a prefix path in all these alternatives.\\nSee: https://chevrotain.io/docs/guide/resolving_grammar_errors.html#COMMON_PREFIX\\nFor Further details.\");\n        return errMsg;\n      },\n      buildAlternationAmbiguityError: function buildAlternationAmbiguityError(options) {\n        var pathMsg = map(options.prefixPath, function (currtok) {\n          return tokenLabel(currtok);\n        }).join(\", \");\n        var occurrence = options.alternation.idx === 0 ? \"\" : options.alternation.idx;\n        var currMessage = \"Ambiguous Alternatives Detected: <\".concat(options.ambiguityIndices.join(\" ,\"), \"> in <OR\").concat(occurrence, \"> inside <\").concat(options.topLevelRule.name, \"> Rule,\\n<\").concat(pathMsg, \"> may appears as a prefix path in all these alternatives.\\n\");\n        currMessage = currMessage + \"See: https://chevrotain.io/docs/guide/resolving_grammar_errors.html#AMBIGUOUS_ALTERNATIVES\\nFor Further details.\";\n        return currMessage;\n      },\n      buildEmptyRepetitionError: function buildEmptyRepetitionError(options) {\n        var dslName = getProductionDslName(options.repetition);\n        if (options.repetition.idx !== 0) {\n          dslName += options.repetition.idx;\n        }\n        var errMsg = \"The repetition <\".concat(dslName, \"> within Rule <\").concat(options.topLevelRule.name, \"> can never consume any tokens.\\nThis could lead to an infinite loop.\");\n        return errMsg;\n      },\n      // TODO: remove - `errors_public` from nyc.config.js exclude\n      //       once this method is fully removed from this file\n      buildTokenNameError: function buildTokenNameError(options) {\n        return \"deprecated\";\n      },\n      buildEmptyAlternationError: function buildEmptyAlternationError(options) {\n        var errMsg = \"Ambiguous empty alternative: <\".concat(options.emptyChoiceIdx + 1, \"> in <OR\").concat(options.alternation.idx, \"> inside <\").concat(options.topLevelRule.name, \"> Rule.\\nOnly the last alternative may be an empty alternative.\");\n        return errMsg;\n      },\n      buildTooManyAlternativesError: function buildTooManyAlternativesError(options) {\n        var errMsg = \"An Alternation cannot have more than 256 alternatives:\\n<OR\".concat(options.alternation.idx, \"> inside <\").concat(options.topLevelRule.name, \"> Rule.\\n has \").concat(options.alternation.definition.length + 1, \" alternatives.\");\n        return errMsg;\n      },\n      buildLeftRecursionError: function buildLeftRecursionError(options) {\n        var ruleName = options.topLevelRule.name;\n        var pathNames = map(options.leftRecursionPath, function (currRule) {\n          return currRule.name;\n        });\n        var leftRecursivePath = \"\".concat(ruleName, \" --> \").concat(pathNames.concat([ruleName]).join(\" --> \"));\n        var errMsg = \"Left Recursion found in grammar.\\nrule: <\".concat(ruleName, \"> can be invoked from itself (directly or indirectly)\\nwithout consuming any Tokens. The grammar path that causes this is: \\n \").concat(leftRecursivePath, \"\\n To fix this refactor your grammar to remove the left recursion.\\nsee: https://en.wikipedia.org/wiki/LL_parser#Left_factoring.\");\n        return errMsg;\n      },\n      // TODO: remove - `errors_public` from nyc.config.js exclude\n      //       once this method is fully removed from this file\n      buildInvalidRuleNameError: function buildInvalidRuleNameError(options) {\n        return \"deprecated\";\n      },\n      buildDuplicateRuleNameError: function buildDuplicateRuleNameError(options) {\n        var ruleName;\n        if (options.topLevelRule instanceof Rule) {\n          ruleName = options.topLevelRule.name;\n        } else {\n          ruleName = options.topLevelRule;\n        }\n        var errMsg = \"Duplicate definition, rule: ->\".concat(ruleName, \"<- is already defined in the grammar: ->\").concat(options.grammarName, \"<-\");\n        return errMsg;\n      }\n    };\n    function resolveGrammar$1(topLevels, errMsgProvider) {\n      var refResolver = new GastRefResolverVisitor(topLevels, errMsgProvider);\n      refResolver.resolveRefs();\n      return refResolver.errors;\n    }\n    var GastRefResolverVisitor = /*#__PURE__*/function (_GAstVisitor) {\n      _inherits(GastRefResolverVisitor, _GAstVisitor);\n      var _super14 = _createSuper(GastRefResolverVisitor);\n      function GastRefResolverVisitor(nameToTopRule, errMsgProvider) {\n        var _this19;\n        _classCallCheck(this, GastRefResolverVisitor);\n        _this19 = _super14.call(this);\n        _this19.nameToTopRule = nameToTopRule;\n        _this19.errMsgProvider = errMsgProvider;\n        _this19.errors = [];\n        return _this19;\n      }\n      _createClass(GastRefResolverVisitor, [{\n        key: \"resolveRefs\",\n        value: function resolveRefs() {\n          var _this20 = this;\n          forEach(values(this.nameToTopRule), function (prod) {\n            _this20.currTopLevel = prod;\n            prod.accept(_this20);\n          });\n        }\n      }, {\n        key: \"visitNonTerminal\",\n        value: function visitNonTerminal(node) {\n          var ref = this.nameToTopRule[node.nonTerminalName];\n          if (!ref) {\n            var msg = this.errMsgProvider.buildRuleNotFoundError(this.currTopLevel, node);\n            this.errors.push({\n              message: msg,\n              type: ParserDefinitionErrorType.UNRESOLVED_SUBRULE_REF,\n              ruleName: this.currTopLevel.name,\n              unresolvedRefName: node.nonTerminalName\n            });\n          } else {\n            node.referencedRule = ref;\n          }\n        }\n      }]);\n      return GastRefResolverVisitor;\n    }(GAstVisitor);\n    var AbstractNextPossibleTokensWalker = /*#__PURE__*/function (_RestWalker2) {\n      _inherits(AbstractNextPossibleTokensWalker, _RestWalker2);\n      var _super15 = _createSuper(AbstractNextPossibleTokensWalker);\n      function AbstractNextPossibleTokensWalker(topProd, path) {\n        var _this21;\n        _classCallCheck(this, AbstractNextPossibleTokensWalker);\n        _this21 = _super15.call(this);\n        _this21.topProd = topProd;\n        _this21.path = path;\n        _this21.possibleTokTypes = [];\n        _this21.nextProductionName = \"\";\n        _this21.nextProductionOccurrence = 0;\n        _this21.found = false;\n        _this21.isAtEndOfPath = false;\n        return _this21;\n      }\n      _createClass(AbstractNextPossibleTokensWalker, [{\n        key: \"startWalking\",\n        value: function startWalking() {\n          this.found = false;\n          if (this.path.ruleStack[0] !== this.topProd.name) {\n            throw Error(\"The path does not start with the walker's top Rule!\");\n          }\n          this.ruleStack = clone(this.path.ruleStack).reverse();\n          this.occurrenceStack = clone(this.path.occurrenceStack).reverse();\n          this.ruleStack.pop();\n          this.occurrenceStack.pop();\n          this.updateExpectedNext();\n          this.walk(this.topProd);\n          return this.possibleTokTypes;\n        }\n      }, {\n        key: \"walk\",\n        value: function walk(prod) {\n          var prevRest = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n          if (!this.found) {\n            _get(_getPrototypeOf(AbstractNextPossibleTokensWalker.prototype), \"walk\", this).call(this, prod, prevRest);\n          }\n        }\n      }, {\n        key: \"walkProdRef\",\n        value: function walkProdRef(refProd, currRest, prevRest) {\n          if (refProd.referencedRule.name === this.nextProductionName && refProd.idx === this.nextProductionOccurrence) {\n            var fullRest = currRest.concat(prevRest);\n            this.updateExpectedNext();\n            this.walk(refProd.referencedRule, fullRest);\n          }\n        }\n      }, {\n        key: \"updateExpectedNext\",\n        value: function updateExpectedNext() {\n          if (isEmpty(this.ruleStack)) {\n            this.nextProductionName = \"\";\n            this.nextProductionOccurrence = 0;\n            this.isAtEndOfPath = true;\n          } else {\n            this.nextProductionName = this.ruleStack.pop();\n            this.nextProductionOccurrence = this.occurrenceStack.pop();\n          }\n        }\n      }]);\n      return AbstractNextPossibleTokensWalker;\n    }(RestWalker);\n    var NextAfterTokenWalker = /*#__PURE__*/function (_AbstractNextPossible) {\n      _inherits(NextAfterTokenWalker, _AbstractNextPossible);\n      var _super16 = _createSuper(NextAfterTokenWalker);\n      function NextAfterTokenWalker(topProd, path) {\n        var _this22;\n        _classCallCheck(this, NextAfterTokenWalker);\n        _this22 = _super16.call(this, topProd, path);\n        _this22.path = path;\n        _this22.nextTerminalName = \"\";\n        _this22.nextTerminalOccurrence = 0;\n        _this22.nextTerminalName = _this22.path.lastTok.name;\n        _this22.nextTerminalOccurrence = _this22.path.lastTokOccurrence;\n        return _this22;\n      }\n      _createClass(NextAfterTokenWalker, [{\n        key: \"walkTerminal\",\n        value: function walkTerminal(terminal, currRest, prevRest) {\n          if (this.isAtEndOfPath && terminal.terminalType.name === this.nextTerminalName && terminal.idx === this.nextTerminalOccurrence && !this.found) {\n            var fullRest = currRest.concat(prevRest);\n            var restProd = new Alternative({\n              definition: fullRest\n            });\n            this.possibleTokTypes = first(restProd);\n            this.found = true;\n          }\n        }\n      }]);\n      return NextAfterTokenWalker;\n    }(AbstractNextPossibleTokensWalker);\n    var AbstractNextTerminalAfterProductionWalker = /*#__PURE__*/function (_RestWalker3) {\n      _inherits(AbstractNextTerminalAfterProductionWalker, _RestWalker3);\n      var _super17 = _createSuper(AbstractNextTerminalAfterProductionWalker);\n      function AbstractNextTerminalAfterProductionWalker(topRule, occurrence) {\n        var _this23;\n        _classCallCheck(this, AbstractNextTerminalAfterProductionWalker);\n        _this23 = _super17.call(this);\n        _this23.topRule = topRule;\n        _this23.occurrence = occurrence;\n        _this23.result = {\n          token: void 0,\n          occurrence: void 0,\n          isEndOfRule: void 0\n        };\n        return _this23;\n      }\n      _createClass(AbstractNextTerminalAfterProductionWalker, [{\n        key: \"startWalking\",\n        value: function startWalking() {\n          this.walk(this.topRule);\n          return this.result;\n        }\n      }]);\n      return AbstractNextTerminalAfterProductionWalker;\n    }(RestWalker);\n    var NextTerminalAfterManyWalker = /*#__PURE__*/function (_AbstractNextTerminal) {\n      _inherits(NextTerminalAfterManyWalker, _AbstractNextTerminal);\n      var _super18 = _createSuper(NextTerminalAfterManyWalker);\n      function NextTerminalAfterManyWalker() {\n        _classCallCheck(this, NextTerminalAfterManyWalker);\n        return _super18.apply(this, arguments);\n      }\n      _createClass(NextTerminalAfterManyWalker, [{\n        key: \"walkMany\",\n        value: function walkMany(manyProd, currRest, prevRest) {\n          if (manyProd.idx === this.occurrence) {\n            var firstAfterMany = head(currRest.concat(prevRest));\n            this.result.isEndOfRule = firstAfterMany === void 0;\n            if (firstAfterMany instanceof Terminal) {\n              this.result.token = firstAfterMany.terminalType;\n              this.result.occurrence = firstAfterMany.idx;\n            }\n          } else {\n            _get(_getPrototypeOf(NextTerminalAfterManyWalker.prototype), \"walkMany\", this).call(this, manyProd, currRest, prevRest);\n          }\n        }\n      }]);\n      return NextTerminalAfterManyWalker;\n    }(AbstractNextTerminalAfterProductionWalker);\n    var NextTerminalAfterManySepWalker = /*#__PURE__*/function (_AbstractNextTerminal2) {\n      _inherits(NextTerminalAfterManySepWalker, _AbstractNextTerminal2);\n      var _super19 = _createSuper(NextTerminalAfterManySepWalker);\n      function NextTerminalAfterManySepWalker() {\n        _classCallCheck(this, NextTerminalAfterManySepWalker);\n        return _super19.apply(this, arguments);\n      }\n      _createClass(NextTerminalAfterManySepWalker, [{\n        key: \"walkManySep\",\n        value: function walkManySep(manySepProd, currRest, prevRest) {\n          if (manySepProd.idx === this.occurrence) {\n            var firstAfterManySep = head(currRest.concat(prevRest));\n            this.result.isEndOfRule = firstAfterManySep === void 0;\n            if (firstAfterManySep instanceof Terminal) {\n              this.result.token = firstAfterManySep.terminalType;\n              this.result.occurrence = firstAfterManySep.idx;\n            }\n          } else {\n            _get(_getPrototypeOf(NextTerminalAfterManySepWalker.prototype), \"walkManySep\", this).call(this, manySepProd, currRest, prevRest);\n          }\n        }\n      }]);\n      return NextTerminalAfterManySepWalker;\n    }(AbstractNextTerminalAfterProductionWalker);\n    var NextTerminalAfterAtLeastOneWalker = /*#__PURE__*/function (_AbstractNextTerminal3) {\n      _inherits(NextTerminalAfterAtLeastOneWalker, _AbstractNextTerminal3);\n      var _super20 = _createSuper(NextTerminalAfterAtLeastOneWalker);\n      function NextTerminalAfterAtLeastOneWalker() {\n        _classCallCheck(this, NextTerminalAfterAtLeastOneWalker);\n        return _super20.apply(this, arguments);\n      }\n      _createClass(NextTerminalAfterAtLeastOneWalker, [{\n        key: \"walkAtLeastOne\",\n        value: function walkAtLeastOne(atLeastOneProd, currRest, prevRest) {\n          if (atLeastOneProd.idx === this.occurrence) {\n            var firstAfterAtLeastOne = head(currRest.concat(prevRest));\n            this.result.isEndOfRule = firstAfterAtLeastOne === void 0;\n            if (firstAfterAtLeastOne instanceof Terminal) {\n              this.result.token = firstAfterAtLeastOne.terminalType;\n              this.result.occurrence = firstAfterAtLeastOne.idx;\n            }\n          } else {\n            _get(_getPrototypeOf(NextTerminalAfterAtLeastOneWalker.prototype), \"walkAtLeastOne\", this).call(this, atLeastOneProd, currRest, prevRest);\n          }\n        }\n      }]);\n      return NextTerminalAfterAtLeastOneWalker;\n    }(AbstractNextTerminalAfterProductionWalker);\n    var NextTerminalAfterAtLeastOneSepWalker = /*#__PURE__*/function (_AbstractNextTerminal4) {\n      _inherits(NextTerminalAfterAtLeastOneSepWalker, _AbstractNextTerminal4);\n      var _super21 = _createSuper(NextTerminalAfterAtLeastOneSepWalker);\n      function NextTerminalAfterAtLeastOneSepWalker() {\n        _classCallCheck(this, NextTerminalAfterAtLeastOneSepWalker);\n        return _super21.apply(this, arguments);\n      }\n      _createClass(NextTerminalAfterAtLeastOneSepWalker, [{\n        key: \"walkAtLeastOneSep\",\n        value: function walkAtLeastOneSep(atleastOneSepProd, currRest, prevRest) {\n          if (atleastOneSepProd.idx === this.occurrence) {\n            var firstAfterfirstAfterAtLeastOneSep = head(currRest.concat(prevRest));\n            this.result.isEndOfRule = firstAfterfirstAfterAtLeastOneSep === void 0;\n            if (firstAfterfirstAfterAtLeastOneSep instanceof Terminal) {\n              this.result.token = firstAfterfirstAfterAtLeastOneSep.terminalType;\n              this.result.occurrence = firstAfterfirstAfterAtLeastOneSep.idx;\n            }\n          } else {\n            _get(_getPrototypeOf(NextTerminalAfterAtLeastOneSepWalker.prototype), \"walkAtLeastOneSep\", this).call(this, atleastOneSepProd, currRest, prevRest);\n          }\n        }\n      }]);\n      return NextTerminalAfterAtLeastOneSepWalker;\n    }(AbstractNextTerminalAfterProductionWalker);\n    function possiblePathsFrom(targetDef, maxLength) {\n      var currPath = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n      currPath = clone(currPath);\n      var result = [];\n      var i = 0;\n      function remainingPathWith(nextDef) {\n        return nextDef.concat(drop(targetDef, i + 1));\n      }\n      function getAlternativesForProd(definition) {\n        var alternatives = possiblePathsFrom(remainingPathWith(definition), maxLength, currPath);\n        return result.concat(alternatives);\n      }\n      while (currPath.length < maxLength && i < targetDef.length) {\n        var prod = targetDef[i];\n        if (prod instanceof Alternative) {\n          return getAlternativesForProd(prod.definition);\n        } else if (prod instanceof NonTerminal) {\n          return getAlternativesForProd(prod.definition);\n        } else if (prod instanceof Option) {\n          result = getAlternativesForProd(prod.definition);\n        } else if (prod instanceof RepetitionMandatory) {\n          var newDef = prod.definition.concat([new Repetition({\n            definition: prod.definition\n          })]);\n          return getAlternativesForProd(newDef);\n        } else if (prod instanceof RepetitionMandatoryWithSeparator) {\n          var _newDef = [new Alternative({\n            definition: prod.definition\n          }), new Repetition({\n            definition: [new Terminal({\n              terminalType: prod.separator\n            })].concat(prod.definition)\n          })];\n          return getAlternativesForProd(_newDef);\n        } else if (prod instanceof RepetitionWithSeparator) {\n          var _newDef2 = prod.definition.concat([new Repetition({\n            definition: [new Terminal({\n              terminalType: prod.separator\n            })].concat(prod.definition)\n          })]);\n          result = getAlternativesForProd(_newDef2);\n        } else if (prod instanceof Repetition) {\n          var _newDef3 = prod.definition.concat([new Repetition({\n            definition: prod.definition\n          })]);\n          result = getAlternativesForProd(_newDef3);\n        } else if (prod instanceof Alternation) {\n          forEach(prod.definition, function (currAlt) {\n            if (isEmpty(currAlt.definition) === false) {\n              result = getAlternativesForProd(currAlt.definition);\n            }\n          });\n          return result;\n        } else if (prod instanceof Terminal) {\n          currPath.push(prod.terminalType);\n        } else {\n          throw Error(\"non exhaustive match\");\n        }\n        i++;\n      }\n      result.push({\n        partialPath: currPath,\n        suffixDef: drop(targetDef, i)\n      });\n      return result;\n    }\n    function nextPossibleTokensAfter(initialDef, tokenVector, tokMatcher, maxLookAhead) {\n      var EXIT_NON_TERMINAL = \"EXIT_NONE_TERMINAL\";\n      var EXIT_NON_TERMINAL_ARR = [EXIT_NON_TERMINAL];\n      var EXIT_ALTERNATIVE = \"EXIT_ALTERNATIVE\";\n      var foundCompletePath = false;\n      var tokenVectorLength = tokenVector.length;\n      var minimalAlternativesIndex = tokenVectorLength - maxLookAhead - 1;\n      var result = [];\n      var possiblePaths = [];\n      possiblePaths.push({\n        idx: -1,\n        def: initialDef,\n        ruleStack: [],\n        occurrenceStack: []\n      });\n      while (!isEmpty(possiblePaths)) {\n        var currPath = possiblePaths.pop();\n        if (currPath === EXIT_ALTERNATIVE) {\n          if (foundCompletePath && last(possiblePaths).idx <= minimalAlternativesIndex) {\n            possiblePaths.pop();\n          }\n          continue;\n        }\n        var currDef = currPath.def;\n        var currIdx = currPath.idx;\n        var currRuleStack = currPath.ruleStack;\n        var currOccurrenceStack = currPath.occurrenceStack;\n        if (isEmpty(currDef)) {\n          continue;\n        }\n        var prod = currDef[0];\n        if (prod === EXIT_NON_TERMINAL) {\n          var nextPath = {\n            idx: currIdx,\n            def: drop(currDef),\n            ruleStack: dropRight(currRuleStack),\n            occurrenceStack: dropRight(currOccurrenceStack)\n          };\n          possiblePaths.push(nextPath);\n        } else if (prod instanceof Terminal) {\n          if (currIdx < tokenVectorLength - 1) {\n            var nextIdx = currIdx + 1;\n            var actualToken = tokenVector[nextIdx];\n            if (tokMatcher(actualToken, prod.terminalType)) {\n              var _nextPath = {\n                idx: nextIdx,\n                def: drop(currDef),\n                ruleStack: currRuleStack,\n                occurrenceStack: currOccurrenceStack\n              };\n              possiblePaths.push(_nextPath);\n            }\n          } else if (currIdx === tokenVectorLength - 1) {\n            result.push({\n              nextTokenType: prod.terminalType,\n              nextTokenOccurrence: prod.idx,\n              ruleStack: currRuleStack,\n              occurrenceStack: currOccurrenceStack\n            });\n            foundCompletePath = true;\n          } else {\n            throw Error(\"non exhaustive match\");\n          }\n        } else if (prod instanceof NonTerminal) {\n          var newRuleStack = clone(currRuleStack);\n          newRuleStack.push(prod.nonTerminalName);\n          var newOccurrenceStack = clone(currOccurrenceStack);\n          newOccurrenceStack.push(prod.idx);\n          var _nextPath2 = {\n            idx: currIdx,\n            def: prod.definition.concat(EXIT_NON_TERMINAL_ARR, drop(currDef)),\n            ruleStack: newRuleStack,\n            occurrenceStack: newOccurrenceStack\n          };\n          possiblePaths.push(_nextPath2);\n        } else if (prod instanceof Option) {\n          var nextPathWithout = {\n            idx: currIdx,\n            def: drop(currDef),\n            ruleStack: currRuleStack,\n            occurrenceStack: currOccurrenceStack\n          };\n          possiblePaths.push(nextPathWithout);\n          possiblePaths.push(EXIT_ALTERNATIVE);\n          var nextPathWith = {\n            idx: currIdx,\n            def: prod.definition.concat(drop(currDef)),\n            ruleStack: currRuleStack,\n            occurrenceStack: currOccurrenceStack\n          };\n          possiblePaths.push(nextPathWith);\n        } else if (prod instanceof RepetitionMandatory) {\n          var secondIteration = new Repetition({\n            definition: prod.definition,\n            idx: prod.idx\n          });\n          var nextDef = prod.definition.concat([secondIteration], drop(currDef));\n          var _nextPath3 = {\n            idx: currIdx,\n            def: nextDef,\n            ruleStack: currRuleStack,\n            occurrenceStack: currOccurrenceStack\n          };\n          possiblePaths.push(_nextPath3);\n        } else if (prod instanceof RepetitionMandatoryWithSeparator) {\n          var separatorGast = new Terminal({\n            terminalType: prod.separator\n          });\n          var _secondIteration = new Repetition({\n            definition: [separatorGast].concat(prod.definition),\n            idx: prod.idx\n          });\n          var _nextDef = prod.definition.concat([_secondIteration], drop(currDef));\n          var _nextPath4 = {\n            idx: currIdx,\n            def: _nextDef,\n            ruleStack: currRuleStack,\n            occurrenceStack: currOccurrenceStack\n          };\n          possiblePaths.push(_nextPath4);\n        } else if (prod instanceof RepetitionWithSeparator) {\n          var _nextPathWithout = {\n            idx: currIdx,\n            def: drop(currDef),\n            ruleStack: currRuleStack,\n            occurrenceStack: currOccurrenceStack\n          };\n          possiblePaths.push(_nextPathWithout);\n          possiblePaths.push(EXIT_ALTERNATIVE);\n          var _separatorGast = new Terminal({\n            terminalType: prod.separator\n          });\n          var nthRepetition = new Repetition({\n            definition: [_separatorGast].concat(prod.definition),\n            idx: prod.idx\n          });\n          var _nextDef2 = prod.definition.concat([nthRepetition], drop(currDef));\n          var _nextPathWith = {\n            idx: currIdx,\n            def: _nextDef2,\n            ruleStack: currRuleStack,\n            occurrenceStack: currOccurrenceStack\n          };\n          possiblePaths.push(_nextPathWith);\n        } else if (prod instanceof Repetition) {\n          var _nextPathWithout2 = {\n            idx: currIdx,\n            def: drop(currDef),\n            ruleStack: currRuleStack,\n            occurrenceStack: currOccurrenceStack\n          };\n          possiblePaths.push(_nextPathWithout2);\n          possiblePaths.push(EXIT_ALTERNATIVE);\n          var _nthRepetition = new Repetition({\n            definition: prod.definition,\n            idx: prod.idx\n          });\n          var _nextDef3 = prod.definition.concat([_nthRepetition], drop(currDef));\n          var _nextPathWith2 = {\n            idx: currIdx,\n            def: _nextDef3,\n            ruleStack: currRuleStack,\n            occurrenceStack: currOccurrenceStack\n          };\n          possiblePaths.push(_nextPathWith2);\n        } else if (prod instanceof Alternation) {\n          for (var _i8 = prod.definition.length - 1; _i8 >= 0; _i8--) {\n            var currAlt = prod.definition[_i8];\n            var currAltPath = {\n              idx: currIdx,\n              def: currAlt.definition.concat(drop(currDef)),\n              ruleStack: currRuleStack,\n              occurrenceStack: currOccurrenceStack\n            };\n            possiblePaths.push(currAltPath);\n            possiblePaths.push(EXIT_ALTERNATIVE);\n          }\n        } else if (prod instanceof Alternative) {\n          possiblePaths.push({\n            idx: currIdx,\n            def: prod.definition.concat(drop(currDef)),\n            ruleStack: currRuleStack,\n            occurrenceStack: currOccurrenceStack\n          });\n        } else if (prod instanceof Rule) {\n          possiblePaths.push(expandTopLevelRule(prod, currIdx, currRuleStack, currOccurrenceStack));\n        } else {\n          throw Error(\"non exhaustive match\");\n        }\n      }\n      return result;\n    }\n    function expandTopLevelRule(topRule, currIdx, currRuleStack, currOccurrenceStack) {\n      var newRuleStack = clone(currRuleStack);\n      newRuleStack.push(topRule.name);\n      var newCurrOccurrenceStack = clone(currOccurrenceStack);\n      newCurrOccurrenceStack.push(1);\n      return {\n        idx: currIdx,\n        def: topRule.definition,\n        ruleStack: newRuleStack,\n        occurrenceStack: newCurrOccurrenceStack\n      };\n    }\n    var PROD_TYPE;\n    (function (PROD_TYPE2) {\n      PROD_TYPE2[PROD_TYPE2[\"OPTION\"] = 0] = \"OPTION\";\n      PROD_TYPE2[PROD_TYPE2[\"REPETITION\"] = 1] = \"REPETITION\";\n      PROD_TYPE2[PROD_TYPE2[\"REPETITION_MANDATORY\"] = 2] = \"REPETITION_MANDATORY\";\n      PROD_TYPE2[PROD_TYPE2[\"REPETITION_MANDATORY_WITH_SEPARATOR\"] = 3] = \"REPETITION_MANDATORY_WITH_SEPARATOR\";\n      PROD_TYPE2[PROD_TYPE2[\"REPETITION_WITH_SEPARATOR\"] = 4] = \"REPETITION_WITH_SEPARATOR\";\n      PROD_TYPE2[PROD_TYPE2[\"ALTERNATION\"] = 5] = \"ALTERNATION\";\n    })(PROD_TYPE || (PROD_TYPE = {}));\n    function getProdType(prod) {\n      if (prod instanceof Option || prod === \"Option\") {\n        return PROD_TYPE.OPTION;\n      } else if (prod instanceof Repetition || prod === \"Repetition\") {\n        return PROD_TYPE.REPETITION;\n      } else if (prod instanceof RepetitionMandatory || prod === \"RepetitionMandatory\") {\n        return PROD_TYPE.REPETITION_MANDATORY;\n      } else if (prod instanceof RepetitionMandatoryWithSeparator || prod === \"RepetitionMandatoryWithSeparator\") {\n        return PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR;\n      } else if (prod instanceof RepetitionWithSeparator || prod === \"RepetitionWithSeparator\") {\n        return PROD_TYPE.REPETITION_WITH_SEPARATOR;\n      } else if (prod instanceof Alternation || prod === \"Alternation\") {\n        return PROD_TYPE.ALTERNATION;\n      } else {\n        throw Error(\"non exhaustive match\");\n      }\n    }\n    function buildLookaheadFuncForOr(occurrence, ruleGrammar, maxLookahead, hasPredicates, dynamicTokensEnabled, laFuncBuilder) {\n      var lookAheadPaths = getLookaheadPathsForOr(occurrence, ruleGrammar, maxLookahead);\n      var tokenMatcher2 = areTokenCategoriesNotUsed(lookAheadPaths) ? tokenStructuredMatcherNoCategories : tokenStructuredMatcher;\n      return laFuncBuilder(lookAheadPaths, hasPredicates, tokenMatcher2, dynamicTokensEnabled);\n    }\n    function buildLookaheadFuncForOptionalProd(occurrence, ruleGrammar, k, dynamicTokensEnabled, prodType, lookaheadBuilder) {\n      var lookAheadPaths = getLookaheadPathsForOptionalProd(occurrence, ruleGrammar, prodType, k);\n      var tokenMatcher2 = areTokenCategoriesNotUsed(lookAheadPaths) ? tokenStructuredMatcherNoCategories : tokenStructuredMatcher;\n      return lookaheadBuilder(lookAheadPaths[0], tokenMatcher2, dynamicTokensEnabled);\n    }\n    function buildAlternativesLookAheadFunc(alts, hasPredicates, tokenMatcher2, dynamicTokensEnabled) {\n      var numOfAlts = alts.length;\n      var areAllOneTokenLookahead = every(alts, function (currAlt) {\n        return every(currAlt, function (currPath) {\n          return currPath.length === 1;\n        });\n      });\n      if (hasPredicates) {\n        return function (orAlts) {\n          var predicates = map(orAlts, function (currAlt) {\n            return currAlt.GATE;\n          });\n          for (var t = 0; t < numOfAlts; t++) {\n            var currAlt = alts[t];\n            var currNumOfPaths = currAlt.length;\n            var currPredicate = predicates[t];\n            if (currPredicate !== void 0 && currPredicate.call(this) === false) {\n              continue;\n            }\n            nextPath: for (var j = 0; j < currNumOfPaths; j++) {\n              var currPath = currAlt[j];\n              var currPathLength = currPath.length;\n              for (var _i9 = 0; _i9 < currPathLength; _i9++) {\n                var nextToken = this.LA(_i9 + 1);\n                if (tokenMatcher2(nextToken, currPath[_i9]) === false) {\n                  continue nextPath;\n                }\n              }\n              return t;\n            }\n          }\n          return void 0;\n        };\n      } else if (areAllOneTokenLookahead && !dynamicTokensEnabled) {\n        var singleTokenAlts = map(alts, function (currAlt) {\n          return flatten(currAlt);\n        });\n        var choiceToAlt = reduce(singleTokenAlts, function (result, currAlt, idx) {\n          forEach(currAlt, function (currTokType) {\n            if (!has(result, currTokType.tokenTypeIdx)) {\n              result[currTokType.tokenTypeIdx] = idx;\n            }\n            forEach(currTokType.categoryMatches, function (currExtendingType) {\n              if (!has(result, currExtendingType)) {\n                result[currExtendingType] = idx;\n              }\n            });\n          });\n          return result;\n        }, {});\n        return function () {\n          var nextToken = this.LA(1);\n          return choiceToAlt[nextToken.tokenTypeIdx];\n        };\n      } else {\n        return function () {\n          for (var t = 0; t < numOfAlts; t++) {\n            var currAlt = alts[t];\n            var currNumOfPaths = currAlt.length;\n            nextPath: for (var j = 0; j < currNumOfPaths; j++) {\n              var currPath = currAlt[j];\n              var currPathLength = currPath.length;\n              for (var _i10 = 0; _i10 < currPathLength; _i10++) {\n                var nextToken = this.LA(_i10 + 1);\n                if (tokenMatcher2(nextToken, currPath[_i10]) === false) {\n                  continue nextPath;\n                }\n              }\n              return t;\n            }\n          }\n          return void 0;\n        };\n      }\n    }\n    function buildSingleAlternativeLookaheadFunction(alt, tokenMatcher2, dynamicTokensEnabled) {\n      var areAllOneTokenLookahead = every(alt, function (currPath) {\n        return currPath.length === 1;\n      });\n      var numOfPaths = alt.length;\n      if (areAllOneTokenLookahead && !dynamicTokensEnabled) {\n        var singleTokensTypes = flatten(alt);\n        if (singleTokensTypes.length === 1 && isEmpty(singleTokensTypes[0].categoryMatches)) {\n          var expectedTokenType = singleTokensTypes[0];\n          var expectedTokenUniqueKey = expectedTokenType.tokenTypeIdx;\n          return function () {\n            return this.LA(1).tokenTypeIdx === expectedTokenUniqueKey;\n          };\n        } else {\n          var choiceToAlt = reduce(singleTokensTypes, function (result, currTokType, idx) {\n            result[currTokType.tokenTypeIdx] = true;\n            forEach(currTokType.categoryMatches, function (currExtendingType) {\n              result[currExtendingType] = true;\n            });\n            return result;\n          }, []);\n          return function () {\n            var nextToken = this.LA(1);\n            return choiceToAlt[nextToken.tokenTypeIdx] === true;\n          };\n        }\n      } else {\n        return function () {\n          nextPath: for (var j = 0; j < numOfPaths; j++) {\n            var currPath = alt[j];\n            var currPathLength = currPath.length;\n            for (var _i11 = 0; _i11 < currPathLength; _i11++) {\n              var nextToken = this.LA(_i11 + 1);\n              if (tokenMatcher2(nextToken, currPath[_i11]) === false) {\n                continue nextPath;\n              }\n            }\n            return true;\n          }\n          return false;\n        };\n      }\n    }\n    var RestDefinitionFinderWalker = /*#__PURE__*/function (_RestWalker4) {\n      _inherits(RestDefinitionFinderWalker, _RestWalker4);\n      var _super22 = _createSuper(RestDefinitionFinderWalker);\n      function RestDefinitionFinderWalker(topProd, targetOccurrence, targetProdType) {\n        var _this24;\n        _classCallCheck(this, RestDefinitionFinderWalker);\n        _this24 = _super22.call(this);\n        _this24.topProd = topProd;\n        _this24.targetOccurrence = targetOccurrence;\n        _this24.targetProdType = targetProdType;\n        return _this24;\n      }\n      _createClass(RestDefinitionFinderWalker, [{\n        key: \"startWalking\",\n        value: function startWalking() {\n          this.walk(this.topProd);\n          return this.restDef;\n        }\n      }, {\n        key: \"checkIsTarget\",\n        value: function checkIsTarget(node, expectedProdType, currRest, prevRest) {\n          if (node.idx === this.targetOccurrence && this.targetProdType === expectedProdType) {\n            this.restDef = currRest.concat(prevRest);\n            return true;\n          }\n          return false;\n        }\n      }, {\n        key: \"walkOption\",\n        value: function walkOption(optionProd, currRest, prevRest) {\n          if (!this.checkIsTarget(optionProd, PROD_TYPE.OPTION, currRest, prevRest)) {\n            _get(_getPrototypeOf(RestDefinitionFinderWalker.prototype), \"walkOption\", this).call(this, optionProd, currRest, prevRest);\n          }\n        }\n      }, {\n        key: \"walkAtLeastOne\",\n        value: function walkAtLeastOne(atLeastOneProd, currRest, prevRest) {\n          if (!this.checkIsTarget(atLeastOneProd, PROD_TYPE.REPETITION_MANDATORY, currRest, prevRest)) {\n            _get(_getPrototypeOf(RestDefinitionFinderWalker.prototype), \"walkOption\", this).call(this, atLeastOneProd, currRest, prevRest);\n          }\n        }\n      }, {\n        key: \"walkAtLeastOneSep\",\n        value: function walkAtLeastOneSep(atLeastOneSepProd, currRest, prevRest) {\n          if (!this.checkIsTarget(atLeastOneSepProd, PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR, currRest, prevRest)) {\n            _get(_getPrototypeOf(RestDefinitionFinderWalker.prototype), \"walkOption\", this).call(this, atLeastOneSepProd, currRest, prevRest);\n          }\n        }\n      }, {\n        key: \"walkMany\",\n        value: function walkMany(manyProd, currRest, prevRest) {\n          if (!this.checkIsTarget(manyProd, PROD_TYPE.REPETITION, currRest, prevRest)) {\n            _get(_getPrototypeOf(RestDefinitionFinderWalker.prototype), \"walkOption\", this).call(this, manyProd, currRest, prevRest);\n          }\n        }\n      }, {\n        key: \"walkManySep\",\n        value: function walkManySep(manySepProd, currRest, prevRest) {\n          if (!this.checkIsTarget(manySepProd, PROD_TYPE.REPETITION_WITH_SEPARATOR, currRest, prevRest)) {\n            _get(_getPrototypeOf(RestDefinitionFinderWalker.prototype), \"walkOption\", this).call(this, manySepProd, currRest, prevRest);\n          }\n        }\n      }]);\n      return RestDefinitionFinderWalker;\n    }(RestWalker);\n    var InsideDefinitionFinderVisitor = /*#__PURE__*/function (_GAstVisitor2) {\n      _inherits(InsideDefinitionFinderVisitor, _GAstVisitor2);\n      var _super23 = _createSuper(InsideDefinitionFinderVisitor);\n      function InsideDefinitionFinderVisitor(targetOccurrence, targetProdType, targetRef) {\n        var _this25;\n        _classCallCheck(this, InsideDefinitionFinderVisitor);\n        _this25 = _super23.call(this);\n        _this25.targetOccurrence = targetOccurrence;\n        _this25.targetProdType = targetProdType;\n        _this25.targetRef = targetRef;\n        _this25.result = [];\n        return _this25;\n      }\n      _createClass(InsideDefinitionFinderVisitor, [{\n        key: \"checkIsTarget\",\n        value: function checkIsTarget(node, expectedProdName) {\n          if (node.idx === this.targetOccurrence && this.targetProdType === expectedProdName && (this.targetRef === void 0 || node === this.targetRef)) {\n            this.result = node.definition;\n          }\n        }\n      }, {\n        key: \"visitOption\",\n        value: function visitOption(node) {\n          this.checkIsTarget(node, PROD_TYPE.OPTION);\n        }\n      }, {\n        key: \"visitRepetition\",\n        value: function visitRepetition(node) {\n          this.checkIsTarget(node, PROD_TYPE.REPETITION);\n        }\n      }, {\n        key: \"visitRepetitionMandatory\",\n        value: function visitRepetitionMandatory(node) {\n          this.checkIsTarget(node, PROD_TYPE.REPETITION_MANDATORY);\n        }\n      }, {\n        key: \"visitRepetitionMandatoryWithSeparator\",\n        value: function visitRepetitionMandatoryWithSeparator(node) {\n          this.checkIsTarget(node, PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR);\n        }\n      }, {\n        key: \"visitRepetitionWithSeparator\",\n        value: function visitRepetitionWithSeparator(node) {\n          this.checkIsTarget(node, PROD_TYPE.REPETITION_WITH_SEPARATOR);\n        }\n      }, {\n        key: \"visitAlternation\",\n        value: function visitAlternation(node) {\n          this.checkIsTarget(node, PROD_TYPE.ALTERNATION);\n        }\n      }]);\n      return InsideDefinitionFinderVisitor;\n    }(GAstVisitor);\n    function initializeArrayOfArrays(size) {\n      var result = new Array(size);\n      for (var _i12 = 0; _i12 < size; _i12++) {\n        result[_i12] = [];\n      }\n      return result;\n    }\n    function pathToHashKeys(path) {\n      var keys2 = [\"\"];\n      for (var _i13 = 0; _i13 < path.length; _i13++) {\n        var tokType = path[_i13];\n        var longerKeys = [];\n        for (var j = 0; j < keys2.length; j++) {\n          var currShorterKey = keys2[j];\n          longerKeys.push(currShorterKey + \"_\" + tokType.tokenTypeIdx);\n          for (var t = 0; t < tokType.categoryMatches.length; t++) {\n            var categoriesKeySuffix = \"_\" + tokType.categoryMatches[t];\n            longerKeys.push(currShorterKey + categoriesKeySuffix);\n          }\n        }\n        keys2 = longerKeys;\n      }\n      return keys2;\n    }\n    function isUniquePrefixHash(altKnownPathsKeys, searchPathKeys, idx) {\n      for (var currAltIdx = 0; currAltIdx < altKnownPathsKeys.length; currAltIdx++) {\n        if (currAltIdx === idx) {\n          continue;\n        }\n        var otherAltKnownPathsKeys = altKnownPathsKeys[currAltIdx];\n        for (var searchIdx = 0; searchIdx < searchPathKeys.length; searchIdx++) {\n          var searchKey = searchPathKeys[searchIdx];\n          if (otherAltKnownPathsKeys[searchKey] === true) {\n            return false;\n          }\n        }\n      }\n      return true;\n    }\n    function lookAheadSequenceFromAlternatives(altsDefs, k) {\n      var partialAlts = map(altsDefs, function (currAlt) {\n        return possiblePathsFrom([currAlt], 1);\n      });\n      var finalResult = initializeArrayOfArrays(partialAlts.length);\n      var altsHashes = map(partialAlts, function (currAltPaths) {\n        var dict = {};\n        forEach(currAltPaths, function (item) {\n          var keys2 = pathToHashKeys(item.partialPath);\n          forEach(keys2, function (currKey) {\n            dict[currKey] = true;\n          });\n        });\n        return dict;\n      });\n      var newData = partialAlts;\n      for (var pathLength = 1; pathLength <= k; pathLength++) {\n        var currDataset = newData;\n        newData = initializeArrayOfArrays(currDataset.length);\n        var _loop = function _loop(altIdx) {\n          var currAltPathsAndSuffixes = currDataset[altIdx];\n          for (var currPathIdx = 0; currPathIdx < currAltPathsAndSuffixes.length; currPathIdx++) {\n            var currPathPrefix = currAltPathsAndSuffixes[currPathIdx].partialPath;\n            var suffixDef = currAltPathsAndSuffixes[currPathIdx].suffixDef;\n            var prefixKeys = pathToHashKeys(currPathPrefix);\n            var isUnique = isUniquePrefixHash(altsHashes, prefixKeys, altIdx);\n            if (isUnique || isEmpty(suffixDef) || currPathPrefix.length === k) {\n              var currAltResult = finalResult[altIdx];\n              if (containsPath(currAltResult, currPathPrefix) === false) {\n                currAltResult.push(currPathPrefix);\n                for (var j = 0; j < prefixKeys.length; j++) {\n                  var currKey = prefixKeys[j];\n                  altsHashes[altIdx][currKey] = true;\n                }\n              }\n            } else {\n              var newPartialPathsAndSuffixes = possiblePathsFrom(suffixDef, pathLength + 1, currPathPrefix);\n              newData[altIdx] = newData[altIdx].concat(newPartialPathsAndSuffixes);\n              forEach(newPartialPathsAndSuffixes, function (item) {\n                var prefixKeys2 = pathToHashKeys(item.partialPath);\n                forEach(prefixKeys2, function (key) {\n                  altsHashes[altIdx][key] = true;\n                });\n              });\n            }\n          }\n        };\n        for (var altIdx = 0; altIdx < currDataset.length; altIdx++) {\n          _loop(altIdx);\n        }\n      }\n      return finalResult;\n    }\n    function getLookaheadPathsForOr(occurrence, ruleGrammar, k, orProd) {\n      var visitor = new InsideDefinitionFinderVisitor(occurrence, PROD_TYPE.ALTERNATION, orProd);\n      ruleGrammar.accept(visitor);\n      return lookAheadSequenceFromAlternatives(visitor.result, k);\n    }\n    function getLookaheadPathsForOptionalProd(occurrence, ruleGrammar, prodType, k) {\n      var insideDefVisitor = new InsideDefinitionFinderVisitor(occurrence, prodType);\n      ruleGrammar.accept(insideDefVisitor);\n      var insideDef = insideDefVisitor.result;\n      var afterDefWalker = new RestDefinitionFinderWalker(ruleGrammar, occurrence, prodType);\n      var afterDef = afterDefWalker.startWalking();\n      var insideFlat = new Alternative({\n        definition: insideDef\n      });\n      var afterFlat = new Alternative({\n        definition: afterDef\n      });\n      return lookAheadSequenceFromAlternatives([insideFlat, afterFlat], k);\n    }\n    function containsPath(alternative, searchPath) {\n      compareOtherPath: for (var _i14 = 0; _i14 < alternative.length; _i14++) {\n        var otherPath = alternative[_i14];\n        if (otherPath.length !== searchPath.length) {\n          continue;\n        }\n        for (var j = 0; j < otherPath.length; j++) {\n          var searchTok = searchPath[j];\n          var otherTok = otherPath[j];\n          var matchingTokens = searchTok === otherTok || otherTok.categoryMatchesMap[searchTok.tokenTypeIdx] !== void 0;\n          if (matchingTokens === false) {\n            continue compareOtherPath;\n          }\n        }\n        return true;\n      }\n      return false;\n    }\n    function isStrictPrefixOfPath(prefix, other) {\n      return prefix.length < other.length && every(prefix, function (tokType, idx) {\n        var otherTokType = other[idx];\n        return tokType === otherTokType || otherTokType.categoryMatchesMap[tokType.tokenTypeIdx];\n      });\n    }\n    function areTokenCategoriesNotUsed(lookAheadPaths) {\n      return every(lookAheadPaths, function (singleAltPaths) {\n        return every(singleAltPaths, function (singlePath) {\n          return every(singlePath, function (token) {\n            return isEmpty(token.categoryMatches);\n          });\n        });\n      });\n    }\n    function validateLookahead(options) {\n      var lookaheadValidationErrorMessages = options.lookaheadStrategy.validate({\n        rules: options.rules,\n        tokenTypes: options.tokenTypes,\n        grammarName: options.grammarName\n      });\n      return map(lookaheadValidationErrorMessages, function (errorMessage) {\n        return Object.assign({\n          type: ParserDefinitionErrorType.CUSTOM_LOOKAHEAD_VALIDATION\n        }, errorMessage);\n      });\n    }\n    function validateGrammar$1(topLevels, tokenTypes, errMsgProvider, grammarName) {\n      var duplicateErrors = flatMap(topLevels, function (currTopLevel) {\n        return validateDuplicateProductions(currTopLevel, errMsgProvider);\n      });\n      var termsNamespaceConflictErrors = checkTerminalAndNoneTerminalsNameSpace(topLevels, tokenTypes, errMsgProvider);\n      var tooManyAltsErrors = flatMap(topLevels, function (curRule) {\n        return validateTooManyAlts(curRule, errMsgProvider);\n      });\n      var duplicateRulesError = flatMap(topLevels, function (curRule) {\n        return validateRuleDoesNotAlreadyExist(curRule, topLevels, grammarName, errMsgProvider);\n      });\n      return duplicateErrors.concat(termsNamespaceConflictErrors, tooManyAltsErrors, duplicateRulesError);\n    }\n    function validateDuplicateProductions(topLevelRule, errMsgProvider) {\n      var collectorVisitor2 = new OccurrenceValidationCollector();\n      topLevelRule.accept(collectorVisitor2);\n      var allRuleProductions = collectorVisitor2.allProductions;\n      var productionGroups = groupBy$1(allRuleProductions, identifyProductionForDuplicates);\n      var duplicates = pickBy(productionGroups, function (currGroup) {\n        return currGroup.length > 1;\n      });\n      var errors = map(values(duplicates), function (currDuplicates) {\n        var firstProd = head(currDuplicates);\n        var msg = errMsgProvider.buildDuplicateFoundError(topLevelRule, currDuplicates);\n        var dslName = getProductionDslName(firstProd);\n        var defError = {\n          message: msg,\n          type: ParserDefinitionErrorType.DUPLICATE_PRODUCTIONS,\n          ruleName: topLevelRule.name,\n          dslName: dslName,\n          occurrence: firstProd.idx\n        };\n        var param = getExtraProductionArgument(firstProd);\n        if (param) {\n          defError.parameter = param;\n        }\n        return defError;\n      });\n      return errors;\n    }\n    function identifyProductionForDuplicates(prod) {\n      return \"\".concat(getProductionDslName(prod), \"_#_\").concat(prod.idx, \"_#_\").concat(getExtraProductionArgument(prod));\n    }\n    function getExtraProductionArgument(prod) {\n      if (prod instanceof Terminal) {\n        return prod.terminalType.name;\n      } else if (prod instanceof NonTerminal) {\n        return prod.nonTerminalName;\n      } else {\n        return \"\";\n      }\n    }\n    var OccurrenceValidationCollector = /*#__PURE__*/function (_GAstVisitor3) {\n      _inherits(OccurrenceValidationCollector, _GAstVisitor3);\n      var _super24 = _createSuper(OccurrenceValidationCollector);\n      function OccurrenceValidationCollector() {\n        var _this26;\n        _classCallCheck(this, OccurrenceValidationCollector);\n        _this26 = _super24.apply(this, arguments);\n        _this26.allProductions = [];\n        return _this26;\n      }\n      _createClass(OccurrenceValidationCollector, [{\n        key: \"visitNonTerminal\",\n        value: function visitNonTerminal(subrule) {\n          this.allProductions.push(subrule);\n        }\n      }, {\n        key: \"visitOption\",\n        value: function visitOption(option) {\n          this.allProductions.push(option);\n        }\n      }, {\n        key: \"visitRepetitionWithSeparator\",\n        value: function visitRepetitionWithSeparator(manySep) {\n          this.allProductions.push(manySep);\n        }\n      }, {\n        key: \"visitRepetitionMandatory\",\n        value: function visitRepetitionMandatory(atLeastOne) {\n          this.allProductions.push(atLeastOne);\n        }\n      }, {\n        key: \"visitRepetitionMandatoryWithSeparator\",\n        value: function visitRepetitionMandatoryWithSeparator(atLeastOneSep) {\n          this.allProductions.push(atLeastOneSep);\n        }\n      }, {\n        key: \"visitRepetition\",\n        value: function visitRepetition(many) {\n          this.allProductions.push(many);\n        }\n      }, {\n        key: \"visitAlternation\",\n        value: function visitAlternation(or) {\n          this.allProductions.push(or);\n        }\n      }, {\n        key: \"visitTerminal\",\n        value: function visitTerminal(terminal) {\n          this.allProductions.push(terminal);\n        }\n      }]);\n      return OccurrenceValidationCollector;\n    }(GAstVisitor);\n    function validateRuleDoesNotAlreadyExist(rule, allRules, className, errMsgProvider) {\n      var errors = [];\n      var occurrences = reduce(allRules, function (result, curRule) {\n        if (curRule.name === rule.name) {\n          return result + 1;\n        }\n        return result;\n      }, 0);\n      if (occurrences > 1) {\n        var errMsg = errMsgProvider.buildDuplicateRuleNameError({\n          topLevelRule: rule,\n          grammarName: className\n        });\n        errors.push({\n          message: errMsg,\n          type: ParserDefinitionErrorType.DUPLICATE_RULE_NAME,\n          ruleName: rule.name\n        });\n      }\n      return errors;\n    }\n    function validateRuleIsOverridden(ruleName, definedRulesNames, className) {\n      var errors = [];\n      var errMsg;\n      if (!includes(definedRulesNames, ruleName)) {\n        errMsg = \"Invalid rule override, rule: ->\".concat(ruleName, \"<- cannot be overridden in the grammar: ->\").concat(className, \"<-as it is not defined in any of the super grammars \");\n        errors.push({\n          message: errMsg,\n          type: ParserDefinitionErrorType.INVALID_RULE_OVERRIDE,\n          ruleName: ruleName\n        });\n      }\n      return errors;\n    }\n    function _validateNoLeftRecursion(topRule, currRule, errMsgProvider) {\n      var path = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];\n      var errors = [];\n      var nextNonTerminals = getFirstNoneTerminal(currRule.definition);\n      if (isEmpty(nextNonTerminals)) {\n        return [];\n      } else {\n        var ruleName = topRule.name;\n        var foundLeftRecursion = includes(nextNonTerminals, topRule);\n        if (foundLeftRecursion) {\n          errors.push({\n            message: errMsgProvider.buildLeftRecursionError({\n              topLevelRule: topRule,\n              leftRecursionPath: path\n            }),\n            type: ParserDefinitionErrorType.LEFT_RECURSION,\n            ruleName: ruleName\n          });\n        }\n        var validNextSteps = difference$1(nextNonTerminals, path.concat([topRule]));\n        var errorsFromNextSteps = flatMap(validNextSteps, function (currRefRule) {\n          var newPath = clone(path);\n          newPath.push(currRefRule);\n          return _validateNoLeftRecursion(topRule, currRefRule, errMsgProvider, newPath);\n        });\n        return errors.concat(errorsFromNextSteps);\n      }\n    }\n    function getFirstNoneTerminal(definition) {\n      var result = [];\n      if (isEmpty(definition)) {\n        return result;\n      }\n      var firstProd = head(definition);\n      if (firstProd instanceof NonTerminal) {\n        result.push(firstProd.referencedRule);\n      } else if (firstProd instanceof Alternative || firstProd instanceof Option || firstProd instanceof RepetitionMandatory || firstProd instanceof RepetitionMandatoryWithSeparator || firstProd instanceof RepetitionWithSeparator || firstProd instanceof Repetition) {\n        result = result.concat(getFirstNoneTerminal(firstProd.definition));\n      } else if (firstProd instanceof Alternation) {\n        result = flatten(map(firstProd.definition, function (currSubDef) {\n          return getFirstNoneTerminal(currSubDef.definition);\n        }));\n      } else if (firstProd instanceof Terminal) ;else {\n        throw Error(\"non exhaustive match\");\n      }\n      var isFirstOptional = isOptionalProd(firstProd);\n      var hasMore = definition.length > 1;\n      if (isFirstOptional && hasMore) {\n        var rest = drop(definition);\n        return result.concat(getFirstNoneTerminal(rest));\n      } else {\n        return result;\n      }\n    }\n    var OrCollector = /*#__PURE__*/function (_GAstVisitor4) {\n      _inherits(OrCollector, _GAstVisitor4);\n      var _super25 = _createSuper(OrCollector);\n      function OrCollector() {\n        var _this27;\n        _classCallCheck(this, OrCollector);\n        _this27 = _super25.apply(this, arguments);\n        _this27.alternations = [];\n        return _this27;\n      }\n      _createClass(OrCollector, [{\n        key: \"visitAlternation\",\n        value: function visitAlternation(node) {\n          this.alternations.push(node);\n        }\n      }]);\n      return OrCollector;\n    }(GAstVisitor);\n    function validateEmptyOrAlternative(topLevelRule, errMsgProvider) {\n      var orCollector = new OrCollector();\n      topLevelRule.accept(orCollector);\n      var ors = orCollector.alternations;\n      var errors = flatMap(ors, function (currOr) {\n        var exceptLast = dropRight(currOr.definition);\n        return flatMap(exceptLast, function (currAlternative, currAltIdx) {\n          var possibleFirstInAlt = nextPossibleTokensAfter([currAlternative], [], tokenStructuredMatcher, 1);\n          if (isEmpty(possibleFirstInAlt)) {\n            return [{\n              message: errMsgProvider.buildEmptyAlternationError({\n                topLevelRule: topLevelRule,\n                alternation: currOr,\n                emptyChoiceIdx: currAltIdx\n              }),\n              type: ParserDefinitionErrorType.NONE_LAST_EMPTY_ALT,\n              ruleName: topLevelRule.name,\n              occurrence: currOr.idx,\n              alternative: currAltIdx + 1\n            }];\n          } else {\n            return [];\n          }\n        });\n      });\n      return errors;\n    }\n    function _validateAmbiguousAlternationAlternatives(topLevelRule, globalMaxLookahead, errMsgProvider) {\n      var orCollector = new OrCollector();\n      topLevelRule.accept(orCollector);\n      var ors = orCollector.alternations;\n      ors = reject(ors, function (currOr) {\n        return currOr.ignoreAmbiguities === true;\n      });\n      var errors = flatMap(ors, function (currOr) {\n        var currOccurrence = currOr.idx;\n        var actualMaxLookahead = currOr.maxLookahead || globalMaxLookahead;\n        var alternatives = getLookaheadPathsForOr(currOccurrence, topLevelRule, actualMaxLookahead, currOr);\n        var altsAmbiguityErrors = checkAlternativesAmbiguities(alternatives, currOr, topLevelRule, errMsgProvider);\n        var altsPrefixAmbiguityErrors = checkPrefixAlternativesAmbiguities(alternatives, currOr, topLevelRule, errMsgProvider);\n        return altsAmbiguityErrors.concat(altsPrefixAmbiguityErrors);\n      });\n      return errors;\n    }\n    var RepetitionCollector = /*#__PURE__*/function (_GAstVisitor5) {\n      _inherits(RepetitionCollector, _GAstVisitor5);\n      var _super26 = _createSuper(RepetitionCollector);\n      function RepetitionCollector() {\n        var _this28;\n        _classCallCheck(this, RepetitionCollector);\n        _this28 = _super26.apply(this, arguments);\n        _this28.allProductions = [];\n        return _this28;\n      }\n      _createClass(RepetitionCollector, [{\n        key: \"visitRepetitionWithSeparator\",\n        value: function visitRepetitionWithSeparator(manySep) {\n          this.allProductions.push(manySep);\n        }\n      }, {\n        key: \"visitRepetitionMandatory\",\n        value: function visitRepetitionMandatory(atLeastOne) {\n          this.allProductions.push(atLeastOne);\n        }\n      }, {\n        key: \"visitRepetitionMandatoryWithSeparator\",\n        value: function visitRepetitionMandatoryWithSeparator(atLeastOneSep) {\n          this.allProductions.push(atLeastOneSep);\n        }\n      }, {\n        key: \"visitRepetition\",\n        value: function visitRepetition(many) {\n          this.allProductions.push(many);\n        }\n      }]);\n      return RepetitionCollector;\n    }(GAstVisitor);\n    function validateTooManyAlts(topLevelRule, errMsgProvider) {\n      var orCollector = new OrCollector();\n      topLevelRule.accept(orCollector);\n      var ors = orCollector.alternations;\n      var errors = flatMap(ors, function (currOr) {\n        if (currOr.definition.length > 255) {\n          return [{\n            message: errMsgProvider.buildTooManyAlternativesError({\n              topLevelRule: topLevelRule,\n              alternation: currOr\n            }),\n            type: ParserDefinitionErrorType.TOO_MANY_ALTS,\n            ruleName: topLevelRule.name,\n            occurrence: currOr.idx\n          }];\n        } else {\n          return [];\n        }\n      });\n      return errors;\n    }\n    function _validateSomeNonEmptyLookaheadPath(topLevelRules, maxLookahead, errMsgProvider) {\n      var errors = [];\n      forEach(topLevelRules, function (currTopRule) {\n        var collectorVisitor2 = new RepetitionCollector();\n        currTopRule.accept(collectorVisitor2);\n        var allRuleProductions = collectorVisitor2.allProductions;\n        forEach(allRuleProductions, function (currProd) {\n          var prodType = getProdType(currProd);\n          var actualMaxLookahead = currProd.maxLookahead || maxLookahead;\n          var currOccurrence = currProd.idx;\n          var paths = getLookaheadPathsForOptionalProd(currOccurrence, currTopRule, prodType, actualMaxLookahead);\n          var pathsInsideProduction = paths[0];\n          if (isEmpty(flatten(pathsInsideProduction))) {\n            var errMsg = errMsgProvider.buildEmptyRepetitionError({\n              topLevelRule: currTopRule,\n              repetition: currProd\n            });\n            errors.push({\n              message: errMsg,\n              type: ParserDefinitionErrorType.NO_NON_EMPTY_LOOKAHEAD,\n              ruleName: currTopRule.name\n            });\n          }\n        });\n      });\n      return errors;\n    }\n    function checkAlternativesAmbiguities(alternatives, alternation, rule, errMsgProvider) {\n      var foundAmbiguousPaths = [];\n      var identicalAmbiguities = reduce(alternatives, function (result, currAlt, currAltIdx) {\n        if (alternation.definition[currAltIdx].ignoreAmbiguities === true) {\n          return result;\n        }\n        forEach(currAlt, function (currPath) {\n          var altsCurrPathAppearsIn = [currAltIdx];\n          forEach(alternatives, function (currOtherAlt, currOtherAltIdx) {\n            if (currAltIdx !== currOtherAltIdx && containsPath(currOtherAlt, currPath) &&\n            // ignore (skip) ambiguities with this \"other\" alternative\n            alternation.definition[currOtherAltIdx].ignoreAmbiguities !== true) {\n              altsCurrPathAppearsIn.push(currOtherAltIdx);\n            }\n          });\n          if (altsCurrPathAppearsIn.length > 1 && !containsPath(foundAmbiguousPaths, currPath)) {\n            foundAmbiguousPaths.push(currPath);\n            result.push({\n              alts: altsCurrPathAppearsIn,\n              path: currPath\n            });\n          }\n        });\n        return result;\n      }, []);\n      var currErrors = map(identicalAmbiguities, function (currAmbDescriptor) {\n        var ambgIndices = map(currAmbDescriptor.alts, function (currAltIdx) {\n          return currAltIdx + 1;\n        });\n        var currMessage = errMsgProvider.buildAlternationAmbiguityError({\n          topLevelRule: rule,\n          alternation: alternation,\n          ambiguityIndices: ambgIndices,\n          prefixPath: currAmbDescriptor.path\n        });\n        return {\n          message: currMessage,\n          type: ParserDefinitionErrorType.AMBIGUOUS_ALTS,\n          ruleName: rule.name,\n          occurrence: alternation.idx,\n          alternatives: currAmbDescriptor.alts\n        };\n      });\n      return currErrors;\n    }\n    function checkPrefixAlternativesAmbiguities(alternatives, alternation, rule, errMsgProvider) {\n      var pathsAndIndices = reduce(alternatives, function (result, currAlt, idx) {\n        var currPathsAndIdx = map(currAlt, function (currPath) {\n          return {\n            idx: idx,\n            path: currPath\n          };\n        });\n        return result.concat(currPathsAndIdx);\n      }, []);\n      var errors = compact(flatMap(pathsAndIndices, function (currPathAndIdx) {\n        var alternativeGast = alternation.definition[currPathAndIdx.idx];\n        if (alternativeGast.ignoreAmbiguities === true) {\n          return [];\n        }\n        var targetIdx = currPathAndIdx.idx;\n        var targetPath = currPathAndIdx.path;\n        var prefixAmbiguitiesPathsAndIndices = filter(pathsAndIndices, function (searchPathAndIdx) {\n          return (\n            // ignore (skip) ambiguities with this \"other\" alternative\n            alternation.definition[searchPathAndIdx.idx].ignoreAmbiguities !== true && searchPathAndIdx.idx < targetIdx &&\n            // checking for strict prefix because identical lookaheads\n            // will be be detected using a different validation.\n            isStrictPrefixOfPath(searchPathAndIdx.path, targetPath)\n          );\n        });\n        var currPathPrefixErrors = map(prefixAmbiguitiesPathsAndIndices, function (currAmbPathAndIdx) {\n          var ambgIndices = [currAmbPathAndIdx.idx + 1, targetIdx + 1];\n          var occurrence = alternation.idx === 0 ? \"\" : alternation.idx;\n          var message = errMsgProvider.buildAlternationPrefixAmbiguityError({\n            topLevelRule: rule,\n            alternation: alternation,\n            ambiguityIndices: ambgIndices,\n            prefixPath: currAmbPathAndIdx.path\n          });\n          return {\n            message: message,\n            type: ParserDefinitionErrorType.AMBIGUOUS_PREFIX_ALTS,\n            ruleName: rule.name,\n            occurrence: occurrence,\n            alternatives: ambgIndices\n          };\n        });\n        return currPathPrefixErrors;\n      }));\n      return errors;\n    }\n    function checkTerminalAndNoneTerminalsNameSpace(topLevels, tokenTypes, errMsgProvider) {\n      var errors = [];\n      var tokenNames = map(tokenTypes, function (currToken) {\n        return currToken.name;\n      });\n      forEach(topLevels, function (currRule) {\n        var currRuleName = currRule.name;\n        if (includes(tokenNames, currRuleName)) {\n          var errMsg = errMsgProvider.buildNamespaceConflictError(currRule);\n          errors.push({\n            message: errMsg,\n            type: ParserDefinitionErrorType.CONFLICT_TOKENS_RULES_NAMESPACE,\n            ruleName: currRuleName\n          });\n        }\n      });\n      return errors;\n    }\n    function resolveGrammar(options) {\n      var actualOptions = defaults$1(options, {\n        errMsgProvider: defaultGrammarResolverErrorProvider\n      });\n      var topRulesTable = {};\n      forEach(options.rules, function (rule) {\n        topRulesTable[rule.name] = rule;\n      });\n      return resolveGrammar$1(topRulesTable, actualOptions.errMsgProvider);\n    }\n    function validateGrammar(options) {\n      options = defaults$1(options, {\n        errMsgProvider: defaultGrammarValidatorErrorProvider\n      });\n      return validateGrammar$1(options.rules, options.tokenTypes, options.errMsgProvider, options.grammarName);\n    }\n    var MISMATCHED_TOKEN_EXCEPTION = \"MismatchedTokenException\";\n    var NO_VIABLE_ALT_EXCEPTION = \"NoViableAltException\";\n    var EARLY_EXIT_EXCEPTION = \"EarlyExitException\";\n    var NOT_ALL_INPUT_PARSED_EXCEPTION = \"NotAllInputParsedException\";\n    var RECOGNITION_EXCEPTION_NAMES = [MISMATCHED_TOKEN_EXCEPTION, NO_VIABLE_ALT_EXCEPTION, EARLY_EXIT_EXCEPTION, NOT_ALL_INPUT_PARSED_EXCEPTION];\n    Object.freeze(RECOGNITION_EXCEPTION_NAMES);\n    function isRecognitionException(error) {\n      return includes(RECOGNITION_EXCEPTION_NAMES, error.name);\n    }\n    var RecognitionException = /*#__PURE__*/function (_Error) {\n      _inherits(RecognitionException, _Error);\n      var _super27 = _createSuper(RecognitionException);\n      function RecognitionException(message, token) {\n        var _this29;\n        _classCallCheck(this, RecognitionException);\n        _this29 = _super27.call(this, message);\n        _this29.token = token;\n        _this29.resyncedTokens = [];\n        Object.setPrototypeOf(_assertThisInitialized(_this29), (this instanceof RecognitionException ? this.constructor : void 0).prototype);\n        if (Error.captureStackTrace) {\n          Error.captureStackTrace(_assertThisInitialized(_this29), _this29.constructor);\n        }\n        return _this29;\n      }\n      return _createClass(RecognitionException);\n    }( /*#__PURE__*/_wrapNativeSuper(Error));\n    var MismatchedTokenException = /*#__PURE__*/function (_RecognitionException) {\n      _inherits(MismatchedTokenException, _RecognitionException);\n      var _super28 = _createSuper(MismatchedTokenException);\n      function MismatchedTokenException(message, token, previousToken) {\n        var _this30;\n        _classCallCheck(this, MismatchedTokenException);\n        _this30 = _super28.call(this, message, token);\n        _this30.previousToken = previousToken;\n        _this30.name = MISMATCHED_TOKEN_EXCEPTION;\n        return _this30;\n      }\n      return _createClass(MismatchedTokenException);\n    }(RecognitionException);\n    var NoViableAltException = /*#__PURE__*/function (_RecognitionException2) {\n      _inherits(NoViableAltException, _RecognitionException2);\n      var _super29 = _createSuper(NoViableAltException);\n      function NoViableAltException(message, token, previousToken) {\n        var _this31;\n        _classCallCheck(this, NoViableAltException);\n        _this31 = _super29.call(this, message, token);\n        _this31.previousToken = previousToken;\n        _this31.name = NO_VIABLE_ALT_EXCEPTION;\n        return _this31;\n      }\n      return _createClass(NoViableAltException);\n    }(RecognitionException);\n    var NotAllInputParsedException = /*#__PURE__*/function (_RecognitionException3) {\n      _inherits(NotAllInputParsedException, _RecognitionException3);\n      var _super30 = _createSuper(NotAllInputParsedException);\n      function NotAllInputParsedException(message, token) {\n        var _this32;\n        _classCallCheck(this, NotAllInputParsedException);\n        _this32 = _super30.call(this, message, token);\n        _this32.name = NOT_ALL_INPUT_PARSED_EXCEPTION;\n        return _this32;\n      }\n      return _createClass(NotAllInputParsedException);\n    }(RecognitionException);\n    var EarlyExitException = /*#__PURE__*/function (_RecognitionException4) {\n      _inherits(EarlyExitException, _RecognitionException4);\n      var _super31 = _createSuper(EarlyExitException);\n      function EarlyExitException(message, token, previousToken) {\n        var _this33;\n        _classCallCheck(this, EarlyExitException);\n        _this33 = _super31.call(this, message, token);\n        _this33.previousToken = previousToken;\n        _this33.name = EARLY_EXIT_EXCEPTION;\n        return _this33;\n      }\n      return _createClass(EarlyExitException);\n    }(RecognitionException);\n    var EOF_FOLLOW_KEY = {};\n    var IN_RULE_RECOVERY_EXCEPTION = \"InRuleRecoveryException\";\n    var InRuleRecoveryException = /*#__PURE__*/function (_Error2) {\n      _inherits(InRuleRecoveryException, _Error2);\n      var _super32 = _createSuper(InRuleRecoveryException);\n      function InRuleRecoveryException(message) {\n        var _this34;\n        _classCallCheck(this, InRuleRecoveryException);\n        _this34 = _super32.call(this, message);\n        _this34.name = IN_RULE_RECOVERY_EXCEPTION;\n        return _this34;\n      }\n      return _createClass(InRuleRecoveryException);\n    }( /*#__PURE__*/_wrapNativeSuper(Error));\n    var Recoverable = /*#__PURE__*/function () {\n      function Recoverable() {\n        _classCallCheck(this, Recoverable);\n      }\n      _createClass(Recoverable, [{\n        key: \"initRecoverable\",\n        value: function initRecoverable(config) {\n          this.firstAfterRepMap = {};\n          this.resyncFollows = {};\n          this.recoveryEnabled = has(config, \"recoveryEnabled\") ? config.recoveryEnabled : DEFAULT_PARSER_CONFIG.recoveryEnabled;\n          if (this.recoveryEnabled) {\n            this.attemptInRepetitionRecovery = attemptInRepetitionRecovery;\n          }\n        }\n      }, {\n        key: \"getTokenToInsert\",\n        value: function getTokenToInsert(tokType) {\n          var tokToInsert = createTokenInstance(tokType, \"\", NaN, NaN, NaN, NaN, NaN, NaN);\n          tokToInsert.isInsertedInRecovery = true;\n          return tokToInsert;\n        }\n      }, {\n        key: \"canTokenTypeBeInsertedInRecovery\",\n        value: function canTokenTypeBeInsertedInRecovery(tokType) {\n          return true;\n        }\n      }, {\n        key: \"canTokenTypeBeDeletedInRecovery\",\n        value: function canTokenTypeBeDeletedInRecovery(tokType) {\n          return true;\n        }\n      }, {\n        key: \"tryInRepetitionRecovery\",\n        value: function tryInRepetitionRecovery(grammarRule, grammarRuleArgs, lookAheadFunc, expectedTokType) {\n          var _this35 = this;\n          var reSyncTokType = this.findReSyncTokenType();\n          var savedLexerState = this.exportLexerState();\n          var resyncedTokens = [];\n          var passedResyncPoint = false;\n          var nextTokenWithoutResync = this.LA(1);\n          var currToken = this.LA(1);\n          var generateErrorMessage = function generateErrorMessage() {\n            var previousToken = _this35.LA(0);\n            var msg = _this35.errorMessageProvider.buildMismatchTokenMessage({\n              expected: expectedTokType,\n              actual: nextTokenWithoutResync,\n              previous: previousToken,\n              ruleName: _this35.getCurrRuleFullName()\n            });\n            var error = new MismatchedTokenException(msg, nextTokenWithoutResync, _this35.LA(0));\n            error.resyncedTokens = dropRight(resyncedTokens);\n            _this35.SAVE_ERROR(error);\n          };\n          while (!passedResyncPoint) {\n            if (this.tokenMatcher(currToken, expectedTokType)) {\n              generateErrorMessage();\n              return;\n            } else if (lookAheadFunc.call(this)) {\n              generateErrorMessage();\n              grammarRule.apply(this, grammarRuleArgs);\n              return;\n            } else if (this.tokenMatcher(currToken, reSyncTokType)) {\n              passedResyncPoint = true;\n            } else {\n              currToken = this.SKIP_TOKEN();\n              this.addToResyncTokens(currToken, resyncedTokens);\n            }\n          }\n          this.importLexerState(savedLexerState);\n        }\n      }, {\n        key: \"shouldInRepetitionRecoveryBeTried\",\n        value: function shouldInRepetitionRecoveryBeTried(expectTokAfterLastMatch, nextTokIdx, notStuck) {\n          if (notStuck === false) {\n            return false;\n          }\n          if (this.tokenMatcher(this.LA(1), expectTokAfterLastMatch)) {\n            return false;\n          }\n          if (this.isBackTracking()) {\n            return false;\n          }\n          if (this.canPerformInRuleRecovery(expectTokAfterLastMatch, this.getFollowsForInRuleRecovery(expectTokAfterLastMatch, nextTokIdx))) {\n            return false;\n          }\n          return true;\n        }\n        // Error Recovery functionality\n      }, {\n        key: \"getFollowsForInRuleRecovery\",\n        value: function getFollowsForInRuleRecovery(tokType, tokIdxInRule) {\n          var grammarPath = this.getCurrentGrammarPath(tokType, tokIdxInRule);\n          var follows = this.getNextPossibleTokenTypes(grammarPath);\n          return follows;\n        }\n      }, {\n        key: \"tryInRuleRecovery\",\n        value: function tryInRuleRecovery(expectedTokType, follows) {\n          if (this.canRecoverWithSingleTokenInsertion(expectedTokType, follows)) {\n            var tokToInsert = this.getTokenToInsert(expectedTokType);\n            return tokToInsert;\n          }\n          if (this.canRecoverWithSingleTokenDeletion(expectedTokType)) {\n            var nextTok = this.SKIP_TOKEN();\n            this.consumeToken();\n            return nextTok;\n          }\n          throw new InRuleRecoveryException(\"sad sad panda\");\n        }\n      }, {\n        key: \"canPerformInRuleRecovery\",\n        value: function canPerformInRuleRecovery(expectedToken, follows) {\n          return this.canRecoverWithSingleTokenInsertion(expectedToken, follows) || this.canRecoverWithSingleTokenDeletion(expectedToken);\n        }\n      }, {\n        key: \"canRecoverWithSingleTokenInsertion\",\n        value: function canRecoverWithSingleTokenInsertion(expectedTokType, follows) {\n          var _this36 = this;\n          if (!this.canTokenTypeBeInsertedInRecovery(expectedTokType)) {\n            return false;\n          }\n          if (isEmpty(follows)) {\n            return false;\n          }\n          var mismatchedTok = this.LA(1);\n          var isMisMatchedTokInFollows = find$1(follows, function (possibleFollowsTokType) {\n            return _this36.tokenMatcher(mismatchedTok, possibleFollowsTokType);\n          }) !== void 0;\n          return isMisMatchedTokInFollows;\n        }\n      }, {\n        key: \"canRecoverWithSingleTokenDeletion\",\n        value: function canRecoverWithSingleTokenDeletion(expectedTokType) {\n          if (!this.canTokenTypeBeDeletedInRecovery(expectedTokType)) {\n            return false;\n          }\n          var isNextTokenWhatIsExpected = this.tokenMatcher(this.LA(2), expectedTokType);\n          return isNextTokenWhatIsExpected;\n        }\n      }, {\n        key: \"isInCurrentRuleReSyncSet\",\n        value: function isInCurrentRuleReSyncSet(tokenTypeIdx) {\n          var followKey = this.getCurrFollowKey();\n          var currentRuleReSyncSet = this.getFollowSetFromFollowKey(followKey);\n          return includes(currentRuleReSyncSet, tokenTypeIdx);\n        }\n      }, {\n        key: \"findReSyncTokenType\",\n        value: function findReSyncTokenType() {\n          var allPossibleReSyncTokTypes = this.flattenFollowSet();\n          var nextToken = this.LA(1);\n          var k = 2;\n          while (true) {\n            var foundMatch = find$1(allPossibleReSyncTokTypes, function (resyncTokType) {\n              var canMatch = tokenMatcher(nextToken, resyncTokType);\n              return canMatch;\n            });\n            if (foundMatch !== void 0) {\n              return foundMatch;\n            }\n            nextToken = this.LA(k);\n            k++;\n          }\n        }\n      }, {\n        key: \"getCurrFollowKey\",\n        value: function getCurrFollowKey() {\n          if (this.RULE_STACK.length === 1) {\n            return EOF_FOLLOW_KEY;\n          }\n          var currRuleShortName = this.getLastExplicitRuleShortName();\n          var currRuleIdx = this.getLastExplicitRuleOccurrenceIndex();\n          var prevRuleShortName = this.getPreviousExplicitRuleShortName();\n          return {\n            ruleName: this.shortRuleNameToFullName(currRuleShortName),\n            idxInCallingRule: currRuleIdx,\n            inRule: this.shortRuleNameToFullName(prevRuleShortName)\n          };\n        }\n      }, {\n        key: \"buildFullFollowKeyStack\",\n        value: function buildFullFollowKeyStack() {\n          var _this37 = this;\n          var explicitRuleStack = this.RULE_STACK;\n          var explicitOccurrenceStack = this.RULE_OCCURRENCE_STACK;\n          return map(explicitRuleStack, function (ruleName, idx) {\n            if (idx === 0) {\n              return EOF_FOLLOW_KEY;\n            }\n            return {\n              ruleName: _this37.shortRuleNameToFullName(ruleName),\n              idxInCallingRule: explicitOccurrenceStack[idx],\n              inRule: _this37.shortRuleNameToFullName(explicitRuleStack[idx - 1])\n            };\n          });\n        }\n      }, {\n        key: \"flattenFollowSet\",\n        value: function flattenFollowSet() {\n          var _this38 = this;\n          var followStack = map(this.buildFullFollowKeyStack(), function (currKey) {\n            return _this38.getFollowSetFromFollowKey(currKey);\n          });\n          return flatten(followStack);\n        }\n      }, {\n        key: \"getFollowSetFromFollowKey\",\n        value: function getFollowSetFromFollowKey(followKey) {\n          if (followKey === EOF_FOLLOW_KEY) {\n            return [EOF];\n          }\n          var followName = followKey.ruleName + followKey.idxInCallingRule + IN + followKey.inRule;\n          return this.resyncFollows[followName];\n        }\n        // It does not make any sense to include a virtual EOF token in the list of resynced tokens\n        // as EOF does not really exist and thus does not contain any useful information (line/column numbers)\n      }, {\n        key: \"addToResyncTokens\",\n        value: function addToResyncTokens(token, resyncTokens) {\n          if (!this.tokenMatcher(token, EOF)) {\n            resyncTokens.push(token);\n          }\n          return resyncTokens;\n        }\n      }, {\n        key: \"reSyncTo\",\n        value: function reSyncTo(tokType) {\n          var resyncedTokens = [];\n          var nextTok = this.LA(1);\n          while (this.tokenMatcher(nextTok, tokType) === false) {\n            nextTok = this.SKIP_TOKEN();\n            this.addToResyncTokens(nextTok, resyncedTokens);\n          }\n          return dropRight(resyncedTokens);\n        }\n      }, {\n        key: \"attemptInRepetitionRecovery\",\n        value: function attemptInRepetitionRecovery(prodFunc, args, lookaheadFunc, dslMethodIdx, prodOccurrence, nextToksWalker, notStuck) {}\n      }, {\n        key: \"getCurrentGrammarPath\",\n        value: function getCurrentGrammarPath(tokType, tokIdxInRule) {\n          var pathRuleStack = this.getHumanReadableRuleStack();\n          var pathOccurrenceStack = clone(this.RULE_OCCURRENCE_STACK);\n          var grammarPath = {\n            ruleStack: pathRuleStack,\n            occurrenceStack: pathOccurrenceStack,\n            lastTok: tokType,\n            lastTokOccurrence: tokIdxInRule\n          };\n          return grammarPath;\n        }\n      }, {\n        key: \"getHumanReadableRuleStack\",\n        value: function getHumanReadableRuleStack() {\n          var _this39 = this;\n          return map(this.RULE_STACK, function (currShortName) {\n            return _this39.shortRuleNameToFullName(currShortName);\n          });\n        }\n      }]);\n      return Recoverable;\n    }();\n    function attemptInRepetitionRecovery(prodFunc, args, lookaheadFunc, dslMethodIdx, prodOccurrence, nextToksWalker, notStuck) {\n      var key = this.getKeyForAutomaticLookahead(dslMethodIdx, prodOccurrence);\n      var firstAfterRepInfo = this.firstAfterRepMap[key];\n      if (firstAfterRepInfo === void 0) {\n        var currRuleName = this.getCurrRuleFullName();\n        var ruleGrammar = this.getGAstProductions()[currRuleName];\n        var walker = new nextToksWalker(ruleGrammar, prodOccurrence);\n        firstAfterRepInfo = walker.startWalking();\n        this.firstAfterRepMap[key] = firstAfterRepInfo;\n      }\n      var expectTokAfterLastMatch = firstAfterRepInfo.token;\n      var nextTokIdx = firstAfterRepInfo.occurrence;\n      var isEndOfRule = firstAfterRepInfo.isEndOfRule;\n      if (this.RULE_STACK.length === 1 && isEndOfRule && expectTokAfterLastMatch === void 0) {\n        expectTokAfterLastMatch = EOF;\n        nextTokIdx = 1;\n      }\n      if (expectTokAfterLastMatch === void 0 || nextTokIdx === void 0) {\n        return;\n      }\n      if (this.shouldInRepetitionRecoveryBeTried(expectTokAfterLastMatch, nextTokIdx, notStuck)) {\n        this.tryInRepetitionRecovery(prodFunc, args, lookaheadFunc, expectTokAfterLastMatch);\n      }\n    }\n    var BITS_FOR_METHOD_TYPE = 4;\n    var BITS_FOR_OCCURRENCE_IDX = 8;\n    var OR_IDX = 1 << BITS_FOR_OCCURRENCE_IDX;\n    var OPTION_IDX = 2 << BITS_FOR_OCCURRENCE_IDX;\n    var MANY_IDX = 3 << BITS_FOR_OCCURRENCE_IDX;\n    var AT_LEAST_ONE_IDX = 4 << BITS_FOR_OCCURRENCE_IDX;\n    var MANY_SEP_IDX = 5 << BITS_FOR_OCCURRENCE_IDX;\n    var AT_LEAST_ONE_SEP_IDX = 6 << BITS_FOR_OCCURRENCE_IDX;\n    function _getKeyForAutomaticLookahead(ruleIdx, dslMethodIdx, occurrence) {\n      return occurrence | dslMethodIdx | ruleIdx;\n    }\n    var LLkLookaheadStrategy = /*#__PURE__*/function () {\n      function LLkLookaheadStrategy(options) {\n        _classCallCheck(this, LLkLookaheadStrategy);\n        var _a;\n        this.maxLookahead = (_a = options === null || options === void 0 ? void 0 : options.maxLookahead) !== null && _a !== void 0 ? _a : DEFAULT_PARSER_CONFIG.maxLookahead;\n      }\n      _createClass(LLkLookaheadStrategy, [{\n        key: \"validate\",\n        value: function validate(options) {\n          var leftRecursionErrors = this.validateNoLeftRecursion(options.rules);\n          if (isEmpty(leftRecursionErrors)) {\n            var emptyAltErrors = this.validateEmptyOrAlternatives(options.rules);\n            var ambiguousAltsErrors = this.validateAmbiguousAlternationAlternatives(options.rules, this.maxLookahead);\n            var emptyRepetitionErrors = this.validateSomeNonEmptyLookaheadPath(options.rules, this.maxLookahead);\n            var allErrors = [].concat(_toConsumableArray(leftRecursionErrors), _toConsumableArray(emptyAltErrors), _toConsumableArray(ambiguousAltsErrors), _toConsumableArray(emptyRepetitionErrors));\n            return allErrors;\n          }\n          return leftRecursionErrors;\n        }\n      }, {\n        key: \"validateNoLeftRecursion\",\n        value: function validateNoLeftRecursion(rules) {\n          return flatMap(rules, function (currTopRule) {\n            return _validateNoLeftRecursion(currTopRule, currTopRule, defaultGrammarValidatorErrorProvider);\n          });\n        }\n      }, {\n        key: \"validateEmptyOrAlternatives\",\n        value: function validateEmptyOrAlternatives(rules) {\n          return flatMap(rules, function (currTopRule) {\n            return validateEmptyOrAlternative(currTopRule, defaultGrammarValidatorErrorProvider);\n          });\n        }\n      }, {\n        key: \"validateAmbiguousAlternationAlternatives\",\n        value: function validateAmbiguousAlternationAlternatives(rules, maxLookahead) {\n          return flatMap(rules, function (currTopRule) {\n            return _validateAmbiguousAlternationAlternatives(currTopRule, maxLookahead, defaultGrammarValidatorErrorProvider);\n          });\n        }\n      }, {\n        key: \"validateSomeNonEmptyLookaheadPath\",\n        value: function validateSomeNonEmptyLookaheadPath(rules, maxLookahead) {\n          return _validateSomeNonEmptyLookaheadPath(rules, maxLookahead, defaultGrammarValidatorErrorProvider);\n        }\n      }, {\n        key: \"buildLookaheadForAlternation\",\n        value: function buildLookaheadForAlternation(options) {\n          return buildLookaheadFuncForOr(options.prodOccurrence, options.rule, options.maxLookahead, options.hasPredicates, options.dynamicTokensEnabled, buildAlternativesLookAheadFunc);\n        }\n      }, {\n        key: \"buildLookaheadForOptional\",\n        value: function buildLookaheadForOptional(options) {\n          return buildLookaheadFuncForOptionalProd(options.prodOccurrence, options.rule, options.maxLookahead, options.dynamicTokensEnabled, getProdType(options.prodType), buildSingleAlternativeLookaheadFunction);\n        }\n      }]);\n      return LLkLookaheadStrategy;\n    }();\n    var LooksAhead = /*#__PURE__*/function () {\n      function LooksAhead() {\n        _classCallCheck(this, LooksAhead);\n      }\n      _createClass(LooksAhead, [{\n        key: \"initLooksAhead\",\n        value: function initLooksAhead(config) {\n          this.dynamicTokensEnabled = has(config, \"dynamicTokensEnabled\") ? config.dynamicTokensEnabled : DEFAULT_PARSER_CONFIG.dynamicTokensEnabled;\n          this.maxLookahead = has(config, \"maxLookahead\") ? config.maxLookahead : DEFAULT_PARSER_CONFIG.maxLookahead;\n          this.lookaheadStrategy = has(config, \"lookaheadStrategy\") ? config.lookaheadStrategy : new LLkLookaheadStrategy({\n            maxLookahead: this.maxLookahead\n          });\n          this.lookAheadFuncsCache = /* @__PURE__ */new Map();\n        }\n      }, {\n        key: \"preComputeLookaheadFunctions\",\n        value: function preComputeLookaheadFunctions(rules) {\n          var _this40 = this;\n          forEach(rules, function (currRule) {\n            _this40.TRACE_INIT(\"\".concat(currRule.name, \" Rule Lookahead\"), function () {\n              var _collectMethods = collectMethods(currRule),\n                alternation = _collectMethods.alternation,\n                repetition = _collectMethods.repetition,\n                option = _collectMethods.option,\n                repetitionMandatory = _collectMethods.repetitionMandatory,\n                repetitionMandatoryWithSeparator = _collectMethods.repetitionMandatoryWithSeparator,\n                repetitionWithSeparator = _collectMethods.repetitionWithSeparator;\n              forEach(alternation, function (currProd) {\n                var prodIdx = currProd.idx === 0 ? \"\" : currProd.idx;\n                _this40.TRACE_INIT(\"\".concat(getProductionDslName(currProd)).concat(prodIdx), function () {\n                  var laFunc = _this40.lookaheadStrategy.buildLookaheadForAlternation({\n                    prodOccurrence: currProd.idx,\n                    rule: currRule,\n                    maxLookahead: currProd.maxLookahead || _this40.maxLookahead,\n                    hasPredicates: currProd.hasPredicates,\n                    dynamicTokensEnabled: _this40.dynamicTokensEnabled\n                  });\n                  var key = _getKeyForAutomaticLookahead(_this40.fullRuleNameToShort[currRule.name], OR_IDX, currProd.idx);\n                  _this40.setLaFuncCache(key, laFunc);\n                });\n              });\n              forEach(repetition, function (currProd) {\n                _this40.computeLookaheadFunc(currRule, currProd.idx, MANY_IDX, \"Repetition\", currProd.maxLookahead, getProductionDslName(currProd));\n              });\n              forEach(option, function (currProd) {\n                _this40.computeLookaheadFunc(currRule, currProd.idx, OPTION_IDX, \"Option\", currProd.maxLookahead, getProductionDslName(currProd));\n              });\n              forEach(repetitionMandatory, function (currProd) {\n                _this40.computeLookaheadFunc(currRule, currProd.idx, AT_LEAST_ONE_IDX, \"RepetitionMandatory\", currProd.maxLookahead, getProductionDslName(currProd));\n              });\n              forEach(repetitionMandatoryWithSeparator, function (currProd) {\n                _this40.computeLookaheadFunc(currRule, currProd.idx, AT_LEAST_ONE_SEP_IDX, \"RepetitionMandatoryWithSeparator\", currProd.maxLookahead, getProductionDslName(currProd));\n              });\n              forEach(repetitionWithSeparator, function (currProd) {\n                _this40.computeLookaheadFunc(currRule, currProd.idx, MANY_SEP_IDX, \"RepetitionWithSeparator\", currProd.maxLookahead, getProductionDslName(currProd));\n              });\n            });\n          });\n        }\n      }, {\n        key: \"computeLookaheadFunc\",\n        value: function computeLookaheadFunc(rule, prodOccurrence, prodKey, prodType, prodMaxLookahead, dslMethodName) {\n          var _this41 = this;\n          this.TRACE_INIT(\"\".concat(dslMethodName).concat(prodOccurrence === 0 ? \"\" : prodOccurrence), function () {\n            var laFunc = _this41.lookaheadStrategy.buildLookaheadForOptional({\n              prodOccurrence: prodOccurrence,\n              rule: rule,\n              maxLookahead: prodMaxLookahead || _this41.maxLookahead,\n              dynamicTokensEnabled: _this41.dynamicTokensEnabled,\n              prodType: prodType\n            });\n            var key = _getKeyForAutomaticLookahead(_this41.fullRuleNameToShort[rule.name], prodKey, prodOccurrence);\n            _this41.setLaFuncCache(key, laFunc);\n          });\n        }\n        // this actually returns a number, but it is always used as a string (object prop key)\n      }, {\n        key: \"getKeyForAutomaticLookahead\",\n        value: function getKeyForAutomaticLookahead(dslMethodIdx, occurrence) {\n          var currRuleShortName = this.getLastExplicitRuleShortName();\n          return _getKeyForAutomaticLookahead(currRuleShortName, dslMethodIdx, occurrence);\n        }\n      }, {\n        key: \"getLaFuncFromCache\",\n        value: function getLaFuncFromCache(key) {\n          return this.lookAheadFuncsCache.get(key);\n        }\n        /* istanbul ignore next */\n      }, {\n        key: \"setLaFuncCache\",\n        value: function setLaFuncCache(key, value) {\n          this.lookAheadFuncsCache.set(key, value);\n        }\n      }]);\n      return LooksAhead;\n    }();\n    var DslMethodsCollectorVisitor = /*#__PURE__*/function (_GAstVisitor6) {\n      _inherits(DslMethodsCollectorVisitor, _GAstVisitor6);\n      var _super33 = _createSuper(DslMethodsCollectorVisitor);\n      function DslMethodsCollectorVisitor() {\n        var _this42;\n        _classCallCheck(this, DslMethodsCollectorVisitor);\n        _this42 = _super33.apply(this, arguments);\n        _this42.dslMethods = {\n          option: [],\n          alternation: [],\n          repetition: [],\n          repetitionWithSeparator: [],\n          repetitionMandatory: [],\n          repetitionMandatoryWithSeparator: []\n        };\n        return _this42;\n      }\n      _createClass(DslMethodsCollectorVisitor, [{\n        key: \"reset\",\n        value: function reset() {\n          this.dslMethods = {\n            option: [],\n            alternation: [],\n            repetition: [],\n            repetitionWithSeparator: [],\n            repetitionMandatory: [],\n            repetitionMandatoryWithSeparator: []\n          };\n        }\n      }, {\n        key: \"visitOption\",\n        value: function visitOption(option) {\n          this.dslMethods.option.push(option);\n        }\n      }, {\n        key: \"visitRepetitionWithSeparator\",\n        value: function visitRepetitionWithSeparator(manySep) {\n          this.dslMethods.repetitionWithSeparator.push(manySep);\n        }\n      }, {\n        key: \"visitRepetitionMandatory\",\n        value: function visitRepetitionMandatory(atLeastOne) {\n          this.dslMethods.repetitionMandatory.push(atLeastOne);\n        }\n      }, {\n        key: \"visitRepetitionMandatoryWithSeparator\",\n        value: function visitRepetitionMandatoryWithSeparator(atLeastOneSep) {\n          this.dslMethods.repetitionMandatoryWithSeparator.push(atLeastOneSep);\n        }\n      }, {\n        key: \"visitRepetition\",\n        value: function visitRepetition(many) {\n          this.dslMethods.repetition.push(many);\n        }\n      }, {\n        key: \"visitAlternation\",\n        value: function visitAlternation(or) {\n          this.dslMethods.alternation.push(or);\n        }\n      }]);\n      return DslMethodsCollectorVisitor;\n    }(GAstVisitor);\n    var collectorVisitor = new DslMethodsCollectorVisitor();\n    function collectMethods(rule) {\n      collectorVisitor.reset();\n      rule.accept(collectorVisitor);\n      var dslMethods = collectorVisitor.dslMethods;\n      collectorVisitor.reset();\n      return dslMethods;\n    }\n    function setNodeLocationOnlyOffset(currNodeLocation, newLocationInfo) {\n      if (isNaN(currNodeLocation.startOffset) === true) {\n        currNodeLocation.startOffset = newLocationInfo.startOffset;\n        currNodeLocation.endOffset = newLocationInfo.endOffset;\n      } else if (currNodeLocation.endOffset < newLocationInfo.endOffset === true) {\n        currNodeLocation.endOffset = newLocationInfo.endOffset;\n      }\n    }\n    function setNodeLocationFull(currNodeLocation, newLocationInfo) {\n      if (isNaN(currNodeLocation.startOffset) === true) {\n        currNodeLocation.startOffset = newLocationInfo.startOffset;\n        currNodeLocation.startColumn = newLocationInfo.startColumn;\n        currNodeLocation.startLine = newLocationInfo.startLine;\n        currNodeLocation.endOffset = newLocationInfo.endOffset;\n        currNodeLocation.endColumn = newLocationInfo.endColumn;\n        currNodeLocation.endLine = newLocationInfo.endLine;\n      } else if (currNodeLocation.endOffset < newLocationInfo.endOffset === true) {\n        currNodeLocation.endOffset = newLocationInfo.endOffset;\n        currNodeLocation.endColumn = newLocationInfo.endColumn;\n        currNodeLocation.endLine = newLocationInfo.endLine;\n      }\n    }\n    function addTerminalToCst(node, token, tokenTypeName) {\n      if (node.children[tokenTypeName] === void 0) {\n        node.children[tokenTypeName] = [token];\n      } else {\n        node.children[tokenTypeName].push(token);\n      }\n    }\n    function addNoneTerminalToCst(node, ruleName, ruleResult) {\n      if (node.children[ruleName] === void 0) {\n        node.children[ruleName] = [ruleResult];\n      } else {\n        node.children[ruleName].push(ruleResult);\n      }\n    }\n    var NAME = \"name\";\n    function defineNameProp(obj, nameValue) {\n      Object.defineProperty(obj, NAME, {\n        enumerable: false,\n        configurable: true,\n        writable: false,\n        value: nameValue\n      });\n    }\n    function defaultVisit(ctx, param) {\n      var childrenNames = keys(ctx);\n      var childrenNamesLength = childrenNames.length;\n      for (var _i15 = 0; _i15 < childrenNamesLength; _i15++) {\n        var currChildName = childrenNames[_i15];\n        var currChildArray = ctx[currChildName];\n        var currChildArrayLength = currChildArray.length;\n        for (var j = 0; j < currChildArrayLength; j++) {\n          var currChild = currChildArray[j];\n          if (currChild.tokenTypeIdx === void 0) {\n            this[currChild.name](currChild.children, param);\n          }\n        }\n      }\n    }\n    function createBaseSemanticVisitorConstructor(grammarName, ruleNames) {\n      var derivedConstructor = function derivedConstructor() {};\n      defineNameProp(derivedConstructor, grammarName + \"BaseSemantics\");\n      var semanticProto = {\n        visit: function visit(cstNode, param) {\n          if (isArray$1(cstNode)) {\n            cstNode = cstNode[0];\n          }\n          if (isUndefined(cstNode)) {\n            return void 0;\n          }\n          return this[cstNode.name](cstNode.children, param);\n        },\n        validateVisitor: function validateVisitor() {\n          var semanticDefinitionErrors = _validateVisitor(this, ruleNames);\n          if (!isEmpty(semanticDefinitionErrors)) {\n            var errorMessages = map(semanticDefinitionErrors, function (currDefError) {\n              return currDefError.msg;\n            });\n            throw Error(\"Errors Detected in CST Visitor <\".concat(this.constructor.name, \">:\\n\\t\").concat(errorMessages.join(\"\\n\\n\").replace(/\\n/g, \"\\n\t\")));\n          }\n        }\n      };\n      derivedConstructor.prototype = semanticProto;\n      derivedConstructor.prototype.constructor = derivedConstructor;\n      derivedConstructor._RULE_NAMES = ruleNames;\n      return derivedConstructor;\n    }\n    function createBaseVisitorConstructorWithDefaults(grammarName, ruleNames, baseConstructor) {\n      var derivedConstructor = function derivedConstructor() {};\n      defineNameProp(derivedConstructor, grammarName + \"BaseSemanticsWithDefaults\");\n      var withDefaultsProto = Object.create(baseConstructor.prototype);\n      forEach(ruleNames, function (ruleName) {\n        withDefaultsProto[ruleName] = defaultVisit;\n      });\n      derivedConstructor.prototype = withDefaultsProto;\n      derivedConstructor.prototype.constructor = derivedConstructor;\n      return derivedConstructor;\n    }\n    var CstVisitorDefinitionError;\n    (function (CstVisitorDefinitionError2) {\n      CstVisitorDefinitionError2[CstVisitorDefinitionError2[\"REDUNDANT_METHOD\"] = 0] = \"REDUNDANT_METHOD\";\n      CstVisitorDefinitionError2[CstVisitorDefinitionError2[\"MISSING_METHOD\"] = 1] = \"MISSING_METHOD\";\n    })(CstVisitorDefinitionError || (CstVisitorDefinitionError = {}));\n    function _validateVisitor(visitorInstance, ruleNames) {\n      var missingErrors = validateMissingCstMethods(visitorInstance, ruleNames);\n      return missingErrors;\n    }\n    function validateMissingCstMethods(visitorInstance, ruleNames) {\n      var missingRuleNames = filter(ruleNames, function (currRuleName) {\n        return isFunction(visitorInstance[currRuleName]) === false;\n      });\n      var errors = map(missingRuleNames, function (currRuleName) {\n        return {\n          msg: \"Missing visitor method: <\".concat(currRuleName, \"> on \").concat(visitorInstance.constructor.name, \" CST Visitor.\"),\n          type: CstVisitorDefinitionError.MISSING_METHOD,\n          methodName: currRuleName\n        };\n      });\n      return compact(errors);\n    }\n    var TreeBuilder = /*#__PURE__*/function () {\n      function TreeBuilder() {\n        _classCallCheck(this, TreeBuilder);\n      }\n      _createClass(TreeBuilder, [{\n        key: \"initTreeBuilder\",\n        value: function initTreeBuilder(config) {\n          this.CST_STACK = [];\n          this.outputCst = config.outputCst;\n          this.nodeLocationTracking = has(config, \"nodeLocationTracking\") ? config.nodeLocationTracking : DEFAULT_PARSER_CONFIG.nodeLocationTracking;\n          if (!this.outputCst) {\n            this.cstInvocationStateUpdate = noop;\n            this.cstFinallyStateUpdate = noop;\n            this.cstPostTerminal = noop;\n            this.cstPostNonTerminal = noop;\n            this.cstPostRule = noop;\n          } else {\n            if (/full/i.test(this.nodeLocationTracking)) {\n              if (this.recoveryEnabled) {\n                this.setNodeLocationFromToken = setNodeLocationFull;\n                this.setNodeLocationFromNode = setNodeLocationFull;\n                this.cstPostRule = noop;\n                this.setInitialNodeLocation = this.setInitialNodeLocationFullRecovery;\n              } else {\n                this.setNodeLocationFromToken = noop;\n                this.setNodeLocationFromNode = noop;\n                this.cstPostRule = this.cstPostRuleFull;\n                this.setInitialNodeLocation = this.setInitialNodeLocationFullRegular;\n              }\n            } else if (/onlyOffset/i.test(this.nodeLocationTracking)) {\n              if (this.recoveryEnabled) {\n                this.setNodeLocationFromToken = setNodeLocationOnlyOffset;\n                this.setNodeLocationFromNode = setNodeLocationOnlyOffset;\n                this.cstPostRule = noop;\n                this.setInitialNodeLocation = this.setInitialNodeLocationOnlyOffsetRecovery;\n              } else {\n                this.setNodeLocationFromToken = noop;\n                this.setNodeLocationFromNode = noop;\n                this.cstPostRule = this.cstPostRuleOnlyOffset;\n                this.setInitialNodeLocation = this.setInitialNodeLocationOnlyOffsetRegular;\n              }\n            } else if (/none/i.test(this.nodeLocationTracking)) {\n              this.setNodeLocationFromToken = noop;\n              this.setNodeLocationFromNode = noop;\n              this.cstPostRule = noop;\n              this.setInitialNodeLocation = noop;\n            } else {\n              throw Error(\"Invalid <nodeLocationTracking> config option: \\\"\".concat(config.nodeLocationTracking, \"\\\"\"));\n            }\n          }\n        }\n      }, {\n        key: \"setInitialNodeLocationOnlyOffsetRecovery\",\n        value: function setInitialNodeLocationOnlyOffsetRecovery(cstNode) {\n          cstNode.location = {\n            startOffset: NaN,\n            endOffset: NaN\n          };\n        }\n      }, {\n        key: \"setInitialNodeLocationOnlyOffsetRegular\",\n        value: function setInitialNodeLocationOnlyOffsetRegular(cstNode) {\n          cstNode.location = {\n            // without error recovery the starting Location of a new CstNode is guaranteed\n            // To be the next Token's startOffset (for valid inputs).\n            // For invalid inputs there won't be any CSTOutput so this potential\n            // inaccuracy does not matter\n            startOffset: this.LA(1).startOffset,\n            endOffset: NaN\n          };\n        }\n      }, {\n        key: \"setInitialNodeLocationFullRecovery\",\n        value: function setInitialNodeLocationFullRecovery(cstNode) {\n          cstNode.location = {\n            startOffset: NaN,\n            startLine: NaN,\n            startColumn: NaN,\n            endOffset: NaN,\n            endLine: NaN,\n            endColumn: NaN\n          };\n        }\n        /**\n             *  @see setInitialNodeLocationOnlyOffsetRegular for explanation why this work\n        \n             * @param cstNode\n             */\n      }, {\n        key: \"setInitialNodeLocationFullRegular\",\n        value: function setInitialNodeLocationFullRegular(cstNode) {\n          var nextToken = this.LA(1);\n          cstNode.location = {\n            startOffset: nextToken.startOffset,\n            startLine: nextToken.startLine,\n            startColumn: nextToken.startColumn,\n            endOffset: NaN,\n            endLine: NaN,\n            endColumn: NaN\n          };\n        }\n      }, {\n        key: \"cstInvocationStateUpdate\",\n        value: function cstInvocationStateUpdate(fullRuleName) {\n          var cstNode = {\n            name: fullRuleName,\n            children: /* @__PURE__ */Object.create(null)\n          };\n          this.setInitialNodeLocation(cstNode);\n          this.CST_STACK.push(cstNode);\n        }\n      }, {\n        key: \"cstFinallyStateUpdate\",\n        value: function cstFinallyStateUpdate() {\n          this.CST_STACK.pop();\n        }\n      }, {\n        key: \"cstPostRuleFull\",\n        value: function cstPostRuleFull(ruleCstNode) {\n          var prevToken = this.LA(0);\n          var loc = ruleCstNode.location;\n          if (loc.startOffset <= prevToken.startOffset === true) {\n            loc.endOffset = prevToken.endOffset;\n            loc.endLine = prevToken.endLine;\n            loc.endColumn = prevToken.endColumn;\n          } else {\n            loc.startOffset = NaN;\n            loc.startLine = NaN;\n            loc.startColumn = NaN;\n          }\n        }\n      }, {\n        key: \"cstPostRuleOnlyOffset\",\n        value: function cstPostRuleOnlyOffset(ruleCstNode) {\n          var prevToken = this.LA(0);\n          var loc = ruleCstNode.location;\n          if (loc.startOffset <= prevToken.startOffset === true) {\n            loc.endOffset = prevToken.endOffset;\n          } else {\n            loc.startOffset = NaN;\n          }\n        }\n      }, {\n        key: \"cstPostTerminal\",\n        value: function cstPostTerminal(key, consumedToken) {\n          var rootCst = this.CST_STACK[this.CST_STACK.length - 1];\n          addTerminalToCst(rootCst, consumedToken, key);\n          this.setNodeLocationFromToken(rootCst.location, consumedToken);\n        }\n      }, {\n        key: \"cstPostNonTerminal\",\n        value: function cstPostNonTerminal(ruleCstResult, ruleName) {\n          var preCstNode = this.CST_STACK[this.CST_STACK.length - 1];\n          addNoneTerminalToCst(preCstNode, ruleName, ruleCstResult);\n          this.setNodeLocationFromNode(preCstNode.location, ruleCstResult.location);\n        }\n      }, {\n        key: \"getBaseCstVisitorConstructor\",\n        value: function getBaseCstVisitorConstructor() {\n          if (isUndefined(this.baseCstVisitorConstructor)) {\n            var newBaseCstVisitorConstructor = createBaseSemanticVisitorConstructor(this.className, keys(this.gastProductionsCache));\n            this.baseCstVisitorConstructor = newBaseCstVisitorConstructor;\n            return newBaseCstVisitorConstructor;\n          }\n          return this.baseCstVisitorConstructor;\n        }\n      }, {\n        key: \"getBaseCstVisitorConstructorWithDefaults\",\n        value: function getBaseCstVisitorConstructorWithDefaults() {\n          if (isUndefined(this.baseCstVisitorWithDefaultsConstructor)) {\n            var newConstructor = createBaseVisitorConstructorWithDefaults(this.className, keys(this.gastProductionsCache), this.getBaseCstVisitorConstructor());\n            this.baseCstVisitorWithDefaultsConstructor = newConstructor;\n            return newConstructor;\n          }\n          return this.baseCstVisitorWithDefaultsConstructor;\n        }\n      }, {\n        key: \"getLastExplicitRuleShortName\",\n        value: function getLastExplicitRuleShortName() {\n          var ruleStack = this.RULE_STACK;\n          return ruleStack[ruleStack.length - 1];\n        }\n      }, {\n        key: \"getPreviousExplicitRuleShortName\",\n        value: function getPreviousExplicitRuleShortName() {\n          var ruleStack = this.RULE_STACK;\n          return ruleStack[ruleStack.length - 2];\n        }\n      }, {\n        key: \"getLastExplicitRuleOccurrenceIndex\",\n        value: function getLastExplicitRuleOccurrenceIndex() {\n          var occurrenceStack = this.RULE_OCCURRENCE_STACK;\n          return occurrenceStack[occurrenceStack.length - 1];\n        }\n      }]);\n      return TreeBuilder;\n    }();\n    var LexerAdapter = /*#__PURE__*/function () {\n      function LexerAdapter() {\n        _classCallCheck(this, LexerAdapter);\n      }\n      _createClass(LexerAdapter, [{\n        key: \"initLexerAdapter\",\n        value: function initLexerAdapter() {\n          this.tokVector = [];\n          this.tokVectorLength = 0;\n          this.currIdx = -1;\n        }\n      }, {\n        key: \"input\",\n        get: function get() {\n          return this.tokVector;\n        }\n        // skips a token and returns the next token\n        ,\n        set: function set(newInput) {\n          if (this.selfAnalysisDone !== true) {\n            throw Error(\"Missing <performSelfAnalysis> invocation at the end of the Parser's constructor.\");\n          }\n          this.reset();\n          this.tokVector = newInput;\n          this.tokVectorLength = newInput.length;\n        }\n      }, {\n        key: \"SKIP_TOKEN\",\n        value: function SKIP_TOKEN() {\n          if (this.currIdx <= this.tokVector.length - 2) {\n            this.consumeToken();\n            return this.LA(1);\n          } else {\n            return END_OF_FILE;\n          }\n        }\n        // Lexer (accessing Token vector) related methods which can be overridden to implement lazy lexers\n        // or lexers dependent on parser context.\n      }, {\n        key: \"LA\",\n        value: function LA(howMuch) {\n          var soughtIdx = this.currIdx + howMuch;\n          if (soughtIdx < 0 || this.tokVectorLength <= soughtIdx) {\n            return END_OF_FILE;\n          } else {\n            return this.tokVector[soughtIdx];\n          }\n        }\n      }, {\n        key: \"consumeToken\",\n        value: function consumeToken() {\n          this.currIdx++;\n        }\n      }, {\n        key: \"exportLexerState\",\n        value: function exportLexerState() {\n          return this.currIdx;\n        }\n      }, {\n        key: \"importLexerState\",\n        value: function importLexerState(newState) {\n          this.currIdx = newState;\n        }\n      }, {\n        key: \"resetLexerState\",\n        value: function resetLexerState() {\n          this.currIdx = -1;\n        }\n      }, {\n        key: \"moveToTerminatedState\",\n        value: function moveToTerminatedState() {\n          this.currIdx = this.tokVector.length - 1;\n        }\n      }, {\n        key: \"getLexerPosition\",\n        value: function getLexerPosition() {\n          return this.exportLexerState();\n        }\n      }]);\n      return LexerAdapter;\n    }();\n    var RecognizerApi = /*#__PURE__*/function () {\n      function RecognizerApi() {\n        _classCallCheck(this, RecognizerApi);\n      }\n      _createClass(RecognizerApi, [{\n        key: \"ACTION\",\n        value: function ACTION(impl) {\n          return impl.call(this);\n        }\n      }, {\n        key: \"consume\",\n        value: function consume(idx, tokType, options) {\n          return this.consumeInternal(tokType, idx, options);\n        }\n      }, {\n        key: \"subrule\",\n        value: function subrule(idx, ruleToCall, options) {\n          return this.subruleInternal(ruleToCall, idx, options);\n        }\n      }, {\n        key: \"option\",\n        value: function option(idx, actionORMethodDef) {\n          return this.optionInternal(actionORMethodDef, idx);\n        }\n      }, {\n        key: \"or\",\n        value: function or(idx, altsOrOpts) {\n          return this.orInternal(altsOrOpts, idx);\n        }\n      }, {\n        key: \"many\",\n        value: function many(idx, actionORMethodDef) {\n          return this.manyInternal(idx, actionORMethodDef);\n        }\n      }, {\n        key: \"atLeastOne\",\n        value: function atLeastOne(idx, actionORMethodDef) {\n          return this.atLeastOneInternal(idx, actionORMethodDef);\n        }\n      }, {\n        key: \"CONSUME\",\n        value: function CONSUME(tokType, options) {\n          return this.consumeInternal(tokType, 0, options);\n        }\n      }, {\n        key: \"CONSUME1\",\n        value: function CONSUME1(tokType, options) {\n          return this.consumeInternal(tokType, 1, options);\n        }\n      }, {\n        key: \"CONSUME2\",\n        value: function CONSUME2(tokType, options) {\n          return this.consumeInternal(tokType, 2, options);\n        }\n      }, {\n        key: \"CONSUME3\",\n        value: function CONSUME3(tokType, options) {\n          return this.consumeInternal(tokType, 3, options);\n        }\n      }, {\n        key: \"CONSUME4\",\n        value: function CONSUME4(tokType, options) {\n          return this.consumeInternal(tokType, 4, options);\n        }\n      }, {\n        key: \"CONSUME5\",\n        value: function CONSUME5(tokType, options) {\n          return this.consumeInternal(tokType, 5, options);\n        }\n      }, {\n        key: \"CONSUME6\",\n        value: function CONSUME6(tokType, options) {\n          return this.consumeInternal(tokType, 6, options);\n        }\n      }, {\n        key: \"CONSUME7\",\n        value: function CONSUME7(tokType, options) {\n          return this.consumeInternal(tokType, 7, options);\n        }\n      }, {\n        key: \"CONSUME8\",\n        value: function CONSUME8(tokType, options) {\n          return this.consumeInternal(tokType, 8, options);\n        }\n      }, {\n        key: \"CONSUME9\",\n        value: function CONSUME9(tokType, options) {\n          return this.consumeInternal(tokType, 9, options);\n        }\n      }, {\n        key: \"SUBRULE\",\n        value: function SUBRULE(ruleToCall, options) {\n          return this.subruleInternal(ruleToCall, 0, options);\n        }\n      }, {\n        key: \"SUBRULE1\",\n        value: function SUBRULE1(ruleToCall, options) {\n          return this.subruleInternal(ruleToCall, 1, options);\n        }\n      }, {\n        key: \"SUBRULE2\",\n        value: function SUBRULE2(ruleToCall, options) {\n          return this.subruleInternal(ruleToCall, 2, options);\n        }\n      }, {\n        key: \"SUBRULE3\",\n        value: function SUBRULE3(ruleToCall, options) {\n          return this.subruleInternal(ruleToCall, 3, options);\n        }\n      }, {\n        key: \"SUBRULE4\",\n        value: function SUBRULE4(ruleToCall, options) {\n          return this.subruleInternal(ruleToCall, 4, options);\n        }\n      }, {\n        key: \"SUBRULE5\",\n        value: function SUBRULE5(ruleToCall, options) {\n          return this.subruleInternal(ruleToCall, 5, options);\n        }\n      }, {\n        key: \"SUBRULE6\",\n        value: function SUBRULE6(ruleToCall, options) {\n          return this.subruleInternal(ruleToCall, 6, options);\n        }\n      }, {\n        key: \"SUBRULE7\",\n        value: function SUBRULE7(ruleToCall, options) {\n          return this.subruleInternal(ruleToCall, 7, options);\n        }\n      }, {\n        key: \"SUBRULE8\",\n        value: function SUBRULE8(ruleToCall, options) {\n          return this.subruleInternal(ruleToCall, 8, options);\n        }\n      }, {\n        key: \"SUBRULE9\",\n        value: function SUBRULE9(ruleToCall, options) {\n          return this.subruleInternal(ruleToCall, 9, options);\n        }\n      }, {\n        key: \"OPTION\",\n        value: function OPTION(actionORMethodDef) {\n          return this.optionInternal(actionORMethodDef, 0);\n        }\n      }, {\n        key: \"OPTION1\",\n        value: function OPTION1(actionORMethodDef) {\n          return this.optionInternal(actionORMethodDef, 1);\n        }\n      }, {\n        key: \"OPTION2\",\n        value: function OPTION2(actionORMethodDef) {\n          return this.optionInternal(actionORMethodDef, 2);\n        }\n      }, {\n        key: \"OPTION3\",\n        value: function OPTION3(actionORMethodDef) {\n          return this.optionInternal(actionORMethodDef, 3);\n        }\n      }, {\n        key: \"OPTION4\",\n        value: function OPTION4(actionORMethodDef) {\n          return this.optionInternal(actionORMethodDef, 4);\n        }\n      }, {\n        key: \"OPTION5\",\n        value: function OPTION5(actionORMethodDef) {\n          return this.optionInternal(actionORMethodDef, 5);\n        }\n      }, {\n        key: \"OPTION6\",\n        value: function OPTION6(actionORMethodDef) {\n          return this.optionInternal(actionORMethodDef, 6);\n        }\n      }, {\n        key: \"OPTION7\",\n        value: function OPTION7(actionORMethodDef) {\n          return this.optionInternal(actionORMethodDef, 7);\n        }\n      }, {\n        key: \"OPTION8\",\n        value: function OPTION8(actionORMethodDef) {\n          return this.optionInternal(actionORMethodDef, 8);\n        }\n      }, {\n        key: \"OPTION9\",\n        value: function OPTION9(actionORMethodDef) {\n          return this.optionInternal(actionORMethodDef, 9);\n        }\n      }, {\n        key: \"OR\",\n        value: function OR(altsOrOpts) {\n          return this.orInternal(altsOrOpts, 0);\n        }\n      }, {\n        key: \"OR1\",\n        value: function OR1(altsOrOpts) {\n          return this.orInternal(altsOrOpts, 1);\n        }\n      }, {\n        key: \"OR2\",\n        value: function OR2(altsOrOpts) {\n          return this.orInternal(altsOrOpts, 2);\n        }\n      }, {\n        key: \"OR3\",\n        value: function OR3(altsOrOpts) {\n          return this.orInternal(altsOrOpts, 3);\n        }\n      }, {\n        key: \"OR4\",\n        value: function OR4(altsOrOpts) {\n          return this.orInternal(altsOrOpts, 4);\n        }\n      }, {\n        key: \"OR5\",\n        value: function OR5(altsOrOpts) {\n          return this.orInternal(altsOrOpts, 5);\n        }\n      }, {\n        key: \"OR6\",\n        value: function OR6(altsOrOpts) {\n          return this.orInternal(altsOrOpts, 6);\n        }\n      }, {\n        key: \"OR7\",\n        value: function OR7(altsOrOpts) {\n          return this.orInternal(altsOrOpts, 7);\n        }\n      }, {\n        key: \"OR8\",\n        value: function OR8(altsOrOpts) {\n          return this.orInternal(altsOrOpts, 8);\n        }\n      }, {\n        key: \"OR9\",\n        value: function OR9(altsOrOpts) {\n          return this.orInternal(altsOrOpts, 9);\n        }\n      }, {\n        key: \"MANY\",\n        value: function MANY(actionORMethodDef) {\n          this.manyInternal(0, actionORMethodDef);\n        }\n      }, {\n        key: \"MANY1\",\n        value: function MANY1(actionORMethodDef) {\n          this.manyInternal(1, actionORMethodDef);\n        }\n      }, {\n        key: \"MANY2\",\n        value: function MANY2(actionORMethodDef) {\n          this.manyInternal(2, actionORMethodDef);\n        }\n      }, {\n        key: \"MANY3\",\n        value: function MANY3(actionORMethodDef) {\n          this.manyInternal(3, actionORMethodDef);\n        }\n      }, {\n        key: \"MANY4\",\n        value: function MANY4(actionORMethodDef) {\n          this.manyInternal(4, actionORMethodDef);\n        }\n      }, {\n        key: \"MANY5\",\n        value: function MANY5(actionORMethodDef) {\n          this.manyInternal(5, actionORMethodDef);\n        }\n      }, {\n        key: \"MANY6\",\n        value: function MANY6(actionORMethodDef) {\n          this.manyInternal(6, actionORMethodDef);\n        }\n      }, {\n        key: \"MANY7\",\n        value: function MANY7(actionORMethodDef) {\n          this.manyInternal(7, actionORMethodDef);\n        }\n      }, {\n        key: \"MANY8\",\n        value: function MANY8(actionORMethodDef) {\n          this.manyInternal(8, actionORMethodDef);\n        }\n      }, {\n        key: \"MANY9\",\n        value: function MANY9(actionORMethodDef) {\n          this.manyInternal(9, actionORMethodDef);\n        }\n      }, {\n        key: \"MANY_SEP\",\n        value: function MANY_SEP(options) {\n          this.manySepFirstInternal(0, options);\n        }\n      }, {\n        key: \"MANY_SEP1\",\n        value: function MANY_SEP1(options) {\n          this.manySepFirstInternal(1, options);\n        }\n      }, {\n        key: \"MANY_SEP2\",\n        value: function MANY_SEP2(options) {\n          this.manySepFirstInternal(2, options);\n        }\n      }, {\n        key: \"MANY_SEP3\",\n        value: function MANY_SEP3(options) {\n          this.manySepFirstInternal(3, options);\n        }\n      }, {\n        key: \"MANY_SEP4\",\n        value: function MANY_SEP4(options) {\n          this.manySepFirstInternal(4, options);\n        }\n      }, {\n        key: \"MANY_SEP5\",\n        value: function MANY_SEP5(options) {\n          this.manySepFirstInternal(5, options);\n        }\n      }, {\n        key: \"MANY_SEP6\",\n        value: function MANY_SEP6(options) {\n          this.manySepFirstInternal(6, options);\n        }\n      }, {\n        key: \"MANY_SEP7\",\n        value: function MANY_SEP7(options) {\n          this.manySepFirstInternal(7, options);\n        }\n      }, {\n        key: \"MANY_SEP8\",\n        value: function MANY_SEP8(options) {\n          this.manySepFirstInternal(8, options);\n        }\n      }, {\n        key: \"MANY_SEP9\",\n        value: function MANY_SEP9(options) {\n          this.manySepFirstInternal(9, options);\n        }\n      }, {\n        key: \"AT_LEAST_ONE\",\n        value: function AT_LEAST_ONE(actionORMethodDef) {\n          this.atLeastOneInternal(0, actionORMethodDef);\n        }\n      }, {\n        key: \"AT_LEAST_ONE1\",\n        value: function AT_LEAST_ONE1(actionORMethodDef) {\n          return this.atLeastOneInternal(1, actionORMethodDef);\n        }\n      }, {\n        key: \"AT_LEAST_ONE2\",\n        value: function AT_LEAST_ONE2(actionORMethodDef) {\n          this.atLeastOneInternal(2, actionORMethodDef);\n        }\n      }, {\n        key: \"AT_LEAST_ONE3\",\n        value: function AT_LEAST_ONE3(actionORMethodDef) {\n          this.atLeastOneInternal(3, actionORMethodDef);\n        }\n      }, {\n        key: \"AT_LEAST_ONE4\",\n        value: function AT_LEAST_ONE4(actionORMethodDef) {\n          this.atLeastOneInternal(4, actionORMethodDef);\n        }\n      }, {\n        key: \"AT_LEAST_ONE5\",\n        value: function AT_LEAST_ONE5(actionORMethodDef) {\n          this.atLeastOneInternal(5, actionORMethodDef);\n        }\n      }, {\n        key: \"AT_LEAST_ONE6\",\n        value: function AT_LEAST_ONE6(actionORMethodDef) {\n          this.atLeastOneInternal(6, actionORMethodDef);\n        }\n      }, {\n        key: \"AT_LEAST_ONE7\",\n        value: function AT_LEAST_ONE7(actionORMethodDef) {\n          this.atLeastOneInternal(7, actionORMethodDef);\n        }\n      }, {\n        key: \"AT_LEAST_ONE8\",\n        value: function AT_LEAST_ONE8(actionORMethodDef) {\n          this.atLeastOneInternal(8, actionORMethodDef);\n        }\n      }, {\n        key: \"AT_LEAST_ONE9\",\n        value: function AT_LEAST_ONE9(actionORMethodDef) {\n          this.atLeastOneInternal(9, actionORMethodDef);\n        }\n      }, {\n        key: \"AT_LEAST_ONE_SEP\",\n        value: function AT_LEAST_ONE_SEP(options) {\n          this.atLeastOneSepFirstInternal(0, options);\n        }\n      }, {\n        key: \"AT_LEAST_ONE_SEP1\",\n        value: function AT_LEAST_ONE_SEP1(options) {\n          this.atLeastOneSepFirstInternal(1, options);\n        }\n      }, {\n        key: \"AT_LEAST_ONE_SEP2\",\n        value: function AT_LEAST_ONE_SEP2(options) {\n          this.atLeastOneSepFirstInternal(2, options);\n        }\n      }, {\n        key: \"AT_LEAST_ONE_SEP3\",\n        value: function AT_LEAST_ONE_SEP3(options) {\n          this.atLeastOneSepFirstInternal(3, options);\n        }\n      }, {\n        key: \"AT_LEAST_ONE_SEP4\",\n        value: function AT_LEAST_ONE_SEP4(options) {\n          this.atLeastOneSepFirstInternal(4, options);\n        }\n      }, {\n        key: \"AT_LEAST_ONE_SEP5\",\n        value: function AT_LEAST_ONE_SEP5(options) {\n          this.atLeastOneSepFirstInternal(5, options);\n        }\n      }, {\n        key: \"AT_LEAST_ONE_SEP6\",\n        value: function AT_LEAST_ONE_SEP6(options) {\n          this.atLeastOneSepFirstInternal(6, options);\n        }\n      }, {\n        key: \"AT_LEAST_ONE_SEP7\",\n        value: function AT_LEAST_ONE_SEP7(options) {\n          this.atLeastOneSepFirstInternal(7, options);\n        }\n      }, {\n        key: \"AT_LEAST_ONE_SEP8\",\n        value: function AT_LEAST_ONE_SEP8(options) {\n          this.atLeastOneSepFirstInternal(8, options);\n        }\n      }, {\n        key: \"AT_LEAST_ONE_SEP9\",\n        value: function AT_LEAST_ONE_SEP9(options) {\n          this.atLeastOneSepFirstInternal(9, options);\n        }\n      }, {\n        key: \"RULE\",\n        value: function RULE(name, implementation) {\n          var config = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : DEFAULT_RULE_CONFIG;\n          if (includes(this.definedRulesNames, name)) {\n            var errMsg = defaultGrammarValidatorErrorProvider.buildDuplicateRuleNameError({\n              topLevelRule: name,\n              grammarName: this.className\n            });\n            var error = {\n              message: errMsg,\n              type: ParserDefinitionErrorType.DUPLICATE_RULE_NAME,\n              ruleName: name\n            };\n            this.definitionErrors.push(error);\n          }\n          this.definedRulesNames.push(name);\n          var ruleImplementation = this.defineRule(name, implementation, config);\n          this[name] = ruleImplementation;\n          return ruleImplementation;\n        }\n      }, {\n        key: \"OVERRIDE_RULE\",\n        value: function OVERRIDE_RULE(name, impl) {\n          var config = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : DEFAULT_RULE_CONFIG;\n          var ruleErrors = validateRuleIsOverridden(name, this.definedRulesNames, this.className);\n          this.definitionErrors = this.definitionErrors.concat(ruleErrors);\n          var ruleImplementation = this.defineRule(name, impl, config);\n          this[name] = ruleImplementation;\n          return ruleImplementation;\n        }\n      }, {\n        key: \"BACKTRACK\",\n        value: function BACKTRACK(grammarRule, args) {\n          return function () {\n            this.isBackTrackingStack.push(1);\n            var orgState = this.saveRecogState();\n            try {\n              grammarRule.apply(this, args);\n              return true;\n            } catch (e) {\n              if (isRecognitionException(e)) {\n                return false;\n              } else {\n                throw e;\n              }\n            } finally {\n              this.reloadRecogState(orgState);\n              this.isBackTrackingStack.pop();\n            }\n          };\n        }\n        // GAST export APIs\n      }, {\n        key: \"getGAstProductions\",\n        value: function getGAstProductions() {\n          return this.gastProductionsCache;\n        }\n      }, {\n        key: \"getSerializedGastProductions\",\n        value: function getSerializedGastProductions() {\n          return serializeGrammar(values(this.gastProductionsCache));\n        }\n      }]);\n      return RecognizerApi;\n    }();\n    var RecognizerEngine = /*#__PURE__*/function () {\n      function RecognizerEngine() {\n        _classCallCheck(this, RecognizerEngine);\n      }\n      _createClass(RecognizerEngine, [{\n        key: \"initRecognizerEngine\",\n        value: function initRecognizerEngine(tokenVocabulary, config) {\n          this.className = this.constructor.name;\n          this.shortRuleNameToFull = {};\n          this.fullRuleNameToShort = {};\n          this.ruleShortNameIdx = 256;\n          this.tokenMatcher = tokenStructuredMatcherNoCategories;\n          this.subruleIdx = 0;\n          this.definedRulesNames = [];\n          this.tokensMap = {};\n          this.isBackTrackingStack = [];\n          this.RULE_STACK = [];\n          this.RULE_OCCURRENCE_STACK = [];\n          this.gastProductionsCache = {};\n          if (has(config, \"serializedGrammar\")) {\n            throw Error(\"The Parser's configuration can no longer contain a <serializedGrammar> property.\\n\tSee: https://chevrotain.io/docs/changes/BREAKING_CHANGES.html#_6-0-0\\n\tFor Further details.\");\n          }\n          if (isArray$1(tokenVocabulary)) {\n            if (isEmpty(tokenVocabulary)) {\n              throw Error(\"A Token Vocabulary cannot be empty.\\n\tNote that the first argument for the parser constructor\\n\tis no longer a Token vector (since v4.0).\");\n            }\n            if (typeof tokenVocabulary[0].startOffset === \"number\") {\n              throw Error(\"The Parser constructor no longer accepts a token vector as the first argument.\\n\tSee: https://chevrotain.io/docs/changes/BREAKING_CHANGES.html#_4-0-0\\n\tFor Further details.\");\n            }\n          }\n          if (isArray$1(tokenVocabulary)) {\n            this.tokensMap = reduce(tokenVocabulary, function (acc, tokType) {\n              acc[tokType.name] = tokType;\n              return acc;\n            }, {});\n          } else if (has(tokenVocabulary, \"modes\") && every(flatten(values(tokenVocabulary.modes)), isTokenType)) {\n            var allTokenTypes2 = flatten(values(tokenVocabulary.modes));\n            var uniqueTokens = uniq(allTokenTypes2);\n            this.tokensMap = reduce(uniqueTokens, function (acc, tokType) {\n              acc[tokType.name] = tokType;\n              return acc;\n            }, {});\n          } else if (isObject(tokenVocabulary)) {\n            this.tokensMap = clone(tokenVocabulary);\n          } else {\n            throw new Error(\"<tokensDictionary> argument must be An Array of Token constructors, A dictionary of Token constructors or an IMultiModeLexerDefinition\");\n          }\n          this.tokensMap[\"EOF\"] = EOF;\n          var allTokenTypes = has(tokenVocabulary, \"modes\") ? flatten(values(tokenVocabulary.modes)) : values(tokenVocabulary);\n          var noTokenCategoriesUsed = every(allTokenTypes, function (tokenConstructor) {\n            return isEmpty(tokenConstructor.categoryMatches);\n          });\n          this.tokenMatcher = noTokenCategoriesUsed ? tokenStructuredMatcherNoCategories : tokenStructuredMatcher;\n          augmentTokenTypes(values(this.tokensMap));\n        }\n      }, {\n        key: \"defineRule\",\n        value: function defineRule(ruleName, impl, config) {\n          if (this.selfAnalysisDone) {\n            throw Error(\"Grammar rule <\".concat(ruleName, \"> may not be defined after the 'performSelfAnalysis' method has been called'\\nMake sure that all grammar rule definitions are done before 'performSelfAnalysis' is called.\"));\n          }\n          var resyncEnabled = has(config, \"resyncEnabled\") ? config.resyncEnabled : DEFAULT_RULE_CONFIG.resyncEnabled;\n          var recoveryValueFunc = has(config, \"recoveryValueFunc\") ? config.recoveryValueFunc : DEFAULT_RULE_CONFIG.recoveryValueFunc;\n          var shortName = this.ruleShortNameIdx << BITS_FOR_METHOD_TYPE + BITS_FOR_OCCURRENCE_IDX;\n          this.ruleShortNameIdx++;\n          this.shortRuleNameToFull[shortName] = ruleName;\n          this.fullRuleNameToShort[ruleName] = shortName;\n          var invokeRuleWithTry;\n          if (this.outputCst === true) {\n            invokeRuleWithTry = function invokeRuleWithTry2() {\n              try {\n                this.ruleInvocationStateUpdate(shortName, ruleName, this.subruleIdx);\n                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n                  args[_key] = arguments[_key];\n                }\n                impl.apply(this, args);\n                var cst = this.CST_STACK[this.CST_STACK.length - 1];\n                this.cstPostRule(cst);\n                return cst;\n              } catch (e) {\n                return this.invokeRuleCatch(e, resyncEnabled, recoveryValueFunc);\n              } finally {\n                this.ruleFinallyStateUpdate();\n              }\n            };\n          } else {\n            invokeRuleWithTry = function invokeRuleWithTryCst() {\n              try {\n                this.ruleInvocationStateUpdate(shortName, ruleName, this.subruleIdx);\n                for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n                  args[_key2] = arguments[_key2];\n                }\n                return impl.apply(this, args);\n              } catch (e) {\n                return this.invokeRuleCatch(e, resyncEnabled, recoveryValueFunc);\n              } finally {\n                this.ruleFinallyStateUpdate();\n              }\n            };\n          }\n          var wrappedGrammarRule = Object.assign(invokeRuleWithTry, {\n            ruleName: ruleName,\n            originalGrammarAction: impl\n          });\n          return wrappedGrammarRule;\n        }\n      }, {\n        key: \"invokeRuleCatch\",\n        value: function invokeRuleCatch(e, resyncEnabledConfig, recoveryValueFunc) {\n          var isFirstInvokedRule = this.RULE_STACK.length === 1;\n          var reSyncEnabled = resyncEnabledConfig && !this.isBackTracking() && this.recoveryEnabled;\n          if (isRecognitionException(e)) {\n            var recogError = e;\n            if (reSyncEnabled) {\n              var reSyncTokType = this.findReSyncTokenType();\n              if (this.isInCurrentRuleReSyncSet(reSyncTokType)) {\n                recogError.resyncedTokens = this.reSyncTo(reSyncTokType);\n                if (this.outputCst) {\n                  var partialCstResult = this.CST_STACK[this.CST_STACK.length - 1];\n                  partialCstResult.recoveredNode = true;\n                  return partialCstResult;\n                } else {\n                  return recoveryValueFunc(e);\n                }\n              } else {\n                if (this.outputCst) {\n                  var _partialCstResult = this.CST_STACK[this.CST_STACK.length - 1];\n                  _partialCstResult.recoveredNode = true;\n                  recogError.partialCstResult = _partialCstResult;\n                }\n                throw recogError;\n              }\n            } else if (isFirstInvokedRule) {\n              this.moveToTerminatedState();\n              return recoveryValueFunc(e);\n            } else {\n              throw recogError;\n            }\n          } else {\n            throw e;\n          }\n        }\n        // Implementation of parsing DSL\n      }, {\n        key: \"optionInternal\",\n        value: function optionInternal(actionORMethodDef, occurrence) {\n          var key = this.getKeyForAutomaticLookahead(OPTION_IDX, occurrence);\n          return this.optionInternalLogic(actionORMethodDef, occurrence, key);\n        }\n      }, {\n        key: \"optionInternalLogic\",\n        value: function optionInternalLogic(actionORMethodDef, occurrence, key) {\n          var _this43 = this;\n          var lookAheadFunc = this.getLaFuncFromCache(key);\n          var action;\n          if (typeof actionORMethodDef !== \"function\") {\n            action = actionORMethodDef.DEF;\n            var predicate = actionORMethodDef.GATE;\n            if (predicate !== void 0) {\n              var orgLookaheadFunction = lookAheadFunc;\n              lookAheadFunc = function lookAheadFunc() {\n                return predicate.call(_this43) && orgLookaheadFunction.call(_this43);\n              };\n            }\n          } else {\n            action = actionORMethodDef;\n          }\n          if (lookAheadFunc.call(this) === true) {\n            return action.call(this);\n          }\n          return void 0;\n        }\n      }, {\n        key: \"atLeastOneInternal\",\n        value: function atLeastOneInternal(prodOccurrence, actionORMethodDef) {\n          var laKey = this.getKeyForAutomaticLookahead(AT_LEAST_ONE_IDX, prodOccurrence);\n          return this.atLeastOneInternalLogic(prodOccurrence, actionORMethodDef, laKey);\n        }\n      }, {\n        key: \"atLeastOneInternalLogic\",\n        value: function atLeastOneInternalLogic(prodOccurrence, actionORMethodDef, key) {\n          var _this44 = this;\n          var lookAheadFunc = this.getLaFuncFromCache(key);\n          var action;\n          if (typeof actionORMethodDef !== \"function\") {\n            action = actionORMethodDef.DEF;\n            var predicate = actionORMethodDef.GATE;\n            if (predicate !== void 0) {\n              var orgLookaheadFunction = lookAheadFunc;\n              lookAheadFunc = function lookAheadFunc() {\n                return predicate.call(_this44) && orgLookaheadFunction.call(_this44);\n              };\n            }\n          } else {\n            action = actionORMethodDef;\n          }\n          if (lookAheadFunc.call(this) === true) {\n            var notStuck = this.doSingleRepetition(action);\n            while (lookAheadFunc.call(this) === true && notStuck === true) {\n              notStuck = this.doSingleRepetition(action);\n            }\n          } else {\n            throw this.raiseEarlyExitException(prodOccurrence, PROD_TYPE.REPETITION_MANDATORY, actionORMethodDef.ERR_MSG);\n          }\n          this.attemptInRepetitionRecovery(this.atLeastOneInternal, [prodOccurrence, actionORMethodDef], lookAheadFunc, AT_LEAST_ONE_IDX, prodOccurrence, NextTerminalAfterAtLeastOneWalker);\n        }\n      }, {\n        key: \"atLeastOneSepFirstInternal\",\n        value: function atLeastOneSepFirstInternal(prodOccurrence, options) {\n          var laKey = this.getKeyForAutomaticLookahead(AT_LEAST_ONE_SEP_IDX, prodOccurrence);\n          this.atLeastOneSepFirstInternalLogic(prodOccurrence, options, laKey);\n        }\n      }, {\n        key: \"atLeastOneSepFirstInternalLogic\",\n        value: function atLeastOneSepFirstInternalLogic(prodOccurrence, options, key) {\n          var _this45 = this;\n          var action = options.DEF;\n          var separator = options.SEP;\n          var firstIterationLookaheadFunc = this.getLaFuncFromCache(key);\n          if (firstIterationLookaheadFunc.call(this) === true) {\n            action.call(this);\n            var separatorLookAheadFunc = function separatorLookAheadFunc() {\n              return _this45.tokenMatcher(_this45.LA(1), separator);\n            };\n            while (this.tokenMatcher(this.LA(1), separator) === true) {\n              this.CONSUME(separator);\n              action.call(this);\n            }\n            this.attemptInRepetitionRecovery(this.repetitionSepSecondInternal, [prodOccurrence, separator, separatorLookAheadFunc, action, NextTerminalAfterAtLeastOneSepWalker], separatorLookAheadFunc, AT_LEAST_ONE_SEP_IDX, prodOccurrence, NextTerminalAfterAtLeastOneSepWalker);\n          } else {\n            throw this.raiseEarlyExitException(prodOccurrence, PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR, options.ERR_MSG);\n          }\n        }\n      }, {\n        key: \"manyInternal\",\n        value: function manyInternal(prodOccurrence, actionORMethodDef) {\n          var laKey = this.getKeyForAutomaticLookahead(MANY_IDX, prodOccurrence);\n          return this.manyInternalLogic(prodOccurrence, actionORMethodDef, laKey);\n        }\n      }, {\n        key: \"manyInternalLogic\",\n        value: function manyInternalLogic(prodOccurrence, actionORMethodDef, key) {\n          var _this46 = this;\n          var lookaheadFunction = this.getLaFuncFromCache(key);\n          var action;\n          if (typeof actionORMethodDef !== \"function\") {\n            action = actionORMethodDef.DEF;\n            var predicate = actionORMethodDef.GATE;\n            if (predicate !== void 0) {\n              var orgLookaheadFunction = lookaheadFunction;\n              lookaheadFunction = function lookaheadFunction() {\n                return predicate.call(_this46) && orgLookaheadFunction.call(_this46);\n              };\n            }\n          } else {\n            action = actionORMethodDef;\n          }\n          var notStuck = true;\n          while (lookaheadFunction.call(this) === true && notStuck === true) {\n            notStuck = this.doSingleRepetition(action);\n          }\n          this.attemptInRepetitionRecovery(this.manyInternal, [prodOccurrence, actionORMethodDef], lookaheadFunction, MANY_IDX, prodOccurrence, NextTerminalAfterManyWalker,\n          // The notStuck parameter is only relevant when \"attemptInRepetitionRecovery\"\n          // is invoked from manyInternal, in the MANY_SEP case and AT_LEAST_ONE[_SEP]\n          // An infinite loop cannot occur as:\n          // - Either the lookahead is guaranteed to consume something (Single Token Separator)\n          // - AT_LEAST_ONE by definition is guaranteed to consume something (or error out).\n          notStuck);\n        }\n      }, {\n        key: \"manySepFirstInternal\",\n        value: function manySepFirstInternal(prodOccurrence, options) {\n          var laKey = this.getKeyForAutomaticLookahead(MANY_SEP_IDX, prodOccurrence);\n          this.manySepFirstInternalLogic(prodOccurrence, options, laKey);\n        }\n      }, {\n        key: \"manySepFirstInternalLogic\",\n        value: function manySepFirstInternalLogic(prodOccurrence, options, key) {\n          var _this47 = this;\n          var action = options.DEF;\n          var separator = options.SEP;\n          var firstIterationLaFunc = this.getLaFuncFromCache(key);\n          if (firstIterationLaFunc.call(this) === true) {\n            action.call(this);\n            var separatorLookAheadFunc = function separatorLookAheadFunc() {\n              return _this47.tokenMatcher(_this47.LA(1), separator);\n            };\n            while (this.tokenMatcher(this.LA(1), separator) === true) {\n              this.CONSUME(separator);\n              action.call(this);\n            }\n            this.attemptInRepetitionRecovery(this.repetitionSepSecondInternal, [prodOccurrence, separator, separatorLookAheadFunc, action, NextTerminalAfterManySepWalker], separatorLookAheadFunc, MANY_SEP_IDX, prodOccurrence, NextTerminalAfterManySepWalker);\n          }\n        }\n      }, {\n        key: \"repetitionSepSecondInternal\",\n        value: function repetitionSepSecondInternal(prodOccurrence, separator, separatorLookAheadFunc, action, nextTerminalAfterWalker) {\n          while (separatorLookAheadFunc()) {\n            this.CONSUME(separator);\n            action.call(this);\n          }\n          this.attemptInRepetitionRecovery(this.repetitionSepSecondInternal, [prodOccurrence, separator, separatorLookAheadFunc, action, nextTerminalAfterWalker], separatorLookAheadFunc, AT_LEAST_ONE_SEP_IDX, prodOccurrence, nextTerminalAfterWalker);\n        }\n      }, {\n        key: \"doSingleRepetition\",\n        value: function doSingleRepetition(action) {\n          var beforeIteration = this.getLexerPosition();\n          action.call(this);\n          var afterIteration = this.getLexerPosition();\n          return afterIteration > beforeIteration;\n        }\n      }, {\n        key: \"orInternal\",\n        value: function orInternal(altsOrOpts, occurrence) {\n          var laKey = this.getKeyForAutomaticLookahead(OR_IDX, occurrence);\n          var alts = isArray$1(altsOrOpts) ? altsOrOpts : altsOrOpts.DEF;\n          var laFunc = this.getLaFuncFromCache(laKey);\n          var altIdxToTake = laFunc.call(this, alts);\n          if (altIdxToTake !== void 0) {\n            var chosenAlternative = alts[altIdxToTake];\n            return chosenAlternative.ALT.call(this);\n          }\n          this.raiseNoAltException(occurrence, altsOrOpts.ERR_MSG);\n        }\n      }, {\n        key: \"ruleFinallyStateUpdate\",\n        value: function ruleFinallyStateUpdate() {\n          this.RULE_STACK.pop();\n          this.RULE_OCCURRENCE_STACK.pop();\n          this.cstFinallyStateUpdate();\n          if (this.RULE_STACK.length === 0 && this.isAtEndOfInput() === false) {\n            var firstRedundantTok = this.LA(1);\n            var errMsg = this.errorMessageProvider.buildNotAllInputParsedMessage({\n              firstRedundant: firstRedundantTok,\n              ruleName: this.getCurrRuleFullName()\n            });\n            this.SAVE_ERROR(new NotAllInputParsedException(errMsg, firstRedundantTok));\n          }\n        }\n      }, {\n        key: \"subruleInternal\",\n        value: function subruleInternal(ruleToCall, idx, options) {\n          var ruleResult;\n          try {\n            var args = options !== void 0 ? options.ARGS : void 0;\n            this.subruleIdx = idx;\n            ruleResult = ruleToCall.apply(this, args);\n            this.cstPostNonTerminal(ruleResult, options !== void 0 && options.LABEL !== void 0 ? options.LABEL : ruleToCall.ruleName);\n            return ruleResult;\n          } catch (e) {\n            throw this.subruleInternalError(e, options, ruleToCall.ruleName);\n          }\n        }\n      }, {\n        key: \"subruleInternalError\",\n        value: function subruleInternalError(e, options, ruleName) {\n          if (isRecognitionException(e) && e.partialCstResult !== void 0) {\n            this.cstPostNonTerminal(e.partialCstResult, options !== void 0 && options.LABEL !== void 0 ? options.LABEL : ruleName);\n            delete e.partialCstResult;\n          }\n          throw e;\n        }\n      }, {\n        key: \"consumeInternal\",\n        value: function consumeInternal(tokType, idx, options) {\n          var consumedToken;\n          try {\n            var nextToken = this.LA(1);\n            if (this.tokenMatcher(nextToken, tokType) === true) {\n              this.consumeToken();\n              consumedToken = nextToken;\n            } else {\n              this.consumeInternalError(tokType, nextToken, options);\n            }\n          } catch (eFromConsumption) {\n            consumedToken = this.consumeInternalRecovery(tokType, idx, eFromConsumption);\n          }\n          this.cstPostTerminal(options !== void 0 && options.LABEL !== void 0 ? options.LABEL : tokType.name, consumedToken);\n          return consumedToken;\n        }\n      }, {\n        key: \"consumeInternalError\",\n        value: function consumeInternalError(tokType, nextToken, options) {\n          var msg;\n          var previousToken = this.LA(0);\n          if (options !== void 0 && options.ERR_MSG) {\n            msg = options.ERR_MSG;\n          } else {\n            msg = this.errorMessageProvider.buildMismatchTokenMessage({\n              expected: tokType,\n              actual: nextToken,\n              previous: previousToken,\n              ruleName: this.getCurrRuleFullName()\n            });\n          }\n          throw this.SAVE_ERROR(new MismatchedTokenException(msg, nextToken, previousToken));\n        }\n      }, {\n        key: \"consumeInternalRecovery\",\n        value: function consumeInternalRecovery(tokType, idx, eFromConsumption) {\n          if (this.recoveryEnabled &&\n          // TODO: more robust checking of the exception type. Perhaps Typescript extending expressions?\n          eFromConsumption.name === \"MismatchedTokenException\" && !this.isBackTracking()) {\n            var follows = this.getFollowsForInRuleRecovery(tokType, idx);\n            try {\n              return this.tryInRuleRecovery(tokType, follows);\n            } catch (eFromInRuleRecovery) {\n              if (eFromInRuleRecovery.name === IN_RULE_RECOVERY_EXCEPTION) {\n                throw eFromConsumption;\n              } else {\n                throw eFromInRuleRecovery;\n              }\n            }\n          } else {\n            throw eFromConsumption;\n          }\n        }\n      }, {\n        key: \"saveRecogState\",\n        value: function saveRecogState() {\n          var savedErrors = this.errors;\n          var savedRuleStack = clone(this.RULE_STACK);\n          return {\n            errors: savedErrors,\n            lexerState: this.exportLexerState(),\n            RULE_STACK: savedRuleStack,\n            CST_STACK: this.CST_STACK\n          };\n        }\n      }, {\n        key: \"reloadRecogState\",\n        value: function reloadRecogState(newState) {\n          this.errors = newState.errors;\n          this.importLexerState(newState.lexerState);\n          this.RULE_STACK = newState.RULE_STACK;\n        }\n      }, {\n        key: \"ruleInvocationStateUpdate\",\n        value: function ruleInvocationStateUpdate(shortName, fullName, idxInCallingRule) {\n          this.RULE_OCCURRENCE_STACK.push(idxInCallingRule);\n          this.RULE_STACK.push(shortName);\n          this.cstInvocationStateUpdate(fullName);\n        }\n      }, {\n        key: \"isBackTracking\",\n        value: function isBackTracking() {\n          return this.isBackTrackingStack.length !== 0;\n        }\n      }, {\n        key: \"getCurrRuleFullName\",\n        value: function getCurrRuleFullName() {\n          var shortName = this.getLastExplicitRuleShortName();\n          return this.shortRuleNameToFull[shortName];\n        }\n      }, {\n        key: \"shortRuleNameToFullName\",\n        value: function shortRuleNameToFullName(shortName) {\n          return this.shortRuleNameToFull[shortName];\n        }\n      }, {\n        key: \"isAtEndOfInput\",\n        value: function isAtEndOfInput() {\n          return this.tokenMatcher(this.LA(1), EOF);\n        }\n      }, {\n        key: \"reset\",\n        value: function reset() {\n          this.resetLexerState();\n          this.subruleIdx = 0;\n          this.isBackTrackingStack = [];\n          this.errors = [];\n          this.RULE_STACK = [];\n          this.CST_STACK = [];\n          this.RULE_OCCURRENCE_STACK = [];\n        }\n      }]);\n      return RecognizerEngine;\n    }();\n    var ErrorHandler = /*#__PURE__*/function () {\n      function ErrorHandler() {\n        _classCallCheck(this, ErrorHandler);\n      }\n      _createClass(ErrorHandler, [{\n        key: \"initErrorHandler\",\n        value: function initErrorHandler(config) {\n          this._errors = [];\n          this.errorMessageProvider = has(config, \"errorMessageProvider\") ? config.errorMessageProvider : DEFAULT_PARSER_CONFIG.errorMessageProvider;\n        }\n      }, {\n        key: \"SAVE_ERROR\",\n        value: function SAVE_ERROR(error) {\n          if (isRecognitionException(error)) {\n            error.context = {\n              ruleStack: this.getHumanReadableRuleStack(),\n              ruleOccurrenceStack: clone(this.RULE_OCCURRENCE_STACK)\n            };\n            this._errors.push(error);\n            return error;\n          } else {\n            throw Error(\"Trying to save an Error which is not a RecognitionException\");\n          }\n        }\n      }, {\n        key: \"errors\",\n        get: function get() {\n          return clone(this._errors);\n        },\n        set: function set(newErrors) {\n          this._errors = newErrors;\n        }\n        // TODO: consider caching the error message computed information\n      }, {\n        key: \"raiseEarlyExitException\",\n        value: function raiseEarlyExitException(occurrence, prodType, userDefinedErrMsg) {\n          var ruleName = this.getCurrRuleFullName();\n          var ruleGrammar = this.getGAstProductions()[ruleName];\n          var lookAheadPathsPerAlternative = getLookaheadPathsForOptionalProd(occurrence, ruleGrammar, prodType, this.maxLookahead);\n          var insideProdPaths = lookAheadPathsPerAlternative[0];\n          var actualTokens = [];\n          for (var _i16 = 1; _i16 <= this.maxLookahead; _i16++) {\n            actualTokens.push(this.LA(_i16));\n          }\n          var msg = this.errorMessageProvider.buildEarlyExitMessage({\n            expectedIterationPaths: insideProdPaths,\n            actual: actualTokens,\n            previous: this.LA(0),\n            customUserDescription: userDefinedErrMsg,\n            ruleName: ruleName\n          });\n          throw this.SAVE_ERROR(new EarlyExitException(msg, this.LA(1), this.LA(0)));\n        }\n        // TODO: consider caching the error message computed information\n      }, {\n        key: \"raiseNoAltException\",\n        value: function raiseNoAltException(occurrence, errMsgTypes) {\n          var ruleName = this.getCurrRuleFullName();\n          var ruleGrammar = this.getGAstProductions()[ruleName];\n          var lookAheadPathsPerAlternative = getLookaheadPathsForOr(occurrence, ruleGrammar, this.maxLookahead);\n          var actualTokens = [];\n          for (var _i17 = 1; _i17 <= this.maxLookahead; _i17++) {\n            actualTokens.push(this.LA(_i17));\n          }\n          var previousToken = this.LA(0);\n          var errMsg = this.errorMessageProvider.buildNoViableAltMessage({\n            expectedPathsPerAlt: lookAheadPathsPerAlternative,\n            actual: actualTokens,\n            previous: previousToken,\n            customUserDescription: errMsgTypes,\n            ruleName: this.getCurrRuleFullName()\n          });\n          throw this.SAVE_ERROR(new NoViableAltException(errMsg, this.LA(1), previousToken));\n        }\n      }]);\n      return ErrorHandler;\n    }();\n    var ContentAssist = /*#__PURE__*/function () {\n      function ContentAssist() {\n        _classCallCheck(this, ContentAssist);\n      }\n      _createClass(ContentAssist, [{\n        key: \"initContentAssist\",\n        value: function initContentAssist() {}\n      }, {\n        key: \"computeContentAssist\",\n        value: function computeContentAssist(startRuleName, precedingInput) {\n          var startRuleGast = this.gastProductionsCache[startRuleName];\n          if (isUndefined(startRuleGast)) {\n            throw Error(\"Rule ->\".concat(startRuleName, \"<- does not exist in this grammar.\"));\n          }\n          return nextPossibleTokensAfter([startRuleGast], precedingInput, this.tokenMatcher, this.maxLookahead);\n        }\n        // TODO: should this be a member method or a utility? it does not have any state or usage of 'this'...\n        // TODO: should this be more explicitly part of the public API?\n      }, {\n        key: \"getNextPossibleTokenTypes\",\n        value: function getNextPossibleTokenTypes(grammarPath) {\n          var topRuleName = head(grammarPath.ruleStack);\n          var gastProductions = this.getGAstProductions();\n          var topProduction = gastProductions[topRuleName];\n          var nextPossibleTokenTypes = new NextAfterTokenWalker(topProduction, grammarPath).startWalking();\n          return nextPossibleTokenTypes;\n        }\n      }]);\n      return ContentAssist;\n    }();\n    var RECORDING_NULL_OBJECT = {\n      description: \"This Object indicates the Parser is during Recording Phase\"\n    };\n    Object.freeze(RECORDING_NULL_OBJECT);\n    var HANDLE_SEPARATOR = true;\n    var MAX_METHOD_IDX = Math.pow(2, BITS_FOR_OCCURRENCE_IDX) - 1;\n    var RFT = createToken2({\n      name: \"RECORDING_PHASE_TOKEN\",\n      pattern: Lexer2.NA\n    });\n    augmentTokenTypes([RFT]);\n    var RECORDING_PHASE_TOKEN = createTokenInstance(RFT, \"This IToken indicates the Parser is in Recording Phase\\n\tSee: https://chevrotain.io/docs/guide/internals.html#grammar-recording for details\",\n    // Using \"-1\" instead of NaN (as in EOF) because an actual number is less likely to\n    // cause errors if the output of LA or CONSUME would be (incorrectly) used during the recording phase.\n    -1, -1, -1, -1, -1, -1);\n    Object.freeze(RECORDING_PHASE_TOKEN);\n    var RECORDING_PHASE_CSTNODE = {\n      name: \"This CSTNode indicates the Parser is in Recording Phase\\n\tSee: https://chevrotain.io/docs/guide/internals.html#grammar-recording for details\",\n      children: {}\n    };\n    var GastRecorder = /*#__PURE__*/function () {\n      function GastRecorder() {\n        _classCallCheck(this, GastRecorder);\n      }\n      _createClass(GastRecorder, [{\n        key: \"initGastRecorder\",\n        value: function initGastRecorder(config) {\n          this.recordingProdStack = [];\n          this.RECORDING_PHASE = false;\n        }\n      }, {\n        key: \"enableRecording\",\n        value: function enableRecording() {\n          var _this48 = this;\n          this.RECORDING_PHASE = true;\n          this.TRACE_INIT(\"Enable Recording\", function () {\n            var _loop2 = function _loop2(_i18) {\n              var idx = _i18 > 0 ? _i18 : \"\";\n              _this48[\"CONSUME\".concat(idx)] = function (arg1, arg2) {\n                return this.consumeInternalRecord(arg1, _i18, arg2);\n              };\n              _this48[\"SUBRULE\".concat(idx)] = function (arg1, arg2) {\n                return this.subruleInternalRecord(arg1, _i18, arg2);\n              };\n              _this48[\"OPTION\".concat(idx)] = function (arg1) {\n                return this.optionInternalRecord(arg1, _i18);\n              };\n              _this48[\"OR\".concat(idx)] = function (arg1) {\n                return this.orInternalRecord(arg1, _i18);\n              };\n              _this48[\"MANY\".concat(idx)] = function (arg1) {\n                this.manyInternalRecord(_i18, arg1);\n              };\n              _this48[\"MANY_SEP\".concat(idx)] = function (arg1) {\n                this.manySepFirstInternalRecord(_i18, arg1);\n              };\n              _this48[\"AT_LEAST_ONE\".concat(idx)] = function (arg1) {\n                this.atLeastOneInternalRecord(_i18, arg1);\n              };\n              _this48[\"AT_LEAST_ONE_SEP\".concat(idx)] = function (arg1) {\n                this.atLeastOneSepFirstInternalRecord(_i18, arg1);\n              };\n            };\n            for (var _i18 = 0; _i18 < 10; _i18++) {\n              _loop2(_i18);\n            }\n            _this48[\"consume\"] = function (idx, arg1, arg2) {\n              return this.consumeInternalRecord(arg1, idx, arg2);\n            };\n            _this48[\"subrule\"] = function (idx, arg1, arg2) {\n              return this.subruleInternalRecord(arg1, idx, arg2);\n            };\n            _this48[\"option\"] = function (idx, arg1) {\n              return this.optionInternalRecord(arg1, idx);\n            };\n            _this48[\"or\"] = function (idx, arg1) {\n              return this.orInternalRecord(arg1, idx);\n            };\n            _this48[\"many\"] = function (idx, arg1) {\n              this.manyInternalRecord(idx, arg1);\n            };\n            _this48[\"atLeastOne\"] = function (idx, arg1) {\n              this.atLeastOneInternalRecord(idx, arg1);\n            };\n            _this48.ACTION = _this48.ACTION_RECORD;\n            _this48.BACKTRACK = _this48.BACKTRACK_RECORD;\n            _this48.LA = _this48.LA_RECORD;\n          });\n        }\n      }, {\n        key: \"disableRecording\",\n        value: function disableRecording() {\n          var _this49 = this;\n          this.RECORDING_PHASE = false;\n          this.TRACE_INIT(\"Deleting Recording methods\", function () {\n            var that = _this49;\n            for (var _i19 = 0; _i19 < 10; _i19++) {\n              var idx = _i19 > 0 ? _i19 : \"\";\n              delete that[\"CONSUME\".concat(idx)];\n              delete that[\"SUBRULE\".concat(idx)];\n              delete that[\"OPTION\".concat(idx)];\n              delete that[\"OR\".concat(idx)];\n              delete that[\"MANY\".concat(idx)];\n              delete that[\"MANY_SEP\".concat(idx)];\n              delete that[\"AT_LEAST_ONE\".concat(idx)];\n              delete that[\"AT_LEAST_ONE_SEP\".concat(idx)];\n            }\n            delete that[\"consume\"];\n            delete that[\"subrule\"];\n            delete that[\"option\"];\n            delete that[\"or\"];\n            delete that[\"many\"];\n            delete that[\"atLeastOne\"];\n            delete that.ACTION;\n            delete that.BACKTRACK;\n            delete that.LA;\n          });\n        }\n        //   Parser methods are called inside an ACTION?\n        //   Maybe try/catch/finally on ACTIONS while disabling the recorders state changes?\n        // @ts-expect-error -- noop place holder\n      }, {\n        key: \"ACTION_RECORD\",\n        value: function ACTION_RECORD(impl) {}\n        // Executing backtracking logic will break our recording logic assumptions\n      }, {\n        key: \"BACKTRACK_RECORD\",\n        value: function BACKTRACK_RECORD(grammarRule, args) {\n          return function () {\n            return true;\n          };\n        }\n        // LA is part of the official API and may be used for custom lookahead logic\n        // by end users who may forget to wrap it in ACTION or inside a GATE\n      }, {\n        key: \"LA_RECORD\",\n        value: function LA_RECORD(howMuch) {\n          return END_OF_FILE;\n        }\n      }, {\n        key: \"topLevelRuleRecord\",\n        value: function topLevelRuleRecord(name, def) {\n          try {\n            var newTopLevelRule = new Rule({\n              definition: [],\n              name: name\n            });\n            newTopLevelRule.name = name;\n            this.recordingProdStack.push(newTopLevelRule);\n            def.call(this);\n            this.recordingProdStack.pop();\n            return newTopLevelRule;\n          } catch (originalError) {\n            if (originalError.KNOWN_RECORDER_ERROR !== true) {\n              try {\n                originalError.message = originalError.message + '\\n\t This error was thrown during the \"grammar recording phase\" For more info see:\\n\thttps://chevrotain.io/docs/guide/internals.html#grammar-recording';\n              } catch (mutabilityError) {\n                throw originalError;\n              }\n            }\n            throw originalError;\n          }\n        }\n        // Implementation of parsing DSL\n      }, {\n        key: \"optionInternalRecord\",\n        value: function optionInternalRecord(actionORMethodDef, occurrence) {\n          return recordProd.call(this, Option, actionORMethodDef, occurrence);\n        }\n      }, {\n        key: \"atLeastOneInternalRecord\",\n        value: function atLeastOneInternalRecord(occurrence, actionORMethodDef) {\n          recordProd.call(this, RepetitionMandatory, actionORMethodDef, occurrence);\n        }\n      }, {\n        key: \"atLeastOneSepFirstInternalRecord\",\n        value: function atLeastOneSepFirstInternalRecord(occurrence, options) {\n          recordProd.call(this, RepetitionMandatoryWithSeparator, options, occurrence, HANDLE_SEPARATOR);\n        }\n      }, {\n        key: \"manyInternalRecord\",\n        value: function manyInternalRecord(occurrence, actionORMethodDef) {\n          recordProd.call(this, Repetition, actionORMethodDef, occurrence);\n        }\n      }, {\n        key: \"manySepFirstInternalRecord\",\n        value: function manySepFirstInternalRecord(occurrence, options) {\n          recordProd.call(this, RepetitionWithSeparator, options, occurrence, HANDLE_SEPARATOR);\n        }\n      }, {\n        key: \"orInternalRecord\",\n        value: function orInternalRecord(altsOrOpts, occurrence) {\n          return recordOrProd.call(this, altsOrOpts, occurrence);\n        }\n      }, {\n        key: \"subruleInternalRecord\",\n        value: function subruleInternalRecord(ruleToCall, occurrence, options) {\n          assertMethodIdxIsValid(occurrence);\n          if (!ruleToCall || has(ruleToCall, \"ruleName\") === false) {\n            var error = new Error(\"<SUBRULE\".concat(getIdxSuffix(occurrence), \"> argument is invalid expecting a Parser method reference but got: <\").concat(JSON.stringify(ruleToCall), \">\\n inside top level rule: <\").concat(this.recordingProdStack[0].name, \">\"));\n            error.KNOWN_RECORDER_ERROR = true;\n            throw error;\n          }\n          var prevProd = last(this.recordingProdStack);\n          var ruleName = ruleToCall.ruleName;\n          var newNoneTerminal = new NonTerminal({\n            idx: occurrence,\n            nonTerminalName: ruleName,\n            label: options === null || options === void 0 ? void 0 : options.LABEL,\n            // The resolving of the `referencedRule` property will be done once all the Rule's GASTs have been created\n            referencedRule: void 0\n          });\n          prevProd.definition.push(newNoneTerminal);\n          return this.outputCst ? RECORDING_PHASE_CSTNODE : RECORDING_NULL_OBJECT;\n        }\n      }, {\n        key: \"consumeInternalRecord\",\n        value: function consumeInternalRecord(tokType, occurrence, options) {\n          assertMethodIdxIsValid(occurrence);\n          if (!hasShortKeyProperty(tokType)) {\n            var error = new Error(\"<CONSUME\".concat(getIdxSuffix(occurrence), \"> argument is invalid expecting a TokenType reference but got: <\").concat(JSON.stringify(tokType), \">\\n inside top level rule: <\").concat(this.recordingProdStack[0].name, \">\"));\n            error.KNOWN_RECORDER_ERROR = true;\n            throw error;\n          }\n          var prevProd = last(this.recordingProdStack);\n          var newNoneTerminal = new Terminal({\n            idx: occurrence,\n            terminalType: tokType,\n            label: options === null || options === void 0 ? void 0 : options.LABEL\n          });\n          prevProd.definition.push(newNoneTerminal);\n          return RECORDING_PHASE_TOKEN;\n        }\n      }]);\n      return GastRecorder;\n    }();\n    function recordProd(prodConstructor, mainProdArg, occurrence) {\n      var handleSep = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n      assertMethodIdxIsValid(occurrence);\n      var prevProd = last(this.recordingProdStack);\n      var grammarAction = isFunction(mainProdArg) ? mainProdArg : mainProdArg.DEF;\n      var newProd = new prodConstructor({\n        definition: [],\n        idx: occurrence\n      });\n      if (handleSep) {\n        newProd.separator = mainProdArg.SEP;\n      }\n      if (has(mainProdArg, \"MAX_LOOKAHEAD\")) {\n        newProd.maxLookahead = mainProdArg.MAX_LOOKAHEAD;\n      }\n      this.recordingProdStack.push(newProd);\n      grammarAction.call(this);\n      prevProd.definition.push(newProd);\n      this.recordingProdStack.pop();\n      return RECORDING_NULL_OBJECT;\n    }\n    function recordOrProd(mainProdArg, occurrence) {\n      var _this50 = this;\n      assertMethodIdxIsValid(occurrence);\n      var prevProd = last(this.recordingProdStack);\n      var hasOptions = isArray$1(mainProdArg) === false;\n      var alts = hasOptions === false ? mainProdArg : mainProdArg.DEF;\n      var newOrProd = new Alternation({\n        definition: [],\n        idx: occurrence,\n        ignoreAmbiguities: hasOptions && mainProdArg.IGNORE_AMBIGUITIES === true\n      });\n      if (has(mainProdArg, \"MAX_LOOKAHEAD\")) {\n        newOrProd.maxLookahead = mainProdArg.MAX_LOOKAHEAD;\n      }\n      var hasPredicates = some(alts, function (currAlt) {\n        return isFunction(currAlt.GATE);\n      });\n      newOrProd.hasPredicates = hasPredicates;\n      prevProd.definition.push(newOrProd);\n      forEach(alts, function (currAlt) {\n        var currAltFlat = new Alternative({\n          definition: []\n        });\n        newOrProd.definition.push(currAltFlat);\n        if (has(currAlt, \"IGNORE_AMBIGUITIES\")) {\n          currAltFlat.ignoreAmbiguities = currAlt.IGNORE_AMBIGUITIES;\n        } else if (has(currAlt, \"GATE\")) {\n          currAltFlat.ignoreAmbiguities = true;\n        }\n        _this50.recordingProdStack.push(currAltFlat);\n        currAlt.ALT.call(_this50);\n        _this50.recordingProdStack.pop();\n      });\n      return RECORDING_NULL_OBJECT;\n    }\n    function getIdxSuffix(idx) {\n      return idx === 0 ? \"\" : \"\".concat(idx);\n    }\n    function assertMethodIdxIsValid(idx) {\n      if (idx < 0 || idx > MAX_METHOD_IDX) {\n        var error = new Error( // The stack trace will contain all the needed details\n        \"Invalid DSL Method idx value: <\".concat(idx, \">\\n\\tIdx value must be a none negative value smaller than \").concat(MAX_METHOD_IDX + 1));\n        error.KNOWN_RECORDER_ERROR = true;\n        throw error;\n      }\n    }\n    var PerformanceTracer = /*#__PURE__*/function () {\n      function PerformanceTracer() {\n        _classCallCheck(this, PerformanceTracer);\n      }\n      _createClass(PerformanceTracer, [{\n        key: \"initPerformanceTracer\",\n        value: function initPerformanceTracer(config) {\n          if (has(config, \"traceInitPerf\")) {\n            var userTraceInitPerf = config.traceInitPerf;\n            var traceIsNumber = typeof userTraceInitPerf === \"number\";\n            this.traceInitMaxIdent = traceIsNumber ? userTraceInitPerf : Infinity;\n            this.traceInitPerf = traceIsNumber ? userTraceInitPerf > 0 : userTraceInitPerf;\n          } else {\n            this.traceInitMaxIdent = 0;\n            this.traceInitPerf = DEFAULT_PARSER_CONFIG.traceInitPerf;\n          }\n          this.traceInitIndent = -1;\n        }\n      }, {\n        key: \"TRACE_INIT\",\n        value: function TRACE_INIT(phaseDesc, phaseImpl) {\n          if (this.traceInitPerf === true) {\n            this.traceInitIndent++;\n            var indent = new Array(this.traceInitIndent + 1).join(\"\t\");\n            if (this.traceInitIndent < this.traceInitMaxIdent) {\n              console.log(\"\".concat(indent, \"--> <\").concat(phaseDesc, \">\"));\n            }\n            var _timer2 = timer(phaseImpl),\n              time = _timer2.time,\n              value = _timer2.value;\n            var traceMethod = time > 10 ? console.warn : console.log;\n            if (this.traceInitIndent < this.traceInitMaxIdent) {\n              traceMethod(\"\".concat(indent, \"<-- <\").concat(phaseDesc, \"> time: \").concat(time, \"ms\"));\n            }\n            this.traceInitIndent--;\n            return value;\n          } else {\n            return phaseImpl();\n          }\n        }\n      }]);\n      return PerformanceTracer;\n    }();\n    function applyMixins(derivedCtor, baseCtors) {\n      baseCtors.forEach(function (baseCtor) {\n        var baseProto = baseCtor.prototype;\n        Object.getOwnPropertyNames(baseProto).forEach(function (propName) {\n          if (propName === \"constructor\") {\n            return;\n          }\n          var basePropDescriptor = Object.getOwnPropertyDescriptor(baseProto, propName);\n          if (basePropDescriptor && (basePropDescriptor.get || basePropDescriptor.set)) {\n            Object.defineProperty(derivedCtor.prototype, propName, basePropDescriptor);\n          } else {\n            derivedCtor.prototype[propName] = baseCtor.prototype[propName];\n          }\n        });\n      });\n    }\n    var END_OF_FILE = createTokenInstance(EOF, \"\", NaN, NaN, NaN, NaN, NaN, NaN);\n    Object.freeze(END_OF_FILE);\n    var DEFAULT_PARSER_CONFIG = Object.freeze({\n      recoveryEnabled: false,\n      maxLookahead: 3,\n      dynamicTokensEnabled: false,\n      outputCst: true,\n      errorMessageProvider: defaultParserErrorProvider,\n      nodeLocationTracking: \"none\",\n      traceInitPerf: false,\n      skipValidations: false\n    });\n    var DEFAULT_RULE_CONFIG = Object.freeze({\n      recoveryValueFunc: function recoveryValueFunc() {\n        return void 0;\n      },\n      resyncEnabled: true\n    });\n    var ParserDefinitionErrorType;\n    (function (ParserDefinitionErrorType2) {\n      ParserDefinitionErrorType2[ParserDefinitionErrorType2[\"INVALID_RULE_NAME\"] = 0] = \"INVALID_RULE_NAME\";\n      ParserDefinitionErrorType2[ParserDefinitionErrorType2[\"DUPLICATE_RULE_NAME\"] = 1] = \"DUPLICATE_RULE_NAME\";\n      ParserDefinitionErrorType2[ParserDefinitionErrorType2[\"INVALID_RULE_OVERRIDE\"] = 2] = \"INVALID_RULE_OVERRIDE\";\n      ParserDefinitionErrorType2[ParserDefinitionErrorType2[\"DUPLICATE_PRODUCTIONS\"] = 3] = \"DUPLICATE_PRODUCTIONS\";\n      ParserDefinitionErrorType2[ParserDefinitionErrorType2[\"UNRESOLVED_SUBRULE_REF\"] = 4] = \"UNRESOLVED_SUBRULE_REF\";\n      ParserDefinitionErrorType2[ParserDefinitionErrorType2[\"LEFT_RECURSION\"] = 5] = \"LEFT_RECURSION\";\n      ParserDefinitionErrorType2[ParserDefinitionErrorType2[\"NONE_LAST_EMPTY_ALT\"] = 6] = \"NONE_LAST_EMPTY_ALT\";\n      ParserDefinitionErrorType2[ParserDefinitionErrorType2[\"AMBIGUOUS_ALTS\"] = 7] = \"AMBIGUOUS_ALTS\";\n      ParserDefinitionErrorType2[ParserDefinitionErrorType2[\"CONFLICT_TOKENS_RULES_NAMESPACE\"] = 8] = \"CONFLICT_TOKENS_RULES_NAMESPACE\";\n      ParserDefinitionErrorType2[ParserDefinitionErrorType2[\"INVALID_TOKEN_NAME\"] = 9] = \"INVALID_TOKEN_NAME\";\n      ParserDefinitionErrorType2[ParserDefinitionErrorType2[\"NO_NON_EMPTY_LOOKAHEAD\"] = 10] = \"NO_NON_EMPTY_LOOKAHEAD\";\n      ParserDefinitionErrorType2[ParserDefinitionErrorType2[\"AMBIGUOUS_PREFIX_ALTS\"] = 11] = \"AMBIGUOUS_PREFIX_ALTS\";\n      ParserDefinitionErrorType2[ParserDefinitionErrorType2[\"TOO_MANY_ALTS\"] = 12] = \"TOO_MANY_ALTS\";\n      ParserDefinitionErrorType2[ParserDefinitionErrorType2[\"CUSTOM_LOOKAHEAD_VALIDATION\"] = 13] = \"CUSTOM_LOOKAHEAD_VALIDATION\";\n    })(ParserDefinitionErrorType || (ParserDefinitionErrorType = {}));\n    var Parser = /*#__PURE__*/function () {\n      function Parser(tokenVocabulary, config) {\n        _classCallCheck(this, Parser);\n        this.definitionErrors = [];\n        this.selfAnalysisDone = false;\n        var that = this;\n        that.initErrorHandler(config);\n        that.initLexerAdapter();\n        that.initLooksAhead(config);\n        that.initRecognizerEngine(tokenVocabulary, config);\n        that.initRecoverable(config);\n        that.initTreeBuilder(config);\n        that.initContentAssist();\n        that.initGastRecorder(config);\n        that.initPerformanceTracer(config);\n        if (has(config, \"ignoredIssues\")) {\n          throw new Error(\"The <ignoredIssues> IParserConfig property has been deprecated.\\n\tPlease use the <IGNORE_AMBIGUITIES> flag on the relevant DSL method instead.\\n\tSee: https://chevrotain.io/docs/guide/resolving_grammar_errors.html#IGNORING_AMBIGUITIES\\n\tFor further details.\");\n        }\n        this.skipValidations = has(config, \"skipValidations\") ? config.skipValidations : DEFAULT_PARSER_CONFIG.skipValidations;\n      }\n      _createClass(Parser, [{\n        key: \"performSelfAnalysis\",\n        value: function performSelfAnalysis() {\n          var _this51 = this;\n          this.TRACE_INIT(\"performSelfAnalysis\", function () {\n            var defErrorsMsgs;\n            _this51.selfAnalysisDone = true;\n            var className = _this51.className;\n            _this51.TRACE_INIT(\"toFastProps\", function () {\n              toFastProperties(_this51);\n            });\n            _this51.TRACE_INIT(\"Grammar Recording\", function () {\n              try {\n                _this51.enableRecording();\n                forEach(_this51.definedRulesNames, function (currRuleName) {\n                  var wrappedRule = _this51[currRuleName];\n                  var originalGrammarAction = wrappedRule[\"originalGrammarAction\"];\n                  var recordedRuleGast;\n                  _this51.TRACE_INIT(\"\".concat(currRuleName, \" Rule\"), function () {\n                    recordedRuleGast = _this51.topLevelRuleRecord(currRuleName, originalGrammarAction);\n                  });\n                  _this51.gastProductionsCache[currRuleName] = recordedRuleGast;\n                });\n              } finally {\n                _this51.disableRecording();\n              }\n            });\n            var resolverErrors = [];\n            _this51.TRACE_INIT(\"Grammar Resolving\", function () {\n              resolverErrors = resolveGrammar({\n                rules: values(_this51.gastProductionsCache)\n              });\n              _this51.definitionErrors = _this51.definitionErrors.concat(resolverErrors);\n            });\n            _this51.TRACE_INIT(\"Grammar Validations\", function () {\n              if (isEmpty(resolverErrors) && _this51.skipValidations === false) {\n                var validationErrors = validateGrammar({\n                  rules: values(_this51.gastProductionsCache),\n                  tokenTypes: values(_this51.tokensMap),\n                  errMsgProvider: defaultGrammarValidatorErrorProvider,\n                  grammarName: className\n                });\n                var lookaheadValidationErrors = validateLookahead({\n                  lookaheadStrategy: _this51.lookaheadStrategy,\n                  rules: values(_this51.gastProductionsCache),\n                  tokenTypes: values(_this51.tokensMap),\n                  grammarName: className\n                });\n                _this51.definitionErrors = _this51.definitionErrors.concat(validationErrors, lookaheadValidationErrors);\n              }\n            });\n            if (isEmpty(_this51.definitionErrors)) {\n              if (_this51.recoveryEnabled) {\n                _this51.TRACE_INIT(\"computeAllProdsFollows\", function () {\n                  var allFollows = computeAllProdsFollows(values(_this51.gastProductionsCache));\n                  _this51.resyncFollows = allFollows;\n                });\n              }\n              _this51.TRACE_INIT(\"ComputeLookaheadFunctions\", function () {\n                var _a, _b;\n                (_b = (_a = _this51.lookaheadStrategy).initialize) === null || _b === void 0 ? void 0 : _b.call(_a, {\n                  rules: values(_this51.gastProductionsCache)\n                });\n                _this51.preComputeLookaheadFunctions(values(_this51.gastProductionsCache));\n              });\n            }\n            if (!Parser.DEFER_DEFINITION_ERRORS_HANDLING && !isEmpty(_this51.definitionErrors)) {\n              defErrorsMsgs = map(_this51.definitionErrors, function (defError) {\n                return defError.message;\n              });\n              throw new Error(\"Parser Definition Errors detected:\\n \".concat(defErrorsMsgs.join(\"\\n-------------------------------\\n\")));\n            }\n          });\n        }\n      }], [{\n        key: \"performSelfAnalysis\",\n        value:\n        /**\n         *  @deprecated use the **instance** method with the same name instead\n         */\n        function performSelfAnalysis(parserInstance) {\n          throw Error(\"The **static** `performSelfAnalysis` method has been deprecated.\t\\nUse the **instance** method with the same name instead.\");\n        }\n      }]);\n      return Parser;\n    }();\n    Parser.DEFER_DEFINITION_ERRORS_HANDLING = false;\n    applyMixins(Parser, [Recoverable, LooksAhead, TreeBuilder, LexerAdapter, RecognizerEngine, RecognizerApi, ErrorHandler, ContentAssist, GastRecorder, PerformanceTracer]);\n    var CstParser2 = /*#__PURE__*/function (_Parser) {\n      _inherits(CstParser2, _Parser);\n      var _super34 = _createSuper(CstParser2);\n      function CstParser2(tokenVocabulary) {\n        var config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DEFAULT_PARSER_CONFIG;\n        _classCallCheck(this, CstParser2);\n        var configClone = clone(config);\n        configClone.outputCst = true;\n        return _super34.call(this, tokenVocabulary, configClone);\n      }\n      return _createClass(CstParser2);\n    }(Parser);\n    return {\n      CstParser: CstParser2,\n      Lexer: Lexer2,\n      createToken: createToken2\n    };\n  }(),\n  CstParser = _ref.CstParser,\n  Lexer = _ref.Lexer,\n  createToken = _ref.createToken;\nexport { CstParser, Lexer, createToken };","map":{"version":3,"names":["_ref","freeGlobal","global","Object","freeGlobal$1","freeSelf","self","root","Function","root$1","Symbol$1","Symbol","Symbol$2","objectProto$j","prototype","hasOwnProperty$g","hasOwnProperty","nativeObjectToString$1","toString","symToStringTag$1","toStringTag","getRawTag","value","isOwn","call","tag","unmasked","e","result","objectProto$i","nativeObjectToString","objectToString","nullTag","undefinedTag","symToStringTag","baseGetTag","isObjectLike","symbolTag$3","isSymbol","arrayMap","array","iteratee","index","length","Array","isArray","isArray$1","INFINITY$3","symbolProto$2","symbolToString","baseToString","reWhitespace","trimmedEndIndex","string","test","charAt","reTrimStart","baseTrim","slice","replace","isObject","type","NAN","reIsBadHex","reIsBinary","reIsOctal","freeParseInt","parseInt","toNumber","other","valueOf","isBinary","INFINITY$2","MAX_INTEGER","toFinite","sign","toInteger","remainder","identity","asyncTag","funcTag$2","genTag$1","proxyTag","isFunction","coreJsData","coreJsData$1","maskSrcKey","uid","exec","keys","IE_PROTO","isMasked","func","funcProto$1","funcToString$1","toSource","reRegExpChar","reIsHostCtor","funcProto","objectProto$h","funcToString","hasOwnProperty$f","reIsNative","RegExp","baseIsNative","pattern","getValue","object","key","getNative","WeakMap","WeakMap$1","objectCreate","create","baseCreate","proto","baseCreate$1","apply","thisArg","args","noop","copyArray","source","HOT_COUNT","HOT_SPAN","nativeNow","Date","now","shortOut","count","lastCalled","stamp","remaining","arguments","constant","defineProperty","defineProperty$1","baseSetToString","configurable","enumerable","writable","baseSetToString$1","setToString","setToString$1","arrayEach","baseFindIndex","predicate","fromIndex","fromRight","baseIsNaN","strictIndexOf","baseIndexOf","arrayIncludes","MAX_SAFE_INTEGER$1","reIsUint","isIndex","baseAssignValue","eq","objectProto$g","hasOwnProperty$e","assignValue","objValue","copyObject","props","customizer","isNew","newValue","nativeMax$3","Math","max","overRest","start","transform","otherArgs","baseRest","MAX_SAFE_INTEGER","isLength","isArrayLike","isIterateeCall","createAssigner","assigner","sources","guard","objectProto$f","isPrototype","Ctor","constructor","baseTimes","n","argsTag$3","baseIsArguments","objectProto$e","hasOwnProperty$d","propertyIsEnumerable$1","propertyIsEnumerable","isArguments","isArguments$1","stubFalse","freeExports$2","exports","nodeType","freeModule$2","module","moduleExports$2","Buffer$1","Buffer","nativeIsBuffer","isBuffer","isBuffer$1","argsTag$2","arrayTag$2","boolTag$3","dateTag$3","errorTag$2","funcTag$1","mapTag$6","numberTag$3","objectTag$3","regexpTag$4","setTag$6","stringTag$4","weakMapTag$2","arrayBufferTag$3","dataViewTag$4","float32Tag$2","float64Tag$2","int8Tag$2","int16Tag$2","int32Tag$2","uint8Tag$2","uint8ClampedTag$2","uint16Tag$2","uint32Tag$2","typedArrayTags","baseIsTypedArray","baseUnary","freeExports$1","freeModule$1","moduleExports$1","freeProcess","process","nodeUtil","types","require","binding","nodeUtil$1","nodeIsTypedArray","isTypedArray","isTypedArray$1","objectProto$d","hasOwnProperty$c","arrayLikeKeys","inherited","isArr","isArg","isBuff","isType","skipIndexes","String","push","overArg","arg","nativeKeys","nativeKeys$1","objectProto$c","hasOwnProperty$b","baseKeys","objectProto$b","hasOwnProperty$a","assign","assign$1","nativeKeysIn","objectProto$a","hasOwnProperty$9","baseKeysIn","isProto","keysIn","reIsDeepProp","reIsPlainProp","isKey","nativeCreate","nativeCreate$1","hashClear","__data__","size","hashDelete","has","HASH_UNDEFINED$2","objectProto$9","hasOwnProperty$8","hashGet","data","objectProto$8","hasOwnProperty$7","hashHas","HASH_UNDEFINED$1","hashSet","Hash","entries","clear","entry","set","get","listCacheClear","assocIndexOf","arrayProto","splice","listCacheDelete","lastIndex","pop","listCacheGet","listCacheHas","listCacheSet","ListCache","Map$1","Map$2","mapCacheClear","hash","map","isKeyable","getMapData","map2","mapCacheDelete","mapCacheGet","mapCacheHas","mapCacheSet","MapCache","FUNC_ERROR_TEXT$1","memoize","resolver","TypeError","memoized","cache","Cache","MAX_MEMOIZE_SIZE","memoizeCapped","rePropName","reEscapeChar","stringToPath","charCodeAt","match","number","quote","subString","stringToPath$1","castPath","INFINITY$1","toKey","baseGet","path","defaultValue","arrayPush","values2","offset","spreadableSymbol","isConcatSpreadable","isFlattenable","baseFlatten","depth","isStrict","flatten","getPrototype","getPrototypeOf","getPrototype$1","baseSlice","end","arrayReduce","accumulator","initAccum","stackClear","stackDelete","stackGet","stackHas","LARGE_ARRAY_SIZE$2","stackSet","pairs","Stack","baseAssign","baseAssignIn","freeExports","freeModule","moduleExports","allocUnsafe","cloneBuffer","buffer","isDeep","copy","arrayFilter","resIndex","stubArray","objectProto$7","nativeGetSymbols$1","getOwnPropertySymbols","getSymbols","symbol","getSymbols$1","copySymbols","nativeGetSymbols","getSymbolsIn","getSymbolsIn$1","copySymbolsIn","baseGetAllKeys","keysFunc","symbolsFunc","getAllKeys","getAllKeysIn","DataView","DataView$1","Promise$1","Promise$2","Set","Set$1","mapTag$5","objectTag$2","promiseTag","setTag$5","weakMapTag$1","dataViewTag$3","dataViewCtorString","mapCtorString","promiseCtorString","setCtorString","weakMapCtorString","getTag","ArrayBuffer","resolve","ctorString","getTag$1","objectProto$6","hasOwnProperty$6","initCloneArray","input","Uint8Array","Uint8Array$1","cloneArrayBuffer","arrayBuffer","byteLength","cloneDataView","dataView","byteOffset","reFlags","cloneRegExp","regexp","symbolProto$1","symbolValueOf$1","cloneSymbol","cloneTypedArray","typedArray","boolTag$2","dateTag$2","mapTag$4","numberTag$2","regexpTag$3","setTag$4","stringTag$3","symbolTag$2","arrayBufferTag$2","dataViewTag$2","float32Tag$1","float64Tag$1","int8Tag$1","int16Tag$1","int32Tag$1","uint8Tag$1","uint8ClampedTag$1","uint16Tag$1","uint32Tag$1","initCloneByTag","initCloneObject","mapTag$3","baseIsMap","nodeIsMap","isMap","isMap$1","setTag$3","baseIsSet","nodeIsSet","isSet","isSet$1","CLONE_DEEP_FLAG","CLONE_FLAT_FLAG","CLONE_SYMBOLS_FLAG$1","argsTag$1","arrayTag$1","boolTag$1","dateTag$1","errorTag$1","funcTag","genTag","mapTag$2","numberTag$1","objectTag$1","regexpTag$2","setTag$2","stringTag$2","symbolTag$1","weakMapTag","arrayBufferTag$1","dataViewTag$1","float32Tag","float64Tag","int8Tag","int16Tag","int32Tag","uint8Tag","uint8ClampedTag","uint16Tag","uint32Tag","cloneableTags","baseClone","bitmask","stack","isFlat","isFull","isFunc","stacked","forEach","subValue","add","key2","CLONE_SYMBOLS_FLAG","clone","compact","HASH_UNDEFINED","setCacheAdd","setCacheHas","SetCache","arraySome","cacheHas","COMPARE_PARTIAL_FLAG$5","COMPARE_UNORDERED_FLAG$3","equalArrays","equalFunc","isPartial","arrLength","othLength","arrStacked","othStacked","seen","arrValue","othValue","compared","othValue2","othIndex","mapToArray","setToArray","COMPARE_PARTIAL_FLAG$4","COMPARE_UNORDERED_FLAG$2","boolTag","dateTag","errorTag","mapTag$1","numberTag","regexpTag$1","setTag$1","stringTag$1","symbolTag","arrayBufferTag","dataViewTag","symbolProto","symbolValueOf","equalByTag","name","message","convert","COMPARE_PARTIAL_FLAG$3","objectProto$5","hasOwnProperty$5","equalObjects","objProps","objLength","othProps","objStacked","skipCtor","objCtor","othCtor","COMPARE_PARTIAL_FLAG$2","argsTag","arrayTag","objectTag","objectProto$4","hasOwnProperty$4","baseIsEqualDeep","objIsArr","othIsArr","objTag","othTag","objIsObj","othIsObj","isSameTag","objIsWrapped","othIsWrapped","objUnwrapped","othUnwrapped","baseIsEqual","COMPARE_PARTIAL_FLAG$1","COMPARE_UNORDERED_FLAG$1","baseIsMatch","matchData","noCustomizer","srcValue","isStrictComparable","getMatchData","matchesStrictComparable","baseMatches","baseHasIn","hasPath","hasFunc","hasIn","COMPARE_PARTIAL_FLAG","COMPARE_UNORDERED_FLAG","baseMatchesProperty","baseProperty","basePropertyDeep","property","baseIteratee","arrayAggregator","setter","createBaseFor","iterable","baseFor","baseFor$1","baseForOwn","createBaseEach","eachFunc","collection","baseEach","baseEach$1","baseAggregator","collection2","createAggregator","initializer","objectProto$3","hasOwnProperty$3","defaults","propsIndex","propsLength","defaults$1","isArrayLikeObject","arrayIncludesWith","comparator","LARGE_ARRAY_SIZE$1","baseDifference","includes2","isCommon","valuesLength","outer","computed","valuesIndex","difference","difference$1","last","drop","dropRight","castFunction","arrayEvery","baseEvery","every","baseFilter","filter","createFind","findIndexFunc","nativeMax$2","findIndex","find","find$1","head","baseMap","flatMap","objectProto$2","hasOwnProperty$2","groupBy","groupBy$1","objectProto$1","hasOwnProperty$1","baseHas","stringTag","isString","baseValues","values","nativeMax$1","includes","indexOf","nativeMax","mapTag","setTag","objectProto","isEmpty","regexpTag","baseIsRegExp","nodeIsRegExp","isRegExp","isRegExp$1","isUndefined","FUNC_ERROR_TEXT","negate","baseSet","nested","basePickBy","paths","pickBy","prop","baseReduce","reduce","reject","baseSome","some","INFINITY","createSet","createSet$1","LARGE_ARRAY_SIZE","baseUniq","seenIndex","uniq","PRINT_ERROR","msg","console","error","concat","PRINT_WARNING","warn","timer","getTime","val","total","time","toFastProperties","toBecomeFast","FakeConstructor","fakeInstance","fakeAccess","bar","tokenLabel$1","tokType","hasTokenLabel$1","LABEL","obj","AbstractProduction","_definition","_classCallCheck","_createClass","accept","visitor","visit","definition","prod","NonTerminal","_AbstractProduction","_inherits","_super","_createSuper","options","_this","idx","_assertThisInitialized","v","referencedRule","Rule","_AbstractProduction2","_super2","_this2","orgText","Alternative","_AbstractProduction3","_super3","_this3","ignoreAmbiguities","Option","_AbstractProduction4","_super4","_this4","RepetitionMandatory","_AbstractProduction5","_super5","_this5","RepetitionMandatoryWithSeparator","_AbstractProduction6","_super6","_this6","Repetition","_AbstractProduction7","_super7","_this7","RepetitionWithSeparator","_AbstractProduction8","_super8","_this8","Alternation","_AbstractProduction9","_super9","_this9","hasPredicates","Terminal","serializeGrammar","topRules","serializeProduction","node","convertDefinition","serializedNonTerminal","nonTerminalName","label","separator","terminalType","serializedTerminal","terminalLabel","PATTERN","Error","GAstVisitor","nodeAny","visitNonTerminal","visitAlternative","visitOption","visitRepetitionMandatory","visitRepetitionMandatoryWithSeparator","visitRepetitionWithSeparator","visitRepetition","visitAlternation","visitTerminal","visitRule","isSequenceProd","isOptionalProd","alreadyVisited","undefined","isDirectlyOptional","subProd","isBranchingProd","getProductionDslName","RestWalker","walk","_this10","prevRest","currRest","walkProdRef","walkTerminal","walkFlat","walkOption","walkAtLeastOne","walkAtLeastOneSep","walkManySep","walkMany","walkOr","terminal","refProd","flatProd","fullOrRest","optionProd","atLeastOneProd","fullAtLeastOneRest","atLeastOneSepProd","fullAtLeastOneSepRest","restForRepetitionWithSeparator","manyProd","fullManyRest","manySepProd","fullManySepRest","orProd","_this11","alt","prodWrapper","repSepProd","repSepRest","fullRepSepRest","first","firstForTerminal","firstForSequence","firstForBranching","firstSet","seq","nextSubProdIdx","hasInnerProdsRemaining","currSubProd","isLastInnerProdOptional","allAlternativesFirsts","innerProd","IN","ResyncFollowsWalker","_RestWalker","_super10","topProd","_this12","follows","startWalking","followName","buildBetweenProdsFollowPrefix","fullRest","restProd","t_in_topProd_follows","computeAllProdsFollows","topProductions","reSyncFollows","currRefsFollow","inner","occurenceInParent","cc","char","insertToSet","item","subItem","addFlag","flagObj","flagKey","ASSERT_EXISTS","ASSERT_NEVER_REACH_HERE","isCharacter","digitsCharCodes","i","wordCharCodes","whitespaceCodes","hexDigitPattern","decimalPattern","decimalPatternNoZero","RegExpParser","groupIdx","saveState","restoreState","newState","consumeChar","disjunction","flags","loc","begin","ignoreCase","multiLine","unicode","sticky","isRegExpFlag","popChar","substring","alts","alternative","peekChar","terms","isTerm","term","isAssertion","assertion","atom","quantifier","isBacktracking","range","atLeast","atMost","Infinity","integerIncludingZero","isDigit","greedy","dotAll","atomEscape","characterClass","group","isPatternCharacter","patternCharacter","isQuantifier","complement","decimalEscapeAtom","characterClassEscape","controlEscapeAtom","controlLetterEscapeAtom","nulCharacterAtom","hexEscapeSequenceAtom","regExpUnicodeEscapeSequenceAtom","identityEscapeAtom","positiveInteger","escapeCode","letter","letterCode","toUpperCase","parseHexDigits","escapedChar","classPatternCharacterAtom","nextChar","isClassAtom","from","classAtom","isRangeDash","to","classEscape","capturing","groupAst","howMuch","isAtom","prevState","howMany","hexString","hexChar","charCode","BaseRegExpVisitor","visitChildren","_this13","child","subChild","visitPattern","visitFlags","visitDisjunction","visitStartAnchor","visitEndAnchor","visitWordBoundary","visitNonWordBoundary","visitLookahead","visitNegativeLookahead","visitCharacter","visitSet","visitGroup","visitGroupBackReference","visitQuantifier","regExpAstCache","regExpParser","getRegExpAst","regExp","regExpStr","regExpAst","clearRegExpParserCache","complementErrorMessage","failedOptimizationPrefixMsg","getOptimizedStartCodesIndices","ensureOptimizations","ast","firstChars","firstCharOptimizedIndices","msgSuffix","addOptimizedIdxToResult","code","rangeCode","minOptimizationVal","minUnOptVal","maxUnOptVal","minOptIdx","charCodeToOptimizedIndex","maxOptIdx","currOptIdx","isOptionalQuantifier","isWholeOptional","optimizedCharIdx","handleIgnoreCase","fromCharCode","upperChar","lowerChar","toLowerCase","findCode","setNode","targetCharCodes","codeOrRange","targetCode","CharCodeFinder","_BaseRegExpVisitor","_super11","_this14","found","_get","_getPrototypeOf","canMatchCharCode","charCodes","charCodeFinder","DEFAULT_MODE","MODES","SUPPORT_STICKY","analyzeTokenTypes","tokenTypes","useSticky","debug","safeMode","positionTracking","lineTerminatorCharacters","tracer","action","initCharCodeToOptimizedIndexMap","onlyRelevantTypes","currType","Lexer2","NA","hasCustom","allTransformedPatterns","currPattern","regExpSource","addStickyFlag","addStartOfInput","escapedRegExpString","wrappedRegExp","patternIdxToType","patternIdxToGroup","patternIdxToLongerAltIdxArr","patternIdxToPushMode","patternIdxToPopMode","tokenTypeIdx","clazz","groupName","GROUP","SKIPPED","longerAltType","LONGER_ALT","longerAltIdxArr","PUSH_MODE","patternIdxToCanLineTerminator","lineTerminatorCharCodes","getCharCodes","LINE_BREAKS","checkLineBreaksIssues","patternIdxToIsCustom","patternIdxToShort","emptyGroups","patternIdxToConfig","isCustomPattern","isShortPattern","acc","x","longerAlt","canLineTerminator","isCustom","short","tokenType","canBeOptimized","charCodeToPatternIdxToConfig","currTokType","optimizedIdx","addToMapOfArrays","START_CHARS_HINT","lastOptimizedIdx","charOrInt","currOptimizedIdx","optimizedCodes","validatePatterns","validModesNames","errors","missingResult","findMissingPatterns","invalidResult","findInvalidPatterns","valid","validTokenTypes","validateRegExpPattern","findInvalidGroupType","findModesThatDoNotExist","findUnreachablePatterns","withRegExpPatterns","findEndOfInputAnchor","findStartOfInputAnchor","findUnsupportedFlags","findDuplicatePatterns","findEmptyMatchRegExps","tokenTypesWithMissingPattern","LexerDefinitionErrorType","MISSING_PATTERN","tokenTypesWithInvalidPattern","INVALID_PATTERN","end_of_input","EndAnchorFinder","_BaseRegExpVisitor2","_super12","_this15","invalidRegex","regexpAst","endAnchorVisitor","EOI_ANCHOR_FOUND","matchesEmptyString","EMPTY_MATCH_PATTERN","start_of_input","StartAnchorFinder","_BaseRegExpVisitor3","_super13","_this16","startAnchorVisitor","SOI_ANCHOR_FOUND","invalidFlags","multiline","UNSUPPORTED_FLAGS_FOUND","identicalPatterns","outerType","innerType","duplicatePatterns","currIdenticalSet","setOfIdentical","tokenTypeNames","dupPatternSrc","join","DUPLICATE_PATTERNS_FOUND","invalidTypes","INVALID_GROUP_TYPE_FOUND","validModes","invalidModes","PUSH_MODE_DOES_NOT_EXIST","canBeTested","str","noMetaChar","testIdx","_ref2","testTokenType","UNREACHABLE_PATTERN","regExpArray","metaChars","performRuntimeChecks","lexerDefinition","trackLines","MULTI_MODE_LEXER_WITHOUT_DEFAULT_MODE","MULTI_MODE_LEXER_WITHOUT_MODES_PROPERTY","modes","defaultMode","MULTI_MODE_LEXER_DEFAULT_MODE_VALUE_DOES_NOT_EXIST","currModeValue","currModeName","currIdx","LEXER_DEFINITION_CANNOT_CONTAIN_UNDEFINED","currLongerAlt","MULTI_MODE_LEXER_LONGER_ALT_NOT_IN_CURRENT_MODE","performWarningRuntimeChecks","warnings","hasAnyLineBreak","allTokenTypes","concreteTokenTypes","terminatorCharCodes","currIssue","buildLineBreakIssueMessage","warningDescriptor","issue","NO_LINE_BREAKS_FLAGS","cloneEmptyGroups","clonedResult","groupKeys","currKey","currGroupValue","LineTerminatorOptimizedTester","text","len","c","IDENTIFY_TERMINATOR","errMsg","CUSTOM_LINE_BREAK","details","charsOrCodes","numOrString","charCodeToOptimizedIdxMap","tokenStructuredMatcher","tokInstance","tokConstructor","instanceType","isParent","categoryMatchesMap","tokenStructuredMatcherNoCategories","token","tokenShortNameIdx","tokenIdxToClass","augmentTokenTypes","tokenTypesAndParents","expandCategories","assignTokenDefaultProps","assignCategoriesMapProp","assignCategoriesTokensProp","categoryMatches","categories","searching","CATEGORIES","newCategories","hasShortKeyProperty","hasCategoriesProperty","hasExtendingTokensTypesProperty","hasExtendingTokensTypesMapProperty","singleAssignCategoriesToksMap","nextNode","pathNode","nextCategory","newPath","isTokenType","defaultLexerErrorProvider","buildUnableToPopLexerModeMessage","image","buildUnexpectedCharactersMessage","fullText","startOffset","line","column","LexerDefinitionErrorType2","DEFAULT_LEXER_CONFIG","deferDefinitionErrorsHandling","lineTerminatorsPattern","errorMessageProvider","traceInitPerf","skipValidations","recoveryEnabled","freeze","_this17","config","lexerDefinitionErrors","lexerDefinitionWarning","trackStartLines","trackEndLines","canModeBeOptimized","TRACE_INIT","phaseDesc","phaseImpl","traceInitIndent","indent","traceInitMaxIdent","log","_timer","traceMethod","traceInitVal","actualDefinition","hasOnlySingleMode","allModeNames","currModDef","currModName","currAnalyzeResult","allErrMessages","allErrMessagesString","chopInput","matchWithTest","updateLastIndex","matchWithExec","handleModes","computeNewColumn","updateTokenEndLineColumnLocation","createTokenInstance","createFullToken","createStartOnlyToken","createOffsetOnlyToken","addToken","addTokenUsingPush","handlePayload","handlePayloadWithCustom","addTokenUsingMemberAccess","handlePayloadNoCustom","unOptimizedModes","cannotBeOptimized","modeName","tokenize","initialMode","tokenizeInternal","_this18","j","k","matchAltImage","matchedImage","payload","altPayload","imageLength","newToken","errLength","orgLength","matchedTokensIndex","guessedNumberOfTokens","floor","matchedTokens","groups","lineTerminatorPattern","currModePatternsLength","currCharCodeToPatternIdxToConfig","modeStack","emptyArray","getPossiblePatterns","getPossiblePatternsSlow","getPossiblePatternsOptimized","possiblePatterns","pop_mode","popToken","msg2","startLine","startColumn","newMode","modeCanBeOptimized","push_mode","currConfig","nextCharCode","chosenPatternIdxToConfig","chosenPatternsLength","singleCharCode","longerAltLength","longerAltConfig","longerAltPattern","numOfLTsInMatch","foundTerminator","lastLTEndOffset","errorStartOffset","errorLine","errorColumn","foundResyncPoint","currConfig2","tokens","pushMode","newLastIndex","lastLTIdx","lastCharIsLT","fixForEndingInLT","endLine","endColumn","oldColumn","endOffset","tokenVector","tokenToAdd","tokenLabel","hasTokenLabel","PARENT","POP_MODE","createToken2","createTokenInternal","EOF","tokenMatcher","defaultParserErrorProvider","buildMismatchTokenMessage","_ref3","expected","actual","previous","ruleName","hasLabel","expectedMsg","buildNotAllInputParsedMessage","_ref4","firstRedundant","buildNoViableAltMessage","_ref5","expectedPathsPerAlt","customUserDescription","errPrefix","actualText","errSuffix","allLookAheadPaths","currAltPaths","nextValidTokenSequences","currPath","currTokenType","nextValidSequenceItems","itemMsg","calculatedDescription","buildEarlyExitMessage","_ref6","expectedIterationPaths","defaultGrammarResolverErrorProvider","buildRuleNotFoundError","topLevelRule","undefinedRule","defaultGrammarValidatorErrorProvider","buildDuplicateFoundError","duplicateProds","getExtraProductionArgument2","topLevelName","duplicateProd","dslName","extraArgument","hasExplicitIndex","buildNamespaceConflictError","rule","buildAlternationPrefixAmbiguityError","pathMsg","prefixPath","currTok","occurrence","alternation","ambiguityIndices","buildAlternationAmbiguityError","currtok","currMessage","buildEmptyRepetitionError","repetition","buildTokenNameError","buildEmptyAlternationError","emptyChoiceIdx","buildTooManyAlternativesError","buildLeftRecursionError","pathNames","leftRecursionPath","currRule","leftRecursivePath","buildInvalidRuleNameError","buildDuplicateRuleNameError","grammarName","resolveGrammar$1","topLevels","errMsgProvider","refResolver","GastRefResolverVisitor","resolveRefs","_GAstVisitor","_super14","nameToTopRule","_this19","_this20","currTopLevel","ref","ParserDefinitionErrorType","UNRESOLVED_SUBRULE_REF","unresolvedRefName","AbstractNextPossibleTokensWalker","_RestWalker2","_super15","_this21","possibleTokTypes","nextProductionName","nextProductionOccurrence","isAtEndOfPath","ruleStack","reverse","occurrenceStack","updateExpectedNext","NextAfterTokenWalker","_AbstractNextPossible","_super16","_this22","nextTerminalName","nextTerminalOccurrence","lastTok","lastTokOccurrence","AbstractNextTerminalAfterProductionWalker","_RestWalker3","_super17","topRule","_this23","isEndOfRule","NextTerminalAfterManyWalker","_AbstractNextTerminal","_super18","firstAfterMany","NextTerminalAfterManySepWalker","_AbstractNextTerminal2","_super19","firstAfterManySep","NextTerminalAfterAtLeastOneWalker","_AbstractNextTerminal3","_super20","firstAfterAtLeastOne","NextTerminalAfterAtLeastOneSepWalker","_AbstractNextTerminal4","_super21","atleastOneSepProd","firstAfterfirstAfterAtLeastOneSep","possiblePathsFrom","targetDef","maxLength","remainingPathWith","nextDef","getAlternativesForProd","alternatives","newDef","currAlt","partialPath","suffixDef","nextPossibleTokensAfter","initialDef","tokMatcher","maxLookAhead","EXIT_NON_TERMINAL","EXIT_NON_TERMINAL_ARR","EXIT_ALTERNATIVE","foundCompletePath","tokenVectorLength","minimalAlternativesIndex","possiblePaths","def","currDef","currRuleStack","currOccurrenceStack","nextPath","nextIdx","actualToken","nextTokenType","nextTokenOccurrence","newRuleStack","newOccurrenceStack","nextPathWithout","nextPathWith","secondIteration","separatorGast","nthRepetition","currAltPath","expandTopLevelRule","newCurrOccurrenceStack","PROD_TYPE","PROD_TYPE2","getProdType","OPTION","REPETITION","REPETITION_MANDATORY","REPETITION_MANDATORY_WITH_SEPARATOR","REPETITION_WITH_SEPARATOR","ALTERNATION","buildLookaheadFuncForOr","ruleGrammar","maxLookahead","dynamicTokensEnabled","laFuncBuilder","lookAheadPaths","getLookaheadPathsForOr","tokenMatcher2","areTokenCategoriesNotUsed","buildLookaheadFuncForOptionalProd","prodType","lookaheadBuilder","getLookaheadPathsForOptionalProd","buildAlternativesLookAheadFunc","numOfAlts","areAllOneTokenLookahead","orAlts","predicates","GATE","t","currNumOfPaths","currPredicate","currPathLength","nextToken","LA","singleTokenAlts","choiceToAlt","currExtendingType","buildSingleAlternativeLookaheadFunction","numOfPaths","singleTokensTypes","expectedTokenType","expectedTokenUniqueKey","RestDefinitionFinderWalker","_RestWalker4","_super22","targetOccurrence","targetProdType","_this24","restDef","checkIsTarget","expectedProdType","InsideDefinitionFinderVisitor","_GAstVisitor2","_super23","targetRef","_this25","expectedProdName","initializeArrayOfArrays","pathToHashKeys","keys2","longerKeys","currShorterKey","categoriesKeySuffix","isUniquePrefixHash","altKnownPathsKeys","searchPathKeys","currAltIdx","otherAltKnownPathsKeys","searchIdx","searchKey","lookAheadSequenceFromAlternatives","altsDefs","partialAlts","finalResult","altsHashes","dict","newData","pathLength","currDataset","_loop","altIdx","currAltPathsAndSuffixes","currPathIdx","currPathPrefix","prefixKeys","isUnique","currAltResult","containsPath","newPartialPathsAndSuffixes","prefixKeys2","insideDefVisitor","insideDef","afterDefWalker","afterDef","insideFlat","afterFlat","searchPath","compareOtherPath","otherPath","searchTok","otherTok","matchingTokens","isStrictPrefixOfPath","prefix","otherTokType","singleAltPaths","singlePath","validateLookahead","lookaheadValidationErrorMessages","lookaheadStrategy","validate","rules","errorMessage","CUSTOM_LOOKAHEAD_VALIDATION","validateGrammar$1","duplicateErrors","validateDuplicateProductions","termsNamespaceConflictErrors","checkTerminalAndNoneTerminalsNameSpace","tooManyAltsErrors","curRule","validateTooManyAlts","duplicateRulesError","validateRuleDoesNotAlreadyExist","collectorVisitor2","OccurrenceValidationCollector","allRuleProductions","allProductions","productionGroups","identifyProductionForDuplicates","duplicates","currGroup","currDuplicates","firstProd","defError","DUPLICATE_PRODUCTIONS","param","getExtraProductionArgument","parameter","_GAstVisitor3","_super24","_this26","subrule","option","manySep","atLeastOne","atLeastOneSep","many","or","allRules","className","occurrences","DUPLICATE_RULE_NAME","validateRuleIsOverridden","definedRulesNames","INVALID_RULE_OVERRIDE","validateNoLeftRecursion","nextNonTerminals","getFirstNoneTerminal","foundLeftRecursion","LEFT_RECURSION","validNextSteps","errorsFromNextSteps","currRefRule","currSubDef","isFirstOptional","hasMore","rest","OrCollector","_GAstVisitor4","_super25","_this27","alternations","validateEmptyOrAlternative","orCollector","ors","currOr","exceptLast","currAlternative","possibleFirstInAlt","NONE_LAST_EMPTY_ALT","validateAmbiguousAlternationAlternatives","globalMaxLookahead","currOccurrence","actualMaxLookahead","altsAmbiguityErrors","checkAlternativesAmbiguities","altsPrefixAmbiguityErrors","checkPrefixAlternativesAmbiguities","RepetitionCollector","_GAstVisitor5","_super26","_this28","TOO_MANY_ALTS","validateSomeNonEmptyLookaheadPath","topLevelRules","currTopRule","currProd","pathsInsideProduction","NO_NON_EMPTY_LOOKAHEAD","foundAmbiguousPaths","identicalAmbiguities","altsCurrPathAppearsIn","currOtherAlt","currOtherAltIdx","currErrors","currAmbDescriptor","ambgIndices","AMBIGUOUS_ALTS","pathsAndIndices","currPathsAndIdx","currPathAndIdx","alternativeGast","targetIdx","targetPath","prefixAmbiguitiesPathsAndIndices","searchPathAndIdx","currPathPrefixErrors","currAmbPathAndIdx","AMBIGUOUS_PREFIX_ALTS","tokenNames","currToken","currRuleName","CONFLICT_TOKENS_RULES_NAMESPACE","resolveGrammar","actualOptions","topRulesTable","validateGrammar","MISMATCHED_TOKEN_EXCEPTION","NO_VIABLE_ALT_EXCEPTION","EARLY_EXIT_EXCEPTION","NOT_ALL_INPUT_PARSED_EXCEPTION","RECOGNITION_EXCEPTION_NAMES","isRecognitionException","RecognitionException","_Error","_super27","_this29","resyncedTokens","setPrototypeOf","captureStackTrace","_wrapNativeSuper","MismatchedTokenException","_RecognitionException","_super28","previousToken","_this30","NoViableAltException","_RecognitionException2","_super29","_this31","NotAllInputParsedException","_RecognitionException3","_super30","_this32","EarlyExitException","_RecognitionException4","_super31","_this33","EOF_FOLLOW_KEY","IN_RULE_RECOVERY_EXCEPTION","InRuleRecoveryException","_Error2","_super32","_this34","Recoverable","initRecoverable","firstAfterRepMap","resyncFollows","DEFAULT_PARSER_CONFIG","attemptInRepetitionRecovery","getTokenToInsert","tokToInsert","NaN","isInsertedInRecovery","canTokenTypeBeInsertedInRecovery","canTokenTypeBeDeletedInRecovery","tryInRepetitionRecovery","grammarRule","grammarRuleArgs","lookAheadFunc","expectedTokType","_this35","reSyncTokType","findReSyncTokenType","savedLexerState","exportLexerState","passedResyncPoint","nextTokenWithoutResync","generateErrorMessage","getCurrRuleFullName","SAVE_ERROR","SKIP_TOKEN","addToResyncTokens","importLexerState","shouldInRepetitionRecoveryBeTried","expectTokAfterLastMatch","nextTokIdx","notStuck","isBackTracking","canPerformInRuleRecovery","getFollowsForInRuleRecovery","tokIdxInRule","grammarPath","getCurrentGrammarPath","getNextPossibleTokenTypes","tryInRuleRecovery","canRecoverWithSingleTokenInsertion","canRecoverWithSingleTokenDeletion","nextTok","consumeToken","expectedToken","_this36","mismatchedTok","isMisMatchedTokInFollows","possibleFollowsTokType","isNextTokenWhatIsExpected","isInCurrentRuleReSyncSet","followKey","getCurrFollowKey","currentRuleReSyncSet","getFollowSetFromFollowKey","allPossibleReSyncTokTypes","flattenFollowSet","foundMatch","resyncTokType","canMatch","RULE_STACK","currRuleShortName","getLastExplicitRuleShortName","currRuleIdx","getLastExplicitRuleOccurrenceIndex","prevRuleShortName","getPreviousExplicitRuleShortName","shortRuleNameToFullName","idxInCallingRule","inRule","buildFullFollowKeyStack","_this37","explicitRuleStack","explicitOccurrenceStack","RULE_OCCURRENCE_STACK","_this38","followStack","resyncTokens","reSyncTo","prodFunc","lookaheadFunc","dslMethodIdx","prodOccurrence","nextToksWalker","pathRuleStack","getHumanReadableRuleStack","pathOccurrenceStack","_this39","currShortName","getKeyForAutomaticLookahead","firstAfterRepInfo","getGAstProductions","walker","BITS_FOR_METHOD_TYPE","BITS_FOR_OCCURRENCE_IDX","OR_IDX","OPTION_IDX","MANY_IDX","AT_LEAST_ONE_IDX","MANY_SEP_IDX","AT_LEAST_ONE_SEP_IDX","ruleIdx","LLkLookaheadStrategy","_a","leftRecursionErrors","emptyAltErrors","validateEmptyOrAlternatives","ambiguousAltsErrors","emptyRepetitionErrors","allErrors","_toConsumableArray","buildLookaheadForAlternation","buildLookaheadForOptional","LooksAhead","initLooksAhead","lookAheadFuncsCache","Map","preComputeLookaheadFunctions","_this40","_collectMethods","collectMethods","repetitionMandatory","repetitionMandatoryWithSeparator","repetitionWithSeparator","prodIdx","laFunc","fullRuleNameToShort","setLaFuncCache","computeLookaheadFunc","prodKey","prodMaxLookahead","dslMethodName","_this41","getLaFuncFromCache","DslMethodsCollectorVisitor","_GAstVisitor6","_super33","_this42","dslMethods","reset","collectorVisitor","setNodeLocationOnlyOffset","currNodeLocation","newLocationInfo","isNaN","setNodeLocationFull","addTerminalToCst","tokenTypeName","children","addNoneTerminalToCst","ruleResult","NAME","defineNameProp","nameValue","defaultVisit","ctx","childrenNames","childrenNamesLength","currChildName","currChildArray","currChildArrayLength","currChild","createBaseSemanticVisitorConstructor","ruleNames","derivedConstructor","semanticProto","cstNode","validateVisitor","semanticDefinitionErrors","errorMessages","currDefError","_RULE_NAMES","createBaseVisitorConstructorWithDefaults","baseConstructor","withDefaultsProto","CstVisitorDefinitionError","CstVisitorDefinitionError2","visitorInstance","missingErrors","validateMissingCstMethods","missingRuleNames","MISSING_METHOD","methodName","TreeBuilder","initTreeBuilder","CST_STACK","outputCst","nodeLocationTracking","cstInvocationStateUpdate","cstFinallyStateUpdate","cstPostTerminal","cstPostNonTerminal","cstPostRule","setNodeLocationFromToken","setNodeLocationFromNode","setInitialNodeLocation","setInitialNodeLocationFullRecovery","cstPostRuleFull","setInitialNodeLocationFullRegular","setInitialNodeLocationOnlyOffsetRecovery","cstPostRuleOnlyOffset","setInitialNodeLocationOnlyOffsetRegular","location","fullRuleName","ruleCstNode","prevToken","consumedToken","rootCst","ruleCstResult","preCstNode","getBaseCstVisitorConstructor","baseCstVisitorConstructor","newBaseCstVisitorConstructor","gastProductionsCache","getBaseCstVisitorConstructorWithDefaults","baseCstVisitorWithDefaultsConstructor","newConstructor","LexerAdapter","initLexerAdapter","tokVector","tokVectorLength","newInput","selfAnalysisDone","END_OF_FILE","soughtIdx","resetLexerState","moveToTerminatedState","getLexerPosition","RecognizerApi","ACTION","impl","consume","consumeInternal","ruleToCall","subruleInternal","actionORMethodDef","optionInternal","altsOrOpts","orInternal","manyInternal","atLeastOneInternal","CONSUME","CONSUME1","CONSUME2","CONSUME3","CONSUME4","CONSUME5","CONSUME6","CONSUME7","CONSUME8","CONSUME9","SUBRULE","SUBRULE1","SUBRULE2","SUBRULE3","SUBRULE4","SUBRULE5","SUBRULE6","SUBRULE7","SUBRULE8","SUBRULE9","OPTION1","OPTION2","OPTION3","OPTION4","OPTION5","OPTION6","OPTION7","OPTION8","OPTION9","OR","OR1","OR2","OR3","OR4","OR5","OR6","OR7","OR8","OR9","MANY","MANY1","MANY2","MANY3","MANY4","MANY5","MANY6","MANY7","MANY8","MANY9","MANY_SEP","manySepFirstInternal","MANY_SEP1","MANY_SEP2","MANY_SEP3","MANY_SEP4","MANY_SEP5","MANY_SEP6","MANY_SEP7","MANY_SEP8","MANY_SEP9","AT_LEAST_ONE","AT_LEAST_ONE1","AT_LEAST_ONE2","AT_LEAST_ONE3","AT_LEAST_ONE4","AT_LEAST_ONE5","AT_LEAST_ONE6","AT_LEAST_ONE7","AT_LEAST_ONE8","AT_LEAST_ONE9","AT_LEAST_ONE_SEP","atLeastOneSepFirstInternal","AT_LEAST_ONE_SEP1","AT_LEAST_ONE_SEP2","AT_LEAST_ONE_SEP3","AT_LEAST_ONE_SEP4","AT_LEAST_ONE_SEP5","AT_LEAST_ONE_SEP6","AT_LEAST_ONE_SEP7","AT_LEAST_ONE_SEP8","AT_LEAST_ONE_SEP9","RULE","implementation","DEFAULT_RULE_CONFIG","definitionErrors","ruleImplementation","defineRule","OVERRIDE_RULE","ruleErrors","BACKTRACK","isBackTrackingStack","orgState","saveRecogState","reloadRecogState","getSerializedGastProductions","RecognizerEngine","initRecognizerEngine","tokenVocabulary","shortRuleNameToFull","ruleShortNameIdx","subruleIdx","tokensMap","allTokenTypes2","uniqueTokens","noTokenCategoriesUsed","tokenConstructor","resyncEnabled","recoveryValueFunc","shortName","invokeRuleWithTry","invokeRuleWithTry2","ruleInvocationStateUpdate","_len","_key","cst","invokeRuleCatch","ruleFinallyStateUpdate","invokeRuleWithTryCst","_len2","_key2","wrappedGrammarRule","originalGrammarAction","resyncEnabledConfig","isFirstInvokedRule","reSyncEnabled","recogError","partialCstResult","recoveredNode","optionInternalLogic","_this43","DEF","orgLookaheadFunction","laKey","atLeastOneInternalLogic","_this44","doSingleRepetition","raiseEarlyExitException","ERR_MSG","atLeastOneSepFirstInternalLogic","_this45","SEP","firstIterationLookaheadFunc","separatorLookAheadFunc","repetitionSepSecondInternal","manyInternalLogic","_this46","lookaheadFunction","manySepFirstInternalLogic","_this47","firstIterationLaFunc","nextTerminalAfterWalker","beforeIteration","afterIteration","altIdxToTake","chosenAlternative","ALT","raiseNoAltException","isAtEndOfInput","firstRedundantTok","ARGS","subruleInternalError","consumeInternalError","eFromConsumption","consumeInternalRecovery","eFromInRuleRecovery","savedErrors","savedRuleStack","lexerState","fullName","ErrorHandler","initErrorHandler","_errors","context","ruleOccurrenceStack","newErrors","userDefinedErrMsg","lookAheadPathsPerAlternative","insideProdPaths","actualTokens","errMsgTypes","ContentAssist","initContentAssist","computeContentAssist","startRuleName","precedingInput","startRuleGast","topRuleName","gastProductions","topProduction","nextPossibleTokenTypes","RECORDING_NULL_OBJECT","description","HANDLE_SEPARATOR","MAX_METHOD_IDX","pow","RFT","RECORDING_PHASE_TOKEN","RECORDING_PHASE_CSTNODE","GastRecorder","initGastRecorder","recordingProdStack","RECORDING_PHASE","enableRecording","_this48","_loop2","_i18","arg1","arg2","consumeInternalRecord","subruleInternalRecord","optionInternalRecord","orInternalRecord","manyInternalRecord","manySepFirstInternalRecord","atLeastOneInternalRecord","atLeastOneSepFirstInternalRecord","ACTION_RECORD","BACKTRACK_RECORD","LA_RECORD","disableRecording","_this49","that","topLevelRuleRecord","newTopLevelRule","originalError","KNOWN_RECORDER_ERROR","mutabilityError","recordProd","recordOrProd","assertMethodIdxIsValid","getIdxSuffix","JSON","stringify","prevProd","newNoneTerminal","prodConstructor","mainProdArg","handleSep","grammarAction","newProd","MAX_LOOKAHEAD","_this50","hasOptions","newOrProd","IGNORE_AMBIGUITIES","currAltFlat","PerformanceTracer","initPerformanceTracer","userTraceInitPerf","traceIsNumber","_timer2","applyMixins","derivedCtor","baseCtors","baseCtor","baseProto","getOwnPropertyNames","propName","basePropDescriptor","getOwnPropertyDescriptor","ParserDefinitionErrorType2","Parser","performSelfAnalysis","_this51","defErrorsMsgs","wrappedRule","recordedRuleGast","resolverErrors","validationErrors","lookaheadValidationErrors","allFollows","_b","initialize","DEFER_DEFINITION_ERRORS_HANDLING","parserInstance","CstParser2","_Parser","_super34","configClone","CstParser","Lexer","createToken"],"sources":["C:\\Users\\Nayyu\\Desktop\\skibidai-public-build\\node_modules\\src\\libs\\chevrotain.js"],"sourcesContent":["const { CstParser, Lexer, createToken } = (() => {\n  /** Detect free variable `global` from Node.js. */\n  var freeGlobal = typeof global == 'object' && global && global.Object === Object && global\n\n  const freeGlobal$1 = freeGlobal\n\n  /** Detect free variable `self`. */\n  var freeSelf = typeof self == 'object' && self && self.Object === Object && self\n\n  /** Used as a reference to the global object. */\n  var root = freeGlobal$1 || freeSelf || Function('return this')()\n\n  const root$1 = root\n\n  /** Built-in value references. */\n  var Symbol$1 = root$1.Symbol\n\n  const Symbol$2 = Symbol$1\n\n  /** Used for built-in method references. */\n  var objectProto$j = Object.prototype\n\n  /** Used to check objects for own properties. */\n  var hasOwnProperty$g = objectProto$j.hasOwnProperty\n\n  /**\n   * Used to resolve the\n   * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n   * of values.\n   */\n  var nativeObjectToString$1 = objectProto$j.toString\n\n  /** Built-in value references. */\n  var symToStringTag$1 = Symbol$2 ? Symbol$2.toStringTag : undefined\n\n  /**\n   * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.\n   *\n   * @private\n   * @param {*} value The value to query.\n   * @returns {string} Returns the raw `toStringTag`.\n   */\n  function getRawTag(value) {\n    var isOwn = hasOwnProperty$g.call(value, symToStringTag$1),\n      tag = value[symToStringTag$1]\n\n    try {\n      value[symToStringTag$1] = undefined\n      var unmasked = true\n    } catch (e) {}\n\n    var result = nativeObjectToString$1.call(value)\n    if (unmasked) {\n      if (isOwn) {\n        value[symToStringTag$1] = tag\n      } else {\n        delete value[symToStringTag$1]\n      }\n    }\n    return result\n  }\n\n  /** Used for built-in method references. */\n  var objectProto$i = Object.prototype\n\n  /**\n   * Used to resolve the\n   * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n   * of values.\n   */\n  var nativeObjectToString = objectProto$i.toString\n\n  /**\n   * Converts `value` to a string using `Object.prototype.toString`.\n   *\n   * @private\n   * @param {*} value The value to convert.\n   * @returns {string} Returns the converted string.\n   */\n  function objectToString(value) {\n    return nativeObjectToString.call(value)\n  }\n\n  /** `Object#toString` result references. */\n  var nullTag = '[object Null]',\n    undefinedTag = '[object Undefined]'\n\n  /** Built-in value references. */\n  var symToStringTag = Symbol$2 ? Symbol$2.toStringTag : undefined\n\n  /**\n   * The base implementation of `getTag` without fallbacks for buggy environments.\n   *\n   * @private\n   * @param {*} value The value to query.\n   * @returns {string} Returns the `toStringTag`.\n   */\n  function baseGetTag(value) {\n    if (value == null) {\n      return value === undefined ? undefinedTag : nullTag\n    }\n    return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value)\n  }\n\n  /**\n   * Checks if `value` is object-like. A value is object-like if it's not `null`\n   * and has a `typeof` result of \"object\".\n   *\n   * @static\n   * @memberOf _\n   * @since 4.0.0\n   * @category Lang\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n   * @example\n   *\n   * _.isObjectLike({});\n   * // => true\n   *\n   * _.isObjectLike([1, 2, 3]);\n   * // => true\n   *\n   * _.isObjectLike(_.noop);\n   * // => false\n   *\n   * _.isObjectLike(null);\n   * // => false\n   */\n  function isObjectLike(value) {\n    return value != null && typeof value == 'object'\n  }\n\n  /** `Object#toString` result references. */\n  var symbolTag$3 = '[object Symbol]'\n\n  /**\n   * Checks if `value` is classified as a `Symbol` primitive or object.\n   *\n   * @static\n   * @memberOf _\n   * @since 4.0.0\n   * @category Lang\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\n   * @example\n   *\n   * _.isSymbol(Symbol.iterator);\n   * // => true\n   *\n   * _.isSymbol('abc');\n   * // => false\n   */\n  function isSymbol(value) {\n    return typeof value == 'symbol' || (isObjectLike(value) && baseGetTag(value) == symbolTag$3)\n  }\n\n  /**\n   * A specialized version of `_.map` for arrays without support for iteratee\n   * shorthands.\n   *\n   * @private\n   * @param {Array} [array] The array to iterate over.\n   * @param {Function} iteratee The function invoked per iteration.\n   * @returns {Array} Returns the new mapped array.\n   */\n  function arrayMap(array, iteratee) {\n    var index = -1,\n      length = array == null ? 0 : array.length,\n      result = Array(length)\n\n    while (++index < length) {\n      result[index] = iteratee(array[index], index, array)\n    }\n    return result\n  }\n\n  /**\n   * Checks if `value` is classified as an `Array` object.\n   *\n   * @static\n   * @memberOf _\n   * @since 0.1.0\n   * @category Lang\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is an array, else `false`.\n   * @example\n   *\n   * _.isArray([1, 2, 3]);\n   * // => true\n   *\n   * _.isArray(document.body.children);\n   * // => false\n   *\n   * _.isArray('abc');\n   * // => false\n   *\n   * _.isArray(_.noop);\n   * // => false\n   */\n  var isArray = Array.isArray\n\n  const isArray$1 = isArray\n\n  /** Used as references for various `Number` constants. */\n  var INFINITY$3 = 1 / 0\n\n  /** Used to convert symbols to primitives and strings. */\n  var symbolProto$2 = Symbol$2 ? Symbol$2.prototype : undefined,\n    symbolToString = symbolProto$2 ? symbolProto$2.toString : undefined\n\n  /**\n   * The base implementation of `_.toString` which doesn't convert nullish\n   * values to empty strings.\n   *\n   * @private\n   * @param {*} value The value to process.\n   * @returns {string} Returns the string.\n   */\n  function baseToString(value) {\n    // Exit early for strings to avoid a performance hit in some environments.\n    if (typeof value == 'string') {\n      return value\n    }\n    if (isArray$1(value)) {\n      // Recursively convert values (susceptible to call stack limits).\n      return arrayMap(value, baseToString) + ''\n    }\n    if (isSymbol(value)) {\n      return symbolToString ? symbolToString.call(value) : ''\n    }\n    var result = value + ''\n    return result == '0' && 1 / value == -INFINITY$3 ? '-0' : result\n  }\n\n  /** Used to match a single whitespace character. */\n  var reWhitespace = /\\s/\n\n  /**\n   * Used by `_.trim` and `_.trimEnd` to get the index of the last non-whitespace\n   * character of `string`.\n   *\n   * @private\n   * @param {string} string The string to inspect.\n   * @returns {number} Returns the index of the last non-whitespace character.\n   */\n  function trimmedEndIndex(string) {\n    var index = string.length\n\n    while (index-- && reWhitespace.test(string.charAt(index))) {}\n    return index\n  }\n\n  /** Used to match leading whitespace. */\n  var reTrimStart = /^\\s+/\n\n  /**\n   * The base implementation of `_.trim`.\n   *\n   * @private\n   * @param {string} string The string to trim.\n   * @returns {string} Returns the trimmed string.\n   */\n  function baseTrim(string) {\n    return string ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, '') : string\n  }\n\n  /**\n   * Checks if `value` is the\n   * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n   * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n   *\n   * @static\n   * @memberOf _\n   * @since 0.1.0\n   * @category Lang\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n   * @example\n   *\n   * _.isObject({});\n   * // => true\n   *\n   * _.isObject([1, 2, 3]);\n   * // => true\n   *\n   * _.isObject(_.noop);\n   * // => true\n   *\n   * _.isObject(null);\n   * // => false\n   */\n  function isObject(value) {\n    var type = typeof value\n    return value != null && (type == 'object' || type == 'function')\n  }\n\n  /** Used as references for various `Number` constants. */\n  var NAN = 0 / 0\n\n  /** Used to detect bad signed hexadecimal string values. */\n  var reIsBadHex = /^[-+]0x[0-9a-f]+$/i\n\n  /** Used to detect binary string values. */\n  var reIsBinary = /^0b[01]+$/i\n\n  /** Used to detect octal string values. */\n  var reIsOctal = /^0o[0-7]+$/i\n\n  /** Built-in method references without a dependency on `root`. */\n  var freeParseInt = parseInt\n\n  /**\n   * Converts `value` to a number.\n   *\n   * @static\n   * @memberOf _\n   * @since 4.0.0\n   * @category Lang\n   * @param {*} value The value to process.\n   * @returns {number} Returns the number.\n   * @example\n   *\n   * _.toNumber(3.2);\n   * // => 3.2\n   *\n   * _.toNumber(Number.MIN_VALUE);\n   * // => 5e-324\n   *\n   * _.toNumber(Infinity);\n   * // => Infinity\n   *\n   * _.toNumber('3.2');\n   * // => 3.2\n   */\n  function toNumber(value) {\n    if (typeof value == 'number') {\n      return value\n    }\n    if (isSymbol(value)) {\n      return NAN\n    }\n    if (isObject(value)) {\n      var other = typeof value.valueOf == 'function' ? value.valueOf() : value\n      value = isObject(other) ? other + '' : other\n    }\n    if (typeof value != 'string') {\n      return value === 0 ? value : +value\n    }\n    value = baseTrim(value)\n    var isBinary = reIsBinary.test(value)\n    return isBinary || reIsOctal.test(value)\n      ? freeParseInt(value.slice(2), isBinary ? 2 : 8)\n      : reIsBadHex.test(value)\n      ? NAN\n      : +value\n  }\n\n  /** Used as references for various `Number` constants. */\n  var INFINITY$2 = 1 / 0,\n    MAX_INTEGER = 1.7976931348623157e308\n\n  /**\n   * Converts `value` to a finite number.\n   *\n   * @static\n   * @memberOf _\n   * @since 4.12.0\n   * @category Lang\n   * @param {*} value The value to convert.\n   * @returns {number} Returns the converted number.\n   * @example\n   *\n   * _.toFinite(3.2);\n   * // => 3.2\n   *\n   * _.toFinite(Number.MIN_VALUE);\n   * // => 5e-324\n   *\n   * _.toFinite(Infinity);\n   * // => 1.7976931348623157e+308\n   *\n   * _.toFinite('3.2');\n   * // => 3.2\n   */\n  function toFinite(value) {\n    if (!value) {\n      return value === 0 ? value : 0\n    }\n    value = toNumber(value)\n    if (value === INFINITY$2 || value === -INFINITY$2) {\n      var sign = value < 0 ? -1 : 1\n      return sign * MAX_INTEGER\n    }\n    return value === value ? value : 0\n  }\n\n  /**\n   * Converts `value` to an integer.\n   *\n   * **Note:** This method is loosely based on\n   * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).\n   *\n   * @static\n   * @memberOf _\n   * @since 4.0.0\n   * @category Lang\n   * @param {*} value The value to convert.\n   * @returns {number} Returns the converted integer.\n   * @example\n   *\n   * _.toInteger(3.2);\n   * // => 3\n   *\n   * _.toInteger(Number.MIN_VALUE);\n   * // => 0\n   *\n   * _.toInteger(Infinity);\n   * // => 1.7976931348623157e+308\n   *\n   * _.toInteger('3.2');\n   * // => 3\n   */\n  function toInteger(value) {\n    var result = toFinite(value),\n      remainder = result % 1\n\n    return result === result ? (remainder ? result - remainder : result) : 0\n  }\n\n  /**\n   * This method returns the first argument it receives.\n   *\n   * @static\n   * @since 0.1.0\n   * @memberOf _\n   * @category Util\n   * @param {*} value Any value.\n   * @returns {*} Returns `value`.\n   * @example\n   *\n   * var object = { 'a': 1 };\n   *\n   * console.log(_.identity(object) === object);\n   * // => true\n   */\n  function identity(value) {\n    return value\n  }\n\n  /** `Object#toString` result references. */\n  var asyncTag = '[object AsyncFunction]',\n    funcTag$2 = '[object Function]',\n    genTag$1 = '[object GeneratorFunction]',\n    proxyTag = '[object Proxy]'\n\n  /**\n   * Checks if `value` is classified as a `Function` object.\n   *\n   * @static\n   * @memberOf _\n   * @since 0.1.0\n   * @category Lang\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is a function, else `false`.\n   * @example\n   *\n   * _.isFunction(_);\n   * // => true\n   *\n   * _.isFunction(/abc/);\n   * // => false\n   */\n  function isFunction(value) {\n    if (!isObject(value)) {\n      return false\n    }\n    // The use of `Object#toString` avoids issues with the `typeof` operator\n    // in Safari 9 which returns 'object' for typed arrays and other constructors.\n    var tag = baseGetTag(value)\n    return tag == funcTag$2 || tag == genTag$1 || tag == asyncTag || tag == proxyTag\n  }\n\n  /** Used to detect overreaching core-js shims. */\n  var coreJsData = root$1['__core-js_shared__']\n\n  const coreJsData$1 = coreJsData\n\n  /** Used to detect methods masquerading as native. */\n  var maskSrcKey = (function () {\n    var uid = /[^.]+$/.exec((coreJsData$1 && coreJsData$1.keys && coreJsData$1.keys.IE_PROTO) || '')\n    return uid ? 'Symbol(src)_1.' + uid : ''\n  })()\n\n  /**\n   * Checks if `func` has its source masked.\n   *\n   * @private\n   * @param {Function} func The function to check.\n   * @returns {boolean} Returns `true` if `func` is masked, else `false`.\n   */\n  function isMasked(func) {\n    return !!maskSrcKey && maskSrcKey in func\n  }\n\n  /** Used for built-in method references. */\n  var funcProto$1 = Function.prototype\n\n  /** Used to resolve the decompiled source of functions. */\n  var funcToString$1 = funcProto$1.toString\n\n  /**\n   * Converts `func` to its source code.\n   *\n   * @private\n   * @param {Function} func The function to convert.\n   * @returns {string} Returns the source code.\n   */\n  function toSource(func) {\n    if (func != null) {\n      try {\n        return funcToString$1.call(func)\n      } catch (e) {}\n      try {\n        return func + ''\n      } catch (e) {}\n    }\n    return ''\n  }\n\n  /**\n   * Used to match `RegExp`\n   * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).\n   */\n  var reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g\n\n  /** Used to detect host constructors (Safari). */\n  var reIsHostCtor = /^\\[object .+?Constructor\\]$/\n\n  /** Used for built-in method references. */\n  var funcProto = Function.prototype,\n    objectProto$h = Object.prototype\n\n  /** Used to resolve the decompiled source of functions. */\n  var funcToString = funcProto.toString\n\n  /** Used to check objects for own properties. */\n  var hasOwnProperty$f = objectProto$h.hasOwnProperty\n\n  /** Used to detect if a method is native. */\n  var reIsNative = RegExp(\n    '^' +\n      funcToString\n        .call(hasOwnProperty$f)\n        .replace(reRegExpChar, '\\\\$&')\n        .replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') +\n      '$',\n  )\n\n  /**\n   * The base implementation of `_.isNative` without bad shim checks.\n   *\n   * @private\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is a native function,\n   *  else `false`.\n   */\n  function baseIsNative(value) {\n    if (!isObject(value) || isMasked(value)) {\n      return false\n    }\n    var pattern = isFunction(value) ? reIsNative : reIsHostCtor\n    return pattern.test(toSource(value))\n  }\n\n  /**\n   * Gets the value at `key` of `object`.\n   *\n   * @private\n   * @param {Object} [object] The object to query.\n   * @param {string} key The key of the property to get.\n   * @returns {*} Returns the property value.\n   */\n  function getValue(object, key) {\n    return object == null ? undefined : object[key]\n  }\n\n  /**\n   * Gets the native function at `key` of `object`.\n   *\n   * @private\n   * @param {Object} object The object to query.\n   * @param {string} key The key of the method to get.\n   * @returns {*} Returns the function if it's native, else `undefined`.\n   */\n  function getNative(object, key) {\n    var value = getValue(object, key)\n    return baseIsNative(value) ? value : undefined\n  }\n\n  /* Built-in method references that are verified to be native. */\n  var WeakMap = getNative(root$1, 'WeakMap')\n\n  const WeakMap$1 = WeakMap\n\n  /** Built-in value references. */\n  var objectCreate = Object.create\n\n  /**\n   * The base implementation of `_.create` without support for assigning\n   * properties to the created object.\n   *\n   * @private\n   * @param {Object} proto The object to inherit from.\n   * @returns {Object} Returns the new object.\n   */\n  var baseCreate = (function () {\n    function object() {}\n    return function (proto) {\n      if (!isObject(proto)) {\n        return {}\n      }\n      if (objectCreate) {\n        return objectCreate(proto)\n      }\n      object.prototype = proto\n      var result = new object()\n      object.prototype = undefined\n      return result\n    }\n  })()\n\n  const baseCreate$1 = baseCreate\n\n  /**\n   * A faster alternative to `Function#apply`, this function invokes `func`\n   * with the `this` binding of `thisArg` and the arguments of `args`.\n   *\n   * @private\n   * @param {Function} func The function to invoke.\n   * @param {*} thisArg The `this` binding of `func`.\n   * @param {Array} args The arguments to invoke `func` with.\n   * @returns {*} Returns the result of `func`.\n   */\n  function apply(func, thisArg, args) {\n    switch (args.length) {\n      case 0:\n        return func.call(thisArg)\n      case 1:\n        return func.call(thisArg, args[0])\n      case 2:\n        return func.call(thisArg, args[0], args[1])\n      case 3:\n        return func.call(thisArg, args[0], args[1], args[2])\n    }\n    return func.apply(thisArg, args)\n  }\n\n  /**\n   * This method returns `undefined`.\n   *\n   * @static\n   * @memberOf _\n   * @since 2.3.0\n   * @category Util\n   * @example\n   *\n   * _.times(2, _.noop);\n   * // => [undefined, undefined]\n   */\n  function noop() {\n    // No operation performed.\n  }\n\n  /**\n   * Copies the values of `source` to `array`.\n   *\n   * @private\n   * @param {Array} source The array to copy values from.\n   * @param {Array} [array=[]] The array to copy values to.\n   * @returns {Array} Returns `array`.\n   */\n  function copyArray(source, array) {\n    var index = -1,\n      length = source.length\n\n    array || (array = Array(length))\n    while (++index < length) {\n      array[index] = source[index]\n    }\n    return array\n  }\n\n  /** Used to detect hot functions by number of calls within a span of milliseconds. */\n  var HOT_COUNT = 800,\n    HOT_SPAN = 16\n\n  /* Built-in method references for those with the same name as other `lodash` methods. */\n  var nativeNow = Date.now\n\n  /**\n   * Creates a function that'll short out and invoke `identity` instead\n   * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`\n   * milliseconds.\n   *\n   * @private\n   * @param {Function} func The function to restrict.\n   * @returns {Function} Returns the new shortable function.\n   */\n  function shortOut(func) {\n    var count = 0,\n      lastCalled = 0\n\n    return function () {\n      var stamp = nativeNow(),\n        remaining = HOT_SPAN - (stamp - lastCalled)\n\n      lastCalled = stamp\n      if (remaining > 0) {\n        if (++count >= HOT_COUNT) {\n          return arguments[0]\n        }\n      } else {\n        count = 0\n      }\n      return func.apply(undefined, arguments)\n    }\n  }\n\n  /**\n   * Creates a function that returns `value`.\n   *\n   * @static\n   * @memberOf _\n   * @since 2.4.0\n   * @category Util\n   * @param {*} value The value to return from the new function.\n   * @returns {Function} Returns the new constant function.\n   * @example\n   *\n   * var objects = _.times(2, _.constant({ 'a': 1 }));\n   *\n   * console.log(objects);\n   * // => [{ 'a': 1 }, { 'a': 1 }]\n   *\n   * console.log(objects[0] === objects[1]);\n   * // => true\n   */\n  function constant(value) {\n    return function () {\n      return value\n    }\n  }\n\n  var defineProperty = (function () {\n    try {\n      var func = getNative(Object, 'defineProperty')\n      func({}, '', {})\n      return func\n    } catch (e) {}\n  })()\n\n  const defineProperty$1 = defineProperty\n\n  /**\n   * The base implementation of `setToString` without support for hot loop shorting.\n   *\n   * @private\n   * @param {Function} func The function to modify.\n   * @param {Function} string The `toString` result.\n   * @returns {Function} Returns `func`.\n   */\n  var baseSetToString = !defineProperty$1\n    ? identity\n    : function (func, string) {\n        return defineProperty$1(func, 'toString', {\n          configurable: true,\n          enumerable: false,\n          value: constant(string),\n          writable: true,\n        })\n      }\n\n  const baseSetToString$1 = baseSetToString\n\n  /**\n   * Sets the `toString` method of `func` to return `string`.\n   *\n   * @private\n   * @param {Function} func The function to modify.\n   * @param {Function} string The `toString` result.\n   * @returns {Function} Returns `func`.\n   */\n  var setToString = shortOut(baseSetToString$1)\n\n  const setToString$1 = setToString\n\n  /**\n   * A specialized version of `_.forEach` for arrays without support for\n   * iteratee shorthands.\n   *\n   * @private\n   * @param {Array} [array] The array to iterate over.\n   * @param {Function} iteratee The function invoked per iteration.\n   * @returns {Array} Returns `array`.\n   */\n  function arrayEach(array, iteratee) {\n    var index = -1,\n      length = array == null ? 0 : array.length\n\n    while (++index < length) {\n      if (iteratee(array[index], index, array) === false) {\n        break\n      }\n    }\n    return array\n  }\n\n  /**\n   * The base implementation of `_.findIndex` and `_.findLastIndex` without\n   * support for iteratee shorthands.\n   *\n   * @private\n   * @param {Array} array The array to inspect.\n   * @param {Function} predicate The function invoked per iteration.\n   * @param {number} fromIndex The index to search from.\n   * @param {boolean} [fromRight] Specify iterating from right to left.\n   * @returns {number} Returns the index of the matched value, else `-1`.\n   */\n  function baseFindIndex(array, predicate, fromIndex, fromRight) {\n    var length = array.length,\n      index = fromIndex + (fromRight ? 1 : -1)\n\n    while (fromRight ? index-- : ++index < length) {\n      if (predicate(array[index], index, array)) {\n        return index\n      }\n    }\n    return -1\n  }\n\n  /**\n   * The base implementation of `_.isNaN` without support for number objects.\n   *\n   * @private\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.\n   */\n  function baseIsNaN(value) {\n    return value !== value\n  }\n\n  /**\n   * A specialized version of `_.indexOf` which performs strict equality\n   * comparisons of values, i.e. `===`.\n   *\n   * @private\n   * @param {Array} array The array to inspect.\n   * @param {*} value The value to search for.\n   * @param {number} fromIndex The index to search from.\n   * @returns {number} Returns the index of the matched value, else `-1`.\n   */\n  function strictIndexOf(array, value, fromIndex) {\n    var index = fromIndex - 1,\n      length = array.length\n\n    while (++index < length) {\n      if (array[index] === value) {\n        return index\n      }\n    }\n    return -1\n  }\n\n  /**\n   * The base implementation of `_.indexOf` without `fromIndex` bounds checks.\n   *\n   * @private\n   * @param {Array} array The array to inspect.\n   * @param {*} value The value to search for.\n   * @param {number} fromIndex The index to search from.\n   * @returns {number} Returns the index of the matched value, else `-1`.\n   */\n  function baseIndexOf(array, value, fromIndex) {\n    return value === value ? strictIndexOf(array, value, fromIndex) : baseFindIndex(array, baseIsNaN, fromIndex)\n  }\n\n  /**\n   * A specialized version of `_.includes` for arrays without support for\n   * specifying an index to search from.\n   *\n   * @private\n   * @param {Array} [array] The array to inspect.\n   * @param {*} target The value to search for.\n   * @returns {boolean} Returns `true` if `target` is found, else `false`.\n   */\n  function arrayIncludes(array, value) {\n    var length = array == null ? 0 : array.length\n    return !!length && baseIndexOf(array, value, 0) > -1\n  }\n\n  /** Used as references for various `Number` constants. */\n  var MAX_SAFE_INTEGER$1 = 9007199254740991\n\n  /** Used to detect unsigned integer values. */\n  var reIsUint = /^(?:0|[1-9]\\d*)$/\n\n  /**\n   * Checks if `value` is a valid array-like index.\n   *\n   * @private\n   * @param {*} value The value to check.\n   * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.\n   * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.\n   */\n  function isIndex(value, length) {\n    var type = typeof value\n    length = length == null ? MAX_SAFE_INTEGER$1 : length\n\n    return (\n      !!length &&\n      (type == 'number' || (type != 'symbol' && reIsUint.test(value))) &&\n      value > -1 &&\n      value % 1 == 0 &&\n      value < length\n    )\n  }\n\n  /**\n   * The base implementation of `assignValue` and `assignMergeValue` without\n   * value checks.\n   *\n   * @private\n   * @param {Object} object The object to modify.\n   * @param {string} key The key of the property to assign.\n   * @param {*} value The value to assign.\n   */\n  function baseAssignValue(object, key, value) {\n    if (key == '__proto__' && defineProperty$1) {\n      defineProperty$1(object, key, {\n        configurable: true,\n        enumerable: true,\n        value: value,\n        writable: true,\n      })\n    } else {\n      object[key] = value\n    }\n  }\n\n  /**\n   * Performs a\n   * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n   * comparison between two values to determine if they are equivalent.\n   *\n   * @static\n   * @memberOf _\n   * @since 4.0.0\n   * @category Lang\n   * @param {*} value The value to compare.\n   * @param {*} other The other value to compare.\n   * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n   * @example\n   *\n   * var object = { 'a': 1 };\n   * var other = { 'a': 1 };\n   *\n   * _.eq(object, object);\n   * // => true\n   *\n   * _.eq(object, other);\n   * // => false\n   *\n   * _.eq('a', 'a');\n   * // => true\n   *\n   * _.eq('a', Object('a'));\n   * // => false\n   *\n   * _.eq(NaN, NaN);\n   * // => true\n   */\n  function eq(value, other) {\n    return value === other || (value !== value && other !== other)\n  }\n\n  /** Used for built-in method references. */\n  var objectProto$g = Object.prototype\n\n  /** Used to check objects for own properties. */\n  var hasOwnProperty$e = objectProto$g.hasOwnProperty\n\n  /**\n   * Assigns `value` to `key` of `object` if the existing value is not equivalent\n   * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n   * for equality comparisons.\n   *\n   * @private\n   * @param {Object} object The object to modify.\n   * @param {string} key The key of the property to assign.\n   * @param {*} value The value to assign.\n   */\n  function assignValue(object, key, value) {\n    var objValue = object[key]\n    if (!(hasOwnProperty$e.call(object, key) && eq(objValue, value)) || (value === undefined && !(key in object))) {\n      baseAssignValue(object, key, value)\n    }\n  }\n\n  /**\n   * Copies properties of `source` to `object`.\n   *\n   * @private\n   * @param {Object} source The object to copy properties from.\n   * @param {Array} props The property identifiers to copy.\n   * @param {Object} [object={}] The object to copy properties to.\n   * @param {Function} [customizer] The function to customize copied values.\n   * @returns {Object} Returns `object`.\n   */\n  function copyObject(source, props, object, customizer) {\n    var isNew = !object\n    object || (object = {})\n\n    var index = -1,\n      length = props.length\n\n    while (++index < length) {\n      var key = props[index]\n\n      var newValue = customizer ? customizer(object[key], source[key], key, object, source) : undefined\n\n      if (newValue === undefined) {\n        newValue = source[key]\n      }\n      if (isNew) {\n        baseAssignValue(object, key, newValue)\n      } else {\n        assignValue(object, key, newValue)\n      }\n    }\n    return object\n  }\n\n  /* Built-in method references for those with the same name as other `lodash` methods. */\n  var nativeMax$3 = Math.max\n\n  /**\n   * A specialized version of `baseRest` which transforms the rest array.\n   *\n   * @private\n   * @param {Function} func The function to apply a rest parameter to.\n   * @param {number} [start=func.length-1] The start position of the rest parameter.\n   * @param {Function} transform The rest array transform.\n   * @returns {Function} Returns the new function.\n   */\n  function overRest(func, start, transform) {\n    start = nativeMax$3(start === undefined ? func.length - 1 : start, 0)\n    return function () {\n      var args = arguments,\n        index = -1,\n        length = nativeMax$3(args.length - start, 0),\n        array = Array(length)\n\n      while (++index < length) {\n        array[index] = args[start + index]\n      }\n      index = -1\n      var otherArgs = Array(start + 1)\n      while (++index < start) {\n        otherArgs[index] = args[index]\n      }\n      otherArgs[start] = transform(array)\n      return apply(func, this, otherArgs)\n    }\n  }\n\n  /**\n   * The base implementation of `_.rest` which doesn't validate or coerce arguments.\n   *\n   * @private\n   * @param {Function} func The function to apply a rest parameter to.\n   * @param {number} [start=func.length-1] The start position of the rest parameter.\n   * @returns {Function} Returns the new function.\n   */\n  function baseRest(func, start) {\n    return setToString$1(overRest(func, start, identity), func + '')\n  }\n\n  /** Used as references for various `Number` constants. */\n  var MAX_SAFE_INTEGER = 9007199254740991\n\n  /**\n   * Checks if `value` is a valid array-like length.\n   *\n   * **Note:** This method is loosely based on\n   * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).\n   *\n   * @static\n   * @memberOf _\n   * @since 4.0.0\n   * @category Lang\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.\n   * @example\n   *\n   * _.isLength(3);\n   * // => true\n   *\n   * _.isLength(Number.MIN_VALUE);\n   * // => false\n   *\n   * _.isLength(Infinity);\n   * // => false\n   *\n   * _.isLength('3');\n   * // => false\n   */\n  function isLength(value) {\n    return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER\n  }\n\n  /**\n   * Checks if `value` is array-like. A value is considered array-like if it's\n   * not a function and has a `value.length` that's an integer greater than or\n   * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.\n   *\n   * @static\n   * @memberOf _\n   * @since 4.0.0\n   * @category Lang\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is array-like, else `false`.\n   * @example\n   *\n   * _.isArrayLike([1, 2, 3]);\n   * // => true\n   *\n   * _.isArrayLike(document.body.children);\n   * // => true\n   *\n   * _.isArrayLike('abc');\n   * // => true\n   *\n   * _.isArrayLike(_.noop);\n   * // => false\n   */\n  function isArrayLike(value) {\n    return value != null && isLength(value.length) && !isFunction(value)\n  }\n\n  /**\n   * Checks if the given arguments are from an iteratee call.\n   *\n   * @private\n   * @param {*} value The potential iteratee value argument.\n   * @param {*} index The potential iteratee index or key argument.\n   * @param {*} object The potential iteratee object argument.\n   * @returns {boolean} Returns `true` if the arguments are from an iteratee call,\n   *  else `false`.\n   */\n  function isIterateeCall(value, index, object) {\n    if (!isObject(object)) {\n      return false\n    }\n    var type = typeof index\n    if (type == 'number' ? isArrayLike(object) && isIndex(index, object.length) : type == 'string' && index in object) {\n      return eq(object[index], value)\n    }\n    return false\n  }\n\n  /**\n   * Creates a function like `_.assign`.\n   *\n   * @private\n   * @param {Function} assigner The function to assign values.\n   * @returns {Function} Returns the new assigner function.\n   */\n  function createAssigner(assigner) {\n    return baseRest(function (object, sources) {\n      var index = -1,\n        length = sources.length,\n        customizer = length > 1 ? sources[length - 1] : undefined,\n        guard = length > 2 ? sources[2] : undefined\n\n      customizer = assigner.length > 3 && typeof customizer == 'function' ? (length--, customizer) : undefined\n\n      if (guard && isIterateeCall(sources[0], sources[1], guard)) {\n        customizer = length < 3 ? undefined : customizer\n        length = 1\n      }\n      object = Object(object)\n      while (++index < length) {\n        var source = sources[index]\n        if (source) {\n          assigner(object, source, index, customizer)\n        }\n      }\n      return object\n    })\n  }\n\n  /** Used for built-in method references. */\n  var objectProto$f = Object.prototype\n\n  /**\n   * Checks if `value` is likely a prototype object.\n   *\n   * @private\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.\n   */\n  function isPrototype(value) {\n    var Ctor = value && value.constructor,\n      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto$f\n\n    return value === proto\n  }\n\n  /**\n   * The base implementation of `_.times` without support for iteratee shorthands\n   * or max array length checks.\n   *\n   * @private\n   * @param {number} n The number of times to invoke `iteratee`.\n   * @param {Function} iteratee The function invoked per iteration.\n   * @returns {Array} Returns the array of results.\n   */\n  function baseTimes(n, iteratee) {\n    var index = -1,\n      result = Array(n)\n\n    while (++index < n) {\n      result[index] = iteratee(index)\n    }\n    return result\n  }\n\n  /** `Object#toString` result references. */\n  var argsTag$3 = '[object Arguments]'\n\n  /**\n   * The base implementation of `_.isArguments`.\n   *\n   * @private\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n   */\n  function baseIsArguments(value) {\n    return isObjectLike(value) && baseGetTag(value) == argsTag$3\n  }\n\n  /** Used for built-in method references. */\n  var objectProto$e = Object.prototype\n\n  /** Used to check objects for own properties. */\n  var hasOwnProperty$d = objectProto$e.hasOwnProperty\n\n  /** Built-in value references. */\n  var propertyIsEnumerable$1 = objectProto$e.propertyIsEnumerable\n\n  /**\n   * Checks if `value` is likely an `arguments` object.\n   *\n   * @static\n   * @memberOf _\n   * @since 0.1.0\n   * @category Lang\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n   *  else `false`.\n   * @example\n   *\n   * _.isArguments(function() { return arguments; }());\n   * // => true\n   *\n   * _.isArguments([1, 2, 3]);\n   * // => false\n   */\n  var isArguments = baseIsArguments(\n    (function () {\n      return arguments\n    })(),\n  )\n    ? baseIsArguments\n    : function (value) {\n        return (\n          isObjectLike(value) && hasOwnProperty$d.call(value, 'callee') && !propertyIsEnumerable$1.call(value, 'callee')\n        )\n      }\n\n  const isArguments$1 = isArguments\n\n  /**\n   * This method returns `false`.\n   *\n   * @static\n   * @memberOf _\n   * @since 4.13.0\n   * @category Util\n   * @returns {boolean} Returns `false`.\n   * @example\n   *\n   * _.times(2, _.stubFalse);\n   * // => [false, false]\n   */\n  function stubFalse() {\n    return false\n  }\n\n  /** Detect free variable `exports`. */\n  var freeExports$2 = typeof exports == 'object' && exports && !exports.nodeType && exports\n\n  /** Detect free variable `module`. */\n  var freeModule$2 = freeExports$2 && typeof module == 'object' && module && !module.nodeType && module\n\n  /** Detect the popular CommonJS extension `module.exports`. */\n  var moduleExports$2 = freeModule$2 && freeModule$2.exports === freeExports$2\n\n  /** Built-in value references. */\n  var Buffer$1 = moduleExports$2 ? root$1.Buffer : undefined\n\n  /* Built-in method references for those with the same name as other `lodash` methods. */\n  var nativeIsBuffer = Buffer$1 ? Buffer$1.isBuffer : undefined\n\n  /**\n   * Checks if `value` is a buffer.\n   *\n   * @static\n   * @memberOf _\n   * @since 4.3.0\n   * @category Lang\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.\n   * @example\n   *\n   * _.isBuffer(new Buffer(2));\n   * // => true\n   *\n   * _.isBuffer(new Uint8Array(2));\n   * // => false\n   */\n  var isBuffer = nativeIsBuffer || stubFalse\n\n  const isBuffer$1 = isBuffer\n\n  /** `Object#toString` result references. */\n  var argsTag$2 = '[object Arguments]',\n    arrayTag$2 = '[object Array]',\n    boolTag$3 = '[object Boolean]',\n    dateTag$3 = '[object Date]',\n    errorTag$2 = '[object Error]',\n    funcTag$1 = '[object Function]',\n    mapTag$6 = '[object Map]',\n    numberTag$3 = '[object Number]',\n    objectTag$3 = '[object Object]',\n    regexpTag$4 = '[object RegExp]',\n    setTag$6 = '[object Set]',\n    stringTag$4 = '[object String]',\n    weakMapTag$2 = '[object WeakMap]'\n\n  var arrayBufferTag$3 = '[object ArrayBuffer]',\n    dataViewTag$4 = '[object DataView]',\n    float32Tag$2 = '[object Float32Array]',\n    float64Tag$2 = '[object Float64Array]',\n    int8Tag$2 = '[object Int8Array]',\n    int16Tag$2 = '[object Int16Array]',\n    int32Tag$2 = '[object Int32Array]',\n    uint8Tag$2 = '[object Uint8Array]',\n    uint8ClampedTag$2 = '[object Uint8ClampedArray]',\n    uint16Tag$2 = '[object Uint16Array]',\n    uint32Tag$2 = '[object Uint32Array]'\n\n  /** Used to identify `toStringTag` values of typed arrays. */\n  var typedArrayTags = {}\n  typedArrayTags[float32Tag$2] = typedArrayTags[float64Tag$2] = typedArrayTags[int8Tag$2] = typedArrayTags[\n    int16Tag$2\n  ] = typedArrayTags[int32Tag$2] = typedArrayTags[uint8Tag$2] = typedArrayTags[uint8ClampedTag$2] = typedArrayTags[\n    uint16Tag$2\n  ] = typedArrayTags[uint32Tag$2] = true\n  typedArrayTags[argsTag$2] = typedArrayTags[arrayTag$2] = typedArrayTags[arrayBufferTag$3] = typedArrayTags[\n    boolTag$3\n  ] = typedArrayTags[dataViewTag$4] = typedArrayTags[dateTag$3] = typedArrayTags[errorTag$2] = typedArrayTags[\n    funcTag$1\n  ] = typedArrayTags[mapTag$6] = typedArrayTags[numberTag$3] = typedArrayTags[objectTag$3] = typedArrayTags[\n    regexpTag$4\n  ] = typedArrayTags[setTag$6] = typedArrayTags[stringTag$4] = typedArrayTags[weakMapTag$2] = false\n\n  /**\n   * The base implementation of `_.isTypedArray` without Node.js optimizations.\n   *\n   * @private\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n   */\n  function baseIsTypedArray(value) {\n    return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)]\n  }\n\n  /**\n   * The base implementation of `_.unary` without support for storing metadata.\n   *\n   * @private\n   * @param {Function} func The function to cap arguments for.\n   * @returns {Function} Returns the new capped function.\n   */\n  function baseUnary(func) {\n    return function (value) {\n      return func(value)\n    }\n  }\n\n  /** Detect free variable `exports`. */\n  var freeExports$1 = typeof exports == 'object' && exports && !exports.nodeType && exports\n\n  /** Detect free variable `module`. */\n  var freeModule$1 = freeExports$1 && typeof module == 'object' && module && !module.nodeType && module\n\n  /** Detect the popular CommonJS extension `module.exports`. */\n  var moduleExports$1 = freeModule$1 && freeModule$1.exports === freeExports$1\n\n  /** Detect free variable `process` from Node.js. */\n  var freeProcess = moduleExports$1 && freeGlobal$1.process\n\n  /** Used to access faster Node.js helpers. */\n  var nodeUtil = (function () {\n    try {\n      // Use `util.types` for Node.js 10+.\n      var types = freeModule$1 && freeModule$1.require && freeModule$1.require('util').types\n\n      if (types) {\n        return types\n      }\n\n      // Legacy `process.binding('util')` for Node.js < 10.\n      return freeProcess && freeProcess.binding && freeProcess.binding('util')\n    } catch (e) {}\n  })()\n\n  const nodeUtil$1 = nodeUtil\n\n  /* Node.js helper references. */\n  var nodeIsTypedArray = nodeUtil$1 && nodeUtil$1.isTypedArray\n\n  /**\n   * Checks if `value` is classified as a typed array.\n   *\n   * @static\n   * @memberOf _\n   * @since 3.0.0\n   * @category Lang\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n   * @example\n   *\n   * _.isTypedArray(new Uint8Array);\n   * // => true\n   *\n   * _.isTypedArray([]);\n   * // => false\n   */\n  var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray\n\n  const isTypedArray$1 = isTypedArray\n\n  /** Used for built-in method references. */\n  var objectProto$d = Object.prototype\n\n  /** Used to check objects for own properties. */\n  var hasOwnProperty$c = objectProto$d.hasOwnProperty\n\n  /**\n   * Creates an array of the enumerable property names of the array-like `value`.\n   *\n   * @private\n   * @param {*} value The value to query.\n   * @param {boolean} inherited Specify returning inherited property names.\n   * @returns {Array} Returns the array of property names.\n   */\n  function arrayLikeKeys(value, inherited) {\n    var isArr = isArray$1(value),\n      isArg = !isArr && isArguments$1(value),\n      isBuff = !isArr && !isArg && isBuffer$1(value),\n      isType = !isArr && !isArg && !isBuff && isTypedArray$1(value),\n      skipIndexes = isArr || isArg || isBuff || isType,\n      result = skipIndexes ? baseTimes(value.length, String) : [],\n      length = result.length\n\n    for (var key in value) {\n      if (\n        (inherited || hasOwnProperty$c.call(value, key)) &&\n        !(\n          skipIndexes &&\n          // Safari 9 has enumerable `arguments.length` in strict mode.\n          (key == 'length' ||\n            // Node.js 0.10 has enumerable non-index properties on buffers.\n            (isBuff && (key == 'offset' || key == 'parent')) ||\n            // PhantomJS 2 has enumerable non-index properties on typed arrays.\n            (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||\n            // Skip index properties.\n            isIndex(key, length))\n        )\n      ) {\n        result.push(key)\n      }\n    }\n    return result\n  }\n\n  /**\n   * Creates a unary function that invokes `func` with its argument transformed.\n   *\n   * @private\n   * @param {Function} func The function to wrap.\n   * @param {Function} transform The argument transform.\n   * @returns {Function} Returns the new function.\n   */\n  function overArg(func, transform) {\n    return function (arg) {\n      return func(transform(arg))\n    }\n  }\n\n  /* Built-in method references for those with the same name as other `lodash` methods. */\n  var nativeKeys = overArg(Object.keys, Object)\n\n  const nativeKeys$1 = nativeKeys\n\n  /** Used for built-in method references. */\n  var objectProto$c = Object.prototype\n\n  /** Used to check objects for own properties. */\n  var hasOwnProperty$b = objectProto$c.hasOwnProperty\n\n  /**\n   * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.\n   *\n   * @private\n   * @param {Object} object The object to query.\n   * @returns {Array} Returns the array of property names.\n   */\n  function baseKeys(object) {\n    if (!isPrototype(object)) {\n      return nativeKeys$1(object)\n    }\n    var result = []\n    for (var key in Object(object)) {\n      if (hasOwnProperty$b.call(object, key) && key != 'constructor') {\n        result.push(key)\n      }\n    }\n    return result\n  }\n\n  /**\n   * Creates an array of the own enumerable property names of `object`.\n   *\n   * **Note:** Non-object values are coerced to objects. See the\n   * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)\n   * for more details.\n   *\n   * @static\n   * @since 0.1.0\n   * @memberOf _\n   * @category Object\n   * @param {Object} object The object to query.\n   * @returns {Array} Returns the array of property names.\n   * @example\n   *\n   * function Foo() {\n   *   this.a = 1;\n   *   this.b = 2;\n   * }\n   *\n   * Foo.prototype.c = 3;\n   *\n   * _.keys(new Foo);\n   * // => ['a', 'b'] (iteration order is not guaranteed)\n   *\n   * _.keys('hi');\n   * // => ['0', '1']\n   */\n  function keys(object) {\n    return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object)\n  }\n\n  /** Used for built-in method references. */\n  var objectProto$b = Object.prototype\n\n  /** Used to check objects for own properties. */\n  var hasOwnProperty$a = objectProto$b.hasOwnProperty\n\n  /**\n   * Assigns own enumerable string keyed properties of source objects to the\n   * destination object. Source objects are applied from left to right.\n   * Subsequent sources overwrite property assignments of previous sources.\n   *\n   * **Note:** This method mutates `object` and is loosely based on\n   * [`Object.assign`](https://mdn.io/Object/assign).\n   *\n   * @static\n   * @memberOf _\n   * @since 0.10.0\n   * @category Object\n   * @param {Object} object The destination object.\n   * @param {...Object} [sources] The source objects.\n   * @returns {Object} Returns `object`.\n   * @see _.assignIn\n   * @example\n   *\n   * function Foo() {\n   *   this.a = 1;\n   * }\n   *\n   * function Bar() {\n   *   this.c = 3;\n   * }\n   *\n   * Foo.prototype.b = 2;\n   * Bar.prototype.d = 4;\n   *\n   * _.assign({ 'a': 0 }, new Foo, new Bar);\n   * // => { 'a': 1, 'c': 3 }\n   */\n  var assign = createAssigner(function (object, source) {\n    if (isPrototype(source) || isArrayLike(source)) {\n      copyObject(source, keys(source), object)\n      return\n    }\n    for (var key in source) {\n      if (hasOwnProperty$a.call(source, key)) {\n        assignValue(object, key, source[key])\n      }\n    }\n  })\n\n  const assign$1 = assign\n\n  /**\n   * This function is like\n   * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)\n   * except that it includes inherited enumerable properties.\n   *\n   * @private\n   * @param {Object} object The object to query.\n   * @returns {Array} Returns the array of property names.\n   */\n  function nativeKeysIn(object) {\n    var result = []\n    if (object != null) {\n      for (var key in Object(object)) {\n        result.push(key)\n      }\n    }\n    return result\n  }\n\n  /** Used for built-in method references. */\n  var objectProto$a = Object.prototype\n\n  /** Used to check objects for own properties. */\n  var hasOwnProperty$9 = objectProto$a.hasOwnProperty\n\n  /**\n   * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.\n   *\n   * @private\n   * @param {Object} object The object to query.\n   * @returns {Array} Returns the array of property names.\n   */\n  function baseKeysIn(object) {\n    if (!isObject(object)) {\n      return nativeKeysIn(object)\n    }\n    var isProto = isPrototype(object),\n      result = []\n\n    for (var key in object) {\n      if (!(key == 'constructor' && (isProto || !hasOwnProperty$9.call(object, key)))) {\n        result.push(key)\n      }\n    }\n    return result\n  }\n\n  /**\n   * Creates an array of the own and inherited enumerable property names of `object`.\n   *\n   * **Note:** Non-object values are coerced to objects.\n   *\n   * @static\n   * @memberOf _\n   * @since 3.0.0\n   * @category Object\n   * @param {Object} object The object to query.\n   * @returns {Array} Returns the array of property names.\n   * @example\n   *\n   * function Foo() {\n   *   this.a = 1;\n   *   this.b = 2;\n   * }\n   *\n   * Foo.prototype.c = 3;\n   *\n   * _.keysIn(new Foo);\n   * // => ['a', 'b', 'c'] (iteration order is not guaranteed)\n   */\n  function keysIn(object) {\n    return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object)\n  }\n\n  /** Used to match property names within property paths. */\n  var reIsDeepProp = /\\.|\\[(?:[^[\\]]*|([\"'])(?:(?!\\1)[^\\\\]|\\\\.)*?\\1)\\]/,\n    reIsPlainProp = /^\\w*$/\n\n  /**\n   * Checks if `value` is a property name and not a property path.\n   *\n   * @private\n   * @param {*} value The value to check.\n   * @param {Object} [object] The object to query keys on.\n   * @returns {boolean} Returns `true` if `value` is a property name, else `false`.\n   */\n  function isKey(value, object) {\n    if (isArray$1(value)) {\n      return false\n    }\n    var type = typeof value\n    if (type == 'number' || type == 'symbol' || type == 'boolean' || value == null || isSymbol(value)) {\n      return true\n    }\n    return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || (object != null && value in Object(object))\n  }\n\n  /* Built-in method references that are verified to be native. */\n  var nativeCreate = getNative(Object, 'create')\n\n  const nativeCreate$1 = nativeCreate\n\n  /**\n   * Removes all key-value entries from the hash.\n   *\n   * @private\n   * @name clear\n   * @memberOf Hash\n   */\n  function hashClear() {\n    this.__data__ = nativeCreate$1 ? nativeCreate$1(null) : {}\n    this.size = 0\n  }\n\n  /**\n   * Removes `key` and its value from the hash.\n   *\n   * @private\n   * @name delete\n   * @memberOf Hash\n   * @param {Object} hash The hash to modify.\n   * @param {string} key The key of the value to remove.\n   * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n   */\n  function hashDelete(key) {\n    var result = this.has(key) && delete this.__data__[key]\n    this.size -= result ? 1 : 0\n    return result\n  }\n\n  /** Used to stand-in for `undefined` hash values. */\n  var HASH_UNDEFINED$2 = '__lodash_hash_undefined__'\n\n  /** Used for built-in method references. */\n  var objectProto$9 = Object.prototype\n\n  /** Used to check objects for own properties. */\n  var hasOwnProperty$8 = objectProto$9.hasOwnProperty\n\n  /**\n   * Gets the hash value for `key`.\n   *\n   * @private\n   * @name get\n   * @memberOf Hash\n   * @param {string} key The key of the value to get.\n   * @returns {*} Returns the entry value.\n   */\n  function hashGet(key) {\n    var data = this.__data__\n    if (nativeCreate$1) {\n      var result = data[key]\n      return result === HASH_UNDEFINED$2 ? undefined : result\n    }\n    return hasOwnProperty$8.call(data, key) ? data[key] : undefined\n  }\n\n  /** Used for built-in method references. */\n  var objectProto$8 = Object.prototype\n\n  /** Used to check objects for own properties. */\n  var hasOwnProperty$7 = objectProto$8.hasOwnProperty\n\n  /**\n   * Checks if a hash value for `key` exists.\n   *\n   * @private\n   * @name has\n   * @memberOf Hash\n   * @param {string} key The key of the entry to check.\n   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n   */\n  function hashHas(key) {\n    var data = this.__data__\n    return nativeCreate$1 ? data[key] !== undefined : hasOwnProperty$7.call(data, key)\n  }\n\n  /** Used to stand-in for `undefined` hash values. */\n  var HASH_UNDEFINED$1 = '__lodash_hash_undefined__'\n\n  /**\n   * Sets the hash `key` to `value`.\n   *\n   * @private\n   * @name set\n   * @memberOf Hash\n   * @param {string} key The key of the value to set.\n   * @param {*} value The value to set.\n   * @returns {Object} Returns the hash instance.\n   */\n  function hashSet(key, value) {\n    var data = this.__data__\n    this.size += this.has(key) ? 0 : 1\n    data[key] = nativeCreate$1 && value === undefined ? HASH_UNDEFINED$1 : value\n    return this\n  }\n\n  /**\n   * Creates a hash object.\n   *\n   * @private\n   * @constructor\n   * @param {Array} [entries] The key-value pairs to cache.\n   */\n  function Hash(entries) {\n    var index = -1,\n      length = entries == null ? 0 : entries.length\n\n    this.clear()\n    while (++index < length) {\n      var entry = entries[index]\n      this.set(entry[0], entry[1])\n    }\n  }\n\n  // Add methods to `Hash`.\n  Hash.prototype.clear = hashClear\n  Hash.prototype['delete'] = hashDelete\n  Hash.prototype.get = hashGet\n  Hash.prototype.has = hashHas\n  Hash.prototype.set = hashSet\n\n  /**\n   * Removes all key-value entries from the list cache.\n   *\n   * @private\n   * @name clear\n   * @memberOf ListCache\n   */\n  function listCacheClear() {\n    this.__data__ = []\n    this.size = 0\n  }\n\n  /**\n   * Gets the index at which the `key` is found in `array` of key-value pairs.\n   *\n   * @private\n   * @param {Array} array The array to inspect.\n   * @param {*} key The key to search for.\n   * @returns {number} Returns the index of the matched value, else `-1`.\n   */\n  function assocIndexOf(array, key) {\n    var length = array.length\n    while (length--) {\n      if (eq(array[length][0], key)) {\n        return length\n      }\n    }\n    return -1\n  }\n\n  /** Used for built-in method references. */\n  var arrayProto = Array.prototype\n\n  /** Built-in value references. */\n  var splice = arrayProto.splice\n\n  /**\n   * Removes `key` and its value from the list cache.\n   *\n   * @private\n   * @name delete\n   * @memberOf ListCache\n   * @param {string} key The key of the value to remove.\n   * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n   */\n  function listCacheDelete(key) {\n    var data = this.__data__,\n      index = assocIndexOf(data, key)\n\n    if (index < 0) {\n      return false\n    }\n    var lastIndex = data.length - 1\n    if (index == lastIndex) {\n      data.pop()\n    } else {\n      splice.call(data, index, 1)\n    }\n    --this.size\n    return true\n  }\n\n  /**\n   * Gets the list cache value for `key`.\n   *\n   * @private\n   * @name get\n   * @memberOf ListCache\n   * @param {string} key The key of the value to get.\n   * @returns {*} Returns the entry value.\n   */\n  function listCacheGet(key) {\n    var data = this.__data__,\n      index = assocIndexOf(data, key)\n\n    return index < 0 ? undefined : data[index][1]\n  }\n\n  /**\n   * Checks if a list cache value for `key` exists.\n   *\n   * @private\n   * @name has\n   * @memberOf ListCache\n   * @param {string} key The key of the entry to check.\n   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n   */\n  function listCacheHas(key) {\n    return assocIndexOf(this.__data__, key) > -1\n  }\n\n  /**\n   * Sets the list cache `key` to `value`.\n   *\n   * @private\n   * @name set\n   * @memberOf ListCache\n   * @param {string} key The key of the value to set.\n   * @param {*} value The value to set.\n   * @returns {Object} Returns the list cache instance.\n   */\n  function listCacheSet(key, value) {\n    var data = this.__data__,\n      index = assocIndexOf(data, key)\n\n    if (index < 0) {\n      ++this.size\n      data.push([key, value])\n    } else {\n      data[index][1] = value\n    }\n    return this\n  }\n\n  /**\n   * Creates an list cache object.\n   *\n   * @private\n   * @constructor\n   * @param {Array} [entries] The key-value pairs to cache.\n   */\n  function ListCache(entries) {\n    var index = -1,\n      length = entries == null ? 0 : entries.length\n\n    this.clear()\n    while (++index < length) {\n      var entry = entries[index]\n      this.set(entry[0], entry[1])\n    }\n  }\n\n  // Add methods to `ListCache`.\n  ListCache.prototype.clear = listCacheClear\n  ListCache.prototype['delete'] = listCacheDelete\n  ListCache.prototype.get = listCacheGet\n  ListCache.prototype.has = listCacheHas\n  ListCache.prototype.set = listCacheSet\n\n  /* Built-in method references that are verified to be native. */\n  var Map$1 = getNative(root$1, 'Map')\n\n  const Map$2 = Map$1\n\n  /**\n   * Removes all key-value entries from the map.\n   *\n   * @private\n   * @name clear\n   * @memberOf MapCache\n   */\n  function mapCacheClear() {\n    this.size = 0\n    this.__data__ = {\n      hash: new Hash(),\n      map: new (Map$2 || ListCache)(),\n      string: new Hash(),\n    }\n  }\n\n  /**\n   * Checks if `value` is suitable for use as unique object key.\n   *\n   * @private\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is suitable, else `false`.\n   */\n  function isKeyable(value) {\n    var type = typeof value\n    return type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean'\n      ? value !== '__proto__'\n      : value === null\n  }\n\n  /**\n   * Gets the data for `map`.\n   *\n   * @private\n   * @param {Object} map The map to query.\n   * @param {string} key The reference key.\n   * @returns {*} Returns the map data.\n   */\n  function getMapData(map, key) {\n    var data = map.__data__\n    return isKeyable(key) ? data[typeof key == 'string' ? 'string' : 'hash'] : data.map\n  }\n\n  /**\n   * Removes `key` and its value from the map.\n   *\n   * @private\n   * @name delete\n   * @memberOf MapCache\n   * @param {string} key The key of the value to remove.\n   * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n   */\n  function mapCacheDelete(key) {\n    var result = getMapData(this, key)['delete'](key)\n    this.size -= result ? 1 : 0\n    return result\n  }\n\n  /**\n   * Gets the map value for `key`.\n   *\n   * @private\n   * @name get\n   * @memberOf MapCache\n   * @param {string} key The key of the value to get.\n   * @returns {*} Returns the entry value.\n   */\n  function mapCacheGet(key) {\n    return getMapData(this, key).get(key)\n  }\n\n  /**\n   * Checks if a map value for `key` exists.\n   *\n   * @private\n   * @name has\n   * @memberOf MapCache\n   * @param {string} key The key of the entry to check.\n   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n   */\n  function mapCacheHas(key) {\n    return getMapData(this, key).has(key)\n  }\n\n  /**\n   * Sets the map `key` to `value`.\n   *\n   * @private\n   * @name set\n   * @memberOf MapCache\n   * @param {string} key The key of the value to set.\n   * @param {*} value The value to set.\n   * @returns {Object} Returns the map cache instance.\n   */\n  function mapCacheSet(key, value) {\n    var data = getMapData(this, key),\n      size = data.size\n\n    data.set(key, value)\n    this.size += data.size == size ? 0 : 1\n    return this\n  }\n\n  /**\n   * Creates a map cache object to store key-value pairs.\n   *\n   * @private\n   * @constructor\n   * @param {Array} [entries] The key-value pairs to cache.\n   */\n  function MapCache(entries) {\n    var index = -1,\n      length = entries == null ? 0 : entries.length\n\n    this.clear()\n    while (++index < length) {\n      var entry = entries[index]\n      this.set(entry[0], entry[1])\n    }\n  }\n\n  // Add methods to `MapCache`.\n  MapCache.prototype.clear = mapCacheClear\n  MapCache.prototype['delete'] = mapCacheDelete\n  MapCache.prototype.get = mapCacheGet\n  MapCache.prototype.has = mapCacheHas\n  MapCache.prototype.set = mapCacheSet\n\n  /** Error message constants. */\n  var FUNC_ERROR_TEXT$1 = 'Expected a function'\n\n  /**\n   * Creates a function that memoizes the result of `func`. If `resolver` is\n   * provided, it determines the cache key for storing the result based on the\n   * arguments provided to the memoized function. By default, the first argument\n   * provided to the memoized function is used as the map cache key. The `func`\n   * is invoked with the `this` binding of the memoized function.\n   *\n   * **Note:** The cache is exposed as the `cache` property on the memoized\n   * function. Its creation may be customized by replacing the `_.memoize.Cache`\n   * constructor with one whose instances implement the\n   * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)\n   * method interface of `clear`, `delete`, `get`, `has`, and `set`.\n   *\n   * @static\n   * @memberOf _\n   * @since 0.1.0\n   * @category Function\n   * @param {Function} func The function to have its output memoized.\n   * @param {Function} [resolver] The function to resolve the cache key.\n   * @returns {Function} Returns the new memoized function.\n   * @example\n   *\n   * var object = { 'a': 1, 'b': 2 };\n   * var other = { 'c': 3, 'd': 4 };\n   *\n   * var values = _.memoize(_.values);\n   * values(object);\n   * // => [1, 2]\n   *\n   * values(other);\n   * // => [3, 4]\n   *\n   * object.a = 2;\n   * values(object);\n   * // => [1, 2]\n   *\n   * // Modify the result cache.\n   * values.cache.set(object, ['a', 'b']);\n   * values(object);\n   * // => ['a', 'b']\n   *\n   * // Replace `_.memoize.Cache`.\n   * _.memoize.Cache = WeakMap;\n   */\n  function memoize(func, resolver) {\n    if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {\n      throw new TypeError(FUNC_ERROR_TEXT$1)\n    }\n    var memoized = function () {\n      var args = arguments,\n        key = resolver ? resolver.apply(this, args) : args[0],\n        cache = memoized.cache\n\n      if (cache.has(key)) {\n        return cache.get(key)\n      }\n      var result = func.apply(this, args)\n      memoized.cache = cache.set(key, result) || cache\n      return result\n    }\n    memoized.cache = new (memoize.Cache || MapCache)()\n    return memoized\n  }\n\n  // Expose `MapCache`.\n  memoize.Cache = MapCache\n\n  /** Used as the maximum memoize cache size. */\n  var MAX_MEMOIZE_SIZE = 500\n\n  /**\n   * A specialized version of `_.memoize` which clears the memoized function's\n   * cache when it exceeds `MAX_MEMOIZE_SIZE`.\n   *\n   * @private\n   * @param {Function} func The function to have its output memoized.\n   * @returns {Function} Returns the new memoized function.\n   */\n  function memoizeCapped(func) {\n    var result = memoize(func, function (key) {\n      if (cache.size === MAX_MEMOIZE_SIZE) {\n        cache.clear()\n      }\n      return key\n    })\n\n    var cache = result.cache\n    return result\n  }\n\n  /** Used to match property names within property paths. */\n  var rePropName = /[^.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))/g\n\n  /** Used to match backslashes in property paths. */\n  var reEscapeChar = /\\\\(\\\\)?/g\n\n  /**\n   * Converts `string` to a property path array.\n   *\n   * @private\n   * @param {string} string The string to convert.\n   * @returns {Array} Returns the property path array.\n   */\n  var stringToPath = memoizeCapped(function (string) {\n    var result = []\n    if (string.charCodeAt(0) === 46 /* . */) {\n      result.push('')\n    }\n    string.replace(rePropName, function (match, number, quote, subString) {\n      result.push(quote ? subString.replace(reEscapeChar, '$1') : number || match)\n    })\n    return result\n  })\n\n  const stringToPath$1 = stringToPath\n\n  /**\n   * Converts `value` to a string. An empty string is returned for `null`\n   * and `undefined` values. The sign of `-0` is preserved.\n   *\n   * @static\n   * @memberOf _\n   * @since 4.0.0\n   * @category Lang\n   * @param {*} value The value to convert.\n   * @returns {string} Returns the converted string.\n   * @example\n   *\n   * _.toString(null);\n   * // => ''\n   *\n   * _.toString(-0);\n   * // => '-0'\n   *\n   * _.toString([1, 2, 3]);\n   * // => '1,2,3'\n   */\n  function toString(value) {\n    return value == null ? '' : baseToString(value)\n  }\n\n  /**\n   * Casts `value` to a path array if it's not one.\n   *\n   * @private\n   * @param {*} value The value to inspect.\n   * @param {Object} [object] The object to query keys on.\n   * @returns {Array} Returns the cast property path array.\n   */\n  function castPath(value, object) {\n    if (isArray$1(value)) {\n      return value\n    }\n    return isKey(value, object) ? [value] : stringToPath$1(toString(value))\n  }\n\n  /** Used as references for various `Number` constants. */\n  var INFINITY$1 = 1 / 0\n\n  /**\n   * Converts `value` to a string key if it's not a string or symbol.\n   *\n   * @private\n   * @param {*} value The value to inspect.\n   * @returns {string|symbol} Returns the key.\n   */\n  function toKey(value) {\n    if (typeof value == 'string' || isSymbol(value)) {\n      return value\n    }\n    var result = value + ''\n    return result == '0' && 1 / value == -INFINITY$1 ? '-0' : result\n  }\n\n  /**\n   * The base implementation of `_.get` without support for default values.\n   *\n   * @private\n   * @param {Object} object The object to query.\n   * @param {Array|string} path The path of the property to get.\n   * @returns {*} Returns the resolved value.\n   */\n  function baseGet(object, path) {\n    path = castPath(path, object)\n\n    var index = 0,\n      length = path.length\n\n    while (object != null && index < length) {\n      object = object[toKey(path[index++])]\n    }\n    return index && index == length ? object : undefined\n  }\n\n  /**\n   * Gets the value at `path` of `object`. If the resolved value is\n   * `undefined`, the `defaultValue` is returned in its place.\n   *\n   * @static\n   * @memberOf _\n   * @since 3.7.0\n   * @category Object\n   * @param {Object} object The object to query.\n   * @param {Array|string} path The path of the property to get.\n   * @param {*} [defaultValue] The value returned for `undefined` resolved values.\n   * @returns {*} Returns the resolved value.\n   * @example\n   *\n   * var object = { 'a': [{ 'b': { 'c': 3 } }] };\n   *\n   * _.get(object, 'a[0].b.c');\n   * // => 3\n   *\n   * _.get(object, ['a', '0', 'b', 'c']);\n   * // => 3\n   *\n   * _.get(object, 'a.b.c', 'default');\n   * // => 'default'\n   */\n  function get(object, path, defaultValue) {\n    var result = object == null ? undefined : baseGet(object, path)\n    return result === undefined ? defaultValue : result\n  }\n\n  /**\n   * Appends the elements of `values` to `array`.\n   *\n   * @private\n   * @param {Array} array The array to modify.\n   * @param {Array} values The values to append.\n   * @returns {Array} Returns `array`.\n   */\n  function arrayPush(array, values) {\n    var index = -1,\n      length = values.length,\n      offset = array.length\n\n    while (++index < length) {\n      array[offset + index] = values[index]\n    }\n    return array\n  }\n\n  /** Built-in value references. */\n  var spreadableSymbol = Symbol$2 ? Symbol$2.isConcatSpreadable : undefined\n\n  /**\n   * Checks if `value` is a flattenable `arguments` object or array.\n   *\n   * @private\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.\n   */\n  function isFlattenable(value) {\n    return isArray$1(value) || isArguments$1(value) || !!(spreadableSymbol && value && value[spreadableSymbol])\n  }\n\n  /**\n   * The base implementation of `_.flatten` with support for restricting flattening.\n   *\n   * @private\n   * @param {Array} array The array to flatten.\n   * @param {number} depth The maximum recursion depth.\n   * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.\n   * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.\n   * @param {Array} [result=[]] The initial result value.\n   * @returns {Array} Returns the new flattened array.\n   */\n  function baseFlatten(array, depth, predicate, isStrict, result) {\n    var index = -1,\n      length = array.length\n\n    predicate || (predicate = isFlattenable)\n    result || (result = [])\n\n    while (++index < length) {\n      var value = array[index]\n      if (depth > 0 && predicate(value)) {\n        if (depth > 1) {\n          // Recursively flatten arrays (susceptible to call stack limits).\n          baseFlatten(value, depth - 1, predicate, isStrict, result)\n        } else {\n          arrayPush(result, value)\n        }\n      } else if (!isStrict) {\n        result[result.length] = value\n      }\n    }\n    return result\n  }\n\n  /**\n   * Flattens `array` a single level deep.\n   *\n   * @static\n   * @memberOf _\n   * @since 0.1.0\n   * @category Array\n   * @param {Array} array The array to flatten.\n   * @returns {Array} Returns the new flattened array.\n   * @example\n   *\n   * _.flatten([1, [2, [3, [4]], 5]]);\n   * // => [1, 2, [3, [4]], 5]\n   */\n  function flatten(array) {\n    var length = array == null ? 0 : array.length\n    return length ? baseFlatten(array, 1) : []\n  }\n\n  /** Built-in value references. */\n  var getPrototype = overArg(Object.getPrototypeOf, Object)\n\n  const getPrototype$1 = getPrototype\n\n  /**\n   * The base implementation of `_.slice` without an iteratee call guard.\n   *\n   * @private\n   * @param {Array} array The array to slice.\n   * @param {number} [start=0] The start position.\n   * @param {number} [end=array.length] The end position.\n   * @returns {Array} Returns the slice of `array`.\n   */\n  function baseSlice(array, start, end) {\n    var index = -1,\n      length = array.length\n\n    if (start < 0) {\n      start = -start > length ? 0 : length + start\n    }\n    end = end > length ? length : end\n    if (end < 0) {\n      end += length\n    }\n    length = start > end ? 0 : (end - start) >>> 0\n    start >>>= 0\n\n    var result = Array(length)\n    while (++index < length) {\n      result[index] = array[index + start]\n    }\n    return result\n  }\n\n  /**\n   * A specialized version of `_.reduce` for arrays without support for\n   * iteratee shorthands.\n   *\n   * @private\n   * @param {Array} [array] The array to iterate over.\n   * @param {Function} iteratee The function invoked per iteration.\n   * @param {*} [accumulator] The initial value.\n   * @param {boolean} [initAccum] Specify using the first element of `array` as\n   *  the initial value.\n   * @returns {*} Returns the accumulated value.\n   */\n  function arrayReduce(array, iteratee, accumulator, initAccum) {\n    var index = -1,\n      length = array == null ? 0 : array.length\n\n    if (initAccum && length) {\n      accumulator = array[++index]\n    }\n    while (++index < length) {\n      accumulator = iteratee(accumulator, array[index], index, array)\n    }\n    return accumulator\n  }\n\n  /**\n   * Removes all key-value entries from the stack.\n   *\n   * @private\n   * @name clear\n   * @memberOf Stack\n   */\n  function stackClear() {\n    this.__data__ = new ListCache()\n    this.size = 0\n  }\n\n  /**\n   * Removes `key` and its value from the stack.\n   *\n   * @private\n   * @name delete\n   * @memberOf Stack\n   * @param {string} key The key of the value to remove.\n   * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n   */\n  function stackDelete(key) {\n    var data = this.__data__,\n      result = data['delete'](key)\n\n    this.size = data.size\n    return result\n  }\n\n  /**\n   * Gets the stack value for `key`.\n   *\n   * @private\n   * @name get\n   * @memberOf Stack\n   * @param {string} key The key of the value to get.\n   * @returns {*} Returns the entry value.\n   */\n  function stackGet(key) {\n    return this.__data__.get(key)\n  }\n\n  /**\n   * Checks if a stack value for `key` exists.\n   *\n   * @private\n   * @name has\n   * @memberOf Stack\n   * @param {string} key The key of the entry to check.\n   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n   */\n  function stackHas(key) {\n    return this.__data__.has(key)\n  }\n\n  /** Used as the size to enable large array optimizations. */\n  var LARGE_ARRAY_SIZE$2 = 200\n\n  /**\n   * Sets the stack `key` to `value`.\n   *\n   * @private\n   * @name set\n   * @memberOf Stack\n   * @param {string} key The key of the value to set.\n   * @param {*} value The value to set.\n   * @returns {Object} Returns the stack cache instance.\n   */\n  function stackSet(key, value) {\n    var data = this.__data__\n    if (data instanceof ListCache) {\n      var pairs = data.__data__\n      if (!Map$2 || pairs.length < LARGE_ARRAY_SIZE$2 - 1) {\n        pairs.push([key, value])\n        this.size = ++data.size\n        return this\n      }\n      data = this.__data__ = new MapCache(pairs)\n    }\n    data.set(key, value)\n    this.size = data.size\n    return this\n  }\n\n  /**\n   * Creates a stack cache object to store key-value pairs.\n   *\n   * @private\n   * @constructor\n   * @param {Array} [entries] The key-value pairs to cache.\n   */\n  function Stack(entries) {\n    var data = (this.__data__ = new ListCache(entries))\n    this.size = data.size\n  }\n\n  // Add methods to `Stack`.\n  Stack.prototype.clear = stackClear\n  Stack.prototype['delete'] = stackDelete\n  Stack.prototype.get = stackGet\n  Stack.prototype.has = stackHas\n  Stack.prototype.set = stackSet\n\n  /**\n   * The base implementation of `_.assign` without support for multiple sources\n   * or `customizer` functions.\n   *\n   * @private\n   * @param {Object} object The destination object.\n   * @param {Object} source The source object.\n   * @returns {Object} Returns `object`.\n   */\n  function baseAssign(object, source) {\n    return object && copyObject(source, keys(source), object)\n  }\n\n  /**\n   * The base implementation of `_.assignIn` without support for multiple sources\n   * or `customizer` functions.\n   *\n   * @private\n   * @param {Object} object The destination object.\n   * @param {Object} source The source object.\n   * @returns {Object} Returns `object`.\n   */\n  function baseAssignIn(object, source) {\n    return object && copyObject(source, keysIn(source), object)\n  }\n\n  /** Detect free variable `exports`. */\n  var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports\n\n  /** Detect free variable `module`. */\n  var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module\n\n  /** Detect the popular CommonJS extension `module.exports`. */\n  var moduleExports = freeModule && freeModule.exports === freeExports\n\n  /** Built-in value references. */\n  var Buffer = moduleExports ? root$1.Buffer : undefined,\n    allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined\n\n  /**\n   * Creates a clone of  `buffer`.\n   *\n   * @private\n   * @param {Buffer} buffer The buffer to clone.\n   * @param {boolean} [isDeep] Specify a deep clone.\n   * @returns {Buffer} Returns the cloned buffer.\n   */\n  function cloneBuffer(buffer, isDeep) {\n    if (isDeep) {\n      return buffer.slice()\n    }\n    var length = buffer.length,\n      result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length)\n\n    buffer.copy(result)\n    return result\n  }\n\n  /**\n   * A specialized version of `_.filter` for arrays without support for\n   * iteratee shorthands.\n   *\n   * @private\n   * @param {Array} [array] The array to iterate over.\n   * @param {Function} predicate The function invoked per iteration.\n   * @returns {Array} Returns the new filtered array.\n   */\n  function arrayFilter(array, predicate) {\n    var index = -1,\n      length = array == null ? 0 : array.length,\n      resIndex = 0,\n      result = []\n\n    while (++index < length) {\n      var value = array[index]\n      if (predicate(value, index, array)) {\n        result[resIndex++] = value\n      }\n    }\n    return result\n  }\n\n  /**\n   * This method returns a new empty array.\n   *\n   * @static\n   * @memberOf _\n   * @since 4.13.0\n   * @category Util\n   * @returns {Array} Returns the new empty array.\n   * @example\n   *\n   * var arrays = _.times(2, _.stubArray);\n   *\n   * console.log(arrays);\n   * // => [[], []]\n   *\n   * console.log(arrays[0] === arrays[1]);\n   * // => false\n   */\n  function stubArray() {\n    return []\n  }\n\n  /** Used for built-in method references. */\n  var objectProto$7 = Object.prototype\n\n  /** Built-in value references. */\n  var propertyIsEnumerable = objectProto$7.propertyIsEnumerable\n\n  /* Built-in method references for those with the same name as other `lodash` methods. */\n  var nativeGetSymbols$1 = Object.getOwnPropertySymbols\n\n  /**\n   * Creates an array of the own enumerable symbols of `object`.\n   *\n   * @private\n   * @param {Object} object The object to query.\n   * @returns {Array} Returns the array of symbols.\n   */\n  var getSymbols = !nativeGetSymbols$1\n    ? stubArray\n    : function (object) {\n        if (object == null) {\n          return []\n        }\n        object = Object(object)\n        return arrayFilter(nativeGetSymbols$1(object), function (symbol) {\n          return propertyIsEnumerable.call(object, symbol)\n        })\n      }\n\n  const getSymbols$1 = getSymbols\n\n  /**\n   * Copies own symbols of `source` to `object`.\n   *\n   * @private\n   * @param {Object} source The object to copy symbols from.\n   * @param {Object} [object={}] The object to copy symbols to.\n   * @returns {Object} Returns `object`.\n   */\n  function copySymbols(source, object) {\n    return copyObject(source, getSymbols$1(source), object)\n  }\n\n  /* Built-in method references for those with the same name as other `lodash` methods. */\n  var nativeGetSymbols = Object.getOwnPropertySymbols\n\n  /**\n   * Creates an array of the own and inherited enumerable symbols of `object`.\n   *\n   * @private\n   * @param {Object} object The object to query.\n   * @returns {Array} Returns the array of symbols.\n   */\n  var getSymbolsIn = !nativeGetSymbols\n    ? stubArray\n    : function (object) {\n        var result = []\n        while (object) {\n          arrayPush(result, getSymbols$1(object))\n          object = getPrototype$1(object)\n        }\n        return result\n      }\n\n  const getSymbolsIn$1 = getSymbolsIn\n\n  /**\n   * Copies own and inherited symbols of `source` to `object`.\n   *\n   * @private\n   * @param {Object} source The object to copy symbols from.\n   * @param {Object} [object={}] The object to copy symbols to.\n   * @returns {Object} Returns `object`.\n   */\n  function copySymbolsIn(source, object) {\n    return copyObject(source, getSymbolsIn$1(source), object)\n  }\n\n  /**\n   * The base implementation of `getAllKeys` and `getAllKeysIn` which uses\n   * `keysFunc` and `symbolsFunc` to get the enumerable property names and\n   * symbols of `object`.\n   *\n   * @private\n   * @param {Object} object The object to query.\n   * @param {Function} keysFunc The function to get the keys of `object`.\n   * @param {Function} symbolsFunc The function to get the symbols of `object`.\n   * @returns {Array} Returns the array of property names and symbols.\n   */\n  function baseGetAllKeys(object, keysFunc, symbolsFunc) {\n    var result = keysFunc(object)\n    return isArray$1(object) ? result : arrayPush(result, symbolsFunc(object))\n  }\n\n  /**\n   * Creates an array of own enumerable property names and symbols of `object`.\n   *\n   * @private\n   * @param {Object} object The object to query.\n   * @returns {Array} Returns the array of property names and symbols.\n   */\n  function getAllKeys(object) {\n    return baseGetAllKeys(object, keys, getSymbols$1)\n  }\n\n  /**\n   * Creates an array of own and inherited enumerable property names and\n   * symbols of `object`.\n   *\n   * @private\n   * @param {Object} object The object to query.\n   * @returns {Array} Returns the array of property names and symbols.\n   */\n  function getAllKeysIn(object) {\n    return baseGetAllKeys(object, keysIn, getSymbolsIn$1)\n  }\n\n  /* Built-in method references that are verified to be native. */\n  var DataView = getNative(root$1, 'DataView')\n\n  const DataView$1 = DataView\n\n  /* Built-in method references that are verified to be native. */\n  var Promise$1 = getNative(root$1, 'Promise')\n\n  const Promise$2 = Promise$1\n\n  /* Built-in method references that are verified to be native. */\n  var Set = getNative(root$1, 'Set')\n\n  const Set$1 = Set\n\n  /** `Object#toString` result references. */\n  var mapTag$5 = '[object Map]',\n    objectTag$2 = '[object Object]',\n    promiseTag = '[object Promise]',\n    setTag$5 = '[object Set]',\n    weakMapTag$1 = '[object WeakMap]'\n\n  var dataViewTag$3 = '[object DataView]'\n\n  /** Used to detect maps, sets, and weakmaps. */\n  var dataViewCtorString = toSource(DataView$1),\n    mapCtorString = toSource(Map$2),\n    promiseCtorString = toSource(Promise$2),\n    setCtorString = toSource(Set$1),\n    weakMapCtorString = toSource(WeakMap$1)\n\n  /**\n   * Gets the `toStringTag` of `value`.\n   *\n   * @private\n   * @param {*} value The value to query.\n   * @returns {string} Returns the `toStringTag`.\n   */\n  var getTag = baseGetTag\n\n  // Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.\n  if (\n    (DataView$1 && getTag(new DataView$1(new ArrayBuffer(1))) != dataViewTag$3) ||\n    (Map$2 && getTag(new Map$2()) != mapTag$5) ||\n    (Promise$2 && getTag(Promise$2.resolve()) != promiseTag) ||\n    (Set$1 && getTag(new Set$1()) != setTag$5) ||\n    (WeakMap$1 && getTag(new WeakMap$1()) != weakMapTag$1)\n  ) {\n    getTag = function (value) {\n      var result = baseGetTag(value),\n        Ctor = result == objectTag$2 ? value.constructor : undefined,\n        ctorString = Ctor ? toSource(Ctor) : ''\n\n      if (ctorString) {\n        switch (ctorString) {\n          case dataViewCtorString:\n            return dataViewTag$3\n          case mapCtorString:\n            return mapTag$5\n          case promiseCtorString:\n            return promiseTag\n          case setCtorString:\n            return setTag$5\n          case weakMapCtorString:\n            return weakMapTag$1\n        }\n      }\n      return result\n    }\n  }\n\n  const getTag$1 = getTag\n\n  /** Used for built-in method references. */\n  var objectProto$6 = Object.prototype\n\n  /** Used to check objects for own properties. */\n  var hasOwnProperty$6 = objectProto$6.hasOwnProperty\n\n  /**\n   * Initializes an array clone.\n   *\n   * @private\n   * @param {Array} array The array to clone.\n   * @returns {Array} Returns the initialized clone.\n   */\n  function initCloneArray(array) {\n    var length = array.length,\n      result = new array.constructor(length)\n\n    // Add properties assigned by `RegExp#exec`.\n    if (length && typeof array[0] == 'string' && hasOwnProperty$6.call(array, 'index')) {\n      result.index = array.index\n      result.input = array.input\n    }\n    return result\n  }\n\n  /** Built-in value references. */\n  var Uint8Array = root$1.Uint8Array\n\n  const Uint8Array$1 = Uint8Array\n\n  /**\n   * Creates a clone of `arrayBuffer`.\n   *\n   * @private\n   * @param {ArrayBuffer} arrayBuffer The array buffer to clone.\n   * @returns {ArrayBuffer} Returns the cloned array buffer.\n   */\n  function cloneArrayBuffer(arrayBuffer) {\n    var result = new arrayBuffer.constructor(arrayBuffer.byteLength)\n    new Uint8Array$1(result).set(new Uint8Array$1(arrayBuffer))\n    return result\n  }\n\n  /**\n   * Creates a clone of `dataView`.\n   *\n   * @private\n   * @param {Object} dataView The data view to clone.\n   * @param {boolean} [isDeep] Specify a deep clone.\n   * @returns {Object} Returns the cloned data view.\n   */\n  function cloneDataView(dataView, isDeep) {\n    var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer\n    return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength)\n  }\n\n  /** Used to match `RegExp` flags from their coerced string values. */\n  var reFlags = /\\w*$/\n\n  /**\n   * Creates a clone of `regexp`.\n   *\n   * @private\n   * @param {Object} regexp The regexp to clone.\n   * @returns {Object} Returns the cloned regexp.\n   */\n  function cloneRegExp(regexp) {\n    var result = new regexp.constructor(regexp.source, reFlags.exec(regexp))\n    result.lastIndex = regexp.lastIndex\n    return result\n  }\n\n  /** Used to convert symbols to primitives and strings. */\n  var symbolProto$1 = Symbol$2 ? Symbol$2.prototype : undefined,\n    symbolValueOf$1 = symbolProto$1 ? symbolProto$1.valueOf : undefined\n\n  /**\n   * Creates a clone of the `symbol` object.\n   *\n   * @private\n   * @param {Object} symbol The symbol object to clone.\n   * @returns {Object} Returns the cloned symbol object.\n   */\n  function cloneSymbol(symbol) {\n    return symbolValueOf$1 ? Object(symbolValueOf$1.call(symbol)) : {}\n  }\n\n  /**\n   * Creates a clone of `typedArray`.\n   *\n   * @private\n   * @param {Object} typedArray The typed array to clone.\n   * @param {boolean} [isDeep] Specify a deep clone.\n   * @returns {Object} Returns the cloned typed array.\n   */\n  function cloneTypedArray(typedArray, isDeep) {\n    var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer\n    return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length)\n  }\n\n  /** `Object#toString` result references. */\n  var boolTag$2 = '[object Boolean]',\n    dateTag$2 = '[object Date]',\n    mapTag$4 = '[object Map]',\n    numberTag$2 = '[object Number]',\n    regexpTag$3 = '[object RegExp]',\n    setTag$4 = '[object Set]',\n    stringTag$3 = '[object String]',\n    symbolTag$2 = '[object Symbol]'\n\n  var arrayBufferTag$2 = '[object ArrayBuffer]',\n    dataViewTag$2 = '[object DataView]',\n    float32Tag$1 = '[object Float32Array]',\n    float64Tag$1 = '[object Float64Array]',\n    int8Tag$1 = '[object Int8Array]',\n    int16Tag$1 = '[object Int16Array]',\n    int32Tag$1 = '[object Int32Array]',\n    uint8Tag$1 = '[object Uint8Array]',\n    uint8ClampedTag$1 = '[object Uint8ClampedArray]',\n    uint16Tag$1 = '[object Uint16Array]',\n    uint32Tag$1 = '[object Uint32Array]'\n\n  /**\n   * Initializes an object clone based on its `toStringTag`.\n   *\n   * **Note:** This function only supports cloning values with tags of\n   * `Boolean`, `Date`, `Error`, `Map`, `Number`, `RegExp`, `Set`, or `String`.\n   *\n   * @private\n   * @param {Object} object The object to clone.\n   * @param {string} tag The `toStringTag` of the object to clone.\n   * @param {boolean} [isDeep] Specify a deep clone.\n   * @returns {Object} Returns the initialized clone.\n   */\n  function initCloneByTag(object, tag, isDeep) {\n    var Ctor = object.constructor\n    switch (tag) {\n      case arrayBufferTag$2:\n        return cloneArrayBuffer(object)\n\n      case boolTag$2:\n      case dateTag$2:\n        return new Ctor(+object)\n\n      case dataViewTag$2:\n        return cloneDataView(object, isDeep)\n\n      case float32Tag$1:\n      case float64Tag$1:\n      case int8Tag$1:\n      case int16Tag$1:\n      case int32Tag$1:\n      case uint8Tag$1:\n      case uint8ClampedTag$1:\n      case uint16Tag$1:\n      case uint32Tag$1:\n        return cloneTypedArray(object, isDeep)\n\n      case mapTag$4:\n        return new Ctor()\n\n      case numberTag$2:\n      case stringTag$3:\n        return new Ctor(object)\n\n      case regexpTag$3:\n        return cloneRegExp(object)\n\n      case setTag$4:\n        return new Ctor()\n\n      case symbolTag$2:\n        return cloneSymbol(object)\n    }\n  }\n\n  /**\n   * Initializes an object clone.\n   *\n   * @private\n   * @param {Object} object The object to clone.\n   * @returns {Object} Returns the initialized clone.\n   */\n  function initCloneObject(object) {\n    return typeof object.constructor == 'function' && !isPrototype(object) ? baseCreate$1(getPrototype$1(object)) : {}\n  }\n\n  /** `Object#toString` result references. */\n  var mapTag$3 = '[object Map]'\n\n  /**\n   * The base implementation of `_.isMap` without Node.js optimizations.\n   *\n   * @private\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is a map, else `false`.\n   */\n  function baseIsMap(value) {\n    return isObjectLike(value) && getTag$1(value) == mapTag$3\n  }\n\n  /* Node.js helper references. */\n  var nodeIsMap = nodeUtil$1 && nodeUtil$1.isMap\n\n  /**\n   * Checks if `value` is classified as a `Map` object.\n   *\n   * @static\n   * @memberOf _\n   * @since 4.3.0\n   * @category Lang\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is a map, else `false`.\n   * @example\n   *\n   * _.isMap(new Map);\n   * // => true\n   *\n   * _.isMap(new WeakMap);\n   * // => false\n   */\n  var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap\n\n  const isMap$1 = isMap\n\n  /** `Object#toString` result references. */\n  var setTag$3 = '[object Set]'\n\n  /**\n   * The base implementation of `_.isSet` without Node.js optimizations.\n   *\n   * @private\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is a set, else `false`.\n   */\n  function baseIsSet(value) {\n    return isObjectLike(value) && getTag$1(value) == setTag$3\n  }\n\n  /* Node.js helper references. */\n  var nodeIsSet = nodeUtil$1 && nodeUtil$1.isSet\n\n  /**\n   * Checks if `value` is classified as a `Set` object.\n   *\n   * @static\n   * @memberOf _\n   * @since 4.3.0\n   * @category Lang\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is a set, else `false`.\n   * @example\n   *\n   * _.isSet(new Set);\n   * // => true\n   *\n   * _.isSet(new WeakSet);\n   * // => false\n   */\n  var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet\n\n  const isSet$1 = isSet\n\n  /** Used to compose bitmasks for cloning. */\n  var CLONE_DEEP_FLAG = 1,\n    CLONE_FLAT_FLAG = 2,\n    CLONE_SYMBOLS_FLAG$1 = 4\n\n  /** `Object#toString` result references. */\n  var argsTag$1 = '[object Arguments]',\n    arrayTag$1 = '[object Array]',\n    boolTag$1 = '[object Boolean]',\n    dateTag$1 = '[object Date]',\n    errorTag$1 = '[object Error]',\n    funcTag = '[object Function]',\n    genTag = '[object GeneratorFunction]',\n    mapTag$2 = '[object Map]',\n    numberTag$1 = '[object Number]',\n    objectTag$1 = '[object Object]',\n    regexpTag$2 = '[object RegExp]',\n    setTag$2 = '[object Set]',\n    stringTag$2 = '[object String]',\n    symbolTag$1 = '[object Symbol]',\n    weakMapTag = '[object WeakMap]'\n\n  var arrayBufferTag$1 = '[object ArrayBuffer]',\n    dataViewTag$1 = '[object DataView]',\n    float32Tag = '[object Float32Array]',\n    float64Tag = '[object Float64Array]',\n    int8Tag = '[object Int8Array]',\n    int16Tag = '[object Int16Array]',\n    int32Tag = '[object Int32Array]',\n    uint8Tag = '[object Uint8Array]',\n    uint8ClampedTag = '[object Uint8ClampedArray]',\n    uint16Tag = '[object Uint16Array]',\n    uint32Tag = '[object Uint32Array]'\n\n  /** Used to identify `toStringTag` values supported by `_.clone`. */\n  var cloneableTags = {}\n  cloneableTags[argsTag$1] = cloneableTags[arrayTag$1] = cloneableTags[arrayBufferTag$1] = cloneableTags[\n    dataViewTag$1\n  ] = cloneableTags[boolTag$1] = cloneableTags[dateTag$1] = cloneableTags[float32Tag] = cloneableTags[\n    float64Tag\n  ] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[\n    mapTag$2\n  ] = cloneableTags[numberTag$1] = cloneableTags[objectTag$1] = cloneableTags[regexpTag$2] = cloneableTags[\n    setTag$2\n  ] = cloneableTags[stringTag$2] = cloneableTags[symbolTag$1] = cloneableTags[uint8Tag] = cloneableTags[\n    uint8ClampedTag\n  ] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true\n  cloneableTags[errorTag$1] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false\n\n  /**\n   * The base implementation of `_.clone` and `_.cloneDeep` which tracks\n   * traversed objects.\n   *\n   * @private\n   * @param {*} value The value to clone.\n   * @param {boolean} bitmask The bitmask flags.\n   *  1 - Deep clone\n   *  2 - Flatten inherited properties\n   *  4 - Clone symbols\n   * @param {Function} [customizer] The function to customize cloning.\n   * @param {string} [key] The key of `value`.\n   * @param {Object} [object] The parent object of `value`.\n   * @param {Object} [stack] Tracks traversed objects and their clone counterparts.\n   * @returns {*} Returns the cloned value.\n   */\n  function baseClone(value, bitmask, customizer, key, object, stack) {\n    var result,\n      isDeep = bitmask & CLONE_DEEP_FLAG,\n      isFlat = bitmask & CLONE_FLAT_FLAG,\n      isFull = bitmask & CLONE_SYMBOLS_FLAG$1\n\n    if (customizer) {\n      result = object ? customizer(value, key, object, stack) : customizer(value)\n    }\n    if (result !== undefined) {\n      return result\n    }\n    if (!isObject(value)) {\n      return value\n    }\n    var isArr = isArray$1(value)\n    if (isArr) {\n      result = initCloneArray(value)\n      if (!isDeep) {\n        return copyArray(value, result)\n      }\n    } else {\n      var tag = getTag$1(value),\n        isFunc = tag == funcTag || tag == genTag\n\n      if (isBuffer$1(value)) {\n        return cloneBuffer(value, isDeep)\n      }\n      if (tag == objectTag$1 || tag == argsTag$1 || (isFunc && !object)) {\n        result = isFlat || isFunc ? {} : initCloneObject(value)\n        if (!isDeep) {\n          return isFlat\n            ? copySymbolsIn(value, baseAssignIn(result, value))\n            : copySymbols(value, baseAssign(result, value))\n        }\n      } else {\n        if (!cloneableTags[tag]) {\n          return object ? value : {}\n        }\n        result = initCloneByTag(value, tag, isDeep)\n      }\n    }\n    // Check for circular references and return its corresponding clone.\n    stack || (stack = new Stack())\n    var stacked = stack.get(value)\n    if (stacked) {\n      return stacked\n    }\n    stack.set(value, result)\n\n    if (isSet$1(value)) {\n      value.forEach(function (subValue) {\n        result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack))\n      })\n    } else if (isMap$1(value)) {\n      value.forEach(function (subValue, key) {\n        result.set(key, baseClone(subValue, bitmask, customizer, key, value, stack))\n      })\n    }\n\n    var keysFunc = isFull ? (isFlat ? getAllKeysIn : getAllKeys) : isFlat ? keysIn : keys\n\n    var props = isArr ? undefined : keysFunc(value)\n    arrayEach(props || value, function (subValue, key) {\n      if (props) {\n        key = subValue\n        subValue = value[key]\n      }\n      // Recursively populate clone (susceptible to call stack limits).\n      assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack))\n    })\n    return result\n  }\n\n  /** Used to compose bitmasks for cloning. */\n  var CLONE_SYMBOLS_FLAG = 4\n\n  /**\n   * Creates a shallow clone of `value`.\n   *\n   * **Note:** This method is loosely based on the\n   * [structured clone algorithm](https://mdn.io/Structured_clone_algorithm)\n   * and supports cloning arrays, array buffers, booleans, date objects, maps,\n   * numbers, `Object` objects, regexes, sets, strings, symbols, and typed\n   * arrays. The own enumerable properties of `arguments` objects are cloned\n   * as plain objects. An empty object is returned for uncloneable values such\n   * as error objects, functions, DOM nodes, and WeakMaps.\n   *\n   * @static\n   * @memberOf _\n   * @since 0.1.0\n   * @category Lang\n   * @param {*} value The value to clone.\n   * @returns {*} Returns the cloned value.\n   * @see _.cloneDeep\n   * @example\n   *\n   * var objects = [{ 'a': 1 }, { 'b': 2 }];\n   *\n   * var shallow = _.clone(objects);\n   * console.log(shallow[0] === objects[0]);\n   * // => true\n   */\n  function clone(value) {\n    return baseClone(value, CLONE_SYMBOLS_FLAG)\n  }\n\n  /**\n   * Creates an array with all falsey values removed. The values `false`, `null`,\n   * `0`, `\"\"`, `undefined`, and `NaN` are falsey.\n   *\n   * @static\n   * @memberOf _\n   * @since 0.1.0\n   * @category Array\n   * @param {Array} array The array to compact.\n   * @returns {Array} Returns the new array of filtered values.\n   * @example\n   *\n   * _.compact([0, 1, false, 2, '', 3]);\n   * // => [1, 2, 3]\n   */\n  function compact(array) {\n    var index = -1,\n      length = array == null ? 0 : array.length,\n      resIndex = 0,\n      result = []\n\n    while (++index < length) {\n      var value = array[index]\n      if (value) {\n        result[resIndex++] = value\n      }\n    }\n    return result\n  }\n\n  /** Used to stand-in for `undefined` hash values. */\n  var HASH_UNDEFINED = '__lodash_hash_undefined__'\n\n  /**\n   * Adds `value` to the array cache.\n   *\n   * @private\n   * @name add\n   * @memberOf SetCache\n   * @alias push\n   * @param {*} value The value to cache.\n   * @returns {Object} Returns the cache instance.\n   */\n  function setCacheAdd(value) {\n    this.__data__.set(value, HASH_UNDEFINED)\n    return this\n  }\n\n  /**\n   * Checks if `value` is in the array cache.\n   *\n   * @private\n   * @name has\n   * @memberOf SetCache\n   * @param {*} value The value to search for.\n   * @returns {number} Returns `true` if `value` is found, else `false`.\n   */\n  function setCacheHas(value) {\n    return this.__data__.has(value)\n  }\n\n  /**\n   *\n   * Creates an array cache object to store unique values.\n   *\n   * @private\n   * @constructor\n   * @param {Array} [values] The values to cache.\n   */\n  function SetCache(values) {\n    var index = -1,\n      length = values == null ? 0 : values.length\n\n    this.__data__ = new MapCache()\n    while (++index < length) {\n      this.add(values[index])\n    }\n  }\n\n  // Add methods to `SetCache`.\n  SetCache.prototype.add = SetCache.prototype.push = setCacheAdd\n  SetCache.prototype.has = setCacheHas\n\n  /**\n   * A specialized version of `_.some` for arrays without support for iteratee\n   * shorthands.\n   *\n   * @private\n   * @param {Array} [array] The array to iterate over.\n   * @param {Function} predicate The function invoked per iteration.\n   * @returns {boolean} Returns `true` if any element passes the predicate check,\n   *  else `false`.\n   */\n  function arraySome(array, predicate) {\n    var index = -1,\n      length = array == null ? 0 : array.length\n\n    while (++index < length) {\n      if (predicate(array[index], index, array)) {\n        return true\n      }\n    }\n    return false\n  }\n\n  /**\n   * Checks if a `cache` value for `key` exists.\n   *\n   * @private\n   * @param {Object} cache The cache to query.\n   * @param {string} key The key of the entry to check.\n   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n   */\n  function cacheHas(cache, key) {\n    return cache.has(key)\n  }\n\n  /** Used to compose bitmasks for value comparisons. */\n  var COMPARE_PARTIAL_FLAG$5 = 1,\n    COMPARE_UNORDERED_FLAG$3 = 2\n\n  /**\n   * A specialized version of `baseIsEqualDeep` for arrays with support for\n   * partial deep comparisons.\n   *\n   * @private\n   * @param {Array} array The array to compare.\n   * @param {Array} other The other array to compare.\n   * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n   * @param {Function} customizer The function to customize comparisons.\n   * @param {Function} equalFunc The function to determine equivalents of values.\n   * @param {Object} stack Tracks traversed `array` and `other` objects.\n   * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.\n   */\n  function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {\n    var isPartial = bitmask & COMPARE_PARTIAL_FLAG$5,\n      arrLength = array.length,\n      othLength = other.length\n\n    if (arrLength != othLength && !(isPartial && othLength > arrLength)) {\n      return false\n    }\n    // Check that cyclic values are equal.\n    var arrStacked = stack.get(array)\n    var othStacked = stack.get(other)\n    if (arrStacked && othStacked) {\n      return arrStacked == other && othStacked == array\n    }\n    var index = -1,\n      result = true,\n      seen = bitmask & COMPARE_UNORDERED_FLAG$3 ? new SetCache() : undefined\n\n    stack.set(array, other)\n    stack.set(other, array)\n\n    // Ignore non-index properties.\n    while (++index < arrLength) {\n      var arrValue = array[index],\n        othValue = other[index]\n\n      if (customizer) {\n        var compared = isPartial\n          ? customizer(othValue, arrValue, index, other, array, stack)\n          : customizer(arrValue, othValue, index, array, other, stack)\n      }\n      if (compared !== undefined) {\n        if (compared) {\n          continue\n        }\n        result = false\n        break\n      }\n      // Recursively compare arrays (susceptible to call stack limits).\n      if (seen) {\n        if (\n          !arraySome(other, function (othValue, othIndex) {\n            if (\n              !cacheHas(seen, othIndex) &&\n              (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))\n            ) {\n              return seen.push(othIndex)\n            }\n          })\n        ) {\n          result = false\n          break\n        }\n      } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {\n        result = false\n        break\n      }\n    }\n    stack['delete'](array)\n    stack['delete'](other)\n    return result\n  }\n\n  /**\n   * Converts `map` to its key-value pairs.\n   *\n   * @private\n   * @param {Object} map The map to convert.\n   * @returns {Array} Returns the key-value pairs.\n   */\n  function mapToArray(map) {\n    var index = -1,\n      result = Array(map.size)\n\n    map.forEach(function (value, key) {\n      result[++index] = [key, value]\n    })\n    return result\n  }\n\n  /**\n   * Converts `set` to an array of its values.\n   *\n   * @private\n   * @param {Object} set The set to convert.\n   * @returns {Array} Returns the values.\n   */\n  function setToArray(set) {\n    var index = -1,\n      result = Array(set.size)\n\n    set.forEach(function (value) {\n      result[++index] = value\n    })\n    return result\n  }\n\n  /** Used to compose bitmasks for value comparisons. */\n  var COMPARE_PARTIAL_FLAG$4 = 1,\n    COMPARE_UNORDERED_FLAG$2 = 2\n\n  /** `Object#toString` result references. */\n  var boolTag = '[object Boolean]',\n    dateTag = '[object Date]',\n    errorTag = '[object Error]',\n    mapTag$1 = '[object Map]',\n    numberTag = '[object Number]',\n    regexpTag$1 = '[object RegExp]',\n    setTag$1 = '[object Set]',\n    stringTag$1 = '[object String]',\n    symbolTag = '[object Symbol]'\n\n  var arrayBufferTag = '[object ArrayBuffer]',\n    dataViewTag = '[object DataView]'\n\n  /** Used to convert symbols to primitives and strings. */\n  var symbolProto = Symbol$2 ? Symbol$2.prototype : undefined,\n    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined\n\n  /**\n   * A specialized version of `baseIsEqualDeep` for comparing objects of\n   * the same `toStringTag`.\n   *\n   * **Note:** This function only supports comparing values with tags of\n   * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.\n   *\n   * @private\n   * @param {Object} object The object to compare.\n   * @param {Object} other The other object to compare.\n   * @param {string} tag The `toStringTag` of the objects to compare.\n   * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n   * @param {Function} customizer The function to customize comparisons.\n   * @param {Function} equalFunc The function to determine equivalents of values.\n   * @param {Object} stack Tracks traversed `object` and `other` objects.\n   * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n   */\n  function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {\n    switch (tag) {\n      case dataViewTag:\n        if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {\n          return false\n        }\n        object = object.buffer\n        other = other.buffer\n\n      case arrayBufferTag:\n        if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array$1(object), new Uint8Array$1(other))) {\n          return false\n        }\n        return true\n\n      case boolTag:\n      case dateTag:\n      case numberTag:\n        // Coerce booleans to `1` or `0` and dates to milliseconds.\n        // Invalid dates are coerced to `NaN`.\n        return eq(+object, +other)\n\n      case errorTag:\n        return object.name == other.name && object.message == other.message\n\n      case regexpTag$1:\n      case stringTag$1:\n        // Coerce regexes to strings and treat strings, primitives and objects,\n        // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring\n        // for more details.\n        return object == other + ''\n\n      case mapTag$1:\n        var convert = mapToArray\n\n      case setTag$1:\n        var isPartial = bitmask & COMPARE_PARTIAL_FLAG$4\n        convert || (convert = setToArray)\n\n        if (object.size != other.size && !isPartial) {\n          return false\n        }\n        // Assume cyclic values are equal.\n        var stacked = stack.get(object)\n        if (stacked) {\n          return stacked == other\n        }\n        bitmask |= COMPARE_UNORDERED_FLAG$2\n\n        // Recursively compare objects (susceptible to call stack limits).\n        stack.set(object, other)\n        var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack)\n        stack['delete'](object)\n        return result\n\n      case symbolTag:\n        if (symbolValueOf) {\n          return symbolValueOf.call(object) == symbolValueOf.call(other)\n        }\n    }\n    return false\n  }\n\n  /** Used to compose bitmasks for value comparisons. */\n  var COMPARE_PARTIAL_FLAG$3 = 1\n\n  /** Used for built-in method references. */\n  var objectProto$5 = Object.prototype\n\n  /** Used to check objects for own properties. */\n  var hasOwnProperty$5 = objectProto$5.hasOwnProperty\n\n  /**\n   * A specialized version of `baseIsEqualDeep` for objects with support for\n   * partial deep comparisons.\n   *\n   * @private\n   * @param {Object} object The object to compare.\n   * @param {Object} other The other object to compare.\n   * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n   * @param {Function} customizer The function to customize comparisons.\n   * @param {Function} equalFunc The function to determine equivalents of values.\n   * @param {Object} stack Tracks traversed `object` and `other` objects.\n   * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n   */\n  function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {\n    var isPartial = bitmask & COMPARE_PARTIAL_FLAG$3,\n      objProps = getAllKeys(object),\n      objLength = objProps.length,\n      othProps = getAllKeys(other),\n      othLength = othProps.length\n\n    if (objLength != othLength && !isPartial) {\n      return false\n    }\n    var index = objLength\n    while (index--) {\n      var key = objProps[index]\n      if (!(isPartial ? key in other : hasOwnProperty$5.call(other, key))) {\n        return false\n      }\n    }\n    // Check that cyclic values are equal.\n    var objStacked = stack.get(object)\n    var othStacked = stack.get(other)\n    if (objStacked && othStacked) {\n      return objStacked == other && othStacked == object\n    }\n    var result = true\n    stack.set(object, other)\n    stack.set(other, object)\n\n    var skipCtor = isPartial\n    while (++index < objLength) {\n      key = objProps[index]\n      var objValue = object[key],\n        othValue = other[key]\n\n      if (customizer) {\n        var compared = isPartial\n          ? customizer(othValue, objValue, key, other, object, stack)\n          : customizer(objValue, othValue, key, object, other, stack)\n      }\n      // Recursively compare objects (susceptible to call stack limits).\n      if (\n        !(compared === undefined\n          ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack)\n          : compared)\n      ) {\n        result = false\n        break\n      }\n      skipCtor || (skipCtor = key == 'constructor')\n    }\n    if (result && !skipCtor) {\n      var objCtor = object.constructor,\n        othCtor = other.constructor\n\n      // Non `Object` object instances with different constructors are not equal.\n      if (\n        objCtor != othCtor &&\n        'constructor' in object &&\n        'constructor' in other &&\n        !(\n          typeof objCtor == 'function' &&\n          objCtor instanceof objCtor &&\n          typeof othCtor == 'function' &&\n          othCtor instanceof othCtor\n        )\n      ) {\n        result = false\n      }\n    }\n    stack['delete'](object)\n    stack['delete'](other)\n    return result\n  }\n\n  /** Used to compose bitmasks for value comparisons. */\n  var COMPARE_PARTIAL_FLAG$2 = 1\n\n  /** `Object#toString` result references. */\n  var argsTag = '[object Arguments]',\n    arrayTag = '[object Array]',\n    objectTag = '[object Object]'\n\n  /** Used for built-in method references. */\n  var objectProto$4 = Object.prototype\n\n  /** Used to check objects for own properties. */\n  var hasOwnProperty$4 = objectProto$4.hasOwnProperty\n\n  /**\n   * A specialized version of `baseIsEqual` for arrays and objects which performs\n   * deep comparisons and tracks traversed objects enabling objects with circular\n   * references to be compared.\n   *\n   * @private\n   * @param {Object} object The object to compare.\n   * @param {Object} other The other object to compare.\n   * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n   * @param {Function} customizer The function to customize comparisons.\n   * @param {Function} equalFunc The function to determine equivalents of values.\n   * @param {Object} [stack] Tracks traversed `object` and `other` objects.\n   * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n   */\n  function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {\n    var objIsArr = isArray$1(object),\n      othIsArr = isArray$1(other),\n      objTag = objIsArr ? arrayTag : getTag$1(object),\n      othTag = othIsArr ? arrayTag : getTag$1(other)\n\n    objTag = objTag == argsTag ? objectTag : objTag\n    othTag = othTag == argsTag ? objectTag : othTag\n\n    var objIsObj = objTag == objectTag,\n      othIsObj = othTag == objectTag,\n      isSameTag = objTag == othTag\n\n    if (isSameTag && isBuffer$1(object)) {\n      if (!isBuffer$1(other)) {\n        return false\n      }\n      objIsArr = true\n      objIsObj = false\n    }\n    if (isSameTag && !objIsObj) {\n      stack || (stack = new Stack())\n      return objIsArr || isTypedArray$1(object)\n        ? equalArrays(object, other, bitmask, customizer, equalFunc, stack)\n        : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack)\n    }\n    if (!(bitmask & COMPARE_PARTIAL_FLAG$2)) {\n      var objIsWrapped = objIsObj && hasOwnProperty$4.call(object, '__wrapped__'),\n        othIsWrapped = othIsObj && hasOwnProperty$4.call(other, '__wrapped__')\n\n      if (objIsWrapped || othIsWrapped) {\n        var objUnwrapped = objIsWrapped ? object.value() : object,\n          othUnwrapped = othIsWrapped ? other.value() : other\n\n        stack || (stack = new Stack())\n        return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack)\n      }\n    }\n    if (!isSameTag) {\n      return false\n    }\n    stack || (stack = new Stack())\n    return equalObjects(object, other, bitmask, customizer, equalFunc, stack)\n  }\n\n  /**\n   * The base implementation of `_.isEqual` which supports partial comparisons\n   * and tracks traversed objects.\n   *\n   * @private\n   * @param {*} value The value to compare.\n   * @param {*} other The other value to compare.\n   * @param {boolean} bitmask The bitmask flags.\n   *  1 - Unordered comparison\n   *  2 - Partial comparison\n   * @param {Function} [customizer] The function to customize comparisons.\n   * @param {Object} [stack] Tracks traversed `value` and `other` objects.\n   * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n   */\n  function baseIsEqual(value, other, bitmask, customizer, stack) {\n    if (value === other) {\n      return true\n    }\n    if (value == null || other == null || (!isObjectLike(value) && !isObjectLike(other))) {\n      return value !== value && other !== other\n    }\n    return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack)\n  }\n\n  /** Used to compose bitmasks for value comparisons. */\n  var COMPARE_PARTIAL_FLAG$1 = 1,\n    COMPARE_UNORDERED_FLAG$1 = 2\n\n  /**\n   * The base implementation of `_.isMatch` without support for iteratee shorthands.\n   *\n   * @private\n   * @param {Object} object The object to inspect.\n   * @param {Object} source The object of property values to match.\n   * @param {Array} matchData The property names, values, and compare flags to match.\n   * @param {Function} [customizer] The function to customize comparisons.\n   * @returns {boolean} Returns `true` if `object` is a match, else `false`.\n   */\n  function baseIsMatch(object, source, matchData, customizer) {\n    var index = matchData.length,\n      length = index,\n      noCustomizer = !customizer\n\n    if (object == null) {\n      return !length\n    }\n    object = Object(object)\n    while (index--) {\n      var data = matchData[index]\n      if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {\n        return false\n      }\n    }\n    while (++index < length) {\n      data = matchData[index]\n      var key = data[0],\n        objValue = object[key],\n        srcValue = data[1]\n\n      if (noCustomizer && data[2]) {\n        if (objValue === undefined && !(key in object)) {\n          return false\n        }\n      } else {\n        var stack = new Stack()\n        if (customizer) {\n          var result = customizer(objValue, srcValue, key, object, source, stack)\n        }\n        if (\n          !(result === undefined\n            ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG$1 | COMPARE_UNORDERED_FLAG$1, customizer, stack)\n            : result)\n        ) {\n          return false\n        }\n      }\n    }\n    return true\n  }\n\n  /**\n   * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.\n   *\n   * @private\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` if suitable for strict\n   *  equality comparisons, else `false`.\n   */\n  function isStrictComparable(value) {\n    return value === value && !isObject(value)\n  }\n\n  /**\n   * Gets the property names, values, and compare flags of `object`.\n   *\n   * @private\n   * @param {Object} object The object to query.\n   * @returns {Array} Returns the match data of `object`.\n   */\n  function getMatchData(object) {\n    var result = keys(object),\n      length = result.length\n\n    while (length--) {\n      var key = result[length],\n        value = object[key]\n\n      result[length] = [key, value, isStrictComparable(value)]\n    }\n    return result\n  }\n\n  /**\n   * A specialized version of `matchesProperty` for source values suitable\n   * for strict equality comparisons, i.e. `===`.\n   *\n   * @private\n   * @param {string} key The key of the property to get.\n   * @param {*} srcValue The value to match.\n   * @returns {Function} Returns the new spec function.\n   */\n  function matchesStrictComparable(key, srcValue) {\n    return function (object) {\n      if (object == null) {\n        return false\n      }\n      return object[key] === srcValue && (srcValue !== undefined || key in Object(object))\n    }\n  }\n\n  /**\n   * The base implementation of `_.matches` which doesn't clone `source`.\n   *\n   * @private\n   * @param {Object} source The object of property values to match.\n   * @returns {Function} Returns the new spec function.\n   */\n  function baseMatches(source) {\n    var matchData = getMatchData(source)\n    if (matchData.length == 1 && matchData[0][2]) {\n      return matchesStrictComparable(matchData[0][0], matchData[0][1])\n    }\n    return function (object) {\n      return object === source || baseIsMatch(object, source, matchData)\n    }\n  }\n\n  /**\n   * The base implementation of `_.hasIn` without support for deep paths.\n   *\n   * @private\n   * @param {Object} [object] The object to query.\n   * @param {Array|string} key The key to check.\n   * @returns {boolean} Returns `true` if `key` exists, else `false`.\n   */\n  function baseHasIn(object, key) {\n    return object != null && key in Object(object)\n  }\n\n  /**\n   * Checks if `path` exists on `object`.\n   *\n   * @private\n   * @param {Object} object The object to query.\n   * @param {Array|string} path The path to check.\n   * @param {Function} hasFunc The function to check properties.\n   * @returns {boolean} Returns `true` if `path` exists, else `false`.\n   */\n  function hasPath(object, path, hasFunc) {\n    path = castPath(path, object)\n\n    var index = -1,\n      length = path.length,\n      result = false\n\n    while (++index < length) {\n      var key = toKey(path[index])\n      if (!(result = object != null && hasFunc(object, key))) {\n        break\n      }\n      object = object[key]\n    }\n    if (result || ++index != length) {\n      return result\n    }\n    length = object == null ? 0 : object.length\n    return !!length && isLength(length) && isIndex(key, length) && (isArray$1(object) || isArguments$1(object))\n  }\n\n  /**\n   * Checks if `path` is a direct or inherited property of `object`.\n   *\n   * @static\n   * @memberOf _\n   * @since 4.0.0\n   * @category Object\n   * @param {Object} object The object to query.\n   * @param {Array|string} path The path to check.\n   * @returns {boolean} Returns `true` if `path` exists, else `false`.\n   * @example\n   *\n   * var object = _.create({ 'a': _.create({ 'b': 2 }) });\n   *\n   * _.hasIn(object, 'a');\n   * // => true\n   *\n   * _.hasIn(object, 'a.b');\n   * // => true\n   *\n   * _.hasIn(object, ['a', 'b']);\n   * // => true\n   *\n   * _.hasIn(object, 'b');\n   * // => false\n   */\n  function hasIn(object, path) {\n    return object != null && hasPath(object, path, baseHasIn)\n  }\n\n  /** Used to compose bitmasks for value comparisons. */\n  var COMPARE_PARTIAL_FLAG = 1,\n    COMPARE_UNORDERED_FLAG = 2\n\n  /**\n   * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.\n   *\n   * @private\n   * @param {string} path The path of the property to get.\n   * @param {*} srcValue The value to match.\n   * @returns {Function} Returns the new spec function.\n   */\n  function baseMatchesProperty(path, srcValue) {\n    if (isKey(path) && isStrictComparable(srcValue)) {\n      return matchesStrictComparable(toKey(path), srcValue)\n    }\n    return function (object) {\n      var objValue = get(object, path)\n      return objValue === undefined && objValue === srcValue\n        ? hasIn(object, path)\n        : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG)\n    }\n  }\n\n  /**\n   * The base implementation of `_.property` without support for deep paths.\n   *\n   * @private\n   * @param {string} key The key of the property to get.\n   * @returns {Function} Returns the new accessor function.\n   */\n  function baseProperty(key) {\n    return function (object) {\n      return object == null ? undefined : object[key]\n    }\n  }\n\n  /**\n   * A specialized version of `baseProperty` which supports deep paths.\n   *\n   * @private\n   * @param {Array|string} path The path of the property to get.\n   * @returns {Function} Returns the new accessor function.\n   */\n  function basePropertyDeep(path) {\n    return function (object) {\n      return baseGet(object, path)\n    }\n  }\n\n  /**\n   * Creates a function that returns the value at `path` of a given object.\n   *\n   * @static\n   * @memberOf _\n   * @since 2.4.0\n   * @category Util\n   * @param {Array|string} path The path of the property to get.\n   * @returns {Function} Returns the new accessor function.\n   * @example\n   *\n   * var objects = [\n   *   { 'a': { 'b': 2 } },\n   *   { 'a': { 'b': 1 } }\n   * ];\n   *\n   * _.map(objects, _.property('a.b'));\n   * // => [2, 1]\n   *\n   * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');\n   * // => [1, 2]\n   */\n  function property(path) {\n    return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path)\n  }\n\n  /**\n   * The base implementation of `_.iteratee`.\n   *\n   * @private\n   * @param {*} [value=_.identity] The value to convert to an iteratee.\n   * @returns {Function} Returns the iteratee.\n   */\n  function baseIteratee(value) {\n    // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.\n    // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.\n    if (typeof value == 'function') {\n      return value\n    }\n    if (value == null) {\n      return identity\n    }\n    if (typeof value == 'object') {\n      return isArray$1(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value)\n    }\n    return property(value)\n  }\n\n  /**\n   * A specialized version of `baseAggregator` for arrays.\n   *\n   * @private\n   * @param {Array} [array] The array to iterate over.\n   * @param {Function} setter The function to set `accumulator` values.\n   * @param {Function} iteratee The iteratee to transform keys.\n   * @param {Object} accumulator The initial aggregated object.\n   * @returns {Function} Returns `accumulator`.\n   */\n  function arrayAggregator(array, setter, iteratee, accumulator) {\n    var index = -1,\n      length = array == null ? 0 : array.length\n\n    while (++index < length) {\n      var value = array[index]\n      setter(accumulator, value, iteratee(value), array)\n    }\n    return accumulator\n  }\n\n  /**\n   * Creates a base function for methods like `_.forIn` and `_.forOwn`.\n   *\n   * @private\n   * @param {boolean} [fromRight] Specify iterating from right to left.\n   * @returns {Function} Returns the new base function.\n   */\n  function createBaseFor(fromRight) {\n    return function (object, iteratee, keysFunc) {\n      var index = -1,\n        iterable = Object(object),\n        props = keysFunc(object),\n        length = props.length\n\n      while (length--) {\n        var key = props[fromRight ? length : ++index]\n        if (iteratee(iterable[key], key, iterable) === false) {\n          break\n        }\n      }\n      return object\n    }\n  }\n\n  /**\n   * The base implementation of `baseForOwn` which iterates over `object`\n   * properties returned by `keysFunc` and invokes `iteratee` for each property.\n   * Iteratee functions may exit iteration early by explicitly returning `false`.\n   *\n   * @private\n   * @param {Object} object The object to iterate over.\n   * @param {Function} iteratee The function invoked per iteration.\n   * @param {Function} keysFunc The function to get the keys of `object`.\n   * @returns {Object} Returns `object`.\n   */\n  var baseFor = createBaseFor()\n\n  const baseFor$1 = baseFor\n\n  /**\n   * The base implementation of `_.forOwn` without support for iteratee shorthands.\n   *\n   * @private\n   * @param {Object} object The object to iterate over.\n   * @param {Function} iteratee The function invoked per iteration.\n   * @returns {Object} Returns `object`.\n   */\n  function baseForOwn(object, iteratee) {\n    return object && baseFor$1(object, iteratee, keys)\n  }\n\n  /**\n   * Creates a `baseEach` or `baseEachRight` function.\n   *\n   * @private\n   * @param {Function} eachFunc The function to iterate over a collection.\n   * @param {boolean} [fromRight] Specify iterating from right to left.\n   * @returns {Function} Returns the new base function.\n   */\n  function createBaseEach(eachFunc, fromRight) {\n    return function (collection, iteratee) {\n      if (collection == null) {\n        return collection\n      }\n      if (!isArrayLike(collection)) {\n        return eachFunc(collection, iteratee)\n      }\n      var length = collection.length,\n        index = fromRight ? length : -1,\n        iterable = Object(collection)\n\n      while (fromRight ? index-- : ++index < length) {\n        if (iteratee(iterable[index], index, iterable) === false) {\n          break\n        }\n      }\n      return collection\n    }\n  }\n\n  /**\n   * The base implementation of `_.forEach` without support for iteratee shorthands.\n   *\n   * @private\n   * @param {Array|Object} collection The collection to iterate over.\n   * @param {Function} iteratee The function invoked per iteration.\n   * @returns {Array|Object} Returns `collection`.\n   */\n  var baseEach = createBaseEach(baseForOwn)\n\n  const baseEach$1 = baseEach\n\n  /**\n   * Aggregates elements of `collection` on `accumulator` with keys transformed\n   * by `iteratee` and values set by `setter`.\n   *\n   * @private\n   * @param {Array|Object} collection The collection to iterate over.\n   * @param {Function} setter The function to set `accumulator` values.\n   * @param {Function} iteratee The iteratee to transform keys.\n   * @param {Object} accumulator The initial aggregated object.\n   * @returns {Function} Returns `accumulator`.\n   */\n  function baseAggregator(collection, setter, iteratee, accumulator) {\n    baseEach$1(collection, function (value, key, collection) {\n      setter(accumulator, value, iteratee(value), collection)\n    })\n    return accumulator\n  }\n\n  /**\n   * Creates a function like `_.groupBy`.\n   *\n   * @private\n   * @param {Function} setter The function to set accumulator values.\n   * @param {Function} [initializer] The accumulator object initializer.\n   * @returns {Function} Returns the new aggregator function.\n   */\n  function createAggregator(setter, initializer) {\n    return function (collection, iteratee) {\n      var func = isArray$1(collection) ? arrayAggregator : baseAggregator,\n        accumulator = initializer ? initializer() : {}\n\n      return func(collection, setter, baseIteratee(iteratee), accumulator)\n    }\n  }\n\n  /** Used for built-in method references. */\n  var objectProto$3 = Object.prototype\n\n  /** Used to check objects for own properties. */\n  var hasOwnProperty$3 = objectProto$3.hasOwnProperty\n\n  /**\n   * Assigns own and inherited enumerable string keyed properties of source\n   * objects to the destination object for all destination properties that\n   * resolve to `undefined`. Source objects are applied from left to right.\n   * Once a property is set, additional values of the same property are ignored.\n   *\n   * **Note:** This method mutates `object`.\n   *\n   * @static\n   * @since 0.1.0\n   * @memberOf _\n   * @category Object\n   * @param {Object} object The destination object.\n   * @param {...Object} [sources] The source objects.\n   * @returns {Object} Returns `object`.\n   * @see _.defaultsDeep\n   * @example\n   *\n   * _.defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });\n   * // => { 'a': 1, 'b': 2 }\n   */\n  var defaults = baseRest(function (object, sources) {\n    object = Object(object)\n\n    var index = -1\n    var length = sources.length\n    var guard = length > 2 ? sources[2] : undefined\n\n    if (guard && isIterateeCall(sources[0], sources[1], guard)) {\n      length = 1\n    }\n\n    while (++index < length) {\n      var source = sources[index]\n      var props = keysIn(source)\n      var propsIndex = -1\n      var propsLength = props.length\n\n      while (++propsIndex < propsLength) {\n        var key = props[propsIndex]\n        var value = object[key]\n\n        if (value === undefined || (eq(value, objectProto$3[key]) && !hasOwnProperty$3.call(object, key))) {\n          object[key] = source[key]\n        }\n      }\n    }\n\n    return object\n  })\n\n  const defaults$1 = defaults\n\n  /**\n   * This method is like `_.isArrayLike` except that it also checks if `value`\n   * is an object.\n   *\n   * @static\n   * @memberOf _\n   * @since 4.0.0\n   * @category Lang\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is an array-like object,\n   *  else `false`.\n   * @example\n   *\n   * _.isArrayLikeObject([1, 2, 3]);\n   * // => true\n   *\n   * _.isArrayLikeObject(document.body.children);\n   * // => true\n   *\n   * _.isArrayLikeObject('abc');\n   * // => false\n   *\n   * _.isArrayLikeObject(_.noop);\n   * // => false\n   */\n  function isArrayLikeObject(value) {\n    return isObjectLike(value) && isArrayLike(value)\n  }\n\n  /**\n   * This function is like `arrayIncludes` except that it accepts a comparator.\n   *\n   * @private\n   * @param {Array} [array] The array to inspect.\n   * @param {*} target The value to search for.\n   * @param {Function} comparator The comparator invoked per element.\n   * @returns {boolean} Returns `true` if `target` is found, else `false`.\n   */\n  function arrayIncludesWith(array, value, comparator) {\n    var index = -1,\n      length = array == null ? 0 : array.length\n\n    while (++index < length) {\n      if (comparator(value, array[index])) {\n        return true\n      }\n    }\n    return false\n  }\n\n  /** Used as the size to enable large array optimizations. */\n  var LARGE_ARRAY_SIZE$1 = 200\n\n  /**\n   * The base implementation of methods like `_.difference` without support\n   * for excluding multiple arrays or iteratee shorthands.\n   *\n   * @private\n   * @param {Array} array The array to inspect.\n   * @param {Array} values The values to exclude.\n   * @param {Function} [iteratee] The iteratee invoked per element.\n   * @param {Function} [comparator] The comparator invoked per element.\n   * @returns {Array} Returns the new array of filtered values.\n   */\n  function baseDifference(array, values, iteratee, comparator) {\n    var index = -1,\n      includes = arrayIncludes,\n      isCommon = true,\n      length = array.length,\n      result = [],\n      valuesLength = values.length\n\n    if (!length) {\n      return result\n    }\n    if (iteratee) {\n      values = arrayMap(values, baseUnary(iteratee))\n    }\n    if (comparator) {\n      includes = arrayIncludesWith\n      isCommon = false\n    } else if (values.length >= LARGE_ARRAY_SIZE$1) {\n      includes = cacheHas\n      isCommon = false\n      values = new SetCache(values)\n    }\n    outer: while (++index < length) {\n      var value = array[index],\n        computed = iteratee == null ? value : iteratee(value)\n\n      value = comparator || value !== 0 ? value : 0\n      if (isCommon && computed === computed) {\n        var valuesIndex = valuesLength\n        while (valuesIndex--) {\n          if (values[valuesIndex] === computed) {\n            continue outer\n          }\n        }\n        result.push(value)\n      } else if (!includes(values, computed, comparator)) {\n        result.push(value)\n      }\n    }\n    return result\n  }\n\n  /**\n   * Creates an array of `array` values not included in the other given arrays\n   * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n   * for equality comparisons. The order and references of result values are\n   * determined by the first array.\n   *\n   * **Note:** Unlike `_.pullAll`, this method returns a new array.\n   *\n   * @static\n   * @memberOf _\n   * @since 0.1.0\n   * @category Array\n   * @param {Array} array The array to inspect.\n   * @param {...Array} [values] The values to exclude.\n   * @returns {Array} Returns the new array of filtered values.\n   * @see _.without, _.xor\n   * @example\n   *\n   * _.difference([2, 1], [2, 3]);\n   * // => [1]\n   */\n  var difference = baseRest(function (array, values) {\n    return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true)) : []\n  })\n\n  const difference$1 = difference\n\n  /**\n   * Gets the last element of `array`.\n   *\n   * @static\n   * @memberOf _\n   * @since 0.1.0\n   * @category Array\n   * @param {Array} array The array to query.\n   * @returns {*} Returns the last element of `array`.\n   * @example\n   *\n   * _.last([1, 2, 3]);\n   * // => 3\n   */\n  function last(array) {\n    var length = array == null ? 0 : array.length\n    return length ? array[length - 1] : undefined\n  }\n\n  /**\n   * Creates a slice of `array` with `n` elements dropped from the beginning.\n   *\n   * @static\n   * @memberOf _\n   * @since 0.5.0\n   * @category Array\n   * @param {Array} array The array to query.\n   * @param {number} [n=1] The number of elements to drop.\n   * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n   * @returns {Array} Returns the slice of `array`.\n   * @example\n   *\n   * _.drop([1, 2, 3]);\n   * // => [2, 3]\n   *\n   * _.drop([1, 2, 3], 2);\n   * // => [3]\n   *\n   * _.drop([1, 2, 3], 5);\n   * // => []\n   *\n   * _.drop([1, 2, 3], 0);\n   * // => [1, 2, 3]\n   */\n  function drop(array, n, guard) {\n    var length = array == null ? 0 : array.length\n    if (!length) {\n      return []\n    }\n    n = guard || n === undefined ? 1 : toInteger(n)\n    return baseSlice(array, n < 0 ? 0 : n, length)\n  }\n\n  /**\n   * Creates a slice of `array` with `n` elements dropped from the end.\n   *\n   * @static\n   * @memberOf _\n   * @since 3.0.0\n   * @category Array\n   * @param {Array} array The array to query.\n   * @param {number} [n=1] The number of elements to drop.\n   * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n   * @returns {Array} Returns the slice of `array`.\n   * @example\n   *\n   * _.dropRight([1, 2, 3]);\n   * // => [1, 2]\n   *\n   * _.dropRight([1, 2, 3], 2);\n   * // => [1]\n   *\n   * _.dropRight([1, 2, 3], 5);\n   * // => []\n   *\n   * _.dropRight([1, 2, 3], 0);\n   * // => [1, 2, 3]\n   */\n  function dropRight(array, n, guard) {\n    var length = array == null ? 0 : array.length\n    if (!length) {\n      return []\n    }\n    n = guard || n === undefined ? 1 : toInteger(n)\n    n = length - n\n    return baseSlice(array, 0, n < 0 ? 0 : n)\n  }\n\n  /**\n   * Casts `value` to `identity` if it's not a function.\n   *\n   * @private\n   * @param {*} value The value to inspect.\n   * @returns {Function} Returns cast function.\n   */\n  function castFunction(value) {\n    return typeof value == 'function' ? value : identity\n  }\n\n  /**\n   * Iterates over elements of `collection` and invokes `iteratee` for each element.\n   * The iteratee is invoked with three arguments: (value, index|key, collection).\n   * Iteratee functions may exit iteration early by explicitly returning `false`.\n   *\n   * **Note:** As with other \"Collections\" methods, objects with a \"length\"\n   * property are iterated like arrays. To avoid this behavior use `_.forIn`\n   * or `_.forOwn` for object iteration.\n   *\n   * @static\n   * @memberOf _\n   * @since 0.1.0\n   * @alias each\n   * @category Collection\n   * @param {Array|Object} collection The collection to iterate over.\n   * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n   * @returns {Array|Object} Returns `collection`.\n   * @see _.forEachRight\n   * @example\n   *\n   * _.forEach([1, 2], function(value) {\n   *   console.log(value);\n   * });\n   * // => Logs `1` then `2`.\n   *\n   * _.forEach({ 'a': 1, 'b': 2 }, function(value, key) {\n   *   console.log(key);\n   * });\n   * // => Logs 'a' then 'b' (iteration order is not guaranteed).\n   */\n  function forEach(collection, iteratee) {\n    var func = isArray$1(collection) ? arrayEach : baseEach$1\n    return func(collection, castFunction(iteratee))\n  }\n\n  /**\n   * A specialized version of `_.every` for arrays without support for\n   * iteratee shorthands.\n   *\n   * @private\n   * @param {Array} [array] The array to iterate over.\n   * @param {Function} predicate The function invoked per iteration.\n   * @returns {boolean} Returns `true` if all elements pass the predicate check,\n   *  else `false`.\n   */\n  function arrayEvery(array, predicate) {\n    var index = -1,\n      length = array == null ? 0 : array.length\n\n    while (++index < length) {\n      if (!predicate(array[index], index, array)) {\n        return false\n      }\n    }\n    return true\n  }\n\n  /**\n   * The base implementation of `_.every` without support for iteratee shorthands.\n   *\n   * @private\n   * @param {Array|Object} collection The collection to iterate over.\n   * @param {Function} predicate The function invoked per iteration.\n   * @returns {boolean} Returns `true` if all elements pass the predicate check,\n   *  else `false`\n   */\n  function baseEvery(collection, predicate) {\n    var result = true\n    baseEach$1(collection, function (value, index, collection) {\n      result = !!predicate(value, index, collection)\n      return result\n    })\n    return result\n  }\n\n  /**\n   * Checks if `predicate` returns truthy for **all** elements of `collection`.\n   * Iteration is stopped once `predicate` returns falsey. The predicate is\n   * invoked with three arguments: (value, index|key, collection).\n   *\n   * **Note:** This method returns `true` for\n   * [empty collections](https://en.wikipedia.org/wiki/Empty_set) because\n   * [everything is true](https://en.wikipedia.org/wiki/Vacuous_truth) of\n   * elements of empty collections.\n   *\n   * @static\n   * @memberOf _\n   * @since 0.1.0\n   * @category Collection\n   * @param {Array|Object} collection The collection to iterate over.\n   * @param {Function} [predicate=_.identity] The function invoked per iteration.\n   * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n   * @returns {boolean} Returns `true` if all elements pass the predicate check,\n   *  else `false`.\n   * @example\n   *\n   * _.every([true, 1, null, 'yes'], Boolean);\n   * // => false\n   *\n   * var users = [\n   *   { 'user': 'barney', 'age': 36, 'active': false },\n   *   { 'user': 'fred',   'age': 40, 'active': false }\n   * ];\n   *\n   * // The `_.matches` iteratee shorthand.\n   * _.every(users, { 'user': 'barney', 'active': false });\n   * // => false\n   *\n   * // The `_.matchesProperty` iteratee shorthand.\n   * _.every(users, ['active', false]);\n   * // => true\n   *\n   * // The `_.property` iteratee shorthand.\n   * _.every(users, 'active');\n   * // => false\n   */\n  function every(collection, predicate, guard) {\n    var func = isArray$1(collection) ? arrayEvery : baseEvery\n    if (guard && isIterateeCall(collection, predicate, guard)) {\n      predicate = undefined\n    }\n    return func(collection, baseIteratee(predicate))\n  }\n\n  /**\n   * The base implementation of `_.filter` without support for iteratee shorthands.\n   *\n   * @private\n   * @param {Array|Object} collection The collection to iterate over.\n   * @param {Function} predicate The function invoked per iteration.\n   * @returns {Array} Returns the new filtered array.\n   */\n  function baseFilter(collection, predicate) {\n    var result = []\n    baseEach$1(collection, function (value, index, collection) {\n      if (predicate(value, index, collection)) {\n        result.push(value)\n      }\n    })\n    return result\n  }\n\n  /**\n   * Iterates over elements of `collection`, returning an array of all elements\n   * `predicate` returns truthy for. The predicate is invoked with three\n   * arguments: (value, index|key, collection).\n   *\n   * **Note:** Unlike `_.remove`, this method returns a new array.\n   *\n   * @static\n   * @memberOf _\n   * @since 0.1.0\n   * @category Collection\n   * @param {Array|Object} collection The collection to iterate over.\n   * @param {Function} [predicate=_.identity] The function invoked per iteration.\n   * @returns {Array} Returns the new filtered array.\n   * @see _.reject\n   * @example\n   *\n   * var users = [\n   *   { 'user': 'barney', 'age': 36, 'active': true },\n   *   { 'user': 'fred',   'age': 40, 'active': false }\n   * ];\n   *\n   * _.filter(users, function(o) { return !o.active; });\n   * // => objects for ['fred']\n   *\n   * // The `_.matches` iteratee shorthand.\n   * _.filter(users, { 'age': 36, 'active': true });\n   * // => objects for ['barney']\n   *\n   * // The `_.matchesProperty` iteratee shorthand.\n   * _.filter(users, ['active', false]);\n   * // => objects for ['fred']\n   *\n   * // The `_.property` iteratee shorthand.\n   * _.filter(users, 'active');\n   * // => objects for ['barney']\n   *\n   * // Combining several predicates using `_.overEvery` or `_.overSome`.\n   * _.filter(users, _.overSome([{ 'age': 36 }, ['age', 40]]));\n   * // => objects for ['fred', 'barney']\n   */\n  function filter(collection, predicate) {\n    var func = isArray$1(collection) ? arrayFilter : baseFilter\n    return func(collection, baseIteratee(predicate))\n  }\n\n  /**\n   * Creates a `_.find` or `_.findLast` function.\n   *\n   * @private\n   * @param {Function} findIndexFunc The function to find the collection index.\n   * @returns {Function} Returns the new find function.\n   */\n  function createFind(findIndexFunc) {\n    return function (collection, predicate, fromIndex) {\n      var iterable = Object(collection)\n      if (!isArrayLike(collection)) {\n        var iteratee = baseIteratee(predicate)\n        collection = keys(collection)\n        predicate = function (key) {\n          return iteratee(iterable[key], key, iterable)\n        }\n      }\n      var index = findIndexFunc(collection, predicate, fromIndex)\n      return index > -1 ? iterable[iteratee ? collection[index] : index] : undefined\n    }\n  }\n\n  /* Built-in method references for those with the same name as other `lodash` methods. */\n  var nativeMax$2 = Math.max\n\n  /**\n   * This method is like `_.find` except that it returns the index of the first\n   * element `predicate` returns truthy for instead of the element itself.\n   *\n   * @static\n   * @memberOf _\n   * @since 1.1.0\n   * @category Array\n   * @param {Array} array The array to inspect.\n   * @param {Function} [predicate=_.identity] The function invoked per iteration.\n   * @param {number} [fromIndex=0] The index to search from.\n   * @returns {number} Returns the index of the found element, else `-1`.\n   * @example\n   *\n   * var users = [\n   *   { 'user': 'barney',  'active': false },\n   *   { 'user': 'fred',    'active': false },\n   *   { 'user': 'pebbles', 'active': true }\n   * ];\n   *\n   * _.findIndex(users, function(o) { return o.user == 'barney'; });\n   * // => 0\n   *\n   * // The `_.matches` iteratee shorthand.\n   * _.findIndex(users, { 'user': 'fred', 'active': false });\n   * // => 1\n   *\n   * // The `_.matchesProperty` iteratee shorthand.\n   * _.findIndex(users, ['active', false]);\n   * // => 0\n   *\n   * // The `_.property` iteratee shorthand.\n   * _.findIndex(users, 'active');\n   * // => 2\n   */\n  function findIndex(array, predicate, fromIndex) {\n    var length = array == null ? 0 : array.length\n    if (!length) {\n      return -1\n    }\n    var index = fromIndex == null ? 0 : toInteger(fromIndex)\n    if (index < 0) {\n      index = nativeMax$2(length + index, 0)\n    }\n    return baseFindIndex(array, baseIteratee(predicate), index)\n  }\n\n  /**\n   * Iterates over elements of `collection`, returning the first element\n   * `predicate` returns truthy for. The predicate is invoked with three\n   * arguments: (value, index|key, collection).\n   *\n   * @static\n   * @memberOf _\n   * @since 0.1.0\n   * @category Collection\n   * @param {Array|Object} collection The collection to inspect.\n   * @param {Function} [predicate=_.identity] The function invoked per iteration.\n   * @param {number} [fromIndex=0] The index to search from.\n   * @returns {*} Returns the matched element, else `undefined`.\n   * @example\n   *\n   * var users = [\n   *   { 'user': 'barney',  'age': 36, 'active': true },\n   *   { 'user': 'fred',    'age': 40, 'active': false },\n   *   { 'user': 'pebbles', 'age': 1,  'active': true }\n   * ];\n   *\n   * _.find(users, function(o) { return o.age < 40; });\n   * // => object for 'barney'\n   *\n   * // The `_.matches` iteratee shorthand.\n   * _.find(users, { 'age': 1, 'active': true });\n   * // => object for 'pebbles'\n   *\n   * // The `_.matchesProperty` iteratee shorthand.\n   * _.find(users, ['active', false]);\n   * // => object for 'fred'\n   *\n   * // The `_.property` iteratee shorthand.\n   * _.find(users, 'active');\n   * // => object for 'barney'\n   */\n  var find = createFind(findIndex)\n\n  const find$1 = find\n\n  /**\n   * Gets the first element of `array`.\n   *\n   * @static\n   * @memberOf _\n   * @since 0.1.0\n   * @alias first\n   * @category Array\n   * @param {Array} array The array to query.\n   * @returns {*} Returns the first element of `array`.\n   * @example\n   *\n   * _.head([1, 2, 3]);\n   * // => 1\n   *\n   * _.head([]);\n   * // => undefined\n   */\n  function head(array) {\n    return array && array.length ? array[0] : undefined\n  }\n\n  /**\n   * The base implementation of `_.map` without support for iteratee shorthands.\n   *\n   * @private\n   * @param {Array|Object} collection The collection to iterate over.\n   * @param {Function} iteratee The function invoked per iteration.\n   * @returns {Array} Returns the new mapped array.\n   */\n  function baseMap(collection, iteratee) {\n    var index = -1,\n      result = isArrayLike(collection) ? Array(collection.length) : []\n\n    baseEach$1(collection, function (value, key, collection) {\n      result[++index] = iteratee(value, key, collection)\n    })\n    return result\n  }\n\n  /**\n   * Creates an array of values by running each element in `collection` thru\n   * `iteratee`. The iteratee is invoked with three arguments:\n   * (value, index|key, collection).\n   *\n   * Many lodash methods are guarded to work as iteratees for methods like\n   * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.\n   *\n   * The guarded methods are:\n   * `ary`, `chunk`, `curry`, `curryRight`, `drop`, `dropRight`, `every`,\n   * `fill`, `invert`, `parseInt`, `random`, `range`, `rangeRight`, `repeat`,\n   * `sampleSize`, `slice`, `some`, `sortBy`, `split`, `take`, `takeRight`,\n   * `template`, `trim`, `trimEnd`, `trimStart`, and `words`\n   *\n   * @static\n   * @memberOf _\n   * @since 0.1.0\n   * @category Collection\n   * @param {Array|Object} collection The collection to iterate over.\n   * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n   * @returns {Array} Returns the new mapped array.\n   * @example\n   *\n   * function square(n) {\n   *   return n * n;\n   * }\n   *\n   * _.map([4, 8], square);\n   * // => [16, 64]\n   *\n   * _.map({ 'a': 4, 'b': 8 }, square);\n   * // => [16, 64] (iteration order is not guaranteed)\n   *\n   * var users = [\n   *   { 'user': 'barney' },\n   *   { 'user': 'fred' }\n   * ];\n   *\n   * // The `_.property` iteratee shorthand.\n   * _.map(users, 'user');\n   * // => ['barney', 'fred']\n   */\n  function map(collection, iteratee) {\n    var func = isArray$1(collection) ? arrayMap : baseMap\n    return func(collection, baseIteratee(iteratee))\n  }\n\n  /**\n   * Creates a flattened array of values by running each element in `collection`\n   * thru `iteratee` and flattening the mapped results. The iteratee is invoked\n   * with three arguments: (value, index|key, collection).\n   *\n   * @static\n   * @memberOf _\n   * @since 4.0.0\n   * @category Collection\n   * @param {Array|Object} collection The collection to iterate over.\n   * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n   * @returns {Array} Returns the new flattened array.\n   * @example\n   *\n   * function duplicate(n) {\n   *   return [n, n];\n   * }\n   *\n   * _.flatMap([1, 2], duplicate);\n   * // => [1, 1, 2, 2]\n   */\n  function flatMap(collection, iteratee) {\n    return baseFlatten(map(collection, iteratee), 1)\n  }\n\n  /** Used for built-in method references. */\n  var objectProto$2 = Object.prototype\n\n  /** Used to check objects for own properties. */\n  var hasOwnProperty$2 = objectProto$2.hasOwnProperty\n\n  /**\n   * Creates an object composed of keys generated from the results of running\n   * each element of `collection` thru `iteratee`. The order of grouped values\n   * is determined by the order they occur in `collection`. The corresponding\n   * value of each key is an array of elements responsible for generating the\n   * key. The iteratee is invoked with one argument: (value).\n   *\n   * @static\n   * @memberOf _\n   * @since 0.1.0\n   * @category Collection\n   * @param {Array|Object} collection The collection to iterate over.\n   * @param {Function} [iteratee=_.identity] The iteratee to transform keys.\n   * @returns {Object} Returns the composed aggregate object.\n   * @example\n   *\n   * _.groupBy([6.1, 4.2, 6.3], Math.floor);\n   * // => { '4': [4.2], '6': [6.1, 6.3] }\n   *\n   * // The `_.property` iteratee shorthand.\n   * _.groupBy(['one', 'two', 'three'], 'length');\n   * // => { '3': ['one', 'two'], '5': ['three'] }\n   */\n  var groupBy = createAggregator(function (result, value, key) {\n    if (hasOwnProperty$2.call(result, key)) {\n      result[key].push(value)\n    } else {\n      baseAssignValue(result, key, [value])\n    }\n  })\n\n  const groupBy$1 = groupBy\n\n  /** Used for built-in method references. */\n  var objectProto$1 = Object.prototype\n\n  /** Used to check objects for own properties. */\n  var hasOwnProperty$1 = objectProto$1.hasOwnProperty\n\n  /**\n   * The base implementation of `_.has` without support for deep paths.\n   *\n   * @private\n   * @param {Object} [object] The object to query.\n   * @param {Array|string} key The key to check.\n   * @returns {boolean} Returns `true` if `key` exists, else `false`.\n   */\n  function baseHas(object, key) {\n    return object != null && hasOwnProperty$1.call(object, key)\n  }\n\n  /**\n   * Checks if `path` is a direct property of `object`.\n   *\n   * @static\n   * @since 0.1.0\n   * @memberOf _\n   * @category Object\n   * @param {Object} object The object to query.\n   * @param {Array|string} path The path to check.\n   * @returns {boolean} Returns `true` if `path` exists, else `false`.\n   * @example\n   *\n   * var object = { 'a': { 'b': 2 } };\n   * var other = _.create({ 'a': _.create({ 'b': 2 }) });\n   *\n   * _.has(object, 'a');\n   * // => true\n   *\n   * _.has(object, 'a.b');\n   * // => true\n   *\n   * _.has(object, ['a', 'b']);\n   * // => true\n   *\n   * _.has(other, 'a');\n   * // => false\n   */\n  function has(object, path) {\n    return object != null && hasPath(object, path, baseHas)\n  }\n\n  /** `Object#toString` result references. */\n  var stringTag = '[object String]'\n\n  /**\n   * Checks if `value` is classified as a `String` primitive or object.\n   *\n   * @static\n   * @since 0.1.0\n   * @memberOf _\n   * @category Lang\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is a string, else `false`.\n   * @example\n   *\n   * _.isString('abc');\n   * // => true\n   *\n   * _.isString(1);\n   * // => false\n   */\n  function isString(value) {\n    return typeof value == 'string' || (!isArray$1(value) && isObjectLike(value) && baseGetTag(value) == stringTag)\n  }\n\n  /**\n   * The base implementation of `_.values` and `_.valuesIn` which creates an\n   * array of `object` property values corresponding to the property names\n   * of `props`.\n   *\n   * @private\n   * @param {Object} object The object to query.\n   * @param {Array} props The property names to get values for.\n   * @returns {Object} Returns the array of property values.\n   */\n  function baseValues(object, props) {\n    return arrayMap(props, function (key) {\n      return object[key]\n    })\n  }\n\n  /**\n   * Creates an array of the own enumerable string keyed property values of `object`.\n   *\n   * **Note:** Non-object values are coerced to objects.\n   *\n   * @static\n   * @since 0.1.0\n   * @memberOf _\n   * @category Object\n   * @param {Object} object The object to query.\n   * @returns {Array} Returns the array of property values.\n   * @example\n   *\n   * function Foo() {\n   *   this.a = 1;\n   *   this.b = 2;\n   * }\n   *\n   * Foo.prototype.c = 3;\n   *\n   * _.values(new Foo);\n   * // => [1, 2] (iteration order is not guaranteed)\n   *\n   * _.values('hi');\n   * // => ['h', 'i']\n   */\n  function values(object) {\n    return object == null ? [] : baseValues(object, keys(object))\n  }\n\n  /* Built-in method references for those with the same name as other `lodash` methods. */\n  var nativeMax$1 = Math.max\n\n  /**\n   * Checks if `value` is in `collection`. If `collection` is a string, it's\n   * checked for a substring of `value`, otherwise\n   * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n   * is used for equality comparisons. If `fromIndex` is negative, it's used as\n   * the offset from the end of `collection`.\n   *\n   * @static\n   * @memberOf _\n   * @since 0.1.0\n   * @category Collection\n   * @param {Array|Object|string} collection The collection to inspect.\n   * @param {*} value The value to search for.\n   * @param {number} [fromIndex=0] The index to search from.\n   * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.\n   * @returns {boolean} Returns `true` if `value` is found, else `false`.\n   * @example\n   *\n   * _.includes([1, 2, 3], 1);\n   * // => true\n   *\n   * _.includes([1, 2, 3], 1, 2);\n   * // => false\n   *\n   * _.includes({ 'a': 1, 'b': 2 }, 1);\n   * // => true\n   *\n   * _.includes('abcd', 'bc');\n   * // => true\n   */\n  function includes(collection, value, fromIndex, guard) {\n    collection = isArrayLike(collection) ? collection : values(collection)\n    fromIndex = fromIndex && !guard ? toInteger(fromIndex) : 0\n\n    var length = collection.length\n    if (fromIndex < 0) {\n      fromIndex = nativeMax$1(length + fromIndex, 0)\n    }\n    return isString(collection)\n      ? fromIndex <= length && collection.indexOf(value, fromIndex) > -1\n      : !!length && baseIndexOf(collection, value, fromIndex) > -1\n  }\n\n  /* Built-in method references for those with the same name as other `lodash` methods. */\n  var nativeMax = Math.max\n\n  /**\n   * Gets the index at which the first occurrence of `value` is found in `array`\n   * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n   * for equality comparisons. If `fromIndex` is negative, it's used as the\n   * offset from the end of `array`.\n   *\n   * @static\n   * @memberOf _\n   * @since 0.1.0\n   * @category Array\n   * @param {Array} array The array to inspect.\n   * @param {*} value The value to search for.\n   * @param {number} [fromIndex=0] The index to search from.\n   * @returns {number} Returns the index of the matched value, else `-1`.\n   * @example\n   *\n   * _.indexOf([1, 2, 1, 2], 2);\n   * // => 1\n   *\n   * // Search from the `fromIndex`.\n   * _.indexOf([1, 2, 1, 2], 2, 2);\n   * // => 3\n   */\n  function indexOf(array, value, fromIndex) {\n    var length = array == null ? 0 : array.length\n    if (!length) {\n      return -1\n    }\n    var index = fromIndex == null ? 0 : toInteger(fromIndex)\n    if (index < 0) {\n      index = nativeMax(length + index, 0)\n    }\n    return baseIndexOf(array, value, index)\n  }\n\n  /** `Object#toString` result references. */\n  var mapTag = '[object Map]',\n    setTag = '[object Set]'\n\n  /** Used for built-in method references. */\n  var objectProto = Object.prototype\n\n  /** Used to check objects for own properties. */\n  var hasOwnProperty = objectProto.hasOwnProperty\n\n  /**\n   * Checks if `value` is an empty object, collection, map, or set.\n   *\n   * Objects are considered empty if they have no own enumerable string keyed\n   * properties.\n   *\n   * Array-like values such as `arguments` objects, arrays, buffers, strings, or\n   * jQuery-like collections are considered empty if they have a `length` of `0`.\n   * Similarly, maps and sets are considered empty if they have a `size` of `0`.\n   *\n   * @static\n   * @memberOf _\n   * @since 0.1.0\n   * @category Lang\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is empty, else `false`.\n   * @example\n   *\n   * _.isEmpty(null);\n   * // => true\n   *\n   * _.isEmpty(true);\n   * // => true\n   *\n   * _.isEmpty(1);\n   * // => true\n   *\n   * _.isEmpty([1, 2, 3]);\n   * // => false\n   *\n   * _.isEmpty({ 'a': 1 });\n   * // => false\n   */\n  function isEmpty(value) {\n    if (value == null) {\n      return true\n    }\n    if (\n      isArrayLike(value) &&\n      (isArray$1(value) ||\n        typeof value == 'string' ||\n        typeof value.splice == 'function' ||\n        isBuffer$1(value) ||\n        isTypedArray$1(value) ||\n        isArguments$1(value))\n    ) {\n      return !value.length\n    }\n    var tag = getTag$1(value)\n    if (tag == mapTag || tag == setTag) {\n      return !value.size\n    }\n    if (isPrototype(value)) {\n      return !baseKeys(value).length\n    }\n    for (var key in value) {\n      if (hasOwnProperty.call(value, key)) {\n        return false\n      }\n    }\n    return true\n  }\n\n  /** `Object#toString` result references. */\n  var regexpTag = '[object RegExp]'\n\n  /**\n   * The base implementation of `_.isRegExp` without Node.js optimizations.\n   *\n   * @private\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.\n   */\n  function baseIsRegExp(value) {\n    return isObjectLike(value) && baseGetTag(value) == regexpTag\n  }\n\n  /* Node.js helper references. */\n  var nodeIsRegExp = nodeUtil$1 && nodeUtil$1.isRegExp\n\n  /**\n   * Checks if `value` is classified as a `RegExp` object.\n   *\n   * @static\n   * @memberOf _\n   * @since 0.1.0\n   * @category Lang\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.\n   * @example\n   *\n   * _.isRegExp(/abc/);\n   * // => true\n   *\n   * _.isRegExp('/abc/');\n   * // => false\n   */\n  var isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp\n\n  const isRegExp$1 = isRegExp\n\n  /**\n   * Checks if `value` is `undefined`.\n   *\n   * @static\n   * @since 0.1.0\n   * @memberOf _\n   * @category Lang\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.\n   * @example\n   *\n   * _.isUndefined(void 0);\n   * // => true\n   *\n   * _.isUndefined(null);\n   * // => false\n   */\n  function isUndefined(value) {\n    return value === undefined\n  }\n\n  /** Error message constants. */\n  var FUNC_ERROR_TEXT = 'Expected a function'\n\n  /**\n   * Creates a function that negates the result of the predicate `func`. The\n   * `func` predicate is invoked with the `this` binding and arguments of the\n   * created function.\n   *\n   * @static\n   * @memberOf _\n   * @since 3.0.0\n   * @category Function\n   * @param {Function} predicate The predicate to negate.\n   * @returns {Function} Returns the new negated function.\n   * @example\n   *\n   * function isEven(n) {\n   *   return n % 2 == 0;\n   * }\n   *\n   * _.filter([1, 2, 3, 4, 5, 6], _.negate(isEven));\n   * // => [1, 3, 5]\n   */\n  function negate(predicate) {\n    if (typeof predicate != 'function') {\n      throw new TypeError(FUNC_ERROR_TEXT)\n    }\n    return function () {\n      var args = arguments\n      switch (args.length) {\n        case 0:\n          return !predicate.call(this)\n        case 1:\n          return !predicate.call(this, args[0])\n        case 2:\n          return !predicate.call(this, args[0], args[1])\n        case 3:\n          return !predicate.call(this, args[0], args[1], args[2])\n      }\n      return !predicate.apply(this, args)\n    }\n  }\n\n  /**\n   * The base implementation of `_.set`.\n   *\n   * @private\n   * @param {Object} object The object to modify.\n   * @param {Array|string} path The path of the property to set.\n   * @param {*} value The value to set.\n   * @param {Function} [customizer] The function to customize path creation.\n   * @returns {Object} Returns `object`.\n   */\n  function baseSet(object, path, value, customizer) {\n    if (!isObject(object)) {\n      return object\n    }\n    path = castPath(path, object)\n\n    var index = -1,\n      length = path.length,\n      lastIndex = length - 1,\n      nested = object\n\n    while (nested != null && ++index < length) {\n      var key = toKey(path[index]),\n        newValue = value\n\n      if (key === '__proto__' || key === 'constructor' || key === 'prototype') {\n        return object\n      }\n\n      if (index != lastIndex) {\n        var objValue = nested[key]\n        newValue = customizer ? customizer(objValue, key, nested) : undefined\n        if (newValue === undefined) {\n          newValue = isObject(objValue) ? objValue : isIndex(path[index + 1]) ? [] : {}\n        }\n      }\n      assignValue(nested, key, newValue)\n      nested = nested[key]\n    }\n    return object\n  }\n\n  /**\n   * The base implementation of  `_.pickBy` without support for iteratee shorthands.\n   *\n   * @private\n   * @param {Object} object The source object.\n   * @param {string[]} paths The property paths to pick.\n   * @param {Function} predicate The function invoked per property.\n   * @returns {Object} Returns the new object.\n   */\n  function basePickBy(object, paths, predicate) {\n    var index = -1,\n      length = paths.length,\n      result = {}\n\n    while (++index < length) {\n      var path = paths[index],\n        value = baseGet(object, path)\n\n      if (predicate(value, path)) {\n        baseSet(result, castPath(path, object), value)\n      }\n    }\n    return result\n  }\n\n  /**\n   * Creates an object composed of the `object` properties `predicate` returns\n   * truthy for. The predicate is invoked with two arguments: (value, key).\n   *\n   * @static\n   * @memberOf _\n   * @since 4.0.0\n   * @category Object\n   * @param {Object} object The source object.\n   * @param {Function} [predicate=_.identity] The function invoked per property.\n   * @returns {Object} Returns the new object.\n   * @example\n   *\n   * var object = { 'a': 1, 'b': '2', 'c': 3 };\n   *\n   * _.pickBy(object, _.isNumber);\n   * // => { 'a': 1, 'c': 3 }\n   */\n  function pickBy(object, predicate) {\n    if (object == null) {\n      return {}\n    }\n    var props = arrayMap(getAllKeysIn(object), function (prop) {\n      return [prop]\n    })\n    predicate = baseIteratee(predicate)\n    return basePickBy(object, props, function (value, path) {\n      return predicate(value, path[0])\n    })\n  }\n\n  /**\n   * The base implementation of `_.reduce` and `_.reduceRight`, without support\n   * for iteratee shorthands, which iterates over `collection` using `eachFunc`.\n   *\n   * @private\n   * @param {Array|Object} collection The collection to iterate over.\n   * @param {Function} iteratee The function invoked per iteration.\n   * @param {*} accumulator The initial value.\n   * @param {boolean} initAccum Specify using the first or last element of\n   *  `collection` as the initial value.\n   * @param {Function} eachFunc The function to iterate over `collection`.\n   * @returns {*} Returns the accumulated value.\n   */\n  function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {\n    eachFunc(collection, function (value, index, collection) {\n      accumulator = initAccum ? ((initAccum = false), value) : iteratee(accumulator, value, index, collection)\n    })\n    return accumulator\n  }\n\n  /**\n   * Reduces `collection` to a value which is the accumulated result of running\n   * each element in `collection` thru `iteratee`, where each successive\n   * invocation is supplied the return value of the previous. If `accumulator`\n   * is not given, the first element of `collection` is used as the initial\n   * value. The iteratee is invoked with four arguments:\n   * (accumulator, value, index|key, collection).\n   *\n   * Many lodash methods are guarded to work as iteratees for methods like\n   * `_.reduce`, `_.reduceRight`, and `_.transform`.\n   *\n   * The guarded methods are:\n   * `assign`, `defaults`, `defaultsDeep`, `includes`, `merge`, `orderBy`,\n   * and `sortBy`\n   *\n   * @static\n   * @memberOf _\n   * @since 0.1.0\n   * @category Collection\n   * @param {Array|Object} collection The collection to iterate over.\n   * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n   * @param {*} [accumulator] The initial value.\n   * @returns {*} Returns the accumulated value.\n   * @see _.reduceRight\n   * @example\n   *\n   * _.reduce([1, 2], function(sum, n) {\n   *   return sum + n;\n   * }, 0);\n   * // => 3\n   *\n   * _.reduce({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {\n   *   (result[value] || (result[value] = [])).push(key);\n   *   return result;\n   * }, {});\n   * // => { '1': ['a', 'c'], '2': ['b'] } (iteration order is not guaranteed)\n   */\n  function reduce(collection, iteratee, accumulator) {\n    var func = isArray$1(collection) ? arrayReduce : baseReduce,\n      initAccum = arguments.length < 3\n\n    return func(collection, baseIteratee(iteratee), accumulator, initAccum, baseEach$1)\n  }\n\n  /**\n   * The opposite of `_.filter`; this method returns the elements of `collection`\n   * that `predicate` does **not** return truthy for.\n   *\n   * @static\n   * @memberOf _\n   * @since 0.1.0\n   * @category Collection\n   * @param {Array|Object} collection The collection to iterate over.\n   * @param {Function} [predicate=_.identity] The function invoked per iteration.\n   * @returns {Array} Returns the new filtered array.\n   * @see _.filter\n   * @example\n   *\n   * var users = [\n   *   { 'user': 'barney', 'age': 36, 'active': false },\n   *   { 'user': 'fred',   'age': 40, 'active': true }\n   * ];\n   *\n   * _.reject(users, function(o) { return !o.active; });\n   * // => objects for ['fred']\n   *\n   * // The `_.matches` iteratee shorthand.\n   * _.reject(users, { 'age': 40, 'active': true });\n   * // => objects for ['barney']\n   *\n   * // The `_.matchesProperty` iteratee shorthand.\n   * _.reject(users, ['active', false]);\n   * // => objects for ['fred']\n   *\n   * // The `_.property` iteratee shorthand.\n   * _.reject(users, 'active');\n   * // => objects for ['barney']\n   */\n  function reject(collection, predicate) {\n    var func = isArray$1(collection) ? arrayFilter : baseFilter\n    return func(collection, negate(baseIteratee(predicate)))\n  }\n\n  /**\n   * The base implementation of `_.some` without support for iteratee shorthands.\n   *\n   * @private\n   * @param {Array|Object} collection The collection to iterate over.\n   * @param {Function} predicate The function invoked per iteration.\n   * @returns {boolean} Returns `true` if any element passes the predicate check,\n   *  else `false`.\n   */\n  function baseSome(collection, predicate) {\n    var result\n\n    baseEach$1(collection, function (value, index, collection) {\n      result = predicate(value, index, collection)\n      return !result\n    })\n    return !!result\n  }\n\n  /**\n   * Checks if `predicate` returns truthy for **any** element of `collection`.\n   * Iteration is stopped once `predicate` returns truthy. The predicate is\n   * invoked with three arguments: (value, index|key, collection).\n   *\n   * @static\n   * @memberOf _\n   * @since 0.1.0\n   * @category Collection\n   * @param {Array|Object} collection The collection to iterate over.\n   * @param {Function} [predicate=_.identity] The function invoked per iteration.\n   * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n   * @returns {boolean} Returns `true` if any element passes the predicate check,\n   *  else `false`.\n   * @example\n   *\n   * _.some([null, 0, 'yes', false], Boolean);\n   * // => true\n   *\n   * var users = [\n   *   { 'user': 'barney', 'active': true },\n   *   { 'user': 'fred',   'active': false }\n   * ];\n   *\n   * // The `_.matches` iteratee shorthand.\n   * _.some(users, { 'user': 'barney', 'active': false });\n   * // => false\n   *\n   * // The `_.matchesProperty` iteratee shorthand.\n   * _.some(users, ['active', false]);\n   * // => true\n   *\n   * // The `_.property` iteratee shorthand.\n   * _.some(users, 'active');\n   * // => true\n   */\n  function some(collection, predicate, guard) {\n    var func = isArray$1(collection) ? arraySome : baseSome\n    if (guard && isIterateeCall(collection, predicate, guard)) {\n      predicate = undefined\n    }\n    return func(collection, baseIteratee(predicate))\n  }\n\n  /** Used as references for various `Number` constants. */\n  var INFINITY = 1 / 0\n\n  /**\n   * Creates a set object of `values`.\n   *\n   * @private\n   * @param {Array} values The values to add to the set.\n   * @returns {Object} Returns the new set.\n   */\n  var createSet = !(Set$1 && 1 / setToArray(new Set$1([, -0]))[1] == INFINITY)\n    ? noop\n    : function (values) {\n        return new Set$1(values)\n      }\n\n  const createSet$1 = createSet\n\n  /** Used as the size to enable large array optimizations. */\n  var LARGE_ARRAY_SIZE = 200\n\n  /**\n   * The base implementation of `_.uniqBy` without support for iteratee shorthands.\n   *\n   * @private\n   * @param {Array} array The array to inspect.\n   * @param {Function} [iteratee] The iteratee invoked per element.\n   * @param {Function} [comparator] The comparator invoked per element.\n   * @returns {Array} Returns the new duplicate free array.\n   */\n  function baseUniq(array, iteratee, comparator) {\n    var index = -1,\n      includes = arrayIncludes,\n      length = array.length,\n      isCommon = true,\n      result = [],\n      seen = result\n\n    if (comparator) {\n      isCommon = false\n      includes = arrayIncludesWith\n    } else if (length >= LARGE_ARRAY_SIZE) {\n      var set = iteratee ? null : createSet$1(array)\n      if (set) {\n        return setToArray(set)\n      }\n      isCommon = false\n      includes = cacheHas\n      seen = new SetCache()\n    } else {\n      seen = iteratee ? [] : result\n    }\n    outer: while (++index < length) {\n      var value = array[index],\n        computed = iteratee ? iteratee(value) : value\n\n      value = comparator || value !== 0 ? value : 0\n      if (isCommon && computed === computed) {\n        var seenIndex = seen.length\n        while (seenIndex--) {\n          if (seen[seenIndex] === computed) {\n            continue outer\n          }\n        }\n        if (iteratee) {\n          seen.push(computed)\n        }\n        result.push(value)\n      } else if (!includes(seen, computed, comparator)) {\n        if (seen !== result) {\n          seen.push(computed)\n        }\n        result.push(value)\n      }\n    }\n    return result\n  }\n\n  /**\n   * Creates a duplicate-free version of an array, using\n   * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n   * for equality comparisons, in which only the first occurrence of each element\n   * is kept. The order of result values is determined by the order they occur\n   * in the array.\n   *\n   * @static\n   * @memberOf _\n   * @since 0.1.0\n   * @category Array\n   * @param {Array} array The array to inspect.\n   * @returns {Array} Returns the new duplicate free array.\n   * @example\n   *\n   * _.uniq([2, 1, 2]);\n   * // => [2, 1]\n   */\n  function uniq(array) {\n    return array && array.length ? baseUniq(array) : []\n  }\n\n  function PRINT_ERROR(msg) {\n    /* istanbul ignore else - can't override global.console in node.js */\n    if (console && console.error) {\n      console.error(`Error: ${msg}`)\n    }\n  }\n  function PRINT_WARNING(msg) {\n    /* istanbul ignore else - can't override global.console in node.js*/\n    if (console && console.warn) {\n      // TODO: modify docs accordingly\n      console.warn(`Warning: ${msg}`)\n    }\n  }\n\n  function timer(func) {\n    const start = new Date().getTime()\n    const val = func()\n    const end = new Date().getTime()\n    const total = end - start\n    return { time: total, value: val }\n  }\n\n  // based on: https://github.com/petkaantonov/bluebird/blob/b97c0d2d487e8c5076e8bd897e0dcd4622d31846/src/util.js#L201-L216\n  function toFastProperties(toBecomeFast) {\n    function FakeConstructor() {}\n    // If our object is used as a constructor, it would receive\n    FakeConstructor.prototype = toBecomeFast\n    const fakeInstance = new FakeConstructor()\n    function fakeAccess() {\n      return typeof fakeInstance.bar\n    }\n    // help V8 understand this is a \"real\" prototype by actually using\n    // the fake instance.\n    fakeAccess()\n    fakeAccess()\n    // Always true condition to suppress the Firefox warning of unreachable\n    // code after a return statement.\n    return toBecomeFast\n  }\n\n  // TODO: duplicated code to avoid extracting another sub-package -- how to avoid?\n  function tokenLabel$1(tokType) {\n    if (hasTokenLabel$1(tokType)) {\n      return tokType.LABEL\n    } else {\n      return tokType.name\n    }\n  }\n  // TODO: duplicated code to avoid extracting another sub-package -- how to avoid?\n  function hasTokenLabel$1(obj) {\n    return isString(obj.LABEL) && obj.LABEL !== ''\n  }\n  class AbstractProduction {\n    get definition() {\n      return this._definition\n    }\n    set definition(value) {\n      this._definition = value\n    }\n    constructor(_definition) {\n      this._definition = _definition\n    }\n    accept(visitor) {\n      visitor.visit(this)\n      forEach(this.definition, (prod) => {\n        prod.accept(visitor)\n      })\n    }\n  }\n  class NonTerminal extends AbstractProduction {\n    constructor(options) {\n      super([])\n      this.idx = 1\n      assign$1(\n        this,\n        pickBy(options, (v) => v !== undefined),\n      )\n    }\n    set definition(definition) {\n      // immutable\n    }\n    get definition() {\n      if (this.referencedRule !== undefined) {\n        return this.referencedRule.definition\n      }\n      return []\n    }\n    accept(visitor) {\n      visitor.visit(this)\n      // don't visit children of a reference, we will get cyclic infinite loops if we do so\n    }\n  }\n  class Rule extends AbstractProduction {\n    constructor(options) {\n      super(options.definition)\n      this.orgText = ''\n      assign$1(\n        this,\n        pickBy(options, (v) => v !== undefined),\n      )\n    }\n  }\n  class Alternative extends AbstractProduction {\n    constructor(options) {\n      super(options.definition)\n      this.ignoreAmbiguities = false\n      assign$1(\n        this,\n        pickBy(options, (v) => v !== undefined),\n      )\n    }\n  }\n  class Option extends AbstractProduction {\n    constructor(options) {\n      super(options.definition)\n      this.idx = 1\n      assign$1(\n        this,\n        pickBy(options, (v) => v !== undefined),\n      )\n    }\n  }\n  class RepetitionMandatory extends AbstractProduction {\n    constructor(options) {\n      super(options.definition)\n      this.idx = 1\n      assign$1(\n        this,\n        pickBy(options, (v) => v !== undefined),\n      )\n    }\n  }\n  class RepetitionMandatoryWithSeparator extends AbstractProduction {\n    constructor(options) {\n      super(options.definition)\n      this.idx = 1\n      assign$1(\n        this,\n        pickBy(options, (v) => v !== undefined),\n      )\n    }\n  }\n  class Repetition extends AbstractProduction {\n    constructor(options) {\n      super(options.definition)\n      this.idx = 1\n      assign$1(\n        this,\n        pickBy(options, (v) => v !== undefined),\n      )\n    }\n  }\n  class RepetitionWithSeparator extends AbstractProduction {\n    constructor(options) {\n      super(options.definition)\n      this.idx = 1\n      assign$1(\n        this,\n        pickBy(options, (v) => v !== undefined),\n      )\n    }\n  }\n  class Alternation extends AbstractProduction {\n    get definition() {\n      return this._definition\n    }\n    set definition(value) {\n      this._definition = value\n    }\n    constructor(options) {\n      super(options.definition)\n      this.idx = 1\n      this.ignoreAmbiguities = false\n      this.hasPredicates = false\n      assign$1(\n        this,\n        pickBy(options, (v) => v !== undefined),\n      )\n    }\n  }\n  class Terminal {\n    constructor(options) {\n      this.idx = 1\n      assign$1(\n        this,\n        pickBy(options, (v) => v !== undefined),\n      )\n    }\n    accept(visitor) {\n      visitor.visit(this)\n    }\n  }\n  function serializeGrammar(topRules) {\n    return map(topRules, serializeProduction)\n  }\n  function serializeProduction(node) {\n    function convertDefinition(definition) {\n      return map(definition, serializeProduction)\n    }\n    /* istanbul ignore else */\n    if (node instanceof NonTerminal) {\n      const serializedNonTerminal = {\n        type: 'NonTerminal',\n        name: node.nonTerminalName,\n        idx: node.idx,\n      }\n      if (isString(node.label)) {\n        serializedNonTerminal.label = node.label\n      }\n      return serializedNonTerminal\n    } else if (node instanceof Alternative) {\n      return {\n        type: 'Alternative',\n        definition: convertDefinition(node.definition),\n      }\n    } else if (node instanceof Option) {\n      return {\n        type: 'Option',\n        idx: node.idx,\n        definition: convertDefinition(node.definition),\n      }\n    } else if (node instanceof RepetitionMandatory) {\n      return {\n        type: 'RepetitionMandatory',\n        idx: node.idx,\n        definition: convertDefinition(node.definition),\n      }\n    } else if (node instanceof RepetitionMandatoryWithSeparator) {\n      return {\n        type: 'RepetitionMandatoryWithSeparator',\n        idx: node.idx,\n        separator: serializeProduction(new Terminal({ terminalType: node.separator })),\n        definition: convertDefinition(node.definition),\n      }\n    } else if (node instanceof RepetitionWithSeparator) {\n      return {\n        type: 'RepetitionWithSeparator',\n        idx: node.idx,\n        separator: serializeProduction(new Terminal({ terminalType: node.separator })),\n        definition: convertDefinition(node.definition),\n      }\n    } else if (node instanceof Repetition) {\n      return {\n        type: 'Repetition',\n        idx: node.idx,\n        definition: convertDefinition(node.definition),\n      }\n    } else if (node instanceof Alternation) {\n      return {\n        type: 'Alternation',\n        idx: node.idx,\n        definition: convertDefinition(node.definition),\n      }\n    } else if (node instanceof Terminal) {\n      const serializedTerminal = {\n        type: 'Terminal',\n        name: node.terminalType.name,\n        label: tokenLabel$1(node.terminalType),\n        idx: node.idx,\n      }\n      if (isString(node.label)) {\n        serializedTerminal.terminalLabel = node.label\n      }\n      const pattern = node.terminalType.PATTERN\n      if (node.terminalType.PATTERN) {\n        serializedTerminal.pattern = isRegExp$1(pattern) ? pattern.source : pattern\n      }\n      return serializedTerminal\n    } else if (node instanceof Rule) {\n      return {\n        type: 'Rule',\n        name: node.name,\n        orgText: node.orgText,\n        definition: convertDefinition(node.definition),\n      }\n      /* c8 ignore next 3 */\n    } else {\n      throw Error('non exhaustive match')\n    }\n  }\n\n  class GAstVisitor {\n    visit(node) {\n      const nodeAny = node\n      switch (nodeAny.constructor) {\n        case NonTerminal:\n          return this.visitNonTerminal(nodeAny)\n        case Alternative:\n          return this.visitAlternative(nodeAny)\n        case Option:\n          return this.visitOption(nodeAny)\n        case RepetitionMandatory:\n          return this.visitRepetitionMandatory(nodeAny)\n        case RepetitionMandatoryWithSeparator:\n          return this.visitRepetitionMandatoryWithSeparator(nodeAny)\n        case RepetitionWithSeparator:\n          return this.visitRepetitionWithSeparator(nodeAny)\n        case Repetition:\n          return this.visitRepetition(nodeAny)\n        case Alternation:\n          return this.visitAlternation(nodeAny)\n        case Terminal:\n          return this.visitTerminal(nodeAny)\n        case Rule:\n          return this.visitRule(nodeAny)\n        /* c8 ignore next 2 */\n        default:\n          throw Error('non exhaustive match')\n      }\n    }\n    /* c8 ignore next */\n    visitNonTerminal(node) {}\n    /* c8 ignore next */\n    visitAlternative(node) {}\n    /* c8 ignore next */\n    visitOption(node) {}\n    /* c8 ignore next */\n    visitRepetition(node) {}\n    /* c8 ignore next */\n    visitRepetitionMandatory(node) {}\n    /* c8 ignore next 3 */\n    visitRepetitionMandatoryWithSeparator(node) {}\n    /* c8 ignore next */\n    visitRepetitionWithSeparator(node) {}\n    /* c8 ignore next */\n    visitAlternation(node) {}\n    /* c8 ignore next */\n    visitTerminal(node) {}\n    /* c8 ignore next */\n    visitRule(node) {}\n  }\n\n  function isSequenceProd(prod) {\n    return (\n      prod instanceof Alternative ||\n      prod instanceof Option ||\n      prod instanceof Repetition ||\n      prod instanceof RepetitionMandatory ||\n      prod instanceof RepetitionMandatoryWithSeparator ||\n      prod instanceof RepetitionWithSeparator ||\n      prod instanceof Terminal ||\n      prod instanceof Rule\n    )\n  }\n  function isOptionalProd(prod, alreadyVisited = []) {\n    const isDirectlyOptional =\n      prod instanceof Option || prod instanceof Repetition || prod instanceof RepetitionWithSeparator\n    if (isDirectlyOptional) {\n      return true\n    }\n    // note that this can cause infinite loop if one optional empty TOP production has a cyclic dependency with another\n    // empty optional top rule\n    // may be indirectly optional ((A?B?C?) | (D?E?F?))\n    if (prod instanceof Alternation) {\n      // for OR its enough for just one of the alternatives to be optional\n      return some(prod.definition, (subProd) => {\n        return isOptionalProd(subProd, alreadyVisited)\n      })\n    } else if (prod instanceof NonTerminal && includes(alreadyVisited, prod)) {\n      // avoiding stack overflow due to infinite recursion\n      return false\n    } else if (prod instanceof AbstractProduction) {\n      if (prod instanceof NonTerminal) {\n        alreadyVisited.push(prod)\n      }\n      return every(prod.definition, (subProd) => {\n        return isOptionalProd(subProd, alreadyVisited)\n      })\n    } else {\n      return false\n    }\n  }\n  function isBranchingProd(prod) {\n    return prod instanceof Alternation\n  }\n  function getProductionDslName(prod) {\n    /* istanbul ignore else */\n    if (prod instanceof NonTerminal) {\n      return 'SUBRULE'\n    } else if (prod instanceof Option) {\n      return 'OPTION'\n    } else if (prod instanceof Alternation) {\n      return 'OR'\n    } else if (prod instanceof RepetitionMandatory) {\n      return 'AT_LEAST_ONE'\n    } else if (prod instanceof RepetitionMandatoryWithSeparator) {\n      return 'AT_LEAST_ONE_SEP'\n    } else if (prod instanceof RepetitionWithSeparator) {\n      return 'MANY_SEP'\n    } else if (prod instanceof Repetition) {\n      return 'MANY'\n    } else if (prod instanceof Terminal) {\n      return 'CONSUME'\n      /* c8 ignore next 3 */\n    } else {\n      throw Error('non exhaustive match')\n    }\n  }\n\n  /**\n   *  A Grammar Walker that computes the \"remaining\" grammar \"after\" a productions in the grammar.\n   */\n  class RestWalker {\n    walk(prod, prevRest = []) {\n      forEach(prod.definition, (subProd, index) => {\n        const currRest = drop(prod.definition, index + 1)\n        /* istanbul ignore else */\n        if (subProd instanceof NonTerminal) {\n          this.walkProdRef(subProd, currRest, prevRest)\n        } else if (subProd instanceof Terminal) {\n          this.walkTerminal(subProd, currRest, prevRest)\n        } else if (subProd instanceof Alternative) {\n          this.walkFlat(subProd, currRest, prevRest)\n        } else if (subProd instanceof Option) {\n          this.walkOption(subProd, currRest, prevRest)\n        } else if (subProd instanceof RepetitionMandatory) {\n          this.walkAtLeastOne(subProd, currRest, prevRest)\n        } else if (subProd instanceof RepetitionMandatoryWithSeparator) {\n          this.walkAtLeastOneSep(subProd, currRest, prevRest)\n        } else if (subProd instanceof RepetitionWithSeparator) {\n          this.walkManySep(subProd, currRest, prevRest)\n        } else if (subProd instanceof Repetition) {\n          this.walkMany(subProd, currRest, prevRest)\n        } else if (subProd instanceof Alternation) {\n          this.walkOr(subProd, currRest, prevRest)\n        } else {\n          throw Error('non exhaustive match')\n        }\n      })\n    }\n    walkTerminal(terminal, currRest, prevRest) {}\n    walkProdRef(refProd, currRest, prevRest) {}\n    walkFlat(flatProd, currRest, prevRest) {\n      // ABCDEF => after the D the rest is EF\n      const fullOrRest = currRest.concat(prevRest)\n      this.walk(flatProd, fullOrRest)\n    }\n    walkOption(optionProd, currRest, prevRest) {\n      // ABC(DE)?F => after the (DE)? the rest is F\n      const fullOrRest = currRest.concat(prevRest)\n      this.walk(optionProd, fullOrRest)\n    }\n    walkAtLeastOne(atLeastOneProd, currRest, prevRest) {\n      // ABC(DE)+F => after the (DE)+ the rest is (DE)?F\n      const fullAtLeastOneRest = [new Option({ definition: atLeastOneProd.definition })].concat(currRest, prevRest)\n      this.walk(atLeastOneProd, fullAtLeastOneRest)\n    }\n    walkAtLeastOneSep(atLeastOneSepProd, currRest, prevRest) {\n      // ABC DE(,DE)* F => after the (,DE)+ the rest is (,DE)?F\n      const fullAtLeastOneSepRest = restForRepetitionWithSeparator(atLeastOneSepProd, currRest, prevRest)\n      this.walk(atLeastOneSepProd, fullAtLeastOneSepRest)\n    }\n    walkMany(manyProd, currRest, prevRest) {\n      // ABC(DE)*F => after the (DE)* the rest is (DE)?F\n      const fullManyRest = [new Option({ definition: manyProd.definition })].concat(currRest, prevRest)\n      this.walk(manyProd, fullManyRest)\n    }\n    walkManySep(manySepProd, currRest, prevRest) {\n      // ABC (DE(,DE)*)? F => after the (,DE)* the rest is (,DE)?F\n      const fullManySepRest = restForRepetitionWithSeparator(manySepProd, currRest, prevRest)\n      this.walk(manySepProd, fullManySepRest)\n    }\n    walkOr(orProd, currRest, prevRest) {\n      // ABC(D|E|F)G => when finding the (D|E|F) the rest is G\n      const fullOrRest = currRest.concat(prevRest)\n      // walk all different alternatives\n      forEach(orProd.definition, (alt) => {\n        // wrapping each alternative in a single definition wrapper\n        // to avoid errors in computing the rest of that alternative in the invocation to computeInProdFollows\n        // (otherwise for OR([alt1,alt2]) alt2 will be considered in 'rest' of alt1\n        const prodWrapper = new Alternative({ definition: [alt] })\n        this.walk(prodWrapper, fullOrRest)\n      })\n    }\n  }\n  function restForRepetitionWithSeparator(repSepProd, currRest, prevRest) {\n    const repSepRest = [\n      new Option({\n        definition: [new Terminal({ terminalType: repSepProd.separator })].concat(repSepProd.definition),\n      }),\n    ]\n    const fullRepSepRest = repSepRest.concat(currRest, prevRest)\n    return fullRepSepRest\n  }\n\n  function first(prod) {\n    /* istanbul ignore else */\n    if (prod instanceof NonTerminal) {\n      // this could in theory cause infinite loops if\n      // (1) prod A refs prod B.\n      // (2) prod B refs prod A\n      // (3) AB can match the empty set\n      // in other words a cycle where everything is optional so the first will keep\n      // looking ahead for the next optional part and will never exit\n      // currently there is no safeguard for this unique edge case because\n      // (1) not sure a grammar in which this can happen is useful for anything (productive)\n      return first(prod.referencedRule)\n    } else if (prod instanceof Terminal) {\n      return firstForTerminal(prod)\n    } else if (isSequenceProd(prod)) {\n      return firstForSequence(prod)\n    } else if (isBranchingProd(prod)) {\n      return firstForBranching(prod)\n    } else {\n      throw Error('non exhaustive match')\n    }\n  }\n  function firstForSequence(prod) {\n    let firstSet = []\n    const seq = prod.definition\n    let nextSubProdIdx = 0\n    let hasInnerProdsRemaining = seq.length > nextSubProdIdx\n    let currSubProd\n    // so we enter the loop at least once (if the definition is not empty\n    let isLastInnerProdOptional = true\n    // scan a sequence until it's end or until we have found a NONE optional production in it\n    while (hasInnerProdsRemaining && isLastInnerProdOptional) {\n      currSubProd = seq[nextSubProdIdx]\n      isLastInnerProdOptional = isOptionalProd(currSubProd)\n      firstSet = firstSet.concat(first(currSubProd))\n      nextSubProdIdx = nextSubProdIdx + 1\n      hasInnerProdsRemaining = seq.length > nextSubProdIdx\n    }\n    return uniq(firstSet)\n  }\n  function firstForBranching(prod) {\n    const allAlternativesFirsts = map(prod.definition, (innerProd) => {\n      return first(innerProd)\n    })\n    return uniq(flatten(allAlternativesFirsts))\n  }\n  function firstForTerminal(terminal) {\n    return [terminal.terminalType]\n  }\n\n  // TODO: can this be removed? where is it used?\n  const IN = '_~IN~_'\n\n  // This ResyncFollowsWalker computes all of the follows required for RESYNC\n  // (skipping reference production).\n  class ResyncFollowsWalker extends RestWalker {\n    constructor(topProd) {\n      super()\n      this.topProd = topProd\n      this.follows = {}\n    }\n    startWalking() {\n      this.walk(this.topProd)\n      return this.follows\n    }\n    walkTerminal(terminal, currRest, prevRest) {\n      // do nothing! just like in the public sector after 13:00\n    }\n    walkProdRef(refProd, currRest, prevRest) {\n      const followName = buildBetweenProdsFollowPrefix(refProd.referencedRule, refProd.idx) + this.topProd.name\n      const fullRest = currRest.concat(prevRest)\n      const restProd = new Alternative({ definition: fullRest })\n      const t_in_topProd_follows = first(restProd)\n      this.follows[followName] = t_in_topProd_follows\n    }\n  }\n  function computeAllProdsFollows(topProductions) {\n    const reSyncFollows = {}\n    forEach(topProductions, (topProd) => {\n      const currRefsFollow = new ResyncFollowsWalker(topProd).startWalking()\n      assign$1(reSyncFollows, currRefsFollow)\n    })\n    return reSyncFollows\n  }\n  function buildBetweenProdsFollowPrefix(inner, occurenceInParent) {\n    return inner.name + occurenceInParent + IN\n  }\n\n  function cc(char) {\n    return char.charCodeAt(0)\n  }\n  function insertToSet(item, set) {\n    if (Array.isArray(item)) {\n      item.forEach(function (subItem) {\n        set.push(subItem)\n      })\n    } else {\n      set.push(item)\n    }\n  }\n  function addFlag(flagObj, flagKey) {\n    if (flagObj[flagKey] === true) {\n      throw 'duplicate flag ' + flagKey\n    }\n    flagObj[flagKey]\n    flagObj[flagKey] = true\n  }\n  function ASSERT_EXISTS(obj) {\n    // istanbul ignore next\n    if (obj === undefined) {\n      throw Error('Internal Error - Should never get here!')\n    }\n    return true\n  }\n  // istanbul ignore next\n  function ASSERT_NEVER_REACH_HERE() {\n    throw Error('Internal Error - Should never get here!')\n  }\n  function isCharacter(obj) {\n    return obj['type'] === 'Character'\n  }\n\n  const digitsCharCodes = []\n  for (let i = cc('0'); i <= cc('9'); i++) {\n    digitsCharCodes.push(i)\n  }\n  const wordCharCodes = [cc('_')].concat(digitsCharCodes)\n  for (let i = cc('a'); i <= cc('z'); i++) {\n    wordCharCodes.push(i)\n  }\n  for (let i = cc('A'); i <= cc('Z'); i++) {\n    wordCharCodes.push(i)\n  }\n  // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp#character-classes\n  const whitespaceCodes = [\n    cc(' '),\n    cc('\\f'),\n    cc('\\n'),\n    cc('\\r'),\n    cc('\\t'),\n    cc('\\v'),\n    cc('\\t'),\n    cc('\\u00a0'),\n    cc('\\u1680'),\n    cc('\\u2000'),\n    cc('\\u2001'),\n    cc('\\u2002'),\n    cc('\\u2003'),\n    cc('\\u2004'),\n    cc('\\u2005'),\n    cc('\\u2006'),\n    cc('\\u2007'),\n    cc('\\u2008'),\n    cc('\\u2009'),\n    cc('\\u200a'),\n    cc('\\u2028'),\n    cc('\\u2029'),\n    cc('\\u202f'),\n    cc('\\u205f'),\n    cc('\\u3000'),\n    cc('\\ufeff'),\n  ]\n\n  // consts and utilities\n  const hexDigitPattern = /[0-9a-fA-F]/\n  const decimalPattern = /[0-9]/\n  const decimalPatternNoZero = /[1-9]/\n  // https://hackernoon.com/the-madness-of-parsing-real-world-javascript-regexps-d9ee336df983\n  // https://www.ecma-international.org/ecma-262/8.0/index.html#prod-Pattern\n  class RegExpParser {\n    constructor() {\n      this.idx = 0\n      this.input = ''\n      this.groupIdx = 0\n    }\n    saveState() {\n      return {\n        idx: this.idx,\n        input: this.input,\n        groupIdx: this.groupIdx,\n      }\n    }\n    restoreState(newState) {\n      this.idx = newState.idx\n      this.input = newState.input\n      this.groupIdx = newState.groupIdx\n    }\n    pattern(input) {\n      // parser state\n      this.idx = 0\n      this.input = input\n      this.groupIdx = 0\n      this.consumeChar('/')\n      const value = this.disjunction()\n      this.consumeChar('/')\n      const flags = {\n        type: 'Flags',\n        loc: { begin: this.idx, end: input.length },\n        global: false,\n        ignoreCase: false,\n        multiLine: false,\n        unicode: false,\n        sticky: false,\n      }\n      while (this.isRegExpFlag()) {\n        switch (this.popChar()) {\n          case 'g':\n            addFlag(flags, 'global')\n            break\n          case 'i':\n            addFlag(flags, 'ignoreCase')\n            break\n          case 'm':\n            addFlag(flags, 'multiLine')\n            break\n          case 'u':\n            addFlag(flags, 'unicode')\n            break\n          case 'y':\n            addFlag(flags, 'sticky')\n            break\n        }\n      }\n      if (this.idx !== this.input.length) {\n        throw Error('Redundant input: ' + this.input.substring(this.idx))\n      }\n      return {\n        type: 'Pattern',\n        flags: flags,\n        value: value,\n        loc: this.loc(0),\n      }\n    }\n    disjunction() {\n      const alts = []\n      const begin = this.idx\n      alts.push(this.alternative())\n      while (this.peekChar() === '|') {\n        this.consumeChar('|')\n        alts.push(this.alternative())\n      }\n      return { type: 'Disjunction', value: alts, loc: this.loc(begin) }\n    }\n    alternative() {\n      const terms = []\n      const begin = this.idx\n      while (this.isTerm()) {\n        terms.push(this.term())\n      }\n      return { type: 'Alternative', value: terms, loc: this.loc(begin) }\n    }\n    term() {\n      if (this.isAssertion()) {\n        return this.assertion()\n      } else {\n        return this.atom()\n      }\n    }\n    assertion() {\n      const begin = this.idx\n      switch (this.popChar()) {\n        case '^':\n          return {\n            type: 'StartAnchor',\n            loc: this.loc(begin),\n          }\n        case '$':\n          return { type: 'EndAnchor', loc: this.loc(begin) }\n        // '\\b' or '\\B'\n        case '\\\\':\n          switch (this.popChar()) {\n            case 'b':\n              return {\n                type: 'WordBoundary',\n                loc: this.loc(begin),\n              }\n            case 'B':\n              return {\n                type: 'NonWordBoundary',\n                loc: this.loc(begin),\n              }\n          }\n          // istanbul ignore next\n          throw Error('Invalid Assertion Escape')\n        // '(?=' or '(?!'\n        case '(':\n          this.consumeChar('?')\n          let type\n          switch (this.popChar()) {\n            case '=':\n              type = 'Lookahead'\n              break\n            case '!':\n              type = 'NegativeLookahead'\n              break\n          }\n          ASSERT_EXISTS(type)\n          const disjunction = this.disjunction()\n          this.consumeChar(')')\n          return {\n            type: type,\n            value: disjunction,\n            loc: this.loc(begin),\n          }\n      }\n      // istanbul ignore next\n      return ASSERT_NEVER_REACH_HERE()\n    }\n    quantifier(isBacktracking = false) {\n      let range = undefined\n      const begin = this.idx\n      switch (this.popChar()) {\n        case '*':\n          range = {\n            atLeast: 0,\n            atMost: Infinity,\n          }\n          break\n        case '+':\n          range = {\n            atLeast: 1,\n            atMost: Infinity,\n          }\n          break\n        case '?':\n          range = {\n            atLeast: 0,\n            atMost: 1,\n          }\n          break\n        case '{':\n          const atLeast = this.integerIncludingZero()\n          switch (this.popChar()) {\n            case '}':\n              range = {\n                atLeast: atLeast,\n                atMost: atLeast,\n              }\n              break\n            case ',':\n              let atMost\n              if (this.isDigit()) {\n                atMost = this.integerIncludingZero()\n                range = {\n                  atLeast: atLeast,\n                  atMost: atMost,\n                }\n              } else {\n                range = {\n                  atLeast: atLeast,\n                  atMost: Infinity,\n                }\n              }\n              this.consumeChar('}')\n              break\n          }\n          // throwing exceptions from \"ASSERT_EXISTS\" during backtracking\n          // causes severe performance degradations\n          if (isBacktracking === true && range === undefined) {\n            return undefined\n          }\n          ASSERT_EXISTS(range)\n          break\n      }\n      // throwing exceptions from \"ASSERT_EXISTS\" during backtracking\n      // causes severe performance degradations\n      if (isBacktracking === true && range === undefined) {\n        return undefined\n      }\n      // istanbul ignore else\n      if (ASSERT_EXISTS(range)) {\n        if (this.peekChar(0) === '?') {\n          this.consumeChar('?')\n          range.greedy = false\n        } else {\n          range.greedy = true\n        }\n        range.type = 'Quantifier'\n        range.loc = this.loc(begin)\n        return range\n      }\n    }\n    atom() {\n      let atom\n      const begin = this.idx\n      switch (this.peekChar()) {\n        case '.':\n          atom = this.dotAll()\n          break\n        case '\\\\':\n          atom = this.atomEscape()\n          break\n        case '[':\n          atom = this.characterClass()\n          break\n        case '(':\n          atom = this.group()\n          break\n      }\n      if (atom === undefined && this.isPatternCharacter()) {\n        atom = this.patternCharacter()\n      }\n      // istanbul ignore else\n      if (ASSERT_EXISTS(atom)) {\n        atom.loc = this.loc(begin)\n        if (this.isQuantifier()) {\n          atom.quantifier = this.quantifier()\n        }\n        return atom\n      }\n    }\n    dotAll() {\n      this.consumeChar('.')\n      return {\n        type: 'Set',\n        complement: true,\n        value: [cc('\\n'), cc('\\r'), cc('\\u2028'), cc('\\u2029')],\n      }\n    }\n    atomEscape() {\n      this.consumeChar('\\\\')\n      switch (this.peekChar()) {\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n          return this.decimalEscapeAtom()\n        case 'd':\n        case 'D':\n        case 's':\n        case 'S':\n        case 'w':\n        case 'W':\n          return this.characterClassEscape()\n        case 'f':\n        case 'n':\n        case 'r':\n        case 't':\n        case 'v':\n          return this.controlEscapeAtom()\n        case 'c':\n          return this.controlLetterEscapeAtom()\n        case '0':\n          return this.nulCharacterAtom()\n        case 'x':\n          return this.hexEscapeSequenceAtom()\n        case 'u':\n          return this.regExpUnicodeEscapeSequenceAtom()\n        default:\n          return this.identityEscapeAtom()\n      }\n    }\n    decimalEscapeAtom() {\n      const value = this.positiveInteger()\n      return { type: 'GroupBackReference', value: value }\n    }\n    characterClassEscape() {\n      let set\n      let complement = false\n      switch (this.popChar()) {\n        case 'd':\n          set = digitsCharCodes\n          break\n        case 'D':\n          set = digitsCharCodes\n          complement = true\n          break\n        case 's':\n          set = whitespaceCodes\n          break\n        case 'S':\n          set = whitespaceCodes\n          complement = true\n          break\n        case 'w':\n          set = wordCharCodes\n          break\n        case 'W':\n          set = wordCharCodes\n          complement = true\n          break\n      }\n      // istanbul ignore else\n      if (ASSERT_EXISTS(set)) {\n        return { type: 'Set', value: set, complement: complement }\n      }\n    }\n    controlEscapeAtom() {\n      let escapeCode\n      switch (this.popChar()) {\n        case 'f':\n          escapeCode = cc('\\f')\n          break\n        case 'n':\n          escapeCode = cc('\\n')\n          break\n        case 'r':\n          escapeCode = cc('\\r')\n          break\n        case 't':\n          escapeCode = cc('\\t')\n          break\n        case 'v':\n          escapeCode = cc('\\v')\n          break\n      }\n      // istanbul ignore else\n      if (ASSERT_EXISTS(escapeCode)) {\n        return { type: 'Character', value: escapeCode }\n      }\n    }\n    controlLetterEscapeAtom() {\n      this.consumeChar('c')\n      const letter = this.popChar()\n      if (/[a-zA-Z]/.test(letter) === false) {\n        throw Error('Invalid ')\n      }\n      const letterCode = letter.toUpperCase().charCodeAt(0) - 64\n      return { type: 'Character', value: letterCode }\n    }\n    nulCharacterAtom() {\n      // TODO implement '[lookahead  DecimalDigit]'\n      // TODO: for the deprecated octal escape sequence\n      this.consumeChar('0')\n      return { type: 'Character', value: cc('\\0') }\n    }\n    hexEscapeSequenceAtom() {\n      this.consumeChar('x')\n      return this.parseHexDigits(2)\n    }\n    regExpUnicodeEscapeSequenceAtom() {\n      this.consumeChar('u')\n      return this.parseHexDigits(4)\n    }\n    identityEscapeAtom() {\n      // TODO: implement \"SourceCharacter but not UnicodeIDContinue\"\n      // // http://unicode.org/reports/tr31/#Specific_Character_Adjustments\n      const escapedChar = this.popChar()\n      return { type: 'Character', value: cc(escapedChar) }\n    }\n    classPatternCharacterAtom() {\n      switch (this.peekChar()) {\n        // istanbul ignore next\n        case '\\n':\n        // istanbul ignore next\n        case '\\r':\n        // istanbul ignore next\n        case '\\u2028':\n        // istanbul ignore next\n        case '\\u2029':\n        // istanbul ignore next\n        case '\\\\':\n        // istanbul ignore next\n        case ']':\n          throw Error('TBD')\n        default:\n          const nextChar = this.popChar()\n          return { type: 'Character', value: cc(nextChar) }\n      }\n    }\n    characterClass() {\n      const set = []\n      let complement = false\n      this.consumeChar('[')\n      if (this.peekChar(0) === '^') {\n        this.consumeChar('^')\n        complement = true\n      }\n      while (this.isClassAtom()) {\n        const from = this.classAtom()\n        from.type === 'Character'\n        if (isCharacter(from) && this.isRangeDash()) {\n          this.consumeChar('-')\n          const to = this.classAtom()\n          to.type === 'Character'\n          // a range can only be used when both sides are single characters\n          if (isCharacter(to)) {\n            if (to.value < from.value) {\n              throw Error('Range out of order in character class')\n            }\n            set.push({ from: from.value, to: to.value })\n          } else {\n            // literal dash\n            insertToSet(from.value, set)\n            set.push(cc('-'))\n            insertToSet(to.value, set)\n          }\n        } else {\n          insertToSet(from.value, set)\n        }\n      }\n      this.consumeChar(']')\n      return { type: 'Set', complement: complement, value: set }\n    }\n    classAtom() {\n      switch (this.peekChar()) {\n        // istanbul ignore next\n        case ']':\n        // istanbul ignore next\n        case '\\n':\n        // istanbul ignore next\n        case '\\r':\n        // istanbul ignore next\n        case '\\u2028':\n        // istanbul ignore next\n        case '\\u2029':\n          throw Error('TBD')\n        case '\\\\':\n          return this.classEscape()\n        default:\n          return this.classPatternCharacterAtom()\n      }\n    }\n    classEscape() {\n      this.consumeChar('\\\\')\n      switch (this.peekChar()) {\n        // Matches a backspace.\n        // (Not to be confused with \\b word boundary outside characterClass)\n        case 'b':\n          this.consumeChar('b')\n          return { type: 'Character', value: cc('\\u0008') }\n        case 'd':\n        case 'D':\n        case 's':\n        case 'S':\n        case 'w':\n        case 'W':\n          return this.characterClassEscape()\n        case 'f':\n        case 'n':\n        case 'r':\n        case 't':\n        case 'v':\n          return this.controlEscapeAtom()\n        case 'c':\n          return this.controlLetterEscapeAtom()\n        case '0':\n          return this.nulCharacterAtom()\n        case 'x':\n          return this.hexEscapeSequenceAtom()\n        case 'u':\n          return this.regExpUnicodeEscapeSequenceAtom()\n        default:\n          return this.identityEscapeAtom()\n      }\n    }\n    group() {\n      let capturing = true\n      this.consumeChar('(')\n      switch (this.peekChar(0)) {\n        case '?':\n          this.consumeChar('?')\n          this.consumeChar(':')\n          capturing = false\n          break\n        default:\n          this.groupIdx++\n          break\n      }\n      const value = this.disjunction()\n      this.consumeChar(')')\n      const groupAst = {\n        type: 'Group',\n        capturing: capturing,\n        value: value,\n      }\n      if (capturing) {\n        groupAst['idx'] = this.groupIdx\n      }\n      return groupAst\n    }\n    positiveInteger() {\n      let number = this.popChar()\n      // istanbul ignore next - can't ever get here due to previous lookahead checks\n      // still implementing this error checking in case this ever changes.\n      if (decimalPatternNoZero.test(number) === false) {\n        throw Error('Expecting a positive integer')\n      }\n      while (decimalPattern.test(this.peekChar(0))) {\n        number += this.popChar()\n      }\n      return parseInt(number, 10)\n    }\n    integerIncludingZero() {\n      let number = this.popChar()\n      if (decimalPattern.test(number) === false) {\n        throw Error('Expecting an integer')\n      }\n      while (decimalPattern.test(this.peekChar(0))) {\n        number += this.popChar()\n      }\n      return parseInt(number, 10)\n    }\n    patternCharacter() {\n      const nextChar = this.popChar()\n      switch (nextChar) {\n        // istanbul ignore next\n        case '\\n':\n        // istanbul ignore next\n        case '\\r':\n        // istanbul ignore next\n        case '\\u2028':\n        // istanbul ignore next\n        case '\\u2029':\n        // istanbul ignore next\n        case '^':\n        // istanbul ignore next\n        case '$':\n        // istanbul ignore next\n        case '\\\\':\n        // istanbul ignore next\n        case '.':\n        // istanbul ignore next\n        case '*':\n        // istanbul ignore next\n        case '+':\n        // istanbul ignore next\n        case '?':\n        // istanbul ignore next\n        case '(':\n        // istanbul ignore next\n        case ')':\n        // istanbul ignore next\n        case '[':\n        // istanbul ignore next\n        case '|':\n          // istanbul ignore next\n          throw Error('TBD')\n        default:\n          return { type: 'Character', value: cc(nextChar) }\n      }\n    }\n    isRegExpFlag() {\n      switch (this.peekChar(0)) {\n        case 'g':\n        case 'i':\n        case 'm':\n        case 'u':\n        case 'y':\n          return true\n        default:\n          return false\n      }\n    }\n    isRangeDash() {\n      return this.peekChar() === '-' && this.isClassAtom(1)\n    }\n    isDigit() {\n      return decimalPattern.test(this.peekChar(0))\n    }\n    isClassAtom(howMuch = 0) {\n      switch (this.peekChar(howMuch)) {\n        case ']':\n        case '\\n':\n        case '\\r':\n        case '\\u2028':\n        case '\\u2029':\n          return false\n        default:\n          return true\n      }\n    }\n    isTerm() {\n      return this.isAtom() || this.isAssertion()\n    }\n    isAtom() {\n      if (this.isPatternCharacter()) {\n        return true\n      }\n      switch (this.peekChar(0)) {\n        case '.':\n        case '\\\\': // atomEscape\n        case '[': // characterClass\n        // TODO: isAtom must be called before isAssertion - disambiguate\n        case '(': // group\n          return true\n        default:\n          return false\n      }\n    }\n    isAssertion() {\n      switch (this.peekChar(0)) {\n        case '^':\n        case '$':\n          return true\n        // '\\b' or '\\B'\n        case '\\\\':\n          switch (this.peekChar(1)) {\n            case 'b':\n            case 'B':\n              return true\n            default:\n              return false\n          }\n        // '(?=' or '(?!'\n        case '(':\n          return this.peekChar(1) === '?' && (this.peekChar(2) === '=' || this.peekChar(2) === '!')\n        default:\n          return false\n      }\n    }\n    isQuantifier() {\n      const prevState = this.saveState()\n      try {\n        return this.quantifier(true) !== undefined\n      } catch (e) {\n        return false\n      } finally {\n        this.restoreState(prevState)\n      }\n    }\n    isPatternCharacter() {\n      switch (this.peekChar()) {\n        case '^':\n        case '$':\n        case '\\\\':\n        case '.':\n        case '*':\n        case '+':\n        case '?':\n        case '(':\n        case ')':\n        case '[':\n        case '|':\n        case '/':\n        case '\\n':\n        case '\\r':\n        case '\\u2028':\n        case '\\u2029':\n          return false\n        default:\n          return true\n      }\n    }\n    parseHexDigits(howMany) {\n      let hexString = ''\n      for (let i = 0; i < howMany; i++) {\n        const hexChar = this.popChar()\n        if (hexDigitPattern.test(hexChar) === false) {\n          throw Error('Expecting a HexDecimal digits')\n        }\n        hexString += hexChar\n      }\n      const charCode = parseInt(hexString, 16)\n      return { type: 'Character', value: charCode }\n    }\n    peekChar(howMuch = 0) {\n      return this.input[this.idx + howMuch]\n    }\n    popChar() {\n      const nextChar = this.peekChar(0)\n      this.consumeChar(undefined)\n      return nextChar\n    }\n    consumeChar(char) {\n      if (char !== undefined && this.input[this.idx] !== char) {\n        throw Error(\"Expected: '\" + char + \"' but found: '\" + this.input[this.idx] + \"' at offset: \" + this.idx)\n      }\n      if (this.idx >= this.input.length) {\n        throw Error('Unexpected end of input')\n      }\n      this.idx++\n    }\n    loc(begin) {\n      return { begin: begin, end: this.idx }\n    }\n  }\n\n  class BaseRegExpVisitor {\n    visitChildren(node) {\n      for (const key in node) {\n        const child = node[key]\n        /* istanbul ignore else */\n        if (node.hasOwnProperty(key)) {\n          if (child.type !== undefined) {\n            this.visit(child)\n          } else if (Array.isArray(child)) {\n            child.forEach((subChild) => {\n              this.visit(subChild)\n            }, this)\n          }\n        }\n      }\n    }\n    visit(node) {\n      switch (node.type) {\n        case 'Pattern':\n          this.visitPattern(node)\n          break\n        case 'Flags':\n          this.visitFlags(node)\n          break\n        case 'Disjunction':\n          this.visitDisjunction(node)\n          break\n        case 'Alternative':\n          this.visitAlternative(node)\n          break\n        case 'StartAnchor':\n          this.visitStartAnchor(node)\n          break\n        case 'EndAnchor':\n          this.visitEndAnchor(node)\n          break\n        case 'WordBoundary':\n          this.visitWordBoundary(node)\n          break\n        case 'NonWordBoundary':\n          this.visitNonWordBoundary(node)\n          break\n        case 'Lookahead':\n          this.visitLookahead(node)\n          break\n        case 'NegativeLookahead':\n          this.visitNegativeLookahead(node)\n          break\n        case 'Character':\n          this.visitCharacter(node)\n          break\n        case 'Set':\n          this.visitSet(node)\n          break\n        case 'Group':\n          this.visitGroup(node)\n          break\n        case 'GroupBackReference':\n          this.visitGroupBackReference(node)\n          break\n        case 'Quantifier':\n          this.visitQuantifier(node)\n          break\n      }\n      this.visitChildren(node)\n    }\n    visitPattern(node) {}\n    visitFlags(node) {}\n    visitDisjunction(node) {}\n    visitAlternative(node) {}\n    // Assertion\n    visitStartAnchor(node) {}\n    visitEndAnchor(node) {}\n    visitWordBoundary(node) {}\n    visitNonWordBoundary(node) {}\n    visitLookahead(node) {}\n    visitNegativeLookahead(node) {}\n    // atoms\n    visitCharacter(node) {}\n    visitSet(node) {}\n    visitGroup(node) {}\n    visitGroupBackReference(node) {}\n    visitQuantifier(node) {}\n  }\n\n  let regExpAstCache = {}\n  const regExpParser = new RegExpParser()\n  function getRegExpAst(regExp) {\n    const regExpStr = regExp.toString()\n    if (regExpAstCache.hasOwnProperty(regExpStr)) {\n      return regExpAstCache[regExpStr]\n    } else {\n      const regExpAst = regExpParser.pattern(regExpStr)\n      regExpAstCache[regExpStr] = regExpAst\n      return regExpAst\n    }\n  }\n  function clearRegExpParserCache() {\n    regExpAstCache = {}\n  }\n\n  const complementErrorMessage = 'Complement Sets are not supported for first char optimization'\n  const failedOptimizationPrefixMsg = 'Unable to use \"first char\" lexer optimizations:\\n'\n  function getOptimizedStartCodesIndices(regExp, ensureOptimizations = false) {\n    try {\n      const ast = getRegExpAst(regExp)\n      const firstChars = firstCharOptimizedIndices(ast.value, {}, ast.flags.ignoreCase)\n      return firstChars\n    } catch (e) {\n      /* istanbul ignore next */\n      // Testing this relies on the regexp-to-ast library having a bug... */\n      // TODO: only the else branch needs to be ignored, try to fix with newer prettier / tsc\n      if (e.message === complementErrorMessage) {\n        if (ensureOptimizations) {\n          PRINT_WARNING(\n            `${failedOptimizationPrefixMsg}` +\n              `\\tUnable to optimize: < ${regExp.toString()} >\\n` +\n              '\\tComplement Sets cannot be automatically optimized.\\n' +\n              \"\\tThis will disable the lexer's first char optimizations.\\n\" +\n              '\\tSee: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#COMPLEMENT for details.',\n          )\n        }\n      } else {\n        let msgSuffix = ''\n        if (ensureOptimizations) {\n          msgSuffix =\n            \"\\n\\tThis will disable the lexer's first char optimizations.\\n\" +\n            '\\tSee: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#REGEXP_PARSING for details.'\n        }\n        PRINT_ERROR(\n          `${failedOptimizationPrefixMsg}\\n` +\n            `\\tFailed parsing: < ${regExp.toString()} >\\n` +\n            `\\tUsing the @chevrotain/regexp-to-ast library\\n` +\n            '\\tPlease open an issue at: https://github.com/chevrotain/chevrotain/issues' +\n            msgSuffix,\n        )\n      }\n    }\n    return []\n  }\n  function firstCharOptimizedIndices(ast, result, ignoreCase) {\n    switch (ast.type) {\n      case 'Disjunction':\n        for (let i = 0; i < ast.value.length; i++) {\n          firstCharOptimizedIndices(ast.value[i], result, ignoreCase)\n        }\n        break\n      case 'Alternative':\n        const terms = ast.value\n        for (let i = 0; i < terms.length; i++) {\n          const term = terms[i]\n          // skip terms that cannot effect the first char results\n          switch (term.type) {\n            case 'EndAnchor':\n            // A group back reference cannot affect potential starting char.\n            // because if a back reference is the first production than automatically\n            // the group being referenced has had to come BEFORE so its codes have already been added\n            case 'GroupBackReference':\n            // assertions do not affect potential starting codes\n            case 'Lookahead':\n            case 'NegativeLookahead':\n            case 'StartAnchor':\n            case 'WordBoundary':\n            case 'NonWordBoundary':\n              continue\n          }\n          const atom = term\n          switch (atom.type) {\n            case 'Character':\n              addOptimizedIdxToResult(atom.value, result, ignoreCase)\n              break\n            case 'Set':\n              if (atom.complement === true) {\n                throw Error(complementErrorMessage)\n              }\n              forEach(atom.value, (code) => {\n                if (typeof code === 'number') {\n                  addOptimizedIdxToResult(code, result, ignoreCase)\n                } else {\n                  // range\n                  const range = code\n                  // cannot optimize when ignoreCase is\n                  if (ignoreCase === true) {\n                    for (let rangeCode = range.from; rangeCode <= range.to; rangeCode++) {\n                      addOptimizedIdxToResult(rangeCode, result, ignoreCase)\n                    }\n                  }\n                  // Optimization (2 orders of magnitude less work for very large ranges)\n                  else {\n                    // handle unoptimized values\n                    for (\n                      let rangeCode = range.from;\n                      rangeCode <= range.to && rangeCode < minOptimizationVal;\n                      rangeCode++\n                    ) {\n                      addOptimizedIdxToResult(rangeCode, result, ignoreCase)\n                    }\n                    // Less common charCode where we optimize for faster init time, by using larger \"buckets\"\n                    if (range.to >= minOptimizationVal) {\n                      const minUnOptVal = range.from >= minOptimizationVal ? range.from : minOptimizationVal\n                      const maxUnOptVal = range.to\n                      const minOptIdx = charCodeToOptimizedIndex(minUnOptVal)\n                      const maxOptIdx = charCodeToOptimizedIndex(maxUnOptVal)\n                      for (let currOptIdx = minOptIdx; currOptIdx <= maxOptIdx; currOptIdx++) {\n                        result[currOptIdx] = currOptIdx\n                      }\n                    }\n                  }\n                }\n              })\n              break\n            case 'Group':\n              firstCharOptimizedIndices(atom.value, result, ignoreCase)\n              break\n            /* istanbul ignore next */\n            default:\n              throw Error('Non Exhaustive Match')\n          }\n          // reached a mandatory production, no more **start** codes can be found on this alternative\n          const isOptionalQuantifier = atom.quantifier !== undefined && atom.quantifier.atLeast === 0\n          if (\n            // A group may be optional due to empty contents /(?:)/\n            // or if everything inside it is optional /((a)?)/\n            (atom.type === 'Group' && isWholeOptional(atom) === false) ||\n            // If this term is not a group it may only be optional if it has an optional quantifier\n            (atom.type !== 'Group' && isOptionalQuantifier === false)\n          ) {\n            break\n          }\n        }\n        break\n      /* istanbul ignore next */\n      default:\n        throw Error('non exhaustive match!')\n    }\n    // console.log(Object.keys(result).length)\n    return values(result)\n  }\n  function addOptimizedIdxToResult(code, result, ignoreCase) {\n    const optimizedCharIdx = charCodeToOptimizedIndex(code)\n    result[optimizedCharIdx] = optimizedCharIdx\n    if (ignoreCase === true) {\n      handleIgnoreCase(code, result)\n    }\n  }\n  function handleIgnoreCase(code, result) {\n    const char = String.fromCharCode(code)\n    const upperChar = char.toUpperCase()\n    /* istanbul ignore else */\n    if (upperChar !== char) {\n      const optimizedCharIdx = charCodeToOptimizedIndex(upperChar.charCodeAt(0))\n      result[optimizedCharIdx] = optimizedCharIdx\n    } else {\n      const lowerChar = char.toLowerCase()\n      if (lowerChar !== char) {\n        const optimizedCharIdx = charCodeToOptimizedIndex(lowerChar.charCodeAt(0))\n        result[optimizedCharIdx] = optimizedCharIdx\n      }\n    }\n  }\n  function findCode(setNode, targetCharCodes) {\n    return find$1(setNode.value, (codeOrRange) => {\n      if (typeof codeOrRange === 'number') {\n        return includes(targetCharCodes, codeOrRange)\n      } else {\n        // range\n        const range = codeOrRange\n        return find$1(targetCharCodes, (targetCode) => range.from <= targetCode && targetCode <= range.to) !== undefined\n      }\n    })\n  }\n  function isWholeOptional(ast) {\n    const quantifier = ast.quantifier\n    if (quantifier && quantifier.atLeast === 0) {\n      return true\n    }\n    if (!ast.value) {\n      return false\n    }\n    return isArray$1(ast.value) ? every(ast.value, isWholeOptional) : isWholeOptional(ast.value)\n  }\n  class CharCodeFinder extends BaseRegExpVisitor {\n    constructor(targetCharCodes) {\n      super()\n      this.targetCharCodes = targetCharCodes\n      this.found = false\n    }\n    visitChildren(node) {\n      // No need to keep looking...\n      if (this.found === true) {\n        return\n      }\n      // switch lookaheads as they do not actually consume any characters thus\n      // finding a charCode at lookahead context does not mean that regexp can actually contain it in a match.\n      switch (node.type) {\n        case 'Lookahead':\n          this.visitLookahead(node)\n          return\n        case 'NegativeLookahead':\n          this.visitNegativeLookahead(node)\n          return\n      }\n      super.visitChildren(node)\n    }\n    visitCharacter(node) {\n      if (includes(this.targetCharCodes, node.value)) {\n        this.found = true\n      }\n    }\n    visitSet(node) {\n      if (node.complement) {\n        if (findCode(node, this.targetCharCodes) === undefined) {\n          this.found = true\n        }\n      } else {\n        if (findCode(node, this.targetCharCodes) !== undefined) {\n          this.found = true\n        }\n      }\n    }\n  }\n  function canMatchCharCode(charCodes, pattern) {\n    if (pattern instanceof RegExp) {\n      const ast = getRegExpAst(pattern)\n      const charCodeFinder = new CharCodeFinder(charCodes)\n      charCodeFinder.visit(ast)\n      return charCodeFinder.found\n    } else {\n      return (\n        find$1(pattern, (char) => {\n          return includes(charCodes, char.charCodeAt(0))\n        }) !== undefined\n      )\n    }\n  }\n\n  const PATTERN = 'PATTERN'\n  const DEFAULT_MODE = 'defaultMode'\n  const MODES = 'modes'\n  let SUPPORT_STICKY = typeof new RegExp('(?:)').sticky === 'boolean'\n  function analyzeTokenTypes(tokenTypes, options) {\n    options = defaults$1(options, {\n      useSticky: SUPPORT_STICKY,\n      debug: false,\n      safeMode: false,\n      positionTracking: 'full',\n      lineTerminatorCharacters: ['\\r', '\\n'],\n      tracer: (msg, action) => action(),\n    })\n    const tracer = options.tracer\n    tracer('initCharCodeToOptimizedIndexMap', () => {\n      initCharCodeToOptimizedIndexMap()\n    })\n    let onlyRelevantTypes\n    tracer('Reject Lexer.NA', () => {\n      onlyRelevantTypes = reject(tokenTypes, (currType) => {\n        return currType[PATTERN] === Lexer.NA\n      })\n    })\n    let hasCustom = false\n    let allTransformedPatterns\n    tracer('Transform Patterns', () => {\n      hasCustom = false\n      allTransformedPatterns = map(onlyRelevantTypes, (currType) => {\n        const currPattern = currType[PATTERN]\n        /* istanbul ignore else */\n        if (isRegExp$1(currPattern)) {\n          const regExpSource = currPattern.source\n          if (\n            regExpSource.length === 1 &&\n            // only these regExp meta characters which can appear in a length one regExp\n            regExpSource !== '^' &&\n            regExpSource !== '$' &&\n            regExpSource !== '.' &&\n            !currPattern.ignoreCase\n          ) {\n            return regExpSource\n          } else if (\n            regExpSource.length === 2 &&\n            regExpSource[0] === '\\\\' &&\n            // not a meta character\n            !includes(['d', 'D', 's', 'S', 't', 'r', 'n', 't', '0', 'c', 'b', 'B', 'f', 'v', 'w', 'W'], regExpSource[1])\n          ) {\n            // escaped meta Characters: /\\+/ /\\[/\n            // or redundant escaping: /\\a/\n            // without the escaping \"\\\"\n            return regExpSource[1]\n          } else {\n            return options.useSticky ? addStickyFlag(currPattern) : addStartOfInput(currPattern)\n          }\n        } else if (isFunction(currPattern)) {\n          hasCustom = true\n          // CustomPatternMatcherFunc - custom patterns do not require any transformations, only wrapping in a RegExp Like object\n          return { exec: currPattern }\n        } else if (typeof currPattern === 'object') {\n          hasCustom = true\n          // ICustomPattern\n          return currPattern\n        } else if (typeof currPattern === 'string') {\n          if (currPattern.length === 1) {\n            return currPattern\n          } else {\n            const escapedRegExpString = currPattern.replace(/[\\\\^$.*+?()[\\]{}|]/g, '\\\\$&')\n            const wrappedRegExp = new RegExp(escapedRegExpString)\n            return options.useSticky ? addStickyFlag(wrappedRegExp) : addStartOfInput(wrappedRegExp)\n          }\n        } else {\n          throw Error('non exhaustive match')\n        }\n      })\n    })\n    let patternIdxToType\n    let patternIdxToGroup\n    let patternIdxToLongerAltIdxArr\n    let patternIdxToPushMode\n    let patternIdxToPopMode\n    tracer('misc mapping', () => {\n      patternIdxToType = map(onlyRelevantTypes, (currType) => currType.tokenTypeIdx)\n      patternIdxToGroup = map(onlyRelevantTypes, (clazz) => {\n        const groupName = clazz.GROUP\n        /* istanbul ignore next */\n        if (groupName === Lexer.SKIPPED) {\n          return undefined\n        } else if (isString(groupName)) {\n          return groupName\n        } else if (isUndefined(groupName)) {\n          return false\n        } else {\n          throw Error('non exhaustive match')\n        }\n      })\n      patternIdxToLongerAltIdxArr = map(onlyRelevantTypes, (clazz) => {\n        const longerAltType = clazz.LONGER_ALT\n        if (longerAltType) {\n          const longerAltIdxArr = isArray$1(longerAltType)\n            ? map(longerAltType, (type) => indexOf(onlyRelevantTypes, type))\n            : [indexOf(onlyRelevantTypes, longerAltType)]\n          return longerAltIdxArr\n        }\n      })\n      patternIdxToPushMode = map(onlyRelevantTypes, (clazz) => clazz.PUSH_MODE)\n      patternIdxToPopMode = map(onlyRelevantTypes, (clazz) => has(clazz, 'POP_MODE'))\n    })\n    let patternIdxToCanLineTerminator\n    tracer('Line Terminator Handling', () => {\n      const lineTerminatorCharCodes = getCharCodes(options.lineTerminatorCharacters)\n      patternIdxToCanLineTerminator = map(onlyRelevantTypes, (tokType) => false)\n      if (options.positionTracking !== 'onlyOffset') {\n        patternIdxToCanLineTerminator = map(onlyRelevantTypes, (tokType) => {\n          if (has(tokType, 'LINE_BREAKS')) {\n            return !!tokType.LINE_BREAKS\n          } else {\n            return (\n              checkLineBreaksIssues(tokType, lineTerminatorCharCodes) === false &&\n              canMatchCharCode(lineTerminatorCharCodes, tokType.PATTERN)\n            )\n          }\n        })\n      }\n    })\n    let patternIdxToIsCustom\n    let patternIdxToShort\n    let emptyGroups\n    let patternIdxToConfig\n    tracer('Misc Mapping #2', () => {\n      patternIdxToIsCustom = map(onlyRelevantTypes, isCustomPattern)\n      patternIdxToShort = map(allTransformedPatterns, isShortPattern)\n      emptyGroups = reduce(\n        onlyRelevantTypes,\n        (acc, clazz) => {\n          const groupName = clazz.GROUP\n          if (isString(groupName) && !(groupName === Lexer.SKIPPED)) {\n            acc[groupName] = []\n          }\n          return acc\n        },\n        {},\n      )\n      patternIdxToConfig = map(allTransformedPatterns, (x, idx) => {\n        return {\n          pattern: allTransformedPatterns[idx],\n          longerAlt: patternIdxToLongerAltIdxArr[idx],\n          canLineTerminator: patternIdxToCanLineTerminator[idx],\n          isCustom: patternIdxToIsCustom[idx],\n          short: patternIdxToShort[idx],\n          group: patternIdxToGroup[idx],\n          push: patternIdxToPushMode[idx],\n          pop: patternIdxToPopMode[idx],\n          tokenTypeIdx: patternIdxToType[idx],\n          tokenType: onlyRelevantTypes[idx],\n        }\n      })\n    })\n    let canBeOptimized = true\n    let charCodeToPatternIdxToConfig = []\n    if (!options.safeMode) {\n      tracer('First Char Optimization', () => {\n        charCodeToPatternIdxToConfig = reduce(\n          onlyRelevantTypes,\n          (result, currTokType, idx) => {\n            if (typeof currTokType.PATTERN === 'string') {\n              const charCode = currTokType.PATTERN.charCodeAt(0)\n              const optimizedIdx = charCodeToOptimizedIndex(charCode)\n              addToMapOfArrays(result, optimizedIdx, patternIdxToConfig[idx])\n            } else if (isArray$1(currTokType.START_CHARS_HINT)) {\n              let lastOptimizedIdx\n              forEach(currTokType.START_CHARS_HINT, (charOrInt) => {\n                const charCode = typeof charOrInt === 'string' ? charOrInt.charCodeAt(0) : charOrInt\n                const currOptimizedIdx = charCodeToOptimizedIndex(charCode)\n                // Avoid adding the config multiple times\n                /* istanbul ignore else */\n                // - Difficult to check this scenario effects as it is only a performance\n                //   optimization that does not change correctness\n                if (lastOptimizedIdx !== currOptimizedIdx) {\n                  lastOptimizedIdx = currOptimizedIdx\n                  addToMapOfArrays(result, currOptimizedIdx, patternIdxToConfig[idx])\n                }\n              })\n            } else if (isRegExp$1(currTokType.PATTERN)) {\n              if (currTokType.PATTERN.unicode) {\n                canBeOptimized = false\n                if (options.ensureOptimizations) {\n                  PRINT_ERROR(\n                    `${failedOptimizationPrefixMsg}` +\n                      `\\tUnable to analyze < ${currTokType.PATTERN.toString()} > pattern.\\n` +\n                      '\\tThe regexp unicode flag is not currently supported by the regexp-to-ast library.\\n' +\n                      \"\\tThis will disable the lexer's first char optimizations.\\n\" +\n                      '\\tFor details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#UNICODE_OPTIMIZE',\n                  )\n                }\n              } else {\n                const optimizedCodes = getOptimizedStartCodesIndices(currTokType.PATTERN, options.ensureOptimizations)\n                /* istanbul ignore if */\n                // start code will only be empty given an empty regExp or failure of regexp-to-ast library\n                // the first should be a different validation and the second cannot be tested.\n                if (isEmpty(optimizedCodes)) {\n                  // we cannot understand what codes may start possible matches\n                  // The optimization correctness requires knowing start codes for ALL patterns.\n                  // Not actually sure this is an error, no debug message\n                  canBeOptimized = false\n                }\n                forEach(optimizedCodes, (code) => {\n                  addToMapOfArrays(result, code, patternIdxToConfig[idx])\n                })\n              }\n            } else {\n              if (options.ensureOptimizations) {\n                PRINT_ERROR(\n                  `${failedOptimizationPrefixMsg}` +\n                    `\\tTokenType: <${currTokType.name}> is using a custom token pattern without providing <start_chars_hint> parameter.\\n` +\n                    \"\\tThis will disable the lexer's first char optimizations.\\n\" +\n                    '\\tFor details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#CUSTOM_OPTIMIZE',\n                )\n              }\n              canBeOptimized = false\n            }\n            return result\n          },\n          [],\n        )\n      })\n    }\n    return {\n      emptyGroups: emptyGroups,\n      patternIdxToConfig: patternIdxToConfig,\n      charCodeToPatternIdxToConfig: charCodeToPatternIdxToConfig,\n      hasCustom: hasCustom,\n      canBeOptimized: canBeOptimized,\n    }\n  }\n  function validatePatterns(tokenTypes, validModesNames) {\n    let errors = []\n    const missingResult = findMissingPatterns(tokenTypes)\n    errors = errors.concat(missingResult.errors)\n    const invalidResult = findInvalidPatterns(missingResult.valid)\n    const validTokenTypes = invalidResult.valid\n    errors = errors.concat(invalidResult.errors)\n    errors = errors.concat(validateRegExpPattern(validTokenTypes))\n    errors = errors.concat(findInvalidGroupType(validTokenTypes))\n    errors = errors.concat(findModesThatDoNotExist(validTokenTypes, validModesNames))\n    errors = errors.concat(findUnreachablePatterns(validTokenTypes))\n    return errors\n  }\n  function validateRegExpPattern(tokenTypes) {\n    let errors = []\n    const withRegExpPatterns = filter(tokenTypes, (currTokType) => isRegExp$1(currTokType[PATTERN]))\n    errors = errors.concat(findEndOfInputAnchor(withRegExpPatterns))\n    errors = errors.concat(findStartOfInputAnchor(withRegExpPatterns))\n    errors = errors.concat(findUnsupportedFlags(withRegExpPatterns))\n    errors = errors.concat(findDuplicatePatterns(withRegExpPatterns))\n    errors = errors.concat(findEmptyMatchRegExps(withRegExpPatterns))\n    return errors\n  }\n  function findMissingPatterns(tokenTypes) {\n    const tokenTypesWithMissingPattern = filter(tokenTypes, (currType) => {\n      return !has(currType, PATTERN)\n    })\n    const errors = map(tokenTypesWithMissingPattern, (currType) => {\n      return {\n        message: 'Token Type: ->' + currType.name + \"<- missing static 'PATTERN' property\",\n        type: LexerDefinitionErrorType.MISSING_PATTERN,\n        tokenTypes: [currType],\n      }\n    })\n    const valid = difference$1(tokenTypes, tokenTypesWithMissingPattern)\n    return { errors, valid }\n  }\n  function findInvalidPatterns(tokenTypes) {\n    const tokenTypesWithInvalidPattern = filter(tokenTypes, (currType) => {\n      const pattern = currType[PATTERN]\n      return !isRegExp$1(pattern) && !isFunction(pattern) && !has(pattern, 'exec') && !isString(pattern)\n    })\n    const errors = map(tokenTypesWithInvalidPattern, (currType) => {\n      return {\n        message:\n          'Token Type: ->' +\n          currType.name +\n          \"<- static 'PATTERN' can only be a RegExp, a\" +\n          ' Function matching the {CustomPatternMatcherFunc} type or an Object matching the {ICustomPattern} interface.',\n        type: LexerDefinitionErrorType.INVALID_PATTERN,\n        tokenTypes: [currType],\n      }\n    })\n    const valid = difference$1(tokenTypes, tokenTypesWithInvalidPattern)\n    return { errors, valid }\n  }\n  const end_of_input = /[^\\\\][$]/\n  function findEndOfInputAnchor(tokenTypes) {\n    class EndAnchorFinder extends BaseRegExpVisitor {\n      constructor() {\n        super(...arguments)\n        this.found = false\n      }\n      visitEndAnchor(node) {\n        this.found = true\n      }\n    }\n    const invalidRegex = filter(tokenTypes, (currType) => {\n      const pattern = currType.PATTERN\n      try {\n        const regexpAst = getRegExpAst(pattern)\n        const endAnchorVisitor = new EndAnchorFinder()\n        endAnchorVisitor.visit(regexpAst)\n        return endAnchorVisitor.found\n      } catch (e) {\n        // old behavior in case of runtime exceptions with regexp-to-ast.\n        /* istanbul ignore next - cannot ensure an error in regexp-to-ast*/\n        return end_of_input.test(pattern.source)\n      }\n    })\n    const errors = map(invalidRegex, (currType) => {\n      return {\n        message:\n          'Unexpected RegExp Anchor Error:\\n' +\n          '\\tToken Type: ->' +\n          currType.name +\n          \"<- static 'PATTERN' cannot contain end of input anchor '$'\\n\" +\n          '\\tSee chevrotain.io/docs/guide/resolving_lexer_errors.html#ANCHORS' +\n          '\\tfor details.',\n        type: LexerDefinitionErrorType.EOI_ANCHOR_FOUND,\n        tokenTypes: [currType],\n      }\n    })\n    return errors\n  }\n  function findEmptyMatchRegExps(tokenTypes) {\n    const matchesEmptyString = filter(tokenTypes, (currType) => {\n      const pattern = currType.PATTERN\n      return pattern.test('')\n    })\n    const errors = map(matchesEmptyString, (currType) => {\n      return {\n        message: 'Token Type: ->' + currType.name + \"<- static 'PATTERN' must not match an empty string\",\n        type: LexerDefinitionErrorType.EMPTY_MATCH_PATTERN,\n        tokenTypes: [currType],\n      }\n    })\n    return errors\n  }\n  const start_of_input = /[^\\\\[][\\^]|^\\^/\n  function findStartOfInputAnchor(tokenTypes) {\n    class StartAnchorFinder extends BaseRegExpVisitor {\n      constructor() {\n        super(...arguments)\n        this.found = false\n      }\n      visitStartAnchor(node) {\n        this.found = true\n      }\n    }\n    const invalidRegex = filter(tokenTypes, (currType) => {\n      const pattern = currType.PATTERN\n      try {\n        const regexpAst = getRegExpAst(pattern)\n        const startAnchorVisitor = new StartAnchorFinder()\n        startAnchorVisitor.visit(regexpAst)\n        return startAnchorVisitor.found\n      } catch (e) {\n        // old behavior in case of runtime exceptions with regexp-to-ast.\n        /* istanbul ignore next - cannot ensure an error in regexp-to-ast*/\n        return start_of_input.test(pattern.source)\n      }\n    })\n    const errors = map(invalidRegex, (currType) => {\n      return {\n        message:\n          'Unexpected RegExp Anchor Error:\\n' +\n          '\\tToken Type: ->' +\n          currType.name +\n          \"<- static 'PATTERN' cannot contain start of input anchor '^'\\n\" +\n          '\\tSee https://chevrotain.io/docs/guide/resolving_lexer_errors.html#ANCHORS' +\n          '\\tfor details.',\n        type: LexerDefinitionErrorType.SOI_ANCHOR_FOUND,\n        tokenTypes: [currType],\n      }\n    })\n    return errors\n  }\n  function findUnsupportedFlags(tokenTypes) {\n    const invalidFlags = filter(tokenTypes, (currType) => {\n      const pattern = currType[PATTERN]\n      return pattern instanceof RegExp && (pattern.multiline || pattern.global)\n    })\n    const errors = map(invalidFlags, (currType) => {\n      return {\n        message: 'Token Type: ->' + currType.name + \"<- static 'PATTERN' may NOT contain global('g') or multiline('m')\",\n        type: LexerDefinitionErrorType.UNSUPPORTED_FLAGS_FOUND,\n        tokenTypes: [currType],\n      }\n    })\n    return errors\n  }\n  // This can only test for identical duplicate RegExps, not semantically equivalent ones.\n  function findDuplicatePatterns(tokenTypes) {\n    const found = []\n    let identicalPatterns = map(tokenTypes, (outerType) => {\n      return reduce(\n        tokenTypes,\n        (result, innerType) => {\n          if (\n            outerType.PATTERN.source === innerType.PATTERN.source &&\n            !includes(found, innerType) &&\n            innerType.PATTERN !== Lexer.NA\n          ) {\n            // this avoids duplicates in the result, each Token Type may only appear in one \"set\"\n            // in essence we are creating Equivalence classes on equality relation.\n            found.push(innerType)\n            result.push(innerType)\n            return result\n          }\n          return result\n        },\n        [],\n      )\n    })\n    identicalPatterns = compact(identicalPatterns)\n    const duplicatePatterns = filter(identicalPatterns, (currIdenticalSet) => {\n      return currIdenticalSet.length > 1\n    })\n    const errors = map(duplicatePatterns, (setOfIdentical) => {\n      const tokenTypeNames = map(setOfIdentical, (currType) => {\n        return currType.name\n      })\n      const dupPatternSrc = head(setOfIdentical).PATTERN\n      return {\n        message:\n          `The same RegExp pattern ->${dupPatternSrc}<-` +\n          `has been used in all of the following Token Types: ${tokenTypeNames.join(', ')} <-`,\n        type: LexerDefinitionErrorType.DUPLICATE_PATTERNS_FOUND,\n        tokenTypes: setOfIdentical,\n      }\n    })\n    return errors\n  }\n  function findInvalidGroupType(tokenTypes) {\n    const invalidTypes = filter(tokenTypes, (clazz) => {\n      if (!has(clazz, 'GROUP')) {\n        return false\n      }\n      const group = clazz.GROUP\n      return group !== Lexer.SKIPPED && group !== Lexer.NA && !isString(group)\n    })\n    const errors = map(invalidTypes, (currType) => {\n      return {\n        message: 'Token Type: ->' + currType.name + \"<- static 'GROUP' can only be Lexer.SKIPPED/Lexer.NA/A String\",\n        type: LexerDefinitionErrorType.INVALID_GROUP_TYPE_FOUND,\n        tokenTypes: [currType],\n      }\n    })\n    return errors\n  }\n  function findModesThatDoNotExist(tokenTypes, validModes) {\n    const invalidModes = filter(tokenTypes, (clazz) => {\n      return clazz.PUSH_MODE !== undefined && !includes(validModes, clazz.PUSH_MODE)\n    })\n    const errors = map(invalidModes, (tokType) => {\n      const msg =\n        `Token Type: ->${tokType.name}<- static 'PUSH_MODE' value cannot refer to a Lexer Mode ->${tokType.PUSH_MODE}<-` +\n        `which does not exist`\n      return {\n        message: msg,\n        type: LexerDefinitionErrorType.PUSH_MODE_DOES_NOT_EXIST,\n        tokenTypes: [tokType],\n      }\n    })\n    return errors\n  }\n  function findUnreachablePatterns(tokenTypes) {\n    const errors = []\n    const canBeTested = reduce(\n      tokenTypes,\n      (result, tokType, idx) => {\n        const pattern = tokType.PATTERN\n        if (pattern === Lexer.NA) {\n          return result\n        }\n        // a more comprehensive validation for all forms of regExps would require\n        // deeper regExp analysis capabilities\n        if (isString(pattern)) {\n          result.push({ str: pattern, idx, tokenType: tokType })\n        } else if (isRegExp$1(pattern) && noMetaChar(pattern)) {\n          result.push({ str: pattern.source, idx, tokenType: tokType })\n        }\n        return result\n      },\n      [],\n    )\n    forEach(tokenTypes, (tokType, testIdx) => {\n      forEach(canBeTested, ({ str, idx, tokenType }) => {\n        if (testIdx < idx && testTokenType(str, tokType.PATTERN)) {\n          const msg =\n            `Token: ->${tokenType.name}<- can never be matched.\\n` +\n            `Because it appears AFTER the Token Type ->${tokType.name}<-` +\n            `in the lexer's definition.\\n` +\n            `See https://chevrotain.io/docs/guide/resolving_lexer_errors.html#UNREACHABLE`\n          errors.push({\n            message: msg,\n            type: LexerDefinitionErrorType.UNREACHABLE_PATTERN,\n            tokenTypes: [tokType, tokenType],\n          })\n        }\n      })\n    })\n    return errors\n  }\n  function testTokenType(str, pattern) {\n    /* istanbul ignore else */\n    if (isRegExp$1(pattern)) {\n      const regExpArray = pattern.exec(str)\n      return regExpArray !== null && regExpArray.index === 0\n    } else if (isFunction(pattern)) {\n      // maintain the API of custom patterns\n      return pattern(str, 0, [], {})\n    } else if (has(pattern, 'exec')) {\n      // maintain the API of custom patterns\n      return pattern.exec(str, 0, [], {})\n    } else if (typeof pattern === 'string') {\n      return pattern === str\n    } else {\n      throw Error('non exhaustive match')\n    }\n  }\n  function noMetaChar(regExp) {\n    //https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp\n    const metaChars = ['.', '\\\\', '[', ']', '|', '^', '$', '(', ')', '?', '*', '+', '{']\n    return find$1(metaChars, (char) => regExp.source.indexOf(char) !== -1) === undefined\n  }\n  function addStartOfInput(pattern) {\n    const flags = pattern.ignoreCase ? 'i' : ''\n    // always wrapping in a none capturing group preceded by '^' to make sure matching can only work on start of input.\n    // duplicate/redundant start of input markers have no meaning (/^^^^A/ === /^A/)\n    return new RegExp(`^(?:${pattern.source})`, flags)\n  }\n  function addStickyFlag(pattern) {\n    const flags = pattern.ignoreCase ? 'iy' : 'y'\n    // always wrapping in a none capturing group preceded by '^' to make sure matching can only work on start of input.\n    // duplicate/redundant start of input markers have no meaning (/^^^^A/ === /^A/)\n    return new RegExp(`${pattern.source}`, flags)\n  }\n  function performRuntimeChecks(lexerDefinition, trackLines, lineTerminatorCharacters) {\n    const errors = []\n    // some run time checks to help the end users.\n    if (!has(lexerDefinition, DEFAULT_MODE)) {\n      errors.push({\n        message:\n          'A MultiMode Lexer cannot be initialized without a <' + DEFAULT_MODE + '> property in its definition\\n',\n        type: LexerDefinitionErrorType.MULTI_MODE_LEXER_WITHOUT_DEFAULT_MODE,\n      })\n    }\n    if (!has(lexerDefinition, MODES)) {\n      errors.push({\n        message: 'A MultiMode Lexer cannot be initialized without a <' + MODES + '> property in its definition\\n',\n        type: LexerDefinitionErrorType.MULTI_MODE_LEXER_WITHOUT_MODES_PROPERTY,\n      })\n    }\n    if (\n      has(lexerDefinition, MODES) &&\n      has(lexerDefinition, DEFAULT_MODE) &&\n      !has(lexerDefinition.modes, lexerDefinition.defaultMode)\n    ) {\n      errors.push({\n        message:\n          `A MultiMode Lexer cannot be initialized with a ${DEFAULT_MODE}: <${lexerDefinition.defaultMode}>` +\n          `which does not exist\\n`,\n        type: LexerDefinitionErrorType.MULTI_MODE_LEXER_DEFAULT_MODE_VALUE_DOES_NOT_EXIST,\n      })\n    }\n    if (has(lexerDefinition, MODES)) {\n      forEach(lexerDefinition.modes, (currModeValue, currModeName) => {\n        forEach(currModeValue, (currTokType, currIdx) => {\n          if (isUndefined(currTokType)) {\n            errors.push({\n              message:\n                `A Lexer cannot be initialized using an undefined Token Type. Mode:` +\n                `<${currModeName}> at index: <${currIdx}>\\n`,\n              type: LexerDefinitionErrorType.LEXER_DEFINITION_CANNOT_CONTAIN_UNDEFINED,\n            })\n          } else if (has(currTokType, 'LONGER_ALT')) {\n            const longerAlt = isArray$1(currTokType.LONGER_ALT) ? currTokType.LONGER_ALT : [currTokType.LONGER_ALT]\n            forEach(longerAlt, (currLongerAlt) => {\n              if (!isUndefined(currLongerAlt) && !includes(currModeValue, currLongerAlt)) {\n                errors.push({\n                  message: `A MultiMode Lexer cannot be initialized with a longer_alt <${currLongerAlt.name}> on token <${currTokType.name}> outside of mode <${currModeName}>\\n`,\n                  type: LexerDefinitionErrorType.MULTI_MODE_LEXER_LONGER_ALT_NOT_IN_CURRENT_MODE,\n                })\n              }\n            })\n          }\n        })\n      })\n    }\n    return errors\n  }\n  function performWarningRuntimeChecks(lexerDefinition, trackLines, lineTerminatorCharacters) {\n    const warnings = []\n    let hasAnyLineBreak = false\n    const allTokenTypes = compact(flatten(values(lexerDefinition.modes)))\n    const concreteTokenTypes = reject(allTokenTypes, (currType) => currType[PATTERN] === Lexer.NA)\n    const terminatorCharCodes = getCharCodes(lineTerminatorCharacters)\n    if (trackLines) {\n      forEach(concreteTokenTypes, (tokType) => {\n        const currIssue = checkLineBreaksIssues(tokType, terminatorCharCodes)\n        if (currIssue !== false) {\n          const message = buildLineBreakIssueMessage(tokType, currIssue)\n          const warningDescriptor = {\n            message,\n            type: currIssue.issue,\n            tokenType: tokType,\n          }\n          warnings.push(warningDescriptor)\n        } else {\n          // we don't want to attempt to scan if the user explicitly specified the line_breaks option.\n          if (has(tokType, 'LINE_BREAKS')) {\n            if (tokType.LINE_BREAKS === true) {\n              hasAnyLineBreak = true\n            }\n          } else {\n            if (canMatchCharCode(terminatorCharCodes, tokType.PATTERN)) {\n              hasAnyLineBreak = true\n            }\n          }\n        }\n      })\n    }\n    if (trackLines && !hasAnyLineBreak) {\n      warnings.push({\n        message:\n          'Warning: No LINE_BREAKS Found.\\n' +\n          '\\tThis Lexer has been defined to track line and column information,\\n' +\n          '\\tBut none of the Token Types can be identified as matching a line terminator.\\n' +\n          '\\tSee https://chevrotain.io/docs/guide/resolving_lexer_errors.html#LINE_BREAKS \\n' +\n          '\\tfor details.',\n        type: LexerDefinitionErrorType.NO_LINE_BREAKS_FLAGS,\n      })\n    }\n    return warnings\n  }\n  function cloneEmptyGroups(emptyGroups) {\n    const clonedResult = {}\n    const groupKeys = keys(emptyGroups)\n    forEach(groupKeys, (currKey) => {\n      const currGroupValue = emptyGroups[currKey]\n      /* istanbul ignore else */\n      if (isArray$1(currGroupValue)) {\n        clonedResult[currKey] = []\n      } else {\n        throw Error('non exhaustive match')\n      }\n    })\n    return clonedResult\n  }\n  // TODO: refactor to avoid duplication\n  function isCustomPattern(tokenType) {\n    const pattern = tokenType.PATTERN\n    /* istanbul ignore else */\n    if (isRegExp$1(pattern)) {\n      return false\n    } else if (isFunction(pattern)) {\n      // CustomPatternMatcherFunc - custom patterns do not require any transformations, only wrapping in a RegExp Like object\n      return true\n    } else if (has(pattern, 'exec')) {\n      // ICustomPattern\n      return true\n    } else if (isString(pattern)) {\n      return false\n    } else {\n      throw Error('non exhaustive match')\n    }\n  }\n  function isShortPattern(pattern) {\n    if (isString(pattern) && pattern.length === 1) {\n      return pattern.charCodeAt(0)\n    } else {\n      return false\n    }\n  }\n  /**\n   * Faster than using a RegExp for default newline detection during lexing.\n   */\n  const LineTerminatorOptimizedTester = {\n    // implements /\\n|\\r\\n?/g.test\n    test: function (text) {\n      const len = text.length\n      for (let i = this.lastIndex; i < len; i++) {\n        const c = text.charCodeAt(i)\n        if (c === 10) {\n          this.lastIndex = i + 1\n          return true\n        } else if (c === 13) {\n          if (text.charCodeAt(i + 1) === 10) {\n            this.lastIndex = i + 2\n          } else {\n            this.lastIndex = i + 1\n          }\n          return true\n        }\n      }\n      return false\n    },\n    lastIndex: 0,\n  }\n  function checkLineBreaksIssues(tokType, lineTerminatorCharCodes) {\n    if (has(tokType, 'LINE_BREAKS')) {\n      // if the user explicitly declared the line_breaks option we will respect their choice\n      // and assume it is correct.\n      return false\n    } else {\n      /* istanbul ignore else */\n      if (isRegExp$1(tokType.PATTERN)) {\n        try {\n          // TODO: why is the casting suddenly needed?\n          canMatchCharCode(lineTerminatorCharCodes, tokType.PATTERN)\n        } catch (e) {\n          /* istanbul ignore next - to test this we would have to mock <canMatchCharCode> to throw an error */\n          return {\n            issue: LexerDefinitionErrorType.IDENTIFY_TERMINATOR,\n            errMsg: e.message,\n          }\n        }\n        return false\n      } else if (isString(tokType.PATTERN)) {\n        // string literal patterns can always be analyzed to detect line terminator usage\n        return false\n      } else if (isCustomPattern(tokType)) {\n        // custom token types\n        return { issue: LexerDefinitionErrorType.CUSTOM_LINE_BREAK }\n      } else {\n        throw Error('non exhaustive match')\n      }\n    }\n  }\n  function buildLineBreakIssueMessage(tokType, details) {\n    /* istanbul ignore else */\n    if (details.issue === LexerDefinitionErrorType.IDENTIFY_TERMINATOR) {\n      return (\n        'Warning: unable to identify line terminator usage in pattern.\\n' +\n        `\\tThe problem is in the <${tokType.name}> Token Type\\n` +\n        `\\t Root cause: ${details.errMsg}.\\n` +\n        '\\tFor details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#IDENTIFY_TERMINATOR'\n      )\n    } else if (details.issue === LexerDefinitionErrorType.CUSTOM_LINE_BREAK) {\n      return (\n        'Warning: A Custom Token Pattern should specify the <line_breaks> option.\\n' +\n        `\\tThe problem is in the <${tokType.name}> Token Type\\n` +\n        '\\tFor details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#CUSTOM_LINE_BREAK'\n      )\n    } else {\n      throw Error('non exhaustive match')\n    }\n  }\n  function getCharCodes(charsOrCodes) {\n    const charCodes = map(charsOrCodes, (numOrString) => {\n      if (isString(numOrString)) {\n        return numOrString.charCodeAt(0)\n      } else {\n        return numOrString\n      }\n    })\n    return charCodes\n  }\n  function addToMapOfArrays(map, key, value) {\n    if (map[key] === undefined) {\n      map[key] = [value]\n    } else {\n      map[key].push(value)\n    }\n  }\n  const minOptimizationVal = 256\n  /**\n   * We are mapping charCode above ASCI (256) into buckets each in the size of 256.\n   * This is because ASCI are the most common start chars so each one of those will get its own\n   * possible token configs vector.\n   *\n   * Tokens starting with charCodes \"above\" ASCI are uncommon, so we can \"afford\"\n   * to place these into buckets of possible token configs, What we gain from\n   * this is avoiding the case of creating an optimization 'charCodeToPatternIdxToConfig'\n   * which would contain 10,000+ arrays of small size (e.g unicode Identifiers scenario).\n   * Our 'charCodeToPatternIdxToConfig' max size will now be:\n   * 256 + (2^16 / 2^8) - 1 === 511\n   *\n   * note the hack for fast division integer part extraction\n   * See: https://stackoverflow.com/a/4228528\n   */\n  let charCodeToOptimizedIdxMap = []\n  function charCodeToOptimizedIndex(charCode) {\n    return charCode < minOptimizationVal ? charCode : charCodeToOptimizedIdxMap[charCode]\n  }\n  /**\n   * This is a compromise between cold start / hot running performance\n   * Creating this array takes ~3ms on a modern machine,\n   * But if we perform the computation at runtime as needed the CSS Lexer benchmark\n   * performance degrades by ~10%\n   *\n   * TODO: Perhaps it should be lazy initialized only if a charCode > 255 is used.\n   */\n  function initCharCodeToOptimizedIndexMap() {\n    if (isEmpty(charCodeToOptimizedIdxMap)) {\n      charCodeToOptimizedIdxMap = new Array(65536)\n      for (let i = 0; i < 65536; i++) {\n        charCodeToOptimizedIdxMap[i] = i > 255 ? 255 + ~~(i / 255) : i\n      }\n    }\n  }\n\n  function tokenStructuredMatcher(tokInstance, tokConstructor) {\n    const instanceType = tokInstance.tokenTypeIdx\n    if (instanceType === tokConstructor.tokenTypeIdx) {\n      return true\n    } else {\n      return tokConstructor.isParent === true && tokConstructor.categoryMatchesMap[instanceType] === true\n    }\n  }\n  // Optimized tokenMatcher in case our grammar does not use token categories\n  // Being so tiny it is much more likely to be in-lined and this avoid the function call overhead\n  function tokenStructuredMatcherNoCategories(token, tokType) {\n    return token.tokenTypeIdx === tokType.tokenTypeIdx\n  }\n  let tokenShortNameIdx = 1\n  const tokenIdxToClass = {}\n  function augmentTokenTypes(tokenTypes) {\n    // collect the parent Token Types as well.\n    const tokenTypesAndParents = expandCategories(tokenTypes)\n    // add required tokenType and categoryMatches properties\n    assignTokenDefaultProps(tokenTypesAndParents)\n    // fill up the categoryMatches\n    assignCategoriesMapProp(tokenTypesAndParents)\n    assignCategoriesTokensProp(tokenTypesAndParents)\n    forEach(tokenTypesAndParents, (tokType) => {\n      tokType.isParent = tokType.categoryMatches.length > 0\n    })\n  }\n  function expandCategories(tokenTypes) {\n    let result = clone(tokenTypes)\n    let categories = tokenTypes\n    let searching = true\n    while (searching) {\n      categories = compact(flatten(map(categories, (currTokType) => currTokType.CATEGORIES)))\n      const newCategories = difference$1(categories, result)\n      result = result.concat(newCategories)\n      if (isEmpty(newCategories)) {\n        searching = false\n      } else {\n        categories = newCategories\n      }\n    }\n    return result\n  }\n  function assignTokenDefaultProps(tokenTypes) {\n    forEach(tokenTypes, (currTokType) => {\n      if (!hasShortKeyProperty(currTokType)) {\n        tokenIdxToClass[tokenShortNameIdx] = currTokType\n        currTokType.tokenTypeIdx = tokenShortNameIdx++\n      }\n      // CATEGORIES? : TokenType | TokenType[]\n      if (\n        hasCategoriesProperty(currTokType) &&\n        !isArray$1(currTokType.CATEGORIES)\n        // &&\n        // !isUndefined(currTokType.CATEGORIES.PATTERN)\n      ) {\n        currTokType.CATEGORIES = [currTokType.CATEGORIES]\n      }\n      if (!hasCategoriesProperty(currTokType)) {\n        currTokType.CATEGORIES = []\n      }\n      if (!hasExtendingTokensTypesProperty(currTokType)) {\n        currTokType.categoryMatches = []\n      }\n      if (!hasExtendingTokensTypesMapProperty(currTokType)) {\n        currTokType.categoryMatchesMap = {}\n      }\n    })\n  }\n  function assignCategoriesTokensProp(tokenTypes) {\n    forEach(tokenTypes, (currTokType) => {\n      // avoid duplications\n      currTokType.categoryMatches = []\n      forEach(currTokType.categoryMatchesMap, (val, key) => {\n        currTokType.categoryMatches.push(tokenIdxToClass[key].tokenTypeIdx)\n      })\n    })\n  }\n  function assignCategoriesMapProp(tokenTypes) {\n    forEach(tokenTypes, (currTokType) => {\n      singleAssignCategoriesToksMap([], currTokType)\n    })\n  }\n  function singleAssignCategoriesToksMap(path, nextNode) {\n    forEach(path, (pathNode) => {\n      nextNode.categoryMatchesMap[pathNode.tokenTypeIdx] = true\n    })\n    forEach(nextNode.CATEGORIES, (nextCategory) => {\n      const newPath = path.concat(nextNode)\n      // avoids infinite loops due to cyclic categories.\n      if (!includes(newPath, nextCategory)) {\n        singleAssignCategoriesToksMap(newPath, nextCategory)\n      }\n    })\n  }\n  function hasShortKeyProperty(tokType) {\n    return has(tokType, 'tokenTypeIdx')\n  }\n  function hasCategoriesProperty(tokType) {\n    return has(tokType, 'CATEGORIES')\n  }\n  function hasExtendingTokensTypesProperty(tokType) {\n    return has(tokType, 'categoryMatches')\n  }\n  function hasExtendingTokensTypesMapProperty(tokType) {\n    return has(tokType, 'categoryMatchesMap')\n  }\n  function isTokenType(tokType) {\n    return has(tokType, 'tokenTypeIdx')\n  }\n\n  const defaultLexerErrorProvider = {\n    buildUnableToPopLexerModeMessage(token) {\n      return `Unable to pop Lexer Mode after encountering Token ->${token.image}<- The Mode Stack is empty`\n    },\n    buildUnexpectedCharactersMessage(fullText, startOffset, length, line, column) {\n      return (\n        `unexpected character: ->${fullText.charAt(startOffset)}<- at offset: ${startOffset},` +\n        ` skipped ${length} characters.`\n      )\n    },\n  }\n\n  var LexerDefinitionErrorType\n  ;(function (LexerDefinitionErrorType) {\n    LexerDefinitionErrorType[(LexerDefinitionErrorType['MISSING_PATTERN'] = 0)] = 'MISSING_PATTERN'\n    LexerDefinitionErrorType[(LexerDefinitionErrorType['INVALID_PATTERN'] = 1)] = 'INVALID_PATTERN'\n    LexerDefinitionErrorType[(LexerDefinitionErrorType['EOI_ANCHOR_FOUND'] = 2)] = 'EOI_ANCHOR_FOUND'\n    LexerDefinitionErrorType[(LexerDefinitionErrorType['UNSUPPORTED_FLAGS_FOUND'] = 3)] = 'UNSUPPORTED_FLAGS_FOUND'\n    LexerDefinitionErrorType[(LexerDefinitionErrorType['DUPLICATE_PATTERNS_FOUND'] = 4)] = 'DUPLICATE_PATTERNS_FOUND'\n    LexerDefinitionErrorType[(LexerDefinitionErrorType['INVALID_GROUP_TYPE_FOUND'] = 5)] = 'INVALID_GROUP_TYPE_FOUND'\n    LexerDefinitionErrorType[(LexerDefinitionErrorType['PUSH_MODE_DOES_NOT_EXIST'] = 6)] = 'PUSH_MODE_DOES_NOT_EXIST'\n    LexerDefinitionErrorType[(LexerDefinitionErrorType['MULTI_MODE_LEXER_WITHOUT_DEFAULT_MODE'] = 7)] =\n      'MULTI_MODE_LEXER_WITHOUT_DEFAULT_MODE'\n    LexerDefinitionErrorType[(LexerDefinitionErrorType['MULTI_MODE_LEXER_WITHOUT_MODES_PROPERTY'] = 8)] =\n      'MULTI_MODE_LEXER_WITHOUT_MODES_PROPERTY'\n    LexerDefinitionErrorType[(LexerDefinitionErrorType['MULTI_MODE_LEXER_DEFAULT_MODE_VALUE_DOES_NOT_EXIST'] = 9)] =\n      'MULTI_MODE_LEXER_DEFAULT_MODE_VALUE_DOES_NOT_EXIST'\n    LexerDefinitionErrorType[(LexerDefinitionErrorType['LEXER_DEFINITION_CANNOT_CONTAIN_UNDEFINED'] = 10)] =\n      'LEXER_DEFINITION_CANNOT_CONTAIN_UNDEFINED'\n    LexerDefinitionErrorType[(LexerDefinitionErrorType['SOI_ANCHOR_FOUND'] = 11)] = 'SOI_ANCHOR_FOUND'\n    LexerDefinitionErrorType[(LexerDefinitionErrorType['EMPTY_MATCH_PATTERN'] = 12)] = 'EMPTY_MATCH_PATTERN'\n    LexerDefinitionErrorType[(LexerDefinitionErrorType['NO_LINE_BREAKS_FLAGS'] = 13)] = 'NO_LINE_BREAKS_FLAGS'\n    LexerDefinitionErrorType[(LexerDefinitionErrorType['UNREACHABLE_PATTERN'] = 14)] = 'UNREACHABLE_PATTERN'\n    LexerDefinitionErrorType[(LexerDefinitionErrorType['IDENTIFY_TERMINATOR'] = 15)] = 'IDENTIFY_TERMINATOR'\n    LexerDefinitionErrorType[(LexerDefinitionErrorType['CUSTOM_LINE_BREAK'] = 16)] = 'CUSTOM_LINE_BREAK'\n    LexerDefinitionErrorType[(LexerDefinitionErrorType['MULTI_MODE_LEXER_LONGER_ALT_NOT_IN_CURRENT_MODE'] = 17)] =\n      'MULTI_MODE_LEXER_LONGER_ALT_NOT_IN_CURRENT_MODE'\n  })(LexerDefinitionErrorType || (LexerDefinitionErrorType = {}))\n  const DEFAULT_LEXER_CONFIG = {\n    deferDefinitionErrorsHandling: false,\n    positionTracking: 'full',\n    lineTerminatorsPattern: /\\n|\\r\\n?/g,\n    lineTerminatorCharacters: ['\\n', '\\r'],\n    ensureOptimizations: false,\n    safeMode: false,\n    errorMessageProvider: defaultLexerErrorProvider,\n    traceInitPerf: false,\n    skipValidations: false,\n    recoveryEnabled: true,\n  }\n  Object.freeze(DEFAULT_LEXER_CONFIG)\n  class Lexer {\n    constructor(lexerDefinition, config = DEFAULT_LEXER_CONFIG) {\n      this.lexerDefinition = lexerDefinition\n      this.lexerDefinitionErrors = []\n      this.lexerDefinitionWarning = []\n      this.patternIdxToConfig = {}\n      this.charCodeToPatternIdxToConfig = {}\n      this.modes = []\n      this.emptyGroups = {}\n      this.trackStartLines = true\n      this.trackEndLines = true\n      this.hasCustom = false\n      this.canModeBeOptimized = {}\n      // Duplicated from the parser's perf trace trait to allow future extraction\n      // of the lexer to a separate package.\n      this.TRACE_INIT = (phaseDesc, phaseImpl) => {\n        // No need to optimize this using NOOP pattern because\n        // It is not called in a hot spot...\n        if (this.traceInitPerf === true) {\n          this.traceInitIndent++\n          const indent = new Array(this.traceInitIndent + 1).join('\\t')\n          if (this.traceInitIndent < this.traceInitMaxIdent) {\n            console.log(`${indent}--> <${phaseDesc}>`)\n          }\n          const { time, value } = timer(phaseImpl)\n          /* istanbul ignore next - Difficult to reproduce specific performance behavior (>10ms) in tests */\n          const traceMethod = time > 10 ? console.warn : console.log\n          if (this.traceInitIndent < this.traceInitMaxIdent) {\n            traceMethod(`${indent}<-- <${phaseDesc}> time: ${time}ms`)\n          }\n          this.traceInitIndent--\n          return value\n        } else {\n          return phaseImpl()\n        }\n      }\n      if (typeof config === 'boolean') {\n        throw Error(\n          'The second argument to the Lexer constructor is now an ILexerConfig Object.\\n' +\n            'a boolean 2nd argument is no longer supported',\n        )\n      }\n      // todo: defaults func?\n      this.config = assign$1({}, DEFAULT_LEXER_CONFIG, config)\n      const traceInitVal = this.config.traceInitPerf\n      if (traceInitVal === true) {\n        this.traceInitMaxIdent = Infinity\n        this.traceInitPerf = true\n      } else if (typeof traceInitVal === 'number') {\n        this.traceInitMaxIdent = traceInitVal\n        this.traceInitPerf = true\n      }\n      this.traceInitIndent = -1\n      this.TRACE_INIT('Lexer Constructor', () => {\n        let actualDefinition\n        let hasOnlySingleMode = true\n        this.TRACE_INIT('Lexer Config handling', () => {\n          if (this.config.lineTerminatorsPattern === DEFAULT_LEXER_CONFIG.lineTerminatorsPattern) {\n            // optimized built-in implementation for the defaults definition of lineTerminators\n            this.config.lineTerminatorsPattern = LineTerminatorOptimizedTester\n          } else {\n            if (this.config.lineTerminatorCharacters === DEFAULT_LEXER_CONFIG.lineTerminatorCharacters) {\n              throw Error(\n                'Error: Missing <lineTerminatorCharacters> property on the Lexer config.\\n' +\n                  '\\tFor details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#MISSING_LINE_TERM_CHARS',\n              )\n            }\n          }\n          if (config.safeMode && config.ensureOptimizations) {\n            throw Error('\"safeMode\" and \"ensureOptimizations\" flags are mutually exclusive.')\n          }\n          this.trackStartLines = /full|onlyStart/i.test(this.config.positionTracking)\n          this.trackEndLines = /full/i.test(this.config.positionTracking)\n          // Convert SingleModeLexerDefinition into a IMultiModeLexerDefinition.\n          if (isArray$1(lexerDefinition)) {\n            actualDefinition = {\n              modes: { defaultMode: clone(lexerDefinition) },\n              defaultMode: DEFAULT_MODE,\n            }\n          } else {\n            // no conversion needed, input should already be a IMultiModeLexerDefinition\n            hasOnlySingleMode = false\n            actualDefinition = clone(lexerDefinition)\n          }\n        })\n        if (this.config.skipValidations === false) {\n          this.TRACE_INIT('performRuntimeChecks', () => {\n            this.lexerDefinitionErrors = this.lexerDefinitionErrors.concat(\n              performRuntimeChecks(actualDefinition, this.trackStartLines, this.config.lineTerminatorCharacters),\n            )\n          })\n          this.TRACE_INIT('performWarningRuntimeChecks', () => {\n            this.lexerDefinitionWarning = this.lexerDefinitionWarning.concat(\n              performWarningRuntimeChecks(actualDefinition, this.trackStartLines, this.config.lineTerminatorCharacters),\n            )\n          })\n        }\n        // for extra robustness to avoid throwing an none informative error message\n        actualDefinition.modes = actualDefinition.modes ? actualDefinition.modes : {}\n        // an error of undefined TokenTypes will be detected in \"performRuntimeChecks\" above.\n        // this transformation is to increase robustness in the case of partially invalid lexer definition.\n        forEach(actualDefinition.modes, (currModeValue, currModeName) => {\n          actualDefinition.modes[currModeName] = reject(currModeValue, (currTokType) => isUndefined(currTokType))\n        })\n        const allModeNames = keys(actualDefinition.modes)\n        forEach(actualDefinition.modes, (currModDef, currModName) => {\n          this.TRACE_INIT(`Mode: <${currModName}> processing`, () => {\n            this.modes.push(currModName)\n            if (this.config.skipValidations === false) {\n              this.TRACE_INIT(`validatePatterns`, () => {\n                this.lexerDefinitionErrors = this.lexerDefinitionErrors.concat(\n                  validatePatterns(currModDef, allModeNames),\n                )\n              })\n            }\n            // If definition errors were encountered, the analysis phase may fail unexpectedly/\n            // Considering a lexer with definition errors may never be used, there is no point\n            // to performing the analysis anyhow...\n            if (isEmpty(this.lexerDefinitionErrors)) {\n              augmentTokenTypes(currModDef)\n              let currAnalyzeResult\n              this.TRACE_INIT(`analyzeTokenTypes`, () => {\n                currAnalyzeResult = analyzeTokenTypes(currModDef, {\n                  lineTerminatorCharacters: this.config.lineTerminatorCharacters,\n                  positionTracking: config.positionTracking,\n                  ensureOptimizations: config.ensureOptimizations,\n                  safeMode: config.safeMode,\n                  tracer: this.TRACE_INIT,\n                })\n              })\n              this.patternIdxToConfig[currModName] = currAnalyzeResult.patternIdxToConfig\n              this.charCodeToPatternIdxToConfig[currModName] = currAnalyzeResult.charCodeToPatternIdxToConfig\n              this.emptyGroups = assign$1({}, this.emptyGroups, currAnalyzeResult.emptyGroups)\n              this.hasCustom = currAnalyzeResult.hasCustom || this.hasCustom\n              this.canModeBeOptimized[currModName] = currAnalyzeResult.canBeOptimized\n            }\n          })\n        })\n        this.defaultMode = actualDefinition.defaultMode\n        if (!isEmpty(this.lexerDefinitionErrors) && !this.config.deferDefinitionErrorsHandling) {\n          const allErrMessages = map(this.lexerDefinitionErrors, (error) => {\n            return error.message\n          })\n          const allErrMessagesString = allErrMessages.join('-----------------------\\n')\n          throw new Error('Errors detected in definition of Lexer:\\n' + allErrMessagesString)\n        }\n        // Only print warning if there are no errors, This will avoid pl\n        forEach(this.lexerDefinitionWarning, (warningDescriptor) => {\n          PRINT_WARNING(warningDescriptor.message)\n        })\n        this.TRACE_INIT('Choosing sub-methods implementations', () => {\n          // Choose the relevant internal implementations for this specific parser.\n          // These implementations should be in-lined by the JavaScript engine\n          // to provide optimal performance in each scenario.\n          if (SUPPORT_STICKY) {\n            this.chopInput = identity\n            this.match = this.matchWithTest\n          } else {\n            this.updateLastIndex = noop\n            this.match = this.matchWithExec\n          }\n          if (hasOnlySingleMode) {\n            this.handleModes = noop\n          }\n          if (this.trackStartLines === false) {\n            this.computeNewColumn = identity\n          }\n          if (this.trackEndLines === false) {\n            this.updateTokenEndLineColumnLocation = noop\n          }\n          if (/full/i.test(this.config.positionTracking)) {\n            this.createTokenInstance = this.createFullToken\n          } else if (/onlyStart/i.test(this.config.positionTracking)) {\n            this.createTokenInstance = this.createStartOnlyToken\n          } else if (/onlyOffset/i.test(this.config.positionTracking)) {\n            this.createTokenInstance = this.createOffsetOnlyToken\n          } else {\n            throw Error(`Invalid <positionTracking> config option: \"${this.config.positionTracking}\"`)\n          }\n          if (this.hasCustom) {\n            this.addToken = this.addTokenUsingPush\n            this.handlePayload = this.handlePayloadWithCustom\n          } else {\n            this.addToken = this.addTokenUsingMemberAccess\n            this.handlePayload = this.handlePayloadNoCustom\n          }\n        })\n        this.TRACE_INIT('Failed Optimization Warnings', () => {\n          const unOptimizedModes = reduce(\n            this.canModeBeOptimized,\n            (cannotBeOptimized, canBeOptimized, modeName) => {\n              if (canBeOptimized === false) {\n                cannotBeOptimized.push(modeName)\n              }\n              return cannotBeOptimized\n            },\n            [],\n          )\n          if (config.ensureOptimizations && !isEmpty(unOptimizedModes)) {\n            throw Error(\n              `Lexer Modes: < ${unOptimizedModes.join(', ')} > cannot be optimized.\\n` +\n                '\\t Disable the \"ensureOptimizations\" lexer config flag to silently ignore this and run the lexer in an un-optimized mode.\\n' +\n                '\\t Or inspect the console log for details on how to resolve these issues.',\n            )\n          }\n        })\n        this.TRACE_INIT('clearRegExpParserCache', () => {\n          clearRegExpParserCache()\n        })\n        this.TRACE_INIT('toFastProperties', () => {\n          toFastProperties(this)\n        })\n      })\n    }\n    tokenize(text, initialMode = this.defaultMode) {\n      if (!isEmpty(this.lexerDefinitionErrors)) {\n        const allErrMessages = map(this.lexerDefinitionErrors, (error) => {\n          return error.message\n        })\n        const allErrMessagesString = allErrMessages.join('-----------------------\\n')\n        throw new Error('Unable to Tokenize because Errors detected in definition of Lexer:\\n' + allErrMessagesString)\n      }\n      return this.tokenizeInternal(text, initialMode)\n    }\n    // There is quite a bit of duplication between this and \"tokenizeInternalLazy\"\n    // This is intentional due to performance considerations.\n    // this method also used quite a bit of `!` none null assertions because it is too optimized\n    // for `tsc` to always understand it is \"safe\"\n    tokenizeInternal(text, initialMode) {\n      let i,\n        j,\n        k,\n        matchAltImage,\n        longerAlt,\n        matchedImage,\n        payload,\n        altPayload,\n        imageLength,\n        group,\n        tokType,\n        newToken,\n        errLength,\n        msg,\n        match\n      const orgText = text\n      const orgLength = orgText.length\n      let offset = 0\n      let matchedTokensIndex = 0\n      // initializing the tokensArray to the \"guessed\" size.\n      // guessing too little will still reduce the number of array re-sizes on pushes.\n      // guessing too large (Tested by guessing x4 too large) may cost a bit more of memory\n      // but would still have a faster runtime by avoiding (All but one) array resizing.\n      const guessedNumberOfTokens = this.hasCustom\n        ? 0 // will break custom token pattern APIs the matchedTokens array will contain undefined elements.\n        : Math.floor(text.length / 10)\n      const matchedTokens = new Array(guessedNumberOfTokens)\n      const errors = []\n      let line = this.trackStartLines ? 1 : undefined\n      let column = this.trackStartLines ? 1 : undefined\n      const groups = cloneEmptyGroups(this.emptyGroups)\n      const trackLines = this.trackStartLines\n      const lineTerminatorPattern = this.config.lineTerminatorsPattern\n      let currModePatternsLength = 0\n      let patternIdxToConfig = []\n      let currCharCodeToPatternIdxToConfig = []\n      const modeStack = []\n      const emptyArray = []\n      Object.freeze(emptyArray)\n      let getPossiblePatterns\n      function getPossiblePatternsSlow() {\n        return patternIdxToConfig\n      }\n      function getPossiblePatternsOptimized(charCode) {\n        const optimizedCharIdx = charCodeToOptimizedIndex(charCode)\n        const possiblePatterns = currCharCodeToPatternIdxToConfig[optimizedCharIdx]\n        if (possiblePatterns === undefined) {\n          return emptyArray\n        } else {\n          return possiblePatterns\n        }\n      }\n      const pop_mode = (popToken) => {\n        // TODO: perhaps avoid this error in the edge case there is no more input?\n        if (\n          modeStack.length === 1 &&\n          // if we have both a POP_MODE and a PUSH_MODE this is in-fact a \"transition\"\n          // So no error should occur.\n          popToken.tokenType.PUSH_MODE === undefined\n        ) {\n          // if we try to pop the last mode there lexer will no longer have ANY mode.\n          // thus the pop is ignored, an error will be created and the lexer will continue parsing in the previous mode.\n          const msg = this.config.errorMessageProvider.buildUnableToPopLexerModeMessage(popToken)\n          errors.push({\n            offset: popToken.startOffset,\n            line: popToken.startLine,\n            column: popToken.startColumn,\n            length: popToken.image.length,\n            message: msg,\n          })\n        } else {\n          modeStack.pop()\n          const newMode = last(modeStack)\n          patternIdxToConfig = this.patternIdxToConfig[newMode]\n          currCharCodeToPatternIdxToConfig = this.charCodeToPatternIdxToConfig[newMode]\n          currModePatternsLength = patternIdxToConfig.length\n          const modeCanBeOptimized = this.canModeBeOptimized[newMode] && this.config.safeMode === false\n          if (currCharCodeToPatternIdxToConfig && modeCanBeOptimized) {\n            getPossiblePatterns = getPossiblePatternsOptimized\n          } else {\n            getPossiblePatterns = getPossiblePatternsSlow\n          }\n        }\n      }\n      function push_mode(newMode) {\n        modeStack.push(newMode)\n        currCharCodeToPatternIdxToConfig = this.charCodeToPatternIdxToConfig[newMode]\n        patternIdxToConfig = this.patternIdxToConfig[newMode]\n        currModePatternsLength = patternIdxToConfig.length\n        currModePatternsLength = patternIdxToConfig.length\n        const modeCanBeOptimized = this.canModeBeOptimized[newMode] && this.config.safeMode === false\n        if (currCharCodeToPatternIdxToConfig && modeCanBeOptimized) {\n          getPossiblePatterns = getPossiblePatternsOptimized\n        } else {\n          getPossiblePatterns = getPossiblePatternsSlow\n        }\n      }\n      // this pattern seems to avoid a V8 de-optimization, although that de-optimization does not\n      // seem to matter performance wise.\n      push_mode.call(this, initialMode)\n      let currConfig\n      const recoveryEnabled = this.config.recoveryEnabled\n      while (offset < orgLength) {\n        matchedImage = null\n        const nextCharCode = orgText.charCodeAt(offset)\n        const chosenPatternIdxToConfig = getPossiblePatterns(nextCharCode)\n        const chosenPatternsLength = chosenPatternIdxToConfig.length\n        for (i = 0; i < chosenPatternsLength; i++) {\n          currConfig = chosenPatternIdxToConfig[i]\n          const currPattern = currConfig.pattern\n          payload = null\n          // manually in-lined because > 600 chars won't be in-lined in V8\n          const singleCharCode = currConfig.short\n          if (singleCharCode !== false) {\n            if (nextCharCode === singleCharCode) {\n              // single character string\n              matchedImage = currPattern\n            }\n          } else if (currConfig.isCustom === true) {\n            match = currPattern.exec(orgText, offset, matchedTokens, groups)\n            if (match !== null) {\n              matchedImage = match[0]\n              if (match.payload !== undefined) {\n                payload = match.payload\n              }\n            } else {\n              matchedImage = null\n            }\n          } else {\n            this.updateLastIndex(currPattern, offset)\n            matchedImage = this.match(currPattern, text, offset)\n          }\n          if (matchedImage !== null) {\n            // even though this pattern matched we must try a another longer alternative.\n            // this can be used to prioritize keywords over identifiers\n            longerAlt = currConfig.longerAlt\n            if (longerAlt !== undefined) {\n              // TODO: micro optimize, avoid extra prop access\n              // by saving/linking longerAlt on the original config?\n              const longerAltLength = longerAlt.length\n              for (k = 0; k < longerAltLength; k++) {\n                const longerAltConfig = patternIdxToConfig[longerAlt[k]]\n                const longerAltPattern = longerAltConfig.pattern\n                altPayload = null\n                // single Char can never be a longer alt so no need to test it.\n                // manually in-lined because > 600 chars won't be in-lined in V8\n                if (longerAltConfig.isCustom === true) {\n                  match = longerAltPattern.exec(orgText, offset, matchedTokens, groups)\n                  if (match !== null) {\n                    matchAltImage = match[0]\n                    if (match.payload !== undefined) {\n                      altPayload = match.payload\n                    }\n                  } else {\n                    matchAltImage = null\n                  }\n                } else {\n                  this.updateLastIndex(longerAltPattern, offset)\n                  matchAltImage = this.match(longerAltPattern, text, offset)\n                }\n                if (matchAltImage && matchAltImage.length > matchedImage.length) {\n                  matchedImage = matchAltImage\n                  payload = altPayload\n                  currConfig = longerAltConfig\n                  // Exit the loop early after matching one of the longer alternatives\n                  // The first matched alternative takes precedence\n                  break\n                }\n              }\n            }\n            break\n          }\n        }\n        // successful match\n        if (matchedImage !== null) {\n          imageLength = matchedImage.length\n          group = currConfig.group\n          if (group !== undefined) {\n            tokType = currConfig.tokenTypeIdx\n            // TODO: \"offset + imageLength\" and the new column may be computed twice in case of \"full\" location information inside\n            // createFullToken method\n            newToken = this.createTokenInstance(\n              matchedImage,\n              offset,\n              tokType,\n              currConfig.tokenType,\n              line,\n              column,\n              imageLength,\n            )\n            this.handlePayload(newToken, payload)\n            // TODO: optimize NOOP in case there are no special groups?\n            if (group === false) {\n              matchedTokensIndex = this.addToken(matchedTokens, matchedTokensIndex, newToken)\n            } else {\n              groups[group].push(newToken)\n            }\n          }\n          text = this.chopInput(text, imageLength)\n          offset = offset + imageLength\n          // TODO: with newlines the column may be assigned twice\n          column = this.computeNewColumn(column, imageLength)\n          if (trackLines === true && currConfig.canLineTerminator === true) {\n            let numOfLTsInMatch = 0\n            let foundTerminator\n            let lastLTEndOffset\n            lineTerminatorPattern.lastIndex = 0\n            do {\n              foundTerminator = lineTerminatorPattern.test(matchedImage)\n              if (foundTerminator === true) {\n                lastLTEndOffset = lineTerminatorPattern.lastIndex - 1\n                numOfLTsInMatch++\n              }\n            } while (foundTerminator === true)\n            if (numOfLTsInMatch !== 0) {\n              line = line + numOfLTsInMatch\n              column = imageLength - lastLTEndOffset\n              this.updateTokenEndLineColumnLocation(\n                newToken,\n                group,\n                lastLTEndOffset,\n                numOfLTsInMatch,\n                line,\n                column,\n                imageLength,\n              )\n            }\n          }\n          // will be NOOP if no modes present\n          this.handleModes(currConfig, pop_mode, push_mode, newToken)\n        } else {\n          // error recovery, drop characters until we identify a valid token's start point\n          const errorStartOffset = offset\n          const errorLine = line\n          const errorColumn = column\n          let foundResyncPoint = recoveryEnabled === false\n          while (foundResyncPoint === false && offset < orgLength) {\n            // Identity Func (when sticky flag is enabled)\n            text = this.chopInput(text, 1)\n            offset++\n            for (j = 0; j < currModePatternsLength; j++) {\n              const currConfig = patternIdxToConfig[j]\n              const currPattern = currConfig.pattern\n              // manually in-lined because > 600 chars won't be in-lined in V8\n              const singleCharCode = currConfig.short\n              if (singleCharCode !== false) {\n                if (orgText.charCodeAt(offset) === singleCharCode) {\n                  // single character string\n                  foundResyncPoint = true\n                }\n              } else if (currConfig.isCustom === true) {\n                foundResyncPoint = currPattern.exec(orgText, offset, matchedTokens, groups) !== null\n              } else {\n                this.updateLastIndex(currPattern, offset)\n                foundResyncPoint = currPattern.exec(text) !== null\n              }\n              if (foundResyncPoint === true) {\n                break\n              }\n            }\n          }\n          errLength = offset - errorStartOffset\n          column = this.computeNewColumn(column, errLength)\n          // at this point we either re-synced or reached the end of the input text\n          msg = this.config.errorMessageProvider.buildUnexpectedCharactersMessage(\n            orgText,\n            errorStartOffset,\n            errLength,\n            errorLine,\n            errorColumn,\n          )\n          errors.push({\n            offset: errorStartOffset,\n            line: errorLine,\n            column: errorColumn,\n            length: errLength,\n            message: msg,\n          })\n          if (recoveryEnabled === false) {\n            break\n          }\n        }\n      }\n      // if we do have custom patterns which push directly into the\n      // TODO: custom tokens should not push directly??\n      if (!this.hasCustom) {\n        // if we guessed a too large size for the tokens array this will shrink it to the right size.\n        matchedTokens.length = matchedTokensIndex\n      }\n      return {\n        tokens: matchedTokens,\n        groups: groups,\n        errors: errors,\n      }\n    }\n    handleModes(config, pop_mode, push_mode, newToken) {\n      if (config.pop === true) {\n        // need to save the PUSH_MODE property as if the mode is popped\n        // patternIdxToPopMode is updated to reflect the new mode after popping the stack\n        const pushMode = config.push\n        pop_mode(newToken)\n        if (pushMode !== undefined) {\n          push_mode.call(this, pushMode)\n        }\n      } else if (config.push !== undefined) {\n        push_mode.call(this, config.push)\n      }\n    }\n    chopInput(text, length) {\n      return text.substring(length)\n    }\n    updateLastIndex(regExp, newLastIndex) {\n      regExp.lastIndex = newLastIndex\n    }\n    // TODO: decrease this under 600 characters? inspect stripping comments option in TSC compiler\n    updateTokenEndLineColumnLocation(newToken, group, lastLTIdx, numOfLTsInMatch, line, column, imageLength) {\n      let lastCharIsLT, fixForEndingInLT\n      if (group !== undefined) {\n        // a none skipped multi line Token, need to update endLine/endColumn\n        lastCharIsLT = lastLTIdx === imageLength - 1\n        fixForEndingInLT = lastCharIsLT ? -1 : 0\n        if (!(numOfLTsInMatch === 1 && lastCharIsLT === true)) {\n          // if a token ends in a LT that last LT only affects the line numbering of following Tokens\n          newToken.endLine = line + fixForEndingInLT\n          // the last LT in a token does not affect the endColumn either as the [columnStart ... columnEnd)\n          // inclusive to exclusive range.\n          newToken.endColumn = column - 1 + -fixForEndingInLT\n        }\n        // else single LT in the last character of a token, no need to modify the endLine/EndColumn\n      }\n    }\n    computeNewColumn(oldColumn, imageLength) {\n      return oldColumn + imageLength\n    }\n    createOffsetOnlyToken(image, startOffset, tokenTypeIdx, tokenType) {\n      return {\n        image,\n        startOffset,\n        tokenTypeIdx,\n        tokenType,\n      }\n    }\n    createStartOnlyToken(image, startOffset, tokenTypeIdx, tokenType, startLine, startColumn) {\n      return {\n        image,\n        startOffset,\n        startLine,\n        startColumn,\n        tokenTypeIdx,\n        tokenType,\n      }\n    }\n    createFullToken(image, startOffset, tokenTypeIdx, tokenType, startLine, startColumn, imageLength) {\n      return {\n        image,\n        startOffset,\n        endOffset: startOffset + imageLength - 1,\n        startLine,\n        endLine: startLine,\n        startColumn,\n        endColumn: startColumn + imageLength - 1,\n        tokenTypeIdx,\n        tokenType,\n      }\n    }\n    addTokenUsingPush(tokenVector, index, tokenToAdd) {\n      tokenVector.push(tokenToAdd)\n      return index\n    }\n    addTokenUsingMemberAccess(tokenVector, index, tokenToAdd) {\n      tokenVector[index] = tokenToAdd\n      index++\n      return index\n    }\n    handlePayloadNoCustom(token, payload) {}\n    handlePayloadWithCustom(token, payload) {\n      if (payload !== null) {\n        token.payload = payload\n      }\n    }\n    matchWithTest(pattern, text, offset) {\n      const found = pattern.test(text)\n      if (found === true) {\n        return text.substring(offset, pattern.lastIndex)\n      }\n      return null\n    }\n    matchWithExec(pattern, text) {\n      const regExpArray = pattern.exec(text)\n      return regExpArray !== null ? regExpArray[0] : null\n    }\n  }\n  Lexer.SKIPPED =\n    'This marks a skipped Token pattern, this means each token identified by it will' +\n    'be consumed and then thrown into oblivion, this can be used to for example to completely ignore whitespace.'\n  Lexer.NA = /NOT_APPLICABLE/\n\n  function tokenLabel(tokType) {\n    if (hasTokenLabel(tokType)) {\n      return tokType.LABEL\n    } else {\n      return tokType.name\n    }\n  }\n  function hasTokenLabel(obj) {\n    return isString(obj.LABEL) && obj.LABEL !== ''\n  }\n  const PARENT = 'parent'\n  const CATEGORIES = 'categories'\n  const LABEL = 'label'\n  const GROUP = 'group'\n  const PUSH_MODE = 'push_mode'\n  const POP_MODE = 'pop_mode'\n  const LONGER_ALT = 'longer_alt'\n  const LINE_BREAKS = 'line_breaks'\n  const START_CHARS_HINT = 'start_chars_hint'\n  function createToken(config) {\n    return createTokenInternal(config)\n  }\n  function createTokenInternal(config) {\n    const pattern = config.pattern\n    const tokenType = {}\n    tokenType.name = config.name\n    if (!isUndefined(pattern)) {\n      tokenType.PATTERN = pattern\n    }\n    if (has(config, PARENT)) {\n      throw (\n        'The parent property is no longer supported.\\n' +\n        'See: https://github.com/chevrotain/chevrotain/issues/564#issuecomment-349062346 for details.'\n      )\n    }\n    if (has(config, CATEGORIES)) {\n      // casting to ANY as this will be fixed inside `augmentTokenTypes``\n      tokenType.CATEGORIES = config[CATEGORIES]\n    }\n    augmentTokenTypes([tokenType])\n    if (has(config, LABEL)) {\n      tokenType.LABEL = config[LABEL]\n    }\n    if (has(config, GROUP)) {\n      tokenType.GROUP = config[GROUP]\n    }\n    if (has(config, POP_MODE)) {\n      tokenType.POP_MODE = config[POP_MODE]\n    }\n    if (has(config, PUSH_MODE)) {\n      tokenType.PUSH_MODE = config[PUSH_MODE]\n    }\n    if (has(config, LONGER_ALT)) {\n      tokenType.LONGER_ALT = config[LONGER_ALT]\n    }\n    if (has(config, LINE_BREAKS)) {\n      tokenType.LINE_BREAKS = config[LINE_BREAKS]\n    }\n    if (has(config, START_CHARS_HINT)) {\n      tokenType.START_CHARS_HINT = config[START_CHARS_HINT]\n    }\n    return tokenType\n  }\n  const EOF = createToken({ name: 'EOF', pattern: Lexer.NA })\n  augmentTokenTypes([EOF])\n  function createTokenInstance(tokType, image, startOffset, endOffset, startLine, endLine, startColumn, endColumn) {\n    return {\n      image,\n      startOffset,\n      endOffset,\n      startLine,\n      endLine,\n      startColumn,\n      endColumn,\n      tokenTypeIdx: tokType.tokenTypeIdx,\n      tokenType: tokType,\n    }\n  }\n  function tokenMatcher(token, tokType) {\n    return tokenStructuredMatcher(token, tokType)\n  }\n\n  const defaultParserErrorProvider = {\n    buildMismatchTokenMessage({ expected, actual, previous, ruleName }) {\n      const hasLabel = hasTokenLabel(expected)\n      const expectedMsg = hasLabel ? `--> ${tokenLabel(expected)} <--` : `token of type --> ${expected.name} <--`\n      const msg = `Expecting ${expectedMsg} but found --> '${actual.image}' <--`\n      return msg\n    },\n    buildNotAllInputParsedMessage({ firstRedundant, ruleName }) {\n      return 'Redundant input, expecting EOF but found: ' + firstRedundant.image\n    },\n    buildNoViableAltMessage({ expectedPathsPerAlt, actual, previous, customUserDescription, ruleName }) {\n      const errPrefix = 'Expecting: '\n      // TODO: issue: No Viable Alternative Error may have incomplete details. #502\n      const actualText = head(actual).image\n      const errSuffix = \"\\nbut found: '\" + actualText + \"'\"\n      if (customUserDescription) {\n        return errPrefix + customUserDescription + errSuffix\n      } else {\n        const allLookAheadPaths = reduce(expectedPathsPerAlt, (result, currAltPaths) => result.concat(currAltPaths), [])\n        const nextValidTokenSequences = map(\n          allLookAheadPaths,\n          (currPath) => `[${map(currPath, (currTokenType) => tokenLabel(currTokenType)).join(', ')}]`,\n        )\n        const nextValidSequenceItems = map(nextValidTokenSequences, (itemMsg, idx) => `  ${idx + 1}. ${itemMsg}`)\n        const calculatedDescription = `one of these possible Token sequences:\\n${nextValidSequenceItems.join('\\n')}`\n        return errPrefix + calculatedDescription + errSuffix\n      }\n    },\n    buildEarlyExitMessage({ expectedIterationPaths, actual, customUserDescription, ruleName }) {\n      const errPrefix = 'Expecting: '\n      // TODO: issue: No Viable Alternative Error may have incomplete details. #502\n      const actualText = head(actual).image\n      const errSuffix = \"\\nbut found: '\" + actualText + \"'\"\n      if (customUserDescription) {\n        return errPrefix + customUserDescription + errSuffix\n      } else {\n        const nextValidTokenSequences = map(\n          expectedIterationPaths,\n          (currPath) => `[${map(currPath, (currTokenType) => tokenLabel(currTokenType)).join(',')}]`,\n        )\n        const calculatedDescription =\n          `expecting at least one iteration which starts with one of these possible Token sequences::\\n  ` +\n          `<${nextValidTokenSequences.join(' ,')}>`\n        return errPrefix + calculatedDescription + errSuffix\n      }\n    },\n  }\n  Object.freeze(defaultParserErrorProvider)\n  const defaultGrammarResolverErrorProvider = {\n    buildRuleNotFoundError(topLevelRule, undefinedRule) {\n      const msg =\n        'Invalid grammar, reference to a rule which is not defined: ->' +\n        undefinedRule.nonTerminalName +\n        '<-\\n' +\n        'inside top level rule: ->' +\n        topLevelRule.name +\n        '<-'\n      return msg\n    },\n  }\n  const defaultGrammarValidatorErrorProvider = {\n    buildDuplicateFoundError(topLevelRule, duplicateProds) {\n      function getExtraProductionArgument(prod) {\n        if (prod instanceof Terminal) {\n          return prod.terminalType.name\n        } else if (prod instanceof NonTerminal) {\n          return prod.nonTerminalName\n        } else {\n          return ''\n        }\n      }\n      const topLevelName = topLevelRule.name\n      const duplicateProd = head(duplicateProds)\n      const index = duplicateProd.idx\n      const dslName = getProductionDslName(duplicateProd)\n      const extraArgument = getExtraProductionArgument(duplicateProd)\n      const hasExplicitIndex = index > 0\n      let msg = `->${dslName}${hasExplicitIndex ? index : ''}<- ${\n        extraArgument ? `with argument: ->${extraArgument}<-` : ''\n      }\n                  appears more than once (${\n                    duplicateProds.length\n                  } times) in the top level rule: ->${topLevelName}<-.                  \n                  For further details see: https://chevrotain.io/docs/FAQ.html#NUMERICAL_SUFFIXES \n                  `\n      // white space trimming time! better to trim afterwards as it allows to use WELL formatted multi line template strings...\n      msg = msg.replace(/[ \\t]+/g, ' ')\n      msg = msg.replace(/\\s\\s+/g, '\\n')\n      return msg\n    },\n    buildNamespaceConflictError(rule) {\n      const errMsg =\n        `Namespace conflict found in grammar.\\n` +\n        `The grammar has both a Terminal(Token) and a Non-Terminal(Rule) named: <${rule.name}>.\\n` +\n        `To resolve this make sure each Terminal and Non-Terminal names are unique\\n` +\n        `This is easy to accomplish by using the convention that Terminal names start with an uppercase letter\\n` +\n        `and Non-Terminal names start with a lower case letter.`\n      return errMsg\n    },\n    buildAlternationPrefixAmbiguityError(options) {\n      const pathMsg = map(options.prefixPath, (currTok) => tokenLabel(currTok)).join(', ')\n      const occurrence = options.alternation.idx === 0 ? '' : options.alternation.idx\n      const errMsg =\n        `Ambiguous alternatives: <${options.ambiguityIndices.join(' ,')}> due to common lookahead prefix\\n` +\n        `in <OR${occurrence}> inside <${options.topLevelRule.name}> Rule,\\n` +\n        `<${pathMsg}> may appears as a prefix path in all these alternatives.\\n` +\n        `See: https://chevrotain.io/docs/guide/resolving_grammar_errors.html#COMMON_PREFIX\\n` +\n        `For Further details.`\n      return errMsg\n    },\n    buildAlternationAmbiguityError(options) {\n      const pathMsg = map(options.prefixPath, (currtok) => tokenLabel(currtok)).join(', ')\n      const occurrence = options.alternation.idx === 0 ? '' : options.alternation.idx\n      let currMessage =\n        `Ambiguous Alternatives Detected: <${options.ambiguityIndices.join(' ,')}> in <OR${occurrence}>` +\n        ` inside <${options.topLevelRule.name}> Rule,\\n` +\n        `<${pathMsg}> may appears as a prefix path in all these alternatives.\\n`\n      currMessage =\n        currMessage +\n        `See: https://chevrotain.io/docs/guide/resolving_grammar_errors.html#AMBIGUOUS_ALTERNATIVES\\n` +\n        `For Further details.`\n      return currMessage\n    },\n    buildEmptyRepetitionError(options) {\n      let dslName = getProductionDslName(options.repetition)\n      if (options.repetition.idx !== 0) {\n        dslName += options.repetition.idx\n      }\n      const errMsg =\n        `The repetition <${dslName}> within Rule <${options.topLevelRule.name}> can never consume any tokens.\\n` +\n        `This could lead to an infinite loop.`\n      return errMsg\n    },\n    // TODO: remove - `errors_public` from nyc.config.js exclude\n    //       once this method is fully removed from this file\n    buildTokenNameError(options) {\n      /* istanbul ignore next */\n      return 'deprecated'\n    },\n    buildEmptyAlternationError(options) {\n      const errMsg =\n        `Ambiguous empty alternative: <${options.emptyChoiceIdx + 1}>` +\n        ` in <OR${options.alternation.idx}> inside <${options.topLevelRule.name}> Rule.\\n` +\n        `Only the last alternative may be an empty alternative.`\n      return errMsg\n    },\n    buildTooManyAlternativesError(options) {\n      const errMsg =\n        `An Alternation cannot have more than 256 alternatives:\\n` +\n        `<OR${options.alternation.idx}> inside <${options.topLevelRule.name}> Rule.\\n has ${\n          options.alternation.definition.length + 1\n        } alternatives.`\n      return errMsg\n    },\n    buildLeftRecursionError(options) {\n      const ruleName = options.topLevelRule.name\n      const pathNames = map(options.leftRecursionPath, (currRule) => currRule.name)\n      const leftRecursivePath = `${ruleName} --> ${pathNames.concat([ruleName]).join(' --> ')}`\n      const errMsg =\n        `Left Recursion found in grammar.\\n` +\n        `rule: <${ruleName}> can be invoked from itself (directly or indirectly)\\n` +\n        `without consuming any Tokens. The grammar path that causes this is: \\n ${leftRecursivePath}\\n` +\n        ` To fix this refactor your grammar to remove the left recursion.\\n` +\n        `see: https://en.wikipedia.org/wiki/LL_parser#Left_factoring.`\n      return errMsg\n    },\n    // TODO: remove - `errors_public` from nyc.config.js exclude\n    //       once this method is fully removed from this file\n    buildInvalidRuleNameError(options) {\n      /* istanbul ignore next */\n      return 'deprecated'\n    },\n    buildDuplicateRuleNameError(options) {\n      let ruleName\n      if (options.topLevelRule instanceof Rule) {\n        ruleName = options.topLevelRule.name\n      } else {\n        ruleName = options.topLevelRule\n      }\n      const errMsg = `Duplicate definition, rule: ->${ruleName}<- is already defined in the grammar: ->${options.grammarName}<-`\n      return errMsg\n    },\n  }\n\n  function resolveGrammar$1(topLevels, errMsgProvider) {\n    const refResolver = new GastRefResolverVisitor(topLevels, errMsgProvider)\n    refResolver.resolveRefs()\n    return refResolver.errors\n  }\n  class GastRefResolverVisitor extends GAstVisitor {\n    constructor(nameToTopRule, errMsgProvider) {\n      super()\n      this.nameToTopRule = nameToTopRule\n      this.errMsgProvider = errMsgProvider\n      this.errors = []\n    }\n    resolveRefs() {\n      forEach(values(this.nameToTopRule), (prod) => {\n        this.currTopLevel = prod\n        prod.accept(this)\n      })\n    }\n    visitNonTerminal(node) {\n      const ref = this.nameToTopRule[node.nonTerminalName]\n      if (!ref) {\n        const msg = this.errMsgProvider.buildRuleNotFoundError(this.currTopLevel, node)\n        this.errors.push({\n          message: msg,\n          type: ParserDefinitionErrorType.UNRESOLVED_SUBRULE_REF,\n          ruleName: this.currTopLevel.name,\n          unresolvedRefName: node.nonTerminalName,\n        })\n      } else {\n        node.referencedRule = ref\n      }\n    }\n  }\n\n  class AbstractNextPossibleTokensWalker extends RestWalker {\n    constructor(topProd, path) {\n      super()\n      this.topProd = topProd\n      this.path = path\n      this.possibleTokTypes = []\n      this.nextProductionName = ''\n      this.nextProductionOccurrence = 0\n      this.found = false\n      this.isAtEndOfPath = false\n    }\n    startWalking() {\n      this.found = false\n      if (this.path.ruleStack[0] !== this.topProd.name) {\n        throw Error(\"The path does not start with the walker's top Rule!\")\n      }\n      // immutable for the win\n      this.ruleStack = clone(this.path.ruleStack).reverse() // intelij bug requires assertion\n      this.occurrenceStack = clone(this.path.occurrenceStack).reverse() // intelij bug requires assertion\n      // already verified that the first production is valid, we now seek the 2nd production\n      this.ruleStack.pop()\n      this.occurrenceStack.pop()\n      this.updateExpectedNext()\n      this.walk(this.topProd)\n      return this.possibleTokTypes\n    }\n    walk(prod, prevRest = []) {\n      // stop scanning once we found the path\n      if (!this.found) {\n        super.walk(prod, prevRest)\n      }\n    }\n    walkProdRef(refProd, currRest, prevRest) {\n      // found the next production, need to keep walking in it\n      if (refProd.referencedRule.name === this.nextProductionName && refProd.idx === this.nextProductionOccurrence) {\n        const fullRest = currRest.concat(prevRest)\n        this.updateExpectedNext()\n        this.walk(refProd.referencedRule, fullRest)\n      }\n    }\n    updateExpectedNext() {\n      // need to consume the Terminal\n      if (isEmpty(this.ruleStack)) {\n        // must reset nextProductionXXX to avoid walking down another Top Level production while what we are\n        // really seeking is the last Terminal...\n        this.nextProductionName = ''\n        this.nextProductionOccurrence = 0\n        this.isAtEndOfPath = true\n      } else {\n        this.nextProductionName = this.ruleStack.pop()\n        this.nextProductionOccurrence = this.occurrenceStack.pop()\n      }\n    }\n  }\n  class NextAfterTokenWalker extends AbstractNextPossibleTokensWalker {\n    constructor(topProd, path) {\n      super(topProd, path)\n      this.path = path\n      this.nextTerminalName = ''\n      this.nextTerminalOccurrence = 0\n      this.nextTerminalName = this.path.lastTok.name\n      this.nextTerminalOccurrence = this.path.lastTokOccurrence\n    }\n    walkTerminal(terminal, currRest, prevRest) {\n      if (\n        this.isAtEndOfPath &&\n        terminal.terminalType.name === this.nextTerminalName &&\n        terminal.idx === this.nextTerminalOccurrence &&\n        !this.found\n      ) {\n        const fullRest = currRest.concat(prevRest)\n        const restProd = new Alternative({ definition: fullRest })\n        this.possibleTokTypes = first(restProd)\n        this.found = true\n      }\n    }\n  }\n  /**\n   * This walker only \"walks\" a single \"TOP\" level in the Grammar Ast, this means\n   * it never \"follows\" production refs\n   */\n  class AbstractNextTerminalAfterProductionWalker extends RestWalker {\n    constructor(topRule, occurrence) {\n      super()\n      this.topRule = topRule\n      this.occurrence = occurrence\n      this.result = {\n        token: undefined,\n        occurrence: undefined,\n        isEndOfRule: undefined,\n      }\n    }\n    startWalking() {\n      this.walk(this.topRule)\n      return this.result\n    }\n  }\n  class NextTerminalAfterManyWalker extends AbstractNextTerminalAfterProductionWalker {\n    walkMany(manyProd, currRest, prevRest) {\n      if (manyProd.idx === this.occurrence) {\n        const firstAfterMany = head(currRest.concat(prevRest))\n        this.result.isEndOfRule = firstAfterMany === undefined\n        if (firstAfterMany instanceof Terminal) {\n          this.result.token = firstAfterMany.terminalType\n          this.result.occurrence = firstAfterMany.idx\n        }\n      } else {\n        super.walkMany(manyProd, currRest, prevRest)\n      }\n    }\n  }\n  class NextTerminalAfterManySepWalker extends AbstractNextTerminalAfterProductionWalker {\n    walkManySep(manySepProd, currRest, prevRest) {\n      if (manySepProd.idx === this.occurrence) {\n        const firstAfterManySep = head(currRest.concat(prevRest))\n        this.result.isEndOfRule = firstAfterManySep === undefined\n        if (firstAfterManySep instanceof Terminal) {\n          this.result.token = firstAfterManySep.terminalType\n          this.result.occurrence = firstAfterManySep.idx\n        }\n      } else {\n        super.walkManySep(manySepProd, currRest, prevRest)\n      }\n    }\n  }\n  class NextTerminalAfterAtLeastOneWalker extends AbstractNextTerminalAfterProductionWalker {\n    walkAtLeastOne(atLeastOneProd, currRest, prevRest) {\n      if (atLeastOneProd.idx === this.occurrence) {\n        const firstAfterAtLeastOne = head(currRest.concat(prevRest))\n        this.result.isEndOfRule = firstAfterAtLeastOne === undefined\n        if (firstAfterAtLeastOne instanceof Terminal) {\n          this.result.token = firstAfterAtLeastOne.terminalType\n          this.result.occurrence = firstAfterAtLeastOne.idx\n        }\n      } else {\n        super.walkAtLeastOne(atLeastOneProd, currRest, prevRest)\n      }\n    }\n  }\n  // TODO: reduce code duplication in the AfterWalkers\n  class NextTerminalAfterAtLeastOneSepWalker extends AbstractNextTerminalAfterProductionWalker {\n    walkAtLeastOneSep(atleastOneSepProd, currRest, prevRest) {\n      if (atleastOneSepProd.idx === this.occurrence) {\n        const firstAfterfirstAfterAtLeastOneSep = head(currRest.concat(prevRest))\n        this.result.isEndOfRule = firstAfterfirstAfterAtLeastOneSep === undefined\n        if (firstAfterfirstAfterAtLeastOneSep instanceof Terminal) {\n          this.result.token = firstAfterfirstAfterAtLeastOneSep.terminalType\n          this.result.occurrence = firstAfterfirstAfterAtLeastOneSep.idx\n        }\n      } else {\n        super.walkAtLeastOneSep(atleastOneSepProd, currRest, prevRest)\n      }\n    }\n  }\n  function possiblePathsFrom(targetDef, maxLength, currPath = []) {\n    // avoid side effects\n    currPath = clone(currPath)\n    let result = []\n    let i = 0\n    // TODO: avoid inner funcs\n    function remainingPathWith(nextDef) {\n      return nextDef.concat(drop(targetDef, i + 1))\n    }\n    // TODO: avoid inner funcs\n    function getAlternativesForProd(definition) {\n      const alternatives = possiblePathsFrom(remainingPathWith(definition), maxLength, currPath)\n      return result.concat(alternatives)\n    }\n    /**\n     * Mandatory productions will halt the loop as the paths computed from their recursive calls will already contain the\n     * following (rest) of the targetDef.\n     *\n     * For optional productions (Option/Repetition/...) the loop will continue to represent the paths that do not include the\n     * the optional production.\n     */\n    while (currPath.length < maxLength && i < targetDef.length) {\n      const prod = targetDef[i]\n      /* istanbul ignore else */\n      if (prod instanceof Alternative) {\n        return getAlternativesForProd(prod.definition)\n      } else if (prod instanceof NonTerminal) {\n        return getAlternativesForProd(prod.definition)\n      } else if (prod instanceof Option) {\n        result = getAlternativesForProd(prod.definition)\n      } else if (prod instanceof RepetitionMandatory) {\n        const newDef = prod.definition.concat([\n          new Repetition({\n            definition: prod.definition,\n          }),\n        ])\n        return getAlternativesForProd(newDef)\n      } else if (prod instanceof RepetitionMandatoryWithSeparator) {\n        const newDef = [\n          new Alternative({ definition: prod.definition }),\n          new Repetition({\n            definition: [new Terminal({ terminalType: prod.separator })].concat(prod.definition),\n          }),\n        ]\n        return getAlternativesForProd(newDef)\n      } else if (prod instanceof RepetitionWithSeparator) {\n        const newDef = prod.definition.concat([\n          new Repetition({\n            definition: [new Terminal({ terminalType: prod.separator })].concat(prod.definition),\n          }),\n        ])\n        result = getAlternativesForProd(newDef)\n      } else if (prod instanceof Repetition) {\n        const newDef = prod.definition.concat([\n          new Repetition({\n            definition: prod.definition,\n          }),\n        ])\n        result = getAlternativesForProd(newDef)\n      } else if (prod instanceof Alternation) {\n        forEach(prod.definition, (currAlt) => {\n          // TODO: this is a limited check for empty alternatives\n          //   It would prevent a common case of infinite loops during parser initialization.\n          //   However **in-directly** empty alternatives may still cause issues.\n          if (isEmpty(currAlt.definition) === false) {\n            result = getAlternativesForProd(currAlt.definition)\n          }\n        })\n        return result\n      } else if (prod instanceof Terminal) {\n        currPath.push(prod.terminalType)\n      } else {\n        throw Error('non exhaustive match')\n      }\n      i++\n    }\n    result.push({\n      partialPath: currPath,\n      suffixDef: drop(targetDef, i),\n    })\n    return result\n  }\n  function nextPossibleTokensAfter(initialDef, tokenVector, tokMatcher, maxLookAhead) {\n    const EXIT_NON_TERMINAL = 'EXIT_NONE_TERMINAL'\n    // to avoid creating a new Array each time.\n    const EXIT_NON_TERMINAL_ARR = [EXIT_NON_TERMINAL]\n    const EXIT_ALTERNATIVE = 'EXIT_ALTERNATIVE'\n    let foundCompletePath = false\n    const tokenVectorLength = tokenVector.length\n    const minimalAlternativesIndex = tokenVectorLength - maxLookAhead - 1\n    const result = []\n    const possiblePaths = []\n    possiblePaths.push({\n      idx: -1,\n      def: initialDef,\n      ruleStack: [],\n      occurrenceStack: [],\n    })\n    while (!isEmpty(possiblePaths)) {\n      const currPath = possiblePaths.pop()\n      // skip alternatives if no more results can be found (assuming deterministic grammar with fixed lookahead)\n      if (currPath === EXIT_ALTERNATIVE) {\n        if (foundCompletePath && last(possiblePaths).idx <= minimalAlternativesIndex) {\n          // remove irrelevant alternative\n          possiblePaths.pop()\n        }\n        continue\n      }\n      const currDef = currPath.def\n      const currIdx = currPath.idx\n      const currRuleStack = currPath.ruleStack\n      const currOccurrenceStack = currPath.occurrenceStack\n      // For Example: an empty path could exist in a valid grammar in the case of an EMPTY_ALT\n      if (isEmpty(currDef)) {\n        continue\n      }\n      const prod = currDef[0]\n      /* istanbul ignore else */\n      if (prod === EXIT_NON_TERMINAL) {\n        const nextPath = {\n          idx: currIdx,\n          def: drop(currDef),\n          ruleStack: dropRight(currRuleStack),\n          occurrenceStack: dropRight(currOccurrenceStack),\n        }\n        possiblePaths.push(nextPath)\n      } else if (prod instanceof Terminal) {\n        /* istanbul ignore else */\n        if (currIdx < tokenVectorLength - 1) {\n          const nextIdx = currIdx + 1\n          const actualToken = tokenVector[nextIdx]\n          if (tokMatcher(actualToken, prod.terminalType)) {\n            const nextPath = {\n              idx: nextIdx,\n              def: drop(currDef),\n              ruleStack: currRuleStack,\n              occurrenceStack: currOccurrenceStack,\n            }\n            possiblePaths.push(nextPath)\n          }\n          // end of the line\n        } else if (currIdx === tokenVectorLength - 1) {\n          // IGNORE ABOVE ELSE\n          result.push({\n            nextTokenType: prod.terminalType,\n            nextTokenOccurrence: prod.idx,\n            ruleStack: currRuleStack,\n            occurrenceStack: currOccurrenceStack,\n          })\n          foundCompletePath = true\n        } else {\n          throw Error('non exhaustive match')\n        }\n      } else if (prod instanceof NonTerminal) {\n        const newRuleStack = clone(currRuleStack)\n        newRuleStack.push(prod.nonTerminalName)\n        const newOccurrenceStack = clone(currOccurrenceStack)\n        newOccurrenceStack.push(prod.idx)\n        const nextPath = {\n          idx: currIdx,\n          def: prod.definition.concat(EXIT_NON_TERMINAL_ARR, drop(currDef)),\n          ruleStack: newRuleStack,\n          occurrenceStack: newOccurrenceStack,\n        }\n        possiblePaths.push(nextPath)\n      } else if (prod instanceof Option) {\n        // the order of alternatives is meaningful, FILO (Last path will be traversed first).\n        const nextPathWithout = {\n          idx: currIdx,\n          def: drop(currDef),\n          ruleStack: currRuleStack,\n          occurrenceStack: currOccurrenceStack,\n        }\n        possiblePaths.push(nextPathWithout)\n        // required marker to avoid backtracking paths whose higher priority alternatives already matched\n        possiblePaths.push(EXIT_ALTERNATIVE)\n        const nextPathWith = {\n          idx: currIdx,\n          def: prod.definition.concat(drop(currDef)),\n          ruleStack: currRuleStack,\n          occurrenceStack: currOccurrenceStack,\n        }\n        possiblePaths.push(nextPathWith)\n      } else if (prod instanceof RepetitionMandatory) {\n        // TODO:(THE NEW operators here take a while...) (convert once?)\n        const secondIteration = new Repetition({\n          definition: prod.definition,\n          idx: prod.idx,\n        })\n        const nextDef = prod.definition.concat([secondIteration], drop(currDef))\n        const nextPath = {\n          idx: currIdx,\n          def: nextDef,\n          ruleStack: currRuleStack,\n          occurrenceStack: currOccurrenceStack,\n        }\n        possiblePaths.push(nextPath)\n      } else if (prod instanceof RepetitionMandatoryWithSeparator) {\n        // TODO:(THE NEW operators here take a while...) (convert once?)\n        const separatorGast = new Terminal({\n          terminalType: prod.separator,\n        })\n        const secondIteration = new Repetition({\n          definition: [separatorGast].concat(prod.definition),\n          idx: prod.idx,\n        })\n        const nextDef = prod.definition.concat([secondIteration], drop(currDef))\n        const nextPath = {\n          idx: currIdx,\n          def: nextDef,\n          ruleStack: currRuleStack,\n          occurrenceStack: currOccurrenceStack,\n        }\n        possiblePaths.push(nextPath)\n      } else if (prod instanceof RepetitionWithSeparator) {\n        // the order of alternatives is meaningful, FILO (Last path will be traversed first).\n        const nextPathWithout = {\n          idx: currIdx,\n          def: drop(currDef),\n          ruleStack: currRuleStack,\n          occurrenceStack: currOccurrenceStack,\n        }\n        possiblePaths.push(nextPathWithout)\n        // required marker to avoid backtracking paths whose higher priority alternatives already matched\n        possiblePaths.push(EXIT_ALTERNATIVE)\n        const separatorGast = new Terminal({\n          terminalType: prod.separator,\n        })\n        const nthRepetition = new Repetition({\n          definition: [separatorGast].concat(prod.definition),\n          idx: prod.idx,\n        })\n        const nextDef = prod.definition.concat([nthRepetition], drop(currDef))\n        const nextPathWith = {\n          idx: currIdx,\n          def: nextDef,\n          ruleStack: currRuleStack,\n          occurrenceStack: currOccurrenceStack,\n        }\n        possiblePaths.push(nextPathWith)\n      } else if (prod instanceof Repetition) {\n        // the order of alternatives is meaningful, FILO (Last path will be traversed first).\n        const nextPathWithout = {\n          idx: currIdx,\n          def: drop(currDef),\n          ruleStack: currRuleStack,\n          occurrenceStack: currOccurrenceStack,\n        }\n        possiblePaths.push(nextPathWithout)\n        // required marker to avoid backtracking paths whose higher priority alternatives already matched\n        possiblePaths.push(EXIT_ALTERNATIVE)\n        // TODO: an empty repetition will cause infinite loops here, will the parser detect this in selfAnalysis?\n        const nthRepetition = new Repetition({\n          definition: prod.definition,\n          idx: prod.idx,\n        })\n        const nextDef = prod.definition.concat([nthRepetition], drop(currDef))\n        const nextPathWith = {\n          idx: currIdx,\n          def: nextDef,\n          ruleStack: currRuleStack,\n          occurrenceStack: currOccurrenceStack,\n        }\n        possiblePaths.push(nextPathWith)\n      } else if (prod instanceof Alternation) {\n        // the order of alternatives is meaningful, FILO (Last path will be traversed first).\n        for (let i = prod.definition.length - 1; i >= 0; i--) {\n          const currAlt = prod.definition[i]\n          const currAltPath = {\n            idx: currIdx,\n            def: currAlt.definition.concat(drop(currDef)),\n            ruleStack: currRuleStack,\n            occurrenceStack: currOccurrenceStack,\n          }\n          possiblePaths.push(currAltPath)\n          possiblePaths.push(EXIT_ALTERNATIVE)\n        }\n      } else if (prod instanceof Alternative) {\n        possiblePaths.push({\n          idx: currIdx,\n          def: prod.definition.concat(drop(currDef)),\n          ruleStack: currRuleStack,\n          occurrenceStack: currOccurrenceStack,\n        })\n      } else if (prod instanceof Rule) {\n        // last because we should only encounter at most a single one of these per invocation.\n        possiblePaths.push(expandTopLevelRule(prod, currIdx, currRuleStack, currOccurrenceStack))\n      } else {\n        throw Error('non exhaustive match')\n      }\n    }\n    return result\n  }\n  function expandTopLevelRule(topRule, currIdx, currRuleStack, currOccurrenceStack) {\n    const newRuleStack = clone(currRuleStack)\n    newRuleStack.push(topRule.name)\n    const newCurrOccurrenceStack = clone(currOccurrenceStack)\n    // top rule is always assumed to have been called with occurrence index 1\n    newCurrOccurrenceStack.push(1)\n    return {\n      idx: currIdx,\n      def: topRule.definition,\n      ruleStack: newRuleStack,\n      occurrenceStack: newCurrOccurrenceStack,\n    }\n  }\n\n  var PROD_TYPE\n  ;(function (PROD_TYPE) {\n    PROD_TYPE[(PROD_TYPE['OPTION'] = 0)] = 'OPTION'\n    PROD_TYPE[(PROD_TYPE['REPETITION'] = 1)] = 'REPETITION'\n    PROD_TYPE[(PROD_TYPE['REPETITION_MANDATORY'] = 2)] = 'REPETITION_MANDATORY'\n    PROD_TYPE[(PROD_TYPE['REPETITION_MANDATORY_WITH_SEPARATOR'] = 3)] = 'REPETITION_MANDATORY_WITH_SEPARATOR'\n    PROD_TYPE[(PROD_TYPE['REPETITION_WITH_SEPARATOR'] = 4)] = 'REPETITION_WITH_SEPARATOR'\n    PROD_TYPE[(PROD_TYPE['ALTERNATION'] = 5)] = 'ALTERNATION'\n  })(PROD_TYPE || (PROD_TYPE = {}))\n  function getProdType(prod) {\n    /* istanbul ignore else */\n    if (prod instanceof Option || prod === 'Option') {\n      return PROD_TYPE.OPTION\n    } else if (prod instanceof Repetition || prod === 'Repetition') {\n      return PROD_TYPE.REPETITION\n    } else if (prod instanceof RepetitionMandatory || prod === 'RepetitionMandatory') {\n      return PROD_TYPE.REPETITION_MANDATORY\n    } else if (prod instanceof RepetitionMandatoryWithSeparator || prod === 'RepetitionMandatoryWithSeparator') {\n      return PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR\n    } else if (prod instanceof RepetitionWithSeparator || prod === 'RepetitionWithSeparator') {\n      return PROD_TYPE.REPETITION_WITH_SEPARATOR\n    } else if (prod instanceof Alternation || prod === 'Alternation') {\n      return PROD_TYPE.ALTERNATION\n    } else {\n      throw Error('non exhaustive match')\n    }\n  }\n  function buildLookaheadFuncForOr(\n    occurrence,\n    ruleGrammar,\n    maxLookahead,\n    hasPredicates,\n    dynamicTokensEnabled,\n    laFuncBuilder,\n  ) {\n    const lookAheadPaths = getLookaheadPathsForOr(occurrence, ruleGrammar, maxLookahead)\n    const tokenMatcher = areTokenCategoriesNotUsed(lookAheadPaths)\n      ? tokenStructuredMatcherNoCategories\n      : tokenStructuredMatcher\n    return laFuncBuilder(lookAheadPaths, hasPredicates, tokenMatcher, dynamicTokensEnabled)\n  }\n  /**\n   *  When dealing with an Optional production (OPTION/MANY/2nd iteration of AT_LEAST_ONE/...) we need to compare\n   *  the lookahead \"inside\" the production and the lookahead immediately \"after\" it in the same top level rule (context free).\n   *\n   *  Example: given a production:\n   *  ABC(DE)?DF\n   *\n   *  The optional '(DE)?' should only be entered if we see 'DE'. a single Token 'D' is not sufficient to distinguish between the two\n   *  alternatives.\n   *\n   *  @returns A Lookahead function which will return true IFF the parser should parse the Optional production.\n   */\n  function buildLookaheadFuncForOptionalProd(\n    occurrence,\n    ruleGrammar,\n    k,\n    dynamicTokensEnabled,\n    prodType,\n    lookaheadBuilder,\n  ) {\n    const lookAheadPaths = getLookaheadPathsForOptionalProd(occurrence, ruleGrammar, prodType, k)\n    const tokenMatcher = areTokenCategoriesNotUsed(lookAheadPaths)\n      ? tokenStructuredMatcherNoCategories\n      : tokenStructuredMatcher\n    return lookaheadBuilder(lookAheadPaths[0], tokenMatcher, dynamicTokensEnabled)\n  }\n  function buildAlternativesLookAheadFunc(alts, hasPredicates, tokenMatcher, dynamicTokensEnabled) {\n    const numOfAlts = alts.length\n    const areAllOneTokenLookahead = every(alts, (currAlt) => {\n      return every(currAlt, (currPath) => {\n        return currPath.length === 1\n      })\n    })\n    // This version takes into account the predicates as well.\n    if (hasPredicates) {\n      /**\n       * @returns {number} - The chosen alternative index\n       */\n      return function (orAlts) {\n        // unfortunately the predicates must be extracted every single time\n        // as they cannot be cached due to references to parameters(vars) which are no longer valid.\n        // note that in the common case of no predicates, no cpu time will be wasted on this (see else block)\n        const predicates = map(orAlts, (currAlt) => currAlt.GATE)\n        for (let t = 0; t < numOfAlts; t++) {\n          const currAlt = alts[t]\n          const currNumOfPaths = currAlt.length\n          const currPredicate = predicates[t]\n          if (currPredicate !== undefined && currPredicate.call(this) === false) {\n            // if the predicate does not match there is no point in checking the paths\n            continue\n          }\n          nextPath: for (let j = 0; j < currNumOfPaths; j++) {\n            const currPath = currAlt[j]\n            const currPathLength = currPath.length\n            for (let i = 0; i < currPathLength; i++) {\n              const nextToken = this.LA(i + 1)\n              if (tokenMatcher(nextToken, currPath[i]) === false) {\n                // mismatch in current path\n                // try the next pth\n                continue nextPath\n              }\n            }\n            // found a full path that matches.\n            // this will also work for an empty ALT as the loop will be skipped\n            return t\n          }\n          // none of the paths for the current alternative matched\n          // try the next alternative\n        }\n        // none of the alternatives could be matched\n        return undefined\n      }\n    } else if (areAllOneTokenLookahead && !dynamicTokensEnabled) {\n      // optimized (common) case of all the lookaheads paths requiring only\n      // a single token lookahead. These Optimizations cannot work if dynamically defined Tokens are used.\n      const singleTokenAlts = map(alts, (currAlt) => {\n        return flatten(currAlt)\n      })\n      const choiceToAlt = reduce(\n        singleTokenAlts,\n        (result, currAlt, idx) => {\n          forEach(currAlt, (currTokType) => {\n            if (!has(result, currTokType.tokenTypeIdx)) {\n              result[currTokType.tokenTypeIdx] = idx\n            }\n            forEach(currTokType.categoryMatches, (currExtendingType) => {\n              if (!has(result, currExtendingType)) {\n                result[currExtendingType] = idx\n              }\n            })\n          })\n          return result\n        },\n        {},\n      )\n      /**\n       * @returns {number} - The chosen alternative index\n       */\n      return function () {\n        const nextToken = this.LA(1)\n        return choiceToAlt[nextToken.tokenTypeIdx]\n      }\n    } else {\n      // optimized lookahead without needing to check the predicates at all.\n      // this causes code duplication which is intentional to improve performance.\n      /**\n       * @returns {number} - The chosen alternative index\n       */\n      return function () {\n        for (let t = 0; t < numOfAlts; t++) {\n          const currAlt = alts[t]\n          const currNumOfPaths = currAlt.length\n          nextPath: for (let j = 0; j < currNumOfPaths; j++) {\n            const currPath = currAlt[j]\n            const currPathLength = currPath.length\n            for (let i = 0; i < currPathLength; i++) {\n              const nextToken = this.LA(i + 1)\n              if (tokenMatcher(nextToken, currPath[i]) === false) {\n                // mismatch in current path\n                // try the next pth\n                continue nextPath\n              }\n            }\n            // found a full path that matches.\n            // this will also work for an empty ALT as the loop will be skipped\n            return t\n          }\n          // none of the paths for the current alternative matched\n          // try the next alternative\n        }\n        // none of the alternatives could be matched\n        return undefined\n      }\n    }\n  }\n  function buildSingleAlternativeLookaheadFunction(alt, tokenMatcher, dynamicTokensEnabled) {\n    const areAllOneTokenLookahead = every(alt, (currPath) => {\n      return currPath.length === 1\n    })\n    const numOfPaths = alt.length\n    // optimized (common) case of all the lookaheads paths requiring only\n    // a single token lookahead.\n    if (areAllOneTokenLookahead && !dynamicTokensEnabled) {\n      const singleTokensTypes = flatten(alt)\n      if (singleTokensTypes.length === 1 && isEmpty(singleTokensTypes[0].categoryMatches)) {\n        const expectedTokenType = singleTokensTypes[0]\n        const expectedTokenUniqueKey = expectedTokenType.tokenTypeIdx\n        return function () {\n          return this.LA(1).tokenTypeIdx === expectedTokenUniqueKey\n        }\n      } else {\n        const choiceToAlt = reduce(\n          singleTokensTypes,\n          (result, currTokType, idx) => {\n            result[currTokType.tokenTypeIdx] = true\n            forEach(currTokType.categoryMatches, (currExtendingType) => {\n              result[currExtendingType] = true\n            })\n            return result\n          },\n          [],\n        )\n        return function () {\n          const nextToken = this.LA(1)\n          return choiceToAlt[nextToken.tokenTypeIdx] === true\n        }\n      }\n    } else {\n      return function () {\n        nextPath: for (let j = 0; j < numOfPaths; j++) {\n          const currPath = alt[j]\n          const currPathLength = currPath.length\n          for (let i = 0; i < currPathLength; i++) {\n            const nextToken = this.LA(i + 1)\n            if (tokenMatcher(nextToken, currPath[i]) === false) {\n              // mismatch in current path\n              // try the next pth\n              continue nextPath\n            }\n          }\n          // found a full path that matches.\n          return true\n        }\n        // none of the paths matched\n        return false\n      }\n    }\n  }\n  class RestDefinitionFinderWalker extends RestWalker {\n    constructor(topProd, targetOccurrence, targetProdType) {\n      super()\n      this.topProd = topProd\n      this.targetOccurrence = targetOccurrence\n      this.targetProdType = targetProdType\n    }\n    startWalking() {\n      this.walk(this.topProd)\n      return this.restDef\n    }\n    checkIsTarget(node, expectedProdType, currRest, prevRest) {\n      if (node.idx === this.targetOccurrence && this.targetProdType === expectedProdType) {\n        this.restDef = currRest.concat(prevRest)\n        return true\n      }\n      // performance optimization, do not iterate over the entire Grammar ast after we have found the target\n      return false\n    }\n    walkOption(optionProd, currRest, prevRest) {\n      if (!this.checkIsTarget(optionProd, PROD_TYPE.OPTION, currRest, prevRest)) {\n        super.walkOption(optionProd, currRest, prevRest)\n      }\n    }\n    walkAtLeastOne(atLeastOneProd, currRest, prevRest) {\n      if (!this.checkIsTarget(atLeastOneProd, PROD_TYPE.REPETITION_MANDATORY, currRest, prevRest)) {\n        super.walkOption(atLeastOneProd, currRest, prevRest)\n      }\n    }\n    walkAtLeastOneSep(atLeastOneSepProd, currRest, prevRest) {\n      if (!this.checkIsTarget(atLeastOneSepProd, PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR, currRest, prevRest)) {\n        super.walkOption(atLeastOneSepProd, currRest, prevRest)\n      }\n    }\n    walkMany(manyProd, currRest, prevRest) {\n      if (!this.checkIsTarget(manyProd, PROD_TYPE.REPETITION, currRest, prevRest)) {\n        super.walkOption(manyProd, currRest, prevRest)\n      }\n    }\n    walkManySep(manySepProd, currRest, prevRest) {\n      if (!this.checkIsTarget(manySepProd, PROD_TYPE.REPETITION_WITH_SEPARATOR, currRest, prevRest)) {\n        super.walkOption(manySepProd, currRest, prevRest)\n      }\n    }\n  }\n  /**\n   * Returns the definition of a target production in a top level level rule.\n   */\n  class InsideDefinitionFinderVisitor extends GAstVisitor {\n    constructor(targetOccurrence, targetProdType, targetRef) {\n      super()\n      this.targetOccurrence = targetOccurrence\n      this.targetProdType = targetProdType\n      this.targetRef = targetRef\n      this.result = []\n    }\n    checkIsTarget(node, expectedProdName) {\n      if (\n        node.idx === this.targetOccurrence &&\n        this.targetProdType === expectedProdName &&\n        (this.targetRef === undefined || node === this.targetRef)\n      ) {\n        this.result = node.definition\n      }\n    }\n    visitOption(node) {\n      this.checkIsTarget(node, PROD_TYPE.OPTION)\n    }\n    visitRepetition(node) {\n      this.checkIsTarget(node, PROD_TYPE.REPETITION)\n    }\n    visitRepetitionMandatory(node) {\n      this.checkIsTarget(node, PROD_TYPE.REPETITION_MANDATORY)\n    }\n    visitRepetitionMandatoryWithSeparator(node) {\n      this.checkIsTarget(node, PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR)\n    }\n    visitRepetitionWithSeparator(node) {\n      this.checkIsTarget(node, PROD_TYPE.REPETITION_WITH_SEPARATOR)\n    }\n    visitAlternation(node) {\n      this.checkIsTarget(node, PROD_TYPE.ALTERNATION)\n    }\n  }\n  function initializeArrayOfArrays(size) {\n    const result = new Array(size)\n    for (let i = 0; i < size; i++) {\n      result[i] = []\n    }\n    return result\n  }\n  /**\n   * A sort of hash function between a Path in the grammar and a string.\n   * Note that this returns multiple \"hashes\" to support the scenario of token categories.\n   * -  A single path with categories may match multiple **actual** paths.\n   */\n  function pathToHashKeys(path) {\n    let keys = ['']\n    for (let i = 0; i < path.length; i++) {\n      const tokType = path[i]\n      const longerKeys = []\n      for (let j = 0; j < keys.length; j++) {\n        const currShorterKey = keys[j]\n        longerKeys.push(currShorterKey + '_' + tokType.tokenTypeIdx)\n        for (let t = 0; t < tokType.categoryMatches.length; t++) {\n          const categoriesKeySuffix = '_' + tokType.categoryMatches[t]\n          longerKeys.push(currShorterKey + categoriesKeySuffix)\n        }\n      }\n      keys = longerKeys\n    }\n    return keys\n  }\n  /**\n   * Imperative style due to being called from a hot spot\n   */\n  function isUniquePrefixHash(altKnownPathsKeys, searchPathKeys, idx) {\n    for (let currAltIdx = 0; currAltIdx < altKnownPathsKeys.length; currAltIdx++) {\n      // We only want to test vs the other alternatives\n      if (currAltIdx === idx) {\n        continue\n      }\n      const otherAltKnownPathsKeys = altKnownPathsKeys[currAltIdx]\n      for (let searchIdx = 0; searchIdx < searchPathKeys.length; searchIdx++) {\n        const searchKey = searchPathKeys[searchIdx]\n        if (otherAltKnownPathsKeys[searchKey] === true) {\n          return false\n        }\n      }\n    }\n    // None of the SearchPathKeys were found in any of the other alternatives\n    return true\n  }\n  function lookAheadSequenceFromAlternatives(altsDefs, k) {\n    const partialAlts = map(altsDefs, (currAlt) => possiblePathsFrom([currAlt], 1))\n    const finalResult = initializeArrayOfArrays(partialAlts.length)\n    const altsHashes = map(partialAlts, (currAltPaths) => {\n      const dict = {}\n      forEach(currAltPaths, (item) => {\n        const keys = pathToHashKeys(item.partialPath)\n        forEach(keys, (currKey) => {\n          dict[currKey] = true\n        })\n      })\n      return dict\n    })\n    let newData = partialAlts\n    // maxLookahead loop\n    for (let pathLength = 1; pathLength <= k; pathLength++) {\n      const currDataset = newData\n      newData = initializeArrayOfArrays(currDataset.length)\n      // alternatives loop\n      for (let altIdx = 0; altIdx < currDataset.length; altIdx++) {\n        const currAltPathsAndSuffixes = currDataset[altIdx]\n        // paths in current alternative loop\n        for (let currPathIdx = 0; currPathIdx < currAltPathsAndSuffixes.length; currPathIdx++) {\n          const currPathPrefix = currAltPathsAndSuffixes[currPathIdx].partialPath\n          const suffixDef = currAltPathsAndSuffixes[currPathIdx].suffixDef\n          const prefixKeys = pathToHashKeys(currPathPrefix)\n          const isUnique = isUniquePrefixHash(altsHashes, prefixKeys, altIdx)\n          // End of the line for this path.\n          if (isUnique || isEmpty(suffixDef) || currPathPrefix.length === k) {\n            const currAltResult = finalResult[altIdx]\n            // TODO: Can we implement a containsPath using Maps/Dictionaries?\n            if (containsPath(currAltResult, currPathPrefix) === false) {\n              currAltResult.push(currPathPrefix)\n              // Update all new  keys for the current path.\n              for (let j = 0; j < prefixKeys.length; j++) {\n                const currKey = prefixKeys[j]\n                altsHashes[altIdx][currKey] = true\n              }\n            }\n          }\n          // Expand longer paths\n          else {\n            const newPartialPathsAndSuffixes = possiblePathsFrom(suffixDef, pathLength + 1, currPathPrefix)\n            newData[altIdx] = newData[altIdx].concat(newPartialPathsAndSuffixes)\n            // Update keys for new known paths\n            forEach(newPartialPathsAndSuffixes, (item) => {\n              const prefixKeys = pathToHashKeys(item.partialPath)\n              forEach(prefixKeys, (key) => {\n                altsHashes[altIdx][key] = true\n              })\n            })\n          }\n        }\n      }\n    }\n    return finalResult\n  }\n  function getLookaheadPathsForOr(occurrence, ruleGrammar, k, orProd) {\n    const visitor = new InsideDefinitionFinderVisitor(occurrence, PROD_TYPE.ALTERNATION, orProd)\n    ruleGrammar.accept(visitor)\n    return lookAheadSequenceFromAlternatives(visitor.result, k)\n  }\n  function getLookaheadPathsForOptionalProd(occurrence, ruleGrammar, prodType, k) {\n    const insideDefVisitor = new InsideDefinitionFinderVisitor(occurrence, prodType)\n    ruleGrammar.accept(insideDefVisitor)\n    const insideDef = insideDefVisitor.result\n    const afterDefWalker = new RestDefinitionFinderWalker(ruleGrammar, occurrence, prodType)\n    const afterDef = afterDefWalker.startWalking()\n    const insideFlat = new Alternative({ definition: insideDef })\n    const afterFlat = new Alternative({ definition: afterDef })\n    return lookAheadSequenceFromAlternatives([insideFlat, afterFlat], k)\n  }\n  function containsPath(alternative, searchPath) {\n    compareOtherPath: for (let i = 0; i < alternative.length; i++) {\n      const otherPath = alternative[i]\n      if (otherPath.length !== searchPath.length) {\n        continue\n      }\n      for (let j = 0; j < otherPath.length; j++) {\n        const searchTok = searchPath[j]\n        const otherTok = otherPath[j]\n        const matchingTokens =\n          searchTok === otherTok || otherTok.categoryMatchesMap[searchTok.tokenTypeIdx] !== undefined\n        if (matchingTokens === false) {\n          continue compareOtherPath\n        }\n      }\n      return true\n    }\n    return false\n  }\n  function isStrictPrefixOfPath(prefix, other) {\n    return (\n      prefix.length < other.length &&\n      every(prefix, (tokType, idx) => {\n        const otherTokType = other[idx]\n        return tokType === otherTokType || otherTokType.categoryMatchesMap[tokType.tokenTypeIdx]\n      })\n    )\n  }\n  function areTokenCategoriesNotUsed(lookAheadPaths) {\n    return every(lookAheadPaths, (singleAltPaths) =>\n      every(singleAltPaths, (singlePath) => every(singlePath, (token) => isEmpty(token.categoryMatches))),\n    )\n  }\n\n  function validateLookahead(options) {\n    const lookaheadValidationErrorMessages = options.lookaheadStrategy.validate({\n      rules: options.rules,\n      tokenTypes: options.tokenTypes,\n      grammarName: options.grammarName,\n    })\n    return map(lookaheadValidationErrorMessages, (errorMessage) =>\n      Object.assign({ type: ParserDefinitionErrorType.CUSTOM_LOOKAHEAD_VALIDATION }, errorMessage),\n    )\n  }\n  function validateGrammar$1(topLevels, tokenTypes, errMsgProvider, grammarName) {\n    const duplicateErrors = flatMap(topLevels, (currTopLevel) =>\n      validateDuplicateProductions(currTopLevel, errMsgProvider),\n    )\n    const termsNamespaceConflictErrors = checkTerminalAndNoneTerminalsNameSpace(topLevels, tokenTypes, errMsgProvider)\n    const tooManyAltsErrors = flatMap(topLevels, (curRule) => validateTooManyAlts(curRule, errMsgProvider))\n    const duplicateRulesError = flatMap(topLevels, (curRule) =>\n      validateRuleDoesNotAlreadyExist(curRule, topLevels, grammarName, errMsgProvider),\n    )\n    return duplicateErrors.concat(termsNamespaceConflictErrors, tooManyAltsErrors, duplicateRulesError)\n  }\n  function validateDuplicateProductions(topLevelRule, errMsgProvider) {\n    const collectorVisitor = new OccurrenceValidationCollector()\n    topLevelRule.accept(collectorVisitor)\n    const allRuleProductions = collectorVisitor.allProductions\n    const productionGroups = groupBy$1(allRuleProductions, identifyProductionForDuplicates)\n    const duplicates = pickBy(productionGroups, (currGroup) => {\n      return currGroup.length > 1\n    })\n    const errors = map(values(duplicates), (currDuplicates) => {\n      const firstProd = head(currDuplicates)\n      const msg = errMsgProvider.buildDuplicateFoundError(topLevelRule, currDuplicates)\n      const dslName = getProductionDslName(firstProd)\n      const defError = {\n        message: msg,\n        type: ParserDefinitionErrorType.DUPLICATE_PRODUCTIONS,\n        ruleName: topLevelRule.name,\n        dslName: dslName,\n        occurrence: firstProd.idx,\n      }\n      const param = getExtraProductionArgument(firstProd)\n      if (param) {\n        defError.parameter = param\n      }\n      return defError\n    })\n    return errors\n  }\n  function identifyProductionForDuplicates(prod) {\n    return `${getProductionDslName(prod)}_#_${prod.idx}_#_${getExtraProductionArgument(prod)}`\n  }\n  function getExtraProductionArgument(prod) {\n    if (prod instanceof Terminal) {\n      return prod.terminalType.name\n    } else if (prod instanceof NonTerminal) {\n      return prod.nonTerminalName\n    } else {\n      return ''\n    }\n  }\n  class OccurrenceValidationCollector extends GAstVisitor {\n    constructor() {\n      super(...arguments)\n      this.allProductions = []\n    }\n    visitNonTerminal(subrule) {\n      this.allProductions.push(subrule)\n    }\n    visitOption(option) {\n      this.allProductions.push(option)\n    }\n    visitRepetitionWithSeparator(manySep) {\n      this.allProductions.push(manySep)\n    }\n    visitRepetitionMandatory(atLeastOne) {\n      this.allProductions.push(atLeastOne)\n    }\n    visitRepetitionMandatoryWithSeparator(atLeastOneSep) {\n      this.allProductions.push(atLeastOneSep)\n    }\n    visitRepetition(many) {\n      this.allProductions.push(many)\n    }\n    visitAlternation(or) {\n      this.allProductions.push(or)\n    }\n    visitTerminal(terminal) {\n      this.allProductions.push(terminal)\n    }\n  }\n  function validateRuleDoesNotAlreadyExist(rule, allRules, className, errMsgProvider) {\n    const errors = []\n    const occurrences = reduce(\n      allRules,\n      (result, curRule) => {\n        if (curRule.name === rule.name) {\n          return result + 1\n        }\n        return result\n      },\n      0,\n    )\n    if (occurrences > 1) {\n      const errMsg = errMsgProvider.buildDuplicateRuleNameError({\n        topLevelRule: rule,\n        grammarName: className,\n      })\n      errors.push({\n        message: errMsg,\n        type: ParserDefinitionErrorType.DUPLICATE_RULE_NAME,\n        ruleName: rule.name,\n      })\n    }\n    return errors\n  }\n  // TODO: is there anyway to get only the rule names of rules inherited from the super grammars?\n  // This is not part of the IGrammarErrorProvider because the validation cannot be performed on\n  // The grammar structure, only at runtime.\n  function validateRuleIsOverridden(ruleName, definedRulesNames, className) {\n    const errors = []\n    let errMsg\n    if (!includes(definedRulesNames, ruleName)) {\n      errMsg =\n        `Invalid rule override, rule: ->${ruleName}<- cannot be overridden in the grammar: ->${className}<-` +\n        `as it is not defined in any of the super grammars `\n      errors.push({\n        message: errMsg,\n        type: ParserDefinitionErrorType.INVALID_RULE_OVERRIDE,\n        ruleName: ruleName,\n      })\n    }\n    return errors\n  }\n  function validateNoLeftRecursion(topRule, currRule, errMsgProvider, path = []) {\n    const errors = []\n    const nextNonTerminals = getFirstNoneTerminal(currRule.definition)\n    if (isEmpty(nextNonTerminals)) {\n      return []\n    } else {\n      const ruleName = topRule.name\n      const foundLeftRecursion = includes(nextNonTerminals, topRule)\n      if (foundLeftRecursion) {\n        errors.push({\n          message: errMsgProvider.buildLeftRecursionError({\n            topLevelRule: topRule,\n            leftRecursionPath: path,\n          }),\n          type: ParserDefinitionErrorType.LEFT_RECURSION,\n          ruleName: ruleName,\n        })\n      }\n      // we are only looking for cyclic paths leading back to the specific topRule\n      // other cyclic paths are ignored, we still need this difference to avoid infinite loops...\n      const validNextSteps = difference$1(nextNonTerminals, path.concat([topRule]))\n      const errorsFromNextSteps = flatMap(validNextSteps, (currRefRule) => {\n        const newPath = clone(path)\n        newPath.push(currRefRule)\n        return validateNoLeftRecursion(topRule, currRefRule, errMsgProvider, newPath)\n      })\n      return errors.concat(errorsFromNextSteps)\n    }\n  }\n  function getFirstNoneTerminal(definition) {\n    let result = []\n    if (isEmpty(definition)) {\n      return result\n    }\n    const firstProd = head(definition)\n    /* istanbul ignore else */\n    if (firstProd instanceof NonTerminal) {\n      result.push(firstProd.referencedRule)\n    } else if (\n      firstProd instanceof Alternative ||\n      firstProd instanceof Option ||\n      firstProd instanceof RepetitionMandatory ||\n      firstProd instanceof RepetitionMandatoryWithSeparator ||\n      firstProd instanceof RepetitionWithSeparator ||\n      firstProd instanceof Repetition\n    ) {\n      result = result.concat(getFirstNoneTerminal(firstProd.definition))\n    } else if (firstProd instanceof Alternation) {\n      // each sub definition in alternation is a FLAT\n      result = flatten(map(firstProd.definition, (currSubDef) => getFirstNoneTerminal(currSubDef.definition)))\n    } else if (firstProd instanceof Terminal);\n    else {\n      throw Error('non exhaustive match')\n    }\n    const isFirstOptional = isOptionalProd(firstProd)\n    const hasMore = definition.length > 1\n    if (isFirstOptional && hasMore) {\n      const rest = drop(definition)\n      return result.concat(getFirstNoneTerminal(rest))\n    } else {\n      return result\n    }\n  }\n  class OrCollector extends GAstVisitor {\n    constructor() {\n      super(...arguments)\n      this.alternations = []\n    }\n    visitAlternation(node) {\n      this.alternations.push(node)\n    }\n  }\n  function validateEmptyOrAlternative(topLevelRule, errMsgProvider) {\n    const orCollector = new OrCollector()\n    topLevelRule.accept(orCollector)\n    const ors = orCollector.alternations\n    const errors = flatMap(ors, (currOr) => {\n      const exceptLast = dropRight(currOr.definition)\n      return flatMap(exceptLast, (currAlternative, currAltIdx) => {\n        const possibleFirstInAlt = nextPossibleTokensAfter([currAlternative], [], tokenStructuredMatcher, 1)\n        if (isEmpty(possibleFirstInAlt)) {\n          return [\n            {\n              message: errMsgProvider.buildEmptyAlternationError({\n                topLevelRule: topLevelRule,\n                alternation: currOr,\n                emptyChoiceIdx: currAltIdx,\n              }),\n              type: ParserDefinitionErrorType.NONE_LAST_EMPTY_ALT,\n              ruleName: topLevelRule.name,\n              occurrence: currOr.idx,\n              alternative: currAltIdx + 1,\n            },\n          ]\n        } else {\n          return []\n        }\n      })\n    })\n    return errors\n  }\n  function validateAmbiguousAlternationAlternatives(topLevelRule, globalMaxLookahead, errMsgProvider) {\n    const orCollector = new OrCollector()\n    topLevelRule.accept(orCollector)\n    let ors = orCollector.alternations\n    // New Handling of ignoring ambiguities\n    // - https://github.com/chevrotain/chevrotain/issues/869\n    ors = reject(ors, (currOr) => currOr.ignoreAmbiguities === true)\n    const errors = flatMap(ors, (currOr) => {\n      const currOccurrence = currOr.idx\n      const actualMaxLookahead = currOr.maxLookahead || globalMaxLookahead\n      const alternatives = getLookaheadPathsForOr(currOccurrence, topLevelRule, actualMaxLookahead, currOr)\n      const altsAmbiguityErrors = checkAlternativesAmbiguities(alternatives, currOr, topLevelRule, errMsgProvider)\n      const altsPrefixAmbiguityErrors = checkPrefixAlternativesAmbiguities(\n        alternatives,\n        currOr,\n        topLevelRule,\n        errMsgProvider,\n      )\n      return altsAmbiguityErrors.concat(altsPrefixAmbiguityErrors)\n    })\n    return errors\n  }\n  class RepetitionCollector extends GAstVisitor {\n    constructor() {\n      super(...arguments)\n      this.allProductions = []\n    }\n    visitRepetitionWithSeparator(manySep) {\n      this.allProductions.push(manySep)\n    }\n    visitRepetitionMandatory(atLeastOne) {\n      this.allProductions.push(atLeastOne)\n    }\n    visitRepetitionMandatoryWithSeparator(atLeastOneSep) {\n      this.allProductions.push(atLeastOneSep)\n    }\n    visitRepetition(many) {\n      this.allProductions.push(many)\n    }\n  }\n  function validateTooManyAlts(topLevelRule, errMsgProvider) {\n    const orCollector = new OrCollector()\n    topLevelRule.accept(orCollector)\n    const ors = orCollector.alternations\n    const errors = flatMap(ors, (currOr) => {\n      if (currOr.definition.length > 255) {\n        return [\n          {\n            message: errMsgProvider.buildTooManyAlternativesError({\n              topLevelRule: topLevelRule,\n              alternation: currOr,\n            }),\n            type: ParserDefinitionErrorType.TOO_MANY_ALTS,\n            ruleName: topLevelRule.name,\n            occurrence: currOr.idx,\n          },\n        ]\n      } else {\n        return []\n      }\n    })\n    return errors\n  }\n  function validateSomeNonEmptyLookaheadPath(topLevelRules, maxLookahead, errMsgProvider) {\n    const errors = []\n    forEach(topLevelRules, (currTopRule) => {\n      const collectorVisitor = new RepetitionCollector()\n      currTopRule.accept(collectorVisitor)\n      const allRuleProductions = collectorVisitor.allProductions\n      forEach(allRuleProductions, (currProd) => {\n        const prodType = getProdType(currProd)\n        const actualMaxLookahead = currProd.maxLookahead || maxLookahead\n        const currOccurrence = currProd.idx\n        const paths = getLookaheadPathsForOptionalProd(currOccurrence, currTopRule, prodType, actualMaxLookahead)\n        const pathsInsideProduction = paths[0]\n        if (isEmpty(flatten(pathsInsideProduction))) {\n          const errMsg = errMsgProvider.buildEmptyRepetitionError({\n            topLevelRule: currTopRule,\n            repetition: currProd,\n          })\n          errors.push({\n            message: errMsg,\n            type: ParserDefinitionErrorType.NO_NON_EMPTY_LOOKAHEAD,\n            ruleName: currTopRule.name,\n          })\n        }\n      })\n    })\n    return errors\n  }\n  function checkAlternativesAmbiguities(alternatives, alternation, rule, errMsgProvider) {\n    const foundAmbiguousPaths = []\n    const identicalAmbiguities = reduce(\n      alternatives,\n      (result, currAlt, currAltIdx) => {\n        // ignore (skip) ambiguities with this alternative\n        if (alternation.definition[currAltIdx].ignoreAmbiguities === true) {\n          return result\n        }\n        forEach(currAlt, (currPath) => {\n          const altsCurrPathAppearsIn = [currAltIdx]\n          forEach(alternatives, (currOtherAlt, currOtherAltIdx) => {\n            if (\n              currAltIdx !== currOtherAltIdx &&\n              containsPath(currOtherAlt, currPath) &&\n              // ignore (skip) ambiguities with this \"other\" alternative\n              alternation.definition[currOtherAltIdx].ignoreAmbiguities !== true\n            ) {\n              altsCurrPathAppearsIn.push(currOtherAltIdx)\n            }\n          })\n          if (altsCurrPathAppearsIn.length > 1 && !containsPath(foundAmbiguousPaths, currPath)) {\n            foundAmbiguousPaths.push(currPath)\n            result.push({\n              alts: altsCurrPathAppearsIn,\n              path: currPath,\n            })\n          }\n        })\n        return result\n      },\n      [],\n    )\n    const currErrors = map(identicalAmbiguities, (currAmbDescriptor) => {\n      const ambgIndices = map(currAmbDescriptor.alts, (currAltIdx) => currAltIdx + 1)\n      const currMessage = errMsgProvider.buildAlternationAmbiguityError({\n        topLevelRule: rule,\n        alternation: alternation,\n        ambiguityIndices: ambgIndices,\n        prefixPath: currAmbDescriptor.path,\n      })\n      return {\n        message: currMessage,\n        type: ParserDefinitionErrorType.AMBIGUOUS_ALTS,\n        ruleName: rule.name,\n        occurrence: alternation.idx,\n        alternatives: currAmbDescriptor.alts,\n      }\n    })\n    return currErrors\n  }\n  function checkPrefixAlternativesAmbiguities(alternatives, alternation, rule, errMsgProvider) {\n    // flatten\n    const pathsAndIndices = reduce(\n      alternatives,\n      (result, currAlt, idx) => {\n        const currPathsAndIdx = map(currAlt, (currPath) => {\n          return { idx: idx, path: currPath }\n        })\n        return result.concat(currPathsAndIdx)\n      },\n      [],\n    )\n    const errors = compact(\n      flatMap(pathsAndIndices, (currPathAndIdx) => {\n        const alternativeGast = alternation.definition[currPathAndIdx.idx]\n        // ignore (skip) ambiguities with this alternative\n        if (alternativeGast.ignoreAmbiguities === true) {\n          return []\n        }\n        const targetIdx = currPathAndIdx.idx\n        const targetPath = currPathAndIdx.path\n        const prefixAmbiguitiesPathsAndIndices = filter(pathsAndIndices, (searchPathAndIdx) => {\n          // prefix ambiguity can only be created from lower idx (higher priority) path\n          return (\n            // ignore (skip) ambiguities with this \"other\" alternative\n            alternation.definition[searchPathAndIdx.idx].ignoreAmbiguities !== true &&\n            searchPathAndIdx.idx < targetIdx &&\n            // checking for strict prefix because identical lookaheads\n            // will be be detected using a different validation.\n            isStrictPrefixOfPath(searchPathAndIdx.path, targetPath)\n          )\n        })\n        const currPathPrefixErrors = map(prefixAmbiguitiesPathsAndIndices, (currAmbPathAndIdx) => {\n          const ambgIndices = [currAmbPathAndIdx.idx + 1, targetIdx + 1]\n          const occurrence = alternation.idx === 0 ? '' : alternation.idx\n          const message = errMsgProvider.buildAlternationPrefixAmbiguityError({\n            topLevelRule: rule,\n            alternation: alternation,\n            ambiguityIndices: ambgIndices,\n            prefixPath: currAmbPathAndIdx.path,\n          })\n          return {\n            message: message,\n            type: ParserDefinitionErrorType.AMBIGUOUS_PREFIX_ALTS,\n            ruleName: rule.name,\n            occurrence: occurrence,\n            alternatives: ambgIndices,\n          }\n        })\n        return currPathPrefixErrors\n      }),\n    )\n    return errors\n  }\n  function checkTerminalAndNoneTerminalsNameSpace(topLevels, tokenTypes, errMsgProvider) {\n    const errors = []\n    const tokenNames = map(tokenTypes, (currToken) => currToken.name)\n    forEach(topLevels, (currRule) => {\n      const currRuleName = currRule.name\n      if (includes(tokenNames, currRuleName)) {\n        const errMsg = errMsgProvider.buildNamespaceConflictError(currRule)\n        errors.push({\n          message: errMsg,\n          type: ParserDefinitionErrorType.CONFLICT_TOKENS_RULES_NAMESPACE,\n          ruleName: currRuleName,\n        })\n      }\n    })\n    return errors\n  }\n\n  function resolveGrammar(options) {\n    const actualOptions = defaults$1(options, {\n      errMsgProvider: defaultGrammarResolverErrorProvider,\n    })\n    const topRulesTable = {}\n    forEach(options.rules, (rule) => {\n      topRulesTable[rule.name] = rule\n    })\n    return resolveGrammar$1(topRulesTable, actualOptions.errMsgProvider)\n  }\n  function validateGrammar(options) {\n    options = defaults$1(options, {\n      errMsgProvider: defaultGrammarValidatorErrorProvider,\n    })\n    return validateGrammar$1(options.rules, options.tokenTypes, options.errMsgProvider, options.grammarName)\n  }\n\n  const MISMATCHED_TOKEN_EXCEPTION = 'MismatchedTokenException'\n  const NO_VIABLE_ALT_EXCEPTION = 'NoViableAltException'\n  const EARLY_EXIT_EXCEPTION = 'EarlyExitException'\n  const NOT_ALL_INPUT_PARSED_EXCEPTION = 'NotAllInputParsedException'\n  const RECOGNITION_EXCEPTION_NAMES = [\n    MISMATCHED_TOKEN_EXCEPTION,\n    NO_VIABLE_ALT_EXCEPTION,\n    EARLY_EXIT_EXCEPTION,\n    NOT_ALL_INPUT_PARSED_EXCEPTION,\n  ]\n  Object.freeze(RECOGNITION_EXCEPTION_NAMES)\n  // hacks to bypass no support for custom Errors in javascript/typescript\n  function isRecognitionException(error) {\n    // can't do instanceof on hacked custom js exceptions\n    return includes(RECOGNITION_EXCEPTION_NAMES, error.name)\n  }\n  class RecognitionException extends Error {\n    constructor(message, token) {\n      super(message)\n      this.token = token\n      this.resyncedTokens = []\n      // fix prototype chain when typescript target is ES5\n      Object.setPrototypeOf(this, new.target.prototype)\n      /* istanbul ignore next - V8 workaround to remove constructor from stacktrace when typescript target is ES5 */\n      if (Error.captureStackTrace) {\n        Error.captureStackTrace(this, this.constructor)\n      }\n    }\n  }\n  class MismatchedTokenException extends RecognitionException {\n    constructor(message, token, previousToken) {\n      super(message, token)\n      this.previousToken = previousToken\n      this.name = MISMATCHED_TOKEN_EXCEPTION\n    }\n  }\n  class NoViableAltException extends RecognitionException {\n    constructor(message, token, previousToken) {\n      super(message, token)\n      this.previousToken = previousToken\n      this.name = NO_VIABLE_ALT_EXCEPTION\n    }\n  }\n  class NotAllInputParsedException extends RecognitionException {\n    constructor(message, token) {\n      super(message, token)\n      this.name = NOT_ALL_INPUT_PARSED_EXCEPTION\n    }\n  }\n  class EarlyExitException extends RecognitionException {\n    constructor(message, token, previousToken) {\n      super(message, token)\n      this.previousToken = previousToken\n      this.name = EARLY_EXIT_EXCEPTION\n    }\n  }\n\n  const EOF_FOLLOW_KEY = {}\n  const IN_RULE_RECOVERY_EXCEPTION = 'InRuleRecoveryException'\n  class InRuleRecoveryException extends Error {\n    constructor(message) {\n      super(message)\n      this.name = IN_RULE_RECOVERY_EXCEPTION\n    }\n  }\n  /**\n   * This trait is responsible for the error recovery and fault tolerant logic\n   */\n  class Recoverable {\n    initRecoverable(config) {\n      this.firstAfterRepMap = {}\n      this.resyncFollows = {}\n      this.recoveryEnabled = has(config, 'recoveryEnabled')\n        ? config.recoveryEnabled // assumes end user provides the correct config value/type\n        : DEFAULT_PARSER_CONFIG.recoveryEnabled\n      // performance optimization, NOOP will be inlined which\n      // effectively means that this optional feature does not exist\n      // when not used.\n      if (this.recoveryEnabled) {\n        this.attemptInRepetitionRecovery = attemptInRepetitionRecovery\n      }\n    }\n    getTokenToInsert(tokType) {\n      const tokToInsert = createTokenInstance(tokType, '', NaN, NaN, NaN, NaN, NaN, NaN)\n      tokToInsert.isInsertedInRecovery = true\n      return tokToInsert\n    }\n    canTokenTypeBeInsertedInRecovery(tokType) {\n      return true\n    }\n    canTokenTypeBeDeletedInRecovery(tokType) {\n      return true\n    }\n    tryInRepetitionRecovery(grammarRule, grammarRuleArgs, lookAheadFunc, expectedTokType) {\n      // TODO: can the resyncTokenType be cached?\n      const reSyncTokType = this.findReSyncTokenType()\n      const savedLexerState = this.exportLexerState()\n      const resyncedTokens = []\n      let passedResyncPoint = false\n      const nextTokenWithoutResync = this.LA(1)\n      let currToken = this.LA(1)\n      const generateErrorMessage = () => {\n        const previousToken = this.LA(0)\n        // we are preemptively re-syncing before an error has been detected, therefor we must reproduce\n        // the error that would have been thrown\n        const msg = this.errorMessageProvider.buildMismatchTokenMessage({\n          expected: expectedTokType,\n          actual: nextTokenWithoutResync,\n          previous: previousToken,\n          ruleName: this.getCurrRuleFullName(),\n        })\n        const error = new MismatchedTokenException(msg, nextTokenWithoutResync, this.LA(0))\n        // the first token here will be the original cause of the error, this is not part of the resyncedTokens property.\n        error.resyncedTokens = dropRight(resyncedTokens)\n        this.SAVE_ERROR(error)\n      }\n      while (!passedResyncPoint) {\n        // re-synced to a point where we can safely exit the repetition/\n        if (this.tokenMatcher(currToken, expectedTokType)) {\n          generateErrorMessage()\n          return // must return here to avoid reverting the inputIdx\n        } else if (lookAheadFunc.call(this)) {\n          // we skipped enough tokens so we can resync right back into another iteration of the repetition grammar rule\n          generateErrorMessage()\n          // recursive invocation in other to support multiple re-syncs in the same top level repetition grammar rule\n          grammarRule.apply(this, grammarRuleArgs)\n          return // must return here to avoid reverting the inputIdx\n        } else if (this.tokenMatcher(currToken, reSyncTokType)) {\n          passedResyncPoint = true\n        } else {\n          currToken = this.SKIP_TOKEN()\n          this.addToResyncTokens(currToken, resyncedTokens)\n        }\n      }\n      // we were unable to find a CLOSER point to resync inside the Repetition, reset the state.\n      // The parsing exception we were trying to prevent will happen in the NEXT parsing step. it may be handled by\n      // \"between rules\" resync recovery later in the flow.\n      this.importLexerState(savedLexerState)\n    }\n    shouldInRepetitionRecoveryBeTried(expectTokAfterLastMatch, nextTokIdx, notStuck) {\n      // Edge case of arriving from a MANY repetition which is stuck\n      // Attempting recovery in this case could cause an infinite loop\n      if (notStuck === false) {\n        return false\n      }\n      // no need to recover, next token is what we expect...\n      if (this.tokenMatcher(this.LA(1), expectTokAfterLastMatch)) {\n        return false\n      }\n      // error recovery is disabled during backtracking as it can make the parser ignore a valid grammar path\n      // and prefer some backtracking path that includes recovered errors.\n      if (this.isBackTracking()) {\n        return false\n      }\n      // if we can perform inRule recovery (single token insertion or deletion) we always prefer that recovery algorithm\n      // because if it works, it makes the least amount of changes to the input stream (greedy algorithm)\n      //noinspection RedundantIfStatementJS\n      if (\n        this.canPerformInRuleRecovery(\n          expectTokAfterLastMatch,\n          this.getFollowsForInRuleRecovery(expectTokAfterLastMatch, nextTokIdx),\n        )\n      ) {\n        return false\n      }\n      return true\n    }\n    // Error Recovery functionality\n    getFollowsForInRuleRecovery(tokType, tokIdxInRule) {\n      const grammarPath = this.getCurrentGrammarPath(tokType, tokIdxInRule)\n      const follows = this.getNextPossibleTokenTypes(grammarPath)\n      return follows\n    }\n    tryInRuleRecovery(expectedTokType, follows) {\n      if (this.canRecoverWithSingleTokenInsertion(expectedTokType, follows)) {\n        const tokToInsert = this.getTokenToInsert(expectedTokType)\n        return tokToInsert\n      }\n      if (this.canRecoverWithSingleTokenDeletion(expectedTokType)) {\n        const nextTok = this.SKIP_TOKEN()\n        this.consumeToken()\n        return nextTok\n      }\n      throw new InRuleRecoveryException('sad sad panda')\n    }\n    canPerformInRuleRecovery(expectedToken, follows) {\n      return (\n        this.canRecoverWithSingleTokenInsertion(expectedToken, follows) ||\n        this.canRecoverWithSingleTokenDeletion(expectedToken)\n      )\n    }\n    canRecoverWithSingleTokenInsertion(expectedTokType, follows) {\n      if (!this.canTokenTypeBeInsertedInRecovery(expectedTokType)) {\n        return false\n      }\n      // must know the possible following tokens to perform single token insertion\n      if (isEmpty(follows)) {\n        return false\n      }\n      const mismatchedTok = this.LA(1)\n      const isMisMatchedTokInFollows =\n        find$1(follows, (possibleFollowsTokType) => {\n          return this.tokenMatcher(mismatchedTok, possibleFollowsTokType)\n        }) !== undefined\n      return isMisMatchedTokInFollows\n    }\n    canRecoverWithSingleTokenDeletion(expectedTokType) {\n      if (!this.canTokenTypeBeDeletedInRecovery(expectedTokType)) {\n        return false\n      }\n      const isNextTokenWhatIsExpected = this.tokenMatcher(this.LA(2), expectedTokType)\n      return isNextTokenWhatIsExpected\n    }\n    isInCurrentRuleReSyncSet(tokenTypeIdx) {\n      const followKey = this.getCurrFollowKey()\n      const currentRuleReSyncSet = this.getFollowSetFromFollowKey(followKey)\n      return includes(currentRuleReSyncSet, tokenTypeIdx)\n    }\n    findReSyncTokenType() {\n      const allPossibleReSyncTokTypes = this.flattenFollowSet()\n      // this loop will always terminate as EOF is always in the follow stack and also always (virtually) in the input\n      let nextToken = this.LA(1)\n      let k = 2\n      while (true) {\n        const foundMatch = find$1(allPossibleReSyncTokTypes, (resyncTokType) => {\n          const canMatch = tokenMatcher(nextToken, resyncTokType)\n          return canMatch\n        })\n        if (foundMatch !== undefined) {\n          return foundMatch\n        }\n        nextToken = this.LA(k)\n        k++\n      }\n    }\n    getCurrFollowKey() {\n      // the length is at least one as we always add the ruleName to the stack before invoking the rule.\n      if (this.RULE_STACK.length === 1) {\n        return EOF_FOLLOW_KEY\n      }\n      const currRuleShortName = this.getLastExplicitRuleShortName()\n      const currRuleIdx = this.getLastExplicitRuleOccurrenceIndex()\n      const prevRuleShortName = this.getPreviousExplicitRuleShortName()\n      return {\n        ruleName: this.shortRuleNameToFullName(currRuleShortName),\n        idxInCallingRule: currRuleIdx,\n        inRule: this.shortRuleNameToFullName(prevRuleShortName),\n      }\n    }\n    buildFullFollowKeyStack() {\n      const explicitRuleStack = this.RULE_STACK\n      const explicitOccurrenceStack = this.RULE_OCCURRENCE_STACK\n      return map(explicitRuleStack, (ruleName, idx) => {\n        if (idx === 0) {\n          return EOF_FOLLOW_KEY\n        }\n        return {\n          ruleName: this.shortRuleNameToFullName(ruleName),\n          idxInCallingRule: explicitOccurrenceStack[idx],\n          inRule: this.shortRuleNameToFullName(explicitRuleStack[idx - 1]),\n        }\n      })\n    }\n    flattenFollowSet() {\n      const followStack = map(this.buildFullFollowKeyStack(), (currKey) => {\n        return this.getFollowSetFromFollowKey(currKey)\n      })\n      return flatten(followStack)\n    }\n    getFollowSetFromFollowKey(followKey) {\n      if (followKey === EOF_FOLLOW_KEY) {\n        return [EOF]\n      }\n      const followName = followKey.ruleName + followKey.idxInCallingRule + IN + followKey.inRule\n      return this.resyncFollows[followName]\n    }\n    // It does not make any sense to include a virtual EOF token in the list of resynced tokens\n    // as EOF does not really exist and thus does not contain any useful information (line/column numbers)\n    addToResyncTokens(token, resyncTokens) {\n      if (!this.tokenMatcher(token, EOF)) {\n        resyncTokens.push(token)\n      }\n      return resyncTokens\n    }\n    reSyncTo(tokType) {\n      const resyncedTokens = []\n      let nextTok = this.LA(1)\n      while (this.tokenMatcher(nextTok, tokType) === false) {\n        nextTok = this.SKIP_TOKEN()\n        this.addToResyncTokens(nextTok, resyncedTokens)\n      }\n      // the last token is not part of the error.\n      return dropRight(resyncedTokens)\n    }\n    attemptInRepetitionRecovery(prodFunc, args, lookaheadFunc, dslMethodIdx, prodOccurrence, nextToksWalker, notStuck) {\n      // by default this is a NO-OP\n      // The actual implementation is with the function(not method) below\n    }\n    getCurrentGrammarPath(tokType, tokIdxInRule) {\n      const pathRuleStack = this.getHumanReadableRuleStack()\n      const pathOccurrenceStack = clone(this.RULE_OCCURRENCE_STACK)\n      const grammarPath = {\n        ruleStack: pathRuleStack,\n        occurrenceStack: pathOccurrenceStack,\n        lastTok: tokType,\n        lastTokOccurrence: tokIdxInRule,\n      }\n      return grammarPath\n    }\n    getHumanReadableRuleStack() {\n      return map(this.RULE_STACK, (currShortName) => this.shortRuleNameToFullName(currShortName))\n    }\n  }\n  function attemptInRepetitionRecovery(\n    prodFunc,\n    args,\n    lookaheadFunc,\n    dslMethodIdx,\n    prodOccurrence,\n    nextToksWalker,\n    notStuck,\n  ) {\n    const key = this.getKeyForAutomaticLookahead(dslMethodIdx, prodOccurrence)\n    let firstAfterRepInfo = this.firstAfterRepMap[key]\n    if (firstAfterRepInfo === undefined) {\n      const currRuleName = this.getCurrRuleFullName()\n      const ruleGrammar = this.getGAstProductions()[currRuleName]\n      const walker = new nextToksWalker(ruleGrammar, prodOccurrence)\n      firstAfterRepInfo = walker.startWalking()\n      this.firstAfterRepMap[key] = firstAfterRepInfo\n    }\n    let expectTokAfterLastMatch = firstAfterRepInfo.token\n    let nextTokIdx = firstAfterRepInfo.occurrence\n    const isEndOfRule = firstAfterRepInfo.isEndOfRule\n    // special edge case of a TOP most repetition after which the input should END.\n    // this will force an attempt for inRule recovery in that scenario.\n    if (this.RULE_STACK.length === 1 && isEndOfRule && expectTokAfterLastMatch === undefined) {\n      expectTokAfterLastMatch = EOF\n      nextTokIdx = 1\n    }\n    // We don't have anything to re-sync to...\n    // this condition was extracted from `shouldInRepetitionRecoveryBeTried` to act as a type-guard\n    if (expectTokAfterLastMatch === undefined || nextTokIdx === undefined) {\n      return\n    }\n    if (this.shouldInRepetitionRecoveryBeTried(expectTokAfterLastMatch, nextTokIdx, notStuck)) {\n      // TODO: performance optimization: instead of passing the original args here, we modify\n      // the args param (or create a new one) and make sure the lookahead func is explicitly provided\n      // to avoid searching the cache for it once more.\n      this.tryInRepetitionRecovery(prodFunc, args, lookaheadFunc, expectTokAfterLastMatch)\n    }\n  }\n\n  // Lookahead keys are 32Bit integers in the form\n  // TTTTTTTT-ZZZZZZZZZZZZ-YYYY-XXXXXXXX\n  // XXXX -> Occurrence Index bitmap.\n  // YYYY -> DSL Method Type bitmap.\n  // ZZZZZZZZZZZZZZZ -> Rule short Index bitmap.\n  // TTTTTTTTT -> alternation alternative index bitmap\n  const BITS_FOR_METHOD_TYPE = 4\n  const BITS_FOR_OCCURRENCE_IDX = 8\n  // short string used as part of mapping keys.\n  // being short improves the performance when composing KEYS for maps out of these\n  // The 5 - 8 bits (16 possible values, are reserved for the DSL method indices)\n  const OR_IDX = 1 << BITS_FOR_OCCURRENCE_IDX\n  const OPTION_IDX = 2 << BITS_FOR_OCCURRENCE_IDX\n  const MANY_IDX = 3 << BITS_FOR_OCCURRENCE_IDX\n  const AT_LEAST_ONE_IDX = 4 << BITS_FOR_OCCURRENCE_IDX\n  const MANY_SEP_IDX = 5 << BITS_FOR_OCCURRENCE_IDX\n  const AT_LEAST_ONE_SEP_IDX = 6 << BITS_FOR_OCCURRENCE_IDX\n  // this actually returns a number, but it is always used as a string (object prop key)\n  function getKeyForAutomaticLookahead(ruleIdx, dslMethodIdx, occurrence) {\n    return occurrence | dslMethodIdx | ruleIdx\n  }\n\n  class LLkLookaheadStrategy {\n    constructor(options) {\n      var _a\n      this.maxLookahead =\n        (_a = options === null || options === void 0 ? void 0 : options.maxLookahead) !== null && _a !== void 0\n          ? _a\n          : DEFAULT_PARSER_CONFIG.maxLookahead\n    }\n    validate(options) {\n      const leftRecursionErrors = this.validateNoLeftRecursion(options.rules)\n      if (isEmpty(leftRecursionErrors)) {\n        const emptyAltErrors = this.validateEmptyOrAlternatives(options.rules)\n        const ambiguousAltsErrors = this.validateAmbiguousAlternationAlternatives(options.rules, this.maxLookahead)\n        const emptyRepetitionErrors = this.validateSomeNonEmptyLookaheadPath(options.rules, this.maxLookahead)\n        const allErrors = [...leftRecursionErrors, ...emptyAltErrors, ...ambiguousAltsErrors, ...emptyRepetitionErrors]\n        return allErrors\n      }\n      return leftRecursionErrors\n    }\n    validateNoLeftRecursion(rules) {\n      return flatMap(rules, (currTopRule) =>\n        validateNoLeftRecursion(currTopRule, currTopRule, defaultGrammarValidatorErrorProvider),\n      )\n    }\n    validateEmptyOrAlternatives(rules) {\n      return flatMap(rules, (currTopRule) =>\n        validateEmptyOrAlternative(currTopRule, defaultGrammarValidatorErrorProvider),\n      )\n    }\n    validateAmbiguousAlternationAlternatives(rules, maxLookahead) {\n      return flatMap(rules, (currTopRule) =>\n        validateAmbiguousAlternationAlternatives(currTopRule, maxLookahead, defaultGrammarValidatorErrorProvider),\n      )\n    }\n    validateSomeNonEmptyLookaheadPath(rules, maxLookahead) {\n      return validateSomeNonEmptyLookaheadPath(rules, maxLookahead, defaultGrammarValidatorErrorProvider)\n    }\n    buildLookaheadForAlternation(options) {\n      return buildLookaheadFuncForOr(\n        options.prodOccurrence,\n        options.rule,\n        options.maxLookahead,\n        options.hasPredicates,\n        options.dynamicTokensEnabled,\n        buildAlternativesLookAheadFunc,\n      )\n    }\n    buildLookaheadForOptional(options) {\n      return buildLookaheadFuncForOptionalProd(\n        options.prodOccurrence,\n        options.rule,\n        options.maxLookahead,\n        options.dynamicTokensEnabled,\n        getProdType(options.prodType),\n        buildSingleAlternativeLookaheadFunction,\n      )\n    }\n  }\n\n  /**\n   * Trait responsible for the lookahead related utilities and optimizations.\n   */\n  class LooksAhead {\n    initLooksAhead(config) {\n      this.dynamicTokensEnabled = has(config, 'dynamicTokensEnabled')\n        ? config.dynamicTokensEnabled // assumes end user provides the correct config value/type\n        : DEFAULT_PARSER_CONFIG.dynamicTokensEnabled\n      this.maxLookahead = has(config, 'maxLookahead')\n        ? config.maxLookahead // assumes end user provides the correct config value/type\n        : DEFAULT_PARSER_CONFIG.maxLookahead\n      this.lookaheadStrategy = has(config, 'lookaheadStrategy')\n        ? config.lookaheadStrategy // assumes end user provides the correct config value/type\n        : new LLkLookaheadStrategy({ maxLookahead: this.maxLookahead })\n      this.lookAheadFuncsCache = new Map()\n    }\n    preComputeLookaheadFunctions(rules) {\n      forEach(rules, (currRule) => {\n        this.TRACE_INIT(`${currRule.name} Rule Lookahead`, () => {\n          const {\n            alternation,\n            repetition,\n            option,\n            repetitionMandatory,\n            repetitionMandatoryWithSeparator,\n            repetitionWithSeparator,\n          } = collectMethods(currRule)\n          forEach(alternation, (currProd) => {\n            const prodIdx = currProd.idx === 0 ? '' : currProd.idx\n            this.TRACE_INIT(`${getProductionDslName(currProd)}${prodIdx}`, () => {\n              const laFunc = this.lookaheadStrategy.buildLookaheadForAlternation({\n                prodOccurrence: currProd.idx,\n                rule: currRule,\n                maxLookahead: currProd.maxLookahead || this.maxLookahead,\n                hasPredicates: currProd.hasPredicates,\n                dynamicTokensEnabled: this.dynamicTokensEnabled,\n              })\n              const key = getKeyForAutomaticLookahead(this.fullRuleNameToShort[currRule.name], OR_IDX, currProd.idx)\n              this.setLaFuncCache(key, laFunc)\n            })\n          })\n          forEach(repetition, (currProd) => {\n            this.computeLookaheadFunc(\n              currRule,\n              currProd.idx,\n              MANY_IDX,\n              'Repetition',\n              currProd.maxLookahead,\n              getProductionDslName(currProd),\n            )\n          })\n          forEach(option, (currProd) => {\n            this.computeLookaheadFunc(\n              currRule,\n              currProd.idx,\n              OPTION_IDX,\n              'Option',\n              currProd.maxLookahead,\n              getProductionDslName(currProd),\n            )\n          })\n          forEach(repetitionMandatory, (currProd) => {\n            this.computeLookaheadFunc(\n              currRule,\n              currProd.idx,\n              AT_LEAST_ONE_IDX,\n              'RepetitionMandatory',\n              currProd.maxLookahead,\n              getProductionDslName(currProd),\n            )\n          })\n          forEach(repetitionMandatoryWithSeparator, (currProd) => {\n            this.computeLookaheadFunc(\n              currRule,\n              currProd.idx,\n              AT_LEAST_ONE_SEP_IDX,\n              'RepetitionMandatoryWithSeparator',\n              currProd.maxLookahead,\n              getProductionDslName(currProd),\n            )\n          })\n          forEach(repetitionWithSeparator, (currProd) => {\n            this.computeLookaheadFunc(\n              currRule,\n              currProd.idx,\n              MANY_SEP_IDX,\n              'RepetitionWithSeparator',\n              currProd.maxLookahead,\n              getProductionDslName(currProd),\n            )\n          })\n        })\n      })\n    }\n    computeLookaheadFunc(rule, prodOccurrence, prodKey, prodType, prodMaxLookahead, dslMethodName) {\n      this.TRACE_INIT(`${dslMethodName}${prodOccurrence === 0 ? '' : prodOccurrence}`, () => {\n        const laFunc = this.lookaheadStrategy.buildLookaheadForOptional({\n          prodOccurrence,\n          rule,\n          maxLookahead: prodMaxLookahead || this.maxLookahead,\n          dynamicTokensEnabled: this.dynamicTokensEnabled,\n          prodType,\n        })\n        const key = getKeyForAutomaticLookahead(this.fullRuleNameToShort[rule.name], prodKey, prodOccurrence)\n        this.setLaFuncCache(key, laFunc)\n      })\n    }\n    // this actually returns a number, but it is always used as a string (object prop key)\n    getKeyForAutomaticLookahead(dslMethodIdx, occurrence) {\n      const currRuleShortName = this.getLastExplicitRuleShortName()\n      return getKeyForAutomaticLookahead(currRuleShortName, dslMethodIdx, occurrence)\n    }\n    getLaFuncFromCache(key) {\n      return this.lookAheadFuncsCache.get(key)\n    }\n    /* istanbul ignore next */\n    setLaFuncCache(key, value) {\n      this.lookAheadFuncsCache.set(key, value)\n    }\n  }\n  class DslMethodsCollectorVisitor extends GAstVisitor {\n    constructor() {\n      super(...arguments)\n      this.dslMethods = {\n        option: [],\n        alternation: [],\n        repetition: [],\n        repetitionWithSeparator: [],\n        repetitionMandatory: [],\n        repetitionMandatoryWithSeparator: [],\n      }\n    }\n    reset() {\n      this.dslMethods = {\n        option: [],\n        alternation: [],\n        repetition: [],\n        repetitionWithSeparator: [],\n        repetitionMandatory: [],\n        repetitionMandatoryWithSeparator: [],\n      }\n    }\n    visitOption(option) {\n      this.dslMethods.option.push(option)\n    }\n    visitRepetitionWithSeparator(manySep) {\n      this.dslMethods.repetitionWithSeparator.push(manySep)\n    }\n    visitRepetitionMandatory(atLeastOne) {\n      this.dslMethods.repetitionMandatory.push(atLeastOne)\n    }\n    visitRepetitionMandatoryWithSeparator(atLeastOneSep) {\n      this.dslMethods.repetitionMandatoryWithSeparator.push(atLeastOneSep)\n    }\n    visitRepetition(many) {\n      this.dslMethods.repetition.push(many)\n    }\n    visitAlternation(or) {\n      this.dslMethods.alternation.push(or)\n    }\n  }\n  const collectorVisitor = new DslMethodsCollectorVisitor()\n  function collectMethods(rule) {\n    collectorVisitor.reset()\n    rule.accept(collectorVisitor)\n    const dslMethods = collectorVisitor.dslMethods\n    // avoid uncleaned references\n    collectorVisitor.reset()\n    return dslMethods\n  }\n\n  /**\n   * This nodeLocation tracking is not efficient and should only be used\n   * when error recovery is enabled or the Token Vector contains virtual Tokens\n   * (e.g, Python Indent/Outdent)\n   * As it executes the calculation for every single terminal/nonTerminal\n   * and does not rely on the fact the token vector is **sorted**\n   */\n  function setNodeLocationOnlyOffset(currNodeLocation, newLocationInfo) {\n    // First (valid) update for this cst node\n    if (isNaN(currNodeLocation.startOffset) === true) {\n      // assumption1: Token location information is either NaN or a valid number\n      // assumption2: Token location information is fully valid if it exist\n      // (both start/end offsets exist and are numbers).\n      currNodeLocation.startOffset = newLocationInfo.startOffset\n      currNodeLocation.endOffset = newLocationInfo.endOffset\n    }\n    // Once the startOffset has been updated with a valid number it should never receive\n    // any farther updates as the Token vector is sorted.\n    // We still have to check this this condition for every new possible location info\n    // because with error recovery enabled we may encounter invalid tokens (NaN location props)\n    else if (currNodeLocation.endOffset < newLocationInfo.endOffset === true) {\n      currNodeLocation.endOffset = newLocationInfo.endOffset\n    }\n  }\n  /**\n   * This nodeLocation tracking is not efficient and should only be used\n   * when error recovery is enabled or the Token Vector contains virtual Tokens\n   * (e.g, Python Indent/Outdent)\n   * As it executes the calculation for every single terminal/nonTerminal\n   * and does not rely on the fact the token vector is **sorted**\n   */\n  function setNodeLocationFull(currNodeLocation, newLocationInfo) {\n    // First (valid) update for this cst node\n    if (isNaN(currNodeLocation.startOffset) === true) {\n      // assumption1: Token location information is either NaN or a valid number\n      // assumption2: Token location information is fully valid if it exist\n      // (all start/end props exist and are numbers).\n      currNodeLocation.startOffset = newLocationInfo.startOffset\n      currNodeLocation.startColumn = newLocationInfo.startColumn\n      currNodeLocation.startLine = newLocationInfo.startLine\n      currNodeLocation.endOffset = newLocationInfo.endOffset\n      currNodeLocation.endColumn = newLocationInfo.endColumn\n      currNodeLocation.endLine = newLocationInfo.endLine\n    }\n    // Once the start props has been updated with a valid number it should never receive\n    // any farther updates as the Token vector is sorted.\n    // We still have to check this this condition for every new possible location info\n    // because with error recovery enabled we may encounter invalid tokens (NaN location props)\n    else if (currNodeLocation.endOffset < newLocationInfo.endOffset === true) {\n      currNodeLocation.endOffset = newLocationInfo.endOffset\n      currNodeLocation.endColumn = newLocationInfo.endColumn\n      currNodeLocation.endLine = newLocationInfo.endLine\n    }\n  }\n  function addTerminalToCst(node, token, tokenTypeName) {\n    if (node.children[tokenTypeName] === undefined) {\n      node.children[tokenTypeName] = [token]\n    } else {\n      node.children[tokenTypeName].push(token)\n    }\n  }\n  function addNoneTerminalToCst(node, ruleName, ruleResult) {\n    if (node.children[ruleName] === undefined) {\n      node.children[ruleName] = [ruleResult]\n    } else {\n      node.children[ruleName].push(ruleResult)\n    }\n  }\n\n  const NAME = 'name'\n  function defineNameProp(obj, nameValue) {\n    Object.defineProperty(obj, NAME, {\n      enumerable: false,\n      configurable: true,\n      writable: false,\n      value: nameValue,\n    })\n  }\n\n  function defaultVisit(ctx, param) {\n    const childrenNames = keys(ctx)\n    const childrenNamesLength = childrenNames.length\n    for (let i = 0; i < childrenNamesLength; i++) {\n      const currChildName = childrenNames[i]\n      const currChildArray = ctx[currChildName]\n      const currChildArrayLength = currChildArray.length\n      for (let j = 0; j < currChildArrayLength; j++) {\n        const currChild = currChildArray[j]\n        // distinction between Tokens Children and CstNode children\n        if (currChild.tokenTypeIdx === undefined) {\n          this[currChild.name](currChild.children, param)\n        }\n      }\n    }\n    // defaultVisit does not support generic out param\n  }\n  function createBaseSemanticVisitorConstructor(grammarName, ruleNames) {\n    const derivedConstructor = function () {}\n    // can be overwritten according to:\n    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/\n    // name?redirectlocale=en-US&redirectslug=JavaScript%2FReference%2FGlobal_Objects%2FFunction%2Fname\n    defineNameProp(derivedConstructor, grammarName + 'BaseSemantics')\n    const semanticProto = {\n      visit: function (cstNode, param) {\n        // enables writing more concise visitor methods when CstNode has only a single child\n        if (isArray$1(cstNode)) {\n          // A CST Node's children dictionary can never have empty arrays as values\n          // If a key is defined there will be at least one element in the corresponding value array.\n          cstNode = cstNode[0]\n        }\n        // enables passing optional CstNodes concisely.\n        if (isUndefined(cstNode)) {\n          return undefined\n        }\n        return this[cstNode.name](cstNode.children, param)\n      },\n      validateVisitor: function () {\n        const semanticDefinitionErrors = validateVisitor(this, ruleNames)\n        if (!isEmpty(semanticDefinitionErrors)) {\n          const errorMessages = map(semanticDefinitionErrors, (currDefError) => currDefError.msg)\n          throw Error(\n            `Errors Detected in CST Visitor <${this.constructor.name}>:\\n\\t` +\n              `${errorMessages.join('\\n\\n').replace(/\\n/g, '\\n\\t')}`,\n          )\n        }\n      },\n    }\n    derivedConstructor.prototype = semanticProto\n    derivedConstructor.prototype.constructor = derivedConstructor\n    derivedConstructor._RULE_NAMES = ruleNames\n    return derivedConstructor\n  }\n  function createBaseVisitorConstructorWithDefaults(grammarName, ruleNames, baseConstructor) {\n    const derivedConstructor = function () {}\n    // can be overwritten according to:\n    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/\n    // name?redirectlocale=en-US&redirectslug=JavaScript%2FReference%2FGlobal_Objects%2FFunction%2Fname\n    defineNameProp(derivedConstructor, grammarName + 'BaseSemanticsWithDefaults')\n    const withDefaultsProto = Object.create(baseConstructor.prototype)\n    forEach(ruleNames, (ruleName) => {\n      withDefaultsProto[ruleName] = defaultVisit\n    })\n    derivedConstructor.prototype = withDefaultsProto\n    derivedConstructor.prototype.constructor = derivedConstructor\n    return derivedConstructor\n  }\n  var CstVisitorDefinitionError\n  ;(function (CstVisitorDefinitionError) {\n    CstVisitorDefinitionError[(CstVisitorDefinitionError['REDUNDANT_METHOD'] = 0)] = 'REDUNDANT_METHOD'\n    CstVisitorDefinitionError[(CstVisitorDefinitionError['MISSING_METHOD'] = 1)] = 'MISSING_METHOD'\n  })(CstVisitorDefinitionError || (CstVisitorDefinitionError = {}))\n  function validateVisitor(visitorInstance, ruleNames) {\n    const missingErrors = validateMissingCstMethods(visitorInstance, ruleNames)\n    return missingErrors\n  }\n  function validateMissingCstMethods(visitorInstance, ruleNames) {\n    const missingRuleNames = filter(ruleNames, (currRuleName) => {\n      return isFunction(visitorInstance[currRuleName]) === false\n    })\n    const errors = map(missingRuleNames, (currRuleName) => {\n      return {\n        msg: `Missing visitor method: <${currRuleName}> on ${visitorInstance.constructor.name} CST Visitor.`,\n        type: CstVisitorDefinitionError.MISSING_METHOD,\n        methodName: currRuleName,\n      }\n    })\n    return compact(errors)\n  }\n\n  /**\n   * This trait is responsible for the CST building logic.\n   */\n  class TreeBuilder {\n    initTreeBuilder(config) {\n      this.CST_STACK = []\n      // outputCst is no longer exposed/defined in the pubic API\n      this.outputCst = config.outputCst\n      this.nodeLocationTracking = has(config, 'nodeLocationTracking')\n        ? config.nodeLocationTracking // assumes end user provides the correct config value/type\n        : DEFAULT_PARSER_CONFIG.nodeLocationTracking\n      if (!this.outputCst) {\n        this.cstInvocationStateUpdate = noop\n        this.cstFinallyStateUpdate = noop\n        this.cstPostTerminal = noop\n        this.cstPostNonTerminal = noop\n        this.cstPostRule = noop\n      } else {\n        if (/full/i.test(this.nodeLocationTracking)) {\n          if (this.recoveryEnabled) {\n            this.setNodeLocationFromToken = setNodeLocationFull\n            this.setNodeLocationFromNode = setNodeLocationFull\n            this.cstPostRule = noop\n            this.setInitialNodeLocation = this.setInitialNodeLocationFullRecovery\n          } else {\n            this.setNodeLocationFromToken = noop\n            this.setNodeLocationFromNode = noop\n            this.cstPostRule = this.cstPostRuleFull\n            this.setInitialNodeLocation = this.setInitialNodeLocationFullRegular\n          }\n        } else if (/onlyOffset/i.test(this.nodeLocationTracking)) {\n          if (this.recoveryEnabled) {\n            this.setNodeLocationFromToken = setNodeLocationOnlyOffset\n            this.setNodeLocationFromNode = setNodeLocationOnlyOffset\n            this.cstPostRule = noop\n            this.setInitialNodeLocation = this.setInitialNodeLocationOnlyOffsetRecovery\n          } else {\n            this.setNodeLocationFromToken = noop\n            this.setNodeLocationFromNode = noop\n            this.cstPostRule = this.cstPostRuleOnlyOffset\n            this.setInitialNodeLocation = this.setInitialNodeLocationOnlyOffsetRegular\n          }\n        } else if (/none/i.test(this.nodeLocationTracking)) {\n          this.setNodeLocationFromToken = noop\n          this.setNodeLocationFromNode = noop\n          this.cstPostRule = noop\n          this.setInitialNodeLocation = noop\n        } else {\n          throw Error(`Invalid <nodeLocationTracking> config option: \"${config.nodeLocationTracking}\"`)\n        }\n      }\n    }\n    setInitialNodeLocationOnlyOffsetRecovery(cstNode) {\n      cstNode.location = {\n        startOffset: NaN,\n        endOffset: NaN,\n      }\n    }\n    setInitialNodeLocationOnlyOffsetRegular(cstNode) {\n      cstNode.location = {\n        // without error recovery the starting Location of a new CstNode is guaranteed\n        // To be the next Token's startOffset (for valid inputs).\n        // For invalid inputs there won't be any CSTOutput so this potential\n        // inaccuracy does not matter\n        startOffset: this.LA(1).startOffset,\n        endOffset: NaN,\n      }\n    }\n    setInitialNodeLocationFullRecovery(cstNode) {\n      cstNode.location = {\n        startOffset: NaN,\n        startLine: NaN,\n        startColumn: NaN,\n        endOffset: NaN,\n        endLine: NaN,\n        endColumn: NaN,\n      }\n    }\n    /**\n       *  @see setInitialNodeLocationOnlyOffsetRegular for explanation why this work\n  \n       * @param cstNode\n       */\n    setInitialNodeLocationFullRegular(cstNode) {\n      const nextToken = this.LA(1)\n      cstNode.location = {\n        startOffset: nextToken.startOffset,\n        startLine: nextToken.startLine,\n        startColumn: nextToken.startColumn,\n        endOffset: NaN,\n        endLine: NaN,\n        endColumn: NaN,\n      }\n    }\n    cstInvocationStateUpdate(fullRuleName) {\n      const cstNode = {\n        name: fullRuleName,\n        children: Object.create(null),\n      }\n      this.setInitialNodeLocation(cstNode)\n      this.CST_STACK.push(cstNode)\n    }\n    cstFinallyStateUpdate() {\n      this.CST_STACK.pop()\n    }\n    cstPostRuleFull(ruleCstNode) {\n      // casts to `required<CstNodeLocation>` are safe because `cstPostRuleFull` should only be invoked when full location is enabled\n      const prevToken = this.LA(0)\n      const loc = ruleCstNode.location\n      // If this condition is true it means we consumed at least one Token\n      // In this CstNode.\n      if (loc.startOffset <= prevToken.startOffset === true) {\n        loc.endOffset = prevToken.endOffset\n        loc.endLine = prevToken.endLine\n        loc.endColumn = prevToken.endColumn\n      }\n      // \"empty\" CstNode edge case\n      else {\n        loc.startOffset = NaN\n        loc.startLine = NaN\n        loc.startColumn = NaN\n      }\n    }\n    cstPostRuleOnlyOffset(ruleCstNode) {\n      const prevToken = this.LA(0)\n      // `location' is not null because `cstPostRuleOnlyOffset` will only be invoked when location tracking is enabled.\n      const loc = ruleCstNode.location\n      // If this condition is true it means we consumed at least one Token\n      // In this CstNode.\n      if (loc.startOffset <= prevToken.startOffset === true) {\n        loc.endOffset = prevToken.endOffset\n      }\n      // \"empty\" CstNode edge case\n      else {\n        loc.startOffset = NaN\n      }\n    }\n    cstPostTerminal(key, consumedToken) {\n      const rootCst = this.CST_STACK[this.CST_STACK.length - 1]\n      addTerminalToCst(rootCst, consumedToken, key)\n      // This is only used when **both** error recovery and CST Output are enabled.\n      this.setNodeLocationFromToken(rootCst.location, consumedToken)\n    }\n    cstPostNonTerminal(ruleCstResult, ruleName) {\n      const preCstNode = this.CST_STACK[this.CST_STACK.length - 1]\n      addNoneTerminalToCst(preCstNode, ruleName, ruleCstResult)\n      // This is only used when **both** error recovery and CST Output are enabled.\n      this.setNodeLocationFromNode(preCstNode.location, ruleCstResult.location)\n    }\n    getBaseCstVisitorConstructor() {\n      if (isUndefined(this.baseCstVisitorConstructor)) {\n        const newBaseCstVisitorConstructor = createBaseSemanticVisitorConstructor(\n          this.className,\n          keys(this.gastProductionsCache),\n        )\n        this.baseCstVisitorConstructor = newBaseCstVisitorConstructor\n        return newBaseCstVisitorConstructor\n      }\n      return this.baseCstVisitorConstructor\n    }\n    getBaseCstVisitorConstructorWithDefaults() {\n      if (isUndefined(this.baseCstVisitorWithDefaultsConstructor)) {\n        const newConstructor = createBaseVisitorConstructorWithDefaults(\n          this.className,\n          keys(this.gastProductionsCache),\n          this.getBaseCstVisitorConstructor(),\n        )\n        this.baseCstVisitorWithDefaultsConstructor = newConstructor\n        return newConstructor\n      }\n      return this.baseCstVisitorWithDefaultsConstructor\n    }\n    getLastExplicitRuleShortName() {\n      const ruleStack = this.RULE_STACK\n      return ruleStack[ruleStack.length - 1]\n    }\n    getPreviousExplicitRuleShortName() {\n      const ruleStack = this.RULE_STACK\n      return ruleStack[ruleStack.length - 2]\n    }\n    getLastExplicitRuleOccurrenceIndex() {\n      const occurrenceStack = this.RULE_OCCURRENCE_STACK\n      return occurrenceStack[occurrenceStack.length - 1]\n    }\n  }\n\n  /**\n   * Trait responsible abstracting over the interaction with Lexer output (Token vector).\n   *\n   * This could be generalized to support other kinds of lexers, e.g.\n   * - Just in Time Lexing / Lexer-Less parsing.\n   * - Streaming Lexer.\n   */\n  class LexerAdapter {\n    initLexerAdapter() {\n      this.tokVector = []\n      this.tokVectorLength = 0\n      this.currIdx = -1\n    }\n    set input(newInput) {\n      // @ts-ignore - `this parameter` not supported in setters/getters\n      //   - https://www.typescriptlang.org/docs/handbook/functions.html#this-parameters\n      if (this.selfAnalysisDone !== true) {\n        throw Error(`Missing <performSelfAnalysis> invocation at the end of the Parser's constructor.`)\n      }\n      // @ts-ignore - `this parameter` not supported in setters/getters\n      //   - https://www.typescriptlang.org/docs/handbook/functions.html#this-parameters\n      this.reset()\n      this.tokVector = newInput\n      this.tokVectorLength = newInput.length\n    }\n    get input() {\n      return this.tokVector\n    }\n    // skips a token and returns the next token\n    SKIP_TOKEN() {\n      if (this.currIdx <= this.tokVector.length - 2) {\n        this.consumeToken()\n        return this.LA(1)\n      } else {\n        return END_OF_FILE\n      }\n    }\n    // Lexer (accessing Token vector) related methods which can be overridden to implement lazy lexers\n    // or lexers dependent on parser context.\n    LA(howMuch) {\n      const soughtIdx = this.currIdx + howMuch\n      if (soughtIdx < 0 || this.tokVectorLength <= soughtIdx) {\n        return END_OF_FILE\n      } else {\n        return this.tokVector[soughtIdx]\n      }\n    }\n    consumeToken() {\n      this.currIdx++\n    }\n    exportLexerState() {\n      return this.currIdx\n    }\n    importLexerState(newState) {\n      this.currIdx = newState\n    }\n    resetLexerState() {\n      this.currIdx = -1\n    }\n    moveToTerminatedState() {\n      this.currIdx = this.tokVector.length - 1\n    }\n    getLexerPosition() {\n      return this.exportLexerState()\n    }\n  }\n\n  /**\n   * This trait is responsible for implementing the public API\n   * for defining Chevrotain parsers, i.e:\n   * - CONSUME\n   * - RULE\n   * - OPTION\n   * - ...\n   */\n  class RecognizerApi {\n    ACTION(impl) {\n      return impl.call(this)\n    }\n    consume(idx, tokType, options) {\n      return this.consumeInternal(tokType, idx, options)\n    }\n    subrule(idx, ruleToCall, options) {\n      return this.subruleInternal(ruleToCall, idx, options)\n    }\n    option(idx, actionORMethodDef) {\n      return this.optionInternal(actionORMethodDef, idx)\n    }\n    or(idx, altsOrOpts) {\n      return this.orInternal(altsOrOpts, idx)\n    }\n    many(idx, actionORMethodDef) {\n      return this.manyInternal(idx, actionORMethodDef)\n    }\n    atLeastOne(idx, actionORMethodDef) {\n      return this.atLeastOneInternal(idx, actionORMethodDef)\n    }\n    CONSUME(tokType, options) {\n      return this.consumeInternal(tokType, 0, options)\n    }\n    CONSUME1(tokType, options) {\n      return this.consumeInternal(tokType, 1, options)\n    }\n    CONSUME2(tokType, options) {\n      return this.consumeInternal(tokType, 2, options)\n    }\n    CONSUME3(tokType, options) {\n      return this.consumeInternal(tokType, 3, options)\n    }\n    CONSUME4(tokType, options) {\n      return this.consumeInternal(tokType, 4, options)\n    }\n    CONSUME5(tokType, options) {\n      return this.consumeInternal(tokType, 5, options)\n    }\n    CONSUME6(tokType, options) {\n      return this.consumeInternal(tokType, 6, options)\n    }\n    CONSUME7(tokType, options) {\n      return this.consumeInternal(tokType, 7, options)\n    }\n    CONSUME8(tokType, options) {\n      return this.consumeInternal(tokType, 8, options)\n    }\n    CONSUME9(tokType, options) {\n      return this.consumeInternal(tokType, 9, options)\n    }\n    SUBRULE(ruleToCall, options) {\n      return this.subruleInternal(ruleToCall, 0, options)\n    }\n    SUBRULE1(ruleToCall, options) {\n      return this.subruleInternal(ruleToCall, 1, options)\n    }\n    SUBRULE2(ruleToCall, options) {\n      return this.subruleInternal(ruleToCall, 2, options)\n    }\n    SUBRULE3(ruleToCall, options) {\n      return this.subruleInternal(ruleToCall, 3, options)\n    }\n    SUBRULE4(ruleToCall, options) {\n      return this.subruleInternal(ruleToCall, 4, options)\n    }\n    SUBRULE5(ruleToCall, options) {\n      return this.subruleInternal(ruleToCall, 5, options)\n    }\n    SUBRULE6(ruleToCall, options) {\n      return this.subruleInternal(ruleToCall, 6, options)\n    }\n    SUBRULE7(ruleToCall, options) {\n      return this.subruleInternal(ruleToCall, 7, options)\n    }\n    SUBRULE8(ruleToCall, options) {\n      return this.subruleInternal(ruleToCall, 8, options)\n    }\n    SUBRULE9(ruleToCall, options) {\n      return this.subruleInternal(ruleToCall, 9, options)\n    }\n    OPTION(actionORMethodDef) {\n      return this.optionInternal(actionORMethodDef, 0)\n    }\n    OPTION1(actionORMethodDef) {\n      return this.optionInternal(actionORMethodDef, 1)\n    }\n    OPTION2(actionORMethodDef) {\n      return this.optionInternal(actionORMethodDef, 2)\n    }\n    OPTION3(actionORMethodDef) {\n      return this.optionInternal(actionORMethodDef, 3)\n    }\n    OPTION4(actionORMethodDef) {\n      return this.optionInternal(actionORMethodDef, 4)\n    }\n    OPTION5(actionORMethodDef) {\n      return this.optionInternal(actionORMethodDef, 5)\n    }\n    OPTION6(actionORMethodDef) {\n      return this.optionInternal(actionORMethodDef, 6)\n    }\n    OPTION7(actionORMethodDef) {\n      return this.optionInternal(actionORMethodDef, 7)\n    }\n    OPTION8(actionORMethodDef) {\n      return this.optionInternal(actionORMethodDef, 8)\n    }\n    OPTION9(actionORMethodDef) {\n      return this.optionInternal(actionORMethodDef, 9)\n    }\n    OR(altsOrOpts) {\n      return this.orInternal(altsOrOpts, 0)\n    }\n    OR1(altsOrOpts) {\n      return this.orInternal(altsOrOpts, 1)\n    }\n    OR2(altsOrOpts) {\n      return this.orInternal(altsOrOpts, 2)\n    }\n    OR3(altsOrOpts) {\n      return this.orInternal(altsOrOpts, 3)\n    }\n    OR4(altsOrOpts) {\n      return this.orInternal(altsOrOpts, 4)\n    }\n    OR5(altsOrOpts) {\n      return this.orInternal(altsOrOpts, 5)\n    }\n    OR6(altsOrOpts) {\n      return this.orInternal(altsOrOpts, 6)\n    }\n    OR7(altsOrOpts) {\n      return this.orInternal(altsOrOpts, 7)\n    }\n    OR8(altsOrOpts) {\n      return this.orInternal(altsOrOpts, 8)\n    }\n    OR9(altsOrOpts) {\n      return this.orInternal(altsOrOpts, 9)\n    }\n    MANY(actionORMethodDef) {\n      this.manyInternal(0, actionORMethodDef)\n    }\n    MANY1(actionORMethodDef) {\n      this.manyInternal(1, actionORMethodDef)\n    }\n    MANY2(actionORMethodDef) {\n      this.manyInternal(2, actionORMethodDef)\n    }\n    MANY3(actionORMethodDef) {\n      this.manyInternal(3, actionORMethodDef)\n    }\n    MANY4(actionORMethodDef) {\n      this.manyInternal(4, actionORMethodDef)\n    }\n    MANY5(actionORMethodDef) {\n      this.manyInternal(5, actionORMethodDef)\n    }\n    MANY6(actionORMethodDef) {\n      this.manyInternal(6, actionORMethodDef)\n    }\n    MANY7(actionORMethodDef) {\n      this.manyInternal(7, actionORMethodDef)\n    }\n    MANY8(actionORMethodDef) {\n      this.manyInternal(8, actionORMethodDef)\n    }\n    MANY9(actionORMethodDef) {\n      this.manyInternal(9, actionORMethodDef)\n    }\n    MANY_SEP(options) {\n      this.manySepFirstInternal(0, options)\n    }\n    MANY_SEP1(options) {\n      this.manySepFirstInternal(1, options)\n    }\n    MANY_SEP2(options) {\n      this.manySepFirstInternal(2, options)\n    }\n    MANY_SEP3(options) {\n      this.manySepFirstInternal(3, options)\n    }\n    MANY_SEP4(options) {\n      this.manySepFirstInternal(4, options)\n    }\n    MANY_SEP5(options) {\n      this.manySepFirstInternal(5, options)\n    }\n    MANY_SEP6(options) {\n      this.manySepFirstInternal(6, options)\n    }\n    MANY_SEP7(options) {\n      this.manySepFirstInternal(7, options)\n    }\n    MANY_SEP8(options) {\n      this.manySepFirstInternal(8, options)\n    }\n    MANY_SEP9(options) {\n      this.manySepFirstInternal(9, options)\n    }\n    AT_LEAST_ONE(actionORMethodDef) {\n      this.atLeastOneInternal(0, actionORMethodDef)\n    }\n    AT_LEAST_ONE1(actionORMethodDef) {\n      return this.atLeastOneInternal(1, actionORMethodDef)\n    }\n    AT_LEAST_ONE2(actionORMethodDef) {\n      this.atLeastOneInternal(2, actionORMethodDef)\n    }\n    AT_LEAST_ONE3(actionORMethodDef) {\n      this.atLeastOneInternal(3, actionORMethodDef)\n    }\n    AT_LEAST_ONE4(actionORMethodDef) {\n      this.atLeastOneInternal(4, actionORMethodDef)\n    }\n    AT_LEAST_ONE5(actionORMethodDef) {\n      this.atLeastOneInternal(5, actionORMethodDef)\n    }\n    AT_LEAST_ONE6(actionORMethodDef) {\n      this.atLeastOneInternal(6, actionORMethodDef)\n    }\n    AT_LEAST_ONE7(actionORMethodDef) {\n      this.atLeastOneInternal(7, actionORMethodDef)\n    }\n    AT_LEAST_ONE8(actionORMethodDef) {\n      this.atLeastOneInternal(8, actionORMethodDef)\n    }\n    AT_LEAST_ONE9(actionORMethodDef) {\n      this.atLeastOneInternal(9, actionORMethodDef)\n    }\n    AT_LEAST_ONE_SEP(options) {\n      this.atLeastOneSepFirstInternal(0, options)\n    }\n    AT_LEAST_ONE_SEP1(options) {\n      this.atLeastOneSepFirstInternal(1, options)\n    }\n    AT_LEAST_ONE_SEP2(options) {\n      this.atLeastOneSepFirstInternal(2, options)\n    }\n    AT_LEAST_ONE_SEP3(options) {\n      this.atLeastOneSepFirstInternal(3, options)\n    }\n    AT_LEAST_ONE_SEP4(options) {\n      this.atLeastOneSepFirstInternal(4, options)\n    }\n    AT_LEAST_ONE_SEP5(options) {\n      this.atLeastOneSepFirstInternal(5, options)\n    }\n    AT_LEAST_ONE_SEP6(options) {\n      this.atLeastOneSepFirstInternal(6, options)\n    }\n    AT_LEAST_ONE_SEP7(options) {\n      this.atLeastOneSepFirstInternal(7, options)\n    }\n    AT_LEAST_ONE_SEP8(options) {\n      this.atLeastOneSepFirstInternal(8, options)\n    }\n    AT_LEAST_ONE_SEP9(options) {\n      this.atLeastOneSepFirstInternal(9, options)\n    }\n    RULE(name, implementation, config = DEFAULT_RULE_CONFIG) {\n      if (includes(this.definedRulesNames, name)) {\n        const errMsg = defaultGrammarValidatorErrorProvider.buildDuplicateRuleNameError({\n          topLevelRule: name,\n          grammarName: this.className,\n        })\n        const error = {\n          message: errMsg,\n          type: ParserDefinitionErrorType.DUPLICATE_RULE_NAME,\n          ruleName: name,\n        }\n        this.definitionErrors.push(error)\n      }\n      this.definedRulesNames.push(name)\n      const ruleImplementation = this.defineRule(name, implementation, config)\n      this[name] = ruleImplementation\n      return ruleImplementation\n    }\n    OVERRIDE_RULE(name, impl, config = DEFAULT_RULE_CONFIG) {\n      const ruleErrors = validateRuleIsOverridden(name, this.definedRulesNames, this.className)\n      this.definitionErrors = this.definitionErrors.concat(ruleErrors)\n      const ruleImplementation = this.defineRule(name, impl, config)\n      this[name] = ruleImplementation\n      return ruleImplementation\n    }\n    BACKTRACK(grammarRule, args) {\n      return function () {\n        // save org state\n        this.isBackTrackingStack.push(1)\n        const orgState = this.saveRecogState()\n        try {\n          grammarRule.apply(this, args)\n          // if no exception was thrown we have succeed parsing the rule.\n          return true\n        } catch (e) {\n          if (isRecognitionException(e)) {\n            return false\n          } else {\n            throw e\n          }\n        } finally {\n          this.reloadRecogState(orgState)\n          this.isBackTrackingStack.pop()\n        }\n      }\n    }\n    // GAST export APIs\n    getGAstProductions() {\n      return this.gastProductionsCache\n    }\n    getSerializedGastProductions() {\n      return serializeGrammar(values(this.gastProductionsCache))\n    }\n  }\n\n  /**\n   * This trait is responsible for the runtime parsing engine\n   * Used by the official API (recognizer_api.ts)\n   */\n  class RecognizerEngine {\n    initRecognizerEngine(tokenVocabulary, config) {\n      this.className = this.constructor.name\n      // TODO: would using an ES6 Map or plain object be faster (CST building scenario)\n      this.shortRuleNameToFull = {}\n      this.fullRuleNameToShort = {}\n      this.ruleShortNameIdx = 256\n      this.tokenMatcher = tokenStructuredMatcherNoCategories\n      this.subruleIdx = 0\n      this.definedRulesNames = []\n      this.tokensMap = {}\n      this.isBackTrackingStack = []\n      this.RULE_STACK = []\n      this.RULE_OCCURRENCE_STACK = []\n      this.gastProductionsCache = {}\n      if (has(config, 'serializedGrammar')) {\n        throw Error(\n          \"The Parser's configuration can no longer contain a <serializedGrammar> property.\\n\" +\n            '\\tSee: https://chevrotain.io/docs/changes/BREAKING_CHANGES.html#_6-0-0\\n' +\n            '\\tFor Further details.',\n        )\n      }\n      if (isArray$1(tokenVocabulary)) {\n        // This only checks for Token vocabularies provided as arrays.\n        // That is good enough because the main objective is to detect users of pre-V4.0 APIs\n        // rather than all edge cases of empty Token vocabularies.\n        if (isEmpty(tokenVocabulary)) {\n          throw Error(\n            'A Token Vocabulary cannot be empty.\\n' +\n              '\\tNote that the first argument for the parser constructor\\n' +\n              '\\tis no longer a Token vector (since v4.0).',\n          )\n        }\n        if (typeof tokenVocabulary[0].startOffset === 'number') {\n          throw Error(\n            'The Parser constructor no longer accepts a token vector as the first argument.\\n' +\n              '\\tSee: https://chevrotain.io/docs/changes/BREAKING_CHANGES.html#_4-0-0\\n' +\n              '\\tFor Further details.',\n          )\n        }\n      }\n      if (isArray$1(tokenVocabulary)) {\n        this.tokensMap = reduce(\n          tokenVocabulary,\n          (acc, tokType) => {\n            acc[tokType.name] = tokType\n            return acc\n          },\n          {},\n        )\n      } else if (has(tokenVocabulary, 'modes') && every(flatten(values(tokenVocabulary.modes)), isTokenType)) {\n        const allTokenTypes = flatten(values(tokenVocabulary.modes))\n        const uniqueTokens = uniq(allTokenTypes)\n        this.tokensMap = reduce(\n          uniqueTokens,\n          (acc, tokType) => {\n            acc[tokType.name] = tokType\n            return acc\n          },\n          {},\n        )\n      } else if (isObject(tokenVocabulary)) {\n        this.tokensMap = clone(tokenVocabulary)\n      } else {\n        throw new Error(\n          '<tokensDictionary> argument must be An Array of Token constructors,' +\n            ' A dictionary of Token constructors or an IMultiModeLexerDefinition',\n        )\n      }\n      // always add EOF to the tokenNames -> constructors map. it is useful to assure all the input has been\n      // parsed with a clear error message (\"expecting EOF but found ...\")\n      this.tokensMap['EOF'] = EOF\n      const allTokenTypes = has(tokenVocabulary, 'modes')\n        ? flatten(values(tokenVocabulary.modes))\n        : values(tokenVocabulary)\n      const noTokenCategoriesUsed = every(allTokenTypes, (tokenConstructor) =>\n        isEmpty(tokenConstructor.categoryMatches),\n      )\n      this.tokenMatcher = noTokenCategoriesUsed ? tokenStructuredMatcherNoCategories : tokenStructuredMatcher\n      // Because ES2015+ syntax should be supported for creating Token classes\n      // We cannot assume that the Token classes were created using the \"extendToken\" utilities\n      // Therefore we must augment the Token classes both on Lexer initialization and on Parser initialization\n      augmentTokenTypes(values(this.tokensMap))\n    }\n    defineRule(ruleName, impl, config) {\n      if (this.selfAnalysisDone) {\n        throw Error(\n          `Grammar rule <${ruleName}> may not be defined after the 'performSelfAnalysis' method has been called'\\n` +\n            `Make sure that all grammar rule definitions are done before 'performSelfAnalysis' is called.`,\n        )\n      }\n      const resyncEnabled = has(config, 'resyncEnabled')\n        ? config.resyncEnabled // assumes end user provides the correct config value/type\n        : DEFAULT_RULE_CONFIG.resyncEnabled\n      const recoveryValueFunc = has(config, 'recoveryValueFunc')\n        ? config.recoveryValueFunc // assumes end user provides the correct config value/type\n        : DEFAULT_RULE_CONFIG.recoveryValueFunc\n      // performance optimization: Use small integers as keys for the longer human readable \"full\" rule names.\n      // this greatly improves Map access time (as much as 8% for some performance benchmarks).\n      const shortName = this.ruleShortNameIdx << (BITS_FOR_METHOD_TYPE + BITS_FOR_OCCURRENCE_IDX)\n      this.ruleShortNameIdx++\n      this.shortRuleNameToFull[shortName] = ruleName\n      this.fullRuleNameToShort[ruleName] = shortName\n      let invokeRuleWithTry\n      // Micro optimization, only check the condition **once** on rule definition\n      // instead of **every single** rule invocation.\n      if (this.outputCst === true) {\n        invokeRuleWithTry = function invokeRuleWithTry(...args) {\n          try {\n            this.ruleInvocationStateUpdate(shortName, ruleName, this.subruleIdx)\n            impl.apply(this, args)\n            const cst = this.CST_STACK[this.CST_STACK.length - 1]\n            this.cstPostRule(cst)\n            return cst\n          } catch (e) {\n            return this.invokeRuleCatch(e, resyncEnabled, recoveryValueFunc)\n          } finally {\n            this.ruleFinallyStateUpdate()\n          }\n        }\n      } else {\n        invokeRuleWithTry = function invokeRuleWithTryCst(...args) {\n          try {\n            this.ruleInvocationStateUpdate(shortName, ruleName, this.subruleIdx)\n            return impl.apply(this, args)\n          } catch (e) {\n            return this.invokeRuleCatch(e, resyncEnabled, recoveryValueFunc)\n          } finally {\n            this.ruleFinallyStateUpdate()\n          }\n        }\n      }\n      const wrappedGrammarRule = Object.assign(invokeRuleWithTry, { ruleName, originalGrammarAction: impl })\n      return wrappedGrammarRule\n    }\n    invokeRuleCatch(e, resyncEnabledConfig, recoveryValueFunc) {\n      const isFirstInvokedRule = this.RULE_STACK.length === 1\n      // note the reSync is always enabled for the first rule invocation, because we must always be able to\n      // reSync with EOF and just output some INVALID ParseTree\n      // during backtracking reSync recovery is disabled, otherwise we can't be certain the backtracking\n      // path is really the most valid one\n      const reSyncEnabled = resyncEnabledConfig && !this.isBackTracking() && this.recoveryEnabled\n      if (isRecognitionException(e)) {\n        const recogError = e\n        if (reSyncEnabled) {\n          const reSyncTokType = this.findReSyncTokenType()\n          if (this.isInCurrentRuleReSyncSet(reSyncTokType)) {\n            recogError.resyncedTokens = this.reSyncTo(reSyncTokType)\n            if (this.outputCst) {\n              const partialCstResult = this.CST_STACK[this.CST_STACK.length - 1]\n              partialCstResult.recoveredNode = true\n              return partialCstResult\n            } else {\n              return recoveryValueFunc(e)\n            }\n          } else {\n            if (this.outputCst) {\n              const partialCstResult = this.CST_STACK[this.CST_STACK.length - 1]\n              partialCstResult.recoveredNode = true\n              recogError.partialCstResult = partialCstResult\n            }\n            // to be handled Further up the call stack\n            throw recogError\n          }\n        } else if (isFirstInvokedRule) {\n          // otherwise a Redundant input error will be created as well and we cannot guarantee that this is indeed the case\n          this.moveToTerminatedState()\n          // the parser should never throw one of its own errors outside its flow.\n          // even if error recovery is disabled\n          return recoveryValueFunc(e)\n        } else {\n          // to be recovered Further up the call stack\n          throw recogError\n        }\n      } else {\n        // some other Error type which we don't know how to handle (for example a built in JavaScript Error)\n        throw e\n      }\n    }\n    // Implementation of parsing DSL\n    optionInternal(actionORMethodDef, occurrence) {\n      const key = this.getKeyForAutomaticLookahead(OPTION_IDX, occurrence)\n      return this.optionInternalLogic(actionORMethodDef, occurrence, key)\n    }\n    optionInternalLogic(actionORMethodDef, occurrence, key) {\n      let lookAheadFunc = this.getLaFuncFromCache(key)\n      let action\n      if (typeof actionORMethodDef !== 'function') {\n        action = actionORMethodDef.DEF\n        const predicate = actionORMethodDef.GATE\n        // predicate present\n        if (predicate !== undefined) {\n          const orgLookaheadFunction = lookAheadFunc\n          lookAheadFunc = () => {\n            return predicate.call(this) && orgLookaheadFunction.call(this)\n          }\n        }\n      } else {\n        action = actionORMethodDef\n      }\n      if (lookAheadFunc.call(this) === true) {\n        return action.call(this)\n      }\n      return undefined\n    }\n    atLeastOneInternal(prodOccurrence, actionORMethodDef) {\n      const laKey = this.getKeyForAutomaticLookahead(AT_LEAST_ONE_IDX, prodOccurrence)\n      return this.atLeastOneInternalLogic(prodOccurrence, actionORMethodDef, laKey)\n    }\n    atLeastOneInternalLogic(prodOccurrence, actionORMethodDef, key) {\n      let lookAheadFunc = this.getLaFuncFromCache(key)\n      let action\n      if (typeof actionORMethodDef !== 'function') {\n        action = actionORMethodDef.DEF\n        const predicate = actionORMethodDef.GATE\n        // predicate present\n        if (predicate !== undefined) {\n          const orgLookaheadFunction = lookAheadFunc\n          lookAheadFunc = () => {\n            return predicate.call(this) && orgLookaheadFunction.call(this)\n          }\n        }\n      } else {\n        action = actionORMethodDef\n      }\n      if (lookAheadFunc.call(this) === true) {\n        let notStuck = this.doSingleRepetition(action)\n        while (lookAheadFunc.call(this) === true && notStuck === true) {\n          notStuck = this.doSingleRepetition(action)\n        }\n      } else {\n        throw this.raiseEarlyExitException(prodOccurrence, PROD_TYPE.REPETITION_MANDATORY, actionORMethodDef.ERR_MSG)\n      }\n      // note that while it may seem that this can cause an error because by using a recursive call to\n      // AT_LEAST_ONE we change the grammar to AT_LEAST_TWO, AT_LEAST_THREE ... , the possible recursive call\n      // from the tryInRepetitionRecovery(...) will only happen IFF there really are TWO/THREE/.... items.\n      // Performance optimization: \"attemptInRepetitionRecovery\" will be defined as NOOP unless recovery is enabled\n      this.attemptInRepetitionRecovery(\n        this.atLeastOneInternal,\n        [prodOccurrence, actionORMethodDef],\n        lookAheadFunc,\n        AT_LEAST_ONE_IDX,\n        prodOccurrence,\n        NextTerminalAfterAtLeastOneWalker,\n      )\n    }\n    atLeastOneSepFirstInternal(prodOccurrence, options) {\n      const laKey = this.getKeyForAutomaticLookahead(AT_LEAST_ONE_SEP_IDX, prodOccurrence)\n      this.atLeastOneSepFirstInternalLogic(prodOccurrence, options, laKey)\n    }\n    atLeastOneSepFirstInternalLogic(prodOccurrence, options, key) {\n      const action = options.DEF\n      const separator = options.SEP\n      const firstIterationLookaheadFunc = this.getLaFuncFromCache(key)\n      // 1st iteration\n      if (firstIterationLookaheadFunc.call(this) === true) {\n        action.call(this)\n        //  TODO: Optimization can move this function construction into \"attemptInRepetitionRecovery\"\n        //  because it is only needed in error recovery scenarios.\n        const separatorLookAheadFunc = () => {\n          return this.tokenMatcher(this.LA(1), separator)\n        }\n        // 2nd..nth iterations\n        while (this.tokenMatcher(this.LA(1), separator) === true) {\n          // note that this CONSUME will never enter recovery because\n          // the separatorLookAheadFunc checks that the separator really does exist.\n          this.CONSUME(separator)\n          // No need for checking infinite loop here due to consuming the separator.\n          action.call(this)\n        }\n        // Performance optimization: \"attemptInRepetitionRecovery\" will be defined as NOOP unless recovery is enabled\n        this.attemptInRepetitionRecovery(\n          this.repetitionSepSecondInternal,\n          [prodOccurrence, separator, separatorLookAheadFunc, action, NextTerminalAfterAtLeastOneSepWalker],\n          separatorLookAheadFunc,\n          AT_LEAST_ONE_SEP_IDX,\n          prodOccurrence,\n          NextTerminalAfterAtLeastOneSepWalker,\n        )\n      } else {\n        throw this.raiseEarlyExitException(\n          prodOccurrence,\n          PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR,\n          options.ERR_MSG,\n        )\n      }\n    }\n    manyInternal(prodOccurrence, actionORMethodDef) {\n      const laKey = this.getKeyForAutomaticLookahead(MANY_IDX, prodOccurrence)\n      return this.manyInternalLogic(prodOccurrence, actionORMethodDef, laKey)\n    }\n    manyInternalLogic(prodOccurrence, actionORMethodDef, key) {\n      let lookaheadFunction = this.getLaFuncFromCache(key)\n      let action\n      if (typeof actionORMethodDef !== 'function') {\n        action = actionORMethodDef.DEF\n        const predicate = actionORMethodDef.GATE\n        // predicate present\n        if (predicate !== undefined) {\n          const orgLookaheadFunction = lookaheadFunction\n          lookaheadFunction = () => {\n            return predicate.call(this) && orgLookaheadFunction.call(this)\n          }\n        }\n      } else {\n        action = actionORMethodDef\n      }\n      let notStuck = true\n      while (lookaheadFunction.call(this) === true && notStuck === true) {\n        notStuck = this.doSingleRepetition(action)\n      }\n      // Performance optimization: \"attemptInRepetitionRecovery\" will be defined as NOOP unless recovery is enabled\n      this.attemptInRepetitionRecovery(\n        this.manyInternal,\n        [prodOccurrence, actionORMethodDef],\n        lookaheadFunction,\n        MANY_IDX,\n        prodOccurrence,\n        NextTerminalAfterManyWalker,\n        // The notStuck parameter is only relevant when \"attemptInRepetitionRecovery\"\n        // is invoked from manyInternal, in the MANY_SEP case and AT_LEAST_ONE[_SEP]\n        // An infinite loop cannot occur as:\n        // - Either the lookahead is guaranteed to consume something (Single Token Separator)\n        // - AT_LEAST_ONE by definition is guaranteed to consume something (or error out).\n        notStuck,\n      )\n    }\n    manySepFirstInternal(prodOccurrence, options) {\n      const laKey = this.getKeyForAutomaticLookahead(MANY_SEP_IDX, prodOccurrence)\n      this.manySepFirstInternalLogic(prodOccurrence, options, laKey)\n    }\n    manySepFirstInternalLogic(prodOccurrence, options, key) {\n      const action = options.DEF\n      const separator = options.SEP\n      const firstIterationLaFunc = this.getLaFuncFromCache(key)\n      // 1st iteration\n      if (firstIterationLaFunc.call(this) === true) {\n        action.call(this)\n        const separatorLookAheadFunc = () => {\n          return this.tokenMatcher(this.LA(1), separator)\n        }\n        // 2nd..nth iterations\n        while (this.tokenMatcher(this.LA(1), separator) === true) {\n          // note that this CONSUME will never enter recovery because\n          // the separatorLookAheadFunc checks that the separator really does exist.\n          this.CONSUME(separator)\n          // No need for checking infinite loop here due to consuming the separator.\n          action.call(this)\n        }\n        // Performance optimization: \"attemptInRepetitionRecovery\" will be defined as NOOP unless recovery is enabled\n        this.attemptInRepetitionRecovery(\n          this.repetitionSepSecondInternal,\n          [prodOccurrence, separator, separatorLookAheadFunc, action, NextTerminalAfterManySepWalker],\n          separatorLookAheadFunc,\n          MANY_SEP_IDX,\n          prodOccurrence,\n          NextTerminalAfterManySepWalker,\n        )\n      }\n    }\n    repetitionSepSecondInternal(prodOccurrence, separator, separatorLookAheadFunc, action, nextTerminalAfterWalker) {\n      while (separatorLookAheadFunc()) {\n        // note that this CONSUME will never enter recovery because\n        // the separatorLookAheadFunc checks that the separator really does exist.\n        this.CONSUME(separator)\n        action.call(this)\n      }\n      // we can only arrive to this function after an error\n      // has occurred (hence the name 'second') so the following\n      // IF will always be entered, its possible to remove it...\n      // however it is kept to avoid confusion and be consistent.\n      // Performance optimization: \"attemptInRepetitionRecovery\" will be defined as NOOP unless recovery is enabled\n      /* istanbul ignore else */\n      this.attemptInRepetitionRecovery(\n        this.repetitionSepSecondInternal,\n        [prodOccurrence, separator, separatorLookAheadFunc, action, nextTerminalAfterWalker],\n        separatorLookAheadFunc,\n        AT_LEAST_ONE_SEP_IDX,\n        prodOccurrence,\n        nextTerminalAfterWalker,\n      )\n    }\n    doSingleRepetition(action) {\n      const beforeIteration = this.getLexerPosition()\n      action.call(this)\n      const afterIteration = this.getLexerPosition()\n      // This boolean will indicate if this repetition progressed\n      // or if we are \"stuck\" (potential infinite loop in the repetition).\n      return afterIteration > beforeIteration\n    }\n    orInternal(altsOrOpts, occurrence) {\n      const laKey = this.getKeyForAutomaticLookahead(OR_IDX, occurrence)\n      const alts = isArray$1(altsOrOpts) ? altsOrOpts : altsOrOpts.DEF\n      const laFunc = this.getLaFuncFromCache(laKey)\n      const altIdxToTake = laFunc.call(this, alts)\n      if (altIdxToTake !== undefined) {\n        const chosenAlternative = alts[altIdxToTake]\n        return chosenAlternative.ALT.call(this)\n      }\n      this.raiseNoAltException(occurrence, altsOrOpts.ERR_MSG)\n    }\n    ruleFinallyStateUpdate() {\n      this.RULE_STACK.pop()\n      this.RULE_OCCURRENCE_STACK.pop()\n      // NOOP when cst is disabled\n      this.cstFinallyStateUpdate()\n      if (this.RULE_STACK.length === 0 && this.isAtEndOfInput() === false) {\n        const firstRedundantTok = this.LA(1)\n        const errMsg = this.errorMessageProvider.buildNotAllInputParsedMessage({\n          firstRedundant: firstRedundantTok,\n          ruleName: this.getCurrRuleFullName(),\n        })\n        this.SAVE_ERROR(new NotAllInputParsedException(errMsg, firstRedundantTok))\n      }\n    }\n    subruleInternal(ruleToCall, idx, options) {\n      let ruleResult\n      try {\n        const args = options !== undefined ? options.ARGS : undefined\n        this.subruleIdx = idx\n        ruleResult = ruleToCall.apply(this, args)\n        this.cstPostNonTerminal(\n          ruleResult,\n          options !== undefined && options.LABEL !== undefined ? options.LABEL : ruleToCall.ruleName,\n        )\n        return ruleResult\n      } catch (e) {\n        throw this.subruleInternalError(e, options, ruleToCall.ruleName)\n      }\n    }\n    subruleInternalError(e, options, ruleName) {\n      if (isRecognitionException(e) && e.partialCstResult !== undefined) {\n        this.cstPostNonTerminal(\n          e.partialCstResult,\n          options !== undefined && options.LABEL !== undefined ? options.LABEL : ruleName,\n        )\n        delete e.partialCstResult\n      }\n      throw e\n    }\n    consumeInternal(tokType, idx, options) {\n      let consumedToken\n      try {\n        const nextToken = this.LA(1)\n        if (this.tokenMatcher(nextToken, tokType) === true) {\n          this.consumeToken()\n          consumedToken = nextToken\n        } else {\n          this.consumeInternalError(tokType, nextToken, options)\n        }\n      } catch (eFromConsumption) {\n        consumedToken = this.consumeInternalRecovery(tokType, idx, eFromConsumption)\n      }\n      this.cstPostTerminal(\n        options !== undefined && options.LABEL !== undefined ? options.LABEL : tokType.name,\n        consumedToken,\n      )\n      return consumedToken\n    }\n    consumeInternalError(tokType, nextToken, options) {\n      let msg\n      const previousToken = this.LA(0)\n      if (options !== undefined && options.ERR_MSG) {\n        msg = options.ERR_MSG\n      } else {\n        msg = this.errorMessageProvider.buildMismatchTokenMessage({\n          expected: tokType,\n          actual: nextToken,\n          previous: previousToken,\n          ruleName: this.getCurrRuleFullName(),\n        })\n      }\n      throw this.SAVE_ERROR(new MismatchedTokenException(msg, nextToken, previousToken))\n    }\n    consumeInternalRecovery(tokType, idx, eFromConsumption) {\n      // no recovery allowed during backtracking, otherwise backtracking may recover invalid syntax and accept it\n      // but the original syntax could have been parsed successfully without any backtracking + recovery\n      if (\n        this.recoveryEnabled &&\n        // TODO: more robust checking of the exception type. Perhaps Typescript extending expressions?\n        eFromConsumption.name === 'MismatchedTokenException' &&\n        !this.isBackTracking()\n      ) {\n        const follows = this.getFollowsForInRuleRecovery(tokType, idx)\n        try {\n          return this.tryInRuleRecovery(tokType, follows)\n        } catch (eFromInRuleRecovery) {\n          if (eFromInRuleRecovery.name === IN_RULE_RECOVERY_EXCEPTION) {\n            // failed in RuleRecovery.\n            // throw the original error in order to trigger reSync error recovery\n            throw eFromConsumption\n          } else {\n            throw eFromInRuleRecovery\n          }\n        }\n      } else {\n        throw eFromConsumption\n      }\n    }\n    saveRecogState() {\n      // errors is a getter which will clone the errors array\n      const savedErrors = this.errors\n      const savedRuleStack = clone(this.RULE_STACK)\n      return {\n        errors: savedErrors,\n        lexerState: this.exportLexerState(),\n        RULE_STACK: savedRuleStack,\n        CST_STACK: this.CST_STACK,\n      }\n    }\n    reloadRecogState(newState) {\n      this.errors = newState.errors\n      this.importLexerState(newState.lexerState)\n      this.RULE_STACK = newState.RULE_STACK\n    }\n    ruleInvocationStateUpdate(shortName, fullName, idxInCallingRule) {\n      this.RULE_OCCURRENCE_STACK.push(idxInCallingRule)\n      this.RULE_STACK.push(shortName)\n      // NOOP when cst is disabled\n      this.cstInvocationStateUpdate(fullName)\n    }\n    isBackTracking() {\n      return this.isBackTrackingStack.length !== 0\n    }\n    getCurrRuleFullName() {\n      const shortName = this.getLastExplicitRuleShortName()\n      return this.shortRuleNameToFull[shortName]\n    }\n    shortRuleNameToFullName(shortName) {\n      return this.shortRuleNameToFull[shortName]\n    }\n    isAtEndOfInput() {\n      return this.tokenMatcher(this.LA(1), EOF)\n    }\n    reset() {\n      this.resetLexerState()\n      this.subruleIdx = 0\n      this.isBackTrackingStack = []\n      this.errors = []\n      this.RULE_STACK = []\n      // TODO: extract a specific reset for TreeBuilder trait\n      this.CST_STACK = []\n      this.RULE_OCCURRENCE_STACK = []\n    }\n  }\n\n  /**\n   * Trait responsible for runtime parsing errors.\n   */\n  class ErrorHandler {\n    initErrorHandler(config) {\n      this._errors = []\n      this.errorMessageProvider = has(config, 'errorMessageProvider')\n        ? config.errorMessageProvider // assumes end user provides the correct config value/type\n        : DEFAULT_PARSER_CONFIG.errorMessageProvider\n    }\n    SAVE_ERROR(error) {\n      if (isRecognitionException(error)) {\n        error.context = {\n          ruleStack: this.getHumanReadableRuleStack(),\n          ruleOccurrenceStack: clone(this.RULE_OCCURRENCE_STACK),\n        }\n        this._errors.push(error)\n        return error\n      } else {\n        throw Error('Trying to save an Error which is not a RecognitionException')\n      }\n    }\n    get errors() {\n      return clone(this._errors)\n    }\n    set errors(newErrors) {\n      this._errors = newErrors\n    }\n    // TODO: consider caching the error message computed information\n    raiseEarlyExitException(occurrence, prodType, userDefinedErrMsg) {\n      const ruleName = this.getCurrRuleFullName()\n      const ruleGrammar = this.getGAstProductions()[ruleName]\n      const lookAheadPathsPerAlternative = getLookaheadPathsForOptionalProd(\n        occurrence,\n        ruleGrammar,\n        prodType,\n        this.maxLookahead,\n      )\n      const insideProdPaths = lookAheadPathsPerAlternative[0]\n      const actualTokens = []\n      for (let i = 1; i <= this.maxLookahead; i++) {\n        actualTokens.push(this.LA(i))\n      }\n      const msg = this.errorMessageProvider.buildEarlyExitMessage({\n        expectedIterationPaths: insideProdPaths,\n        actual: actualTokens,\n        previous: this.LA(0),\n        customUserDescription: userDefinedErrMsg,\n        ruleName: ruleName,\n      })\n      throw this.SAVE_ERROR(new EarlyExitException(msg, this.LA(1), this.LA(0)))\n    }\n    // TODO: consider caching the error message computed information\n    raiseNoAltException(occurrence, errMsgTypes) {\n      const ruleName = this.getCurrRuleFullName()\n      const ruleGrammar = this.getGAstProductions()[ruleName]\n      // TODO: getLookaheadPathsForOr can be slow for large enough maxLookahead and certain grammars, consider caching ?\n      const lookAheadPathsPerAlternative = getLookaheadPathsForOr(occurrence, ruleGrammar, this.maxLookahead)\n      const actualTokens = []\n      for (let i = 1; i <= this.maxLookahead; i++) {\n        actualTokens.push(this.LA(i))\n      }\n      const previousToken = this.LA(0)\n      const errMsg = this.errorMessageProvider.buildNoViableAltMessage({\n        expectedPathsPerAlt: lookAheadPathsPerAlternative,\n        actual: actualTokens,\n        previous: previousToken,\n        customUserDescription: errMsgTypes,\n        ruleName: this.getCurrRuleFullName(),\n      })\n      throw this.SAVE_ERROR(new NoViableAltException(errMsg, this.LA(1), previousToken))\n    }\n  }\n\n  class ContentAssist {\n    initContentAssist() {}\n    computeContentAssist(startRuleName, precedingInput) {\n      const startRuleGast = this.gastProductionsCache[startRuleName]\n      if (isUndefined(startRuleGast)) {\n        throw Error(`Rule ->${startRuleName}<- does not exist in this grammar.`)\n      }\n      return nextPossibleTokensAfter([startRuleGast], precedingInput, this.tokenMatcher, this.maxLookahead)\n    }\n    // TODO: should this be a member method or a utility? it does not have any state or usage of 'this'...\n    // TODO: should this be more explicitly part of the public API?\n    getNextPossibleTokenTypes(grammarPath) {\n      const topRuleName = head(grammarPath.ruleStack)\n      const gastProductions = this.getGAstProductions()\n      const topProduction = gastProductions[topRuleName]\n      const nextPossibleTokenTypes = new NextAfterTokenWalker(topProduction, grammarPath).startWalking()\n      return nextPossibleTokenTypes\n    }\n  }\n\n  const RECORDING_NULL_OBJECT = {\n    description: 'This Object indicates the Parser is during Recording Phase',\n  }\n  Object.freeze(RECORDING_NULL_OBJECT)\n  const HANDLE_SEPARATOR = true\n  const MAX_METHOD_IDX = Math.pow(2, BITS_FOR_OCCURRENCE_IDX) - 1\n  const RFT = createToken({ name: 'RECORDING_PHASE_TOKEN', pattern: Lexer.NA })\n  augmentTokenTypes([RFT])\n  const RECORDING_PHASE_TOKEN = createTokenInstance(\n    RFT,\n    'This IToken indicates the Parser is in Recording Phase\\n\\t' +\n      '' +\n      'See: https://chevrotain.io/docs/guide/internals.html#grammar-recording for details',\n    // Using \"-1\" instead of NaN (as in EOF) because an actual number is less likely to\n    // cause errors if the output of LA or CONSUME would be (incorrectly) used during the recording phase.\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n  )\n  Object.freeze(RECORDING_PHASE_TOKEN)\n  const RECORDING_PHASE_CSTNODE = {\n    name:\n      'This CSTNode indicates the Parser is in Recording Phase\\n\\t' +\n      'See: https://chevrotain.io/docs/guide/internals.html#grammar-recording for details',\n    children: {},\n  }\n  /**\n   * This trait handles the creation of the GAST structure for Chevrotain Grammars\n   */\n  class GastRecorder {\n    initGastRecorder(config) {\n      this.recordingProdStack = []\n      this.RECORDING_PHASE = false\n    }\n    enableRecording() {\n      this.RECORDING_PHASE = true\n      this.TRACE_INIT('Enable Recording', () => {\n        /**\n         * Warning Dark Voodoo Magic upcoming!\n         * We are \"replacing\" the public parsing DSL methods API\n         * With **new** alternative implementations on the Parser **instance**\n         *\n         * So far this is the only way I've found to avoid performance regressions during parsing time.\n         * - Approx 30% performance regression was measured on Chrome 75 Canary when attempting to replace the \"internal\"\n         *   implementations directly instead.\n         */\n        for (let i = 0; i < 10; i++) {\n          const idx = i > 0 ? i : ''\n          this[`CONSUME${idx}`] = function (arg1, arg2) {\n            return this.consumeInternalRecord(arg1, i, arg2)\n          }\n          this[`SUBRULE${idx}`] = function (arg1, arg2) {\n            return this.subruleInternalRecord(arg1, i, arg2)\n          }\n          this[`OPTION${idx}`] = function (arg1) {\n            return this.optionInternalRecord(arg1, i)\n          }\n          this[`OR${idx}`] = function (arg1) {\n            return this.orInternalRecord(arg1, i)\n          }\n          this[`MANY${idx}`] = function (arg1) {\n            this.manyInternalRecord(i, arg1)\n          }\n          this[`MANY_SEP${idx}`] = function (arg1) {\n            this.manySepFirstInternalRecord(i, arg1)\n          }\n          this[`AT_LEAST_ONE${idx}`] = function (arg1) {\n            this.atLeastOneInternalRecord(i, arg1)\n          }\n          this[`AT_LEAST_ONE_SEP${idx}`] = function (arg1) {\n            this.atLeastOneSepFirstInternalRecord(i, arg1)\n          }\n        }\n        // DSL methods with the idx(suffix) as an argument\n        this[`consume`] = function (idx, arg1, arg2) {\n          return this.consumeInternalRecord(arg1, idx, arg2)\n        }\n        this[`subrule`] = function (idx, arg1, arg2) {\n          return this.subruleInternalRecord(arg1, idx, arg2)\n        }\n        this[`option`] = function (idx, arg1) {\n          return this.optionInternalRecord(arg1, idx)\n        }\n        this[`or`] = function (idx, arg1) {\n          return this.orInternalRecord(arg1, idx)\n        }\n        this[`many`] = function (idx, arg1) {\n          this.manyInternalRecord(idx, arg1)\n        }\n        this[`atLeastOne`] = function (idx, arg1) {\n          this.atLeastOneInternalRecord(idx, arg1)\n        }\n        this.ACTION = this.ACTION_RECORD\n        this.BACKTRACK = this.BACKTRACK_RECORD\n        this.LA = this.LA_RECORD\n      })\n    }\n    disableRecording() {\n      this.RECORDING_PHASE = false\n      // By deleting these **instance** properties, any future invocation\n      // will be deferred to the original methods on the **prototype** object\n      // This seems to get rid of any incorrect optimizations that V8 may\n      // do during the recording phase.\n      this.TRACE_INIT('Deleting Recording methods', () => {\n        const that = this\n        for (let i = 0; i < 10; i++) {\n          const idx = i > 0 ? i : ''\n          delete that[`CONSUME${idx}`]\n          delete that[`SUBRULE${idx}`]\n          delete that[`OPTION${idx}`]\n          delete that[`OR${idx}`]\n          delete that[`MANY${idx}`]\n          delete that[`MANY_SEP${idx}`]\n          delete that[`AT_LEAST_ONE${idx}`]\n          delete that[`AT_LEAST_ONE_SEP${idx}`]\n        }\n        delete that[`consume`]\n        delete that[`subrule`]\n        delete that[`option`]\n        delete that[`or`]\n        delete that[`many`]\n        delete that[`atLeastOne`]\n        delete that.ACTION\n        delete that.BACKTRACK\n        delete that.LA\n      })\n    }\n    //   Parser methods are called inside an ACTION?\n    //   Maybe try/catch/finally on ACTIONS while disabling the recorders state changes?\n    // @ts-expect-error -- noop place holder\n    ACTION_RECORD(impl) {\n      // NO-OP during recording\n    }\n    // Executing backtracking logic will break our recording logic assumptions\n    BACKTRACK_RECORD(grammarRule, args) {\n      return () => true\n    }\n    // LA is part of the official API and may be used for custom lookahead logic\n    // by end users who may forget to wrap it in ACTION or inside a GATE\n    LA_RECORD(howMuch) {\n      // We cannot use the RECORD_PHASE_TOKEN here because someone may depend\n      // On LA return EOF at the end of the input so an infinite loop may occur.\n      return END_OF_FILE\n    }\n    topLevelRuleRecord(name, def) {\n      try {\n        const newTopLevelRule = new Rule({ definition: [], name: name })\n        newTopLevelRule.name = name\n        this.recordingProdStack.push(newTopLevelRule)\n        def.call(this)\n        this.recordingProdStack.pop()\n        return newTopLevelRule\n      } catch (originalError) {\n        if (originalError.KNOWN_RECORDER_ERROR !== true) {\n          try {\n            originalError.message =\n              originalError.message +\n              '\\n\\t This error was thrown during the \"grammar recording phase\" For more info see:\\n\\t' +\n              'https://chevrotain.io/docs/guide/internals.html#grammar-recording'\n          } catch (mutabilityError) {\n            // We may not be able to modify the original error object\n            throw originalError\n          }\n        }\n        throw originalError\n      }\n    }\n    // Implementation of parsing DSL\n    optionInternalRecord(actionORMethodDef, occurrence) {\n      return recordProd.call(this, Option, actionORMethodDef, occurrence)\n    }\n    atLeastOneInternalRecord(occurrence, actionORMethodDef) {\n      recordProd.call(this, RepetitionMandatory, actionORMethodDef, occurrence)\n    }\n    atLeastOneSepFirstInternalRecord(occurrence, options) {\n      recordProd.call(this, RepetitionMandatoryWithSeparator, options, occurrence, HANDLE_SEPARATOR)\n    }\n    manyInternalRecord(occurrence, actionORMethodDef) {\n      recordProd.call(this, Repetition, actionORMethodDef, occurrence)\n    }\n    manySepFirstInternalRecord(occurrence, options) {\n      recordProd.call(this, RepetitionWithSeparator, options, occurrence, HANDLE_SEPARATOR)\n    }\n    orInternalRecord(altsOrOpts, occurrence) {\n      return recordOrProd.call(this, altsOrOpts, occurrence)\n    }\n    subruleInternalRecord(ruleToCall, occurrence, options) {\n      assertMethodIdxIsValid(occurrence)\n      if (!ruleToCall || has(ruleToCall, 'ruleName') === false) {\n        const error = new Error(\n          `<SUBRULE${getIdxSuffix(occurrence)}> argument is invalid` +\n            ` expecting a Parser method reference but got: <${JSON.stringify(ruleToCall)}>` +\n            `\\n inside top level rule: <${this.recordingProdStack[0].name}>`,\n        )\n        error.KNOWN_RECORDER_ERROR = true\n        throw error\n      }\n      const prevProd = last(this.recordingProdStack)\n      const ruleName = ruleToCall.ruleName\n      const newNoneTerminal = new NonTerminal({\n        idx: occurrence,\n        nonTerminalName: ruleName,\n        label: options === null || options === void 0 ? void 0 : options.LABEL,\n        // The resolving of the `referencedRule` property will be done once all the Rule's GASTs have been created\n        referencedRule: undefined,\n      })\n      prevProd.definition.push(newNoneTerminal)\n      return this.outputCst ? RECORDING_PHASE_CSTNODE : RECORDING_NULL_OBJECT\n    }\n    consumeInternalRecord(tokType, occurrence, options) {\n      assertMethodIdxIsValid(occurrence)\n      if (!hasShortKeyProperty(tokType)) {\n        const error = new Error(\n          `<CONSUME${getIdxSuffix(occurrence)}> argument is invalid` +\n            ` expecting a TokenType reference but got: <${JSON.stringify(tokType)}>` +\n            `\\n inside top level rule: <${this.recordingProdStack[0].name}>`,\n        )\n        error.KNOWN_RECORDER_ERROR = true\n        throw error\n      }\n      const prevProd = last(this.recordingProdStack)\n      const newNoneTerminal = new Terminal({\n        idx: occurrence,\n        terminalType: tokType,\n        label: options === null || options === void 0 ? void 0 : options.LABEL,\n      })\n      prevProd.definition.push(newNoneTerminal)\n      return RECORDING_PHASE_TOKEN\n    }\n  }\n  function recordProd(prodConstructor, mainProdArg, occurrence, handleSep = false) {\n    assertMethodIdxIsValid(occurrence)\n    const prevProd = last(this.recordingProdStack)\n    const grammarAction = isFunction(mainProdArg) ? mainProdArg : mainProdArg.DEF\n    const newProd = new prodConstructor({ definition: [], idx: occurrence })\n    if (handleSep) {\n      newProd.separator = mainProdArg.SEP\n    }\n    if (has(mainProdArg, 'MAX_LOOKAHEAD')) {\n      newProd.maxLookahead = mainProdArg.MAX_LOOKAHEAD\n    }\n    this.recordingProdStack.push(newProd)\n    grammarAction.call(this)\n    prevProd.definition.push(newProd)\n    this.recordingProdStack.pop()\n    return RECORDING_NULL_OBJECT\n  }\n  function recordOrProd(mainProdArg, occurrence) {\n    assertMethodIdxIsValid(occurrence)\n    const prevProd = last(this.recordingProdStack)\n    // Only an array of alternatives\n    const hasOptions = isArray$1(mainProdArg) === false\n    const alts = hasOptions === false ? mainProdArg : mainProdArg.DEF\n    const newOrProd = new Alternation({\n      definition: [],\n      idx: occurrence,\n      ignoreAmbiguities: hasOptions && mainProdArg.IGNORE_AMBIGUITIES === true,\n    })\n    if (has(mainProdArg, 'MAX_LOOKAHEAD')) {\n      newOrProd.maxLookahead = mainProdArg.MAX_LOOKAHEAD\n    }\n    const hasPredicates = some(alts, (currAlt) => isFunction(currAlt.GATE))\n    newOrProd.hasPredicates = hasPredicates\n    prevProd.definition.push(newOrProd)\n    forEach(alts, (currAlt) => {\n      const currAltFlat = new Alternative({ definition: [] })\n      newOrProd.definition.push(currAltFlat)\n      if (has(currAlt, 'IGNORE_AMBIGUITIES')) {\n        currAltFlat.ignoreAmbiguities = currAlt.IGNORE_AMBIGUITIES // assumes end user provides the correct config value/type\n      }\n      // **implicit** ignoreAmbiguities due to usage of gate\n      else if (has(currAlt, 'GATE')) {\n        currAltFlat.ignoreAmbiguities = true\n      }\n      this.recordingProdStack.push(currAltFlat)\n      currAlt.ALT.call(this)\n      this.recordingProdStack.pop()\n    })\n    return RECORDING_NULL_OBJECT\n  }\n  function getIdxSuffix(idx) {\n    return idx === 0 ? '' : `${idx}`\n  }\n  function assertMethodIdxIsValid(idx) {\n    if (idx < 0 || idx > MAX_METHOD_IDX) {\n      const error = new Error(\n        // The stack trace will contain all the needed details\n        `Invalid DSL Method idx value: <${idx}>\\n\\t` +\n          `Idx value must be a none negative value smaller than ${MAX_METHOD_IDX + 1}`,\n      )\n      error.KNOWN_RECORDER_ERROR = true\n      throw error\n    }\n  }\n\n  /**\n   * Trait responsible for runtime parsing errors.\n   */\n  class PerformanceTracer {\n    initPerformanceTracer(config) {\n      if (has(config, 'traceInitPerf')) {\n        const userTraceInitPerf = config.traceInitPerf\n        const traceIsNumber = typeof userTraceInitPerf === 'number'\n        this.traceInitMaxIdent = traceIsNumber ? userTraceInitPerf : Infinity\n        this.traceInitPerf = traceIsNumber ? userTraceInitPerf > 0 : userTraceInitPerf // assumes end user provides the correct config value/type\n      } else {\n        this.traceInitMaxIdent = 0\n        this.traceInitPerf = DEFAULT_PARSER_CONFIG.traceInitPerf\n      }\n      this.traceInitIndent = -1\n    }\n    TRACE_INIT(phaseDesc, phaseImpl) {\n      // No need to optimize this using NOOP pattern because\n      // It is not called in a hot spot...\n      if (this.traceInitPerf === true) {\n        this.traceInitIndent++\n        const indent = new Array(this.traceInitIndent + 1).join('\\t')\n        if (this.traceInitIndent < this.traceInitMaxIdent) {\n          console.log(`${indent}--> <${phaseDesc}>`)\n        }\n        const { time, value } = timer(phaseImpl)\n        /* istanbul ignore next - Difficult to reproduce specific performance behavior (>10ms) in tests */\n        const traceMethod = time > 10 ? console.warn : console.log\n        if (this.traceInitIndent < this.traceInitMaxIdent) {\n          traceMethod(`${indent}<-- <${phaseDesc}> time: ${time}ms`)\n        }\n        this.traceInitIndent--\n        return value\n      } else {\n        return phaseImpl()\n      }\n    }\n  }\n\n  function applyMixins(derivedCtor, baseCtors) {\n    baseCtors.forEach((baseCtor) => {\n      const baseProto = baseCtor.prototype\n      Object.getOwnPropertyNames(baseProto).forEach((propName) => {\n        if (propName === 'constructor') {\n          return\n        }\n        const basePropDescriptor = Object.getOwnPropertyDescriptor(baseProto, propName)\n        // Handle Accessors\n        if (basePropDescriptor && (basePropDescriptor.get || basePropDescriptor.set)) {\n          Object.defineProperty(derivedCtor.prototype, propName, basePropDescriptor)\n        } else {\n          derivedCtor.prototype[propName] = baseCtor.prototype[propName]\n        }\n      })\n    })\n  }\n\n  const END_OF_FILE = createTokenInstance(EOF, '', NaN, NaN, NaN, NaN, NaN, NaN)\n  Object.freeze(END_OF_FILE)\n  const DEFAULT_PARSER_CONFIG = Object.freeze({\n    recoveryEnabled: false,\n    maxLookahead: 3,\n    dynamicTokensEnabled: false,\n    outputCst: true,\n    errorMessageProvider: defaultParserErrorProvider,\n    nodeLocationTracking: 'none',\n    traceInitPerf: false,\n    skipValidations: false,\n  })\n  const DEFAULT_RULE_CONFIG = Object.freeze({\n    recoveryValueFunc: () => undefined,\n    resyncEnabled: true,\n  })\n  var ParserDefinitionErrorType\n  ;(function (ParserDefinitionErrorType) {\n    ParserDefinitionErrorType[(ParserDefinitionErrorType['INVALID_RULE_NAME'] = 0)] = 'INVALID_RULE_NAME'\n    ParserDefinitionErrorType[(ParserDefinitionErrorType['DUPLICATE_RULE_NAME'] = 1)] = 'DUPLICATE_RULE_NAME'\n    ParserDefinitionErrorType[(ParserDefinitionErrorType['INVALID_RULE_OVERRIDE'] = 2)] = 'INVALID_RULE_OVERRIDE'\n    ParserDefinitionErrorType[(ParserDefinitionErrorType['DUPLICATE_PRODUCTIONS'] = 3)] = 'DUPLICATE_PRODUCTIONS'\n    ParserDefinitionErrorType[(ParserDefinitionErrorType['UNRESOLVED_SUBRULE_REF'] = 4)] = 'UNRESOLVED_SUBRULE_REF'\n    ParserDefinitionErrorType[(ParserDefinitionErrorType['LEFT_RECURSION'] = 5)] = 'LEFT_RECURSION'\n    ParserDefinitionErrorType[(ParserDefinitionErrorType['NONE_LAST_EMPTY_ALT'] = 6)] = 'NONE_LAST_EMPTY_ALT'\n    ParserDefinitionErrorType[(ParserDefinitionErrorType['AMBIGUOUS_ALTS'] = 7)] = 'AMBIGUOUS_ALTS'\n    ParserDefinitionErrorType[(ParserDefinitionErrorType['CONFLICT_TOKENS_RULES_NAMESPACE'] = 8)] =\n      'CONFLICT_TOKENS_RULES_NAMESPACE'\n    ParserDefinitionErrorType[(ParserDefinitionErrorType['INVALID_TOKEN_NAME'] = 9)] = 'INVALID_TOKEN_NAME'\n    ParserDefinitionErrorType[(ParserDefinitionErrorType['NO_NON_EMPTY_LOOKAHEAD'] = 10)] = 'NO_NON_EMPTY_LOOKAHEAD'\n    ParserDefinitionErrorType[(ParserDefinitionErrorType['AMBIGUOUS_PREFIX_ALTS'] = 11)] = 'AMBIGUOUS_PREFIX_ALTS'\n    ParserDefinitionErrorType[(ParserDefinitionErrorType['TOO_MANY_ALTS'] = 12)] = 'TOO_MANY_ALTS'\n    ParserDefinitionErrorType[(ParserDefinitionErrorType['CUSTOM_LOOKAHEAD_VALIDATION'] = 13)] =\n      'CUSTOM_LOOKAHEAD_VALIDATION'\n  })(ParserDefinitionErrorType || (ParserDefinitionErrorType = {}))\n  class Parser {\n    /**\n     *  @deprecated use the **instance** method with the same name instead\n     */\n    static performSelfAnalysis(parserInstance) {\n      throw Error(\n        'The **static** `performSelfAnalysis` method has been deprecated.' +\n          '\\t\\nUse the **instance** method with the same name instead.',\n      )\n    }\n    performSelfAnalysis() {\n      this.TRACE_INIT('performSelfAnalysis', () => {\n        let defErrorsMsgs\n        this.selfAnalysisDone = true\n        const className = this.className\n        this.TRACE_INIT('toFastProps', () => {\n          // Without this voodoo magic the parser would be x3-x4 slower\n          // It seems it is better to invoke `toFastProperties` **before**\n          // Any manipulations of the `this` object done during the recording phase.\n          toFastProperties(this)\n        })\n        this.TRACE_INIT('Grammar Recording', () => {\n          try {\n            this.enableRecording()\n            // Building the GAST\n            forEach(this.definedRulesNames, (currRuleName) => {\n              const wrappedRule = this[currRuleName]\n              const originalGrammarAction = wrappedRule['originalGrammarAction']\n              let recordedRuleGast\n              this.TRACE_INIT(`${currRuleName} Rule`, () => {\n                recordedRuleGast = this.topLevelRuleRecord(currRuleName, originalGrammarAction)\n              })\n              this.gastProductionsCache[currRuleName] = recordedRuleGast\n            })\n          } finally {\n            this.disableRecording()\n          }\n        })\n        let resolverErrors = []\n        this.TRACE_INIT('Grammar Resolving', () => {\n          resolverErrors = resolveGrammar({\n            rules: values(this.gastProductionsCache),\n          })\n          this.definitionErrors = this.definitionErrors.concat(resolverErrors)\n        })\n        this.TRACE_INIT('Grammar Validations', () => {\n          // only perform additional grammar validations IFF no resolving errors have occurred.\n          // as unresolved grammar may lead to unhandled runtime exceptions in the follow up validations.\n          if (isEmpty(resolverErrors) && this.skipValidations === false) {\n            const validationErrors = validateGrammar({\n              rules: values(this.gastProductionsCache),\n              tokenTypes: values(this.tokensMap),\n              errMsgProvider: defaultGrammarValidatorErrorProvider,\n              grammarName: className,\n            })\n            const lookaheadValidationErrors = validateLookahead({\n              lookaheadStrategy: this.lookaheadStrategy,\n              rules: values(this.gastProductionsCache),\n              tokenTypes: values(this.tokensMap),\n              grammarName: className,\n            })\n            this.definitionErrors = this.definitionErrors.concat(validationErrors, lookaheadValidationErrors)\n          }\n        })\n        // this analysis may fail if the grammar is not perfectly valid\n        if (isEmpty(this.definitionErrors)) {\n          // The results of these computations are not needed unless error recovery is enabled.\n          if (this.recoveryEnabled) {\n            this.TRACE_INIT('computeAllProdsFollows', () => {\n              const allFollows = computeAllProdsFollows(values(this.gastProductionsCache))\n              this.resyncFollows = allFollows\n            })\n          }\n          this.TRACE_INIT('ComputeLookaheadFunctions', () => {\n            var _a, _b\n            ;(_b = (_a = this.lookaheadStrategy).initialize) === null || _b === void 0\n              ? void 0\n              : _b.call(_a, {\n                  rules: values(this.gastProductionsCache),\n                })\n            this.preComputeLookaheadFunctions(values(this.gastProductionsCache))\n          })\n        }\n        if (!Parser.DEFER_DEFINITION_ERRORS_HANDLING && !isEmpty(this.definitionErrors)) {\n          defErrorsMsgs = map(this.definitionErrors, (defError) => defError.message)\n          throw new Error(\n            `Parser Definition Errors detected:\\n ${defErrorsMsgs.join('\\n-------------------------------\\n')}`,\n          )\n        }\n      })\n    }\n    constructor(tokenVocabulary, config) {\n      this.definitionErrors = []\n      this.selfAnalysisDone = false\n      const that = this\n      that.initErrorHandler(config)\n      that.initLexerAdapter()\n      that.initLooksAhead(config)\n      that.initRecognizerEngine(tokenVocabulary, config)\n      that.initRecoverable(config)\n      that.initTreeBuilder(config)\n      that.initContentAssist()\n      that.initGastRecorder(config)\n      that.initPerformanceTracer(config)\n      if (has(config, 'ignoredIssues')) {\n        throw new Error(\n          'The <ignoredIssues> IParserConfig property has been deprecated.\\n\\t' +\n            'Please use the <IGNORE_AMBIGUITIES> flag on the relevant DSL method instead.\\n\\t' +\n            'See: https://chevrotain.io/docs/guide/resolving_grammar_errors.html#IGNORING_AMBIGUITIES\\n\\t' +\n            'For further details.',\n        )\n      }\n      this.skipValidations = has(config, 'skipValidations')\n        ? config.skipValidations // casting assumes the end user passing the correct type\n        : DEFAULT_PARSER_CONFIG.skipValidations\n    }\n  }\n  // Set this flag to true if you don't want the Parser to throw error when problems in it's definition are detected.\n  // (normally during the parser's constructor).\n  // This is a design time flag, it will not affect the runtime error handling of the parser, just design time errors,\n  // for example: duplicate rule names, referencing an unresolved subrule, ect...\n  // This flag should not be enabled during normal usage, it is used in special situations, for example when\n  // needing to display the parser definition errors in some GUI(online playground).\n  Parser.DEFER_DEFINITION_ERRORS_HANDLING = false\n  applyMixins(Parser, [\n    Recoverable,\n    LooksAhead,\n    TreeBuilder,\n    LexerAdapter,\n    RecognizerEngine,\n    RecognizerApi,\n    ErrorHandler,\n    ContentAssist,\n    GastRecorder,\n    PerformanceTracer,\n  ])\n  class CstParser extends Parser {\n    constructor(tokenVocabulary, config = DEFAULT_PARSER_CONFIG) {\n      const configClone = clone(config)\n      configClone.outputCst = true\n      super(tokenVocabulary, configClone)\n    }\n  }\n\n  return { CstParser, Lexer, createToken }\n})()\n\nexport { CstParser, Lexer, createToken }\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}