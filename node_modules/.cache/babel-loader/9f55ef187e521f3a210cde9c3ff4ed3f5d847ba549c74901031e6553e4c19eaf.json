{"ast":null,"code":"import _createClass from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _classCallCheck from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport { Color, REVISION, ShaderMaterial, UniformsUtils, UniformsLib, BackSide } from \"three\";\nvar OutlineEffect = /*#__PURE__*/_createClass(function OutlineEffect(renderer) {\n  var parameters = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  _classCallCheck(this, OutlineEffect);\n  this.enabled = true;\n  var defaultThickness = parameters.defaultThickness !== void 0 ? parameters.defaultThickness : 3e-3;\n  var defaultColor = new Color().fromArray(parameters.defaultColor !== void 0 ? parameters.defaultColor : [0, 0, 0]);\n  var defaultAlpha = parameters.defaultAlpha !== void 0 ? parameters.defaultAlpha : 1;\n  var defaultKeepAlive = parameters.defaultKeepAlive !== void 0 ? parameters.defaultKeepAlive : false;\n  var cache = {};\n  var removeThresholdCount = 60;\n  var originalMaterials = {};\n  var originalOnBeforeRenders = {};\n  var uniformsOutline = {\n    outlineThickness: {\n      value: defaultThickness\n    },\n    outlineColor: {\n      value: defaultColor\n    },\n    outlineAlpha: {\n      value: defaultAlpha\n    }\n  };\n  var vertexShader = [\"#include <common>\", \"#include <uv_pars_vertex>\", \"#include <displacementmap_pars_vertex>\", \"#include <fog_pars_vertex>\", \"#include <morphtarget_pars_vertex>\", \"#include <skinning_pars_vertex>\", \"#include <logdepthbuf_pars_vertex>\", \"#include <clipping_planes_pars_vertex>\", \"uniform float outlineThickness;\", \"vec4 calculateOutline( vec4 pos, vec3 normal, vec4 skinned ) {\", \"\tfloat thickness = outlineThickness;\", \"\tconst float ratio = 1.0;\",\n  // TODO: support outline thickness ratio for each vertex\n  \"\tvec4 pos2 = projectionMatrix * modelViewMatrix * vec4( skinned.xyz + normal, 1.0 );\",\n  // NOTE: subtract pos2 from pos because BackSide objectNormal is negative\n  \"\tvec4 norm = normalize( pos - pos2 );\", \"\treturn pos + norm * thickness * pos.w * ratio;\", \"}\", \"void main() {\", \"\t#include <uv_vertex>\", \"\t#include <beginnormal_vertex>\", \"\t#include <morphnormal_vertex>\", \"\t#include <skinbase_vertex>\", \"\t#include <skinnormal_vertex>\", \"\t#include <begin_vertex>\", \"\t#include <morphtarget_vertex>\", \"\t#include <skinning_vertex>\", \"\t#include <displacementmap_vertex>\", \"\t#include <project_vertex>\", \"\tvec3 outlineNormal = - objectNormal;\",\n  // the outline material is always rendered with BackSide\n  \"\tgl_Position = calculateOutline( gl_Position, outlineNormal, vec4( transformed, 1.0 ) );\", \"\t#include <logdepthbuf_vertex>\", \"\t#include <clipping_planes_vertex>\", \"\t#include <fog_vertex>\", \"}\"].join(\"\\n\");\n  var fragmentShader = [\"#include <common>\", \"#include <fog_pars_fragment>\", \"#include <logdepthbuf_pars_fragment>\", \"#include <clipping_planes_pars_fragment>\", \"uniform vec3 outlineColor;\", \"uniform float outlineAlpha;\", \"void main() {\", \"\t#include <clipping_planes_fragment>\", \"\t#include <logdepthbuf_fragment>\", \"\tgl_FragColor = vec4( outlineColor, outlineAlpha );\", \"\t#include <tonemapping_fragment>\", \"\\t#include <\".concat(parseInt(REVISION.replace(/\\D+/g, \"\")) >= 154 ? \"colorspace_fragment\" : \"encodings_fragment\", \">\"), \"\t#include <fog_fragment>\", \"\t#include <premultiplied_alpha_fragment>\", \"}\"].join(\"\\n\");\n  function createMaterial() {\n    return new ShaderMaterial({\n      type: \"OutlineEffect\",\n      uniforms: UniformsUtils.merge([UniformsLib[\"fog\"], UniformsLib[\"displacementmap\"], uniformsOutline]),\n      vertexShader: vertexShader,\n      fragmentShader: fragmentShader,\n      side: BackSide\n    });\n  }\n  function getOutlineMaterialFromCache(originalMaterial) {\n    var data = cache[originalMaterial.uuid];\n    if (data === void 0) {\n      data = {\n        material: createMaterial(),\n        used: true,\n        keepAlive: defaultKeepAlive,\n        count: 0\n      };\n      cache[originalMaterial.uuid] = data;\n    }\n    data.used = true;\n    return data.material;\n  }\n  function getOutlineMaterial(originalMaterial) {\n    var outlineMaterial = getOutlineMaterialFromCache(originalMaterial);\n    originalMaterials[outlineMaterial.uuid] = originalMaterial;\n    updateOutlineMaterial(outlineMaterial, originalMaterial);\n    return outlineMaterial;\n  }\n  function isCompatible(object) {\n    var geometry = object.geometry;\n    var hasNormals = geometry !== void 0 && geometry.attributes.normal !== void 0;\n    return object.isMesh === true && object.material !== void 0 && hasNormals === true;\n  }\n  function setOutlineMaterial(object) {\n    if (isCompatible(object) === false) return;\n    if (Array.isArray(object.material)) {\n      for (var i = 0, il = object.material.length; i < il; i++) {\n        object.material[i] = getOutlineMaterial(object.material[i]);\n      }\n    } else {\n      object.material = getOutlineMaterial(object.material);\n    }\n    originalOnBeforeRenders[object.uuid] = object.onBeforeRender;\n    object.onBeforeRender = onBeforeRender;\n  }\n  function restoreOriginalMaterial(object) {\n    if (isCompatible(object) === false) return;\n    if (Array.isArray(object.material)) {\n      for (var i = 0, il = object.material.length; i < il; i++) {\n        object.material[i] = originalMaterials[object.material[i].uuid];\n      }\n    } else {\n      object.material = originalMaterials[object.material.uuid];\n    }\n    object.onBeforeRender = originalOnBeforeRenders[object.uuid];\n  }\n  function onBeforeRender(renderer2, scene, camera, geometry, material) {\n    var originalMaterial = originalMaterials[material.uuid];\n    if (originalMaterial === void 0) return;\n    updateUniforms(material, originalMaterial);\n  }\n  function updateUniforms(material, originalMaterial) {\n    var outlineParameters = originalMaterial.userData.outlineParameters;\n    material.uniforms.outlineAlpha.value = originalMaterial.opacity;\n    if (outlineParameters !== void 0) {\n      if (outlineParameters.thickness !== void 0) material.uniforms.outlineThickness.value = outlineParameters.thickness;\n      if (outlineParameters.color !== void 0) material.uniforms.outlineColor.value.fromArray(outlineParameters.color);\n      if (outlineParameters.alpha !== void 0) material.uniforms.outlineAlpha.value = outlineParameters.alpha;\n    }\n    if (originalMaterial.displacementMap) {\n      material.uniforms.displacementMap.value = originalMaterial.displacementMap;\n      material.uniforms.displacementScale.value = originalMaterial.displacementScale;\n      material.uniforms.displacementBias.value = originalMaterial.displacementBias;\n    }\n  }\n  function updateOutlineMaterial(material, originalMaterial) {\n    if (material.name === \"invisible\") return;\n    var outlineParameters = originalMaterial.userData.outlineParameters;\n    material.fog = originalMaterial.fog;\n    material.toneMapped = originalMaterial.toneMapped;\n    material.premultipliedAlpha = originalMaterial.premultipliedAlpha;\n    material.displacementMap = originalMaterial.displacementMap;\n    if (outlineParameters !== void 0) {\n      if (originalMaterial.visible === false) {\n        material.visible = false;\n      } else {\n        material.visible = outlineParameters.visible !== void 0 ? outlineParameters.visible : true;\n      }\n      material.transparent = outlineParameters.alpha !== void 0 && outlineParameters.alpha < 1 ? true : originalMaterial.transparent;\n      if (outlineParameters.keepAlive !== void 0) cache[originalMaterial.uuid].keepAlive = outlineParameters.keepAlive;\n    } else {\n      material.transparent = originalMaterial.transparent;\n      material.visible = originalMaterial.visible;\n    }\n    if (originalMaterial.wireframe === true || originalMaterial.depthTest === false) material.visible = false;\n    if (originalMaterial.clippingPlanes) {\n      material.clipping = true;\n      material.clippingPlanes = originalMaterial.clippingPlanes;\n      material.clipIntersection = originalMaterial.clipIntersection;\n      material.clipShadows = originalMaterial.clipShadows;\n    }\n    material.version = originalMaterial.version;\n  }\n  function cleanupCache() {\n    var keys;\n    keys = Object.keys(originalMaterials);\n    for (var i = 0, il = keys.length; i < il; i++) {\n      originalMaterials[keys[i]] = void 0;\n    }\n    keys = Object.keys(originalOnBeforeRenders);\n    for (var _i = 0, _il = keys.length; _i < _il; _i++) {\n      originalOnBeforeRenders[keys[_i]] = void 0;\n    }\n    keys = Object.keys(cache);\n    for (var _i2 = 0, _il2 = keys.length; _i2 < _il2; _i2++) {\n      var key = keys[_i2];\n      if (cache[key].used === false) {\n        cache[key].count++;\n        if (cache[key].keepAlive === false && cache[key].count > removeThresholdCount) {\n          delete cache[key];\n        }\n      } else {\n        cache[key].used = false;\n        cache[key].count = 0;\n      }\n    }\n  }\n  this.render = function (scene, camera) {\n    if (this.enabled === false) {\n      renderer.render(scene, camera);\n      return;\n    }\n    var currentAutoClear = renderer.autoClear;\n    renderer.autoClear = this.autoClear;\n    renderer.render(scene, camera);\n    renderer.autoClear = currentAutoClear;\n    this.renderOutline(scene, camera);\n  };\n  this.renderOutline = function (scene, camera) {\n    var currentAutoClear = renderer.autoClear;\n    var currentSceneAutoUpdate = scene.matrixWorldAutoUpdate;\n    var currentSceneBackground = scene.background;\n    var currentShadowMapEnabled = renderer.shadowMap.enabled;\n    scene.matrixWorldAutoUpdate = false;\n    scene.background = null;\n    renderer.autoClear = false;\n    renderer.shadowMap.enabled = false;\n    scene.traverse(setOutlineMaterial);\n    renderer.render(scene, camera);\n    scene.traverse(restoreOriginalMaterial);\n    cleanupCache();\n    scene.matrixWorldAutoUpdate = currentSceneAutoUpdate;\n    scene.background = currentSceneBackground;\n    renderer.autoClear = currentAutoClear;\n    renderer.shadowMap.enabled = currentShadowMapEnabled;\n  };\n  this.autoClear = renderer.autoClear;\n  this.domElement = renderer.domElement;\n  this.shadowMap = renderer.shadowMap;\n  this.clear = function (color, depth, stencil) {\n    renderer.clear(color, depth, stencil);\n  };\n  this.getPixelRatio = function () {\n    return renderer.getPixelRatio();\n  };\n  this.setPixelRatio = function (value) {\n    renderer.setPixelRatio(value);\n  };\n  this.getSize = function (target) {\n    return renderer.getSize(target);\n  };\n  this.setSize = function (width, height, updateStyle) {\n    renderer.setSize(width, height, updateStyle);\n  };\n  this.setViewport = function (x, y, width, height) {\n    renderer.setViewport(x, y, width, height);\n  };\n  this.setScissor = function (x, y, width, height) {\n    renderer.setScissor(x, y, width, height);\n  };\n  this.setScissorTest = function (boolean) {\n    renderer.setScissorTest(boolean);\n  };\n  this.setRenderTarget = function (renderTarget) {\n    renderer.setRenderTarget(renderTarget);\n  };\n});\nexport { OutlineEffect };","map":{"version":3,"names":["OutlineEffect","_createClass","renderer","parameters","arguments","length","undefined","_classCallCheck","enabled","defaultThickness","defaultColor","Color","fromArray","defaultAlpha","defaultKeepAlive","cache","removeThresholdCount","originalMaterials","originalOnBeforeRenders","uniformsOutline","outlineThickness","value","outlineColor","outlineAlpha","vertexShader","join","fragmentShader","concat","parseInt","REVISION","replace","createMaterial","ShaderMaterial","type","uniforms","UniformsUtils","merge","UniformsLib","side","BackSide","getOutlineMaterialFromCache","originalMaterial","data","uuid","material","used","keepAlive","count","getOutlineMaterial","outlineMaterial","updateOutlineMaterial","isCompatible","object","geometry","hasNormals","attributes","normal","isMesh","setOutlineMaterial","Array","isArray","i","il","onBeforeRender","restoreOriginalMaterial","renderer2","scene","camera","updateUniforms","outlineParameters","userData","opacity","thickness","color","alpha","displacementMap","displacementScale","displacementBias","name","fog","toneMapped","premultipliedAlpha","visible","transparent","wireframe","depthTest","clippingPlanes","clipping","clipIntersection","clipShadows","version","cleanupCache","keys","Object","key","render","currentAutoClear","autoClear","renderOutline","currentSceneAutoUpdate","matrixWorldAutoUpdate","currentSceneBackground","background","currentShadowMapEnabled","shadowMap","traverse","domElement","clear","depth","stencil","getPixelRatio","setPixelRatio","getSize","target","setSize","width","height","updateStyle","setViewport","x","y","setScissor","setScissorTest","boolean","setRenderTarget","renderTarget"],"sources":["C:\\Users\\Nayyu\\Desktop\\skibidai-public-build\\node_modules\\src\\effects\\OutlineEffect.js"],"sourcesContent":["import { BackSide, Color, ShaderMaterial, UniformsLib, UniformsUtils, REVISION } from 'three'\n\n/**\n * Reference: https://en.wikipedia.org/wiki/Cel_shading\n *\n * API\n *\n * 1. Traditional\n *\n * const effect = new OutlineEffect( renderer );\n *\n * function render() {\n *\n * \teffect.render( scene, camera );\n *\n * }\n *\n * 2. VR compatible\n *\n * const effect = new OutlineEffect( renderer );\n * let renderingOutline = false;\n *\n * scene.onAfterRender = function () {\n *\n * \tif ( renderingOutline ) return;\n *\n * \trenderingOutline = true;\n *\n * \teffect.renderOutline( scene, camera );\n *\n * \trenderingOutline = false;\n *\n * };\n *\n * function render() {\n *\n * \trenderer.render( scene, camera );\n *\n * }\n *\n * // How to set default outline parameters\n * new OutlineEffect( renderer, {\n * \tdefaultThickness: 0.01,\n * \tdefaultColor: [ 0, 0, 0 ],\n * \tdefaultAlpha: 0.8,\n * \tdefaultKeepAlive: true // keeps outline material in cache even if material is removed from scene\n * } );\n *\n * // How to set outline parameters for each material\n * material.userData.outlineParameters = {\n * \tthickness: 0.01,\n * \tcolor: [ 0, 0, 0 ],\n * \talpha: 0.8,\n * \tvisible: true,\n * \tkeepAlive: true\n * };\n */\n\nclass OutlineEffect {\n  constructor(renderer, parameters = {}) {\n    this.enabled = true\n\n    const defaultThickness = parameters.defaultThickness !== undefined ? parameters.defaultThickness : 0.003\n    const defaultColor = new Color().fromArray(\n      parameters.defaultColor !== undefined ? parameters.defaultColor : [0, 0, 0],\n    )\n    const defaultAlpha = parameters.defaultAlpha !== undefined ? parameters.defaultAlpha : 1.0\n    const defaultKeepAlive = parameters.defaultKeepAlive !== undefined ? parameters.defaultKeepAlive : false\n\n    // object.material.uuid -> outlineMaterial or\n    // object.material[ n ].uuid -> outlineMaterial\n    // save at the outline material creation and release\n    // if it's unused removeThresholdCount frames\n    // unless keepAlive is true.\n    const cache = {}\n\n    const removeThresholdCount = 60\n\n    // outlineMaterial.uuid -> object.material or\n    // outlineMaterial.uuid -> object.material[ n ]\n    // save before render and release after render.\n    const originalMaterials = {}\n\n    // object.uuid -> originalOnBeforeRender\n    // save before render and release after render.\n    const originalOnBeforeRenders = {}\n\n    //this.cache = cache;  // for debug\n\n    const uniformsOutline = {\n      outlineThickness: { value: defaultThickness },\n      outlineColor: { value: defaultColor },\n      outlineAlpha: { value: defaultAlpha },\n    }\n\n    const vertexShader = [\n      '#include <common>',\n      '#include <uv_pars_vertex>',\n      '#include <displacementmap_pars_vertex>',\n      '#include <fog_pars_vertex>',\n      '#include <morphtarget_pars_vertex>',\n      '#include <skinning_pars_vertex>',\n      '#include <logdepthbuf_pars_vertex>',\n      '#include <clipping_planes_pars_vertex>',\n\n      'uniform float outlineThickness;',\n\n      'vec4 calculateOutline( vec4 pos, vec3 normal, vec4 skinned ) {',\n      '\tfloat thickness = outlineThickness;',\n      '\tconst float ratio = 1.0;', // TODO: support outline thickness ratio for each vertex\n      '\tvec4 pos2 = projectionMatrix * modelViewMatrix * vec4( skinned.xyz + normal, 1.0 );',\n      // NOTE: subtract pos2 from pos because BackSide objectNormal is negative\n      '\tvec4 norm = normalize( pos - pos2 );',\n      '\treturn pos + norm * thickness * pos.w * ratio;',\n      '}',\n\n      'void main() {',\n\n      '\t#include <uv_vertex>',\n\n      '\t#include <beginnormal_vertex>',\n      '\t#include <morphnormal_vertex>',\n      '\t#include <skinbase_vertex>',\n      '\t#include <skinnormal_vertex>',\n\n      '\t#include <begin_vertex>',\n      '\t#include <morphtarget_vertex>',\n      '\t#include <skinning_vertex>',\n      '\t#include <displacementmap_vertex>',\n      '\t#include <project_vertex>',\n\n      '\tvec3 outlineNormal = - objectNormal;', // the outline material is always rendered with BackSide\n\n      '\tgl_Position = calculateOutline( gl_Position, outlineNormal, vec4( transformed, 1.0 ) );',\n\n      '\t#include <logdepthbuf_vertex>',\n      '\t#include <clipping_planes_vertex>',\n      '\t#include <fog_vertex>',\n\n      '}',\n    ].join('\\n')\n\n    const fragmentShader = [\n      '#include <common>',\n      '#include <fog_pars_fragment>',\n      '#include <logdepthbuf_pars_fragment>',\n      '#include <clipping_planes_pars_fragment>',\n\n      'uniform vec3 outlineColor;',\n      'uniform float outlineAlpha;',\n\n      'void main() {',\n\n      '\t#include <clipping_planes_fragment>',\n      '\t#include <logdepthbuf_fragment>',\n\n      '\tgl_FragColor = vec4( outlineColor, outlineAlpha );',\n\n      '\t#include <tonemapping_fragment>',\n      `\t#include <${parseInt(REVISION.replace(/\\D+/g, '')) >= 154 ? 'colorspace_fragment' : 'encodings_fragment'}>`,\n      '\t#include <fog_fragment>',\n      '\t#include <premultiplied_alpha_fragment>',\n\n      '}',\n    ].join('\\n')\n\n    function createMaterial() {\n      return new ShaderMaterial({\n        type: 'OutlineEffect',\n        uniforms: UniformsUtils.merge([UniformsLib['fog'], UniformsLib['displacementmap'], uniformsOutline]),\n        vertexShader: vertexShader,\n        fragmentShader: fragmentShader,\n        side: BackSide,\n      })\n    }\n\n    function getOutlineMaterialFromCache(originalMaterial) {\n      let data = cache[originalMaterial.uuid]\n\n      if (data === undefined) {\n        data = {\n          material: createMaterial(),\n          used: true,\n          keepAlive: defaultKeepAlive,\n          count: 0,\n        }\n\n        cache[originalMaterial.uuid] = data\n      }\n\n      data.used = true\n\n      return data.material\n    }\n\n    function getOutlineMaterial(originalMaterial) {\n      const outlineMaterial = getOutlineMaterialFromCache(originalMaterial)\n\n      originalMaterials[outlineMaterial.uuid] = originalMaterial\n\n      updateOutlineMaterial(outlineMaterial, originalMaterial)\n\n      return outlineMaterial\n    }\n\n    function isCompatible(object) {\n      const geometry = object.geometry\n      const hasNormals = geometry !== undefined && geometry.attributes.normal !== undefined\n\n      return object.isMesh === true && object.material !== undefined && hasNormals === true\n    }\n\n    function setOutlineMaterial(object) {\n      if (isCompatible(object) === false) return\n\n      if (Array.isArray(object.material)) {\n        for (let i = 0, il = object.material.length; i < il; i++) {\n          object.material[i] = getOutlineMaterial(object.material[i])\n        }\n      } else {\n        object.material = getOutlineMaterial(object.material)\n      }\n\n      originalOnBeforeRenders[object.uuid] = object.onBeforeRender\n      object.onBeforeRender = onBeforeRender\n    }\n\n    function restoreOriginalMaterial(object) {\n      if (isCompatible(object) === false) return\n\n      if (Array.isArray(object.material)) {\n        for (let i = 0, il = object.material.length; i < il; i++) {\n          object.material[i] = originalMaterials[object.material[i].uuid]\n        }\n      } else {\n        object.material = originalMaterials[object.material.uuid]\n      }\n\n      object.onBeforeRender = originalOnBeforeRenders[object.uuid]\n    }\n\n    function onBeforeRender(renderer, scene, camera, geometry, material) {\n      const originalMaterial = originalMaterials[material.uuid]\n\n      // just in case\n      if (originalMaterial === undefined) return\n\n      updateUniforms(material, originalMaterial)\n    }\n\n    function updateUniforms(material, originalMaterial) {\n      const outlineParameters = originalMaterial.userData.outlineParameters\n\n      material.uniforms.outlineAlpha.value = originalMaterial.opacity\n\n      if (outlineParameters !== undefined) {\n        if (outlineParameters.thickness !== undefined)\n          material.uniforms.outlineThickness.value = outlineParameters.thickness\n        if (outlineParameters.color !== undefined)\n          material.uniforms.outlineColor.value.fromArray(outlineParameters.color)\n        if (outlineParameters.alpha !== undefined) material.uniforms.outlineAlpha.value = outlineParameters.alpha\n      }\n\n      if (originalMaterial.displacementMap) {\n        material.uniforms.displacementMap.value = originalMaterial.displacementMap\n        material.uniforms.displacementScale.value = originalMaterial.displacementScale\n        material.uniforms.displacementBias.value = originalMaterial.displacementBias\n      }\n    }\n\n    function updateOutlineMaterial(material, originalMaterial) {\n      if (material.name === 'invisible') return\n\n      const outlineParameters = originalMaterial.userData.outlineParameters\n\n      material.fog = originalMaterial.fog\n      material.toneMapped = originalMaterial.toneMapped\n      material.premultipliedAlpha = originalMaterial.premultipliedAlpha\n      material.displacementMap = originalMaterial.displacementMap\n\n      if (outlineParameters !== undefined) {\n        if (originalMaterial.visible === false) {\n          material.visible = false\n        } else {\n          material.visible = outlineParameters.visible !== undefined ? outlineParameters.visible : true\n        }\n\n        material.transparent =\n          outlineParameters.alpha !== undefined && outlineParameters.alpha < 1.0 ? true : originalMaterial.transparent\n\n        if (outlineParameters.keepAlive !== undefined)\n          cache[originalMaterial.uuid].keepAlive = outlineParameters.keepAlive\n      } else {\n        material.transparent = originalMaterial.transparent\n        material.visible = originalMaterial.visible\n      }\n\n      if (originalMaterial.wireframe === true || originalMaterial.depthTest === false) material.visible = false\n\n      if (originalMaterial.clippingPlanes) {\n        material.clipping = true\n\n        material.clippingPlanes = originalMaterial.clippingPlanes\n        material.clipIntersection = originalMaterial.clipIntersection\n        material.clipShadows = originalMaterial.clipShadows\n      }\n\n      material.version = originalMaterial.version // update outline material if necessary\n    }\n\n    function cleanupCache() {\n      let keys\n\n      // clear originialMaterials\n      keys = Object.keys(originalMaterials)\n\n      for (let i = 0, il = keys.length; i < il; i++) {\n        originalMaterials[keys[i]] = undefined\n      }\n\n      // clear originalOnBeforeRenders\n      keys = Object.keys(originalOnBeforeRenders)\n\n      for (let i = 0, il = keys.length; i < il; i++) {\n        originalOnBeforeRenders[keys[i]] = undefined\n      }\n\n      // remove unused outlineMaterial from cache\n      keys = Object.keys(cache)\n\n      for (let i = 0, il = keys.length; i < il; i++) {\n        const key = keys[i]\n\n        if (cache[key].used === false) {\n          cache[key].count++\n\n          if (cache[key].keepAlive === false && cache[key].count > removeThresholdCount) {\n            delete cache[key]\n          }\n        } else {\n          cache[key].used = false\n          cache[key].count = 0\n        }\n      }\n    }\n\n    this.render = function (scene, camera) {\n      if (this.enabled === false) {\n        renderer.render(scene, camera)\n        return\n      }\n\n      const currentAutoClear = renderer.autoClear\n      renderer.autoClear = this.autoClear\n\n      renderer.render(scene, camera)\n\n      renderer.autoClear = currentAutoClear\n\n      this.renderOutline(scene, camera)\n    }\n\n    this.renderOutline = function (scene, camera) {\n      const currentAutoClear = renderer.autoClear\n      const currentSceneAutoUpdate = scene.matrixWorldAutoUpdate\n      const currentSceneBackground = scene.background\n      const currentShadowMapEnabled = renderer.shadowMap.enabled\n\n      scene.matrixWorldAutoUpdate = false\n      scene.background = null\n      renderer.autoClear = false\n      renderer.shadowMap.enabled = false\n\n      scene.traverse(setOutlineMaterial)\n\n      renderer.render(scene, camera)\n\n      scene.traverse(restoreOriginalMaterial)\n\n      cleanupCache()\n\n      scene.matrixWorldAutoUpdate = currentSceneAutoUpdate\n      scene.background = currentSceneBackground\n      renderer.autoClear = currentAutoClear\n      renderer.shadowMap.enabled = currentShadowMapEnabled\n    }\n\n    /*\n     * See #9918\n     *\n     * The following property copies and wrapper methods enable\n     * OutlineEffect to be called from other *Effect, like\n     *\n     * effect = new StereoEffect( new OutlineEffect( renderer ) );\n     *\n     * function render () {\n     *\n     * \teffect.render( scene, camera );\n     *\n     * }\n     */\n    this.autoClear = renderer.autoClear\n    this.domElement = renderer.domElement\n    this.shadowMap = renderer.shadowMap\n\n    this.clear = function (color, depth, stencil) {\n      renderer.clear(color, depth, stencil)\n    }\n\n    this.getPixelRatio = function () {\n      return renderer.getPixelRatio()\n    }\n\n    this.setPixelRatio = function (value) {\n      renderer.setPixelRatio(value)\n    }\n\n    this.getSize = function (target) {\n      return renderer.getSize(target)\n    }\n\n    this.setSize = function (width, height, updateStyle) {\n      renderer.setSize(width, height, updateStyle)\n    }\n\n    this.setViewport = function (x, y, width, height) {\n      renderer.setViewport(x, y, width, height)\n    }\n\n    this.setScissor = function (x, y, width, height) {\n      renderer.setScissor(x, y, width, height)\n    }\n\n    this.setScissorTest = function (boolean) {\n      renderer.setScissorTest(boolean)\n    }\n\n    this.setRenderTarget = function (renderTarget) {\n      renderer.setRenderTarget(renderTarget)\n    }\n  }\n}\n\nexport { OutlineEffect }\n"],"mappings":";;;IA0DMA,aAAA,gBAAAC,YAAA,CACJ,SAAAD,cAAYE,QAAA,EAA2B;EAAA,IAAjBC,UAAA,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAa;EAAAG,eAAA,OAAAP,aAAA;EACjC,KAAKQ,OAAA,GAAU;EAEf,IAAMC,gBAAA,GAAmBN,UAAA,CAAWM,gBAAA,KAAqB,SAAYN,UAAA,CAAWM,gBAAA,GAAmB;EACnG,IAAMC,YAAA,GAAe,IAAIC,KAAA,CAAK,EAAGC,SAAA,CAC/BT,UAAA,CAAWO,YAAA,KAAiB,SAAYP,UAAA,CAAWO,YAAA,GAAe,CAAC,GAAG,GAAG,CAAC,CAC3E;EACD,IAAMG,YAAA,GAAeV,UAAA,CAAWU,YAAA,KAAiB,SAAYV,UAAA,CAAWU,YAAA,GAAe;EACvF,IAAMC,gBAAA,GAAmBX,UAAA,CAAWW,gBAAA,KAAqB,SAAYX,UAAA,CAAWW,gBAAA,GAAmB;EAOnG,IAAMC,KAAA,GAAQ,CAAE;EAEhB,IAAMC,oBAAA,GAAuB;EAK7B,IAAMC,iBAAA,GAAoB,CAAE;EAI5B,IAAMC,uBAAA,GAA0B,CAAE;EAIlC,IAAMC,eAAA,GAAkB;IACtBC,gBAAA,EAAkB;MAAEC,KAAA,EAAOZ;IAAkB;IAC7Ca,YAAA,EAAc;MAAED,KAAA,EAAOX;IAAc;IACrCa,YAAA,EAAc;MAAEF,KAAA,EAAOR;IAAc;EACtC;EAED,IAAMW,YAAA,GAAe,CACnB,qBACA,6BACA,0CACA,8BACA,sCACA,mCACA,sCACA,0CAEA,mCAEA,kEACA,wCACA;EAAA;EACA;EAAA;EAEA,yCACA,mDACA,KAEA,iBAEA,yBAEA,kCACA,kCACA,+BACA,iCAEA,4BACA,kCACA,+BACA,sCACA,8BAEA;EAAA;EAEA,4FAEA,kCACA,sCACA,0BAEA,IACN,CAAMC,IAAA,CAAK,IAAI;EAEX,IAAMC,cAAA,GAAiB,CACrB,qBACA,gCACA,wCACA,4CAEA,8BACA,+BAEA,iBAEA,wCACA,oCAEA,uDAEA,mDAAAC,MAAA,CACcC,QAAA,CAASC,QAAA,CAASC,OAAA,CAAQ,QAAQ,EAAE,CAAC,KAAK,MAAM,wBAAwB,4BACtF,4BACA,4CAEA,IACN,CAAML,IAAA,CAAK,IAAI;EAEX,SAASM,eAAA,EAAiB;IACxB,OAAO,IAAIC,cAAA,CAAe;MACxBC,IAAA,EAAM;MACNC,QAAA,EAAUC,aAAA,CAAcC,KAAA,CAAM,CAACC,WAAA,CAAY,KAAK,GAAGA,WAAA,CAAY,iBAAiB,GAAGlB,eAAe,CAAC;MACnGK,YAAA,EAAAA,YAAA;MACAE,cAAA,EAAAA,cAAA;MACAY,IAAA,EAAMC;IACd,CAAO;EACF;EAED,SAASC,4BAA4BC,gBAAA,EAAkB;IACrD,IAAIC,IAAA,GAAO3B,KAAA,CAAM0B,gBAAA,CAAiBE,IAAI;IAEtC,IAAID,IAAA,KAAS,QAAW;MACtBA,IAAA,GAAO;QACLE,QAAA,EAAUb,cAAA,CAAgB;QAC1Bc,IAAA,EAAM;QACNC,SAAA,EAAWhC,gBAAA;QACXiC,KAAA,EAAO;MACR;MAEDhC,KAAA,CAAM0B,gBAAA,CAAiBE,IAAI,IAAID,IAAA;IAChC;IAEDA,IAAA,CAAKG,IAAA,GAAO;IAEZ,OAAOH,IAAA,CAAKE,QAAA;EACb;EAED,SAASI,mBAAmBP,gBAAA,EAAkB;IAC5C,IAAMQ,eAAA,GAAkBT,2BAAA,CAA4BC,gBAAgB;IAEpExB,iBAAA,CAAkBgC,eAAA,CAAgBN,IAAI,IAAIF,gBAAA;IAE1CS,qBAAA,CAAsBD,eAAA,EAAiBR,gBAAgB;IAEvD,OAAOQ,eAAA;EACR;EAED,SAASE,aAAaC,MAAA,EAAQ;IAC5B,IAAMC,QAAA,GAAWD,MAAA,CAAOC,QAAA;IACxB,IAAMC,UAAA,GAAaD,QAAA,KAAa,UAAaA,QAAA,CAASE,UAAA,CAAWC,MAAA,KAAW;IAE5E,OAAOJ,MAAA,CAAOK,MAAA,KAAW,QAAQL,MAAA,CAAOR,QAAA,KAAa,UAAaU,UAAA,KAAe;EAClF;EAED,SAASI,mBAAmBN,MAAA,EAAQ;IAClC,IAAID,YAAA,CAAaC,MAAM,MAAM,OAAO;IAEpC,IAAIO,KAAA,CAAMC,OAAA,CAAQR,MAAA,CAAOR,QAAQ,GAAG;MAClC,SAASiB,CAAA,GAAI,GAAGC,EAAA,GAAKV,MAAA,CAAOR,QAAA,CAASvC,MAAA,EAAQwD,CAAA,GAAIC,EAAA,EAAID,CAAA,IAAK;QACxDT,MAAA,CAAOR,QAAA,CAASiB,CAAC,IAAIb,kBAAA,CAAmBI,MAAA,CAAOR,QAAA,CAASiB,CAAC,CAAC;MAC3D;IACT,OAAa;MACLT,MAAA,CAAOR,QAAA,GAAWI,kBAAA,CAAmBI,MAAA,CAAOR,QAAQ;IACrD;IAED1B,uBAAA,CAAwBkC,MAAA,CAAOT,IAAI,IAAIS,MAAA,CAAOW,cAAA;IAC9CX,MAAA,CAAOW,cAAA,GAAiBA,cAAA;EACzB;EAED,SAASC,wBAAwBZ,MAAA,EAAQ;IACvC,IAAID,YAAA,CAAaC,MAAM,MAAM,OAAO;IAEpC,IAAIO,KAAA,CAAMC,OAAA,CAAQR,MAAA,CAAOR,QAAQ,GAAG;MAClC,SAASiB,CAAA,GAAI,GAAGC,EAAA,GAAKV,MAAA,CAAOR,QAAA,CAASvC,MAAA,EAAQwD,CAAA,GAAIC,EAAA,EAAID,CAAA,IAAK;QACxDT,MAAA,CAAOR,QAAA,CAASiB,CAAC,IAAI5C,iBAAA,CAAkBmC,MAAA,CAAOR,QAAA,CAASiB,CAAC,EAAElB,IAAI;MAC/D;IACT,OAAa;MACLS,MAAA,CAAOR,QAAA,GAAW3B,iBAAA,CAAkBmC,MAAA,CAAOR,QAAA,CAASD,IAAI;IACzD;IAEDS,MAAA,CAAOW,cAAA,GAAiB7C,uBAAA,CAAwBkC,MAAA,CAAOT,IAAI;EAC5D;EAED,SAASoB,eAAeE,SAAA,EAAUC,KAAA,EAAOC,MAAA,EAAQd,QAAA,EAAUT,QAAA,EAAU;IACnE,IAAMH,gBAAA,GAAmBxB,iBAAA,CAAkB2B,QAAA,CAASD,IAAI;IAGxD,IAAIF,gBAAA,KAAqB,QAAW;IAEpC2B,cAAA,CAAexB,QAAA,EAAUH,gBAAgB;EAC1C;EAED,SAAS2B,eAAexB,QAAA,EAAUH,gBAAA,EAAkB;IAClD,IAAM4B,iBAAA,GAAoB5B,gBAAA,CAAiB6B,QAAA,CAASD,iBAAA;IAEpDzB,QAAA,CAASV,QAAA,CAASX,YAAA,CAAaF,KAAA,GAAQoB,gBAAA,CAAiB8B,OAAA;IAExD,IAAIF,iBAAA,KAAsB,QAAW;MACnC,IAAIA,iBAAA,CAAkBG,SAAA,KAAc,QAClC5B,QAAA,CAASV,QAAA,CAASd,gBAAA,CAAiBC,KAAA,GAAQgD,iBAAA,CAAkBG,SAAA;MAC/D,IAAIH,iBAAA,CAAkBI,KAAA,KAAU,QAC9B7B,QAAA,CAASV,QAAA,CAASZ,YAAA,CAAaD,KAAA,CAAMT,SAAA,CAAUyD,iBAAA,CAAkBI,KAAK;MACxE,IAAIJ,iBAAA,CAAkBK,KAAA,KAAU,QAAW9B,QAAA,CAASV,QAAA,CAASX,YAAA,CAAaF,KAAA,GAAQgD,iBAAA,CAAkBK,KAAA;IACrG;IAED,IAAIjC,gBAAA,CAAiBkC,eAAA,EAAiB;MACpC/B,QAAA,CAASV,QAAA,CAASyC,eAAA,CAAgBtD,KAAA,GAAQoB,gBAAA,CAAiBkC,eAAA;MAC3D/B,QAAA,CAASV,QAAA,CAAS0C,iBAAA,CAAkBvD,KAAA,GAAQoB,gBAAA,CAAiBmC,iBAAA;MAC7DhC,QAAA,CAASV,QAAA,CAAS2C,gBAAA,CAAiBxD,KAAA,GAAQoB,gBAAA,CAAiBoC,gBAAA;IAC7D;EACF;EAED,SAAS3B,sBAAsBN,QAAA,EAAUH,gBAAA,EAAkB;IACzD,IAAIG,QAAA,CAASkC,IAAA,KAAS,aAAa;IAEnC,IAAMT,iBAAA,GAAoB5B,gBAAA,CAAiB6B,QAAA,CAASD,iBAAA;IAEpDzB,QAAA,CAASmC,GAAA,GAAMtC,gBAAA,CAAiBsC,GAAA;IAChCnC,QAAA,CAASoC,UAAA,GAAavC,gBAAA,CAAiBuC,UAAA;IACvCpC,QAAA,CAASqC,kBAAA,GAAqBxC,gBAAA,CAAiBwC,kBAAA;IAC/CrC,QAAA,CAAS+B,eAAA,GAAkBlC,gBAAA,CAAiBkC,eAAA;IAE5C,IAAIN,iBAAA,KAAsB,QAAW;MACnC,IAAI5B,gBAAA,CAAiByC,OAAA,KAAY,OAAO;QACtCtC,QAAA,CAASsC,OAAA,GAAU;MAC7B,OAAe;QACLtC,QAAA,CAASsC,OAAA,GAAUb,iBAAA,CAAkBa,OAAA,KAAY,SAAYb,iBAAA,CAAkBa,OAAA,GAAU;MAC1F;MAEDtC,QAAA,CAASuC,WAAA,GACPd,iBAAA,CAAkBK,KAAA,KAAU,UAAaL,iBAAA,CAAkBK,KAAA,GAAQ,IAAM,OAAOjC,gBAAA,CAAiB0C,WAAA;MAEnG,IAAId,iBAAA,CAAkBvB,SAAA,KAAc,QAClC/B,KAAA,CAAM0B,gBAAA,CAAiBE,IAAI,EAAEG,SAAA,GAAYuB,iBAAA,CAAkBvB,SAAA;IACrE,OAAa;MACLF,QAAA,CAASuC,WAAA,GAAc1C,gBAAA,CAAiB0C,WAAA;MACxCvC,QAAA,CAASsC,OAAA,GAAUzC,gBAAA,CAAiByC,OAAA;IACrC;IAED,IAAIzC,gBAAA,CAAiB2C,SAAA,KAAc,QAAQ3C,gBAAA,CAAiB4C,SAAA,KAAc,OAAOzC,QAAA,CAASsC,OAAA,GAAU;IAEpG,IAAIzC,gBAAA,CAAiB6C,cAAA,EAAgB;MACnC1C,QAAA,CAAS2C,QAAA,GAAW;MAEpB3C,QAAA,CAAS0C,cAAA,GAAiB7C,gBAAA,CAAiB6C,cAAA;MAC3C1C,QAAA,CAAS4C,gBAAA,GAAmB/C,gBAAA,CAAiB+C,gBAAA;MAC7C5C,QAAA,CAAS6C,WAAA,GAAchD,gBAAA,CAAiBgD,WAAA;IACzC;IAED7C,QAAA,CAAS8C,OAAA,GAAUjD,gBAAA,CAAiBiD,OAAA;EACrC;EAED,SAASC,aAAA,EAAe;IACtB,IAAIC,IAAA;IAGJA,IAAA,GAAOC,MAAA,CAAOD,IAAA,CAAK3E,iBAAiB;IAEpC,SAAS4C,CAAA,GAAI,GAAGC,EAAA,GAAK8B,IAAA,CAAKvF,MAAA,EAAQwD,CAAA,GAAIC,EAAA,EAAID,CAAA,IAAK;MAC7C5C,iBAAA,CAAkB2E,IAAA,CAAK/B,CAAC,CAAC,IAAI;IAC9B;IAGD+B,IAAA,GAAOC,MAAA,CAAOD,IAAA,CAAK1E,uBAAuB;IAE1C,SAAS2C,EAAA,GAAI,GAAGC,GAAA,GAAK8B,IAAA,CAAKvF,MAAA,EAAQwD,EAAA,GAAIC,GAAA,EAAID,EAAA,IAAK;MAC7C3C,uBAAA,CAAwB0E,IAAA,CAAK/B,EAAC,CAAC,IAAI;IACpC;IAGD+B,IAAA,GAAOC,MAAA,CAAOD,IAAA,CAAK7E,KAAK;IAExB,SAAS8C,GAAA,GAAI,GAAGC,IAAA,GAAK8B,IAAA,CAAKvF,MAAA,EAAQwD,GAAA,GAAIC,IAAA,EAAID,GAAA,IAAK;MAC7C,IAAMiC,GAAA,GAAMF,IAAA,CAAK/B,GAAC;MAElB,IAAI9C,KAAA,CAAM+E,GAAG,EAAEjD,IAAA,KAAS,OAAO;QAC7B9B,KAAA,CAAM+E,GAAG,EAAE/C,KAAA;QAEX,IAAIhC,KAAA,CAAM+E,GAAG,EAAEhD,SAAA,KAAc,SAAS/B,KAAA,CAAM+E,GAAG,EAAE/C,KAAA,GAAQ/B,oBAAA,EAAsB;UAC7E,OAAOD,KAAA,CAAM+E,GAAG;QACjB;MACX,OAAe;QACL/E,KAAA,CAAM+E,GAAG,EAAEjD,IAAA,GAAO;QAClB9B,KAAA,CAAM+E,GAAG,EAAE/C,KAAA,GAAQ;MACpB;IACF;EACF;EAED,KAAKgD,MAAA,GAAS,UAAU7B,KAAA,EAAOC,MAAA,EAAQ;IACrC,IAAI,KAAK3D,OAAA,KAAY,OAAO;MAC1BN,QAAA,CAAS6F,MAAA,CAAO7B,KAAA,EAAOC,MAAM;MAC7B;IACD;IAED,IAAM6B,gBAAA,GAAmB9F,QAAA,CAAS+F,SAAA;IAClC/F,QAAA,CAAS+F,SAAA,GAAY,KAAKA,SAAA;IAE1B/F,QAAA,CAAS6F,MAAA,CAAO7B,KAAA,EAAOC,MAAM;IAE7BjE,QAAA,CAAS+F,SAAA,GAAYD,gBAAA;IAErB,KAAKE,aAAA,CAAchC,KAAA,EAAOC,MAAM;EACjC;EAED,KAAK+B,aAAA,GAAgB,UAAUhC,KAAA,EAAOC,MAAA,EAAQ;IAC5C,IAAM6B,gBAAA,GAAmB9F,QAAA,CAAS+F,SAAA;IAClC,IAAME,sBAAA,GAAyBjC,KAAA,CAAMkC,qBAAA;IACrC,IAAMC,sBAAA,GAAyBnC,KAAA,CAAMoC,UAAA;IACrC,IAAMC,uBAAA,GAA0BrG,QAAA,CAASsG,SAAA,CAAUhG,OAAA;IAEnD0D,KAAA,CAAMkC,qBAAA,GAAwB;IAC9BlC,KAAA,CAAMoC,UAAA,GAAa;IACnBpG,QAAA,CAAS+F,SAAA,GAAY;IACrB/F,QAAA,CAASsG,SAAA,CAAUhG,OAAA,GAAU;IAE7B0D,KAAA,CAAMuC,QAAA,CAAS/C,kBAAkB;IAEjCxD,QAAA,CAAS6F,MAAA,CAAO7B,KAAA,EAAOC,MAAM;IAE7BD,KAAA,CAAMuC,QAAA,CAASzC,uBAAuB;IAEtC2B,YAAA,CAAc;IAEdzB,KAAA,CAAMkC,qBAAA,GAAwBD,sBAAA;IAC9BjC,KAAA,CAAMoC,UAAA,GAAaD,sBAAA;IACnBnG,QAAA,CAAS+F,SAAA,GAAYD,gBAAA;IACrB9F,QAAA,CAASsG,SAAA,CAAUhG,OAAA,GAAU+F,uBAAA;EAC9B;EAgBD,KAAKN,SAAA,GAAY/F,QAAA,CAAS+F,SAAA;EAC1B,KAAKS,UAAA,GAAaxG,QAAA,CAASwG,UAAA;EAC3B,KAAKF,SAAA,GAAYtG,QAAA,CAASsG,SAAA;EAE1B,KAAKG,KAAA,GAAQ,UAAUlC,KAAA,EAAOmC,KAAA,EAAOC,OAAA,EAAS;IAC5C3G,QAAA,CAASyG,KAAA,CAAMlC,KAAA,EAAOmC,KAAA,EAAOC,OAAO;EACrC;EAED,KAAKC,aAAA,GAAgB,YAAY;IAC/B,OAAO5G,QAAA,CAAS4G,aAAA,CAAe;EAChC;EAED,KAAKC,aAAA,GAAgB,UAAU1F,KAAA,EAAO;IACpCnB,QAAA,CAAS6G,aAAA,CAAc1F,KAAK;EAC7B;EAED,KAAK2F,OAAA,GAAU,UAAUC,MAAA,EAAQ;IAC/B,OAAO/G,QAAA,CAAS8G,OAAA,CAAQC,MAAM;EAC/B;EAED,KAAKC,OAAA,GAAU,UAAUC,KAAA,EAAOC,MAAA,EAAQC,WAAA,EAAa;IACnDnH,QAAA,CAASgH,OAAA,CAAQC,KAAA,EAAOC,MAAA,EAAQC,WAAW;EAC5C;EAED,KAAKC,WAAA,GAAc,UAAUC,CAAA,EAAGC,CAAA,EAAGL,KAAA,EAAOC,MAAA,EAAQ;IAChDlH,QAAA,CAASoH,WAAA,CAAYC,CAAA,EAAGC,CAAA,EAAGL,KAAA,EAAOC,MAAM;EACzC;EAED,KAAKK,UAAA,GAAa,UAAUF,CAAA,EAAGC,CAAA,EAAGL,KAAA,EAAOC,MAAA,EAAQ;IAC/ClH,QAAA,CAASuH,UAAA,CAAWF,CAAA,EAAGC,CAAA,EAAGL,KAAA,EAAOC,MAAM;EACxC;EAED,KAAKM,cAAA,GAAiB,UAAUC,OAAA,EAAS;IACvCzH,QAAA,CAASwH,cAAA,CAAeC,OAAO;EAChC;EAED,KAAKC,eAAA,GAAkB,UAAUC,YAAA,EAAc;IAC7C3H,QAAA,CAAS0H,eAAA,CAAgBC,YAAY;EACtC;AACF"},"metadata":{},"sourceType":"module","externalDependencies":[]}