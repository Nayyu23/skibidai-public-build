{"ast":null,"code":"import _classCallCheck from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _inherits from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport { Loader, LoaderUtils, FileLoader, Vector3, Quaternion, Matrix4, MeshBasicMaterial, Scene, TextureLoader, Euler, MathUtils, AnimationClip, VectorKeyframeTrack, QuaternionKeyframeTrack, MeshLambertMaterial, MeshPhongMaterial, Vector2, DoubleSide, FrontSide, PerspectiveCamera, OrthographicCamera, Color, AmbientLight, SpotLight, PointLight, DirectionalLight, BufferGeometry, Float32BufferAttribute, Group, Bone, LineBasicMaterial, SkinnedMesh, Mesh, Line, LineSegments, RepeatWrapping, ClampToEdgeWrapping, Skeleton } from \"three\";\nimport { TGALoader } from \"./TGALoader.js\";\nimport { UV1 } from \"../_polyfill/uv1.js\";\nvar ColladaLoader = /*#__PURE__*/function (_Loader) {\n  _inherits(ColladaLoader, _Loader);\n  var _super = _createSuper(ColladaLoader);\n  function ColladaLoader(manager) {\n    _classCallCheck(this, ColladaLoader);\n    return _super.call(this, manager);\n  }\n  _createClass(ColladaLoader, [{\n    key: \"load\",\n    value: function load(url, onLoad, onProgress, onError) {\n      var scope = this;\n      var path = scope.path === \"\" ? LoaderUtils.extractUrlBase(url) : scope.path;\n      var loader = new FileLoader(scope.manager);\n      loader.setPath(scope.path);\n      loader.setRequestHeader(scope.requestHeader);\n      loader.setWithCredentials(scope.withCredentials);\n      loader.load(url, function (text) {\n        try {\n          onLoad(scope.parse(text, path));\n        } catch (e) {\n          if (onError) {\n            onError(e);\n          } else {\n            console.error(e);\n          }\n          scope.manager.itemError(url);\n        }\n      }, onProgress, onError);\n    }\n  }, {\n    key: \"parse\",\n    value: function parse(text, path) {\n      function getElementsByTagName(xml2, name) {\n        var array = [];\n        var childNodes = xml2.childNodes;\n        for (var i = 0, l = childNodes.length; i < l; i++) {\n          var child = childNodes[i];\n          if (child.nodeName === name) {\n            array.push(child);\n          }\n        }\n        return array;\n      }\n      function parseStrings(text2) {\n        if (text2.length === 0) return [];\n        var parts = text2.trim().split(/\\s+/);\n        var array = new Array(parts.length);\n        for (var i = 0, l = parts.length; i < l; i++) {\n          array[i] = parts[i];\n        }\n        return array;\n      }\n      function parseFloats(text2) {\n        if (text2.length === 0) return [];\n        var parts = text2.trim().split(/\\s+/);\n        var array = new Array(parts.length);\n        for (var i = 0, l = parts.length; i < l; i++) {\n          array[i] = parseFloat(parts[i]);\n        }\n        return array;\n      }\n      function parseInts(text2) {\n        if (text2.length === 0) return [];\n        var parts = text2.trim().split(/\\s+/);\n        var array = new Array(parts.length);\n        for (var i = 0, l = parts.length; i < l; i++) {\n          array[i] = parseInt(parts[i]);\n        }\n        return array;\n      }\n      function parseId(text2) {\n        return text2.substring(1);\n      }\n      function generateId() {\n        return \"three_default_\" + count++;\n      }\n      function isEmpty(object) {\n        return Object.keys(object).length === 0;\n      }\n      function parseAsset(xml2) {\n        return {\n          unit: parseAssetUnit(getElementsByTagName(xml2, \"unit\")[0]),\n          upAxis: parseAssetUpAxis(getElementsByTagName(xml2, \"up_axis\")[0])\n        };\n      }\n      function parseAssetUnit(xml2) {\n        if (xml2 !== void 0 && xml2.hasAttribute(\"meter\") === true) {\n          return parseFloat(xml2.getAttribute(\"meter\"));\n        } else {\n          return 1;\n        }\n      }\n      function parseAssetUpAxis(xml2) {\n        return xml2 !== void 0 ? xml2.textContent : \"Y_UP\";\n      }\n      function parseLibrary(xml2, libraryName, nodeName, parser) {\n        var library2 = getElementsByTagName(xml2, libraryName)[0];\n        if (library2 !== void 0) {\n          var elements = getElementsByTagName(library2, nodeName);\n          for (var i = 0; i < elements.length; i++) {\n            parser(elements[i]);\n          }\n        }\n      }\n      function buildLibrary(data, builder) {\n        for (var name in data) {\n          var object = data[name];\n          object.build = builder(data[name]);\n        }\n      }\n      function getBuild(data, builder) {\n        if (data.build !== void 0) return data.build;\n        data.build = builder(data);\n        return data.build;\n      }\n      function parseAnimation(xml2) {\n        var data = {\n          sources: {},\n          samplers: {},\n          channels: {}\n        };\n        var hasChildren = false;\n        for (var i = 0, l = xml2.childNodes.length; i < l; i++) {\n          var child = xml2.childNodes[i];\n          if (child.nodeType !== 1) continue;\n          var id = void 0;\n          switch (child.nodeName) {\n            case \"source\":\n              id = child.getAttribute(\"id\");\n              data.sources[id] = parseSource(child);\n              break;\n            case \"sampler\":\n              id = child.getAttribute(\"id\");\n              data.samplers[id] = parseAnimationSampler(child);\n              break;\n            case \"channel\":\n              id = child.getAttribute(\"target\");\n              data.channels[id] = parseAnimationChannel(child);\n              break;\n            case \"animation\":\n              parseAnimation(child);\n              hasChildren = true;\n              break;\n            default:\n              console.log(child);\n          }\n        }\n        if (hasChildren === false) {\n          library.animations[xml2.getAttribute(\"id\") || MathUtils.generateUUID()] = data;\n        }\n      }\n      function parseAnimationSampler(xml2) {\n        var data = {\n          inputs: {}\n        };\n        for (var i = 0, l = xml2.childNodes.length; i < l; i++) {\n          var child = xml2.childNodes[i];\n          if (child.nodeType !== 1) continue;\n          switch (child.nodeName) {\n            case \"input\":\n              var id = parseId(child.getAttribute(\"source\"));\n              var semantic = child.getAttribute(\"semantic\");\n              data.inputs[semantic] = id;\n              break;\n          }\n        }\n        return data;\n      }\n      function parseAnimationChannel(xml2) {\n        var data = {};\n        var target = xml2.getAttribute(\"target\");\n        var parts = target.split(\"/\");\n        var id = parts.shift();\n        var sid = parts.shift();\n        var arraySyntax = sid.indexOf(\"(\") !== -1;\n        var memberSyntax = sid.indexOf(\".\") !== -1;\n        if (memberSyntax) {\n          parts = sid.split(\".\");\n          sid = parts.shift();\n          data.member = parts.shift();\n        } else if (arraySyntax) {\n          var indices = sid.split(\"(\");\n          sid = indices.shift();\n          for (var i = 0; i < indices.length; i++) {\n            indices[i] = parseInt(indices[i].replace(/\\)/, \"\"));\n          }\n          data.indices = indices;\n        }\n        data.id = id;\n        data.sid = sid;\n        data.arraySyntax = arraySyntax;\n        data.memberSyntax = memberSyntax;\n        data.sampler = parseId(xml2.getAttribute(\"source\"));\n        return data;\n      }\n      function buildAnimation(data) {\n        var tracks = [];\n        var channels = data.channels;\n        var samplers = data.samplers;\n        var sources = data.sources;\n        for (var target in channels) {\n          if (channels.hasOwnProperty(target)) {\n            var channel = channels[target];\n            var sampler = samplers[channel.sampler];\n            var inputId = sampler.inputs.INPUT;\n            var outputId = sampler.inputs.OUTPUT;\n            var inputSource = sources[inputId];\n            var outputSource = sources[outputId];\n            var animation = buildAnimationChannel(channel, inputSource, outputSource);\n            createKeyframeTracks(animation, tracks);\n          }\n        }\n        return tracks;\n      }\n      function getAnimation(id) {\n        return getBuild(library.animations[id], buildAnimation);\n      }\n      function buildAnimationChannel(channel, inputSource, outputSource) {\n        var node = library.nodes[channel.id];\n        var object3D = getNode(node.id);\n        var transform = node.transforms[channel.sid];\n        var defaultMatrix = node.matrix.clone().transpose();\n        var time, stride;\n        var i, il, j, jl;\n        var data = {};\n        switch (transform) {\n          case \"matrix\":\n            for (i = 0, il = inputSource.array.length; i < il; i++) {\n              time = inputSource.array[i];\n              stride = i * outputSource.stride;\n              if (data[time] === void 0) data[time] = {};\n              if (channel.arraySyntax === true) {\n                var value = outputSource.array[stride];\n                var index = channel.indices[0] + 4 * channel.indices[1];\n                data[time][index] = value;\n              } else {\n                for (j = 0, jl = outputSource.stride; j < jl; j++) {\n                  data[time][j] = outputSource.array[stride + j];\n                }\n              }\n            }\n            break;\n          case \"translate\":\n            console.warn('THREE.ColladaLoader: Animation transform type \"%s\" not yet implemented.', transform);\n            break;\n          case \"rotate\":\n            console.warn('THREE.ColladaLoader: Animation transform type \"%s\" not yet implemented.', transform);\n            break;\n          case \"scale\":\n            console.warn('THREE.ColladaLoader: Animation transform type \"%s\" not yet implemented.', transform);\n            break;\n        }\n        var keyframes = prepareAnimationData(data, defaultMatrix);\n        var animation = {\n          name: object3D.uuid,\n          keyframes: keyframes\n        };\n        return animation;\n      }\n      function prepareAnimationData(data, defaultMatrix) {\n        var keyframes = [];\n        for (var time in data) {\n          keyframes.push({\n            time: parseFloat(time),\n            value: data[time]\n          });\n        }\n        keyframes.sort(ascending);\n        for (var i = 0; i < 16; i++) {\n          transformAnimationData(keyframes, i, defaultMatrix.elements[i]);\n        }\n        return keyframes;\n        function ascending(a, b) {\n          return a.time - b.time;\n        }\n      }\n      var position = new Vector3();\n      var scale = new Vector3();\n      var quaternion = new Quaternion();\n      function createKeyframeTracks(animation, tracks) {\n        var keyframes = animation.keyframes;\n        var name = animation.name;\n        var times = [];\n        var positionData = [];\n        var quaternionData = [];\n        var scaleData = [];\n        for (var i = 0, l = keyframes.length; i < l; i++) {\n          var keyframe = keyframes[i];\n          var time = keyframe.time;\n          var value = keyframe.value;\n          matrix.fromArray(value).transpose();\n          matrix.decompose(position, quaternion, scale);\n          times.push(time);\n          positionData.push(position.x, position.y, position.z);\n          quaternionData.push(quaternion.x, quaternion.y, quaternion.z, quaternion.w);\n          scaleData.push(scale.x, scale.y, scale.z);\n        }\n        if (positionData.length > 0) tracks.push(new VectorKeyframeTrack(name + \".position\", times, positionData));\n        if (quaternionData.length > 0) {\n          tracks.push(new QuaternionKeyframeTrack(name + \".quaternion\", times, quaternionData));\n        }\n        if (scaleData.length > 0) tracks.push(new VectorKeyframeTrack(name + \".scale\", times, scaleData));\n        return tracks;\n      }\n      function transformAnimationData(keyframes, property, defaultValue) {\n        var keyframe;\n        var empty = true;\n        var i, l;\n        for (i = 0, l = keyframes.length; i < l; i++) {\n          keyframe = keyframes[i];\n          if (keyframe.value[property] === void 0) {\n            keyframe.value[property] = null;\n          } else {\n            empty = false;\n          }\n        }\n        if (empty === true) {\n          for (i = 0, l = keyframes.length; i < l; i++) {\n            keyframe = keyframes[i];\n            keyframe.value[property] = defaultValue;\n          }\n        } else {\n          createMissingKeyframes(keyframes, property);\n        }\n      }\n      function createMissingKeyframes(keyframes, property) {\n        var prev, next;\n        for (var i = 0, l = keyframes.length; i < l; i++) {\n          var keyframe = keyframes[i];\n          if (keyframe.value[property] === null) {\n            prev = getPrev(keyframes, i, property);\n            next = getNext(keyframes, i, property);\n            if (prev === null) {\n              keyframe.value[property] = next.value[property];\n              continue;\n            }\n            if (next === null) {\n              keyframe.value[property] = prev.value[property];\n              continue;\n            }\n            interpolate(keyframe, prev, next, property);\n          }\n        }\n      }\n      function getPrev(keyframes, i, property) {\n        while (i >= 0) {\n          var keyframe = keyframes[i];\n          if (keyframe.value[property] !== null) return keyframe;\n          i--;\n        }\n        return null;\n      }\n      function getNext(keyframes, i, property) {\n        while (i < keyframes.length) {\n          var keyframe = keyframes[i];\n          if (keyframe.value[property] !== null) return keyframe;\n          i++;\n        }\n        return null;\n      }\n      function interpolate(key, prev, next, property) {\n        if (next.time - prev.time === 0) {\n          key.value[property] = prev.value[property];\n          return;\n        }\n        key.value[property] = (key.time - prev.time) * (next.value[property] - prev.value[property]) / (next.time - prev.time) + prev.value[property];\n      }\n      function parseAnimationClip(xml2) {\n        var data = {\n          name: xml2.getAttribute(\"id\") || \"default\",\n          start: parseFloat(xml2.getAttribute(\"start\") || 0),\n          end: parseFloat(xml2.getAttribute(\"end\") || 0),\n          animations: []\n        };\n        for (var i = 0, l = xml2.childNodes.length; i < l; i++) {\n          var child = xml2.childNodes[i];\n          if (child.nodeType !== 1) continue;\n          switch (child.nodeName) {\n            case \"instance_animation\":\n              data.animations.push(parseId(child.getAttribute(\"url\")));\n              break;\n          }\n        }\n        library.clips[xml2.getAttribute(\"id\")] = data;\n      }\n      function buildAnimationClip(data) {\n        var tracks = [];\n        var name = data.name;\n        var duration = data.end - data.start || -1;\n        var animations2 = data.animations;\n        for (var i = 0, il = animations2.length; i < il; i++) {\n          var animationTracks = getAnimation(animations2[i]);\n          for (var j = 0, jl = animationTracks.length; j < jl; j++) {\n            tracks.push(animationTracks[j]);\n          }\n        }\n        return new AnimationClip(name, duration, tracks);\n      }\n      function getAnimationClip(id) {\n        return getBuild(library.clips[id], buildAnimationClip);\n      }\n      function parseController(xml2) {\n        var data = {};\n        for (var i = 0, l = xml2.childNodes.length; i < l; i++) {\n          var child = xml2.childNodes[i];\n          if (child.nodeType !== 1) continue;\n          switch (child.nodeName) {\n            case \"skin\":\n              data.id = parseId(child.getAttribute(\"source\"));\n              data.skin = parseSkin(child);\n              break;\n            case \"morph\":\n              data.id = parseId(child.getAttribute(\"source\"));\n              console.warn(\"THREE.ColladaLoader: Morph target animation not supported yet.\");\n              break;\n          }\n        }\n        library.controllers[xml2.getAttribute(\"id\")] = data;\n      }\n      function parseSkin(xml2) {\n        var data = {\n          sources: {}\n        };\n        for (var i = 0, l = xml2.childNodes.length; i < l; i++) {\n          var child = xml2.childNodes[i];\n          if (child.nodeType !== 1) continue;\n          switch (child.nodeName) {\n            case \"bind_shape_matrix\":\n              data.bindShapeMatrix = parseFloats(child.textContent);\n              break;\n            case \"source\":\n              var id = child.getAttribute(\"id\");\n              data.sources[id] = parseSource(child);\n              break;\n            case \"joints\":\n              data.joints = parseJoints(child);\n              break;\n            case \"vertex_weights\":\n              data.vertexWeights = parseVertexWeights(child);\n              break;\n          }\n        }\n        return data;\n      }\n      function parseJoints(xml2) {\n        var data = {\n          inputs: {}\n        };\n        for (var i = 0, l = xml2.childNodes.length; i < l; i++) {\n          var child = xml2.childNodes[i];\n          if (child.nodeType !== 1) continue;\n          switch (child.nodeName) {\n            case \"input\":\n              var semantic = child.getAttribute(\"semantic\");\n              var id = parseId(child.getAttribute(\"source\"));\n              data.inputs[semantic] = id;\n              break;\n          }\n        }\n        return data;\n      }\n      function parseVertexWeights(xml2) {\n        var data = {\n          inputs: {}\n        };\n        for (var i = 0, l = xml2.childNodes.length; i < l; i++) {\n          var child = xml2.childNodes[i];\n          if (child.nodeType !== 1) continue;\n          switch (child.nodeName) {\n            case \"input\":\n              var semantic = child.getAttribute(\"semantic\");\n              var id = parseId(child.getAttribute(\"source\"));\n              var offset = parseInt(child.getAttribute(\"offset\"));\n              data.inputs[semantic] = {\n                id: id,\n                offset: offset\n              };\n              break;\n            case \"vcount\":\n              data.vcount = parseInts(child.textContent);\n              break;\n            case \"v\":\n              data.v = parseInts(child.textContent);\n              break;\n          }\n        }\n        return data;\n      }\n      function buildController(data) {\n        var build = {\n          id: data.id\n        };\n        var geometry = library.geometries[build.id];\n        if (data.skin !== void 0) {\n          build.skin = buildSkin(data.skin);\n          geometry.sources.skinIndices = build.skin.indices;\n          geometry.sources.skinWeights = build.skin.weights;\n        }\n        return build;\n      }\n      function buildSkin(data) {\n        var BONE_LIMIT = 4;\n        var build = {\n          joints: [],\n          // this must be an array to preserve the joint order\n          indices: {\n            array: [],\n            stride: BONE_LIMIT\n          },\n          weights: {\n            array: [],\n            stride: BONE_LIMIT\n          }\n        };\n        var sources = data.sources;\n        var vertexWeights = data.vertexWeights;\n        var vcount = vertexWeights.vcount;\n        var v = vertexWeights.v;\n        var jointOffset = vertexWeights.inputs.JOINT.offset;\n        var weightOffset = vertexWeights.inputs.WEIGHT.offset;\n        var jointSource = data.sources[data.joints.inputs.JOINT];\n        var inverseSource = data.sources[data.joints.inputs.INV_BIND_MATRIX];\n        var weights = sources[vertexWeights.inputs.WEIGHT.id].array;\n        var stride = 0;\n        var i, j, l;\n        for (i = 0, l = vcount.length; i < l; i++) {\n          var jointCount = vcount[i];\n          var vertexSkinData = [];\n          for (j = 0; j < jointCount; j++) {\n            var skinIndex = v[stride + jointOffset];\n            var weightId = v[stride + weightOffset];\n            var skinWeight = weights[weightId];\n            vertexSkinData.push({\n              index: skinIndex,\n              weight: skinWeight\n            });\n            stride += 2;\n          }\n          vertexSkinData.sort(descending);\n          for (j = 0; j < BONE_LIMIT; j++) {\n            var d = vertexSkinData[j];\n            if (d !== void 0) {\n              build.indices.array.push(d.index);\n              build.weights.array.push(d.weight);\n            } else {\n              build.indices.array.push(0);\n              build.weights.array.push(0);\n            }\n          }\n        }\n        if (data.bindShapeMatrix) {\n          build.bindMatrix = new Matrix4().fromArray(data.bindShapeMatrix).transpose();\n        } else {\n          build.bindMatrix = new Matrix4().identity();\n        }\n        for (i = 0, l = jointSource.array.length; i < l; i++) {\n          var name = jointSource.array[i];\n          var boneInverse = new Matrix4().fromArray(inverseSource.array, i * inverseSource.stride).transpose();\n          build.joints.push({\n            name: name,\n            boneInverse: boneInverse\n          });\n        }\n        return build;\n        function descending(a, b) {\n          return b.weight - a.weight;\n        }\n      }\n      function getController(id) {\n        return getBuild(library.controllers[id], buildController);\n      }\n      function parseImage(xml2) {\n        var data = {\n          init_from: getElementsByTagName(xml2, \"init_from\")[0].textContent\n        };\n        library.images[xml2.getAttribute(\"id\")] = data;\n      }\n      function buildImage(data) {\n        if (data.build !== void 0) return data.build;\n        return data.init_from;\n      }\n      function getImage(id) {\n        var data = library.images[id];\n        if (data !== void 0) {\n          return getBuild(data, buildImage);\n        }\n        console.warn(\"THREE.ColladaLoader: Couldn't find image with ID:\", id);\n        return null;\n      }\n      function parseEffect(xml2) {\n        var data = {};\n        for (var i = 0, l = xml2.childNodes.length; i < l; i++) {\n          var child = xml2.childNodes[i];\n          if (child.nodeType !== 1) continue;\n          switch (child.nodeName) {\n            case \"profile_COMMON\":\n              data.profile = parseEffectProfileCOMMON(child);\n              break;\n          }\n        }\n        library.effects[xml2.getAttribute(\"id\")] = data;\n      }\n      function parseEffectProfileCOMMON(xml2) {\n        var data = {\n          surfaces: {},\n          samplers: {}\n        };\n        for (var i = 0, l = xml2.childNodes.length; i < l; i++) {\n          var child = xml2.childNodes[i];\n          if (child.nodeType !== 1) continue;\n          switch (child.nodeName) {\n            case \"newparam\":\n              parseEffectNewparam(child, data);\n              break;\n            case \"technique\":\n              data.technique = parseEffectTechnique(child);\n              break;\n            case \"extra\":\n              data.extra = parseEffectExtra(child);\n              break;\n          }\n        }\n        return data;\n      }\n      function parseEffectNewparam(xml2, data) {\n        var sid = xml2.getAttribute(\"sid\");\n        for (var i = 0, l = xml2.childNodes.length; i < l; i++) {\n          var child = xml2.childNodes[i];\n          if (child.nodeType !== 1) continue;\n          switch (child.nodeName) {\n            case \"surface\":\n              data.surfaces[sid] = parseEffectSurface(child);\n              break;\n            case \"sampler2D\":\n              data.samplers[sid] = parseEffectSampler(child);\n              break;\n          }\n        }\n      }\n      function parseEffectSurface(xml2) {\n        var data = {};\n        for (var i = 0, l = xml2.childNodes.length; i < l; i++) {\n          var child = xml2.childNodes[i];\n          if (child.nodeType !== 1) continue;\n          switch (child.nodeName) {\n            case \"init_from\":\n              data.init_from = child.textContent;\n              break;\n          }\n        }\n        return data;\n      }\n      function parseEffectSampler(xml2) {\n        var data = {};\n        for (var i = 0, l = xml2.childNodes.length; i < l; i++) {\n          var child = xml2.childNodes[i];\n          if (child.nodeType !== 1) continue;\n          switch (child.nodeName) {\n            case \"source\":\n              data.source = child.textContent;\n              break;\n          }\n        }\n        return data;\n      }\n      function parseEffectTechnique(xml2) {\n        var data = {};\n        for (var i = 0, l = xml2.childNodes.length; i < l; i++) {\n          var child = xml2.childNodes[i];\n          if (child.nodeType !== 1) continue;\n          switch (child.nodeName) {\n            case \"constant\":\n            case \"lambert\":\n            case \"blinn\":\n            case \"phong\":\n              data.type = child.nodeName;\n              data.parameters = parseEffectParameters(child);\n              break;\n            case \"extra\":\n              data.extra = parseEffectExtra(child);\n              break;\n          }\n        }\n        return data;\n      }\n      function parseEffectParameters(xml2) {\n        var data = {};\n        for (var i = 0, l = xml2.childNodes.length; i < l; i++) {\n          var child = xml2.childNodes[i];\n          if (child.nodeType !== 1) continue;\n          switch (child.nodeName) {\n            case \"emission\":\n            case \"diffuse\":\n            case \"specular\":\n            case \"bump\":\n            case \"ambient\":\n            case \"shininess\":\n            case \"transparency\":\n              data[child.nodeName] = parseEffectParameter(child);\n              break;\n            case \"transparent\":\n              data[child.nodeName] = {\n                opaque: child.hasAttribute(\"opaque\") ? child.getAttribute(\"opaque\") : \"A_ONE\",\n                data: parseEffectParameter(child)\n              };\n              break;\n          }\n        }\n        return data;\n      }\n      function parseEffectParameter(xml2) {\n        var data = {};\n        for (var i = 0, l = xml2.childNodes.length; i < l; i++) {\n          var child = xml2.childNodes[i];\n          if (child.nodeType !== 1) continue;\n          switch (child.nodeName) {\n            case \"color\":\n              data[child.nodeName] = parseFloats(child.textContent);\n              break;\n            case \"float\":\n              data[child.nodeName] = parseFloat(child.textContent);\n              break;\n            case \"texture\":\n              data[child.nodeName] = {\n                id: child.getAttribute(\"texture\"),\n                extra: parseEffectParameterTexture(child)\n              };\n              break;\n          }\n        }\n        return data;\n      }\n      function parseEffectParameterTexture(xml2) {\n        var data = {\n          technique: {}\n        };\n        for (var i = 0, l = xml2.childNodes.length; i < l; i++) {\n          var child = xml2.childNodes[i];\n          if (child.nodeType !== 1) continue;\n          switch (child.nodeName) {\n            case \"extra\":\n              parseEffectParameterTextureExtra(child, data);\n              break;\n          }\n        }\n        return data;\n      }\n      function parseEffectParameterTextureExtra(xml2, data) {\n        for (var i = 0, l = xml2.childNodes.length; i < l; i++) {\n          var child = xml2.childNodes[i];\n          if (child.nodeType !== 1) continue;\n          switch (child.nodeName) {\n            case \"technique\":\n              parseEffectParameterTextureExtraTechnique(child, data);\n              break;\n          }\n        }\n      }\n      function parseEffectParameterTextureExtraTechnique(xml2, data) {\n        for (var i = 0, l = xml2.childNodes.length; i < l; i++) {\n          var child = xml2.childNodes[i];\n          if (child.nodeType !== 1) continue;\n          switch (child.nodeName) {\n            case \"repeatU\":\n            case \"repeatV\":\n            case \"offsetU\":\n            case \"offsetV\":\n              data.technique[child.nodeName] = parseFloat(child.textContent);\n              break;\n            case \"wrapU\":\n            case \"wrapV\":\n              if (child.textContent.toUpperCase() === \"TRUE\") {\n                data.technique[child.nodeName] = 1;\n              } else if (child.textContent.toUpperCase() === \"FALSE\") {\n                data.technique[child.nodeName] = 0;\n              } else {\n                data.technique[child.nodeName] = parseInt(child.textContent);\n              }\n              break;\n            case \"bump\":\n              data[child.nodeName] = parseEffectExtraTechniqueBump(child);\n              break;\n          }\n        }\n      }\n      function parseEffectExtra(xml2) {\n        var data = {};\n        for (var i = 0, l = xml2.childNodes.length; i < l; i++) {\n          var child = xml2.childNodes[i];\n          if (child.nodeType !== 1) continue;\n          switch (child.nodeName) {\n            case \"technique\":\n              data.technique = parseEffectExtraTechnique(child);\n              break;\n          }\n        }\n        return data;\n      }\n      function parseEffectExtraTechnique(xml2) {\n        var data = {};\n        for (var i = 0, l = xml2.childNodes.length; i < l; i++) {\n          var child = xml2.childNodes[i];\n          if (child.nodeType !== 1) continue;\n          switch (child.nodeName) {\n            case \"double_sided\":\n              data[child.nodeName] = parseInt(child.textContent);\n              break;\n            case \"bump\":\n              data[child.nodeName] = parseEffectExtraTechniqueBump(child);\n              break;\n          }\n        }\n        return data;\n      }\n      function parseEffectExtraTechniqueBump(xml2) {\n        var data = {};\n        for (var i = 0, l = xml2.childNodes.length; i < l; i++) {\n          var child = xml2.childNodes[i];\n          if (child.nodeType !== 1) continue;\n          switch (child.nodeName) {\n            case \"texture\":\n              data[child.nodeName] = {\n                id: child.getAttribute(\"texture\"),\n                texcoord: child.getAttribute(\"texcoord\"),\n                extra: parseEffectParameterTexture(child)\n              };\n              break;\n          }\n        }\n        return data;\n      }\n      function buildEffect(data) {\n        return data;\n      }\n      function getEffect(id) {\n        return getBuild(library.effects[id], buildEffect);\n      }\n      function parseMaterial(xml2) {\n        var data = {\n          name: xml2.getAttribute(\"name\")\n        };\n        for (var i = 0, l = xml2.childNodes.length; i < l; i++) {\n          var child = xml2.childNodes[i];\n          if (child.nodeType !== 1) continue;\n          switch (child.nodeName) {\n            case \"instance_effect\":\n              data.url = parseId(child.getAttribute(\"url\"));\n              break;\n          }\n        }\n        library.materials[xml2.getAttribute(\"id\")] = data;\n      }\n      function getTextureLoader(image) {\n        var loader;\n        var extension = image.slice((image.lastIndexOf(\".\") - 1 >>> 0) + 2);\n        extension = extension.toLowerCase();\n        switch (extension) {\n          case \"tga\":\n            loader = tgaLoader;\n            break;\n          default:\n            loader = textureLoader;\n        }\n        return loader;\n      }\n      function buildMaterial(data) {\n        var effect = getEffect(data.url);\n        var technique = effect.profile.technique;\n        var material;\n        switch (technique.type) {\n          case \"phong\":\n          case \"blinn\":\n            material = new MeshPhongMaterial();\n            break;\n          case \"lambert\":\n            material = new MeshLambertMaterial();\n            break;\n          default:\n            material = new MeshBasicMaterial();\n            break;\n        }\n        material.name = data.name || \"\";\n        function getTexture(textureObject) {\n          var sampler = effect.profile.samplers[textureObject.id];\n          var image = null;\n          if (sampler !== void 0) {\n            var surface = effect.profile.surfaces[sampler.source];\n            image = getImage(surface.init_from);\n          } else {\n            console.warn(\"THREE.ColladaLoader: Undefined sampler. Access image directly (see #12530).\");\n            image = getImage(textureObject.id);\n          }\n          if (image !== null) {\n            var loader = getTextureLoader(image);\n            if (loader !== void 0) {\n              var texture = loader.load(image);\n              var extra = textureObject.extra;\n              if (extra !== void 0 && extra.technique !== void 0 && isEmpty(extra.technique) === false) {\n                var technique2 = extra.technique;\n                texture.wrapS = technique2.wrapU ? RepeatWrapping : ClampToEdgeWrapping;\n                texture.wrapT = technique2.wrapV ? RepeatWrapping : ClampToEdgeWrapping;\n                texture.offset.set(technique2.offsetU || 0, technique2.offsetV || 0);\n                texture.repeat.set(technique2.repeatU || 1, technique2.repeatV || 1);\n              } else {\n                texture.wrapS = RepeatWrapping;\n                texture.wrapT = RepeatWrapping;\n              }\n              return texture;\n            } else {\n              console.warn(\"THREE.ColladaLoader: Loader for texture %s not found.\", image);\n              return null;\n            }\n          } else {\n            console.warn(\"THREE.ColladaLoader: Couldn't create texture with ID:\", textureObject.id);\n            return null;\n          }\n        }\n        var parameters = technique.parameters;\n        for (var key in parameters) {\n          var parameter = parameters[key];\n          switch (key) {\n            case \"diffuse\":\n              if (parameter.color) material.color.fromArray(parameter.color);\n              if (parameter.texture) material.map = getTexture(parameter.texture);\n              break;\n            case \"specular\":\n              if (parameter.color && material.specular) material.specular.fromArray(parameter.color);\n              if (parameter.texture) material.specularMap = getTexture(parameter.texture);\n              break;\n            case \"bump\":\n              if (parameter.texture) material.normalMap = getTexture(parameter.texture);\n              break;\n            case \"ambient\":\n              if (parameter.texture) material.lightMap = getTexture(parameter.texture);\n              break;\n            case \"shininess\":\n              if (parameter.float && material.shininess) material.shininess = parameter.float;\n              break;\n            case \"emission\":\n              if (parameter.color && material.emissive) material.emissive.fromArray(parameter.color);\n              if (parameter.texture) material.emissiveMap = getTexture(parameter.texture);\n              break;\n          }\n        }\n        var transparent = parameters[\"transparent\"];\n        var transparency = parameters[\"transparency\"];\n        if (transparency === void 0 && transparent) {\n          transparency = {\n            float: 1\n          };\n        }\n        if (transparent === void 0 && transparency) {\n          transparent = {\n            opaque: \"A_ONE\",\n            data: {\n              color: [1, 1, 1, 1]\n            }\n          };\n        }\n        if (transparent && transparency) {\n          if (transparent.data.texture) {\n            material.transparent = true;\n          } else {\n            var color = transparent.data.color;\n            switch (transparent.opaque) {\n              case \"A_ONE\":\n                material.opacity = color[3] * transparency.float;\n                break;\n              case \"RGB_ZERO\":\n                material.opacity = 1 - color[0] * transparency.float;\n                break;\n              case \"A_ZERO\":\n                material.opacity = 1 - color[3] * transparency.float;\n                break;\n              case \"RGB_ONE\":\n                material.opacity = color[0] * transparency.float;\n                break;\n              default:\n                console.warn('THREE.ColladaLoader: Invalid opaque type \"%s\" of transparent tag.', transparent.opaque);\n            }\n            if (material.opacity < 1) material.transparent = true;\n          }\n        }\n        if (technique.extra !== void 0 && technique.extra.technique !== void 0) {\n          var techniques = technique.extra.technique;\n          for (var k in techniques) {\n            var v = techniques[k];\n            switch (k) {\n              case \"double_sided\":\n                material.side = v === 1 ? DoubleSide : FrontSide;\n                break;\n              case \"bump\":\n                material.normalMap = getTexture(v.texture);\n                material.normalScale = new Vector2(1, 1);\n                break;\n            }\n          }\n        }\n        return material;\n      }\n      function getMaterial(id) {\n        return getBuild(library.materials[id], buildMaterial);\n      }\n      function parseCamera(xml2) {\n        var data = {\n          name: xml2.getAttribute(\"name\")\n        };\n        for (var i = 0, l = xml2.childNodes.length; i < l; i++) {\n          var child = xml2.childNodes[i];\n          if (child.nodeType !== 1) continue;\n          switch (child.nodeName) {\n            case \"optics\":\n              data.optics = parseCameraOptics(child);\n              break;\n          }\n        }\n        library.cameras[xml2.getAttribute(\"id\")] = data;\n      }\n      function parseCameraOptics(xml2) {\n        for (var i = 0; i < xml2.childNodes.length; i++) {\n          var child = xml2.childNodes[i];\n          switch (child.nodeName) {\n            case \"technique_common\":\n              return parseCameraTechnique(child);\n          }\n        }\n        return {};\n      }\n      function parseCameraTechnique(xml2) {\n        var data = {};\n        for (var i = 0; i < xml2.childNodes.length; i++) {\n          var child = xml2.childNodes[i];\n          switch (child.nodeName) {\n            case \"perspective\":\n            case \"orthographic\":\n              data.technique = child.nodeName;\n              data.parameters = parseCameraParameters(child);\n              break;\n          }\n        }\n        return data;\n      }\n      function parseCameraParameters(xml2) {\n        var data = {};\n        for (var i = 0; i < xml2.childNodes.length; i++) {\n          var child = xml2.childNodes[i];\n          switch (child.nodeName) {\n            case \"xfov\":\n            case \"yfov\":\n            case \"xmag\":\n            case \"ymag\":\n            case \"znear\":\n            case \"zfar\":\n            case \"aspect_ratio\":\n              data[child.nodeName] = parseFloat(child.textContent);\n              break;\n          }\n        }\n        return data;\n      }\n      function buildCamera(data) {\n        var camera;\n        switch (data.optics.technique) {\n          case \"perspective\":\n            camera = new PerspectiveCamera(data.optics.parameters.yfov, data.optics.parameters.aspect_ratio, data.optics.parameters.znear, data.optics.parameters.zfar);\n            break;\n          case \"orthographic\":\n            var ymag = data.optics.parameters.ymag;\n            var xmag = data.optics.parameters.xmag;\n            var aspectRatio = data.optics.parameters.aspect_ratio;\n            xmag = xmag === void 0 ? ymag * aspectRatio : xmag;\n            ymag = ymag === void 0 ? xmag / aspectRatio : ymag;\n            xmag *= 0.5;\n            ymag *= 0.5;\n            camera = new OrthographicCamera(-xmag, xmag, ymag, -ymag,\n            // left, right, top, bottom\n            data.optics.parameters.znear, data.optics.parameters.zfar);\n            break;\n          default:\n            camera = new PerspectiveCamera();\n            break;\n        }\n        camera.name = data.name || \"\";\n        return camera;\n      }\n      function getCamera(id) {\n        var data = library.cameras[id];\n        if (data !== void 0) {\n          return getBuild(data, buildCamera);\n        }\n        console.warn(\"THREE.ColladaLoader: Couldn't find camera with ID:\", id);\n        return null;\n      }\n      function parseLight(xml2) {\n        var data = {};\n        for (var i = 0, l = xml2.childNodes.length; i < l; i++) {\n          var child = xml2.childNodes[i];\n          if (child.nodeType !== 1) continue;\n          switch (child.nodeName) {\n            case \"technique_common\":\n              data = parseLightTechnique(child);\n              break;\n          }\n        }\n        library.lights[xml2.getAttribute(\"id\")] = data;\n      }\n      function parseLightTechnique(xml2) {\n        var data = {};\n        for (var i = 0, l = xml2.childNodes.length; i < l; i++) {\n          var child = xml2.childNodes[i];\n          if (child.nodeType !== 1) continue;\n          switch (child.nodeName) {\n            case \"directional\":\n            case \"point\":\n            case \"spot\":\n            case \"ambient\":\n              data.technique = child.nodeName;\n              data.parameters = parseLightParameters(child);\n          }\n        }\n        return data;\n      }\n      function parseLightParameters(xml2) {\n        var data = {};\n        for (var i = 0, l = xml2.childNodes.length; i < l; i++) {\n          var child = xml2.childNodes[i];\n          if (child.nodeType !== 1) continue;\n          switch (child.nodeName) {\n            case \"color\":\n              var array = parseFloats(child.textContent);\n              data.color = new Color().fromArray(array);\n              break;\n            case \"falloff_angle\":\n              data.falloffAngle = parseFloat(child.textContent);\n              break;\n            case \"quadratic_attenuation\":\n              var f = parseFloat(child.textContent);\n              data.distance = f ? Math.sqrt(1 / f) : 0;\n              break;\n          }\n        }\n        return data;\n      }\n      function buildLight(data) {\n        var light;\n        switch (data.technique) {\n          case \"directional\":\n            light = new DirectionalLight();\n            break;\n          case \"point\":\n            light = new PointLight();\n            break;\n          case \"spot\":\n            light = new SpotLight();\n            break;\n          case \"ambient\":\n            light = new AmbientLight();\n            break;\n        }\n        if (data.parameters.color) light.color.copy(data.parameters.color);\n        if (data.parameters.distance) light.distance = data.parameters.distance;\n        return light;\n      }\n      function getLight(id) {\n        var data = library.lights[id];\n        if (data !== void 0) {\n          return getBuild(data, buildLight);\n        }\n        console.warn(\"THREE.ColladaLoader: Couldn't find light with ID:\", id);\n        return null;\n      }\n      function parseGeometry(xml2) {\n        var data = {\n          name: xml2.getAttribute(\"name\"),\n          sources: {},\n          vertices: {},\n          primitives: []\n        };\n        var mesh = getElementsByTagName(xml2, \"mesh\")[0];\n        if (mesh === void 0) return;\n        for (var i = 0; i < mesh.childNodes.length; i++) {\n          var child = mesh.childNodes[i];\n          if (child.nodeType !== 1) continue;\n          var id = child.getAttribute(\"id\");\n          switch (child.nodeName) {\n            case \"source\":\n              data.sources[id] = parseSource(child);\n              break;\n            case \"vertices\":\n              data.vertices = parseGeometryVertices(child);\n              break;\n            case \"polygons\":\n              console.warn(\"THREE.ColladaLoader: Unsupported primitive type: \", child.nodeName);\n              break;\n            case \"lines\":\n            case \"linestrips\":\n            case \"polylist\":\n            case \"triangles\":\n              data.primitives.push(parseGeometryPrimitive(child));\n              break;\n            default:\n              console.log(child);\n          }\n        }\n        library.geometries[xml2.getAttribute(\"id\")] = data;\n      }\n      function parseSource(xml2) {\n        var data = {\n          array: [],\n          stride: 3\n        };\n        for (var i = 0; i < xml2.childNodes.length; i++) {\n          var child = xml2.childNodes[i];\n          if (child.nodeType !== 1) continue;\n          switch (child.nodeName) {\n            case \"float_array\":\n              data.array = parseFloats(child.textContent);\n              break;\n            case \"Name_array\":\n              data.array = parseStrings(child.textContent);\n              break;\n            case \"technique_common\":\n              var accessor = getElementsByTagName(child, \"accessor\")[0];\n              if (accessor !== void 0) {\n                data.stride = parseInt(accessor.getAttribute(\"stride\"));\n              }\n              break;\n          }\n        }\n        return data;\n      }\n      function parseGeometryVertices(xml2) {\n        var data = {};\n        for (var i = 0; i < xml2.childNodes.length; i++) {\n          var child = xml2.childNodes[i];\n          if (child.nodeType !== 1) continue;\n          data[child.getAttribute(\"semantic\")] = parseId(child.getAttribute(\"source\"));\n        }\n        return data;\n      }\n      function parseGeometryPrimitive(xml2) {\n        var primitive = {\n          type: xml2.nodeName,\n          material: xml2.getAttribute(\"material\"),\n          count: parseInt(xml2.getAttribute(\"count\")),\n          inputs: {},\n          stride: 0,\n          hasUV: false\n        };\n        for (var i = 0, l = xml2.childNodes.length; i < l; i++) {\n          var child = xml2.childNodes[i];\n          if (child.nodeType !== 1) continue;\n          switch (child.nodeName) {\n            case \"input\":\n              var id = parseId(child.getAttribute(\"source\"));\n              var semantic = child.getAttribute(\"semantic\");\n              var offset = parseInt(child.getAttribute(\"offset\"));\n              var set = parseInt(child.getAttribute(\"set\"));\n              var inputname = set > 0 ? semantic + set : semantic;\n              primitive.inputs[inputname] = {\n                id: id,\n                offset: offset\n              };\n              primitive.stride = Math.max(primitive.stride, offset + 1);\n              if (semantic === \"TEXCOORD\") primitive.hasUV = true;\n              break;\n            case \"vcount\":\n              primitive.vcount = parseInts(child.textContent);\n              break;\n            case \"p\":\n              primitive.p = parseInts(child.textContent);\n              break;\n          }\n        }\n        return primitive;\n      }\n      function groupPrimitives(primitives) {\n        var build = {};\n        for (var i = 0; i < primitives.length; i++) {\n          var primitive = primitives[i];\n          if (build[primitive.type] === void 0) build[primitive.type] = [];\n          build[primitive.type].push(primitive);\n        }\n        return build;\n      }\n      function checkUVCoordinates(primitives) {\n        var count2 = 0;\n        for (var i = 0, l = primitives.length; i < l; i++) {\n          var primitive = primitives[i];\n          if (primitive.hasUV === true) {\n            count2++;\n          }\n        }\n        if (count2 > 0 && count2 < primitives.length) {\n          primitives.uvsNeedsFix = true;\n        }\n      }\n      function buildGeometry(data) {\n        var build = {};\n        var sources = data.sources;\n        var vertices = data.vertices;\n        var primitives = data.primitives;\n        if (primitives.length === 0) return {};\n        var groupedPrimitives = groupPrimitives(primitives);\n        for (var type in groupedPrimitives) {\n          var primitiveType = groupedPrimitives[type];\n          checkUVCoordinates(primitiveType);\n          build[type] = buildGeometryType(primitiveType, sources, vertices);\n        }\n        return build;\n      }\n      function buildGeometryType(primitives, sources, vertices) {\n        var build = {};\n        var position2 = {\n          array: [],\n          stride: 0\n        };\n        var normal = {\n          array: [],\n          stride: 0\n        };\n        var uv = {\n          array: [],\n          stride: 0\n        };\n        var uv1 = {\n          array: [],\n          stride: 0\n        };\n        var color = {\n          array: [],\n          stride: 0\n        };\n        var skinIndex = {\n          array: [],\n          stride: 4\n        };\n        var skinWeight = {\n          array: [],\n          stride: 4\n        };\n        var geometry = new BufferGeometry();\n        var materialKeys = [];\n        var start = 0;\n        for (var p = 0; p < primitives.length; p++) {\n          var primitive = primitives[p];\n          var inputs = primitive.inputs;\n          var count2 = 0;\n          switch (primitive.type) {\n            case \"lines\":\n            case \"linestrips\":\n              count2 = primitive.count * 2;\n              break;\n            case \"triangles\":\n              count2 = primitive.count * 3;\n              break;\n            case \"polylist\":\n              for (var g = 0; g < primitive.count; g++) {\n                var vc = primitive.vcount[g];\n                switch (vc) {\n                  case 3:\n                    count2 += 3;\n                    break;\n                  case 4:\n                    count2 += 6;\n                    break;\n                  default:\n                    count2 += (vc - 2) * 3;\n                    break;\n                }\n              }\n              break;\n            default:\n              console.warn(\"THREE.ColladaLoader: Unknow primitive type:\", primitive.type);\n          }\n          geometry.addGroup(start, count2, p);\n          start += count2;\n          if (primitive.material) {\n            materialKeys.push(primitive.material);\n          }\n          for (var name in inputs) {\n            var input = inputs[name];\n            switch (name) {\n              case \"VERTEX\":\n                for (var key in vertices) {\n                  var id = vertices[key];\n                  switch (key) {\n                    case \"POSITION\":\n                      var prevLength = position2.array.length;\n                      buildGeometryData(primitive, sources[id], input.offset, position2.array);\n                      position2.stride = sources[id].stride;\n                      if (sources.skinWeights && sources.skinIndices) {\n                        buildGeometryData(primitive, sources.skinIndices, input.offset, skinIndex.array);\n                        buildGeometryData(primitive, sources.skinWeights, input.offset, skinWeight.array);\n                      }\n                      if (primitive.hasUV === false && primitives.uvsNeedsFix === true) {\n                        var count3 = (position2.array.length - prevLength) / position2.stride;\n                        for (var i = 0; i < count3; i++) {\n                          uv.array.push(0, 0);\n                        }\n                      }\n                      break;\n                    case \"NORMAL\":\n                      buildGeometryData(primitive, sources[id], input.offset, normal.array);\n                      normal.stride = sources[id].stride;\n                      break;\n                    case \"COLOR\":\n                      buildGeometryData(primitive, sources[id], input.offset, color.array);\n                      color.stride = sources[id].stride;\n                      break;\n                    case \"TEXCOORD\":\n                      buildGeometryData(primitive, sources[id], input.offset, uv.array);\n                      uv.stride = sources[id].stride;\n                      break;\n                    case \"TEXCOORD1\":\n                      buildGeometryData(primitive, sources[id], input.offset, uv1.array);\n                      uv.stride = sources[id].stride;\n                      break;\n                    default:\n                      console.warn('THREE.ColladaLoader: Semantic \"%s\" not handled in geometry build process.', key);\n                  }\n                }\n                break;\n              case \"NORMAL\":\n                buildGeometryData(primitive, sources[input.id], input.offset, normal.array);\n                normal.stride = sources[input.id].stride;\n                break;\n              case \"COLOR\":\n                buildGeometryData(primitive, sources[input.id], input.offset, color.array);\n                color.stride = sources[input.id].stride;\n                break;\n              case \"TEXCOORD\":\n                buildGeometryData(primitive, sources[input.id], input.offset, uv.array);\n                uv.stride = sources[input.id].stride;\n                break;\n              case \"TEXCOORD1\":\n                buildGeometryData(primitive, sources[input.id], input.offset, uv1.array);\n                uv1.stride = sources[input.id].stride;\n                break;\n            }\n          }\n        }\n        if (position2.array.length > 0) {\n          geometry.setAttribute(\"position\", new Float32BufferAttribute(position2.array, position2.stride));\n        }\n        if (normal.array.length > 0) {\n          geometry.setAttribute(\"normal\", new Float32BufferAttribute(normal.array, normal.stride));\n        }\n        if (color.array.length > 0) geometry.setAttribute(\"color\", new Float32BufferAttribute(color.array, color.stride));\n        if (uv.array.length > 0) geometry.setAttribute(\"uv\", new Float32BufferAttribute(uv.array, uv.stride));\n        if (uv1.array.length > 0) geometry.setAttribute(UV1, new Float32BufferAttribute(uv1.array, uv1.stride));\n        if (skinIndex.array.length > 0) {\n          geometry.setAttribute(\"skinIndex\", new Float32BufferAttribute(skinIndex.array, skinIndex.stride));\n        }\n        if (skinWeight.array.length > 0) {\n          geometry.setAttribute(\"skinWeight\", new Float32BufferAttribute(skinWeight.array, skinWeight.stride));\n        }\n        build.data = geometry;\n        build.type = primitives[0].type;\n        build.materialKeys = materialKeys;\n        return build;\n      }\n      function buildGeometryData(primitive, source, offset, array) {\n        var indices = primitive.p;\n        var stride = primitive.stride;\n        var vcount = primitive.vcount;\n        function pushVector(i) {\n          var index = indices[i + offset] * sourceStride;\n          var length = index + sourceStride;\n          for (; index < length; index++) {\n            array.push(sourceArray[index]);\n          }\n        }\n        var sourceArray = source.array;\n        var sourceStride = source.stride;\n        if (primitive.vcount !== void 0) {\n          var index = 0;\n          for (var i = 0, l = vcount.length; i < l; i++) {\n            var count2 = vcount[i];\n            if (count2 === 4) {\n              var a = index + stride * 0;\n              var b = index + stride * 1;\n              var c = index + stride * 2;\n              var d = index + stride * 3;\n              pushVector(a);\n              pushVector(b);\n              pushVector(d);\n              pushVector(b);\n              pushVector(c);\n              pushVector(d);\n            } else if (count2 === 3) {\n              var _a = index + stride * 0;\n              var _b = index + stride * 1;\n              var _c = index + stride * 2;\n              pushVector(_a);\n              pushVector(_b);\n              pushVector(_c);\n            } else if (count2 > 4) {\n              for (var k = 1, kl = count2 - 2; k <= kl; k++) {\n                var _a2 = index + stride * 0;\n                var _b2 = index + stride * k;\n                var _c2 = index + stride * (k + 1);\n                pushVector(_a2);\n                pushVector(_b2);\n                pushVector(_c2);\n              }\n            }\n            index += stride * count2;\n          }\n        } else {\n          for (var _i = 0, _l = indices.length; _i < _l; _i += stride) {\n            pushVector(_i);\n          }\n        }\n      }\n      function getGeometry(id) {\n        return getBuild(library.geometries[id], buildGeometry);\n      }\n      function parseKinematicsModel(xml2) {\n        var data = {\n          name: xml2.getAttribute(\"name\") || \"\",\n          joints: {},\n          links: []\n        };\n        for (var i = 0; i < xml2.childNodes.length; i++) {\n          var child = xml2.childNodes[i];\n          if (child.nodeType !== 1) continue;\n          switch (child.nodeName) {\n            case \"technique_common\":\n              parseKinematicsTechniqueCommon(child, data);\n              break;\n          }\n        }\n        library.kinematicsModels[xml2.getAttribute(\"id\")] = data;\n      }\n      function buildKinematicsModel(data) {\n        if (data.build !== void 0) return data.build;\n        return data;\n      }\n      function getKinematicsModel(id) {\n        return getBuild(library.kinematicsModels[id], buildKinematicsModel);\n      }\n      function parseKinematicsTechniqueCommon(xml2, data) {\n        for (var i = 0; i < xml2.childNodes.length; i++) {\n          var child = xml2.childNodes[i];\n          if (child.nodeType !== 1) continue;\n          switch (child.nodeName) {\n            case \"joint\":\n              data.joints[child.getAttribute(\"sid\")] = parseKinematicsJoint(child);\n              break;\n            case \"link\":\n              data.links.push(parseKinematicsLink(child));\n              break;\n          }\n        }\n      }\n      function parseKinematicsJoint(xml2) {\n        var data;\n        for (var i = 0; i < xml2.childNodes.length; i++) {\n          var child = xml2.childNodes[i];\n          if (child.nodeType !== 1) continue;\n          switch (child.nodeName) {\n            case \"prismatic\":\n            case \"revolute\":\n              data = parseKinematicsJointParameter(child);\n              break;\n          }\n        }\n        return data;\n      }\n      function parseKinematicsJointParameter(xml2) {\n        var data = {\n          sid: xml2.getAttribute(\"sid\"),\n          name: xml2.getAttribute(\"name\") || \"\",\n          axis: new Vector3(),\n          limits: {\n            min: 0,\n            max: 0\n          },\n          type: xml2.nodeName,\n          static: false,\n          zeroPosition: 0,\n          middlePosition: 0\n        };\n        for (var i = 0; i < xml2.childNodes.length; i++) {\n          var child = xml2.childNodes[i];\n          if (child.nodeType !== 1) continue;\n          switch (child.nodeName) {\n            case \"axis\":\n              var array = parseFloats(child.textContent);\n              data.axis.fromArray(array);\n              break;\n            case \"limits\":\n              var max = child.getElementsByTagName(\"max\")[0];\n              var min = child.getElementsByTagName(\"min\")[0];\n              data.limits.max = parseFloat(max.textContent);\n              data.limits.min = parseFloat(min.textContent);\n              break;\n          }\n        }\n        if (data.limits.min >= data.limits.max) {\n          data.static = true;\n        }\n        data.middlePosition = (data.limits.min + data.limits.max) / 2;\n        return data;\n      }\n      function parseKinematicsLink(xml2) {\n        var data = {\n          sid: xml2.getAttribute(\"sid\"),\n          name: xml2.getAttribute(\"name\") || \"\",\n          attachments: [],\n          transforms: []\n        };\n        for (var i = 0; i < xml2.childNodes.length; i++) {\n          var child = xml2.childNodes[i];\n          if (child.nodeType !== 1) continue;\n          switch (child.nodeName) {\n            case \"attachment_full\":\n              data.attachments.push(parseKinematicsAttachment(child));\n              break;\n            case \"matrix\":\n            case \"translate\":\n            case \"rotate\":\n              data.transforms.push(parseKinematicsTransform(child));\n              break;\n          }\n        }\n        return data;\n      }\n      function parseKinematicsAttachment(xml2) {\n        var data = {\n          joint: xml2.getAttribute(\"joint\").split(\"/\").pop(),\n          transforms: [],\n          links: []\n        };\n        for (var i = 0; i < xml2.childNodes.length; i++) {\n          var child = xml2.childNodes[i];\n          if (child.nodeType !== 1) continue;\n          switch (child.nodeName) {\n            case \"link\":\n              data.links.push(parseKinematicsLink(child));\n              break;\n            case \"matrix\":\n            case \"translate\":\n            case \"rotate\":\n              data.transforms.push(parseKinematicsTransform(child));\n              break;\n          }\n        }\n        return data;\n      }\n      function parseKinematicsTransform(xml2) {\n        var data = {\n          type: xml2.nodeName\n        };\n        var array = parseFloats(xml2.textContent);\n        switch (data.type) {\n          case \"matrix\":\n            data.obj = new Matrix4();\n            data.obj.fromArray(array).transpose();\n            break;\n          case \"translate\":\n            data.obj = new Vector3();\n            data.obj.fromArray(array);\n            break;\n          case \"rotate\":\n            data.obj = new Vector3();\n            data.obj.fromArray(array);\n            data.angle = MathUtils.degToRad(array[3]);\n            break;\n        }\n        return data;\n      }\n      function parsePhysicsModel(xml2) {\n        var data = {\n          name: xml2.getAttribute(\"name\") || \"\",\n          rigidBodies: {}\n        };\n        for (var i = 0; i < xml2.childNodes.length; i++) {\n          var child = xml2.childNodes[i];\n          if (child.nodeType !== 1) continue;\n          switch (child.nodeName) {\n            case \"rigid_body\":\n              data.rigidBodies[child.getAttribute(\"name\")] = {};\n              parsePhysicsRigidBody(child, data.rigidBodies[child.getAttribute(\"name\")]);\n              break;\n          }\n        }\n        library.physicsModels[xml2.getAttribute(\"id\")] = data;\n      }\n      function parsePhysicsRigidBody(xml2, data) {\n        for (var i = 0; i < xml2.childNodes.length; i++) {\n          var child = xml2.childNodes[i];\n          if (child.nodeType !== 1) continue;\n          switch (child.nodeName) {\n            case \"technique_common\":\n              parsePhysicsTechniqueCommon(child, data);\n              break;\n          }\n        }\n      }\n      function parsePhysicsTechniqueCommon(xml2, data) {\n        for (var i = 0; i < xml2.childNodes.length; i++) {\n          var child = xml2.childNodes[i];\n          if (child.nodeType !== 1) continue;\n          switch (child.nodeName) {\n            case \"inertia\":\n              data.inertia = parseFloats(child.textContent);\n              break;\n            case \"mass\":\n              data.mass = parseFloats(child.textContent)[0];\n              break;\n          }\n        }\n      }\n      function parseKinematicsScene(xml2) {\n        var data = {\n          bindJointAxis: []\n        };\n        for (var i = 0; i < xml2.childNodes.length; i++) {\n          var child = xml2.childNodes[i];\n          if (child.nodeType !== 1) continue;\n          switch (child.nodeName) {\n            case \"bind_joint_axis\":\n              data.bindJointAxis.push(parseKinematicsBindJointAxis(child));\n              break;\n          }\n        }\n        library.kinematicsScenes[parseId(xml2.getAttribute(\"url\"))] = data;\n      }\n      function parseKinematicsBindJointAxis(xml2) {\n        var data = {\n          target: xml2.getAttribute(\"target\").split(\"/\").pop()\n        };\n        for (var i = 0; i < xml2.childNodes.length; i++) {\n          var child = xml2.childNodes[i];\n          if (child.nodeType !== 1) continue;\n          switch (child.nodeName) {\n            case \"axis\":\n              var param = child.getElementsByTagName(\"param\")[0];\n              data.axis = param.textContent;\n              var tmpJointIndex = data.axis.split(\"inst_\").pop().split(\"axis\")[0];\n              data.jointIndex = tmpJointIndex.substr(0, tmpJointIndex.length - 1);\n              break;\n          }\n        }\n        return data;\n      }\n      function buildKinematicsScene(data) {\n        if (data.build !== void 0) return data.build;\n        return data;\n      }\n      function getKinematicsScene(id) {\n        return getBuild(library.kinematicsScenes[id], buildKinematicsScene);\n      }\n      function setupKinematics() {\n        var kinematicsModelId = Object.keys(library.kinematicsModels)[0];\n        var kinematicsSceneId = Object.keys(library.kinematicsScenes)[0];\n        var visualSceneId = Object.keys(library.visualScenes)[0];\n        if (kinematicsModelId === void 0 || kinematicsSceneId === void 0) return;\n        var kinematicsModel = getKinematicsModel(kinematicsModelId);\n        var kinematicsScene = getKinematicsScene(kinematicsSceneId);\n        var visualScene = getVisualScene(visualSceneId);\n        var bindJointAxis = kinematicsScene.bindJointAxis;\n        var jointMap = {};\n        for (var i = 0, l = bindJointAxis.length; i < l; i++) {\n          var axis = bindJointAxis[i];\n          var targetElement = collada.querySelector('[sid=\"' + axis.target + '\"]');\n          if (targetElement) {\n            var parentVisualElement = targetElement.parentElement;\n            connect(axis.jointIndex, parentVisualElement);\n          }\n        }\n        function connect(jointIndex, visualElement) {\n          var visualElementName = visualElement.getAttribute(\"name\");\n          var joint = kinematicsModel.joints[jointIndex];\n          visualScene.traverse(function (object) {\n            if (object.name === visualElementName) {\n              jointMap[jointIndex] = {\n                object: object,\n                transforms: buildTransformList(visualElement),\n                joint: joint,\n                position: joint.zeroPosition\n              };\n            }\n          });\n        }\n        var m0 = new Matrix4();\n        kinematics = {\n          joints: kinematicsModel && kinematicsModel.joints,\n          getJointValue: function getJointValue(jointIndex) {\n            var jointData = jointMap[jointIndex];\n            if (jointData) {\n              return jointData.position;\n            } else {\n              console.warn(\"THREE.ColladaLoader: Joint \" + jointIndex + \" doesn't exist.\");\n            }\n          },\n          setJointValue: function setJointValue(jointIndex, value) {\n            var jointData = jointMap[jointIndex];\n            if (jointData) {\n              var joint = jointData.joint;\n              if (value > joint.limits.max || value < joint.limits.min) {\n                console.warn(\"THREE.ColladaLoader: Joint \" + jointIndex + \" value \" + value + \" outside of limits (min: \" + joint.limits.min + \", max: \" + joint.limits.max + \").\");\n              } else if (joint.static) {\n                console.warn(\"THREE.ColladaLoader: Joint \" + jointIndex + \" is static.\");\n              } else {\n                var object = jointData.object;\n                var _axis = joint.axis;\n                var transforms = jointData.transforms;\n                matrix.identity();\n                for (var _i2 = 0; _i2 < transforms.length; _i2++) {\n                  var transform = transforms[_i2];\n                  if (transform.sid && transform.sid.indexOf(jointIndex) !== -1) {\n                    switch (joint.type) {\n                      case \"revolute\":\n                        matrix.multiply(m0.makeRotationAxis(_axis, MathUtils.degToRad(value)));\n                        break;\n                      case \"prismatic\":\n                        matrix.multiply(m0.makeTranslation(_axis.x * value, _axis.y * value, _axis.z * value));\n                        break;\n                      default:\n                        console.warn(\"THREE.ColladaLoader: Unknown joint type: \" + joint.type);\n                        break;\n                    }\n                  } else {\n                    switch (transform.type) {\n                      case \"matrix\":\n                        matrix.multiply(transform.obj);\n                        break;\n                      case \"translate\":\n                        matrix.multiply(m0.makeTranslation(transform.obj.x, transform.obj.y, transform.obj.z));\n                        break;\n                      case \"scale\":\n                        matrix.scale(transform.obj);\n                        break;\n                      case \"rotate\":\n                        matrix.multiply(m0.makeRotationAxis(transform.obj, transform.angle));\n                        break;\n                    }\n                  }\n                }\n                object.matrix.copy(matrix);\n                object.matrix.decompose(object.position, object.quaternion, object.scale);\n                jointMap[jointIndex].position = value;\n              }\n            } else {\n              console.log(\"THREE.ColladaLoader: \" + jointIndex + \" does not exist.\");\n            }\n          }\n        };\n      }\n      function buildTransformList(node) {\n        var transforms = [];\n        var xml2 = collada.querySelector('[id=\"' + node.id + '\"]');\n        for (var i = 0; i < xml2.childNodes.length; i++) {\n          var child = xml2.childNodes[i];\n          if (child.nodeType !== 1) continue;\n          var array = void 0,\n            vector2 = void 0;\n          switch (child.nodeName) {\n            case \"matrix\":\n              array = parseFloats(child.textContent);\n              var matrix2 = new Matrix4().fromArray(array).transpose();\n              transforms.push({\n                sid: child.getAttribute(\"sid\"),\n                type: child.nodeName,\n                obj: matrix2\n              });\n              break;\n            case \"translate\":\n            case \"scale\":\n              array = parseFloats(child.textContent);\n              vector2 = new Vector3().fromArray(array);\n              transforms.push({\n                sid: child.getAttribute(\"sid\"),\n                type: child.nodeName,\n                obj: vector2\n              });\n              break;\n            case \"rotate\":\n              array = parseFloats(child.textContent);\n              vector2 = new Vector3().fromArray(array);\n              var angle = MathUtils.degToRad(array[3]);\n              transforms.push({\n                sid: child.getAttribute(\"sid\"),\n                type: child.nodeName,\n                obj: vector2,\n                angle: angle\n              });\n              break;\n          }\n        }\n        return transforms;\n      }\n      function prepareNodes(xml2) {\n        var elements = xml2.getElementsByTagName(\"node\");\n        for (var i = 0; i < elements.length; i++) {\n          var element = elements[i];\n          if (element.hasAttribute(\"id\") === false) {\n            element.setAttribute(\"id\", generateId());\n          }\n        }\n      }\n      var matrix = new Matrix4();\n      var vector = new Vector3();\n      function parseNode(xml2) {\n        var data = {\n          name: xml2.getAttribute(\"name\") || \"\",\n          type: xml2.getAttribute(\"type\"),\n          id: xml2.getAttribute(\"id\"),\n          sid: xml2.getAttribute(\"sid\"),\n          matrix: new Matrix4(),\n          nodes: [],\n          instanceCameras: [],\n          instanceControllers: [],\n          instanceLights: [],\n          instanceGeometries: [],\n          instanceNodes: [],\n          transforms: {}\n        };\n        for (var i = 0; i < xml2.childNodes.length; i++) {\n          var child = xml2.childNodes[i];\n          if (child.nodeType !== 1) continue;\n          var array = void 0;\n          switch (child.nodeName) {\n            case \"node\":\n              data.nodes.push(child.getAttribute(\"id\"));\n              parseNode(child);\n              break;\n            case \"instance_camera\":\n              data.instanceCameras.push(parseId(child.getAttribute(\"url\")));\n              break;\n            case \"instance_controller\":\n              data.instanceControllers.push(parseNodeInstance(child));\n              break;\n            case \"instance_light\":\n              data.instanceLights.push(parseId(child.getAttribute(\"url\")));\n              break;\n            case \"instance_geometry\":\n              data.instanceGeometries.push(parseNodeInstance(child));\n              break;\n            case \"instance_node\":\n              data.instanceNodes.push(parseId(child.getAttribute(\"url\")));\n              break;\n            case \"matrix\":\n              array = parseFloats(child.textContent);\n              data.matrix.multiply(matrix.fromArray(array).transpose());\n              data.transforms[child.getAttribute(\"sid\")] = child.nodeName;\n              break;\n            case \"translate\":\n              array = parseFloats(child.textContent);\n              vector.fromArray(array);\n              data.matrix.multiply(matrix.makeTranslation(vector.x, vector.y, vector.z));\n              data.transforms[child.getAttribute(\"sid\")] = child.nodeName;\n              break;\n            case \"rotate\":\n              array = parseFloats(child.textContent);\n              var angle = MathUtils.degToRad(array[3]);\n              data.matrix.multiply(matrix.makeRotationAxis(vector.fromArray(array), angle));\n              data.transforms[child.getAttribute(\"sid\")] = child.nodeName;\n              break;\n            case \"scale\":\n              array = parseFloats(child.textContent);\n              data.matrix.scale(vector.fromArray(array));\n              data.transforms[child.getAttribute(\"sid\")] = child.nodeName;\n              break;\n            case \"extra\":\n              break;\n            default:\n              console.log(child);\n          }\n        }\n        if (hasNode(data.id)) {\n          console.warn(\"THREE.ColladaLoader: There is already a node with ID %s. Exclude current node from further processing.\", data.id);\n        } else {\n          library.nodes[data.id] = data;\n        }\n        return data;\n      }\n      function parseNodeInstance(xml2) {\n        var data = {\n          id: parseId(xml2.getAttribute(\"url\")),\n          materials: {},\n          skeletons: []\n        };\n        for (var i = 0; i < xml2.childNodes.length; i++) {\n          var child = xml2.childNodes[i];\n          switch (child.nodeName) {\n            case \"bind_material\":\n              var instances = child.getElementsByTagName(\"instance_material\");\n              for (var j = 0; j < instances.length; j++) {\n                var instance = instances[j];\n                var symbol = instance.getAttribute(\"symbol\");\n                var target = instance.getAttribute(\"target\");\n                data.materials[symbol] = parseId(target);\n              }\n              break;\n            case \"skeleton\":\n              data.skeletons.push(parseId(child.textContent));\n              break;\n          }\n        }\n        return data;\n      }\n      function buildSkeleton(skeletons, joints) {\n        var boneData = [];\n        var sortedBoneData = [];\n        var i, j, data;\n        for (i = 0; i < skeletons.length; i++) {\n          var skeleton = skeletons[i];\n          var root = void 0;\n          if (hasNode(skeleton)) {\n            root = getNode(skeleton);\n            buildBoneHierarchy(root, joints, boneData);\n          } else if (hasVisualScene(skeleton)) {\n            var visualScene = library.visualScenes[skeleton];\n            var children = visualScene.children;\n            for (var j2 = 0; j2 < children.length; j2++) {\n              var child = children[j2];\n              if (child.type === \"JOINT\") {\n                var root2 = getNode(child.id);\n                buildBoneHierarchy(root2, joints, boneData);\n              }\n            }\n          } else {\n            console.error(\"THREE.ColladaLoader: Unable to find root bone of skeleton with ID:\", skeleton);\n          }\n        }\n        for (i = 0; i < joints.length; i++) {\n          for (j = 0; j < boneData.length; j++) {\n            data = boneData[j];\n            if (data.bone.name === joints[i].name) {\n              sortedBoneData[i] = data;\n              data.processed = true;\n              break;\n            }\n          }\n        }\n        for (i = 0; i < boneData.length; i++) {\n          data = boneData[i];\n          if (data.processed === false) {\n            sortedBoneData.push(data);\n            data.processed = true;\n          }\n        }\n        var bones = [];\n        var boneInverses = [];\n        for (i = 0; i < sortedBoneData.length; i++) {\n          data = sortedBoneData[i];\n          bones.push(data.bone);\n          boneInverses.push(data.boneInverse);\n        }\n        return new Skeleton(bones, boneInverses);\n      }\n      function buildBoneHierarchy(root, joints, boneData) {\n        root.traverse(function (object) {\n          if (object.isBone === true) {\n            var boneInverse;\n            for (var i = 0; i < joints.length; i++) {\n              var joint = joints[i];\n              if (joint.name === object.name) {\n                boneInverse = joint.boneInverse;\n                break;\n              }\n            }\n            if (boneInverse === void 0) {\n              boneInverse = new Matrix4();\n            }\n            boneData.push({\n              bone: object,\n              boneInverse: boneInverse,\n              processed: false\n            });\n          }\n        });\n      }\n      function buildNode(data) {\n        var objects = [];\n        var matrix2 = data.matrix;\n        var nodes = data.nodes;\n        var type = data.type;\n        var instanceCameras = data.instanceCameras;\n        var instanceControllers = data.instanceControllers;\n        var instanceLights = data.instanceLights;\n        var instanceGeometries = data.instanceGeometries;\n        var instanceNodes = data.instanceNodes;\n        for (var i = 0, l = nodes.length; i < l; i++) {\n          objects.push(getNode(nodes[i]));\n        }\n        for (var _i3 = 0, _l2 = instanceCameras.length; _i3 < _l2; _i3++) {\n          var instanceCamera = getCamera(instanceCameras[_i3]);\n          if (instanceCamera !== null) {\n            objects.push(instanceCamera.clone());\n          }\n        }\n        for (var _i4 = 0, _l3 = instanceControllers.length; _i4 < _l3; _i4++) {\n          var instance = instanceControllers[_i4];\n          var controller = getController(instance.id);\n          var geometries = getGeometry(controller.id);\n          var newObjects = buildObjects(geometries, instance.materials);\n          var skeletons = instance.skeletons;\n          var joints = controller.skin.joints;\n          var skeleton = buildSkeleton(skeletons, joints);\n          for (var j = 0, jl = newObjects.length; j < jl; j++) {\n            var object2 = newObjects[j];\n            if (object2.isSkinnedMesh) {\n              object2.bind(skeleton, controller.skin.bindMatrix);\n              object2.normalizeSkinWeights();\n            }\n            objects.push(object2);\n          }\n        }\n        for (var _i5 = 0, _l4 = instanceLights.length; _i5 < _l4; _i5++) {\n          var instanceLight = getLight(instanceLights[_i5]);\n          if (instanceLight !== null) {\n            objects.push(instanceLight.clone());\n          }\n        }\n        for (var _i6 = 0, _l5 = instanceGeometries.length; _i6 < _l5; _i6++) {\n          var _instance = instanceGeometries[_i6];\n          var _geometries = getGeometry(_instance.id);\n          var _newObjects = buildObjects(_geometries, _instance.materials);\n          for (var _j = 0, _jl = _newObjects.length; _j < _jl; _j++) {\n            objects.push(_newObjects[_j]);\n          }\n        }\n        for (var _i7 = 0, _l6 = instanceNodes.length; _i7 < _l6; _i7++) {\n          objects.push(getNode(instanceNodes[_i7]).clone());\n        }\n        var object;\n        if (nodes.length === 0 && objects.length === 1) {\n          object = objects[0];\n        } else {\n          object = type === \"JOINT\" ? new Bone() : new Group();\n          for (var _i8 = 0; _i8 < objects.length; _i8++) {\n            object.add(objects[_i8]);\n          }\n        }\n        object.name = type === \"JOINT\" ? data.sid : data.name;\n        object.matrix.copy(matrix2);\n        object.matrix.decompose(object.position, object.quaternion, object.scale);\n        return object;\n      }\n      var fallbackMaterial = new MeshBasicMaterial({\n        color: 16711935\n      });\n      function resolveMaterialBinding(keys, instanceMaterials) {\n        var materials = [];\n        for (var i = 0, l = keys.length; i < l; i++) {\n          var id = instanceMaterials[keys[i]];\n          if (id === void 0) {\n            console.warn(\"THREE.ColladaLoader: Material with key %s not found. Apply fallback material.\", keys[i]);\n            materials.push(fallbackMaterial);\n          } else {\n            materials.push(getMaterial(id));\n          }\n        }\n        return materials;\n      }\n      function buildObjects(geometries, instanceMaterials) {\n        var objects = [];\n        for (var type in geometries) {\n          var geometry = geometries[type];\n          var materials = resolveMaterialBinding(geometry.materialKeys, instanceMaterials);\n          if (materials.length === 0) {\n            if (type === \"lines\" || type === \"linestrips\") {\n              materials.push(new LineBasicMaterial());\n            } else {\n              materials.push(new MeshPhongMaterial());\n            }\n          }\n          var skinning = geometry.data.attributes.skinIndex !== void 0;\n          var material = materials.length === 1 ? materials[0] : materials;\n          var object = void 0;\n          switch (type) {\n            case \"lines\":\n              object = new LineSegments(geometry.data, material);\n              break;\n            case \"linestrips\":\n              object = new Line(geometry.data, material);\n              break;\n            case \"triangles\":\n            case \"polylist\":\n              if (skinning) {\n                object = new SkinnedMesh(geometry.data, material);\n              } else {\n                object = new Mesh(geometry.data, material);\n              }\n              break;\n          }\n          objects.push(object);\n        }\n        return objects;\n      }\n      function hasNode(id) {\n        return library.nodes[id] !== void 0;\n      }\n      function getNode(id) {\n        return getBuild(library.nodes[id], buildNode);\n      }\n      function parseVisualScene(xml2) {\n        var data = {\n          name: xml2.getAttribute(\"name\"),\n          children: []\n        };\n        prepareNodes(xml2);\n        var elements = getElementsByTagName(xml2, \"node\");\n        for (var i = 0; i < elements.length; i++) {\n          data.children.push(parseNode(elements[i]));\n        }\n        library.visualScenes[xml2.getAttribute(\"id\")] = data;\n      }\n      function buildVisualScene(data) {\n        var group = new Group();\n        group.name = data.name;\n        var children = data.children;\n        for (var i = 0; i < children.length; i++) {\n          var child = children[i];\n          group.add(getNode(child.id));\n        }\n        return group;\n      }\n      function hasVisualScene(id) {\n        return library.visualScenes[id] !== void 0;\n      }\n      function getVisualScene(id) {\n        return getBuild(library.visualScenes[id], buildVisualScene);\n      }\n      function parseScene(xml2) {\n        var instance = getElementsByTagName(xml2, \"instance_visual_scene\")[0];\n        return getVisualScene(parseId(instance.getAttribute(\"url\")));\n      }\n      function setupAnimations() {\n        var clips = library.clips;\n        if (isEmpty(clips) === true) {\n          if (isEmpty(library.animations) === false) {\n            var tracks = [];\n            for (var id in library.animations) {\n              var animationTracks = getAnimation(id);\n              for (var i = 0, l = animationTracks.length; i < l; i++) {\n                tracks.push(animationTracks[i]);\n              }\n            }\n            animations.push(new AnimationClip(\"default\", -1, tracks));\n          }\n        } else {\n          for (var _id in clips) {\n            animations.push(getAnimationClip(_id));\n          }\n        }\n      }\n      function parserErrorToText(parserError2) {\n        var result = \"\";\n        var stack = [parserError2];\n        while (stack.length) {\n          var node = stack.shift();\n          if (node.nodeType === Node.TEXT_NODE) {\n            result += node.textContent;\n          } else {\n            result += \"\\n\";\n            stack.push.apply(stack, node.childNodes);\n          }\n        }\n        return result.trim();\n      }\n      if (text.length === 0) {\n        return {\n          scene: new Scene()\n        };\n      }\n      var xml = new DOMParser().parseFromString(text, \"application/xml\");\n      var collada = getElementsByTagName(xml, \"COLLADA\")[0];\n      var parserError = xml.getElementsByTagName(\"parsererror\")[0];\n      if (parserError !== void 0) {\n        var errorElement = getElementsByTagName(parserError, \"div\")[0];\n        var errorText;\n        if (errorElement) {\n          errorText = errorElement.textContent;\n        } else {\n          errorText = parserErrorToText(parserError);\n        }\n        console.error(\"THREE.ColladaLoader: Failed to parse collada file.\\n\", errorText);\n        return null;\n      }\n      var version = collada.getAttribute(\"version\");\n      console.log(\"THREE.ColladaLoader: File version\", version);\n      var asset = parseAsset(getElementsByTagName(collada, \"asset\")[0]);\n      var textureLoader = new TextureLoader(this.manager);\n      textureLoader.setPath(this.resourcePath || path).setCrossOrigin(this.crossOrigin);\n      var tgaLoader;\n      if (TGALoader) {\n        tgaLoader = new TGALoader(this.manager);\n        tgaLoader.setPath(this.resourcePath || path);\n      }\n      var animations = [];\n      var kinematics = {};\n      var count = 0;\n      var library = {\n        animations: {},\n        clips: {},\n        controllers: {},\n        images: {},\n        effects: {},\n        materials: {},\n        cameras: {},\n        lights: {},\n        geometries: {},\n        nodes: {},\n        visualScenes: {},\n        kinematicsModels: {},\n        physicsModels: {},\n        kinematicsScenes: {}\n      };\n      parseLibrary(collada, \"library_animations\", \"animation\", parseAnimation);\n      parseLibrary(collada, \"library_animation_clips\", \"animation_clip\", parseAnimationClip);\n      parseLibrary(collada, \"library_controllers\", \"controller\", parseController);\n      parseLibrary(collada, \"library_images\", \"image\", parseImage);\n      parseLibrary(collada, \"library_effects\", \"effect\", parseEffect);\n      parseLibrary(collada, \"library_materials\", \"material\", parseMaterial);\n      parseLibrary(collada, \"library_cameras\", \"camera\", parseCamera);\n      parseLibrary(collada, \"library_lights\", \"light\", parseLight);\n      parseLibrary(collada, \"library_geometries\", \"geometry\", parseGeometry);\n      parseLibrary(collada, \"library_nodes\", \"node\", parseNode);\n      parseLibrary(collada, \"library_visual_scenes\", \"visual_scene\", parseVisualScene);\n      parseLibrary(collada, \"library_kinematics_models\", \"kinematics_model\", parseKinematicsModel);\n      parseLibrary(collada, \"library_physics_models\", \"physics_model\", parsePhysicsModel);\n      parseLibrary(collada, \"scene\", \"instance_kinematics_scene\", parseKinematicsScene);\n      buildLibrary(library.animations, buildAnimation);\n      buildLibrary(library.clips, buildAnimationClip);\n      buildLibrary(library.controllers, buildController);\n      buildLibrary(library.images, buildImage);\n      buildLibrary(library.effects, buildEffect);\n      buildLibrary(library.materials, buildMaterial);\n      buildLibrary(library.cameras, buildCamera);\n      buildLibrary(library.lights, buildLight);\n      buildLibrary(library.geometries, buildGeometry);\n      buildLibrary(library.visualScenes, buildVisualScene);\n      setupAnimations();\n      setupKinematics();\n      var scene = parseScene(getElementsByTagName(collada, \"scene\")[0]);\n      scene.animations = animations;\n      if (asset.upAxis === \"Z_UP\") {\n        scene.quaternion.setFromEuler(new Euler(-Math.PI / 2, 0, 0));\n      }\n      scene.scale.multiplyScalar(asset.unit);\n      return {\n        get animations() {\n          console.warn(\"THREE.ColladaLoader: Please access animations over scene.animations now.\");\n          return animations;\n        },\n        kinematics: kinematics,\n        library: library,\n        scene: scene\n      };\n    }\n  }]);\n  return ColladaLoader;\n}(Loader);\nexport { ColladaLoader };","map":{"version":3,"names":["ColladaLoader","_Loader","_inherits","_super","_createSuper","manager","_classCallCheck","call","_createClass","key","value","load","url","onLoad","onProgress","onError","scope","path","LoaderUtils","extractUrlBase","loader","FileLoader","setPath","setRequestHeader","requestHeader","setWithCredentials","withCredentials","text","parse","e","console","error","itemError","getElementsByTagName","xml2","name","array","childNodes","i","l","length","child","nodeName","push","parseStrings","text2","parts","trim","split","Array","parseFloats","parseFloat","parseInts","parseInt","parseId","substring","generateId","count","isEmpty","object","Object","keys","parseAsset","unit","parseAssetUnit","upAxis","parseAssetUpAxis","hasAttribute","getAttribute","textContent","parseLibrary","libraryName","parser","library2","elements","buildLibrary","data","builder","build","getBuild","parseAnimation","sources","samplers","channels","hasChildren","nodeType","id","parseSource","parseAnimationSampler","parseAnimationChannel","log","library","animations","MathUtils","generateUUID","inputs","semantic","target","shift","sid","arraySyntax","indexOf","memberSyntax","member","indices","replace","sampler","buildAnimation","tracks","hasOwnProperty","channel","inputId","INPUT","outputId","OUTPUT","inputSource","outputSource","animation","buildAnimationChannel","createKeyframeTracks","getAnimation","node","nodes","object3D","getNode","transform","transforms","defaultMatrix","matrix","clone","transpose","time","stride","il","j","jl","index","warn","keyframes","prepareAnimationData","uuid","sort","ascending","transformAnimationData","a","b","position","Vector3","scale","quaternion","Quaternion","times","positionData","quaternionData","scaleData","keyframe","fromArray","decompose","x","y","z","w","VectorKeyframeTrack","QuaternionKeyframeTrack","property","defaultValue","empty","createMissingKeyframes","prev","next","getPrev","getNext","interpolate","parseAnimationClip","start","end","clips","buildAnimationClip","duration","animations2","animationTracks","AnimationClip","getAnimationClip","parseController","skin","parseSkin","controllers","bindShapeMatrix","joints","parseJoints","vertexWeights","parseVertexWeights","offset","vcount","v","buildController","geometry","geometries","buildSkin","skinIndices","skinWeights","weights","BONE_LIMIT","jointOffset","JOINT","weightOffset","WEIGHT","jointSource","inverseSource","INV_BIND_MATRIX","jointCount","vertexSkinData","skinIndex","weightId","skinWeight","weight","descending","d","bindMatrix","Matrix4","identity","boneInverse","getController","parseImage","init_from","images","buildImage","getImage","parseEffect","profile","parseEffectProfileCOMMON","effects","surfaces","parseEffectNewparam","technique","parseEffectTechnique","extra","parseEffectExtra","parseEffectSurface","parseEffectSampler","source","type","parameters","parseEffectParameters","parseEffectParameter","opaque","parseEffectParameterTexture","parseEffectParameterTextureExtra","parseEffectParameterTextureExtraTechnique","toUpperCase","parseEffectExtraTechniqueBump","parseEffectExtraTechnique","texcoord","buildEffect","getEffect","parseMaterial","materials","getTextureLoader","image","extension","slice","lastIndexOf","toLowerCase","tgaLoader","textureLoader","buildMaterial","effect","material","MeshPhongMaterial","MeshLambertMaterial","MeshBasicMaterial","getTexture","textureObject","surface","texture","technique2","wrapS","wrapU","RepeatWrapping","ClampToEdgeWrapping","wrapT","wrapV","set","offsetU","offsetV","repeat","repeatU","repeatV","parameter","color","map","specular","specularMap","normalMap","lightMap","float","shininess","emissive","emissiveMap","transparent","transparency","opacity","techniques","k","side","DoubleSide","FrontSide","normalScale","Vector2","getMaterial","parseCamera","optics","parseCameraOptics","cameras","parseCameraTechnique","parseCameraParameters","buildCamera","camera","PerspectiveCamera","yfov","aspect_ratio","znear","zfar","ymag","xmag","aspectRatio","OrthographicCamera","getCamera","parseLight","parseLightTechnique","lights","parseLightParameters","Color","falloffAngle","f","distance","Math","sqrt","buildLight","light","DirectionalLight","PointLight","SpotLight","AmbientLight","copy","getLight","parseGeometry","vertices","primitives","mesh","parseGeometryVertices","parseGeometryPrimitive","accessor","primitive","hasUV","inputname","max","p","groupPrimitives","checkUVCoordinates","count2","uvsNeedsFix","buildGeometry","groupedPrimitives","primitiveType","buildGeometryType","position2","normal","uv","uv1","BufferGeometry","materialKeys","g","vc","addGroup","input","prevLength","buildGeometryData","count3","setAttribute","Float32BufferAttribute","UV1","pushVector","sourceStride","sourceArray","c","kl","getGeometry","parseKinematicsModel","links","parseKinematicsTechniqueCommon","kinematicsModels","buildKinematicsModel","getKinematicsModel","parseKinematicsJoint","parseKinematicsLink","parseKinematicsJointParameter","axis","limits","min","static","zeroPosition","middlePosition","attachments","parseKinematicsAttachment","parseKinematicsTransform","joint","pop","obj","angle","degToRad","parsePhysicsModel","rigidBodies","parsePhysicsRigidBody","physicsModels","parsePhysicsTechniqueCommon","inertia","mass","parseKinematicsScene","bindJointAxis","parseKinematicsBindJointAxis","kinematicsScenes","param","tmpJointIndex","jointIndex","substr","buildKinematicsScene","getKinematicsScene","setupKinematics","kinematicsModelId","kinematicsSceneId","visualSceneId","visualScenes","kinematicsModel","kinematicsScene","visualScene","getVisualScene","jointMap","targetElement","collada","querySelector","parentVisualElement","parentElement","connect","visualElement","visualElementName","traverse","buildTransformList","m0","kinematics","getJointValue","jointData","setJointValue","multiply","makeRotationAxis","makeTranslation","vector2","matrix2","prepareNodes","element","vector","parseNode","instanceCameras","instanceControllers","instanceLights","instanceGeometries","instanceNodes","parseNodeInstance","hasNode","skeletons","instances","instance","symbol","buildSkeleton","boneData","sortedBoneData","skeleton","root","buildBoneHierarchy","hasVisualScene","children","j2","root2","bone","processed","bones","boneInverses","Skeleton","isBone","buildNode","objects","instanceCamera","controller","newObjects","buildObjects","object2","isSkinnedMesh","bind","normalizeSkinWeights","instanceLight","Bone","Group","add","fallbackMaterial","resolveMaterialBinding","instanceMaterials","LineBasicMaterial","skinning","attributes","LineSegments","Line","SkinnedMesh","Mesh","parseVisualScene","buildVisualScene","group","parseScene","setupAnimations","parserErrorToText","parserError2","result","stack","Node","TEXT_NODE","apply","scene","Scene","xml","DOMParser","parseFromString","parserError","errorElement","errorText","version","asset","TextureLoader","resourcePath","setCrossOrigin","crossOrigin","TGALoader","setFromEuler","Euler","PI","multiplyScalar","Loader"],"sources":["C:\\Users\\Nayyu\\Desktop\\skibidai-public-build\\node_modules\\src\\loaders\\ColladaLoader.js"],"sourcesContent":["import {\n  AmbientLight,\n  AnimationClip,\n  Bone,\n  BufferGeometry,\n  ClampToEdgeWrapping,\n  Color,\n  DirectionalLight,\n  DoubleSide,\n  Euler,\n  FileLoader,\n  Float32BufferAttribute,\n  FrontSide,\n  Group,\n  Line,\n  LineBasicMaterial,\n  LineSegments,\n  Loader,\n  LoaderUtils,\n  MathUtils,\n  Matrix4,\n  Mesh,\n  MeshBasicMaterial,\n  MeshLambertMaterial,\n  MeshPhongMaterial,\n  OrthographicCamera,\n  PerspectiveCamera,\n  PointLight,\n  Quaternion,\n  QuaternionKeyframeTrack,\n  RepeatWrapping,\n  Scene,\n  Skeleton,\n  SkinnedMesh,\n  SpotLight,\n  TextureLoader,\n  Vector2,\n  Vector3,\n  VectorKeyframeTrack,\n} from 'three'\nimport { TGALoader } from '../loaders/TGALoader'\nimport { UV1 } from '../_polyfill/uv1'\n\nclass ColladaLoader extends Loader {\n  constructor(manager) {\n    super(manager)\n  }\n\n  load(url, onLoad, onProgress, onError) {\n    const scope = this\n\n    const path = scope.path === '' ? LoaderUtils.extractUrlBase(url) : scope.path\n\n    const loader = new FileLoader(scope.manager)\n    loader.setPath(scope.path)\n    loader.setRequestHeader(scope.requestHeader)\n    loader.setWithCredentials(scope.withCredentials)\n    loader.load(\n      url,\n      function (text) {\n        try {\n          onLoad(scope.parse(text, path))\n        } catch (e) {\n          if (onError) {\n            onError(e)\n          } else {\n            console.error(e)\n          }\n\n          scope.manager.itemError(url)\n        }\n      },\n      onProgress,\n      onError,\n    )\n  }\n\n  parse(text, path) {\n    function getElementsByTagName(xml, name) {\n      // Non recursive xml.getElementsByTagName() ...\n\n      const array = []\n      const childNodes = xml.childNodes\n\n      for (let i = 0, l = childNodes.length; i < l; i++) {\n        const child = childNodes[i]\n\n        if (child.nodeName === name) {\n          array.push(child)\n        }\n      }\n\n      return array\n    }\n\n    function parseStrings(text) {\n      if (text.length === 0) return []\n\n      const parts = text.trim().split(/\\s+/)\n      const array = new Array(parts.length)\n\n      for (let i = 0, l = parts.length; i < l; i++) {\n        array[i] = parts[i]\n      }\n\n      return array\n    }\n\n    function parseFloats(text) {\n      if (text.length === 0) return []\n\n      const parts = text.trim().split(/\\s+/)\n      const array = new Array(parts.length)\n\n      for (let i = 0, l = parts.length; i < l; i++) {\n        array[i] = parseFloat(parts[i])\n      }\n\n      return array\n    }\n\n    function parseInts(text) {\n      if (text.length === 0) return []\n\n      const parts = text.trim().split(/\\s+/)\n      const array = new Array(parts.length)\n\n      for (let i = 0, l = parts.length; i < l; i++) {\n        array[i] = parseInt(parts[i])\n      }\n\n      return array\n    }\n\n    function parseId(text) {\n      return text.substring(1)\n    }\n\n    function generateId() {\n      return 'three_default_' + count++\n    }\n\n    function isEmpty(object) {\n      return Object.keys(object).length === 0\n    }\n\n    // asset\n\n    function parseAsset(xml) {\n      return {\n        unit: parseAssetUnit(getElementsByTagName(xml, 'unit')[0]),\n        upAxis: parseAssetUpAxis(getElementsByTagName(xml, 'up_axis')[0]),\n      }\n    }\n\n    function parseAssetUnit(xml) {\n      if (xml !== undefined && xml.hasAttribute('meter') === true) {\n        return parseFloat(xml.getAttribute('meter'))\n      } else {\n        return 1 // default 1 meter\n      }\n    }\n\n    function parseAssetUpAxis(xml) {\n      return xml !== undefined ? xml.textContent : 'Y_UP'\n    }\n\n    // library\n\n    function parseLibrary(xml, libraryName, nodeName, parser) {\n      const library = getElementsByTagName(xml, libraryName)[0]\n\n      if (library !== undefined) {\n        const elements = getElementsByTagName(library, nodeName)\n\n        for (let i = 0; i < elements.length; i++) {\n          parser(elements[i])\n        }\n      }\n    }\n\n    function buildLibrary(data, builder) {\n      for (const name in data) {\n        const object = data[name]\n        object.build = builder(data[name])\n      }\n    }\n\n    // get\n\n    function getBuild(data, builder) {\n      if (data.build !== undefined) return data.build\n\n      data.build = builder(data)\n\n      return data.build\n    }\n\n    // animation\n\n    function parseAnimation(xml) {\n      const data = {\n        sources: {},\n        samplers: {},\n        channels: {},\n      }\n\n      let hasChildren = false\n\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        const child = xml.childNodes[i]\n\n        if (child.nodeType !== 1) continue\n\n        let id\n\n        switch (child.nodeName) {\n          case 'source':\n            id = child.getAttribute('id')\n            data.sources[id] = parseSource(child)\n            break\n\n          case 'sampler':\n            id = child.getAttribute('id')\n            data.samplers[id] = parseAnimationSampler(child)\n            break\n\n          case 'channel':\n            id = child.getAttribute('target')\n            data.channels[id] = parseAnimationChannel(child)\n            break\n\n          case 'animation':\n            // hierarchy of related animations\n            parseAnimation(child)\n            hasChildren = true\n            break\n\n          default:\n            console.log(child)\n        }\n      }\n\n      if (hasChildren === false) {\n        // since 'id' attributes can be optional, it's necessary to generate a UUID for unqiue assignment\n\n        library.animations[xml.getAttribute('id') || MathUtils.generateUUID()] = data\n      }\n    }\n\n    function parseAnimationSampler(xml) {\n      const data = {\n        inputs: {},\n      }\n\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        const child = xml.childNodes[i]\n\n        if (child.nodeType !== 1) continue\n\n        switch (child.nodeName) {\n          case 'input':\n            const id = parseId(child.getAttribute('source'))\n            const semantic = child.getAttribute('semantic')\n            data.inputs[semantic] = id\n            break\n        }\n      }\n\n      return data\n    }\n\n    function parseAnimationChannel(xml) {\n      const data = {}\n\n      const target = xml.getAttribute('target')\n\n      // parsing SID Addressing Syntax\n\n      let parts = target.split('/')\n\n      const id = parts.shift()\n      let sid = parts.shift()\n\n      // check selection syntax\n\n      const arraySyntax = sid.indexOf('(') !== -1\n      const memberSyntax = sid.indexOf('.') !== -1\n\n      if (memberSyntax) {\n        //  member selection access\n\n        parts = sid.split('.')\n        sid = parts.shift()\n        data.member = parts.shift()\n      } else if (arraySyntax) {\n        // array-access syntax. can be used to express fields in one-dimensional vectors or two-dimensional matrices.\n\n        const indices = sid.split('(')\n        sid = indices.shift()\n\n        for (let i = 0; i < indices.length; i++) {\n          indices[i] = parseInt(indices[i].replace(/\\)/, ''))\n        }\n\n        data.indices = indices\n      }\n\n      data.id = id\n      data.sid = sid\n\n      data.arraySyntax = arraySyntax\n      data.memberSyntax = memberSyntax\n\n      data.sampler = parseId(xml.getAttribute('source'))\n\n      return data\n    }\n\n    function buildAnimation(data) {\n      const tracks = []\n\n      const channels = data.channels\n      const samplers = data.samplers\n      const sources = data.sources\n\n      for (const target in channels) {\n        if (channels.hasOwnProperty(target)) {\n          const channel = channels[target]\n          const sampler = samplers[channel.sampler]\n\n          const inputId = sampler.inputs.INPUT\n          const outputId = sampler.inputs.OUTPUT\n\n          const inputSource = sources[inputId]\n          const outputSource = sources[outputId]\n\n          const animation = buildAnimationChannel(channel, inputSource, outputSource)\n\n          createKeyframeTracks(animation, tracks)\n        }\n      }\n\n      return tracks\n    }\n\n    function getAnimation(id) {\n      return getBuild(library.animations[id], buildAnimation)\n    }\n\n    function buildAnimationChannel(channel, inputSource, outputSource) {\n      const node = library.nodes[channel.id]\n      const object3D = getNode(node.id)\n\n      const transform = node.transforms[channel.sid]\n      const defaultMatrix = node.matrix.clone().transpose()\n\n      let time, stride\n      let i, il, j, jl\n\n      const data = {}\n\n      // the collada spec allows the animation of data in various ways.\n      // depending on the transform type (matrix, translate, rotate, scale), we execute different logic\n\n      switch (transform) {\n        case 'matrix':\n          for (i = 0, il = inputSource.array.length; i < il; i++) {\n            time = inputSource.array[i]\n            stride = i * outputSource.stride\n\n            if (data[time] === undefined) data[time] = {}\n\n            if (channel.arraySyntax === true) {\n              const value = outputSource.array[stride]\n              const index = channel.indices[0] + 4 * channel.indices[1]\n\n              data[time][index] = value\n            } else {\n              for (j = 0, jl = outputSource.stride; j < jl; j++) {\n                data[time][j] = outputSource.array[stride + j]\n              }\n            }\n          }\n\n          break\n\n        case 'translate':\n          console.warn('THREE.ColladaLoader: Animation transform type \"%s\" not yet implemented.', transform)\n          break\n\n        case 'rotate':\n          console.warn('THREE.ColladaLoader: Animation transform type \"%s\" not yet implemented.', transform)\n          break\n\n        case 'scale':\n          console.warn('THREE.ColladaLoader: Animation transform type \"%s\" not yet implemented.', transform)\n          break\n      }\n\n      const keyframes = prepareAnimationData(data, defaultMatrix)\n\n      const animation = {\n        name: object3D.uuid,\n        keyframes: keyframes,\n      }\n\n      return animation\n    }\n\n    function prepareAnimationData(data, defaultMatrix) {\n      const keyframes = []\n\n      // transfer data into a sortable array\n\n      for (const time in data) {\n        keyframes.push({ time: parseFloat(time), value: data[time] })\n      }\n\n      // ensure keyframes are sorted by time\n\n      keyframes.sort(ascending)\n\n      // now we clean up all animation data, so we can use them for keyframe tracks\n\n      for (let i = 0; i < 16; i++) {\n        transformAnimationData(keyframes, i, defaultMatrix.elements[i])\n      }\n\n      return keyframes\n\n      // array sort function\n\n      function ascending(a, b) {\n        return a.time - b.time\n      }\n    }\n\n    const position = new Vector3()\n    const scale = new Vector3()\n    const quaternion = new Quaternion()\n\n    function createKeyframeTracks(animation, tracks) {\n      const keyframes = animation.keyframes\n      const name = animation.name\n\n      const times = []\n      const positionData = []\n      const quaternionData = []\n      const scaleData = []\n\n      for (let i = 0, l = keyframes.length; i < l; i++) {\n        const keyframe = keyframes[i]\n\n        const time = keyframe.time\n        const value = keyframe.value\n\n        matrix.fromArray(value).transpose()\n        matrix.decompose(position, quaternion, scale)\n\n        times.push(time)\n        positionData.push(position.x, position.y, position.z)\n        quaternionData.push(quaternion.x, quaternion.y, quaternion.z, quaternion.w)\n        scaleData.push(scale.x, scale.y, scale.z)\n      }\n\n      if (positionData.length > 0) tracks.push(new VectorKeyframeTrack(name + '.position', times, positionData))\n      if (quaternionData.length > 0) {\n        tracks.push(new QuaternionKeyframeTrack(name + '.quaternion', times, quaternionData))\n      }\n      if (scaleData.length > 0) tracks.push(new VectorKeyframeTrack(name + '.scale', times, scaleData))\n\n      return tracks\n    }\n\n    function transformAnimationData(keyframes, property, defaultValue) {\n      let keyframe\n\n      let empty = true\n      let i, l\n\n      // check, if values of a property are missing in our keyframes\n\n      for (i = 0, l = keyframes.length; i < l; i++) {\n        keyframe = keyframes[i]\n\n        if (keyframe.value[property] === undefined) {\n          keyframe.value[property] = null // mark as missing\n        } else {\n          empty = false\n        }\n      }\n\n      if (empty === true) {\n        // no values at all, so we set a default value\n\n        for (i = 0, l = keyframes.length; i < l; i++) {\n          keyframe = keyframes[i]\n\n          keyframe.value[property] = defaultValue\n        }\n      } else {\n        // filling gaps\n\n        createMissingKeyframes(keyframes, property)\n      }\n    }\n\n    function createMissingKeyframes(keyframes, property) {\n      let prev, next\n\n      for (let i = 0, l = keyframes.length; i < l; i++) {\n        const keyframe = keyframes[i]\n\n        if (keyframe.value[property] === null) {\n          prev = getPrev(keyframes, i, property)\n          next = getNext(keyframes, i, property)\n\n          if (prev === null) {\n            keyframe.value[property] = next.value[property]\n            continue\n          }\n\n          if (next === null) {\n            keyframe.value[property] = prev.value[property]\n            continue\n          }\n\n          interpolate(keyframe, prev, next, property)\n        }\n      }\n    }\n\n    function getPrev(keyframes, i, property) {\n      while (i >= 0) {\n        const keyframe = keyframes[i]\n\n        if (keyframe.value[property] !== null) return keyframe\n\n        i--\n      }\n\n      return null\n    }\n\n    function getNext(keyframes, i, property) {\n      while (i < keyframes.length) {\n        const keyframe = keyframes[i]\n\n        if (keyframe.value[property] !== null) return keyframe\n\n        i++\n      }\n\n      return null\n    }\n\n    function interpolate(key, prev, next, property) {\n      if (next.time - prev.time === 0) {\n        key.value[property] = prev.value[property]\n        return\n      }\n\n      key.value[property] =\n        ((key.time - prev.time) * (next.value[property] - prev.value[property])) / (next.time - prev.time) +\n        prev.value[property]\n    }\n\n    // animation clips\n\n    function parseAnimationClip(xml) {\n      const data = {\n        name: xml.getAttribute('id') || 'default',\n        start: parseFloat(xml.getAttribute('start') || 0),\n        end: parseFloat(xml.getAttribute('end') || 0),\n        animations: [],\n      }\n\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        const child = xml.childNodes[i]\n\n        if (child.nodeType !== 1) continue\n\n        switch (child.nodeName) {\n          case 'instance_animation':\n            data.animations.push(parseId(child.getAttribute('url')))\n            break\n        }\n      }\n\n      library.clips[xml.getAttribute('id')] = data\n    }\n\n    function buildAnimationClip(data) {\n      const tracks = []\n\n      const name = data.name\n      const duration = data.end - data.start || -1\n      const animations = data.animations\n\n      for (let i = 0, il = animations.length; i < il; i++) {\n        const animationTracks = getAnimation(animations[i])\n\n        for (let j = 0, jl = animationTracks.length; j < jl; j++) {\n          tracks.push(animationTracks[j])\n        }\n      }\n\n      return new AnimationClip(name, duration, tracks)\n    }\n\n    function getAnimationClip(id) {\n      return getBuild(library.clips[id], buildAnimationClip)\n    }\n\n    // controller\n\n    function parseController(xml) {\n      const data = {}\n\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        const child = xml.childNodes[i]\n\n        if (child.nodeType !== 1) continue\n\n        switch (child.nodeName) {\n          case 'skin':\n            // there is exactly one skin per controller\n            data.id = parseId(child.getAttribute('source'))\n            data.skin = parseSkin(child)\n            break\n\n          case 'morph':\n            data.id = parseId(child.getAttribute('source'))\n            console.warn('THREE.ColladaLoader: Morph target animation not supported yet.')\n            break\n        }\n      }\n\n      library.controllers[xml.getAttribute('id')] = data\n    }\n\n    function parseSkin(xml) {\n      const data = {\n        sources: {},\n      }\n\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        const child = xml.childNodes[i]\n\n        if (child.nodeType !== 1) continue\n\n        switch (child.nodeName) {\n          case 'bind_shape_matrix':\n            data.bindShapeMatrix = parseFloats(child.textContent)\n            break\n\n          case 'source':\n            const id = child.getAttribute('id')\n            data.sources[id] = parseSource(child)\n            break\n\n          case 'joints':\n            data.joints = parseJoints(child)\n            break\n\n          case 'vertex_weights':\n            data.vertexWeights = parseVertexWeights(child)\n            break\n        }\n      }\n\n      return data\n    }\n\n    function parseJoints(xml) {\n      const data = {\n        inputs: {},\n      }\n\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        const child = xml.childNodes[i]\n\n        if (child.nodeType !== 1) continue\n\n        switch (child.nodeName) {\n          case 'input':\n            const semantic = child.getAttribute('semantic')\n            const id = parseId(child.getAttribute('source'))\n            data.inputs[semantic] = id\n            break\n        }\n      }\n\n      return data\n    }\n\n    function parseVertexWeights(xml) {\n      const data = {\n        inputs: {},\n      }\n\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        const child = xml.childNodes[i]\n\n        if (child.nodeType !== 1) continue\n\n        switch (child.nodeName) {\n          case 'input':\n            const semantic = child.getAttribute('semantic')\n            const id = parseId(child.getAttribute('source'))\n            const offset = parseInt(child.getAttribute('offset'))\n            data.inputs[semantic] = { id: id, offset: offset }\n            break\n\n          case 'vcount':\n            data.vcount = parseInts(child.textContent)\n            break\n\n          case 'v':\n            data.v = parseInts(child.textContent)\n            break\n        }\n      }\n\n      return data\n    }\n\n    function buildController(data) {\n      const build = {\n        id: data.id,\n      }\n\n      const geometry = library.geometries[build.id]\n\n      if (data.skin !== undefined) {\n        build.skin = buildSkin(data.skin)\n\n        // we enhance the 'sources' property of the corresponding geometry with our skin data\n\n        geometry.sources.skinIndices = build.skin.indices\n        geometry.sources.skinWeights = build.skin.weights\n      }\n\n      return build\n    }\n\n    function buildSkin(data) {\n      const BONE_LIMIT = 4\n\n      const build = {\n        joints: [], // this must be an array to preserve the joint order\n        indices: {\n          array: [],\n          stride: BONE_LIMIT,\n        },\n        weights: {\n          array: [],\n          stride: BONE_LIMIT,\n        },\n      }\n\n      const sources = data.sources\n      const vertexWeights = data.vertexWeights\n\n      const vcount = vertexWeights.vcount\n      const v = vertexWeights.v\n      const jointOffset = vertexWeights.inputs.JOINT.offset\n      const weightOffset = vertexWeights.inputs.WEIGHT.offset\n\n      const jointSource = data.sources[data.joints.inputs.JOINT]\n      const inverseSource = data.sources[data.joints.inputs.INV_BIND_MATRIX]\n\n      const weights = sources[vertexWeights.inputs.WEIGHT.id].array\n      let stride = 0\n\n      let i, j, l\n\n      // procces skin data for each vertex\n\n      for (i = 0, l = vcount.length; i < l; i++) {\n        const jointCount = vcount[i] // this is the amount of joints that affect a single vertex\n        const vertexSkinData = []\n\n        for (j = 0; j < jointCount; j++) {\n          const skinIndex = v[stride + jointOffset]\n          const weightId = v[stride + weightOffset]\n          const skinWeight = weights[weightId]\n\n          vertexSkinData.push({ index: skinIndex, weight: skinWeight })\n\n          stride += 2\n        }\n\n        // we sort the joints in descending order based on the weights.\n        // this ensures, we only procced the most important joints of the vertex\n\n        vertexSkinData.sort(descending)\n\n        // now we provide for each vertex a set of four index and weight values.\n        // the order of the skin data matches the order of vertices\n\n        for (j = 0; j < BONE_LIMIT; j++) {\n          const d = vertexSkinData[j]\n\n          if (d !== undefined) {\n            build.indices.array.push(d.index)\n            build.weights.array.push(d.weight)\n          } else {\n            build.indices.array.push(0)\n            build.weights.array.push(0)\n          }\n        }\n      }\n\n      // setup bind matrix\n\n      if (data.bindShapeMatrix) {\n        build.bindMatrix = new Matrix4().fromArray(data.bindShapeMatrix).transpose()\n      } else {\n        build.bindMatrix = new Matrix4().identity()\n      }\n\n      // process bones and inverse bind matrix data\n\n      for (i = 0, l = jointSource.array.length; i < l; i++) {\n        const name = jointSource.array[i]\n        const boneInverse = new Matrix4().fromArray(inverseSource.array, i * inverseSource.stride).transpose()\n\n        build.joints.push({ name: name, boneInverse: boneInverse })\n      }\n\n      return build\n\n      // array sort function\n\n      function descending(a, b) {\n        return b.weight - a.weight\n      }\n    }\n\n    function getController(id) {\n      return getBuild(library.controllers[id], buildController)\n    }\n\n    // image\n\n    function parseImage(xml) {\n      const data = {\n        init_from: getElementsByTagName(xml, 'init_from')[0].textContent,\n      }\n\n      library.images[xml.getAttribute('id')] = data\n    }\n\n    function buildImage(data) {\n      if (data.build !== undefined) return data.build\n\n      return data.init_from\n    }\n\n    function getImage(id) {\n      const data = library.images[id]\n\n      if (data !== undefined) {\n        return getBuild(data, buildImage)\n      }\n\n      console.warn(\"THREE.ColladaLoader: Couldn't find image with ID:\", id)\n\n      return null\n    }\n\n    // effect\n\n    function parseEffect(xml) {\n      const data = {}\n\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        const child = xml.childNodes[i]\n\n        if (child.nodeType !== 1) continue\n\n        switch (child.nodeName) {\n          case 'profile_COMMON':\n            data.profile = parseEffectProfileCOMMON(child)\n            break\n        }\n      }\n\n      library.effects[xml.getAttribute('id')] = data\n    }\n\n    function parseEffectProfileCOMMON(xml) {\n      const data = {\n        surfaces: {},\n        samplers: {},\n      }\n\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        const child = xml.childNodes[i]\n\n        if (child.nodeType !== 1) continue\n\n        switch (child.nodeName) {\n          case 'newparam':\n            parseEffectNewparam(child, data)\n            break\n\n          case 'technique':\n            data.technique = parseEffectTechnique(child)\n            break\n\n          case 'extra':\n            data.extra = parseEffectExtra(child)\n            break\n        }\n      }\n\n      return data\n    }\n\n    function parseEffectNewparam(xml, data) {\n      const sid = xml.getAttribute('sid')\n\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        const child = xml.childNodes[i]\n\n        if (child.nodeType !== 1) continue\n\n        switch (child.nodeName) {\n          case 'surface':\n            data.surfaces[sid] = parseEffectSurface(child)\n            break\n\n          case 'sampler2D':\n            data.samplers[sid] = parseEffectSampler(child)\n            break\n        }\n      }\n    }\n\n    function parseEffectSurface(xml) {\n      const data = {}\n\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        const child = xml.childNodes[i]\n\n        if (child.nodeType !== 1) continue\n\n        switch (child.nodeName) {\n          case 'init_from':\n            data.init_from = child.textContent\n            break\n        }\n      }\n\n      return data\n    }\n\n    function parseEffectSampler(xml) {\n      const data = {}\n\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        const child = xml.childNodes[i]\n\n        if (child.nodeType !== 1) continue\n\n        switch (child.nodeName) {\n          case 'source':\n            data.source = child.textContent\n            break\n        }\n      }\n\n      return data\n    }\n\n    function parseEffectTechnique(xml) {\n      const data = {}\n\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        const child = xml.childNodes[i]\n\n        if (child.nodeType !== 1) continue\n\n        switch (child.nodeName) {\n          case 'constant':\n          case 'lambert':\n          case 'blinn':\n          case 'phong':\n            data.type = child.nodeName\n            data.parameters = parseEffectParameters(child)\n            break\n\n          case 'extra':\n            data.extra = parseEffectExtra(child)\n            break\n        }\n      }\n\n      return data\n    }\n\n    function parseEffectParameters(xml) {\n      const data = {}\n\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        const child = xml.childNodes[i]\n\n        if (child.nodeType !== 1) continue\n\n        switch (child.nodeName) {\n          case 'emission':\n          case 'diffuse':\n          case 'specular':\n          case 'bump':\n          case 'ambient':\n          case 'shininess':\n          case 'transparency':\n            data[child.nodeName] = parseEffectParameter(child)\n            break\n          case 'transparent':\n            data[child.nodeName] = {\n              opaque: child.hasAttribute('opaque') ? child.getAttribute('opaque') : 'A_ONE',\n              data: parseEffectParameter(child),\n            }\n            break\n        }\n      }\n\n      return data\n    }\n\n    function parseEffectParameter(xml) {\n      const data = {}\n\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        const child = xml.childNodes[i]\n\n        if (child.nodeType !== 1) continue\n\n        switch (child.nodeName) {\n          case 'color':\n            data[child.nodeName] = parseFloats(child.textContent)\n            break\n\n          case 'float':\n            data[child.nodeName] = parseFloat(child.textContent)\n            break\n\n          case 'texture':\n            data[child.nodeName] = { id: child.getAttribute('texture'), extra: parseEffectParameterTexture(child) }\n            break\n        }\n      }\n\n      return data\n    }\n\n    function parseEffectParameterTexture(xml) {\n      const data = {\n        technique: {},\n      }\n\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        const child = xml.childNodes[i]\n\n        if (child.nodeType !== 1) continue\n\n        switch (child.nodeName) {\n          case 'extra':\n            parseEffectParameterTextureExtra(child, data)\n            break\n        }\n      }\n\n      return data\n    }\n\n    function parseEffectParameterTextureExtra(xml, data) {\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        const child = xml.childNodes[i]\n\n        if (child.nodeType !== 1) continue\n\n        switch (child.nodeName) {\n          case 'technique':\n            parseEffectParameterTextureExtraTechnique(child, data)\n            break\n        }\n      }\n    }\n\n    function parseEffectParameterTextureExtraTechnique(xml, data) {\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        const child = xml.childNodes[i]\n\n        if (child.nodeType !== 1) continue\n\n        switch (child.nodeName) {\n          case 'repeatU':\n          case 'repeatV':\n          case 'offsetU':\n          case 'offsetV':\n            data.technique[child.nodeName] = parseFloat(child.textContent)\n            break\n\n          case 'wrapU':\n          case 'wrapV':\n            // some files have values for wrapU/wrapV which become NaN via parseInt\n\n            if (child.textContent.toUpperCase() === 'TRUE') {\n              data.technique[child.nodeName] = 1\n            } else if (child.textContent.toUpperCase() === 'FALSE') {\n              data.technique[child.nodeName] = 0\n            } else {\n              data.technique[child.nodeName] = parseInt(child.textContent)\n            }\n\n            break\n\n          case 'bump':\n            data[child.nodeName] = parseEffectExtraTechniqueBump(child)\n            break\n        }\n      }\n    }\n\n    function parseEffectExtra(xml) {\n      const data = {}\n\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        const child = xml.childNodes[i]\n\n        if (child.nodeType !== 1) continue\n\n        switch (child.nodeName) {\n          case 'technique':\n            data.technique = parseEffectExtraTechnique(child)\n            break\n        }\n      }\n\n      return data\n    }\n\n    function parseEffectExtraTechnique(xml) {\n      const data = {}\n\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        const child = xml.childNodes[i]\n\n        if (child.nodeType !== 1) continue\n\n        switch (child.nodeName) {\n          case 'double_sided':\n            data[child.nodeName] = parseInt(child.textContent)\n            break\n\n          case 'bump':\n            data[child.nodeName] = parseEffectExtraTechniqueBump(child)\n            break\n        }\n      }\n\n      return data\n    }\n\n    function parseEffectExtraTechniqueBump(xml) {\n      var data = {}\n\n      for (var i = 0, l = xml.childNodes.length; i < l; i++) {\n        var child = xml.childNodes[i]\n\n        if (child.nodeType !== 1) continue\n\n        switch (child.nodeName) {\n          case 'texture':\n            data[child.nodeName] = {\n              id: child.getAttribute('texture'),\n              texcoord: child.getAttribute('texcoord'),\n              extra: parseEffectParameterTexture(child),\n            }\n            break\n        }\n      }\n\n      return data\n    }\n\n    function buildEffect(data) {\n      return data\n    }\n\n    function getEffect(id) {\n      return getBuild(library.effects[id], buildEffect)\n    }\n\n    // material\n\n    function parseMaterial(xml) {\n      const data = {\n        name: xml.getAttribute('name'),\n      }\n\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        const child = xml.childNodes[i]\n\n        if (child.nodeType !== 1) continue\n\n        switch (child.nodeName) {\n          case 'instance_effect':\n            data.url = parseId(child.getAttribute('url'))\n            break\n        }\n      }\n\n      library.materials[xml.getAttribute('id')] = data\n    }\n\n    function getTextureLoader(image) {\n      let loader\n\n      let extension = image.slice(((image.lastIndexOf('.') - 1) >>> 0) + 2) // http://www.jstips.co/en/javascript/get-file-extension/\n      extension = extension.toLowerCase()\n\n      switch (extension) {\n        case 'tga':\n          loader = tgaLoader\n          break\n\n        default:\n          loader = textureLoader\n      }\n\n      return loader\n    }\n\n    function buildMaterial(data) {\n      const effect = getEffect(data.url)\n      const technique = effect.profile.technique\n\n      let material\n\n      switch (technique.type) {\n        case 'phong':\n        case 'blinn':\n          material = new MeshPhongMaterial()\n          break\n\n        case 'lambert':\n          material = new MeshLambertMaterial()\n          break\n\n        default:\n          material = new MeshBasicMaterial()\n          break\n      }\n\n      material.name = data.name || ''\n\n      function getTexture(textureObject) {\n        const sampler = effect.profile.samplers[textureObject.id]\n        let image = null\n\n        // get image\n\n        if (sampler !== undefined) {\n          const surface = effect.profile.surfaces[sampler.source]\n          image = getImage(surface.init_from)\n        } else {\n          console.warn('THREE.ColladaLoader: Undefined sampler. Access image directly (see #12530).')\n          image = getImage(textureObject.id)\n        }\n\n        // create texture if image is avaiable\n\n        if (image !== null) {\n          const loader = getTextureLoader(image)\n\n          if (loader !== undefined) {\n            const texture = loader.load(image)\n\n            const extra = textureObject.extra\n\n            if (extra !== undefined && extra.technique !== undefined && isEmpty(extra.technique) === false) {\n              const technique = extra.technique\n\n              texture.wrapS = technique.wrapU ? RepeatWrapping : ClampToEdgeWrapping\n              texture.wrapT = technique.wrapV ? RepeatWrapping : ClampToEdgeWrapping\n\n              texture.offset.set(technique.offsetU || 0, technique.offsetV || 0)\n              texture.repeat.set(technique.repeatU || 1, technique.repeatV || 1)\n            } else {\n              texture.wrapS = RepeatWrapping\n              texture.wrapT = RepeatWrapping\n            }\n\n            return texture\n          } else {\n            console.warn('THREE.ColladaLoader: Loader for texture %s not found.', image)\n\n            return null\n          }\n        } else {\n          console.warn(\"THREE.ColladaLoader: Couldn't create texture with ID:\", textureObject.id)\n\n          return null\n        }\n      }\n\n      const parameters = technique.parameters\n\n      for (const key in parameters) {\n        const parameter = parameters[key]\n\n        switch (key) {\n          case 'diffuse':\n            if (parameter.color) material.color.fromArray(parameter.color)\n            if (parameter.texture) material.map = getTexture(parameter.texture)\n            break\n          case 'specular':\n            if (parameter.color && material.specular) material.specular.fromArray(parameter.color)\n            if (parameter.texture) material.specularMap = getTexture(parameter.texture)\n            break\n          case 'bump':\n            if (parameter.texture) material.normalMap = getTexture(parameter.texture)\n            break\n          case 'ambient':\n            if (parameter.texture) material.lightMap = getTexture(parameter.texture)\n            break\n          case 'shininess':\n            if (parameter.float && material.shininess) material.shininess = parameter.float\n            break\n          case 'emission':\n            if (parameter.color && material.emissive) material.emissive.fromArray(parameter.color)\n            if (parameter.texture) material.emissiveMap = getTexture(parameter.texture)\n            break\n        }\n      }\n\n      //\n\n      let transparent = parameters['transparent']\n      let transparency = parameters['transparency']\n\n      // <transparency> does not exist but <transparent>\n\n      if (transparency === undefined && transparent) {\n        transparency = {\n          float: 1,\n        }\n      }\n\n      // <transparent> does not exist but <transparency>\n\n      if (transparent === undefined && transparency) {\n        transparent = {\n          opaque: 'A_ONE',\n          data: {\n            color: [1, 1, 1, 1],\n          },\n        }\n      }\n\n      if (transparent && transparency) {\n        // handle case if a texture exists but no color\n\n        if (transparent.data.texture) {\n          // we do not set an alpha map (see #13792)\n\n          material.transparent = true\n        } else {\n          const color = transparent.data.color\n\n          switch (transparent.opaque) {\n            case 'A_ONE':\n              material.opacity = color[3] * transparency.float\n              break\n            case 'RGB_ZERO':\n              material.opacity = 1 - color[0] * transparency.float\n              break\n            case 'A_ZERO':\n              material.opacity = 1 - color[3] * transparency.float\n              break\n            case 'RGB_ONE':\n              material.opacity = color[0] * transparency.float\n              break\n            default:\n              console.warn('THREE.ColladaLoader: Invalid opaque type \"%s\" of transparent tag.', transparent.opaque)\n          }\n\n          if (material.opacity < 1) material.transparent = true\n        }\n      }\n\n      //\n\n      if (technique.extra !== undefined && technique.extra.technique !== undefined) {\n        const techniques = technique.extra.technique\n\n        for (const k in techniques) {\n          const v = techniques[k]\n\n          switch (k) {\n            case 'double_sided':\n              material.side = v === 1 ? DoubleSide : FrontSide\n              break\n\n            case 'bump':\n              material.normalMap = getTexture(v.texture)\n              material.normalScale = new Vector2(1, 1)\n              break\n          }\n        }\n      }\n\n      return material\n    }\n\n    function getMaterial(id) {\n      return getBuild(library.materials[id], buildMaterial)\n    }\n\n    // camera\n\n    function parseCamera(xml) {\n      const data = {\n        name: xml.getAttribute('name'),\n      }\n\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        const child = xml.childNodes[i]\n\n        if (child.nodeType !== 1) continue\n\n        switch (child.nodeName) {\n          case 'optics':\n            data.optics = parseCameraOptics(child)\n            break\n        }\n      }\n\n      library.cameras[xml.getAttribute('id')] = data\n    }\n\n    function parseCameraOptics(xml) {\n      for (let i = 0; i < xml.childNodes.length; i++) {\n        const child = xml.childNodes[i]\n\n        switch (child.nodeName) {\n          case 'technique_common':\n            return parseCameraTechnique(child)\n        }\n      }\n\n      return {}\n    }\n\n    function parseCameraTechnique(xml) {\n      const data = {}\n\n      for (let i = 0; i < xml.childNodes.length; i++) {\n        const child = xml.childNodes[i]\n\n        switch (child.nodeName) {\n          case 'perspective':\n          case 'orthographic':\n            data.technique = child.nodeName\n            data.parameters = parseCameraParameters(child)\n\n            break\n        }\n      }\n\n      return data\n    }\n\n    function parseCameraParameters(xml) {\n      const data = {}\n\n      for (let i = 0; i < xml.childNodes.length; i++) {\n        const child = xml.childNodes[i]\n\n        switch (child.nodeName) {\n          case 'xfov':\n          case 'yfov':\n          case 'xmag':\n          case 'ymag':\n          case 'znear':\n          case 'zfar':\n          case 'aspect_ratio':\n            data[child.nodeName] = parseFloat(child.textContent)\n            break\n        }\n      }\n\n      return data\n    }\n\n    function buildCamera(data) {\n      let camera\n\n      switch (data.optics.technique) {\n        case 'perspective':\n          camera = new PerspectiveCamera(\n            data.optics.parameters.yfov,\n            data.optics.parameters.aspect_ratio,\n            data.optics.parameters.znear,\n            data.optics.parameters.zfar,\n          )\n          break\n\n        case 'orthographic':\n          let ymag = data.optics.parameters.ymag\n          let xmag = data.optics.parameters.xmag\n          const aspectRatio = data.optics.parameters.aspect_ratio\n\n          xmag = xmag === undefined ? ymag * aspectRatio : xmag\n          ymag = ymag === undefined ? xmag / aspectRatio : ymag\n\n          xmag *= 0.5\n          ymag *= 0.5\n\n          camera = new OrthographicCamera(\n            -xmag,\n            xmag,\n            ymag,\n            -ymag, // left, right, top, bottom\n            data.optics.parameters.znear,\n            data.optics.parameters.zfar,\n          )\n          break\n\n        default:\n          camera = new PerspectiveCamera()\n          break\n      }\n\n      camera.name = data.name || ''\n\n      return camera\n    }\n\n    function getCamera(id) {\n      const data = library.cameras[id]\n\n      if (data !== undefined) {\n        return getBuild(data, buildCamera)\n      }\n\n      console.warn(\"THREE.ColladaLoader: Couldn't find camera with ID:\", id)\n\n      return null\n    }\n\n    // light\n\n    function parseLight(xml) {\n      let data = {}\n\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        const child = xml.childNodes[i]\n\n        if (child.nodeType !== 1) continue\n\n        switch (child.nodeName) {\n          case 'technique_common':\n            data = parseLightTechnique(child)\n            break\n        }\n      }\n\n      library.lights[xml.getAttribute('id')] = data\n    }\n\n    function parseLightTechnique(xml) {\n      const data = {}\n\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        const child = xml.childNodes[i]\n\n        if (child.nodeType !== 1) continue\n\n        switch (child.nodeName) {\n          case 'directional':\n          case 'point':\n          case 'spot':\n          case 'ambient':\n            data.technique = child.nodeName\n            data.parameters = parseLightParameters(child)\n        }\n      }\n\n      return data\n    }\n\n    function parseLightParameters(xml) {\n      const data = {}\n\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        const child = xml.childNodes[i]\n\n        if (child.nodeType !== 1) continue\n\n        switch (child.nodeName) {\n          case 'color':\n            const array = parseFloats(child.textContent)\n            data.color = new Color().fromArray(array)\n            break\n\n          case 'falloff_angle':\n            data.falloffAngle = parseFloat(child.textContent)\n            break\n\n          case 'quadratic_attenuation':\n            const f = parseFloat(child.textContent)\n            data.distance = f ? Math.sqrt(1 / f) : 0\n            break\n        }\n      }\n\n      return data\n    }\n\n    function buildLight(data) {\n      let light\n\n      switch (data.technique) {\n        case 'directional':\n          light = new DirectionalLight()\n          break\n\n        case 'point':\n          light = new PointLight()\n          break\n\n        case 'spot':\n          light = new SpotLight()\n          break\n\n        case 'ambient':\n          light = new AmbientLight()\n          break\n      }\n\n      if (data.parameters.color) light.color.copy(data.parameters.color)\n      if (data.parameters.distance) light.distance = data.parameters.distance\n\n      return light\n    }\n\n    function getLight(id) {\n      const data = library.lights[id]\n\n      if (data !== undefined) {\n        return getBuild(data, buildLight)\n      }\n\n      console.warn(\"THREE.ColladaLoader: Couldn't find light with ID:\", id)\n\n      return null\n    }\n\n    // geometry\n\n    function parseGeometry(xml) {\n      const data = {\n        name: xml.getAttribute('name'),\n        sources: {},\n        vertices: {},\n        primitives: [],\n      }\n\n      const mesh = getElementsByTagName(xml, 'mesh')[0]\n\n      // the following tags inside geometry are not supported yet (see https://github.com/mrdoob/three.js/pull/12606): convex_mesh, spline, brep\n      if (mesh === undefined) return\n\n      for (let i = 0; i < mesh.childNodes.length; i++) {\n        const child = mesh.childNodes[i]\n\n        if (child.nodeType !== 1) continue\n\n        const id = child.getAttribute('id')\n\n        switch (child.nodeName) {\n          case 'source':\n            data.sources[id] = parseSource(child)\n            break\n\n          case 'vertices':\n            // data.sources[ id ] = data.sources[ parseId( getElementsByTagName( child, 'input' )[ 0 ].getAttribute( 'source' ) ) ];\n            data.vertices = parseGeometryVertices(child)\n            break\n\n          case 'polygons':\n            console.warn('THREE.ColladaLoader: Unsupported primitive type: ', child.nodeName)\n            break\n\n          case 'lines':\n          case 'linestrips':\n          case 'polylist':\n          case 'triangles':\n            data.primitives.push(parseGeometryPrimitive(child))\n            break\n\n          default:\n            console.log(child)\n        }\n      }\n\n      library.geometries[xml.getAttribute('id')] = data\n    }\n\n    function parseSource(xml) {\n      const data = {\n        array: [],\n        stride: 3,\n      }\n\n      for (let i = 0; i < xml.childNodes.length; i++) {\n        const child = xml.childNodes[i]\n\n        if (child.nodeType !== 1) continue\n\n        switch (child.nodeName) {\n          case 'float_array':\n            data.array = parseFloats(child.textContent)\n            break\n\n          case 'Name_array':\n            data.array = parseStrings(child.textContent)\n            break\n\n          case 'technique_common':\n            const accessor = getElementsByTagName(child, 'accessor')[0]\n\n            if (accessor !== undefined) {\n              data.stride = parseInt(accessor.getAttribute('stride'))\n            }\n\n            break\n        }\n      }\n\n      return data\n    }\n\n    function parseGeometryVertices(xml) {\n      const data = {}\n\n      for (let i = 0; i < xml.childNodes.length; i++) {\n        const child = xml.childNodes[i]\n\n        if (child.nodeType !== 1) continue\n\n        data[child.getAttribute('semantic')] = parseId(child.getAttribute('source'))\n      }\n\n      return data\n    }\n\n    function parseGeometryPrimitive(xml) {\n      const primitive = {\n        type: xml.nodeName,\n        material: xml.getAttribute('material'),\n        count: parseInt(xml.getAttribute('count')),\n        inputs: {},\n        stride: 0,\n        hasUV: false,\n      }\n\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        const child = xml.childNodes[i]\n\n        if (child.nodeType !== 1) continue\n\n        switch (child.nodeName) {\n          case 'input':\n            const id = parseId(child.getAttribute('source'))\n            const semantic = child.getAttribute('semantic')\n            const offset = parseInt(child.getAttribute('offset'))\n            const set = parseInt(child.getAttribute('set'))\n            const inputname = set > 0 ? semantic + set : semantic\n            primitive.inputs[inputname] = { id: id, offset: offset }\n            primitive.stride = Math.max(primitive.stride, offset + 1)\n            if (semantic === 'TEXCOORD') primitive.hasUV = true\n            break\n\n          case 'vcount':\n            primitive.vcount = parseInts(child.textContent)\n            break\n\n          case 'p':\n            primitive.p = parseInts(child.textContent)\n            break\n        }\n      }\n\n      return primitive\n    }\n\n    function groupPrimitives(primitives) {\n      const build = {}\n\n      for (let i = 0; i < primitives.length; i++) {\n        const primitive = primitives[i]\n\n        if (build[primitive.type] === undefined) build[primitive.type] = []\n\n        build[primitive.type].push(primitive)\n      }\n\n      return build\n    }\n\n    function checkUVCoordinates(primitives) {\n      let count = 0\n\n      for (let i = 0, l = primitives.length; i < l; i++) {\n        const primitive = primitives[i]\n\n        if (primitive.hasUV === true) {\n          count++\n        }\n      }\n\n      if (count > 0 && count < primitives.length) {\n        primitives.uvsNeedsFix = true\n      }\n    }\n\n    function buildGeometry(data) {\n      const build = {}\n\n      const sources = data.sources\n      const vertices = data.vertices\n      const primitives = data.primitives\n\n      if (primitives.length === 0) return {}\n\n      // our goal is to create one buffer geometry for a single type of primitives\n      // first, we group all primitives by their type\n\n      const groupedPrimitives = groupPrimitives(primitives)\n\n      for (const type in groupedPrimitives) {\n        const primitiveType = groupedPrimitives[type]\n\n        // second, ensure consistent uv coordinates for each type of primitives (polylist,triangles or lines)\n\n        checkUVCoordinates(primitiveType)\n\n        // third, create a buffer geometry for each type of primitives\n\n        build[type] = buildGeometryType(primitiveType, sources, vertices)\n      }\n\n      return build\n    }\n\n    function buildGeometryType(primitives, sources, vertices) {\n      const build = {}\n\n      const position = { array: [], stride: 0 }\n      const normal = { array: [], stride: 0 }\n      const uv = { array: [], stride: 0 }\n      const uv1 = { array: [], stride: 0 }\n      const color = { array: [], stride: 0 }\n\n      const skinIndex = { array: [], stride: 4 }\n      const skinWeight = { array: [], stride: 4 }\n\n      const geometry = new BufferGeometry()\n\n      const materialKeys = []\n\n      let start = 0\n\n      for (let p = 0; p < primitives.length; p++) {\n        const primitive = primitives[p]\n        const inputs = primitive.inputs\n\n        // groups\n\n        let count = 0\n\n        switch (primitive.type) {\n          case 'lines':\n          case 'linestrips':\n            count = primitive.count * 2\n            break\n\n          case 'triangles':\n            count = primitive.count * 3\n            break\n\n          case 'polylist':\n            for (let g = 0; g < primitive.count; g++) {\n              const vc = primitive.vcount[g]\n\n              switch (vc) {\n                case 3:\n                  count += 3 // single triangle\n                  break\n\n                case 4:\n                  count += 6 // quad, subdivided into two triangles\n                  break\n\n                default:\n                  count += (vc - 2) * 3 // polylist with more than four vertices\n                  break\n              }\n            }\n\n            break\n\n          default:\n            console.warn('THREE.ColladaLoader: Unknow primitive type:', primitive.type)\n        }\n\n        geometry.addGroup(start, count, p)\n        start += count\n\n        // material\n\n        if (primitive.material) {\n          materialKeys.push(primitive.material)\n        }\n\n        // geometry data\n\n        for (const name in inputs) {\n          const input = inputs[name]\n\n          switch (name) {\n            case 'VERTEX':\n              for (const key in vertices) {\n                const id = vertices[key]\n\n                switch (key) {\n                  case 'POSITION':\n                    const prevLength = position.array.length\n                    buildGeometryData(primitive, sources[id], input.offset, position.array)\n                    position.stride = sources[id].stride\n\n                    if (sources.skinWeights && sources.skinIndices) {\n                      buildGeometryData(primitive, sources.skinIndices, input.offset, skinIndex.array)\n                      buildGeometryData(primitive, sources.skinWeights, input.offset, skinWeight.array)\n                    }\n\n                    // see #3803\n\n                    if (primitive.hasUV === false && primitives.uvsNeedsFix === true) {\n                      const count = (position.array.length - prevLength) / position.stride\n\n                      for (let i = 0; i < count; i++) {\n                        // fill missing uv coordinates\n\n                        uv.array.push(0, 0)\n                      }\n                    }\n\n                    break\n\n                  case 'NORMAL':\n                    buildGeometryData(primitive, sources[id], input.offset, normal.array)\n                    normal.stride = sources[id].stride\n                    break\n\n                  case 'COLOR':\n                    buildGeometryData(primitive, sources[id], input.offset, color.array)\n                    color.stride = sources[id].stride\n                    break\n\n                  case 'TEXCOORD':\n                    buildGeometryData(primitive, sources[id], input.offset, uv.array)\n                    uv.stride = sources[id].stride\n                    break\n\n                  case 'TEXCOORD1':\n                    buildGeometryData(primitive, sources[id], input.offset, uv1.array)\n                    uv.stride = sources[id].stride\n                    break\n\n                  default:\n                    console.warn('THREE.ColladaLoader: Semantic \"%s\" not handled in geometry build process.', key)\n                }\n              }\n\n              break\n\n            case 'NORMAL':\n              buildGeometryData(primitive, sources[input.id], input.offset, normal.array)\n              normal.stride = sources[input.id].stride\n              break\n\n            case 'COLOR':\n              buildGeometryData(primitive, sources[input.id], input.offset, color.array)\n              color.stride = sources[input.id].stride\n              break\n\n            case 'TEXCOORD':\n              buildGeometryData(primitive, sources[input.id], input.offset, uv.array)\n              uv.stride = sources[input.id].stride\n              break\n\n            case 'TEXCOORD1':\n              buildGeometryData(primitive, sources[input.id], input.offset, uv1.array)\n              uv1.stride = sources[input.id].stride\n              break\n          }\n        }\n      }\n\n      // build geometry\n\n      if (position.array.length > 0) {\n        geometry.setAttribute('position', new Float32BufferAttribute(position.array, position.stride))\n      }\n      if (normal.array.length > 0) {\n        geometry.setAttribute('normal', new Float32BufferAttribute(normal.array, normal.stride))\n      }\n      if (color.array.length > 0) geometry.setAttribute('color', new Float32BufferAttribute(color.array, color.stride))\n      if (uv.array.length > 0) geometry.setAttribute('uv', new Float32BufferAttribute(uv.array, uv.stride))\n      if (uv1.array.length > 0) geometry.setAttribute(UV1, new Float32BufferAttribute(uv1.array, uv1.stride))\n\n      if (skinIndex.array.length > 0) {\n        geometry.setAttribute('skinIndex', new Float32BufferAttribute(skinIndex.array, skinIndex.stride))\n      }\n      if (skinWeight.array.length > 0) {\n        geometry.setAttribute('skinWeight', new Float32BufferAttribute(skinWeight.array, skinWeight.stride))\n      }\n\n      build.data = geometry\n      build.type = primitives[0].type\n      build.materialKeys = materialKeys\n\n      return build\n    }\n\n    function buildGeometryData(primitive, source, offset, array) {\n      const indices = primitive.p\n      const stride = primitive.stride\n      const vcount = primitive.vcount\n\n      function pushVector(i) {\n        let index = indices[i + offset] * sourceStride\n        const length = index + sourceStride\n\n        for (; index < length; index++) {\n          array.push(sourceArray[index])\n        }\n      }\n\n      const sourceArray = source.array\n      const sourceStride = source.stride\n\n      if (primitive.vcount !== undefined) {\n        let index = 0\n\n        for (let i = 0, l = vcount.length; i < l; i++) {\n          const count = vcount[i]\n\n          if (count === 4) {\n            const a = index + stride * 0\n            const b = index + stride * 1\n            const c = index + stride * 2\n            const d = index + stride * 3\n\n            pushVector(a)\n            pushVector(b)\n            pushVector(d)\n            pushVector(b)\n            pushVector(c)\n            pushVector(d)\n          } else if (count === 3) {\n            const a = index + stride * 0\n            const b = index + stride * 1\n            const c = index + stride * 2\n\n            pushVector(a)\n            pushVector(b)\n            pushVector(c)\n          } else if (count > 4) {\n            for (let k = 1, kl = count - 2; k <= kl; k++) {\n              const a = index + stride * 0\n              const b = index + stride * k\n              const c = index + stride * (k + 1)\n\n              pushVector(a)\n              pushVector(b)\n              pushVector(c)\n            }\n          }\n\n          index += stride * count\n        }\n      } else {\n        for (let i = 0, l = indices.length; i < l; i += stride) {\n          pushVector(i)\n        }\n      }\n    }\n\n    function getGeometry(id) {\n      return getBuild(library.geometries[id], buildGeometry)\n    }\n\n    // kinematics\n\n    function parseKinematicsModel(xml) {\n      const data = {\n        name: xml.getAttribute('name') || '',\n        joints: {},\n        links: [],\n      }\n\n      for (let i = 0; i < xml.childNodes.length; i++) {\n        const child = xml.childNodes[i]\n\n        if (child.nodeType !== 1) continue\n\n        switch (child.nodeName) {\n          case 'technique_common':\n            parseKinematicsTechniqueCommon(child, data)\n            break\n        }\n      }\n\n      library.kinematicsModels[xml.getAttribute('id')] = data\n    }\n\n    function buildKinematicsModel(data) {\n      if (data.build !== undefined) return data.build\n\n      return data\n    }\n\n    function getKinematicsModel(id) {\n      return getBuild(library.kinematicsModels[id], buildKinematicsModel)\n    }\n\n    function parseKinematicsTechniqueCommon(xml, data) {\n      for (let i = 0; i < xml.childNodes.length; i++) {\n        const child = xml.childNodes[i]\n\n        if (child.nodeType !== 1) continue\n\n        switch (child.nodeName) {\n          case 'joint':\n            data.joints[child.getAttribute('sid')] = parseKinematicsJoint(child)\n            break\n\n          case 'link':\n            data.links.push(parseKinematicsLink(child))\n            break\n        }\n      }\n    }\n\n    function parseKinematicsJoint(xml) {\n      let data\n\n      for (let i = 0; i < xml.childNodes.length; i++) {\n        const child = xml.childNodes[i]\n\n        if (child.nodeType !== 1) continue\n\n        switch (child.nodeName) {\n          case 'prismatic':\n          case 'revolute':\n            data = parseKinematicsJointParameter(child)\n            break\n        }\n      }\n\n      return data\n    }\n\n    function parseKinematicsJointParameter(xml) {\n      const data = {\n        sid: xml.getAttribute('sid'),\n        name: xml.getAttribute('name') || '',\n        axis: new Vector3(),\n        limits: {\n          min: 0,\n          max: 0,\n        },\n        type: xml.nodeName,\n        static: false,\n        zeroPosition: 0,\n        middlePosition: 0,\n      }\n\n      for (let i = 0; i < xml.childNodes.length; i++) {\n        const child = xml.childNodes[i]\n\n        if (child.nodeType !== 1) continue\n\n        switch (child.nodeName) {\n          case 'axis':\n            const array = parseFloats(child.textContent)\n            data.axis.fromArray(array)\n            break\n          case 'limits':\n            const max = child.getElementsByTagName('max')[0]\n            const min = child.getElementsByTagName('min')[0]\n\n            data.limits.max = parseFloat(max.textContent)\n            data.limits.min = parseFloat(min.textContent)\n            break\n        }\n      }\n\n      // if min is equal to or greater than max, consider the joint static\n\n      if (data.limits.min >= data.limits.max) {\n        data.static = true\n      }\n\n      // calculate middle position\n\n      data.middlePosition = (data.limits.min + data.limits.max) / 2.0\n\n      return data\n    }\n\n    function parseKinematicsLink(xml) {\n      const data = {\n        sid: xml.getAttribute('sid'),\n        name: xml.getAttribute('name') || '',\n        attachments: [],\n        transforms: [],\n      }\n\n      for (let i = 0; i < xml.childNodes.length; i++) {\n        const child = xml.childNodes[i]\n\n        if (child.nodeType !== 1) continue\n\n        switch (child.nodeName) {\n          case 'attachment_full':\n            data.attachments.push(parseKinematicsAttachment(child))\n            break\n\n          case 'matrix':\n          case 'translate':\n          case 'rotate':\n            data.transforms.push(parseKinematicsTransform(child))\n            break\n        }\n      }\n\n      return data\n    }\n\n    function parseKinematicsAttachment(xml) {\n      const data = {\n        joint: xml.getAttribute('joint').split('/').pop(),\n        transforms: [],\n        links: [],\n      }\n\n      for (let i = 0; i < xml.childNodes.length; i++) {\n        const child = xml.childNodes[i]\n\n        if (child.nodeType !== 1) continue\n\n        switch (child.nodeName) {\n          case 'link':\n            data.links.push(parseKinematicsLink(child))\n            break\n\n          case 'matrix':\n          case 'translate':\n          case 'rotate':\n            data.transforms.push(parseKinematicsTransform(child))\n            break\n        }\n      }\n\n      return data\n    }\n\n    function parseKinematicsTransform(xml) {\n      const data = {\n        type: xml.nodeName,\n      }\n\n      const array = parseFloats(xml.textContent)\n\n      switch (data.type) {\n        case 'matrix':\n          data.obj = new Matrix4()\n          data.obj.fromArray(array).transpose()\n          break\n\n        case 'translate':\n          data.obj = new Vector3()\n          data.obj.fromArray(array)\n          break\n\n        case 'rotate':\n          data.obj = new Vector3()\n          data.obj.fromArray(array)\n          data.angle = MathUtils.degToRad(array[3])\n          break\n      }\n\n      return data\n    }\n\n    // physics\n\n    function parsePhysicsModel(xml) {\n      const data = {\n        name: xml.getAttribute('name') || '',\n        rigidBodies: {},\n      }\n\n      for (let i = 0; i < xml.childNodes.length; i++) {\n        const child = xml.childNodes[i]\n\n        if (child.nodeType !== 1) continue\n\n        switch (child.nodeName) {\n          case 'rigid_body':\n            data.rigidBodies[child.getAttribute('name')] = {}\n            parsePhysicsRigidBody(child, data.rigidBodies[child.getAttribute('name')])\n            break\n        }\n      }\n\n      library.physicsModels[xml.getAttribute('id')] = data\n    }\n\n    function parsePhysicsRigidBody(xml, data) {\n      for (let i = 0; i < xml.childNodes.length; i++) {\n        const child = xml.childNodes[i]\n\n        if (child.nodeType !== 1) continue\n\n        switch (child.nodeName) {\n          case 'technique_common':\n            parsePhysicsTechniqueCommon(child, data)\n            break\n        }\n      }\n    }\n\n    function parsePhysicsTechniqueCommon(xml, data) {\n      for (let i = 0; i < xml.childNodes.length; i++) {\n        const child = xml.childNodes[i]\n\n        if (child.nodeType !== 1) continue\n\n        switch (child.nodeName) {\n          case 'inertia':\n            data.inertia = parseFloats(child.textContent)\n            break\n\n          case 'mass':\n            data.mass = parseFloats(child.textContent)[0]\n            break\n        }\n      }\n    }\n\n    // scene\n\n    function parseKinematicsScene(xml) {\n      const data = {\n        bindJointAxis: [],\n      }\n\n      for (let i = 0; i < xml.childNodes.length; i++) {\n        const child = xml.childNodes[i]\n\n        if (child.nodeType !== 1) continue\n\n        switch (child.nodeName) {\n          case 'bind_joint_axis':\n            data.bindJointAxis.push(parseKinematicsBindJointAxis(child))\n            break\n        }\n      }\n\n      library.kinematicsScenes[parseId(xml.getAttribute('url'))] = data\n    }\n\n    function parseKinematicsBindJointAxis(xml) {\n      const data = {\n        target: xml.getAttribute('target').split('/').pop(),\n      }\n\n      for (let i = 0; i < xml.childNodes.length; i++) {\n        const child = xml.childNodes[i]\n\n        if (child.nodeType !== 1) continue\n\n        switch (child.nodeName) {\n          case 'axis':\n            const param = child.getElementsByTagName('param')[0]\n            data.axis = param.textContent\n            const tmpJointIndex = data.axis.split('inst_').pop().split('axis')[0]\n            data.jointIndex = tmpJointIndex.substr(0, tmpJointIndex.length - 1)\n            break\n        }\n      }\n\n      return data\n    }\n\n    function buildKinematicsScene(data) {\n      if (data.build !== undefined) return data.build\n\n      return data\n    }\n\n    function getKinematicsScene(id) {\n      return getBuild(library.kinematicsScenes[id], buildKinematicsScene)\n    }\n\n    function setupKinematics() {\n      const kinematicsModelId = Object.keys(library.kinematicsModels)[0]\n      const kinematicsSceneId = Object.keys(library.kinematicsScenes)[0]\n      const visualSceneId = Object.keys(library.visualScenes)[0]\n\n      if (kinematicsModelId === undefined || kinematicsSceneId === undefined) return\n\n      const kinematicsModel = getKinematicsModel(kinematicsModelId)\n      const kinematicsScene = getKinematicsScene(kinematicsSceneId)\n      const visualScene = getVisualScene(visualSceneId)\n\n      const bindJointAxis = kinematicsScene.bindJointAxis\n      const jointMap = {}\n\n      for (let i = 0, l = bindJointAxis.length; i < l; i++) {\n        const axis = bindJointAxis[i]\n\n        // the result of the following query is an element of type 'translate', 'rotate','scale' or 'matrix'\n\n        const targetElement = collada.querySelector('[sid=\"' + axis.target + '\"]')\n\n        if (targetElement) {\n          // get the parent of the transform element\n\n          const parentVisualElement = targetElement.parentElement\n\n          // connect the joint of the kinematics model with the element in the visual scene\n\n          connect(axis.jointIndex, parentVisualElement)\n        }\n      }\n\n      function connect(jointIndex, visualElement) {\n        const visualElementName = visualElement.getAttribute('name')\n        const joint = kinematicsModel.joints[jointIndex]\n\n        visualScene.traverse(function (object) {\n          if (object.name === visualElementName) {\n            jointMap[jointIndex] = {\n              object: object,\n              transforms: buildTransformList(visualElement),\n              joint: joint,\n              position: joint.zeroPosition,\n            }\n          }\n        })\n      }\n\n      const m0 = new Matrix4()\n\n      kinematics = {\n        joints: kinematicsModel && kinematicsModel.joints,\n\n        getJointValue: function (jointIndex) {\n          const jointData = jointMap[jointIndex]\n\n          if (jointData) {\n            return jointData.position\n          } else {\n            console.warn('THREE.ColladaLoader: Joint ' + jointIndex + \" doesn't exist.\")\n          }\n        },\n\n        setJointValue: function (jointIndex, value) {\n          const jointData = jointMap[jointIndex]\n\n          if (jointData) {\n            const joint = jointData.joint\n\n            if (value > joint.limits.max || value < joint.limits.min) {\n              console.warn(\n                'THREE.ColladaLoader: Joint ' +\n                jointIndex +\n                ' value ' +\n                value +\n                ' outside of limits (min: ' +\n                joint.limits.min +\n                ', max: ' +\n                joint.limits.max +\n                ').',\n              )\n            } else if (joint.static) {\n              console.warn('THREE.ColladaLoader: Joint ' + jointIndex + ' is static.')\n            } else {\n              const object = jointData.object\n              const axis = joint.axis\n              const transforms = jointData.transforms\n\n              matrix.identity()\n\n              // each update, we have to apply all transforms in the correct order\n\n              for (let i = 0; i < transforms.length; i++) {\n                const transform = transforms[i]\n\n                // if there is a connection of the transform node with a joint, apply the joint value\n\n                if (transform.sid && transform.sid.indexOf(jointIndex) !== -1) {\n                  switch (joint.type) {\n                    case 'revolute':\n                      matrix.multiply(m0.makeRotationAxis(axis, MathUtils.degToRad(value)))\n                      break\n\n                    case 'prismatic':\n                      matrix.multiply(m0.makeTranslation(axis.x * value, axis.y * value, axis.z * value))\n                      break\n\n                    default:\n                      console.warn('THREE.ColladaLoader: Unknown joint type: ' + joint.type)\n                      break\n                  }\n                } else {\n                  switch (transform.type) {\n                    case 'matrix':\n                      matrix.multiply(transform.obj)\n                      break\n\n                    case 'translate':\n                      matrix.multiply(m0.makeTranslation(transform.obj.x, transform.obj.y, transform.obj.z))\n                      break\n\n                    case 'scale':\n                      matrix.scale(transform.obj)\n                      break\n\n                    case 'rotate':\n                      matrix.multiply(m0.makeRotationAxis(transform.obj, transform.angle))\n                      break\n                  }\n                }\n              }\n\n              object.matrix.copy(matrix)\n              object.matrix.decompose(object.position, object.quaternion, object.scale)\n\n              jointMap[jointIndex].position = value\n            }\n          } else {\n            console.log('THREE.ColladaLoader: ' + jointIndex + ' does not exist.')\n          }\n        },\n      }\n    }\n\n    function buildTransformList(node) {\n      const transforms = []\n\n      const xml = collada.querySelector('[id=\"' + node.id + '\"]')\n\n      for (let i = 0; i < xml.childNodes.length; i++) {\n        const child = xml.childNodes[i]\n\n        if (child.nodeType !== 1) continue\n\n        let array, vector\n\n        switch (child.nodeName) {\n          case 'matrix':\n            array = parseFloats(child.textContent)\n            const matrix = new Matrix4().fromArray(array).transpose()\n            transforms.push({\n              sid: child.getAttribute('sid'),\n              type: child.nodeName,\n              obj: matrix,\n            })\n            break\n\n          case 'translate':\n          case 'scale':\n            array = parseFloats(child.textContent)\n            vector = new Vector3().fromArray(array)\n            transforms.push({\n              sid: child.getAttribute('sid'),\n              type: child.nodeName,\n              obj: vector,\n            })\n            break\n\n          case 'rotate':\n            array = parseFloats(child.textContent)\n            vector = new Vector3().fromArray(array)\n            const angle = MathUtils.degToRad(array[3])\n            transforms.push({\n              sid: child.getAttribute('sid'),\n              type: child.nodeName,\n              obj: vector,\n              angle: angle,\n            })\n            break\n        }\n      }\n\n      return transforms\n    }\n\n    // nodes\n\n    function prepareNodes(xml) {\n      const elements = xml.getElementsByTagName('node')\n\n      // ensure all node elements have id attributes\n\n      for (let i = 0; i < elements.length; i++) {\n        const element = elements[i]\n\n        if (element.hasAttribute('id') === false) {\n          element.setAttribute('id', generateId())\n        }\n      }\n    }\n\n    const matrix = new Matrix4()\n    const vector = new Vector3()\n\n    function parseNode(xml) {\n      const data = {\n        name: xml.getAttribute('name') || '',\n        type: xml.getAttribute('type'),\n        id: xml.getAttribute('id'),\n        sid: xml.getAttribute('sid'),\n        matrix: new Matrix4(),\n        nodes: [],\n        instanceCameras: [],\n        instanceControllers: [],\n        instanceLights: [],\n        instanceGeometries: [],\n        instanceNodes: [],\n        transforms: {},\n      }\n\n      for (let i = 0; i < xml.childNodes.length; i++) {\n        const child = xml.childNodes[i]\n\n        if (child.nodeType !== 1) continue\n\n        let array\n\n        switch (child.nodeName) {\n          case 'node':\n            data.nodes.push(child.getAttribute('id'))\n            parseNode(child)\n            break\n\n          case 'instance_camera':\n            data.instanceCameras.push(parseId(child.getAttribute('url')))\n            break\n\n          case 'instance_controller':\n            data.instanceControllers.push(parseNodeInstance(child))\n            break\n\n          case 'instance_light':\n            data.instanceLights.push(parseId(child.getAttribute('url')))\n            break\n\n          case 'instance_geometry':\n            data.instanceGeometries.push(parseNodeInstance(child))\n            break\n\n          case 'instance_node':\n            data.instanceNodes.push(parseId(child.getAttribute('url')))\n            break\n\n          case 'matrix':\n            array = parseFloats(child.textContent)\n            data.matrix.multiply(matrix.fromArray(array).transpose())\n            data.transforms[child.getAttribute('sid')] = child.nodeName\n            break\n\n          case 'translate':\n            array = parseFloats(child.textContent)\n            vector.fromArray(array)\n            data.matrix.multiply(matrix.makeTranslation(vector.x, vector.y, vector.z))\n            data.transforms[child.getAttribute('sid')] = child.nodeName\n            break\n\n          case 'rotate':\n            array = parseFloats(child.textContent)\n            const angle = MathUtils.degToRad(array[3])\n            data.matrix.multiply(matrix.makeRotationAxis(vector.fromArray(array), angle))\n            data.transforms[child.getAttribute('sid')] = child.nodeName\n            break\n\n          case 'scale':\n            array = parseFloats(child.textContent)\n            data.matrix.scale(vector.fromArray(array))\n            data.transforms[child.getAttribute('sid')] = child.nodeName\n            break\n\n          case 'extra':\n            break\n\n          default:\n            console.log(child)\n        }\n      }\n\n      if (hasNode(data.id)) {\n        console.warn(\n          'THREE.ColladaLoader: There is already a node with ID %s. Exclude current node from further processing.',\n          data.id,\n        )\n      } else {\n        library.nodes[data.id] = data\n      }\n\n      return data\n    }\n\n    function parseNodeInstance(xml) {\n      const data = {\n        id: parseId(xml.getAttribute('url')),\n        materials: {},\n        skeletons: [],\n      }\n\n      for (let i = 0; i < xml.childNodes.length; i++) {\n        const child = xml.childNodes[i]\n\n        switch (child.nodeName) {\n          case 'bind_material':\n            const instances = child.getElementsByTagName('instance_material')\n\n            for (let j = 0; j < instances.length; j++) {\n              const instance = instances[j]\n              const symbol = instance.getAttribute('symbol')\n              const target = instance.getAttribute('target')\n\n              data.materials[symbol] = parseId(target)\n            }\n\n            break\n\n          case 'skeleton':\n            data.skeletons.push(parseId(child.textContent))\n            break\n\n          default:\n            break\n        }\n      }\n\n      return data\n    }\n\n    function buildSkeleton(skeletons, joints) {\n      const boneData = []\n      const sortedBoneData = []\n\n      let i, j, data\n\n      // a skeleton can have multiple root bones. collada expresses this\n      // situtation with multiple \"skeleton\" tags per controller instance\n\n      for (i = 0; i < skeletons.length; i++) {\n        const skeleton = skeletons[i]\n\n        let root\n\n        if (hasNode(skeleton)) {\n          root = getNode(skeleton)\n          buildBoneHierarchy(root, joints, boneData)\n        } else if (hasVisualScene(skeleton)) {\n          // handle case where the skeleton refers to the visual scene (#13335)\n\n          const visualScene = library.visualScenes[skeleton]\n          const children = visualScene.children\n\n          for (let j = 0; j < children.length; j++) {\n            const child = children[j]\n\n            if (child.type === 'JOINT') {\n              const root = getNode(child.id)\n              buildBoneHierarchy(root, joints, boneData)\n            }\n          }\n        } else {\n          console.error('THREE.ColladaLoader: Unable to find root bone of skeleton with ID:', skeleton)\n        }\n      }\n\n      // sort bone data (the order is defined in the corresponding controller)\n\n      for (i = 0; i < joints.length; i++) {\n        for (j = 0; j < boneData.length; j++) {\n          data = boneData[j]\n\n          if (data.bone.name === joints[i].name) {\n            sortedBoneData[i] = data\n            data.processed = true\n            break\n          }\n        }\n      }\n\n      // add unprocessed bone data at the end of the list\n\n      for (i = 0; i < boneData.length; i++) {\n        data = boneData[i]\n\n        if (data.processed === false) {\n          sortedBoneData.push(data)\n          data.processed = true\n        }\n      }\n\n      // setup arrays for skeleton creation\n\n      const bones = []\n      const boneInverses = []\n\n      for (i = 0; i < sortedBoneData.length; i++) {\n        data = sortedBoneData[i]\n\n        bones.push(data.bone)\n        boneInverses.push(data.boneInverse)\n      }\n\n      return new Skeleton(bones, boneInverses)\n    }\n\n    function buildBoneHierarchy(root, joints, boneData) {\n      // setup bone data from visual scene\n\n      root.traverse(function (object) {\n        if (object.isBone === true) {\n          let boneInverse\n\n          // retrieve the boneInverse from the controller data\n\n          for (let i = 0; i < joints.length; i++) {\n            const joint = joints[i]\n\n            if (joint.name === object.name) {\n              boneInverse = joint.boneInverse\n              break\n            }\n          }\n\n          if (boneInverse === undefined) {\n            // Unfortunately, there can be joints in the visual scene that are not part of the\n            // corresponding controller. In this case, we have to create a dummy boneInverse matrix\n            // for the respective bone. This bone won't affect any vertices, because there are no skin indices\n            // and weights defined for it. But we still have to add the bone to the sorted bone list in order to\n            // ensure a correct animation of the model.\n\n            boneInverse = new Matrix4()\n          }\n\n          boneData.push({ bone: object, boneInverse: boneInverse, processed: false })\n        }\n      })\n    }\n\n    function buildNode(data) {\n      const objects = []\n\n      const matrix = data.matrix\n      const nodes = data.nodes\n      const type = data.type\n      const instanceCameras = data.instanceCameras\n      const instanceControllers = data.instanceControllers\n      const instanceLights = data.instanceLights\n      const instanceGeometries = data.instanceGeometries\n      const instanceNodes = data.instanceNodes\n\n      // nodes\n\n      for (let i = 0, l = nodes.length; i < l; i++) {\n        objects.push(getNode(nodes[i]))\n      }\n\n      // instance cameras\n\n      for (let i = 0, l = instanceCameras.length; i < l; i++) {\n        const instanceCamera = getCamera(instanceCameras[i])\n\n        if (instanceCamera !== null) {\n          objects.push(instanceCamera.clone())\n        }\n      }\n\n      // instance controllers\n\n      for (let i = 0, l = instanceControllers.length; i < l; i++) {\n        const instance = instanceControllers[i]\n        const controller = getController(instance.id)\n        const geometries = getGeometry(controller.id)\n        const newObjects = buildObjects(geometries, instance.materials)\n\n        const skeletons = instance.skeletons\n        const joints = controller.skin.joints\n\n        const skeleton = buildSkeleton(skeletons, joints)\n\n        for (let j = 0, jl = newObjects.length; j < jl; j++) {\n          const object = newObjects[j]\n\n          if (object.isSkinnedMesh) {\n            object.bind(skeleton, controller.skin.bindMatrix)\n            object.normalizeSkinWeights()\n          }\n\n          objects.push(object)\n        }\n      }\n\n      // instance lights\n\n      for (let i = 0, l = instanceLights.length; i < l; i++) {\n        const instanceLight = getLight(instanceLights[i])\n\n        if (instanceLight !== null) {\n          objects.push(instanceLight.clone())\n        }\n      }\n\n      // instance geometries\n\n      for (let i = 0, l = instanceGeometries.length; i < l; i++) {\n        const instance = instanceGeometries[i]\n\n        // a single geometry instance in collada can lead to multiple object3Ds.\n        // this is the case when primitives are combined like triangles and lines\n\n        const geometries = getGeometry(instance.id)\n        const newObjects = buildObjects(geometries, instance.materials)\n\n        for (let j = 0, jl = newObjects.length; j < jl; j++) {\n          objects.push(newObjects[j])\n        }\n      }\n\n      // instance nodes\n\n      for (let i = 0, l = instanceNodes.length; i < l; i++) {\n        objects.push(getNode(instanceNodes[i]).clone())\n      }\n\n      let object\n\n      if (nodes.length === 0 && objects.length === 1) {\n        object = objects[0]\n      } else {\n        object = type === 'JOINT' ? new Bone() : new Group()\n\n        for (let i = 0; i < objects.length; i++) {\n          object.add(objects[i])\n        }\n      }\n\n      object.name = type === 'JOINT' ? data.sid : data.name\n      object.matrix.copy(matrix)\n      object.matrix.decompose(object.position, object.quaternion, object.scale)\n\n      return object\n    }\n\n    const fallbackMaterial = new MeshBasicMaterial({ color: 0xff00ff })\n\n    function resolveMaterialBinding(keys, instanceMaterials) {\n      const materials = []\n\n      for (let i = 0, l = keys.length; i < l; i++) {\n        const id = instanceMaterials[keys[i]]\n\n        if (id === undefined) {\n          console.warn('THREE.ColladaLoader: Material with key %s not found. Apply fallback material.', keys[i])\n          materials.push(fallbackMaterial)\n        } else {\n          materials.push(getMaterial(id))\n        }\n      }\n\n      return materials\n    }\n\n    function buildObjects(geometries, instanceMaterials) {\n      const objects = []\n\n      for (const type in geometries) {\n        const geometry = geometries[type]\n\n        const materials = resolveMaterialBinding(geometry.materialKeys, instanceMaterials)\n\n        // handle case if no materials are defined\n\n        if (materials.length === 0) {\n          if (type === 'lines' || type === 'linestrips') {\n            materials.push(new LineBasicMaterial())\n          } else {\n            materials.push(new MeshPhongMaterial())\n          }\n        }\n\n        // regard skinning\n\n        const skinning = geometry.data.attributes.skinIndex !== undefined\n\n        // choose between a single or multi materials (material array)\n\n        const material = materials.length === 1 ? materials[0] : materials\n\n        // now create a specific 3D object\n\n        let object\n\n        switch (type) {\n          case 'lines':\n            object = new LineSegments(geometry.data, material)\n            break\n\n          case 'linestrips':\n            object = new Line(geometry.data, material)\n            break\n\n          case 'triangles':\n          case 'polylist':\n            if (skinning) {\n              object = new SkinnedMesh(geometry.data, material)\n            } else {\n              object = new Mesh(geometry.data, material)\n            }\n\n            break\n        }\n\n        objects.push(object)\n      }\n\n      return objects\n    }\n\n    function hasNode(id) {\n      return library.nodes[id] !== undefined\n    }\n\n    function getNode(id) {\n      return getBuild(library.nodes[id], buildNode)\n    }\n\n    // visual scenes\n\n    function parseVisualScene(xml) {\n      const data = {\n        name: xml.getAttribute('name'),\n        children: [],\n      }\n\n      prepareNodes(xml)\n\n      const elements = getElementsByTagName(xml, 'node')\n\n      for (let i = 0; i < elements.length; i++) {\n        data.children.push(parseNode(elements[i]))\n      }\n\n      library.visualScenes[xml.getAttribute('id')] = data\n    }\n\n    function buildVisualScene(data) {\n      const group = new Group()\n      group.name = data.name\n\n      const children = data.children\n\n      for (let i = 0; i < children.length; i++) {\n        const child = children[i]\n\n        group.add(getNode(child.id))\n      }\n\n      return group\n    }\n\n    function hasVisualScene(id) {\n      return library.visualScenes[id] !== undefined\n    }\n\n    function getVisualScene(id) {\n      return getBuild(library.visualScenes[id], buildVisualScene)\n    }\n\n    // scenes\n\n    function parseScene(xml) {\n      const instance = getElementsByTagName(xml, 'instance_visual_scene')[0]\n      return getVisualScene(parseId(instance.getAttribute('url')))\n    }\n\n    function setupAnimations() {\n      const clips = library.clips\n\n      if (isEmpty(clips) === true) {\n        if (isEmpty(library.animations) === false) {\n          // if there are animations but no clips, we create a default clip for playback\n\n          const tracks = []\n\n          for (const id in library.animations) {\n            const animationTracks = getAnimation(id)\n\n            for (let i = 0, l = animationTracks.length; i < l; i++) {\n              tracks.push(animationTracks[i])\n            }\n          }\n\n          animations.push(new AnimationClip('default', -1, tracks))\n        }\n      } else {\n        for (const id in clips) {\n          animations.push(getAnimationClip(id))\n        }\n      }\n    }\n\n    // convert the parser error element into text with each child elements text\n    // separated by new lines.\n\n    function parserErrorToText(parserError) {\n      let result = ''\n      const stack = [parserError]\n\n      while (stack.length) {\n        const node = stack.shift()\n\n        if (node.nodeType === Node.TEXT_NODE) {\n          result += node.textContent\n        } else {\n          result += '\\n'\n          stack.push.apply(stack, node.childNodes)\n        }\n      }\n\n      return result.trim()\n    }\n\n    if (text.length === 0) {\n      return { scene: new Scene() }\n    }\n\n    const xml = new DOMParser().parseFromString(text, 'application/xml')\n\n    const collada = getElementsByTagName(xml, 'COLLADA')[0]\n\n    const parserError = xml.getElementsByTagName('parsererror')[0]\n    if (parserError !== undefined) {\n      // Chrome will return parser error with a div in it\n\n      const errorElement = getElementsByTagName(parserError, 'div')[0]\n      let errorText\n\n      if (errorElement) {\n        errorText = errorElement.textContent\n      } else {\n        errorText = parserErrorToText(parserError)\n      }\n\n      console.error('THREE.ColladaLoader: Failed to parse collada file.\\n', errorText)\n\n      return null\n    }\n\n    // metadata\n\n    const version = collada.getAttribute('version')\n    console.log('THREE.ColladaLoader: File version', version)\n\n    const asset = parseAsset(getElementsByTagName(collada, 'asset')[0])\n    const textureLoader = new TextureLoader(this.manager)\n    textureLoader.setPath(this.resourcePath || path).setCrossOrigin(this.crossOrigin)\n\n    let tgaLoader\n\n    if (TGALoader) {\n      tgaLoader = new TGALoader(this.manager)\n      tgaLoader.setPath(this.resourcePath || path)\n    }\n\n    //\n\n    const animations = []\n    let kinematics = {}\n    let count = 0\n\n    //\n\n    const library = {\n      animations: {},\n      clips: {},\n      controllers: {},\n      images: {},\n      effects: {},\n      materials: {},\n      cameras: {},\n      lights: {},\n      geometries: {},\n      nodes: {},\n      visualScenes: {},\n      kinematicsModels: {},\n      physicsModels: {},\n      kinematicsScenes: {},\n    }\n\n    parseLibrary(collada, 'library_animations', 'animation', parseAnimation)\n    parseLibrary(collada, 'library_animation_clips', 'animation_clip', parseAnimationClip)\n    parseLibrary(collada, 'library_controllers', 'controller', parseController)\n    parseLibrary(collada, 'library_images', 'image', parseImage)\n    parseLibrary(collada, 'library_effects', 'effect', parseEffect)\n    parseLibrary(collada, 'library_materials', 'material', parseMaterial)\n    parseLibrary(collada, 'library_cameras', 'camera', parseCamera)\n    parseLibrary(collada, 'library_lights', 'light', parseLight)\n    parseLibrary(collada, 'library_geometries', 'geometry', parseGeometry)\n    parseLibrary(collada, 'library_nodes', 'node', parseNode)\n    parseLibrary(collada, 'library_visual_scenes', 'visual_scene', parseVisualScene)\n    parseLibrary(collada, 'library_kinematics_models', 'kinematics_model', parseKinematicsModel)\n    parseLibrary(collada, 'library_physics_models', 'physics_model', parsePhysicsModel)\n    parseLibrary(collada, 'scene', 'instance_kinematics_scene', parseKinematicsScene)\n\n    buildLibrary(library.animations, buildAnimation)\n    buildLibrary(library.clips, buildAnimationClip)\n    buildLibrary(library.controllers, buildController)\n    buildLibrary(library.images, buildImage)\n    buildLibrary(library.effects, buildEffect)\n    buildLibrary(library.materials, buildMaterial)\n    buildLibrary(library.cameras, buildCamera)\n    buildLibrary(library.lights, buildLight)\n    buildLibrary(library.geometries, buildGeometry)\n    buildLibrary(library.visualScenes, buildVisualScene)\n\n    setupAnimations()\n    setupKinematics()\n\n    const scene = parseScene(getElementsByTagName(collada, 'scene')[0])\n    scene.animations = animations\n\n    if (asset.upAxis === 'Z_UP') {\n      scene.quaternion.setFromEuler(new Euler(-Math.PI / 2, 0, 0))\n    }\n\n    scene.scale.multiplyScalar(asset.unit)\n\n    return {\n      get animations() {\n        console.warn('THREE.ColladaLoader: Please access animations over scene.animations now.')\n        return animations\n      },\n      kinematics: kinematics,\n      library: library,\n      scene: scene,\n    }\n  }\n}\n\nexport { ColladaLoader }\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}