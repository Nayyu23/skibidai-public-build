{"ast":null,"code":"import _regeneratorRuntime from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nfunction AmmoPhysics() {\n  return _AmmoPhysics.apply(this, arguments);\n}\nfunction _AmmoPhysics() {\n  _AmmoPhysics = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n    var AmmoLib, frameRate, collisionConfiguration, dispatcher, broadphase, solver, world, worldTransform, getShape, meshes, meshMap, addMesh, handleMesh, handleInstancedMesh, setMeshPosition, lastTime, step;\n    return _regeneratorRuntime().wrap(function _callee$(_context) {\n      while (1) switch (_context.prev = _context.next) {\n        case 0:\n          step = function _step() {\n            var time = performance.now();\n            if (lastTime > 0) {\n              var delta = (time - lastTime) / 1e3;\n              world.stepSimulation(delta, 10);\n            }\n            lastTime = time;\n            for (var i = 0, l = meshes.length; i < l; i++) {\n              var mesh = meshes[i];\n              if (mesh.isInstancedMesh) {\n                var array = mesh.instanceMatrix.array;\n                var bodies = meshMap.get(mesh);\n                for (var j = 0; j < bodies.length; j++) {\n                  var body = bodies[j];\n                  var motionState = body.getMotionState();\n                  motionState.getWorldTransform(worldTransform);\n                  var position = worldTransform.getOrigin();\n                  var quaternion = worldTransform.getRotation();\n                  compose(position, quaternion, array, j * 16);\n                }\n                mesh.instanceMatrix.needsUpdate = true;\n              } else if (mesh.isMesh) {\n                var _body2 = meshMap.get(mesh);\n                var _motionState = _body2.getMotionState();\n                _motionState.getWorldTransform(worldTransform);\n                var _position = worldTransform.getOrigin();\n                var _quaternion = worldTransform.getRotation();\n                mesh.position.set(_position.x(), _position.y(), _position.z());\n                mesh.quaternion.set(_quaternion.x(), _quaternion.y(), _quaternion.z(), _quaternion.w());\n              }\n            }\n          };\n          setMeshPosition = function _setMeshPosition(mesh, position) {\n            var index = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n            if (mesh.isInstancedMesh) {\n              var bodies = meshMap.get(mesh);\n              var body = bodies[index];\n              body.setAngularVelocity(new AmmoLib.btVector3(0, 0, 0));\n              body.setLinearVelocity(new AmmoLib.btVector3(0, 0, 0));\n              worldTransform.setIdentity();\n              worldTransform.setOrigin(new AmmoLib.btVector3(position.x, position.y, position.z));\n              body.setWorldTransform(worldTransform);\n            } else if (mesh.isMesh) {\n              var _body = meshMap.get(mesh);\n              _body.setAngularVelocity(new AmmoLib.btVector3(0, 0, 0));\n              _body.setLinearVelocity(new AmmoLib.btVector3(0, 0, 0));\n              worldTransform.setIdentity();\n              worldTransform.setOrigin(new AmmoLib.btVector3(position.x, position.y, position.z));\n              _body.setWorldTransform(worldTransform);\n            }\n          };\n          handleInstancedMesh = function _handleInstancedMesh(mesh, mass, shape) {\n            var array = mesh.instanceMatrix.array;\n            var bodies = [];\n            for (var i = 0; i < mesh.count; i++) {\n              var index = i * 16;\n              var transform = new AmmoLib.btTransform();\n              transform.setFromOpenGLMatrix(array.slice(index, index + 16));\n              var motionState = new AmmoLib.btDefaultMotionState(transform);\n              var localInertia = new AmmoLib.btVector3(0, 0, 0);\n              shape.calculateLocalInertia(mass, localInertia);\n              var rbInfo = new AmmoLib.btRigidBodyConstructionInfo(mass, motionState, shape, localInertia);\n              var body = new AmmoLib.btRigidBody(rbInfo);\n              world.addRigidBody(body);\n              bodies.push(body);\n            }\n            if (mass > 0) {\n              mesh.instanceMatrix.setUsage(35048);\n              meshes.push(mesh);\n              meshMap.set(mesh, bodies);\n            }\n          };\n          handleMesh = function _handleMesh(mesh, mass, shape) {\n            var position = mesh.position;\n            var quaternion = mesh.quaternion;\n            var transform = new AmmoLib.btTransform();\n            transform.setIdentity();\n            transform.setOrigin(new AmmoLib.btVector3(position.x, position.y, position.z));\n            transform.setRotation(new AmmoLib.btQuaternion(quaternion.x, quaternion.y, quaternion.z, quaternion.w));\n            var motionState = new AmmoLib.btDefaultMotionState(transform);\n            var localInertia = new AmmoLib.btVector3(0, 0, 0);\n            shape.calculateLocalInertia(mass, localInertia);\n            var rbInfo = new AmmoLib.btRigidBodyConstructionInfo(mass, motionState, shape, localInertia);\n            var body = new AmmoLib.btRigidBody(rbInfo);\n            world.addRigidBody(body);\n            if (mass > 0) {\n              meshes.push(mesh);\n              meshMap.set(mesh, body);\n            }\n          };\n          addMesh = function _addMesh(mesh) {\n            var mass = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n            var shape = getShape(mesh.geometry);\n            if (shape !== null) {\n              if (mesh.isInstancedMesh) {\n                handleInstancedMesh(mesh, mass, shape);\n              } else if (mesh.isMesh) {\n                handleMesh(mesh, mass, shape);\n              }\n            }\n          };\n          getShape = function _getShape(geometry) {\n            var parameters = geometry.parameters;\n            if (geometry.type === \"BoxGeometry\") {\n              var sx = parameters.width !== void 0 ? parameters.width / 2 : 0.5;\n              var sy = parameters.height !== void 0 ? parameters.height / 2 : 0.5;\n              var sz = parameters.depth !== void 0 ? parameters.depth / 2 : 0.5;\n              var shape = new AmmoLib.btBoxShape(new AmmoLib.btVector3(sx, sy, sz));\n              shape.setMargin(0.05);\n              return shape;\n            } else if (geometry.type === \"SphereGeometry\" || geometry.type === \"IcosahedronGeometry\") {\n              var radius = parameters.radius !== void 0 ? parameters.radius : 1;\n              var _shape = new AmmoLib.btSphereShape(radius);\n              _shape.setMargin(0.05);\n              return _shape;\n            }\n            return null;\n          };\n          if (!(\"Ammo\" in window === false)) {\n            _context.next = 9;\n            break;\n          }\n          console.error(\"AmmoPhysics: Couldn't find Ammo.js\");\n          return _context.abrupt(\"return\");\n        case 9:\n          _context.next = 11;\n          return Ammo();\n        case 11:\n          AmmoLib = _context.sent;\n          frameRate = 60;\n          collisionConfiguration = new AmmoLib.btDefaultCollisionConfiguration();\n          dispatcher = new AmmoLib.btCollisionDispatcher(collisionConfiguration);\n          broadphase = new AmmoLib.btDbvtBroadphase();\n          solver = new AmmoLib.btSequentialImpulseConstraintSolver();\n          world = new AmmoLib.btDiscreteDynamicsWorld(dispatcher, broadphase, solver, collisionConfiguration);\n          world.setGravity(new AmmoLib.btVector3(0, -9.8, 0));\n          worldTransform = new AmmoLib.btTransform();\n          meshes = [];\n          meshMap = /* @__PURE__ */new WeakMap();\n          lastTime = 0;\n          setInterval(step, 1e3 / frameRate);\n          return _context.abrupt(\"return\", {\n            addMesh: addMesh,\n            setMeshPosition: setMeshPosition\n            // addCompoundMesh\n          });\n        case 25:\n        case \"end\":\n          return _context.stop();\n      }\n    }, _callee);\n  }));\n  return _AmmoPhysics.apply(this, arguments);\n}\nfunction compose(position, quaternion, array, index) {\n  var x = quaternion.x(),\n    y = quaternion.y(),\n    z = quaternion.z(),\n    w = quaternion.w();\n  var x2 = x + x,\n    y2 = y + y,\n    z2 = z + z;\n  var xx = x * x2,\n    xy = x * y2,\n    xz = x * z2;\n  var yy = y * y2,\n    yz = y * z2,\n    zz = z * z2;\n  var wx = w * x2,\n    wy = w * y2,\n    wz = w * z2;\n  array[index + 0] = 1 - (yy + zz);\n  array[index + 1] = xy + wz;\n  array[index + 2] = xz - wy;\n  array[index + 3] = 0;\n  array[index + 4] = xy - wz;\n  array[index + 5] = 1 - (xx + zz);\n  array[index + 6] = yz + wx;\n  array[index + 7] = 0;\n  array[index + 8] = xz + wy;\n  array[index + 9] = yz - wx;\n  array[index + 10] = 1 - (xx + yy);\n  array[index + 11] = 0;\n  array[index + 12] = position.x();\n  array[index + 13] = position.y();\n  array[index + 14] = position.z();\n  array[index + 15] = 1;\n}\nexport { AmmoPhysics };","map":{"version":3,"names":["AmmoPhysics","_AmmoPhysics","apply","arguments","_asyncToGenerator","_regeneratorRuntime","mark","_callee","AmmoLib","frameRate","collisionConfiguration","dispatcher","broadphase","solver","world","worldTransform","getShape","meshes","meshMap","addMesh","handleMesh","handleInstancedMesh","setMeshPosition","lastTime","step","wrap","_callee$","_context","prev","next","_step","time","performance","now","delta","stepSimulation","i","l","length","mesh","isInstancedMesh","array","instanceMatrix","bodies","get","j","body","motionState","getMotionState","getWorldTransform","position","getOrigin","quaternion","getRotation","compose","needsUpdate","isMesh","set","x","y","z","w","_setMeshPosition","index","undefined","setAngularVelocity","btVector3","setLinearVelocity","setIdentity","setOrigin","setWorldTransform","_handleInstancedMesh","mass","shape","count","transform","btTransform","setFromOpenGLMatrix","slice","btDefaultMotionState","localInertia","calculateLocalInertia","rbInfo","btRigidBodyConstructionInfo","btRigidBody","addRigidBody","push","setUsage","_handleMesh","setRotation","btQuaternion","_addMesh","geometry","_getShape","parameters","type","sx","width","sy","height","sz","depth","btBoxShape","setMargin","radius","btSphereShape","window","console","error","abrupt","Ammo","sent","btDefaultCollisionConfiguration","btCollisionDispatcher","btDbvtBroadphase","btSequentialImpulseConstraintSolver","btDiscreteDynamicsWorld","setGravity","WeakMap","setInterval","stop","x2","y2","z2","xx","xy","xz","yy","yz","zz","wx","wy","wz"],"sources":["C:\\Users\\Nayyu\\Desktop\\skibidai-public-build\\node_modules\\src\\physics\\AmmoPhysics.js"],"sourcesContent":["async function AmmoPhysics() {\n  if ('Ammo' in window === false) {\n    console.error(\"AmmoPhysics: Couldn't find Ammo.js\")\n    return\n  }\n\n  const AmmoLib = await Ammo()\n\n  const frameRate = 60\n\n  const collisionConfiguration = new AmmoLib.btDefaultCollisionConfiguration()\n  const dispatcher = new AmmoLib.btCollisionDispatcher(collisionConfiguration)\n  const broadphase = new AmmoLib.btDbvtBroadphase()\n  const solver = new AmmoLib.btSequentialImpulseConstraintSolver()\n  const world = new AmmoLib.btDiscreteDynamicsWorld(dispatcher, broadphase, solver, collisionConfiguration)\n  world.setGravity(new AmmoLib.btVector3(0, -9.8, 0))\n\n  const worldTransform = new AmmoLib.btTransform()\n\n  //\n\n  function getShape(geometry) {\n    const parameters = geometry.parameters\n\n    // TODO change type to is*\n\n    if (geometry.type === 'BoxGeometry') {\n      const sx = parameters.width !== undefined ? parameters.width / 2 : 0.5\n      const sy = parameters.height !== undefined ? parameters.height / 2 : 0.5\n      const sz = parameters.depth !== undefined ? parameters.depth / 2 : 0.5\n\n      const shape = new AmmoLib.btBoxShape(new AmmoLib.btVector3(sx, sy, sz))\n      shape.setMargin(0.05)\n\n      return shape\n    } else if (geometry.type === 'SphereGeometry' || geometry.type === 'IcosahedronGeometry') {\n      const radius = parameters.radius !== undefined ? parameters.radius : 1\n\n      const shape = new AmmoLib.btSphereShape(radius)\n      shape.setMargin(0.05)\n\n      return shape\n    }\n\n    return null\n  }\n\n  const meshes = []\n  const meshMap = new WeakMap()\n\n  function addMesh(mesh, mass = 0) {\n    const shape = getShape(mesh.geometry)\n\n    if (shape !== null) {\n      if (mesh.isInstancedMesh) {\n        handleInstancedMesh(mesh, mass, shape)\n      } else if (mesh.isMesh) {\n        handleMesh(mesh, mass, shape)\n      }\n    }\n  }\n\n  function handleMesh(mesh, mass, shape) {\n    const position = mesh.position\n    const quaternion = mesh.quaternion\n\n    const transform = new AmmoLib.btTransform()\n    transform.setIdentity()\n    transform.setOrigin(new AmmoLib.btVector3(position.x, position.y, position.z))\n    transform.setRotation(new AmmoLib.btQuaternion(quaternion.x, quaternion.y, quaternion.z, quaternion.w))\n\n    const motionState = new AmmoLib.btDefaultMotionState(transform)\n\n    const localInertia = new AmmoLib.btVector3(0, 0, 0)\n    shape.calculateLocalInertia(mass, localInertia)\n\n    const rbInfo = new AmmoLib.btRigidBodyConstructionInfo(mass, motionState, shape, localInertia)\n\n    const body = new AmmoLib.btRigidBody(rbInfo)\n    // body.setFriction( 4 );\n    world.addRigidBody(body)\n\n    if (mass > 0) {\n      meshes.push(mesh)\n      meshMap.set(mesh, body)\n    }\n  }\n\n  function handleInstancedMesh(mesh, mass, shape) {\n    const array = mesh.instanceMatrix.array\n\n    const bodies = []\n\n    for (let i = 0; i < mesh.count; i++) {\n      const index = i * 16\n\n      const transform = new AmmoLib.btTransform()\n      transform.setFromOpenGLMatrix(array.slice(index, index + 16))\n\n      const motionState = new AmmoLib.btDefaultMotionState(transform)\n\n      const localInertia = new AmmoLib.btVector3(0, 0, 0)\n      shape.calculateLocalInertia(mass, localInertia)\n\n      const rbInfo = new AmmoLib.btRigidBodyConstructionInfo(mass, motionState, shape, localInertia)\n\n      const body = new AmmoLib.btRigidBody(rbInfo)\n      world.addRigidBody(body)\n\n      bodies.push(body)\n    }\n\n    if (mass > 0) {\n      mesh.instanceMatrix.setUsage(35048) // THREE.DynamicDrawUsage = 35048\n      meshes.push(mesh)\n\n      meshMap.set(mesh, bodies)\n    }\n  }\n\n  //\n\n  function setMeshPosition(mesh, position, index = 0) {\n    if (mesh.isInstancedMesh) {\n      const bodies = meshMap.get(mesh)\n      const body = bodies[index]\n\n      body.setAngularVelocity(new AmmoLib.btVector3(0, 0, 0))\n      body.setLinearVelocity(new AmmoLib.btVector3(0, 0, 0))\n\n      worldTransform.setIdentity()\n      worldTransform.setOrigin(new AmmoLib.btVector3(position.x, position.y, position.z))\n      body.setWorldTransform(worldTransform)\n    } else if (mesh.isMesh) {\n      const body = meshMap.get(mesh)\n\n      body.setAngularVelocity(new AmmoLib.btVector3(0, 0, 0))\n      body.setLinearVelocity(new AmmoLib.btVector3(0, 0, 0))\n\n      worldTransform.setIdentity()\n      worldTransform.setOrigin(new AmmoLib.btVector3(position.x, position.y, position.z))\n      body.setWorldTransform(worldTransform)\n    }\n  }\n\n  //\n\n  let lastTime = 0\n\n  function step() {\n    const time = performance.now()\n\n    if (lastTime > 0) {\n      const delta = (time - lastTime) / 1000\n\n      // console.time( 'world.step' );\n      world.stepSimulation(delta, 10)\n      // console.timeEnd( 'world.step' );\n    }\n\n    lastTime = time\n\n    //\n\n    for (let i = 0, l = meshes.length; i < l; i++) {\n      const mesh = meshes[i]\n\n      if (mesh.isInstancedMesh) {\n        const array = mesh.instanceMatrix.array\n        const bodies = meshMap.get(mesh)\n\n        for (let j = 0; j < bodies.length; j++) {\n          const body = bodies[j]\n\n          const motionState = body.getMotionState()\n          motionState.getWorldTransform(worldTransform)\n\n          const position = worldTransform.getOrigin()\n          const quaternion = worldTransform.getRotation()\n\n          compose(position, quaternion, array, j * 16)\n        }\n\n        mesh.instanceMatrix.needsUpdate = true\n      } else if (mesh.isMesh) {\n        const body = meshMap.get(mesh)\n\n        const motionState = body.getMotionState()\n        motionState.getWorldTransform(worldTransform)\n\n        const position = worldTransform.getOrigin()\n        const quaternion = worldTransform.getRotation()\n        mesh.position.set(position.x(), position.y(), position.z())\n        mesh.quaternion.set(quaternion.x(), quaternion.y(), quaternion.z(), quaternion.w())\n      }\n    }\n  }\n\n  // animate\n\n  setInterval(step, 1000 / frameRate)\n\n  return {\n    addMesh: addMesh,\n    setMeshPosition: setMeshPosition,\n    // addCompoundMesh\n  }\n}\n\nfunction compose(position, quaternion, array, index) {\n  const x = quaternion.x(),\n    y = quaternion.y(),\n    z = quaternion.z(),\n    w = quaternion.w()\n  const x2 = x + x,\n    y2 = y + y,\n    z2 = z + z\n  const xx = x * x2,\n    xy = x * y2,\n    xz = x * z2\n  const yy = y * y2,\n    yz = y * z2,\n    zz = z * z2\n  const wx = w * x2,\n    wy = w * y2,\n    wz = w * z2\n\n  array[index + 0] = 1 - (yy + zz)\n  array[index + 1] = xy + wz\n  array[index + 2] = xz - wy\n  array[index + 3] = 0\n\n  array[index + 4] = xy - wz\n  array[index + 5] = 1 - (xx + zz)\n  array[index + 6] = yz + wx\n  array[index + 7] = 0\n\n  array[index + 8] = xz + wy\n  array[index + 9] = yz - wx\n  array[index + 10] = 1 - (xx + yy)\n  array[index + 11] = 0\n\n  array[index + 12] = position.x()\n  array[index + 13] = position.y()\n  array[index + 14] = position.z()\n  array[index + 15] = 1\n}\n\nexport { AmmoPhysics }\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}