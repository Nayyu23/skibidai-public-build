{"ast":null,"code":"import _regeneratorRuntime from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _createClass from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _classCallCheck from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _assertThisInitialized from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js\";\nimport _inherits from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport { Vector3, Ray, Loader, FileLoader, MeshStandardMaterial, LineBasicMaterial, ShaderMaterial, UniformsUtils, UniformsLib, Color, REVISION, BufferGeometry, BufferAttribute, LineSegments, Mesh, Matrix4, Group } from \"three\";\nvar FINISH_TYPE_DEFAULT = 0;\nvar FINISH_TYPE_CHROME = 1;\nvar FINISH_TYPE_PEARLESCENT = 2;\nvar FINISH_TYPE_RUBBER = 3;\nvar FINISH_TYPE_MATTE_METALLIC = 4;\nvar FINISH_TYPE_METAL = 5;\nvar FILE_LOCATION_AS_IS = 0;\nvar FILE_LOCATION_TRY_PARTS = 1;\nvar FILE_LOCATION_TRY_P = 2;\nvar FILE_LOCATION_TRY_MODELS = 3;\nvar FILE_LOCATION_TRY_RELATIVE = 4;\nvar FILE_LOCATION_TRY_ABSOLUTE = 5;\nvar FILE_LOCATION_NOT_FOUND = 6;\nvar MAIN_COLOUR_CODE = \"16\";\nvar MAIN_EDGE_COLOUR_CODE = \"24\";\nvar _tempVec0 = new Vector3();\nvar _tempVec1 = new Vector3();\nvar LDrawConditionalLineMaterial = /*#__PURE__*/function (_ShaderMaterial) {\n  _inherits(LDrawConditionalLineMaterial, _ShaderMaterial);\n  var _super = _createSuper(LDrawConditionalLineMaterial);\n  function LDrawConditionalLineMaterial(parameters) {\n    var _this;\n    _classCallCheck(this, LDrawConditionalLineMaterial);\n    _this = _super.call(this, {\n      uniforms: UniformsUtils.merge([UniformsLib.fog, {\n        diffuse: {\n          value: new Color()\n        },\n        opacity: {\n          value: 1\n        }\n      }]),\n      vertexShader: /* glsl */\"\\n        attribute vec3 control0;\\n        attribute vec3 control1;\\n        attribute vec3 direction;\\n        varying float discardFlag;\\n\\n        #include <common>\\n        #include <color_pars_vertex>\\n        #include <fog_pars_vertex>\\n        #include <logdepthbuf_pars_vertex>\\n        #include <clipping_planes_pars_vertex>\\n\\n        void main() {\\n          #include <color_vertex>\\n\\n          vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\\n          gl_Position = projectionMatrix * mvPosition;\\n\\n          // Transform the line segment ends and control points into camera clip space\\n          vec4 c0 = projectionMatrix * modelViewMatrix * vec4(control0, 1.0);\\n          vec4 c1 = projectionMatrix * modelViewMatrix * vec4(control1, 1.0);\\n          vec4 p0 = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\\n          vec4 p1 = projectionMatrix * modelViewMatrix * vec4(position + direction, 1.0);\\n\\n          c0.xy /= c0.w;\\n          c1.xy /= c1.w;\\n          p0.xy /= p0.w;\\n          p1.xy /= p1.w;\\n\\n          // Get the direction of the segment and an orthogonal vector\\n          vec2 dir = p1.xy - p0.xy;\\n          vec2 norm = vec2(-dir.y, dir.x);\\n\\n          // Get control point directions from the line\\n          vec2 c0dir = c0.xy - p1.xy;\\n          vec2 c1dir = c1.xy - p1.xy;\\n\\n          // If the vectors to the controls points are pointed in different directions away\\n          // from the line segment then the line should not be drawn.\\n          float d0 = dot(normalize(norm), normalize(c0dir));\\n          float d1 = dot(normalize(norm), normalize(c1dir));\\n          discardFlag = float(sign(d0) != sign(d1));\\n\\n          #include <logdepthbuf_vertex>\\n          #include <clipping_planes_vertex>\\n          #include <fog_vertex>\\n        }\\n      \",\n      fragmentShader: /* glsl */\"\\n        uniform vec3 diffuse;\\n        uniform float opacity;\\n        varying float discardFlag;\\n\\n        #include <common>\\n        #include <color_pars_fragment>\\n        #include <fog_pars_fragment>\\n        #include <logdepthbuf_pars_fragment>\\n        #include <clipping_planes_pars_fragment>\\n\\n        void main() {\\n          if (discardFlag > 0.5) discard;\\n\\n          #include <clipping_planes_fragment>\\n          vec3 outgoingLight = vec3(0.0);\\n          vec4 diffuseColor = vec4(diffuse, opacity);\\n          #include <logdepthbuf_fragment>\\n          #include <color_fragment>\\n          outgoingLight = diffuseColor.rgb; // simple shader\\n          gl_FragColor = vec4(outgoingLight, diffuseColor.a);\\n          #include <tonemapping_fragment>\\n          #include <\".concat(parseInt(REVISION.replace(/\\D+/g, \"\")) >= 154 ? \"colorspace_fragment\" : \"encodings_fragment\", \">\\n          #include <fog_fragment>\\n          #include <premultiplied_alpha_fragment>\\n        }\\n      \")\n    });\n    Object.defineProperties(_assertThisInitialized(_this), {\n      opacity: {\n        get: function get() {\n          return this.uniforms.opacity.value;\n        },\n        set: function set(value) {\n          this.uniforms.opacity.value = value;\n        }\n      },\n      color: {\n        get: function get() {\n          return this.uniforms.diffuse.value;\n        }\n      }\n    });\n    _this.setValues(parameters);\n    _this.isLDrawConditionalLineMaterial = true;\n    return _this;\n  }\n  return _createClass(LDrawConditionalLineMaterial);\n}(ShaderMaterial);\nvar ConditionalLineSegments = /*#__PURE__*/function (_LineSegments) {\n  _inherits(ConditionalLineSegments, _LineSegments);\n  var _super2 = _createSuper(ConditionalLineSegments);\n  function ConditionalLineSegments(geometry, material) {\n    var _this2;\n    _classCallCheck(this, ConditionalLineSegments);\n    _this2 = _super2.call(this, geometry, material);\n    _this2.isConditionalLine = true;\n    return _this2;\n  }\n  return _createClass(ConditionalLineSegments);\n}(LineSegments);\nfunction generateFaceNormals(faces) {\n  for (var i = 0, l = faces.length; i < l; i++) {\n    var face = faces[i];\n    var vertices = face.vertices;\n    var v0 = vertices[0];\n    var v1 = vertices[1];\n    var v2 = vertices[2];\n    _tempVec0.subVectors(v1, v0);\n    _tempVec1.subVectors(v2, v1);\n    face.faceNormal = new Vector3().crossVectors(_tempVec0, _tempVec1).normalize();\n  }\n}\nvar _ray = new Ray();\nfunction smoothNormals(faces, lineSegments) {\n  var checkSubSegments = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  var hashMultiplier = (1 + 1e-10) * 100;\n  function hashVertex(v) {\n    var x = ~~(v.x * hashMultiplier);\n    var y = ~~(v.y * hashMultiplier);\n    var z = ~~(v.z * hashMultiplier);\n    return \"\".concat(x, \",\").concat(y, \",\").concat(z);\n  }\n  function hashEdge(v0, v1) {\n    return \"\".concat(hashVertex(v0), \"_\").concat(hashVertex(v1));\n  }\n  function toNormalizedRay(v0, v1, targetRay) {\n    targetRay.direction.subVectors(v1, v0).normalize();\n    var scalar = v0.dot(targetRay.direction);\n    targetRay.origin.copy(v0).addScaledVector(targetRay.direction, -scalar);\n    return targetRay;\n  }\n  function hashRay(ray) {\n    return hashEdge(ray.origin, ray.direction);\n  }\n  var hardEdges = /* @__PURE__ */new Set();\n  var hardEdgeRays = /* @__PURE__ */new Map();\n  var halfEdgeList = {};\n  var normals = [];\n  for (var i = 0, l = lineSegments.length; i < l; i++) {\n    var ls = lineSegments[i];\n    var vertices = ls.vertices;\n    var v0 = vertices[0];\n    var v1 = vertices[1];\n    hardEdges.add(hashEdge(v0, v1));\n    hardEdges.add(hashEdge(v1, v0));\n    if (checkSubSegments) {\n      var ray = toNormalizedRay(v0, v1, new Ray());\n      var rh1 = hashRay(ray);\n      if (!hardEdgeRays.has(rh1)) {\n        toNormalizedRay(v1, v0, ray);\n        var rh2 = hashRay(ray);\n        var info2 = {\n          ray: ray,\n          distances: []\n        };\n        hardEdgeRays.set(rh1, info2);\n        hardEdgeRays.set(rh2, info2);\n      }\n      var info = hardEdgeRays.get(rh1);\n      var d0 = info.ray.direction.dot(v0);\n      var d1 = info.ray.direction.dot(v1);\n      if (d0 > d1) {\n        var _ref = [d1, d0];\n        d0 = _ref[0];\n        d1 = _ref[1];\n      }\n      info.distances.push(d0, d1);\n    }\n  }\n  for (var _i = 0, _l = faces.length; _i < _l; _i++) {\n    var tri = faces[_i];\n    var _vertices = tri.vertices;\n    var vertCount = _vertices.length;\n    for (var i2 = 0; i2 < vertCount; i2++) {\n      var index = i2;\n      var next = (i2 + 1) % vertCount;\n      var _v = _vertices[index];\n      var _v2 = _vertices[next];\n      var hash = hashEdge(_v, _v2);\n      if (hardEdges.has(hash)) {\n        continue;\n      }\n      if (checkSubSegments) {\n        toNormalizedRay(_v, _v2, _ray);\n        var rayHash = hashRay(_ray);\n        if (hardEdgeRays.has(rayHash)) {\n          var _info = hardEdgeRays.get(rayHash);\n          var _ray2 = _info.ray,\n            distances = _info.distances;\n          var _d = _ray2.direction.dot(_v);\n          var _d2 = _ray2.direction.dot(_v2);\n          if (_d > _d2) {\n            var _ref2 = [_d2, _d];\n            _d = _ref2[0];\n            _d2 = _ref2[1];\n          }\n          var found = false;\n          for (var i3 = 0, l2 = distances.length; i3 < l2; i3 += 2) {\n            if (_d >= distances[i3] && _d2 <= distances[i3 + 1]) {\n              found = true;\n              break;\n            }\n          }\n          if (found) {\n            continue;\n          }\n        }\n      }\n      var _info2 = {\n        index: index,\n        tri: tri\n      };\n      halfEdgeList[hash] = _info2;\n    }\n  }\n  while (true) {\n    var halfEdge = null;\n    for (var key in halfEdgeList) {\n      halfEdge = halfEdgeList[key];\n      break;\n    }\n    if (halfEdge === null) {\n      break;\n    }\n    var queue = [halfEdge];\n    while (queue.length > 0) {\n      var _tri = queue.pop().tri;\n      var _vertices2 = _tri.vertices;\n      var vertNormals = _tri.normals;\n      var faceNormal = _tri.faceNormal;\n      var _vertCount = _vertices2.length;\n      for (var _i2 = 0; _i2 < _vertCount; _i2++) {\n        var _index = _i2;\n        var _next = (_i2 + 1) % _vertCount;\n        var _v3 = _vertices2[_index];\n        var _v4 = _vertices2[_next];\n        var _hash = hashEdge(_v3, _v4);\n        delete halfEdgeList[_hash];\n        var reverseHash = hashEdge(_v4, _v3);\n        var otherInfo = halfEdgeList[reverseHash];\n        if (otherInfo) {\n          var otherTri = otherInfo.tri;\n          var otherIndex = otherInfo.index;\n          var otherNormals = otherTri.normals;\n          var otherVertCount = otherNormals.length;\n          var otherFaceNormal = otherTri.faceNormal;\n          if (Math.abs(otherTri.faceNormal.dot(_tri.faceNormal)) < 0.25) {\n            continue;\n          }\n          if (reverseHash in halfEdgeList) {\n            queue.push(otherInfo);\n            delete halfEdgeList[reverseHash];\n          }\n          var otherNext = (otherIndex + 1) % otherVertCount;\n          if (vertNormals[_index] && otherNormals[otherNext] && vertNormals[_index] !== otherNormals[otherNext]) {\n            otherNormals[otherNext].norm.add(vertNormals[_index].norm);\n            vertNormals[_index].norm = otherNormals[otherNext].norm;\n          }\n          var sharedNormal1 = vertNormals[_index] || otherNormals[otherNext];\n          if (sharedNormal1 === null) {\n            sharedNormal1 = {\n              norm: new Vector3()\n            };\n            normals.push(sharedNormal1.norm);\n          }\n          if (vertNormals[_index] === null) {\n            vertNormals[_index] = sharedNormal1;\n            sharedNormal1.norm.add(faceNormal);\n          }\n          if (otherNormals[otherNext] === null) {\n            otherNormals[otherNext] = sharedNormal1;\n            sharedNormal1.norm.add(otherFaceNormal);\n          }\n          if (vertNormals[_next] && otherNormals[otherIndex] && vertNormals[_next] !== otherNormals[otherIndex]) {\n            otherNormals[otherIndex].norm.add(vertNormals[_next].norm);\n            vertNormals[_next].norm = otherNormals[otherIndex].norm;\n          }\n          var sharedNormal2 = vertNormals[_next] || otherNormals[otherIndex];\n          if (sharedNormal2 === null) {\n            sharedNormal2 = {\n              norm: new Vector3()\n            };\n            normals.push(sharedNormal2.norm);\n          }\n          if (vertNormals[_next] === null) {\n            vertNormals[_next] = sharedNormal2;\n            sharedNormal2.norm.add(faceNormal);\n          }\n          if (otherNormals[otherIndex] === null) {\n            otherNormals[otherIndex] = sharedNormal2;\n            sharedNormal2.norm.add(otherFaceNormal);\n          }\n        }\n      }\n    }\n  }\n  for (var _i3 = 0, _l2 = normals.length; _i3 < _l2; _i3++) {\n    normals[_i3].normalize();\n  }\n}\nfunction isPartType(type) {\n  return type === \"Part\" || type === \"Unofficial_Part\";\n}\nfunction isPrimitiveType(type) {\n  return /primitive/i.test(type) || type === \"Subpart\";\n}\nvar LineParser = /*#__PURE__*/function () {\n  function LineParser(line, lineNumber) {\n    _classCallCheck(this, LineParser);\n    this.line = line;\n    this.lineLength = line.length;\n    this.currentCharIndex = 0;\n    this.currentChar = \" \";\n    this.lineNumber = lineNumber;\n  }\n  _createClass(LineParser, [{\n    key: \"seekNonSpace\",\n    value: function seekNonSpace() {\n      while (this.currentCharIndex < this.lineLength) {\n        this.currentChar = this.line.charAt(this.currentCharIndex);\n        if (this.currentChar !== \" \" && this.currentChar !== \"\t\") {\n          return;\n        }\n        this.currentCharIndex++;\n      }\n    }\n  }, {\n    key: \"getToken\",\n    value: function getToken() {\n      var pos0 = this.currentCharIndex++;\n      while (this.currentCharIndex < this.lineLength) {\n        this.currentChar = this.line.charAt(this.currentCharIndex);\n        if (this.currentChar === \" \" || this.currentChar === \"\t\") {\n          break;\n        }\n        this.currentCharIndex++;\n      }\n      var pos1 = this.currentCharIndex;\n      this.seekNonSpace();\n      return this.line.substring(pos0, pos1);\n    }\n  }, {\n    key: \"getVector\",\n    value: function getVector() {\n      return new Vector3(parseFloat(this.getToken()), parseFloat(this.getToken()), parseFloat(this.getToken()));\n    }\n  }, {\n    key: \"getRemainingString\",\n    value: function getRemainingString() {\n      return this.line.substring(this.currentCharIndex, this.lineLength);\n    }\n  }, {\n    key: \"isAtTheEnd\",\n    value: function isAtTheEnd() {\n      return this.currentCharIndex >= this.lineLength;\n    }\n  }, {\n    key: \"setToEnd\",\n    value: function setToEnd() {\n      this.currentCharIndex = this.lineLength;\n    }\n  }, {\n    key: \"getLineNumberString\",\n    value: function getLineNumberString() {\n      return this.lineNumber >= 0 ? \" at line \" + this.lineNumber : \"\";\n    }\n  }]);\n  return LineParser;\n}();\nvar LDrawParsedCache = /*#__PURE__*/function () {\n  function LDrawParsedCache(loader) {\n    _classCallCheck(this, LDrawParsedCache);\n    this.loader = loader;\n    this._cache = {};\n  }\n  _createClass(LDrawParsedCache, [{\n    key: \"cloneResult\",\n    value: function cloneResult(original) {\n      var result = {};\n      result.faces = original.faces.map(function (face) {\n        return {\n          colorCode: face.colorCode,\n          material: face.material,\n          vertices: face.vertices.map(function (v) {\n            return v.clone();\n          }),\n          normals: face.normals.map(function () {\n            return null;\n          }),\n          faceNormal: null\n        };\n      });\n      result.conditionalSegments = original.conditionalSegments.map(function (face) {\n        return {\n          colorCode: face.colorCode,\n          material: face.material,\n          vertices: face.vertices.map(function (v) {\n            return v.clone();\n          }),\n          controlPoints: face.controlPoints.map(function (v) {\n            return v.clone();\n          })\n        };\n      });\n      result.lineSegments = original.lineSegments.map(function (face) {\n        return {\n          colorCode: face.colorCode,\n          material: face.material,\n          vertices: face.vertices.map(function (v) {\n            return v.clone();\n          })\n        };\n      });\n      result.type = original.type;\n      result.category = original.category;\n      result.keywords = original.keywords;\n      result.subobjects = original.subobjects;\n      result.totalFaces = original.totalFaces;\n      result.startingConstructionStep = original.startingConstructionStep;\n      result.materials = original.materials;\n      result.group = null;\n      return result;\n    }\n  }, {\n    key: \"fetchData\",\n    value: function () {\n      var _fetchData = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(fileName) {\n        var triedLowerCase, locationState, subobjectURL, loader, fileLoader, text;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              triedLowerCase = false;\n              locationState = FILE_LOCATION_AS_IS;\n            case 2:\n              if (!(locationState !== FILE_LOCATION_NOT_FOUND)) {\n                _context.next = 40;\n                break;\n              }\n              subobjectURL = fileName;\n              _context.t0 = locationState;\n              _context.next = _context.t0 === FILE_LOCATION_AS_IS ? 7 : _context.t0 === FILE_LOCATION_TRY_PARTS ? 9 : _context.t0 === FILE_LOCATION_TRY_P ? 12 : _context.t0 === FILE_LOCATION_TRY_MODELS ? 15 : _context.t0 === FILE_LOCATION_TRY_RELATIVE ? 18 : _context.t0 === FILE_LOCATION_TRY_ABSOLUTE ? 21 : 23;\n              break;\n            case 7:\n              locationState = locationState + 1;\n              return _context.abrupt(\"break\", 23);\n            case 9:\n              subobjectURL = \"parts/\" + subobjectURL;\n              locationState = locationState + 1;\n              return _context.abrupt(\"break\", 23);\n            case 12:\n              subobjectURL = \"p/\" + subobjectURL;\n              locationState = locationState + 1;\n              return _context.abrupt(\"break\", 23);\n            case 15:\n              subobjectURL = \"models/\" + subobjectURL;\n              locationState = locationState + 1;\n              return _context.abrupt(\"break\", 23);\n            case 18:\n              subobjectURL = fileName.substring(0, fileName.lastIndexOf(\"/\") + 1) + subobjectURL;\n              locationState = locationState + 1;\n              return _context.abrupt(\"break\", 23);\n            case 21:\n              if (triedLowerCase) {\n                locationState = FILE_LOCATION_NOT_FOUND;\n              } else {\n                fileName = fileName.toLowerCase();\n                subobjectURL = fileName;\n                triedLowerCase = true;\n                locationState = FILE_LOCATION_AS_IS;\n              }\n              return _context.abrupt(\"break\", 23);\n            case 23:\n              loader = this.loader;\n              fileLoader = new FileLoader(loader.manager);\n              fileLoader.setPath(loader.partsLibraryPath);\n              fileLoader.setRequestHeader(loader.requestHeader);\n              fileLoader.setWithCredentials(loader.withCredentials);\n              _context.prev = 28;\n              _context.next = 31;\n              return fileLoader.loadAsync(subobjectURL);\n            case 31:\n              text = _context.sent;\n              return _context.abrupt(\"return\", text);\n            case 35:\n              _context.prev = 35;\n              _context.t1 = _context[\"catch\"](28);\n              return _context.abrupt(\"continue\", 2);\n            case 38:\n              _context.next = 2;\n              break;\n            case 40:\n              throw new Error('LDrawLoader: Subobject \"' + fileName + '\" could not be loaded.');\n            case 41:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee, this, [[28, 35]]);\n      }));\n      function fetchData(_x) {\n        return _fetchData.apply(this, arguments);\n      }\n      return fetchData;\n    }()\n  }, {\n    key: \"parse\",\n    value: function parse(text) {\n      var fileName = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      var loader = this.loader;\n      var faces = [];\n      var lineSegments = [];\n      var conditionalSegments = [];\n      var subobjects = [];\n      var materials = {};\n      var getLocalMaterial = function getLocalMaterial(colorCode) {\n        return materials[colorCode] || null;\n      };\n      var type = \"Model\";\n      var category = null;\n      var keywords = null;\n      var totalFaces = 0;\n      if (text.indexOf(\"\\r\\n\") !== -1) {\n        text = text.replace(/\\r\\n/g, \"\\n\");\n      }\n      var lines = text.split(\"\\n\");\n      var numLines = lines.length;\n      var parsingEmbeddedFiles = false;\n      var currentEmbeddedFileName = null;\n      var currentEmbeddedText = null;\n      var bfcCertified = false;\n      var bfcCCW = true;\n      var bfcInverted = false;\n      var bfcCull = true;\n      var startingConstructionStep = false;\n      for (var lineIndex = 0; lineIndex < numLines; lineIndex++) {\n        var line = lines[lineIndex];\n        if (line.length === 0) continue;\n        if (parsingEmbeddedFiles) {\n          if (line.startsWith(\"0 FILE \")) {\n            this.setData(currentEmbeddedFileName, currentEmbeddedText);\n            currentEmbeddedFileName = line.substring(7);\n            currentEmbeddedText = \"\";\n          } else {\n            currentEmbeddedText += line + \"\\n\";\n          }\n          continue;\n        }\n        var lp = new LineParser(line, lineIndex + 1);\n        lp.seekNonSpace();\n        if (lp.isAtTheEnd()) {\n          continue;\n        }\n        var lineType = lp.getToken();\n        var material = void 0;\n        var colorCode = void 0;\n        var segment = void 0;\n        var ccw = void 0;\n        var doubleSided = void 0;\n        var v0 = void 0,\n          v1 = void 0,\n          v2 = void 0,\n          v3 = void 0,\n          c0 = void 0,\n          c1 = void 0;\n        switch (lineType) {\n          case \"0\":\n            var meta = lp.getToken();\n            if (meta) {\n              switch (meta) {\n                case \"!LDRAW_ORG\":\n                  type = lp.getToken();\n                  break;\n                case \"!COLOUR\":\n                  material = loader.parseColorMetaDirective(lp);\n                  if (material) {\n                    materials[material.userData.code] = material;\n                  } else {\n                    console.warn(\"LDrawLoader: Error parsing material\" + lp.getLineNumberString());\n                  }\n                  break;\n                case \"!CATEGORY\":\n                  category = lp.getToken();\n                  break;\n                case \"!KEYWORDS\":\n                  var newKeywords = lp.getRemainingString().split(\",\");\n                  if (newKeywords.length > 0) {\n                    if (!keywords) {\n                      keywords = [];\n                    }\n                    newKeywords.forEach(function (keyword) {\n                      keywords.push(keyword.trim());\n                    });\n                  }\n                  break;\n                case \"FILE\":\n                  if (lineIndex > 0) {\n                    parsingEmbeddedFiles = true;\n                    currentEmbeddedFileName = lp.getRemainingString();\n                    currentEmbeddedText = \"\";\n                    bfcCertified = false;\n                    bfcCCW = true;\n                  }\n                  break;\n                case \"BFC\":\n                  while (!lp.isAtTheEnd()) {\n                    var token = lp.getToken();\n                    switch (token) {\n                      case \"CERTIFY\":\n                      case \"NOCERTIFY\":\n                        bfcCertified = token === \"CERTIFY\";\n                        bfcCCW = true;\n                        break;\n                      case \"CW\":\n                      case \"CCW\":\n                        bfcCCW = token === \"CCW\";\n                        break;\n                      case \"INVERTNEXT\":\n                        bfcInverted = true;\n                        break;\n                      case \"CLIP\":\n                      case \"NOCLIP\":\n                        bfcCull = token === \"CLIP\";\n                        break;\n                      default:\n                        console.warn('THREE.LDrawLoader: BFC directive \"' + token + '\" is unknown.');\n                        break;\n                    }\n                  }\n                  break;\n                case \"STEP\":\n                  startingConstructionStep = true;\n                  break;\n              }\n            }\n            break;\n          case \"1\":\n            colorCode = lp.getToken();\n            material = getLocalMaterial(colorCode);\n            var posX = parseFloat(lp.getToken());\n            var posY = parseFloat(lp.getToken());\n            var posZ = parseFloat(lp.getToken());\n            var m0 = parseFloat(lp.getToken());\n            var m1 = parseFloat(lp.getToken());\n            var m2 = parseFloat(lp.getToken());\n            var m3 = parseFloat(lp.getToken());\n            var m4 = parseFloat(lp.getToken());\n            var m5 = parseFloat(lp.getToken());\n            var m6 = parseFloat(lp.getToken());\n            var m7 = parseFloat(lp.getToken());\n            var m8 = parseFloat(lp.getToken());\n            var matrix = new Matrix4().set(m0, m1, m2, posX, m3, m4, m5, posY, m6, m7, m8, posZ, 0, 0, 0, 1);\n            var fileName2 = lp.getRemainingString().trim().replace(/\\\\/g, \"/\");\n            if (loader.fileMap[fileName2]) {\n              fileName2 = loader.fileMap[fileName2];\n            } else {\n              if (fileName2.startsWith(\"s/\")) {\n                fileName2 = \"parts/\" + fileName2;\n              } else if (fileName2.startsWith(\"48/\")) {\n                fileName2 = \"p/\" + fileName2;\n              }\n            }\n            subobjects.push({\n              material: material,\n              colorCode: colorCode,\n              matrix: matrix,\n              fileName: fileName2,\n              inverted: bfcInverted,\n              startingConstructionStep: startingConstructionStep\n            });\n            bfcInverted = false;\n            break;\n          case \"2\":\n            colorCode = lp.getToken();\n            material = getLocalMaterial(colorCode);\n            v0 = lp.getVector();\n            v1 = lp.getVector();\n            segment = {\n              material: material,\n              colorCode: colorCode,\n              vertices: [v0, v1]\n            };\n            lineSegments.push(segment);\n            break;\n          case \"5\":\n            colorCode = lp.getToken();\n            material = getLocalMaterial(colorCode);\n            v0 = lp.getVector();\n            v1 = lp.getVector();\n            c0 = lp.getVector();\n            c1 = lp.getVector();\n            segment = {\n              material: material,\n              colorCode: colorCode,\n              vertices: [v0, v1],\n              controlPoints: [c0, c1]\n            };\n            conditionalSegments.push(segment);\n            break;\n          case \"3\":\n            colorCode = lp.getToken();\n            material = getLocalMaterial(colorCode);\n            ccw = bfcCCW;\n            doubleSided = !bfcCertified || !bfcCull;\n            if (ccw === true) {\n              v0 = lp.getVector();\n              v1 = lp.getVector();\n              v2 = lp.getVector();\n            } else {\n              v2 = lp.getVector();\n              v1 = lp.getVector();\n              v0 = lp.getVector();\n            }\n            faces.push({\n              material: material,\n              colorCode: colorCode,\n              faceNormal: null,\n              vertices: [v0, v1, v2],\n              normals: [null, null, null]\n            });\n            totalFaces++;\n            if (doubleSided === true) {\n              faces.push({\n                material: material,\n                colorCode: colorCode,\n                faceNormal: null,\n                vertices: [v2, v1, v0],\n                normals: [null, null, null]\n              });\n              totalFaces++;\n            }\n            break;\n          case \"4\":\n            colorCode = lp.getToken();\n            material = getLocalMaterial(colorCode);\n            ccw = bfcCCW;\n            doubleSided = !bfcCertified || !bfcCull;\n            if (ccw === true) {\n              v0 = lp.getVector();\n              v1 = lp.getVector();\n              v2 = lp.getVector();\n              v3 = lp.getVector();\n            } else {\n              v3 = lp.getVector();\n              v2 = lp.getVector();\n              v1 = lp.getVector();\n              v0 = lp.getVector();\n            }\n            faces.push({\n              material: material,\n              colorCode: colorCode,\n              faceNormal: null,\n              vertices: [v0, v1, v2, v3],\n              normals: [null, null, null, null]\n            });\n            totalFaces += 2;\n            if (doubleSided === true) {\n              faces.push({\n                material: material,\n                colorCode: colorCode,\n                faceNormal: null,\n                vertices: [v3, v2, v1, v0],\n                normals: [null, null, null, null]\n              });\n              totalFaces += 2;\n            }\n            break;\n          default:\n            throw new Error('LDrawLoader: Unknown line type \"' + lineType + '\"' + lp.getLineNumberString() + \".\");\n        }\n      }\n      if (parsingEmbeddedFiles) {\n        this.setData(currentEmbeddedFileName, currentEmbeddedText);\n      }\n      return {\n        faces: faces,\n        conditionalSegments: conditionalSegments,\n        lineSegments: lineSegments,\n        type: type,\n        category: category,\n        keywords: keywords,\n        subobjects: subobjects,\n        totalFaces: totalFaces,\n        startingConstructionStep: startingConstructionStep,\n        materials: materials,\n        fileName: fileName,\n        group: null\n      };\n    }\n    // returns an (optionally cloned) instance of the data\n  }, {\n    key: \"getData\",\n    value: function getData(fileName) {\n      var clone = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      var key = fileName.toLowerCase();\n      var result = this._cache[key];\n      if (result === null || result instanceof Promise) {\n        return null;\n      }\n      if (clone) {\n        return this.cloneResult(result);\n      } else {\n        return result;\n      }\n    }\n    // kicks off a fetch and parse of the requested data if it hasn't already been loaded. Returns when\n    // the data is ready to use and can be retrieved synchronously with \"getData\".\n  }, {\n    key: \"ensureDataLoaded\",\n    value: function () {\n      var _ensureDataLoaded = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(fileName) {\n        var _this3 = this;\n        var key;\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) switch (_context2.prev = _context2.next) {\n            case 0:\n              key = fileName.toLowerCase();\n              if (!(key in this._cache)) {\n                this._cache[key] = this.fetchData(fileName).then(function (text) {\n                  var info = _this3.parse(text, fileName);\n                  _this3._cache[key] = info;\n                  return info;\n                });\n              }\n              _context2.next = 4;\n              return this._cache[key];\n            case 4:\n            case \"end\":\n              return _context2.stop();\n          }\n        }, _callee2, this);\n      }));\n      function ensureDataLoaded(_x2) {\n        return _ensureDataLoaded.apply(this, arguments);\n      }\n      return ensureDataLoaded;\n    }() // sets the data in the cache from parsed data\n  }, {\n    key: \"setData\",\n    value: function setData(fileName, text) {\n      var key = fileName.toLowerCase();\n      this._cache[key] = this.parse(text, fileName);\n    }\n  }]);\n  return LDrawParsedCache;\n}();\nfunction getMaterialFromCode(colorCode, parentColorCode, materialHierarchy, forEdge) {\n  var isPassthrough = !forEdge && colorCode === MAIN_COLOUR_CODE || forEdge && colorCode === MAIN_EDGE_COLOUR_CODE;\n  if (isPassthrough) {\n    colorCode = parentColorCode;\n  }\n  return materialHierarchy[colorCode] || null;\n}\nvar LDrawPartsGeometryCache = /*#__PURE__*/function () {\n  function LDrawPartsGeometryCache(loader) {\n    _classCallCheck(this, LDrawPartsGeometryCache);\n    this.loader = loader;\n    this.parseCache = new LDrawParsedCache(loader);\n    this._cache = {};\n  }\n  // Convert the given file information into a mesh by processing subobjects.\n  _createClass(LDrawPartsGeometryCache, [{\n    key: \"processIntoMesh\",\n    value: function () {\n      var _processIntoMesh = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(info) {\n        var _this4 = this;\n        var loader, parseCache, faceMaterials, processInfoSubobjects, i, l, checkSubSegments, group;\n        return _regeneratorRuntime().wrap(function _callee4$(_context5) {\n          while (1) switch (_context5.prev = _context5.next) {\n            case 0:\n              loader = this.loader;\n              parseCache = this.parseCache;\n              faceMaterials = /* @__PURE__ */new Set();\n              processInfoSubobjects = /*#__PURE__*/function () {\n                var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(info2) {\n                  var subobject,\n                    subobjects,\n                    promises,\n                    _loop,\n                    i,\n                    l,\n                    group2,\n                    subobjectInfos,\n                    _i4,\n                    _l3,\n                    subobject2,\n                    subobjectInfo,\n                    subobjectGroup,\n                    parentLineSegments,\n                    parentConditionalSegments,\n                    parentFaces,\n                    lineSegments,\n                    conditionalSegments,\n                    faces,\n                    matrix,\n                    inverted,\n                    matrixScaleInverted,\n                    colorCode,\n                    lineColorCode,\n                    i2,\n                    l2,\n                    ls,\n                    vertices,\n                    _i5,\n                    _l4,\n                    os,\n                    _vertices3,\n                    controlPoints,\n                    _i6,\n                    _l5,\n                    tri,\n                    _vertices4,\n                    i3,\n                    l3,\n                    _args4 = arguments;\n                  return _regeneratorRuntime().wrap(function _callee3$(_context4) {\n                    while (1) switch (_context4.prev = _context4.next) {\n                      case 0:\n                        subobject = _args4.length > 1 && _args4[1] !== undefined ? _args4[1] : null;\n                        subobjects = info2.subobjects;\n                        promises = [];\n                        _loop = /*#__PURE__*/_regeneratorRuntime().mark(function _loop() {\n                          var subobject2, promise;\n                          return _regeneratorRuntime().wrap(function _loop$(_context3) {\n                            while (1) switch (_context3.prev = _context3.next) {\n                              case 0:\n                                subobject2 = subobjects[i];\n                                promise = parseCache.ensureDataLoaded(subobject2.fileName).then(function () {\n                                  var subobjectInfo = parseCache.getData(subobject2.fileName, false);\n                                  if (!isPrimitiveType(subobjectInfo.type)) {\n                                    return _this4.loadModel(subobject2.fileName).catch(function (error) {\n                                      console.warn(error);\n                                      return null;\n                                    });\n                                  }\n                                  return processInfoSubobjects(parseCache.getData(subobject2.fileName), subobject2);\n                                });\n                                promises.push(promise);\n                              case 3:\n                              case \"end\":\n                                return _context3.stop();\n                            }\n                          }, _loop);\n                        });\n                        i = 0, l = subobjects.length;\n                      case 5:\n                        if (!(i < l)) {\n                          _context4.next = 10;\n                          break;\n                        }\n                        return _context4.delegateYield(_loop(), \"t0\", 7);\n                      case 7:\n                        i++;\n                        _context4.next = 5;\n                        break;\n                      case 10:\n                        group2 = new Group();\n                        group2.userData.category = info2.category;\n                        group2.userData.keywords = info2.keywords;\n                        info2.group = group2;\n                        _context4.next = 16;\n                        return Promise.all(promises);\n                      case 16:\n                        subobjectInfos = _context4.sent;\n                        _i4 = 0, _l3 = subobjectInfos.length;\n                      case 18:\n                        if (!(_i4 < _l3)) {\n                          _context4.next = 50;\n                          break;\n                        }\n                        subobject2 = info2.subobjects[_i4];\n                        subobjectInfo = subobjectInfos[_i4];\n                        if (!(subobjectInfo === null)) {\n                          _context4.next = 23;\n                          break;\n                        }\n                        return _context4.abrupt(\"continue\", 47);\n                      case 23:\n                        if (!subobjectInfo.isGroup) {\n                          _context4.next = 31;\n                          break;\n                        }\n                        subobjectGroup = subobjectInfo;\n                        subobject2.matrix.decompose(subobjectGroup.position, subobjectGroup.quaternion, subobjectGroup.scale);\n                        subobjectGroup.userData.startingConstructionStep = subobject2.startingConstructionStep;\n                        subobjectGroup.name = subobject2.fileName;\n                        loader.applyMaterialsToMesh(subobjectGroup, subobject2.colorCode, info2.materials);\n                        group2.add(subobjectGroup);\n                        return _context4.abrupt(\"continue\", 47);\n                      case 31:\n                        if (subobjectInfo.group.children.length) {\n                          group2.add(subobjectInfo.group);\n                        }\n                        parentLineSegments = info2.lineSegments;\n                        parentConditionalSegments = info2.conditionalSegments;\n                        parentFaces = info2.faces;\n                        lineSegments = subobjectInfo.lineSegments;\n                        conditionalSegments = subobjectInfo.conditionalSegments;\n                        faces = subobjectInfo.faces;\n                        matrix = subobject2.matrix;\n                        inverted = subobject2.inverted;\n                        matrixScaleInverted = matrix.determinant() < 0;\n                        colorCode = subobject2.colorCode;\n                        lineColorCode = colorCode === MAIN_COLOUR_CODE ? MAIN_EDGE_COLOUR_CODE : colorCode;\n                        for (i2 = 0, l2 = lineSegments.length; i2 < l2; i2++) {\n                          ls = lineSegments[i2];\n                          vertices = ls.vertices;\n                          vertices[0].applyMatrix4(matrix);\n                          vertices[1].applyMatrix4(matrix);\n                          ls.colorCode = ls.colorCode === MAIN_EDGE_COLOUR_CODE ? lineColorCode : ls.colorCode;\n                          ls.material = ls.material || getMaterialFromCode(ls.colorCode, ls.colorCode, info2.materials, true);\n                          parentLineSegments.push(ls);\n                        }\n                        for (_i5 = 0, _l4 = conditionalSegments.length; _i5 < _l4; _i5++) {\n                          os = conditionalSegments[_i5];\n                          _vertices3 = os.vertices;\n                          controlPoints = os.controlPoints;\n                          _vertices3[0].applyMatrix4(matrix);\n                          _vertices3[1].applyMatrix4(matrix);\n                          controlPoints[0].applyMatrix4(matrix);\n                          controlPoints[1].applyMatrix4(matrix);\n                          os.colorCode = os.colorCode === MAIN_EDGE_COLOUR_CODE ? lineColorCode : os.colorCode;\n                          os.material = os.material || getMaterialFromCode(os.colorCode, os.colorCode, info2.materials, true);\n                          parentConditionalSegments.push(os);\n                        }\n                        for (_i6 = 0, _l5 = faces.length; _i6 < _l5; _i6++) {\n                          tri = faces[_i6];\n                          _vertices4 = tri.vertices;\n                          for (i3 = 0, l3 = _vertices4.length; i3 < l3; i3++) {\n                            _vertices4[i3].applyMatrix4(matrix);\n                          }\n                          tri.colorCode = tri.colorCode === MAIN_COLOUR_CODE ? colorCode : tri.colorCode;\n                          tri.material = tri.material || getMaterialFromCode(tri.colorCode, colorCode, info2.materials, false);\n                          faceMaterials.add(tri.colorCode);\n                          if (matrixScaleInverted !== inverted) {\n                            _vertices4.reverse();\n                          }\n                          parentFaces.push(tri);\n                        }\n                        info2.totalFaces += subobjectInfo.totalFaces;\n                      case 47:\n                        _i4++;\n                        _context4.next = 18;\n                        break;\n                      case 50:\n                        if (subobject) {\n                          loader.applyMaterialsToMesh(group2, subobject.colorCode, info2.materials);\n                        }\n                        return _context4.abrupt(\"return\", info2);\n                      case 52:\n                      case \"end\":\n                        return _context4.stop();\n                    }\n                  }, _callee3);\n                }));\n                return function processInfoSubobjects(_x4) {\n                  return _ref3.apply(this, arguments);\n                };\n              }();\n              for (i = 0, l = info.faces; i < l; i++) {\n                faceMaterials.add(info.faces[i].colorCode);\n              }\n              _context5.next = 7;\n              return processInfoSubobjects(info);\n            case 7:\n              if (loader.smoothNormals) {\n                checkSubSegments = faceMaterials.size > 1;\n                generateFaceNormals(info.faces);\n                smoothNormals(info.faces, info.lineSegments, checkSubSegments);\n              }\n              group = info.group;\n              if (info.faces.length > 0) {\n                group.add(createObject(info.faces, 3, false, info.totalFaces));\n              }\n              if (info.lineSegments.length > 0) {\n                group.add(createObject(info.lineSegments, 2));\n              }\n              if (info.conditionalSegments.length > 0) {\n                group.add(createObject(info.conditionalSegments, 2, true));\n              }\n              return _context5.abrupt(\"return\", group);\n            case 13:\n            case \"end\":\n              return _context5.stop();\n          }\n        }, _callee4, this);\n      }));\n      function processIntoMesh(_x3) {\n        return _processIntoMesh.apply(this, arguments);\n      }\n      return processIntoMesh;\n    }()\n  }, {\n    key: \"hasCachedModel\",\n    value: function hasCachedModel(fileName) {\n      return fileName !== null && fileName.toLowerCase() in this._cache;\n    }\n  }, {\n    key: \"getCachedModel\",\n    value: function () {\n      var _getCachedModel = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(fileName) {\n        var key, group;\n        return _regeneratorRuntime().wrap(function _callee5$(_context6) {\n          while (1) switch (_context6.prev = _context6.next) {\n            case 0:\n              if (!(fileName !== null && this.hasCachedModel(fileName))) {\n                _context6.next = 8;\n                break;\n              }\n              key = fileName.toLowerCase();\n              _context6.next = 4;\n              return this._cache[key];\n            case 4:\n              group = _context6.sent;\n              return _context6.abrupt(\"return\", group.clone());\n            case 8:\n              return _context6.abrupt(\"return\", null);\n            case 9:\n            case \"end\":\n              return _context6.stop();\n          }\n        }, _callee5, this);\n      }));\n      function getCachedModel(_x5) {\n        return _getCachedModel.apply(this, arguments);\n      }\n      return getCachedModel;\n    }() // Loads and parses the model with the given file name. Returns a cached copy if available.\n  }, {\n    key: \"loadModel\",\n    value: function () {\n      var _loadModel = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(fileName) {\n        var parseCache, key, info, promise, group;\n        return _regeneratorRuntime().wrap(function _callee6$(_context7) {\n          while (1) switch (_context7.prev = _context7.next) {\n            case 0:\n              parseCache = this.parseCache;\n              key = fileName.toLowerCase();\n              if (!this.hasCachedModel(fileName)) {\n                _context7.next = 6;\n                break;\n              }\n              return _context7.abrupt(\"return\", this.getCachedModel(fileName));\n            case 6:\n              _context7.next = 8;\n              return parseCache.ensureDataLoaded(fileName);\n            case 8:\n              info = parseCache.getData(fileName);\n              promise = this.processIntoMesh(info);\n              if (!this.hasCachedModel(fileName)) {\n                _context7.next = 12;\n                break;\n              }\n              return _context7.abrupt(\"return\", this.getCachedModel(fileName));\n            case 12:\n              if (isPartType(info.type)) {\n                this._cache[key] = promise;\n              }\n              _context7.next = 15;\n              return promise;\n            case 15:\n              group = _context7.sent;\n              return _context7.abrupt(\"return\", group.clone());\n            case 17:\n            case \"end\":\n              return _context7.stop();\n          }\n        }, _callee6, this);\n      }));\n      function loadModel(_x6) {\n        return _loadModel.apply(this, arguments);\n      }\n      return loadModel;\n    }() // parses the given model text into a renderable object. Returns cached copy if available.\n  }, {\n    key: \"parseModel\",\n    value: function () {\n      var _parseModel = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7(text) {\n        var parseCache, info;\n        return _regeneratorRuntime().wrap(function _callee7$(_context8) {\n          while (1) switch (_context8.prev = _context8.next) {\n            case 0:\n              parseCache = this.parseCache;\n              info = parseCache.parse(text);\n              if (!(isPartType(info.type) && this.hasCachedModel(info.fileName))) {\n                _context8.next = 4;\n                break;\n              }\n              return _context8.abrupt(\"return\", this.getCachedModel(info.fileName));\n            case 4:\n              return _context8.abrupt(\"return\", this.processIntoMesh(info));\n            case 5:\n            case \"end\":\n              return _context8.stop();\n          }\n        }, _callee7, this);\n      }));\n      function parseModel(_x7) {\n        return _parseModel.apply(this, arguments);\n      }\n      return parseModel;\n    }()\n  }]);\n  return LDrawPartsGeometryCache;\n}();\nfunction sortByMaterial(a, b) {\n  if (a.colorCode === b.colorCode) {\n    return 0;\n  }\n  if (a.colorCode < b.colorCode) {\n    return -1;\n  }\n  return 1;\n}\nfunction createObject(elements, elementSize) {\n  var isConditionalSegments = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  var totalElements = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n  elements.sort(sortByMaterial);\n  if (totalElements === null) {\n    totalElements = elements.length;\n  }\n  var positions = new Float32Array(elementSize * totalElements * 3);\n  var normals = elementSize === 3 ? new Float32Array(elementSize * totalElements * 3) : null;\n  var materials = [];\n  var quadArray = new Array(6);\n  var bufferGeometry = new BufferGeometry();\n  var prevMaterial = null;\n  var index0 = 0;\n  var numGroupVerts = 0;\n  var offset = 0;\n  for (var iElem = 0, nElem = elements.length; iElem < nElem; iElem++) {\n    var elem = elements[iElem];\n    var vertices = elem.vertices;\n    if (vertices.length === 4) {\n      quadArray[0] = vertices[0];\n      quadArray[1] = vertices[1];\n      quadArray[2] = vertices[2];\n      quadArray[3] = vertices[0];\n      quadArray[4] = vertices[2];\n      quadArray[5] = vertices[3];\n      vertices = quadArray;\n    }\n    for (var j = 0, l = vertices.length; j < l; j++) {\n      var v = vertices[j];\n      var index = offset + j * 3;\n      positions[index + 0] = v.x;\n      positions[index + 1] = v.y;\n      positions[index + 2] = v.z;\n    }\n    if (elementSize === 3) {\n      if (!elem.faceNormal) {\n        var v0 = vertices[0];\n        var v1 = vertices[1];\n        var v2 = vertices[2];\n        _tempVec0.subVectors(v1, v0);\n        _tempVec1.subVectors(v2, v1);\n        elem.faceNormal = new Vector3().crossVectors(_tempVec0, _tempVec1).normalize();\n      }\n      var elemNormals = elem.normals;\n      if (elemNormals.length === 4) {\n        quadArray[0] = elemNormals[0];\n        quadArray[1] = elemNormals[1];\n        quadArray[2] = elemNormals[2];\n        quadArray[3] = elemNormals[0];\n        quadArray[4] = elemNormals[2];\n        quadArray[5] = elemNormals[3];\n        elemNormals = quadArray;\n      }\n      for (var _j = 0, _l6 = elemNormals.length; _j < _l6; _j++) {\n        var n = elem.faceNormal;\n        if (elemNormals[_j]) {\n          n = elemNormals[_j].norm;\n        }\n        var _index2 = offset + _j * 3;\n        normals[_index2 + 0] = n.x;\n        normals[_index2 + 1] = n.y;\n        normals[_index2 + 2] = n.z;\n      }\n    }\n    if (prevMaterial !== elem.colorCode) {\n      if (prevMaterial !== null) {\n        bufferGeometry.addGroup(index0, numGroupVerts, materials.length - 1);\n      }\n      var material = elem.material;\n      if (material !== null) {\n        if (elementSize === 3) {\n          materials.push(material);\n        } else if (elementSize === 2) {\n          if (material !== null) {\n            if (isConditionalSegments) {\n              materials.push(material.userData.edgeMaterial.userData.conditionalEdgeMaterial);\n            } else {\n              materials.push(material.userData.edgeMaterial);\n            }\n          } else {\n            materials.push(null);\n          }\n        }\n      } else {\n        materials.push(elem.colorCode);\n      }\n      prevMaterial = elem.colorCode;\n      index0 = offset / 3;\n      numGroupVerts = vertices.length;\n    } else {\n      numGroupVerts += vertices.length;\n    }\n    offset += 3 * vertices.length;\n  }\n  if (numGroupVerts > 0) {\n    bufferGeometry.addGroup(index0, Infinity, materials.length - 1);\n  }\n  bufferGeometry.setAttribute(\"position\", new BufferAttribute(positions, 3));\n  if (normals !== null) {\n    bufferGeometry.setAttribute(\"normal\", new BufferAttribute(normals, 3));\n  }\n  var object3d = null;\n  if (elementSize === 2) {\n    if (isConditionalSegments) {\n      object3d = new ConditionalLineSegments(bufferGeometry, materials.length === 1 ? materials[0] : materials);\n    } else {\n      object3d = new LineSegments(bufferGeometry, materials.length === 1 ? materials[0] : materials);\n    }\n  } else if (elementSize === 3) {\n    object3d = new Mesh(bufferGeometry, materials.length === 1 ? materials[0] : materials);\n  }\n  if (isConditionalSegments) {\n    object3d.isConditionalLine = true;\n    var controlArray0 = new Float32Array(elements.length * 3 * 2);\n    var controlArray1 = new Float32Array(elements.length * 3 * 2);\n    var directionArray = new Float32Array(elements.length * 3 * 2);\n    for (var i = 0, _l7 = elements.length; i < _l7; i++) {\n      var os = elements[i];\n      var _vertices5 = os.vertices;\n      var controlPoints = os.controlPoints;\n      var c0 = controlPoints[0];\n      var c1 = controlPoints[1];\n      var _v5 = _vertices5[0];\n      var _v6 = _vertices5[1];\n      var _index3 = i * 3 * 2;\n      controlArray0[_index3 + 0] = c0.x;\n      controlArray0[_index3 + 1] = c0.y;\n      controlArray0[_index3 + 2] = c0.z;\n      controlArray0[_index3 + 3] = c0.x;\n      controlArray0[_index3 + 4] = c0.y;\n      controlArray0[_index3 + 5] = c0.z;\n      controlArray1[_index3 + 0] = c1.x;\n      controlArray1[_index3 + 1] = c1.y;\n      controlArray1[_index3 + 2] = c1.z;\n      controlArray1[_index3 + 3] = c1.x;\n      controlArray1[_index3 + 4] = c1.y;\n      controlArray1[_index3 + 5] = c1.z;\n      directionArray[_index3 + 0] = _v6.x - _v5.x;\n      directionArray[_index3 + 1] = _v6.y - _v5.y;\n      directionArray[_index3 + 2] = _v6.z - _v5.z;\n      directionArray[_index3 + 3] = _v6.x - _v5.x;\n      directionArray[_index3 + 4] = _v6.y - _v5.y;\n      directionArray[_index3 + 5] = _v6.z - _v5.z;\n    }\n    bufferGeometry.setAttribute(\"control0\", new BufferAttribute(controlArray0, 3, false));\n    bufferGeometry.setAttribute(\"control1\", new BufferAttribute(controlArray1, 3, false));\n    bufferGeometry.setAttribute(\"direction\", new BufferAttribute(directionArray, 3, false));\n  }\n  return object3d;\n}\nvar LDrawLoader = /*#__PURE__*/function (_Loader) {\n  _inherits(LDrawLoader, _Loader);\n  var _super3 = _createSuper(LDrawLoader);\n  function LDrawLoader(manager) {\n    var _this5;\n    _classCallCheck(this, LDrawLoader);\n    _this5 = _super3.call(this, manager);\n    _this5.materials = [];\n    _this5.materialLibrary = {};\n    _this5.partsCache = new LDrawPartsGeometryCache(_assertThisInitialized(_this5));\n    _this5.fileMap = {};\n    _this5.setMaterials([]);\n    _this5.smoothNormals = true;\n    _this5.partsLibraryPath = \"\";\n    return _this5;\n  }\n  _createClass(LDrawLoader, [{\n    key: \"setPartsLibraryPath\",\n    value: function setPartsLibraryPath(path) {\n      this.partsLibraryPath = path;\n      return this;\n    }\n  }, {\n    key: \"preloadMaterials\",\n    value: function () {\n      var _preloadMaterials = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8(url) {\n        var fileLoader, text, colorLineRegex, lines, materials, i, l, line, directive, material;\n        return _regeneratorRuntime().wrap(function _callee8$(_context9) {\n          while (1) switch (_context9.prev = _context9.next) {\n            case 0:\n              fileLoader = new FileLoader(this.manager);\n              fileLoader.setPath(this.path);\n              fileLoader.setRequestHeader(this.requestHeader);\n              fileLoader.setWithCredentials(this.withCredentials);\n              _context9.next = 6;\n              return fileLoader.loadAsync(url);\n            case 6:\n              text = _context9.sent;\n              colorLineRegex = /^0 !COLOUR/;\n              lines = text.split(/[\\n\\r]/g);\n              materials = [];\n              for (i = 0, l = lines.length; i < l; i++) {\n                line = lines[i];\n                if (colorLineRegex.test(line)) {\n                  directive = line.replace(colorLineRegex, \"\");\n                  material = this.parseColorMetaDirective(new LineParser(directive));\n                  materials.push(material);\n                }\n              }\n              this.setMaterials(materials);\n            case 12:\n            case \"end\":\n              return _context9.stop();\n          }\n        }, _callee8, this);\n      }));\n      function preloadMaterials(_x8) {\n        return _preloadMaterials.apply(this, arguments);\n      }\n      return preloadMaterials;\n    }()\n  }, {\n    key: \"load\",\n    value: function load(url, onLoad, onProgress, onError) {\n      var _this6 = this;\n      var fileLoader = new FileLoader(this.manager);\n      fileLoader.setPath(this.path);\n      fileLoader.setRequestHeader(this.requestHeader);\n      fileLoader.setWithCredentials(this.withCredentials);\n      fileLoader.load(url, function (text) {\n        _this6.partsCache.parseModel(text, _this6.materialLibrary).then(function (group) {\n          _this6.applyMaterialsToMesh(group, MAIN_COLOUR_CODE, _this6.materialLibrary, true);\n          _this6.computeConstructionSteps(group);\n          onLoad(group);\n        }).catch(onError);\n      }, onProgress, onError);\n    }\n  }, {\n    key: \"parse\",\n    value: function parse(text, onLoad) {\n      var _this7 = this;\n      this.partsCache.parseModel(text, this.materialLibrary).then(function (group) {\n        _this7.computeConstructionSteps(group);\n        onLoad(group);\n      });\n    }\n  }, {\n    key: \"setMaterials\",\n    value: function setMaterials(materials) {\n      this.materialLibrary = {};\n      this.materials = [];\n      for (var i = 0, l = materials.length; i < l; i++) {\n        this.addMaterial(materials[i]);\n      }\n      this.addMaterial(this.parseColorMetaDirective(new LineParser(\"Main_Colour CODE 16 VALUE #FF8080 EDGE #333333\")));\n      this.addMaterial(this.parseColorMetaDirective(new LineParser(\"Edge_Colour CODE 24 VALUE #A0A0A0 EDGE #333333\")));\n      return this;\n    }\n  }, {\n    key: \"setFileMap\",\n    value: function setFileMap(fileMap) {\n      this.fileMap = fileMap;\n      return this;\n    }\n  }, {\n    key: \"addMaterial\",\n    value: function addMaterial(material) {\n      var matLib = this.materialLibrary;\n      if (!matLib[material.userData.code]) {\n        this.materials.push(material);\n        matLib[material.userData.code] = material;\n      }\n      return this;\n    }\n  }, {\n    key: \"getMaterial\",\n    value: function getMaterial(colorCode) {\n      if (colorCode.startsWith(\"0x2\")) {\n        var color = colorCode.substring(3);\n        return this.parseColorMetaDirective(new LineParser(\"Direct_Color_\" + color + \" CODE -1 VALUE #\" + color + \" EDGE #\" + color));\n      }\n      return this.materialLibrary[colorCode] || null;\n    }\n    // Applies the appropriate materials to a prebuilt hierarchy of geometry. Assumes that color codes are present\n    // in the material array if they need to be filled in.\n  }, {\n    key: \"applyMaterialsToMesh\",\n    value: function applyMaterialsToMesh(group, parentColorCode, materialHierarchy) {\n      var finalMaterialPass = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n      var loader = this;\n      var parentIsPassthrough = parentColorCode === MAIN_COLOUR_CODE;\n      group.traverse(function (c) {\n        if (c.isMesh || c.isLineSegments) {\n          if (Array.isArray(c.material)) {\n            for (var i = 0, l = c.material.length; i < l; i++) {\n              if (!c.material[i].isMaterial) {\n                c.material[i] = getMaterial(c, c.material[i]);\n              }\n            }\n          } else if (!c.material.isMaterial) {\n            c.material = getMaterial(c, c.material);\n          }\n        }\n      });\n      function getMaterial(c, colorCode) {\n        if (parentIsPassthrough && !(colorCode in materialHierarchy) && !finalMaterialPass) {\n          return colorCode;\n        }\n        var forEdge = c.isLineSegments || c.isConditionalLine;\n        var isPassthrough = !forEdge && colorCode === MAIN_COLOUR_CODE || forEdge && colorCode === MAIN_EDGE_COLOUR_CODE;\n        if (isPassthrough) {\n          colorCode = parentColorCode;\n        }\n        var material = null;\n        if (colorCode in materialHierarchy) {\n          material = materialHierarchy[colorCode];\n        } else if (finalMaterialPass) {\n          material = loader.getMaterial(colorCode);\n          if (material === null) {\n            throw new Error(\"LDrawLoader: Material properties for code \".concat(colorCode, \" not available.\"));\n          }\n        } else {\n          return colorCode;\n        }\n        if (c.isLineSegments) {\n          material = material.userData.edgeMaterial;\n          if (c.isConditionalLine) {\n            material = material.userData.conditionalEdgeMaterial;\n          }\n        }\n        return material;\n      }\n    }\n  }, {\n    key: \"getMainMaterial\",\n    value: function getMainMaterial() {\n      return this.getMaterial(MAIN_COLOUR_CODE);\n    }\n  }, {\n    key: \"getMainEdgeMaterial\",\n    value: function getMainEdgeMaterial() {\n      return this.getMaterial(MAIN_EDGE_COLOUR_CODE);\n    }\n  }, {\n    key: \"parseColorMetaDirective\",\n    value: function parseColorMetaDirective(lineParser) {\n      var code = null;\n      var color = 16711935;\n      var edgeColor = 16711935;\n      var alpha = 1;\n      var isTransparent = false;\n      var luminance = 0;\n      var finishType = FINISH_TYPE_DEFAULT;\n      var edgeMaterial = null;\n      var name = lineParser.getToken();\n      if (!name) {\n        throw new Error('LDrawLoader: Material name was expected after \"!COLOUR tag' + lineParser.getLineNumberString() + \".\");\n      }\n      var token = null;\n      while (true) {\n        token = lineParser.getToken();\n        if (!token) {\n          break;\n        }\n        switch (token.toUpperCase()) {\n          case \"CODE\":\n            code = lineParser.getToken();\n            break;\n          case \"VALUE\":\n            color = lineParser.getToken();\n            if (color.startsWith(\"0x\")) {\n              color = \"#\" + color.substring(2);\n            } else if (!color.startsWith(\"#\")) {\n              throw new Error(\"LDrawLoader: Invalid color while parsing material\" + lineParser.getLineNumberString() + \".\");\n            }\n            break;\n          case \"EDGE\":\n            edgeColor = lineParser.getToken();\n            if (edgeColor.startsWith(\"0x\")) {\n              edgeColor = \"#\" + edgeColor.substring(2);\n            } else if (!edgeColor.startsWith(\"#\")) {\n              edgeMaterial = this.getMaterial(edgeColor);\n              if (!edgeMaterial) {\n                throw new Error(\"LDrawLoader: Invalid edge color while parsing material\" + lineParser.getLineNumberString() + \".\");\n              }\n              edgeMaterial = edgeMaterial.userData.edgeMaterial;\n            }\n            break;\n          case \"ALPHA\":\n            alpha = parseInt(lineParser.getToken());\n            if (isNaN(alpha)) {\n              throw new Error(\"LDrawLoader: Invalid alpha value in material definition\" + lineParser.getLineNumberString() + \".\");\n            }\n            alpha = Math.max(0, Math.min(1, alpha / 255));\n            if (alpha < 1) {\n              isTransparent = true;\n            }\n            break;\n          case \"LUMINANCE\":\n            luminance = parseInt(lineParser.getToken());\n            if (isNaN(luminance)) {\n              throw new Error(\"LDrawLoader: Invalid luminance value in material definition\" + LineParser.getLineNumberString() + \".\");\n            }\n            luminance = Math.max(0, Math.min(1, luminance / 255));\n            break;\n          case \"CHROME\":\n            finishType = FINISH_TYPE_CHROME;\n            break;\n          case \"PEARLESCENT\":\n            finishType = FINISH_TYPE_PEARLESCENT;\n            break;\n          case \"RUBBER\":\n            finishType = FINISH_TYPE_RUBBER;\n            break;\n          case \"MATTE_METALLIC\":\n            finishType = FINISH_TYPE_MATTE_METALLIC;\n            break;\n          case \"METAL\":\n            finishType = FINISH_TYPE_METAL;\n            break;\n          case \"MATERIAL\":\n            lineParser.setToEnd();\n            break;\n          default:\n            throw new Error('LDrawLoader: Unknown token \"' + token + '\" while parsing material' + lineParser.getLineNumberString() + \".\");\n        }\n      }\n      var material = null;\n      switch (finishType) {\n        case FINISH_TYPE_DEFAULT:\n          material = new MeshStandardMaterial({\n            color: color,\n            roughness: 0.3,\n            metalness: 0\n          });\n          break;\n        case FINISH_TYPE_PEARLESCENT:\n          material = new MeshStandardMaterial({\n            color: color,\n            roughness: 0.3,\n            metalness: 0.25\n          });\n          break;\n        case FINISH_TYPE_CHROME:\n          material = new MeshStandardMaterial({\n            color: color,\n            roughness: 0,\n            metalness: 1\n          });\n          break;\n        case FINISH_TYPE_RUBBER:\n          material = new MeshStandardMaterial({\n            color: color,\n            roughness: 0.9,\n            metalness: 0\n          });\n          break;\n        case FINISH_TYPE_MATTE_METALLIC:\n          material = new MeshStandardMaterial({\n            color: color,\n            roughness: 0.8,\n            metalness: 0.4\n          });\n          break;\n        case FINISH_TYPE_METAL:\n          material = new MeshStandardMaterial({\n            color: color,\n            roughness: 0.2,\n            metalness: 0.85\n          });\n          break;\n      }\n      material.transparent = isTransparent;\n      material.premultipliedAlpha = true;\n      material.opacity = alpha;\n      material.depthWrite = !isTransparent;\n      material.polygonOffset = true;\n      material.polygonOffsetFactor = 1;\n      if (luminance !== 0) {\n        material.emissive.set(material.color).multiplyScalar(luminance);\n      }\n      if (!edgeMaterial) {\n        edgeMaterial = new LineBasicMaterial({\n          color: edgeColor,\n          transparent: isTransparent,\n          opacity: alpha,\n          depthWrite: !isTransparent\n        });\n        edgeMaterial.userData.code = code;\n        edgeMaterial.name = name + \" - Edge\";\n        edgeMaterial.userData.conditionalEdgeMaterial = new LDrawConditionalLineMaterial({\n          fog: true,\n          transparent: isTransparent,\n          depthWrite: !isTransparent,\n          color: edgeColor,\n          opacity: alpha\n        });\n      }\n      material.userData.code = code;\n      material.name = name;\n      material.userData.edgeMaterial = edgeMaterial;\n      this.addMaterial(material);\n      return material;\n    }\n  }, {\n    key: \"computeConstructionSteps\",\n    value: function computeConstructionSteps(model) {\n      var stepNumber = 0;\n      model.traverse(function (c) {\n        if (c.isGroup) {\n          if (c.userData.startingConstructionStep) {\n            stepNumber++;\n          }\n          c.userData.constructionStep = stepNumber;\n        }\n      });\n      model.userData.numConstructionSteps = stepNumber + 1;\n    }\n  }]);\n  return LDrawLoader;\n}(Loader);\nexport { LDrawLoader };","map":{"version":3,"names":["FINISH_TYPE_DEFAULT","FINISH_TYPE_CHROME","FINISH_TYPE_PEARLESCENT","FINISH_TYPE_RUBBER","FINISH_TYPE_MATTE_METALLIC","FINISH_TYPE_METAL","FILE_LOCATION_AS_IS","FILE_LOCATION_TRY_PARTS","FILE_LOCATION_TRY_P","FILE_LOCATION_TRY_MODELS","FILE_LOCATION_TRY_RELATIVE","FILE_LOCATION_TRY_ABSOLUTE","FILE_LOCATION_NOT_FOUND","MAIN_COLOUR_CODE","MAIN_EDGE_COLOUR_CODE","_tempVec0","Vector3","_tempVec1","LDrawConditionalLineMaterial","_ShaderMaterial","_inherits","_super","_createSuper","parameters","_this","_classCallCheck","call","uniforms","UniformsUtils","merge","UniformsLib","fog","diffuse","value","Color","opacity","vertexShader","fragmentShader","concat","parseInt","REVISION","replace","Object","defineProperties","_assertThisInitialized","get","set","color","setValues","isLDrawConditionalLineMaterial","_createClass","ShaderMaterial","ConditionalLineSegments","_LineSegments","_super2","geometry","material","_this2","isConditionalLine","LineSegments","generateFaceNormals","faces","i","l","length","face","vertices","v0","v1","v2","subVectors","faceNormal","crossVectors","normalize","_ray","Ray","smoothNormals","lineSegments","checkSubSegments","arguments","undefined","hashMultiplier","hashVertex","v","x","y","z","hashEdge","toNormalizedRay","targetRay","direction","scalar","dot","origin","copy","addScaledVector","hashRay","ray","hardEdges","Set","hardEdgeRays","Map","halfEdgeList","normals","ls","add","rh1","has","rh2","info2","distances","info","d0","d1","_ref","push","tri","vertCount","i2","index","next","hash","rayHash","_ref2","found","i3","l2","halfEdge","key","queue","pop","vertNormals","reverseHash","otherInfo","otherTri","otherIndex","otherNormals","otherVertCount","otherFaceNormal","Math","abs","otherNext","norm","sharedNormal1","sharedNormal2","isPartType","type","isPrimitiveType","test","LineParser","line","lineNumber","lineLength","currentCharIndex","currentChar","seekNonSpace","charAt","getToken","pos0","pos1","substring","getVector","parseFloat","getRemainingString","isAtTheEnd","setToEnd","getLineNumberString","LDrawParsedCache","loader","_cache","cloneResult","original","result","map","colorCode","clone","conditionalSegments","controlPoints","category","keywords","subobjects","totalFaces","startingConstructionStep","materials","group","_fetchData","_asyncToGenerator","_regeneratorRuntime","mark","_callee","fileName","triedLowerCase","locationState","subobjectURL","fileLoader","text","wrap","_callee$","_context","prev","t0","abrupt","lastIndexOf","toLowerCase","FileLoader","manager","setPath","partsLibraryPath","setRequestHeader","requestHeader","setWithCredentials","withCredentials","loadAsync","sent","t1","Error","stop","fetchData","_x","apply","parse","getLocalMaterial","indexOf","lines","split","numLines","parsingEmbeddedFiles","currentEmbeddedFileName","currentEmbeddedText","bfcCertified","bfcCCW","bfcInverted","bfcCull","lineIndex","startsWith","setData","lp","lineType","segment","ccw","doubleSided","v3","c0","c1","meta","parseColorMetaDirective","userData","code","console","warn","newKeywords","forEach","keyword","trim","token","posX","posY","posZ","m0","m1","m2","m3","m4","m5","m6","m7","m8","matrix","Matrix4","fileName2","fileMap","inverted","getData","Promise","_ensureDataLoaded","_callee2","_this3","_callee2$","_context2","then","ensureDataLoaded","_x2","getMaterialFromCode","parentColorCode","materialHierarchy","forEdge","isPassthrough","LDrawPartsGeometryCache","parseCache","_processIntoMesh","_callee4","_this4","faceMaterials","processInfoSubobjects","_callee4$","_context5","_ref3","_callee3","subobject","promises","_loop","group2","subobjectInfos","_i4","_l3","subobject2","subobjectInfo","subobjectGroup","parentLineSegments","parentConditionalSegments","parentFaces","matrixScaleInverted","lineColorCode","_i5","_l4","os","_vertices3","_i6","_l5","_vertices4","l3","_args4","_callee3$","_context4","promise","_loop$","_context3","loadModel","catch","error","delegateYield","Group","all","isGroup","decompose","position","quaternion","scale","name","applyMaterialsToMesh","children","determinant","applyMatrix4","reverse","_x4","size","createObject","processIntoMesh","_x3","hasCachedModel","_getCachedModel","_callee5","_callee5$","_context6","getCachedModel","_x5","_loadModel","_callee6","_callee6$","_context7","_x6","_parseModel","_callee7","_callee7$","_context8","parseModel","_x7","sortByMaterial","a","b","elements","elementSize","isConditionalSegments","totalElements","sort","positions","Float32Array","quadArray","Array","bufferGeometry","BufferGeometry","prevMaterial","index0","numGroupVerts","offset","iElem","nElem","elem","j","elemNormals","n","addGroup","edgeMaterial","conditionalEdgeMaterial","Infinity","setAttribute","BufferAttribute","object3d","Mesh","controlArray0","controlArray1","directionArray","LDrawLoader","_Loader","_super3","_this5","materialLibrary","partsCache","setMaterials","setPartsLibraryPath","path","_preloadMaterials","_callee8","url","colorLineRegex","directive","_callee8$","_context9","preloadMaterials","_x8","load","onLoad","onProgress","onError","_this6","computeConstructionSteps","_this7","addMaterial","setFileMap","matLib","getMaterial","finalMaterialPass","parentIsPassthrough","traverse","c","isMesh","isLineSegments","isArray","isMaterial","getMainMaterial","getMainEdgeMaterial","lineParser","edgeColor","alpha","isTransparent","luminance","finishType","toUpperCase","isNaN","max","min","MeshStandardMaterial","roughness","metalness","transparent","premultipliedAlpha","depthWrite","polygonOffset","polygonOffsetFactor","emissive","multiplyScalar","LineBasicMaterial","model","stepNumber","constructionStep","numConstructionSteps","Loader"],"sources":["C:\\Users\\Nayyu\\Desktop\\skibidai-public-build\\node_modules\\src\\loaders\\LDrawLoader.js"],"sourcesContent":["import {\n  BufferAttribute,\n  BufferGeometry,\n  Color,\n  FileLoader,\n  Group,\n  LineBasicMaterial,\n  LineSegments,\n  Loader,\n  Matrix4,\n  Mesh,\n  MeshStandardMaterial,\n  ShaderMaterial,\n  UniformsLib,\n  UniformsUtils,\n  Vector3,\n  Ray,\n  REVISION,\n} from 'three'\n\n// Special surface finish tag types.\n// Note: \"MATERIAL\" tag (e.g. GLITTER, SPECKLE) is not implemented\nconst FINISH_TYPE_DEFAULT = 0\nconst FINISH_TYPE_CHROME = 1\nconst FINISH_TYPE_PEARLESCENT = 2\nconst FINISH_TYPE_RUBBER = 3\nconst FINISH_TYPE_MATTE_METALLIC = 4\nconst FINISH_TYPE_METAL = 5\n\n// State machine to search a subobject path.\n// The LDraw standard establishes these various possible subfolders.\nconst FILE_LOCATION_AS_IS = 0\nconst FILE_LOCATION_TRY_PARTS = 1\nconst FILE_LOCATION_TRY_P = 2\nconst FILE_LOCATION_TRY_MODELS = 3\nconst FILE_LOCATION_TRY_RELATIVE = 4\nconst FILE_LOCATION_TRY_ABSOLUTE = 5\nconst FILE_LOCATION_NOT_FOUND = 6\n\nconst MAIN_COLOUR_CODE = '16'\nconst MAIN_EDGE_COLOUR_CODE = '24'\n\nconst _tempVec0 = new Vector3()\nconst _tempVec1 = new Vector3()\n\nclass LDrawConditionalLineMaterial extends ShaderMaterial {\n  constructor(parameters) {\n    super({\n      uniforms: UniformsUtils.merge([\n        UniformsLib.fog,\n        {\n          diffuse: {\n            value: new Color(),\n          },\n          opacity: {\n            value: 1.0,\n          },\n        },\n      ]),\n\n      vertexShader: /* glsl */ `\n        attribute vec3 control0;\n        attribute vec3 control1;\n        attribute vec3 direction;\n        varying float discardFlag;\n\n        #include <common>\n        #include <color_pars_vertex>\n        #include <fog_pars_vertex>\n        #include <logdepthbuf_pars_vertex>\n        #include <clipping_planes_pars_vertex>\n\n        void main() {\n          #include <color_vertex>\n\n          vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n          gl_Position = projectionMatrix * mvPosition;\n\n          // Transform the line segment ends and control points into camera clip space\n          vec4 c0 = projectionMatrix * modelViewMatrix * vec4(control0, 1.0);\n          vec4 c1 = projectionMatrix * modelViewMatrix * vec4(control1, 1.0);\n          vec4 p0 = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n          vec4 p1 = projectionMatrix * modelViewMatrix * vec4(position + direction, 1.0);\n\n          c0.xy /= c0.w;\n          c1.xy /= c1.w;\n          p0.xy /= p0.w;\n          p1.xy /= p1.w;\n\n          // Get the direction of the segment and an orthogonal vector\n          vec2 dir = p1.xy - p0.xy;\n          vec2 norm = vec2(-dir.y, dir.x);\n\n          // Get control point directions from the line\n          vec2 c0dir = c0.xy - p1.xy;\n          vec2 c1dir = c1.xy - p1.xy;\n\n          // If the vectors to the controls points are pointed in different directions away\n          // from the line segment then the line should not be drawn.\n          float d0 = dot(normalize(norm), normalize(c0dir));\n          float d1 = dot(normalize(norm), normalize(c1dir));\n          discardFlag = float(sign(d0) != sign(d1));\n\n          #include <logdepthbuf_vertex>\n          #include <clipping_planes_vertex>\n          #include <fog_vertex>\n        }\n      `,\n\n      fragmentShader: /* glsl */ `\n        uniform vec3 diffuse;\n        uniform float opacity;\n        varying float discardFlag;\n\n        #include <common>\n        #include <color_pars_fragment>\n        #include <fog_pars_fragment>\n        #include <logdepthbuf_pars_fragment>\n        #include <clipping_planes_pars_fragment>\n\n        void main() {\n          if (discardFlag > 0.5) discard;\n\n          #include <clipping_planes_fragment>\n          vec3 outgoingLight = vec3(0.0);\n          vec4 diffuseColor = vec4(diffuse, opacity);\n          #include <logdepthbuf_fragment>\n          #include <color_fragment>\n          outgoingLight = diffuseColor.rgb; // simple shader\n          gl_FragColor = vec4(outgoingLight, diffuseColor.a);\n          #include <tonemapping_fragment>\n          #include <${parseInt(REVISION.replace(/\\D+/g, '')) >= 154 ? 'colorspace_fragment' : 'encodings_fragment'}>\n          #include <fog_fragment>\n          #include <premultiplied_alpha_fragment>\n        }\n      `,\n    })\n\n    Object.defineProperties(this, {\n      opacity: {\n        get: function () {\n          return this.uniforms.opacity.value\n        },\n\n        set: function (value) {\n          this.uniforms.opacity.value = value\n        },\n      },\n\n      color: {\n        get: function () {\n          return this.uniforms.diffuse.value\n        },\n      },\n    })\n\n    this.setValues(parameters)\n    this.isLDrawConditionalLineMaterial = true\n  }\n}\n\nclass ConditionalLineSegments extends LineSegments {\n  constructor(geometry, material) {\n    super(geometry, material)\n    this.isConditionalLine = true\n  }\n}\n\nfunction generateFaceNormals(faces) {\n  for (let i = 0, l = faces.length; i < l; i++) {\n    const face = faces[i]\n    const vertices = face.vertices\n    const v0 = vertices[0]\n    const v1 = vertices[1]\n    const v2 = vertices[2]\n\n    _tempVec0.subVectors(v1, v0)\n    _tempVec1.subVectors(v2, v1)\n    face.faceNormal = new Vector3().crossVectors(_tempVec0, _tempVec1).normalize()\n  }\n}\n\nconst _ray = new Ray()\nfunction smoothNormals(faces, lineSegments, checkSubSegments = false) {\n  // NOTE: 1e2 is pretty coarse but was chosen to quantize the resulting value because\n  // it allows edges to be smoothed as expected (see minifig arms).\n  // --\n  // And the vector values are initialize multiplied by 1 + 1e-10 to account for floating\n  // point errors on vertices along quantization boundaries. Ie after matrix multiplication\n  // vertices that should be merged might be set to \"1.7\" and \"1.6999...\" meaning they won't\n  // get merged. This added epsilon attempts to push these error values to the same quantized\n  // value for the sake of hashing. See \"AT-ST mini\" dishes. See mrdoob/three#23169.\n\n  const hashMultiplier = (1 + 1e-10) * 1e2\n  function hashVertex(v) {\n    const x = ~~(v.x * hashMultiplier)\n    const y = ~~(v.y * hashMultiplier)\n    const z = ~~(v.z * hashMultiplier)\n\n    return `${x},${y},${z}`\n  }\n\n  function hashEdge(v0, v1) {\n    return `${hashVertex(v0)}_${hashVertex(v1)}`\n  }\n\n  // converts the two vertices to a ray with a normalized direction and origin of 0, 0, 0 projected\n  // onto the original line.\n  function toNormalizedRay(v0, v1, targetRay) {\n    targetRay.direction.subVectors(v1, v0).normalize()\n\n    const scalar = v0.dot(targetRay.direction)\n    targetRay.origin.copy(v0).addScaledVector(targetRay.direction, -scalar)\n\n    return targetRay\n  }\n\n  function hashRay(ray) {\n    return hashEdge(ray.origin, ray.direction)\n  }\n\n  const hardEdges = new Set()\n  const hardEdgeRays = new Map()\n  const halfEdgeList = {}\n  const normals = []\n\n  // Save the list of hard edges by hash\n  for (let i = 0, l = lineSegments.length; i < l; i++) {\n    const ls = lineSegments[i]\n    const vertices = ls.vertices\n    const v0 = vertices[0]\n    const v1 = vertices[1]\n    hardEdges.add(hashEdge(v0, v1))\n    hardEdges.add(hashEdge(v1, v0))\n\n    // only generate the hard edge ray map if we're checking subsegments because it's more expensive to check\n    // and requires more memory.\n    if (checkSubSegments) {\n      // add both ray directions to the map\n      const ray = toNormalizedRay(v0, v1, new Ray())\n      const rh1 = hashRay(ray)\n      if (!hardEdgeRays.has(rh1)) {\n        toNormalizedRay(v1, v0, ray)\n        const rh2 = hashRay(ray)\n\n        const info = {\n          ray,\n          distances: [],\n        }\n\n        hardEdgeRays.set(rh1, info)\n        hardEdgeRays.set(rh2, info)\n      }\n\n      // store both segments ends in min, max order in the distances array to check if a face edge is a\n      // subsegment later.\n      const info = hardEdgeRays.get(rh1)\n      let d0 = info.ray.direction.dot(v0)\n      let d1 = info.ray.direction.dot(v1)\n      if (d0 > d1) {\n        ;[d0, d1] = [d1, d0]\n      }\n\n      info.distances.push(d0, d1)\n    }\n  }\n\n  // track the half edges associated with each triangle\n  for (let i = 0, l = faces.length; i < l; i++) {\n    const tri = faces[i]\n    const vertices = tri.vertices\n    const vertCount = vertices.length\n    for (let i2 = 0; i2 < vertCount; i2++) {\n      const index = i2\n      const next = (i2 + 1) % vertCount\n      const v0 = vertices[index]\n      const v1 = vertices[next]\n      const hash = hashEdge(v0, v1)\n\n      // don't add the triangle if the edge is supposed to be hard\n      if (hardEdges.has(hash)) {\n        continue\n      }\n\n      // if checking subsegments then check to see if this edge lies on a hard edge ray and whether its within any ray bounds\n      if (checkSubSegments) {\n        toNormalizedRay(v0, v1, _ray)\n\n        const rayHash = hashRay(_ray)\n        if (hardEdgeRays.has(rayHash)) {\n          const info = hardEdgeRays.get(rayHash)\n          const { ray, distances } = info\n          let d0 = ray.direction.dot(v0)\n          let d1 = ray.direction.dot(v1)\n\n          if (d0 > d1) {\n            ;[d0, d1] = [d1, d0]\n          }\n\n          // return early if the face edge is found to be a subsegment of a line edge meaning the edge will have \"hard\" normals\n          let found = false\n          for (let i = 0, l = distances.length; i < l; i += 2) {\n            if (d0 >= distances[i] && d1 <= distances[i + 1]) {\n              found = true\n              break\n            }\n          }\n\n          if (found) {\n            continue\n          }\n        }\n      }\n\n      const info = {\n        index: index,\n        tri: tri,\n      }\n      halfEdgeList[hash] = info\n    }\n  }\n\n  // Iterate until we've tried to connect all faces to share normals\n  while (true) {\n    // Stop if there are no more faces left\n    let halfEdge = null\n    for (const key in halfEdgeList) {\n      halfEdge = halfEdgeList[key]\n      break\n    }\n\n    if (halfEdge === null) {\n      break\n    }\n\n    // Exhaustively find all connected faces\n    const queue = [halfEdge]\n    while (queue.length > 0) {\n      // initialize all vertex normals in this triangle\n      const tri = queue.pop().tri\n      const vertices = tri.vertices\n      const vertNormals = tri.normals\n      const faceNormal = tri.faceNormal\n\n      // Check if any edge is connected to another triangle edge\n      const vertCount = vertices.length\n      for (let i2 = 0; i2 < vertCount; i2++) {\n        const index = i2\n        const next = (i2 + 1) % vertCount\n        const v0 = vertices[index]\n        const v1 = vertices[next]\n\n        // delete this triangle from the list so it won't be found again\n        const hash = hashEdge(v0, v1)\n        delete halfEdgeList[hash]\n\n        const reverseHash = hashEdge(v1, v0)\n        const otherInfo = halfEdgeList[reverseHash]\n        if (otherInfo) {\n          const otherTri = otherInfo.tri\n          const otherIndex = otherInfo.index\n          const otherNormals = otherTri.normals\n          const otherVertCount = otherNormals.length\n          const otherFaceNormal = otherTri.faceNormal\n\n          // NOTE: If the angle between faces is > 67.5 degrees then assume it's\n          // hard edge. There are some cases where the line segments do not line up exactly\n          // with or span multiple triangle edges (see Lunar Vehicle wheels).\n          if (Math.abs(otherTri.faceNormal.dot(tri.faceNormal)) < 0.25) {\n            continue\n          }\n\n          // if this triangle has already been traversed then it won't be in\n          // the halfEdgeList. If it has not then add it to the queue and delete\n          // it so it won't be found again.\n          if (reverseHash in halfEdgeList) {\n            queue.push(otherInfo)\n            delete halfEdgeList[reverseHash]\n          }\n\n          // share the first normal\n          const otherNext = (otherIndex + 1) % otherVertCount\n          if (vertNormals[index] && otherNormals[otherNext] && vertNormals[index] !== otherNormals[otherNext]) {\n            otherNormals[otherNext].norm.add(vertNormals[index].norm)\n            vertNormals[index].norm = otherNormals[otherNext].norm\n          }\n\n          let sharedNormal1 = vertNormals[index] || otherNormals[otherNext]\n          if (sharedNormal1 === null) {\n            // it's possible to encounter an edge of a triangle that has already been traversed meaning\n            // both edges already have different normals defined and shared. To work around this we create\n            // a wrapper object so when those edges are merged the normals can be updated everywhere.\n            sharedNormal1 = { norm: new Vector3() }\n            normals.push(sharedNormal1.norm)\n          }\n\n          if (vertNormals[index] === null) {\n            vertNormals[index] = sharedNormal1\n            sharedNormal1.norm.add(faceNormal)\n          }\n\n          if (otherNormals[otherNext] === null) {\n            otherNormals[otherNext] = sharedNormal1\n            sharedNormal1.norm.add(otherFaceNormal)\n          }\n\n          // share the second normal\n          if (vertNormals[next] && otherNormals[otherIndex] && vertNormals[next] !== otherNormals[otherIndex]) {\n            otherNormals[otherIndex].norm.add(vertNormals[next].norm)\n            vertNormals[next].norm = otherNormals[otherIndex].norm\n          }\n\n          let sharedNormal2 = vertNormals[next] || otherNormals[otherIndex]\n          if (sharedNormal2 === null) {\n            sharedNormal2 = { norm: new Vector3() }\n            normals.push(sharedNormal2.norm)\n          }\n\n          if (vertNormals[next] === null) {\n            vertNormals[next] = sharedNormal2\n            sharedNormal2.norm.add(faceNormal)\n          }\n\n          if (otherNormals[otherIndex] === null) {\n            otherNormals[otherIndex] = sharedNormal2\n            sharedNormal2.norm.add(otherFaceNormal)\n          }\n        }\n      }\n    }\n  }\n\n  // The normals of each face have been added up so now we average them by normalizing the vector.\n  for (let i = 0, l = normals.length; i < l; i++) {\n    normals[i].normalize()\n  }\n}\n\nfunction isPartType(type) {\n  return type === 'Part' || type === 'Unofficial_Part'\n}\n\nfunction isPrimitiveType(type) {\n  return /primitive/i.test(type) || type === 'Subpart'\n}\n\nclass LineParser {\n  constructor(line, lineNumber) {\n    this.line = line\n    this.lineLength = line.length\n    this.currentCharIndex = 0\n    this.currentChar = ' '\n    this.lineNumber = lineNumber\n  }\n\n  seekNonSpace() {\n    while (this.currentCharIndex < this.lineLength) {\n      this.currentChar = this.line.charAt(this.currentCharIndex)\n\n      if (this.currentChar !== ' ' && this.currentChar !== '\\t') {\n        return\n      }\n\n      this.currentCharIndex++\n    }\n  }\n\n  getToken() {\n    const pos0 = this.currentCharIndex++\n\n    // Seek space\n    while (this.currentCharIndex < this.lineLength) {\n      this.currentChar = this.line.charAt(this.currentCharIndex)\n\n      if (this.currentChar === ' ' || this.currentChar === '\\t') {\n        break\n      }\n\n      this.currentCharIndex++\n    }\n\n    const pos1 = this.currentCharIndex\n\n    this.seekNonSpace()\n\n    return this.line.substring(pos0, pos1)\n  }\n\n  getVector() {\n    return new Vector3(parseFloat(this.getToken()), parseFloat(this.getToken()), parseFloat(this.getToken()))\n  }\n\n  getRemainingString() {\n    return this.line.substring(this.currentCharIndex, this.lineLength)\n  }\n\n  isAtTheEnd() {\n    return this.currentCharIndex >= this.lineLength\n  }\n\n  setToEnd() {\n    this.currentCharIndex = this.lineLength\n  }\n\n  getLineNumberString() {\n    return this.lineNumber >= 0 ? ' at line ' + this.lineNumber : ''\n  }\n}\n\n// Fetches and parses an intermediate representation of LDraw parts files.\nclass LDrawParsedCache {\n  constructor(loader) {\n    this.loader = loader\n    this._cache = {}\n  }\n\n  cloneResult(original) {\n    const result = {}\n\n    // vertices are transformed and normals computed before being converted to geometry\n    // so these pieces must be cloned.\n    result.faces = original.faces.map((face) => {\n      return {\n        colorCode: face.colorCode,\n        material: face.material,\n        vertices: face.vertices.map((v) => v.clone()),\n        normals: face.normals.map(() => null),\n        faceNormal: null,\n      }\n    })\n\n    result.conditionalSegments = original.conditionalSegments.map((face) => {\n      return {\n        colorCode: face.colorCode,\n        material: face.material,\n        vertices: face.vertices.map((v) => v.clone()),\n        controlPoints: face.controlPoints.map((v) => v.clone()),\n      }\n    })\n\n    result.lineSegments = original.lineSegments.map((face) => {\n      return {\n        colorCode: face.colorCode,\n        material: face.material,\n        vertices: face.vertices.map((v) => v.clone()),\n      }\n    })\n\n    // none if this is subsequently modified\n    result.type = original.type\n    result.category = original.category\n    result.keywords = original.keywords\n    result.subobjects = original.subobjects\n    result.totalFaces = original.totalFaces\n    result.startingConstructionStep = original.startingConstructionStep\n    result.materials = original.materials\n    result.group = null\n    return result\n  }\n\n  async fetchData(fileName) {\n    let triedLowerCase = false\n    let locationState = FILE_LOCATION_AS_IS\n    while (locationState !== FILE_LOCATION_NOT_FOUND) {\n      let subobjectURL = fileName\n      switch (locationState) {\n        case FILE_LOCATION_AS_IS:\n          locationState = locationState + 1\n          break\n\n        case FILE_LOCATION_TRY_PARTS:\n          subobjectURL = 'parts/' + subobjectURL\n          locationState = locationState + 1\n          break\n\n        case FILE_LOCATION_TRY_P:\n          subobjectURL = 'p/' + subobjectURL\n          locationState = locationState + 1\n          break\n\n        case FILE_LOCATION_TRY_MODELS:\n          subobjectURL = 'models/' + subobjectURL\n          locationState = locationState + 1\n          break\n\n        case FILE_LOCATION_TRY_RELATIVE:\n          subobjectURL = fileName.substring(0, fileName.lastIndexOf('/') + 1) + subobjectURL\n          locationState = locationState + 1\n          break\n\n        case FILE_LOCATION_TRY_ABSOLUTE:\n          if (triedLowerCase) {\n            // Try absolute path\n            locationState = FILE_LOCATION_NOT_FOUND\n          } else {\n            // Next attempt is lower case\n            fileName = fileName.toLowerCase()\n            subobjectURL = fileName\n            triedLowerCase = true\n            locationState = FILE_LOCATION_AS_IS\n          }\n\n          break\n      }\n\n      const loader = this.loader\n      const fileLoader = new FileLoader(loader.manager)\n      fileLoader.setPath(loader.partsLibraryPath)\n      fileLoader.setRequestHeader(loader.requestHeader)\n      fileLoader.setWithCredentials(loader.withCredentials)\n\n      try {\n        const text = await fileLoader.loadAsync(subobjectURL)\n        return text\n      } catch {\n        continue\n      }\n    }\n\n    throw new Error('LDrawLoader: Subobject \"' + fileName + '\" could not be loaded.')\n  }\n\n  parse(text, fileName = null) {\n    const loader = this.loader\n\n    // final results\n    const faces = []\n    const lineSegments = []\n    const conditionalSegments = []\n    const subobjects = []\n    const materials = {}\n\n    const getLocalMaterial = (colorCode) => {\n      return materials[colorCode] || null\n    }\n\n    let type = 'Model'\n    let category = null\n    let keywords = null\n    let totalFaces = 0\n\n    // split into lines\n    if (text.indexOf('\\r\\n') !== -1) {\n      // This is faster than String.split with regex that splits on both\n      text = text.replace(/\\r\\n/g, '\\n')\n    }\n\n    const lines = text.split('\\n')\n    const numLines = lines.length\n\n    let parsingEmbeddedFiles = false\n    let currentEmbeddedFileName = null\n    let currentEmbeddedText = null\n\n    let bfcCertified = false\n    let bfcCCW = true\n    let bfcInverted = false\n    let bfcCull = true\n\n    let startingConstructionStep = false\n\n    // Parse all line commands\n    for (let lineIndex = 0; lineIndex < numLines; lineIndex++) {\n      const line = lines[lineIndex]\n\n      if (line.length === 0) continue\n\n      if (parsingEmbeddedFiles) {\n        if (line.startsWith('0 FILE ')) {\n          // Save previous embedded file in the cache\n          this.setData(currentEmbeddedFileName, currentEmbeddedText)\n\n          // New embedded text file\n          currentEmbeddedFileName = line.substring(7)\n          currentEmbeddedText = ''\n        } else {\n          currentEmbeddedText += line + '\\n'\n        }\n\n        continue\n      }\n\n      const lp = new LineParser(line, lineIndex + 1)\n      lp.seekNonSpace()\n\n      if (lp.isAtTheEnd()) {\n        // Empty line\n        continue\n      }\n\n      // Parse the line type\n      const lineType = lp.getToken()\n\n      let material\n      let colorCode\n      let segment\n      let ccw\n      let doubleSided\n      let v0, v1, v2, v3, c0, c1\n\n      switch (lineType) {\n        // Line type 0: Comment or META\n        case '0':\n          // Parse meta directive\n          const meta = lp.getToken()\n\n          if (meta) {\n            switch (meta) {\n              case '!LDRAW_ORG':\n                type = lp.getToken()\n                break\n\n              case '!COLOUR':\n                material = loader.parseColorMetaDirective(lp)\n                if (material) {\n                  materials[material.userData.code] = material\n                } else {\n                  console.warn('LDrawLoader: Error parsing material' + lp.getLineNumberString())\n                }\n\n                break\n\n              case '!CATEGORY':\n                category = lp.getToken()\n                break\n\n              case '!KEYWORDS':\n                const newKeywords = lp.getRemainingString().split(',')\n                if (newKeywords.length > 0) {\n                  if (!keywords) {\n                    keywords = []\n                  }\n\n                  newKeywords.forEach(function (keyword) {\n                    keywords.push(keyword.trim())\n                  })\n                }\n\n                break\n\n              case 'FILE':\n                if (lineIndex > 0) {\n                  // Start embedded text files parsing\n                  parsingEmbeddedFiles = true\n                  currentEmbeddedFileName = lp.getRemainingString()\n                  currentEmbeddedText = ''\n\n                  bfcCertified = false\n                  bfcCCW = true\n                }\n\n                break\n\n              case 'BFC':\n                // Changes to the backface culling state\n                while (!lp.isAtTheEnd()) {\n                  const token = lp.getToken()\n\n                  switch (token) {\n                    case 'CERTIFY':\n                    case 'NOCERTIFY':\n                      bfcCertified = token === 'CERTIFY'\n                      bfcCCW = true\n\n                      break\n\n                    case 'CW':\n                    case 'CCW':\n                      bfcCCW = token === 'CCW'\n\n                      break\n\n                    case 'INVERTNEXT':\n                      bfcInverted = true\n\n                      break\n\n                    case 'CLIP':\n                    case 'NOCLIP':\n                      bfcCull = token === 'CLIP'\n\n                      break\n\n                    default:\n                      console.warn('THREE.LDrawLoader: BFC directive \"' + token + '\" is unknown.')\n\n                      break\n                  }\n                }\n\n                break\n\n              case 'STEP':\n                startingConstructionStep = true\n\n                break\n\n              default:\n                // Other meta directives are not implemented\n                break\n            }\n          }\n\n          break\n\n        // Line type 1: Sub-object file\n        case '1':\n          colorCode = lp.getToken()\n          material = getLocalMaterial(colorCode)\n\n          const posX = parseFloat(lp.getToken())\n          const posY = parseFloat(lp.getToken())\n          const posZ = parseFloat(lp.getToken())\n          const m0 = parseFloat(lp.getToken())\n          const m1 = parseFloat(lp.getToken())\n          const m2 = parseFloat(lp.getToken())\n          const m3 = parseFloat(lp.getToken())\n          const m4 = parseFloat(lp.getToken())\n          const m5 = parseFloat(lp.getToken())\n          const m6 = parseFloat(lp.getToken())\n          const m7 = parseFloat(lp.getToken())\n          const m8 = parseFloat(lp.getToken())\n\n          const matrix = new Matrix4().set(m0, m1, m2, posX, m3, m4, m5, posY, m6, m7, m8, posZ, 0, 0, 0, 1)\n\n          let fileName = lp.getRemainingString().trim().replace(/\\\\/g, '/')\n\n          if (loader.fileMap[fileName]) {\n            // Found the subobject path in the preloaded file path map\n            fileName = loader.fileMap[fileName]\n          } else {\n            // Standardized subfolders\n            if (fileName.startsWith('s/')) {\n              fileName = 'parts/' + fileName\n            } else if (fileName.startsWith('48/')) {\n              fileName = 'p/' + fileName\n            }\n          }\n\n          subobjects.push({\n            material: material,\n            colorCode: colorCode,\n            matrix: matrix,\n            fileName: fileName,\n            inverted: bfcInverted,\n            startingConstructionStep: startingConstructionStep,\n          })\n\n          bfcInverted = false\n\n          break\n\n        // Line type 2: Line segment\n        case '2':\n          colorCode = lp.getToken()\n          material = getLocalMaterial(colorCode)\n          v0 = lp.getVector()\n          v1 = lp.getVector()\n\n          segment = {\n            material: material,\n            colorCode: colorCode,\n            vertices: [v0, v1],\n          }\n\n          lineSegments.push(segment)\n\n          break\n\n        // Line type 5: Conditional Line segment\n        case '5':\n          colorCode = lp.getToken()\n          material = getLocalMaterial(colorCode)\n          v0 = lp.getVector()\n          v1 = lp.getVector()\n          c0 = lp.getVector()\n          c1 = lp.getVector()\n\n          segment = {\n            material: material,\n            colorCode: colorCode,\n            vertices: [v0, v1],\n            controlPoints: [c0, c1],\n          }\n\n          conditionalSegments.push(segment)\n\n          break\n\n        // Line type 3: Triangle\n        case '3':\n          colorCode = lp.getToken()\n          material = getLocalMaterial(colorCode)\n          ccw = bfcCCW\n          doubleSided = !bfcCertified || !bfcCull\n\n          if (ccw === true) {\n            v0 = lp.getVector()\n            v1 = lp.getVector()\n            v2 = lp.getVector()\n          } else {\n            v2 = lp.getVector()\n            v1 = lp.getVector()\n            v0 = lp.getVector()\n          }\n\n          faces.push({\n            material: material,\n            colorCode: colorCode,\n            faceNormal: null,\n            vertices: [v0, v1, v2],\n            normals: [null, null, null],\n          })\n          totalFaces++\n\n          if (doubleSided === true) {\n            faces.push({\n              material: material,\n              colorCode: colorCode,\n              faceNormal: null,\n              vertices: [v2, v1, v0],\n              normals: [null, null, null],\n            })\n            totalFaces++\n          }\n\n          break\n\n        // Line type 4: Quadrilateral\n        case '4':\n          colorCode = lp.getToken()\n          material = getLocalMaterial(colorCode)\n          ccw = bfcCCW\n          doubleSided = !bfcCertified || !bfcCull\n\n          if (ccw === true) {\n            v0 = lp.getVector()\n            v1 = lp.getVector()\n            v2 = lp.getVector()\n            v3 = lp.getVector()\n          } else {\n            v3 = lp.getVector()\n            v2 = lp.getVector()\n            v1 = lp.getVector()\n            v0 = lp.getVector()\n          }\n\n          // specifically place the triangle diagonal in the v0 and v1 slots so we can\n          // account for the doubling of vertices later when smoothing normals.\n          faces.push({\n            material: material,\n            colorCode: colorCode,\n            faceNormal: null,\n            vertices: [v0, v1, v2, v3],\n            normals: [null, null, null, null],\n          })\n          totalFaces += 2\n\n          if (doubleSided === true) {\n            faces.push({\n              material: material,\n              colorCode: colorCode,\n              faceNormal: null,\n              vertices: [v3, v2, v1, v0],\n              normals: [null, null, null, null],\n            })\n            totalFaces += 2\n          }\n\n          break\n\n        default:\n          throw new Error('LDrawLoader: Unknown line type \"' + lineType + '\"' + lp.getLineNumberString() + '.')\n      }\n    }\n\n    if (parsingEmbeddedFiles) {\n      this.setData(currentEmbeddedFileName, currentEmbeddedText)\n    }\n\n    return {\n      faces,\n      conditionalSegments,\n      lineSegments,\n      type,\n      category,\n      keywords,\n      subobjects,\n      totalFaces,\n      startingConstructionStep,\n      materials,\n      fileName,\n      group: null,\n    }\n  }\n\n  // returns an (optionally cloned) instance of the data\n  getData(fileName, clone = true) {\n    const key = fileName.toLowerCase()\n    const result = this._cache[key]\n    if (result === null || result instanceof Promise) {\n      return null\n    }\n\n    if (clone) {\n      return this.cloneResult(result)\n    } else {\n      return result\n    }\n  }\n\n  // kicks off a fetch and parse of the requested data if it hasn't already been loaded. Returns when\n  // the data is ready to use and can be retrieved synchronously with \"getData\".\n  async ensureDataLoaded(fileName) {\n    const key = fileName.toLowerCase()\n    if (!(key in this._cache)) {\n      // replace the promise with a copy of the parsed data for immediate processing\n      this._cache[key] = this.fetchData(fileName).then((text) => {\n        const info = this.parse(text, fileName)\n        this._cache[key] = info\n        return info\n      })\n    }\n\n    await this._cache[key]\n  }\n\n  // sets the data in the cache from parsed data\n  setData(fileName, text) {\n    const key = fileName.toLowerCase()\n    this._cache[key] = this.parse(text, fileName)\n  }\n}\n\n// returns the material for an associated color code. If the color code is 16 for a face or 24 for\n// an edge then the passthroughColorCode is used.\nfunction getMaterialFromCode(colorCode, parentColorCode, materialHierarchy, forEdge) {\n  const isPassthrough = (!forEdge && colorCode === MAIN_COLOUR_CODE) || (forEdge && colorCode === MAIN_EDGE_COLOUR_CODE)\n  if (isPassthrough) {\n    colorCode = parentColorCode\n  }\n\n  return materialHierarchy[colorCode] || null\n}\n\n// Class used to parse and build LDraw parts as three.js objects and cache them if they're a \"Part\" type.\nclass LDrawPartsGeometryCache {\n  constructor(loader) {\n    this.loader = loader\n    this.parseCache = new LDrawParsedCache(loader)\n    this._cache = {}\n  }\n\n  // Convert the given file information into a mesh by processing subobjects.\n  async processIntoMesh(info) {\n    const loader = this.loader\n    const parseCache = this.parseCache\n    const faceMaterials = new Set()\n\n    // Processes the part subobject information to load child parts and merge geometry onto part\n    // piece object.\n    const processInfoSubobjects = async (info, subobject = null) => {\n      const subobjects = info.subobjects\n      const promises = []\n\n      // Trigger load of all subobjects. If a subobject isn't a primitive then load it as a separate\n      // group which lets instruction steps apply correctly.\n      for (let i = 0, l = subobjects.length; i < l; i++) {\n        const subobject = subobjects[i]\n        const promise = parseCache.ensureDataLoaded(subobject.fileName).then(() => {\n          const subobjectInfo = parseCache.getData(subobject.fileName, false)\n          if (!isPrimitiveType(subobjectInfo.type)) {\n            return this.loadModel(subobject.fileName).catch((error) => {\n              console.warn(error)\n              return null\n            })\n          }\n\n          return processInfoSubobjects(parseCache.getData(subobject.fileName), subobject)\n        })\n\n        promises.push(promise)\n      }\n\n      const group = new Group()\n      group.userData.category = info.category\n      group.userData.keywords = info.keywords\n      info.group = group\n\n      const subobjectInfos = await Promise.all(promises)\n      for (let i = 0, l = subobjectInfos.length; i < l; i++) {\n        const subobject = info.subobjects[i]\n        const subobjectInfo = subobjectInfos[i]\n\n        if (subobjectInfo === null) {\n          // the subobject failed to load\n          continue\n        }\n\n        // if the subobject was loaded as a separate group then apply the parent scopes materials\n        if (subobjectInfo.isGroup) {\n          const subobjectGroup = subobjectInfo\n          subobject.matrix.decompose(subobjectGroup.position, subobjectGroup.quaternion, subobjectGroup.scale)\n          subobjectGroup.userData.startingConstructionStep = subobject.startingConstructionStep\n          subobjectGroup.name = subobject.fileName\n\n          loader.applyMaterialsToMesh(subobjectGroup, subobject.colorCode, info.materials)\n\n          group.add(subobjectGroup)\n          continue\n        }\n\n        // add the subobject group if it has children in case it has both children and primitives\n        if (subobjectInfo.group.children.length) {\n          group.add(subobjectInfo.group)\n        }\n\n        // transform the primitives into the local space of the parent piece and append them to\n        // to the parent primitives list.\n        const parentLineSegments = info.lineSegments\n        const parentConditionalSegments = info.conditionalSegments\n        const parentFaces = info.faces\n\n        const lineSegments = subobjectInfo.lineSegments\n        const conditionalSegments = subobjectInfo.conditionalSegments\n\n        const faces = subobjectInfo.faces\n        const matrix = subobject.matrix\n        const inverted = subobject.inverted\n        const matrixScaleInverted = matrix.determinant() < 0\n        const colorCode = subobject.colorCode\n\n        const lineColorCode = colorCode === MAIN_COLOUR_CODE ? MAIN_EDGE_COLOUR_CODE : colorCode\n        for (let i = 0, l = lineSegments.length; i < l; i++) {\n          const ls = lineSegments[i]\n          const vertices = ls.vertices\n          vertices[0].applyMatrix4(matrix)\n          vertices[1].applyMatrix4(matrix)\n          ls.colorCode = ls.colorCode === MAIN_EDGE_COLOUR_CODE ? lineColorCode : ls.colorCode\n          ls.material = ls.material || getMaterialFromCode(ls.colorCode, ls.colorCode, info.materials, true)\n\n          parentLineSegments.push(ls)\n        }\n\n        for (let i = 0, l = conditionalSegments.length; i < l; i++) {\n          const os = conditionalSegments[i]\n          const vertices = os.vertices\n          const controlPoints = os.controlPoints\n          vertices[0].applyMatrix4(matrix)\n          vertices[1].applyMatrix4(matrix)\n          controlPoints[0].applyMatrix4(matrix)\n          controlPoints[1].applyMatrix4(matrix)\n          os.colorCode = os.colorCode === MAIN_EDGE_COLOUR_CODE ? lineColorCode : os.colorCode\n          os.material = os.material || getMaterialFromCode(os.colorCode, os.colorCode, info.materials, true)\n\n          parentConditionalSegments.push(os)\n        }\n\n        for (let i = 0, l = faces.length; i < l; i++) {\n          const tri = faces[i]\n          const vertices = tri.vertices\n          for (let i = 0, l = vertices.length; i < l; i++) {\n            vertices[i].applyMatrix4(matrix)\n          }\n\n          tri.colorCode = tri.colorCode === MAIN_COLOUR_CODE ? colorCode : tri.colorCode\n          tri.material = tri.material || getMaterialFromCode(tri.colorCode, colorCode, info.materials, false)\n          faceMaterials.add(tri.colorCode)\n\n          // If the scale of the object is negated then the triangle winding order\n          // needs to be flipped.\n          if (matrixScaleInverted !== inverted) {\n            vertices.reverse()\n          }\n\n          parentFaces.push(tri)\n        }\n\n        info.totalFaces += subobjectInfo.totalFaces\n      }\n\n      // Apply the parent subobjects pass through material code to this object. This is done several times due\n      // to material scoping.\n      if (subobject) {\n        loader.applyMaterialsToMesh(group, subobject.colorCode, info.materials)\n      }\n\n      return info\n    }\n\n    // Track material use to see if we need to use the normal smooth slow path for hard edges.\n    for (let i = 0, l = info.faces; i < l; i++) {\n      faceMaterials.add(info.faces[i].colorCode)\n    }\n\n    await processInfoSubobjects(info)\n\n    if (loader.smoothNormals) {\n      const checkSubSegments = faceMaterials.size > 1\n      generateFaceNormals(info.faces)\n      smoothNormals(info.faces, info.lineSegments, checkSubSegments)\n    }\n\n    // Add the primitive objects and metadata.\n    const group = info.group\n    if (info.faces.length > 0) {\n      group.add(createObject(info.faces, 3, false, info.totalFaces))\n    }\n\n    if (info.lineSegments.length > 0) {\n      group.add(createObject(info.lineSegments, 2))\n    }\n\n    if (info.conditionalSegments.length > 0) {\n      group.add(createObject(info.conditionalSegments, 2, true))\n    }\n\n    return group\n  }\n\n  hasCachedModel(fileName) {\n    return fileName !== null && fileName.toLowerCase() in this._cache\n  }\n\n  async getCachedModel(fileName) {\n    if (fileName !== null && this.hasCachedModel(fileName)) {\n      const key = fileName.toLowerCase()\n      const group = await this._cache[key]\n      return group.clone()\n    } else {\n      return null\n    }\n  }\n\n  // Loads and parses the model with the given file name. Returns a cached copy if available.\n  async loadModel(fileName) {\n    const parseCache = this.parseCache\n    const key = fileName.toLowerCase()\n    if (this.hasCachedModel(fileName)) {\n      // Return cached model if available.\n      return this.getCachedModel(fileName)\n    } else {\n      // Otherwise parse a new model.\n      // Ensure the file data is loaded and pre parsed.\n      await parseCache.ensureDataLoaded(fileName)\n\n      const info = parseCache.getData(fileName)\n      const promise = this.processIntoMesh(info)\n\n      // Now that the file has loaded it's possible that another part parse has been waiting in parallel\n      // so check the cache again to see if it's been added since the last async operation so we don't\n      // do unnecessary work.\n      if (this.hasCachedModel(fileName)) {\n        return this.getCachedModel(fileName)\n      }\n\n      // Cache object if it's a part so it can be reused later.\n      if (isPartType(info.type)) {\n        this._cache[key] = promise\n      }\n\n      // return a copy\n      const group = await promise\n      return group.clone()\n    }\n  }\n\n  // parses the given model text into a renderable object. Returns cached copy if available.\n  async parseModel(text) {\n    const parseCache = this.parseCache\n    const info = parseCache.parse(text)\n    if (isPartType(info.type) && this.hasCachedModel(info.fileName)) {\n      return this.getCachedModel(info.fileName)\n    }\n\n    return this.processIntoMesh(info)\n  }\n}\n\nfunction sortByMaterial(a, b) {\n  if (a.colorCode === b.colorCode) {\n    return 0\n  }\n\n  if (a.colorCode < b.colorCode) {\n    return -1\n  }\n\n  return 1\n}\n\nfunction createObject(elements, elementSize, isConditionalSegments = false, totalElements = null) {\n  // Creates a LineSegments (elementSize = 2) or a Mesh (elementSize = 3 )\n  // With per face / segment material, implemented with mesh groups and materials array\n\n  // Sort the faces or line segments by color code to make later the mesh groups\n  elements.sort(sortByMaterial)\n\n  if (totalElements === null) {\n    totalElements = elements.length\n  }\n\n  const positions = new Float32Array(elementSize * totalElements * 3)\n  const normals = elementSize === 3 ? new Float32Array(elementSize * totalElements * 3) : null\n  const materials = []\n\n  const quadArray = new Array(6)\n  const bufferGeometry = new BufferGeometry()\n  let prevMaterial = null\n  let index0 = 0\n  let numGroupVerts = 0\n  let offset = 0\n\n  for (let iElem = 0, nElem = elements.length; iElem < nElem; iElem++) {\n    const elem = elements[iElem]\n    let vertices = elem.vertices\n    if (vertices.length === 4) {\n      quadArray[0] = vertices[0]\n      quadArray[1] = vertices[1]\n      quadArray[2] = vertices[2]\n      quadArray[3] = vertices[0]\n      quadArray[4] = vertices[2]\n      quadArray[5] = vertices[3]\n      vertices = quadArray\n    }\n\n    for (let j = 0, l = vertices.length; j < l; j++) {\n      const v = vertices[j]\n      const index = offset + j * 3\n      positions[index + 0] = v.x\n      positions[index + 1] = v.y\n      positions[index + 2] = v.z\n    }\n\n    // create the normals array if this is a set of faces\n    if (elementSize === 3) {\n      if (!elem.faceNormal) {\n        const v0 = vertices[0]\n        const v1 = vertices[1]\n        const v2 = vertices[2]\n        _tempVec0.subVectors(v1, v0)\n        _tempVec1.subVectors(v2, v1)\n        elem.faceNormal = new Vector3().crossVectors(_tempVec0, _tempVec1).normalize()\n      }\n\n      let elemNormals = elem.normals\n      if (elemNormals.length === 4) {\n        quadArray[0] = elemNormals[0]\n        quadArray[1] = elemNormals[1]\n        quadArray[2] = elemNormals[2]\n        quadArray[3] = elemNormals[0]\n        quadArray[4] = elemNormals[2]\n        quadArray[5] = elemNormals[3]\n        elemNormals = quadArray\n      }\n\n      for (let j = 0, l = elemNormals.length; j < l; j++) {\n        // use face normal if a vertex normal is not provided\n        let n = elem.faceNormal\n        if (elemNormals[j]) {\n          n = elemNormals[j].norm\n        }\n\n        const index = offset + j * 3\n        normals[index + 0] = n.x\n        normals[index + 1] = n.y\n        normals[index + 2] = n.z\n      }\n    }\n\n    if (prevMaterial !== elem.colorCode) {\n      if (prevMaterial !== null) {\n        bufferGeometry.addGroup(index0, numGroupVerts, materials.length - 1)\n      }\n\n      const material = elem.material\n      if (material !== null) {\n        if (elementSize === 3) {\n          materials.push(material)\n        } else if (elementSize === 2) {\n          if (material !== null) {\n            if (isConditionalSegments) {\n              materials.push(material.userData.edgeMaterial.userData.conditionalEdgeMaterial)\n            } else {\n              materials.push(material.userData.edgeMaterial)\n            }\n          } else {\n            materials.push(null)\n          }\n        }\n      } else {\n        // If a material has not been made available yet then keep the color code string in the material array\n        // to save the spot for the material once a parent scopes materials are being applied to the object.\n        materials.push(elem.colorCode)\n      }\n\n      prevMaterial = elem.colorCode\n      index0 = offset / 3\n      numGroupVerts = vertices.length\n    } else {\n      numGroupVerts += vertices.length\n    }\n\n    offset += 3 * vertices.length\n  }\n\n  if (numGroupVerts > 0) {\n    bufferGeometry.addGroup(index0, Infinity, materials.length - 1)\n  }\n\n  bufferGeometry.setAttribute('position', new BufferAttribute(positions, 3))\n\n  if (normals !== null) {\n    bufferGeometry.setAttribute('normal', new BufferAttribute(normals, 3))\n  }\n\n  let object3d = null\n\n  if (elementSize === 2) {\n    if (isConditionalSegments) {\n      object3d = new ConditionalLineSegments(bufferGeometry, materials.length === 1 ? materials[0] : materials)\n    } else {\n      object3d = new LineSegments(bufferGeometry, materials.length === 1 ? materials[0] : materials)\n    }\n  } else if (elementSize === 3) {\n    object3d = new Mesh(bufferGeometry, materials.length === 1 ? materials[0] : materials)\n  }\n\n  if (isConditionalSegments) {\n    object3d.isConditionalLine = true\n\n    const controlArray0 = new Float32Array(elements.length * 3 * 2)\n    const controlArray1 = new Float32Array(elements.length * 3 * 2)\n    const directionArray = new Float32Array(elements.length * 3 * 2)\n    for (let i = 0, l = elements.length; i < l; i++) {\n      const os = elements[i]\n      const vertices = os.vertices\n      const controlPoints = os.controlPoints\n      const c0 = controlPoints[0]\n      const c1 = controlPoints[1]\n      const v0 = vertices[0]\n      const v1 = vertices[1]\n      const index = i * 3 * 2\n      controlArray0[index + 0] = c0.x\n      controlArray0[index + 1] = c0.y\n      controlArray0[index + 2] = c0.z\n      controlArray0[index + 3] = c0.x\n      controlArray0[index + 4] = c0.y\n      controlArray0[index + 5] = c0.z\n\n      controlArray1[index + 0] = c1.x\n      controlArray1[index + 1] = c1.y\n      controlArray1[index + 2] = c1.z\n      controlArray1[index + 3] = c1.x\n      controlArray1[index + 4] = c1.y\n      controlArray1[index + 5] = c1.z\n\n      directionArray[index + 0] = v1.x - v0.x\n      directionArray[index + 1] = v1.y - v0.y\n      directionArray[index + 2] = v1.z - v0.z\n      directionArray[index + 3] = v1.x - v0.x\n      directionArray[index + 4] = v1.y - v0.y\n      directionArray[index + 5] = v1.z - v0.z\n    }\n\n    bufferGeometry.setAttribute('control0', new BufferAttribute(controlArray0, 3, false))\n    bufferGeometry.setAttribute('control1', new BufferAttribute(controlArray1, 3, false))\n    bufferGeometry.setAttribute('direction', new BufferAttribute(directionArray, 3, false))\n  }\n\n  return object3d\n}\n\n//\n\nclass LDrawLoader extends Loader {\n  constructor(manager) {\n    super(manager)\n\n    // Array of THREE.Material\n    this.materials = []\n    this.materialLibrary = {}\n\n    // This also allows to handle the embedded text files (\"0 FILE\" lines)\n    this.partsCache = new LDrawPartsGeometryCache(this)\n\n    // This object is a map from file names to paths. It agilizes the paths search. If it is not set then files will be searched by trial and error.\n    this.fileMap = {}\n\n    // Initializes the materials library with default materials\n    this.setMaterials([])\n\n    // If this flag is set to true the vertex normals will be smoothed.\n    this.smoothNormals = true\n\n    // The path to load parts from the LDraw parts library from.\n    this.partsLibraryPath = ''\n  }\n\n  setPartsLibraryPath(path) {\n    this.partsLibraryPath = path\n    return this\n  }\n\n  async preloadMaterials(url) {\n    const fileLoader = new FileLoader(this.manager)\n    fileLoader.setPath(this.path)\n    fileLoader.setRequestHeader(this.requestHeader)\n    fileLoader.setWithCredentials(this.withCredentials)\n\n    const text = await fileLoader.loadAsync(url)\n    const colorLineRegex = /^0 !COLOUR/\n    const lines = text.split(/[\\n\\r]/g)\n    const materials = []\n    for (let i = 0, l = lines.length; i < l; i++) {\n      const line = lines[i]\n      if (colorLineRegex.test(line)) {\n        const directive = line.replace(colorLineRegex, '')\n        const material = this.parseColorMetaDirective(new LineParser(directive))\n        materials.push(material)\n      }\n    }\n\n    this.setMaterials(materials)\n  }\n\n  load(url, onLoad, onProgress, onError) {\n    const fileLoader = new FileLoader(this.manager)\n    fileLoader.setPath(this.path)\n    fileLoader.setRequestHeader(this.requestHeader)\n    fileLoader.setWithCredentials(this.withCredentials)\n    fileLoader.load(\n      url,\n      (text) => {\n        this.partsCache\n          .parseModel(text, this.materialLibrary)\n          .then((group) => {\n            this.applyMaterialsToMesh(group, MAIN_COLOUR_CODE, this.materialLibrary, true)\n            this.computeConstructionSteps(group)\n            onLoad(group)\n          })\n          .catch(onError)\n      },\n      onProgress,\n      onError,\n    )\n  }\n\n  parse(text, onLoad) {\n    this.partsCache.parseModel(text, this.materialLibrary).then((group) => {\n      this.computeConstructionSteps(group)\n      onLoad(group)\n    })\n  }\n\n  setMaterials(materials) {\n    this.materialLibrary = {}\n    this.materials = []\n    for (let i = 0, l = materials.length; i < l; i++) {\n      this.addMaterial(materials[i])\n    }\n\n    // Add default main triangle and line edge materials (used in pieces that can be colored with a main color)\n    this.addMaterial(this.parseColorMetaDirective(new LineParser('Main_Colour CODE 16 VALUE #FF8080 EDGE #333333')))\n    this.addMaterial(this.parseColorMetaDirective(new LineParser('Edge_Colour CODE 24 VALUE #A0A0A0 EDGE #333333')))\n\n    return this\n  }\n\n  setFileMap(fileMap) {\n    this.fileMap = fileMap\n\n    return this\n  }\n\n  addMaterial(material) {\n    // Adds a material to the material library which is on top of the parse scopes stack. And also to the materials array\n\n    const matLib = this.materialLibrary\n    if (!matLib[material.userData.code]) {\n      this.materials.push(material)\n      matLib[material.userData.code] = material\n    }\n\n    return this\n  }\n\n  getMaterial(colorCode) {\n    if (colorCode.startsWith('0x2')) {\n      // Special 'direct' material value (RGB color)\n      const color = colorCode.substring(3)\n\n      return this.parseColorMetaDirective(\n        new LineParser('Direct_Color_' + color + ' CODE -1 VALUE #' + color + ' EDGE #' + color + ''),\n      )\n    }\n\n    return this.materialLibrary[colorCode] || null\n  }\n\n  // Applies the appropriate materials to a prebuilt hierarchy of geometry. Assumes that color codes are present\n  // in the material array if they need to be filled in.\n  applyMaterialsToMesh(group, parentColorCode, materialHierarchy, finalMaterialPass = false) {\n    // find any missing materials as indicated by a color code string and replace it with a material from the current material lib\n    const loader = this\n    const parentIsPassthrough = parentColorCode === MAIN_COLOUR_CODE\n    group.traverse((c) => {\n      if (c.isMesh || c.isLineSegments) {\n        if (Array.isArray(c.material)) {\n          for (let i = 0, l = c.material.length; i < l; i++) {\n            if (!c.material[i].isMaterial) {\n              c.material[i] = getMaterial(c, c.material[i])\n            }\n          }\n        } else if (!c.material.isMaterial) {\n          c.material = getMaterial(c, c.material)\n        }\n      }\n    })\n\n    // Returns the appropriate material for the object (line or face) given color code. If the code is \"pass through\"\n    // (24 for lines, 16 for edges) then the pass through color code is used. If that is also pass through then it's\n    // simply returned for the subsequent material application.\n    function getMaterial(c, colorCode) {\n      // if our parent is a passthrough color code and we don't have the current material color available then\n      // return early.\n      if (parentIsPassthrough && !(colorCode in materialHierarchy) && !finalMaterialPass) {\n        return colorCode\n      }\n\n      const forEdge = c.isLineSegments || c.isConditionalLine\n      const isPassthrough =\n        (!forEdge && colorCode === MAIN_COLOUR_CODE) || (forEdge && colorCode === MAIN_EDGE_COLOUR_CODE)\n      if (isPassthrough) {\n        colorCode = parentColorCode\n      }\n\n      let material = null\n      if (colorCode in materialHierarchy) {\n        material = materialHierarchy[colorCode]\n      } else if (finalMaterialPass) {\n        // see if we can get the final material from from the \"getMaterial\" function which will attempt to\n        // parse the \"direct\" colors\n        material = loader.getMaterial(colorCode)\n        if (material === null) {\n          // otherwise throw an error if this is final opportunity to set the material\n          throw new Error(`LDrawLoader: Material properties for code ${colorCode} not available.`)\n        }\n      } else {\n        return colorCode\n      }\n\n      if (c.isLineSegments) {\n        material = material.userData.edgeMaterial\n\n        if (c.isConditionalLine) {\n          material = material.userData.conditionalEdgeMaterial\n        }\n      }\n\n      return material\n    }\n  }\n\n  getMainMaterial() {\n    return this.getMaterial(MAIN_COLOUR_CODE)\n  }\n\n  getMainEdgeMaterial() {\n    return this.getMaterial(MAIN_EDGE_COLOUR_CODE)\n  }\n\n  parseColorMetaDirective(lineParser) {\n    // Parses a color definition and returns a THREE.Material\n\n    let code = null\n\n    // Triangle and line colors\n    let color = 0xff00ff\n    let edgeColor = 0xff00ff\n\n    // Transparency\n    let alpha = 1\n    let isTransparent = false\n    // Self-illumination:\n    let luminance = 0\n\n    let finishType = FINISH_TYPE_DEFAULT\n\n    let edgeMaterial = null\n\n    const name = lineParser.getToken()\n    if (!name) {\n      throw new Error(\n        'LDrawLoader: Material name was expected after \"!COLOUR tag' + lineParser.getLineNumberString() + '.',\n      )\n    }\n\n    // Parse tag tokens and their parameters\n    let token = null\n    while (true) {\n      token = lineParser.getToken()\n\n      if (!token) {\n        break\n      }\n\n      switch (token.toUpperCase()) {\n        case 'CODE':\n          code = lineParser.getToken()\n          break\n\n        case 'VALUE':\n          color = lineParser.getToken()\n          if (color.startsWith('0x')) {\n            color = '#' + color.substring(2)\n          } else if (!color.startsWith('#')) {\n            throw new Error(\n              'LDrawLoader: Invalid color while parsing material' + lineParser.getLineNumberString() + '.',\n            )\n          }\n\n          break\n\n        case 'EDGE':\n          edgeColor = lineParser.getToken()\n          if (edgeColor.startsWith('0x')) {\n            edgeColor = '#' + edgeColor.substring(2)\n          } else if (!edgeColor.startsWith('#')) {\n            // Try to see if edge color is a color code\n            edgeMaterial = this.getMaterial(edgeColor)\n            if (!edgeMaterial) {\n              throw new Error(\n                'LDrawLoader: Invalid edge color while parsing material' + lineParser.getLineNumberString() + '.',\n              )\n            }\n\n            // Get the edge material for this triangle material\n            edgeMaterial = edgeMaterial.userData.edgeMaterial\n          }\n\n          break\n\n        case 'ALPHA':\n          alpha = parseInt(lineParser.getToken())\n\n          if (isNaN(alpha)) {\n            throw new Error(\n              'LDrawLoader: Invalid alpha value in material definition' + lineParser.getLineNumberString() + '.',\n            )\n          }\n\n          alpha = Math.max(0, Math.min(1, alpha / 255))\n\n          if (alpha < 1) {\n            isTransparent = true\n          }\n\n          break\n\n        case 'LUMINANCE':\n          luminance = parseInt(lineParser.getToken())\n\n          if (isNaN(luminance)) {\n            throw new Error(\n              'LDrawLoader: Invalid luminance value in material definition' + LineParser.getLineNumberString() + '.',\n            )\n          }\n\n          luminance = Math.max(0, Math.min(1, luminance / 255))\n\n          break\n\n        case 'CHROME':\n          finishType = FINISH_TYPE_CHROME\n          break\n\n        case 'PEARLESCENT':\n          finishType = FINISH_TYPE_PEARLESCENT\n          break\n\n        case 'RUBBER':\n          finishType = FINISH_TYPE_RUBBER\n          break\n\n        case 'MATTE_METALLIC':\n          finishType = FINISH_TYPE_MATTE_METALLIC\n          break\n\n        case 'METAL':\n          finishType = FINISH_TYPE_METAL\n          break\n\n        case 'MATERIAL':\n          // Not implemented\n          lineParser.setToEnd()\n          break\n\n        default:\n          throw new Error(\n            'LDrawLoader: Unknown token \"' +\n              token +\n              '\" while parsing material' +\n              lineParser.getLineNumberString() +\n              '.',\n          )\n      }\n    }\n\n    let material = null\n\n    switch (finishType) {\n      case FINISH_TYPE_DEFAULT:\n        material = new MeshStandardMaterial({ color: color, roughness: 0.3, metalness: 0 })\n        break\n\n      case FINISH_TYPE_PEARLESCENT:\n        // Try to imitate pearlescency by making the surface glossy\n        material = new MeshStandardMaterial({ color: color, roughness: 0.3, metalness: 0.25 })\n        break\n\n      case FINISH_TYPE_CHROME:\n        // Mirror finish surface\n        material = new MeshStandardMaterial({ color: color, roughness: 0, metalness: 1 })\n        break\n\n      case FINISH_TYPE_RUBBER:\n        // Rubber finish\n        material = new MeshStandardMaterial({ color: color, roughness: 0.9, metalness: 0 })\n        break\n\n      case FINISH_TYPE_MATTE_METALLIC:\n        // Brushed metal finish\n        material = new MeshStandardMaterial({ color: color, roughness: 0.8, metalness: 0.4 })\n        break\n\n      case FINISH_TYPE_METAL:\n        // Average metal finish\n        material = new MeshStandardMaterial({ color: color, roughness: 0.2, metalness: 0.85 })\n        break\n\n      default:\n        // Should not happen\n        break\n    }\n\n    material.transparent = isTransparent\n    material.premultipliedAlpha = true\n    material.opacity = alpha\n    material.depthWrite = !isTransparent\n\n    material.polygonOffset = true\n    material.polygonOffsetFactor = 1\n\n    if (luminance !== 0) {\n      material.emissive.set(material.color).multiplyScalar(luminance)\n    }\n\n    if (!edgeMaterial) {\n      // This is the material used for edges\n      edgeMaterial = new LineBasicMaterial({\n        color: edgeColor,\n        transparent: isTransparent,\n        opacity: alpha,\n        depthWrite: !isTransparent,\n      })\n      edgeMaterial.userData.code = code\n      edgeMaterial.name = name + ' - Edge'\n\n      // This is the material used for conditional edges\n      edgeMaterial.userData.conditionalEdgeMaterial = new LDrawConditionalLineMaterial({\n        fog: true,\n        transparent: isTransparent,\n        depthWrite: !isTransparent,\n        color: edgeColor,\n        opacity: alpha,\n      })\n    }\n\n    material.userData.code = code\n    material.name = name\n\n    material.userData.edgeMaterial = edgeMaterial\n\n    this.addMaterial(material)\n\n    return material\n  }\n\n  computeConstructionSteps(model) {\n    // Sets userdata.constructionStep number in Group objects and userData.numConstructionSteps number in the root Group object.\n\n    let stepNumber = 0\n\n    model.traverse((c) => {\n      if (c.isGroup) {\n        if (c.userData.startingConstructionStep) {\n          stepNumber++\n        }\n\n        c.userData.constructionStep = stepNumber\n      }\n    })\n\n    model.userData.numConstructionSteps = stepNumber + 1\n  }\n}\n\nexport { LDrawLoader }\n"],"mappings":";;;;;;;;AAsBA,IAAMA,mBAAA,GAAsB;AAC5B,IAAMC,kBAAA,GAAqB;AAC3B,IAAMC,uBAAA,GAA0B;AAChC,IAAMC,kBAAA,GAAqB;AAC3B,IAAMC,0BAAA,GAA6B;AACnC,IAAMC,iBAAA,GAAoB;AAI1B,IAAMC,mBAAA,GAAsB;AAC5B,IAAMC,uBAAA,GAA0B;AAChC,IAAMC,mBAAA,GAAsB;AAC5B,IAAMC,wBAAA,GAA2B;AACjC,IAAMC,0BAAA,GAA6B;AACnC,IAAMC,0BAAA,GAA6B;AACnC,IAAMC,uBAAA,GAA0B;AAEhC,IAAMC,gBAAA,GAAmB;AACzB,IAAMC,qBAAA,GAAwB;AAE9B,IAAMC,SAAA,GAAY,IAAIC,OAAA,CAAS;AAC/B,IAAMC,SAAA,GAAY,IAAID,OAAA,CAAS;AAAA,IAEzBE,4BAAA,0BAAAC,eAAA;EAAAC,SAAA,CAAAF,4BAAA,EAAAC,eAAA;EAAA,IAAAE,MAAA,GAAAC,YAAA,CAAAJ,4BAAA;EACJ,SAAAA,6BAAYK,UAAA,EAAY;IAAA,IAAAC,KAAA;IAAAC,eAAA,OAAAP,4BAAA;IACtBM,KAAA,GAAAH,MAAA,CAAAK,IAAA,OAAM;MACJC,QAAA,EAAUC,aAAA,CAAcC,KAAA,CAAM,CAC5BC,WAAA,CAAYC,GAAA,EACZ;QACEC,OAAA,EAAS;UACPC,KAAA,EAAO,IAAIC,KAAA,CAAO;QACnB;QACDC,OAAA,EAAS;UACPF,KAAA,EAAO;QACR;MACF,EACF;MAEDG,YAAA,0yDAAyB;MAiDzBC,cAAA,kyBAAAC,MAAA,CAsBgBC,QAAA,CAASC,QAAA,CAASC,OAAA,CAAQ,QAAQ,EAAE,CAAC,KAAK,MAAM,wBAAwB;IAK9F,CAAK;IAEDC,MAAA,CAAOC,gBAAA,CAAAC,sBAAA,CAAApB,KAAA,GAAuB;MAC5BW,OAAA,EAAS;QACPU,GAAA,EAAK,SAAAA,IAAA,EAAY;UACf,OAAO,KAAKlB,QAAA,CAASQ,OAAA,CAAQF,KAAA;QAC9B;QAEDa,GAAA,EAAK,SAAAA,IAAUb,KAAA,EAAO;UACpB,KAAKN,QAAA,CAASQ,OAAA,CAAQF,KAAA,GAAQA,KAAA;QAC/B;MACF;MAEDc,KAAA,EAAO;QACLF,GAAA,EAAK,SAAAA,IAAA,EAAY;UACf,OAAO,KAAKlB,QAAA,CAASK,OAAA,CAAQC,KAAA;QAC9B;MACF;IACP,CAAK;IAEDT,KAAA,CAAKwB,SAAA,CAAUzB,UAAU;IACzBC,KAAA,CAAKyB,8BAAA,GAAiC;IAAA,OAAAzB,KAAA;EACvC;EAAA,OAAA0B,YAAA,CAAAhC,4BAAA;AAAA,EAjHwCiC,cAAA;AAAA,IAoHrCC,uBAAA,0BAAAC,aAAA;EAAAjC,SAAA,CAAAgC,uBAAA,EAAAC,aAAA;EAAA,IAAAC,OAAA,GAAAhC,YAAA,CAAA8B,uBAAA;EACJ,SAAAA,wBAAYG,QAAA,EAAUC,QAAA,EAAU;IAAA,IAAAC,MAAA;IAAAhC,eAAA,OAAA2B,uBAAA;IAC9BK,MAAA,GAAAH,OAAA,CAAA5B,IAAA,OAAM6B,QAAA,EAAUC,QAAQ;IACxBC,MAAA,CAAKC,iBAAA,GAAoB;IAAA,OAAAD,MAAA;EAC1B;EAAA,OAAAP,YAAA,CAAAE,uBAAA;AAAA,EAJmCO,YAAA;AAOtC,SAASC,oBAAoBC,KAAA,EAAO;EAClC,SAASC,CAAA,GAAI,GAAGC,CAAA,GAAIF,KAAA,CAAMG,MAAA,EAAQF,CAAA,GAAIC,CAAA,EAAGD,CAAA,IAAK;IAC5C,IAAMG,IAAA,GAAOJ,KAAA,CAAMC,CAAC;IACpB,IAAMI,QAAA,GAAWD,IAAA,CAAKC,QAAA;IACtB,IAAMC,EAAA,GAAKD,QAAA,CAAS,CAAC;IACrB,IAAME,EAAA,GAAKF,QAAA,CAAS,CAAC;IACrB,IAAMG,EAAA,GAAKH,QAAA,CAAS,CAAC;IAErBnD,SAAA,CAAUuD,UAAA,CAAWF,EAAA,EAAID,EAAE;IAC3BlD,SAAA,CAAUqD,UAAA,CAAWD,EAAA,EAAID,EAAE;IAC3BH,IAAA,CAAKM,UAAA,GAAa,IAAIvD,OAAA,CAAS,EAACwD,YAAA,CAAazD,SAAA,EAAWE,SAAS,EAAEwD,SAAA,CAAW;EAC/E;AACH;AAEA,IAAMC,IAAA,GAAO,IAAIC,GAAA,CAAK;AACtB,SAASC,cAAcf,KAAA,EAAOgB,YAAA,EAAwC;EAAA,IAA1BC,gBAAA,GAAAC,SAAA,CAAAf,MAAA,QAAAe,SAAA,QAAAC,SAAA,GAAAD,SAAA,MAAmB;EAU7D,IAAME,cAAA,IAAkB,IAAI,SAAS;EACrC,SAASC,WAAWC,CAAA,EAAG;IACrB,IAAMC,CAAA,GAAI,CAAC,EAAED,CAAA,CAAEC,CAAA,GAAIH,cAAA;IACnB,IAAMI,CAAA,GAAI,CAAC,EAAEF,CAAA,CAAEE,CAAA,GAAIJ,cAAA;IACnB,IAAMK,CAAA,GAAI,CAAC,EAAEH,CAAA,CAAEG,CAAA,GAAIL,cAAA;IAEnB,UAAA3C,MAAA,CAAU8C,CAAA,OAAA9C,MAAA,CAAK+C,CAAA,OAAA/C,MAAA,CAAKgD,CAAA;EACrB;EAED,SAASC,SAASpB,EAAA,EAAIC,EAAA,EAAI;IACxB,UAAA9B,MAAA,CAAU4C,UAAA,CAAWf,EAAE,QAAA7B,MAAA,CAAK4C,UAAA,CAAWd,EAAE;EAC1C;EAID,SAASoB,gBAAgBrB,EAAA,EAAIC,EAAA,EAAIqB,SAAA,EAAW;IAC1CA,SAAA,CAAUC,SAAA,CAAUpB,UAAA,CAAWF,EAAA,EAAID,EAAE,EAAEM,SAAA,CAAW;IAElD,IAAMkB,MAAA,GAASxB,EAAA,CAAGyB,GAAA,CAAIH,SAAA,CAAUC,SAAS;IACzCD,SAAA,CAAUI,MAAA,CAAOC,IAAA,CAAK3B,EAAE,EAAE4B,eAAA,CAAgBN,SAAA,CAAUC,SAAA,EAAW,CAACC,MAAM;IAEtE,OAAOF,SAAA;EACR;EAED,SAASO,QAAQC,GAAA,EAAK;IACpB,OAAOV,QAAA,CAASU,GAAA,CAAIJ,MAAA,EAAQI,GAAA,CAAIP,SAAS;EAC1C;EAED,IAAMQ,SAAA,GAAY,mBAAIC,GAAA,CAAK;EAC3B,IAAMC,YAAA,GAAe,mBAAIC,GAAA,CAAK;EAC9B,IAAMC,YAAA,GAAe,CAAE;EACvB,IAAMC,OAAA,GAAU,EAAE;EAGlB,SAASzC,CAAA,GAAI,GAAGC,CAAA,GAAIc,YAAA,CAAab,MAAA,EAAQF,CAAA,GAAIC,CAAA,EAAGD,CAAA,IAAK;IACnD,IAAM0C,EAAA,GAAK3B,YAAA,CAAaf,CAAC;IACzB,IAAMI,QAAA,GAAWsC,EAAA,CAAGtC,QAAA;IACpB,IAAMC,EAAA,GAAKD,QAAA,CAAS,CAAC;IACrB,IAAME,EAAA,GAAKF,QAAA,CAAS,CAAC;IACrBgC,SAAA,CAAUO,GAAA,CAAIlB,QAAA,CAASpB,EAAA,EAAIC,EAAE,CAAC;IAC9B8B,SAAA,CAAUO,GAAA,CAAIlB,QAAA,CAASnB,EAAA,EAAID,EAAE,CAAC;IAI9B,IAAIW,gBAAA,EAAkB;MAEpB,IAAMmB,GAAA,GAAMT,eAAA,CAAgBrB,EAAA,EAAIC,EAAA,EAAI,IAAIO,GAAA,CAAG,CAAE;MAC7C,IAAM+B,GAAA,GAAMV,OAAA,CAAQC,GAAG;MACvB,IAAI,CAACG,YAAA,CAAaO,GAAA,CAAID,GAAG,GAAG;QAC1BlB,eAAA,CAAgBpB,EAAA,EAAID,EAAA,EAAI8B,GAAG;QAC3B,IAAMW,GAAA,GAAMZ,OAAA,CAAQC,GAAG;QAEvB,IAAMY,KAAA,GAAO;UACXZ,GAAA,EAAAA,GAAA;UACAa,SAAA,EAAW;QACZ;QAEDV,YAAA,CAAatD,GAAA,CAAI4D,GAAA,EAAKG,KAAI;QAC1BT,YAAA,CAAatD,GAAA,CAAI8D,GAAA,EAAKC,KAAI;MAC3B;MAID,IAAME,IAAA,GAAOX,YAAA,CAAavD,GAAA,CAAI6D,GAAG;MACjC,IAAIM,EAAA,GAAKD,IAAA,CAAKd,GAAA,CAAIP,SAAA,CAAUE,GAAA,CAAIzB,EAAE;MAClC,IAAI8C,EAAA,GAAKF,IAAA,CAAKd,GAAA,CAAIP,SAAA,CAAUE,GAAA,CAAIxB,EAAE;MAClC,IAAI4C,EAAA,GAAKC,EAAA,EAAI;QAAA,IAAAC,IAAA,GACC,CAACD,EAAA,EAAID,EAAE;QAAjBA,EAAA,GAAAE,IAAA;QAAID,EAAE,GAAAC,IAAA;MACT;MAEDH,IAAA,CAAKD,SAAA,CAAUK,IAAA,CAAKH,EAAA,EAAIC,EAAE;IAC3B;EACF;EAGD,SAASnD,EAAA,GAAI,GAAGC,EAAA,GAAIF,KAAA,CAAMG,MAAA,EAAQF,EAAA,GAAIC,EAAA,EAAGD,EAAA,IAAK;IAC5C,IAAMsD,GAAA,GAAMvD,KAAA,CAAMC,EAAC;IACnB,IAAMI,SAAA,GAAWkD,GAAA,CAAIlD,QAAA;IACrB,IAAMmD,SAAA,GAAYnD,SAAA,CAASF,MAAA;IAC3B,SAASsD,EAAA,GAAK,GAAGA,EAAA,GAAKD,SAAA,EAAWC,EAAA,IAAM;MACrC,IAAMC,KAAA,GAAQD,EAAA;MACd,IAAME,IAAA,IAAQF,EAAA,GAAK,KAAKD,SAAA;MACxB,IAAMlD,EAAA,GAAKD,SAAA,CAASqD,KAAK;MACzB,IAAMnD,GAAA,GAAKF,SAAA,CAASsD,IAAI;MACxB,IAAMC,IAAA,GAAOlC,QAAA,CAASpB,EAAA,EAAIC,GAAE;MAG5B,IAAI8B,SAAA,CAAUS,GAAA,CAAIc,IAAI,GAAG;QACvB;MACD;MAGD,IAAI3C,gBAAA,EAAkB;QACpBU,eAAA,CAAgBrB,EAAA,EAAIC,GAAA,EAAIM,IAAI;QAE5B,IAAMgD,OAAA,GAAU1B,OAAA,CAAQtB,IAAI;QAC5B,IAAI0B,YAAA,CAAaO,GAAA,CAAIe,OAAO,GAAG;UAC7B,IAAMb,KAAA,GAAOT,YAAA,CAAavD,GAAA,CAAI6E,OAAO;UACrC,IAAQzB,KAAA,GAAmBY,KAAA,CAAnBZ,GAAA;YAAKa,SAAA,GAAcD,KAAA,CAAdC,SAAA;UACb,IAAIE,EAAA,GAAKf,KAAA,CAAIP,SAAA,CAAUE,GAAA,CAAIzB,EAAE;UAC7B,IAAI8C,GAAA,GAAKhB,KAAA,CAAIP,SAAA,CAAUE,GAAA,CAAIxB,GAAE;UAE7B,IAAI4C,EAAA,GAAKC,GAAA,EAAI;YAAA,IAAAU,KAAA,GACC,CAACV,GAAA,EAAID,EAAE;YAAjBA,EAAA,GAAAW,KAAA;YAAIV,GAAE,GAAAU,KAAA;UACT;UAGD,IAAIC,KAAA,GAAQ;UACZ,SAASC,EAAA,GAAI,GAAGC,EAAA,GAAIhB,SAAA,CAAU9C,MAAA,EAAQ6D,EAAA,GAAIC,EAAA,EAAGD,EAAA,IAAK,GAAG;YACnD,IAAIb,EAAA,IAAMF,SAAA,CAAUe,EAAC,KAAKZ,GAAA,IAAMH,SAAA,CAAUe,EAAA,GAAI,CAAC,GAAG;cAChDD,KAAA,GAAQ;cACR;YACD;UACF;UAED,IAAIA,KAAA,EAAO;YACT;UACD;QACF;MACF;MAED,IAAMb,MAAA,GAAO;QACXQ,KAAA,EAAAA,KAAA;QACAH,GAAA,EAAAA;MACD;MACDd,YAAA,CAAamB,IAAI,IAAIV,MAAA;IACtB;EACF;EAGD,OAAO,MAAM;IAEX,IAAIgB,QAAA,GAAW;IACf,SAAWC,GAAA,IAAO1B,YAAA,EAAc;MAC9ByB,QAAA,GAAWzB,YAAA,CAAa0B,GAAG;MAC3B;IACD;IAED,IAAID,QAAA,KAAa,MAAM;MACrB;IACD;IAGD,IAAME,KAAA,GAAQ,CAACF,QAAQ;IACvB,OAAOE,KAAA,CAAMjE,MAAA,GAAS,GAAG;MAEvB,IAAMoD,IAAA,GAAMa,KAAA,CAAMC,GAAA,CAAG,EAAGd,GAAA;MACxB,IAAMlD,UAAA,GAAWkD,IAAA,CAAIlD,QAAA;MACrB,IAAMiE,WAAA,GAAcf,IAAA,CAAIb,OAAA;MACxB,IAAMhC,UAAA,GAAa6C,IAAA,CAAI7C,UAAA;MAGvB,IAAM8C,UAAA,GAAYnD,UAAA,CAASF,MAAA;MAC3B,SAASsD,GAAA,GAAK,GAAGA,GAAA,GAAKD,UAAA,EAAWC,GAAA,IAAM;QACrC,IAAMC,MAAA,GAAQD,GAAA;QACd,IAAME,KAAA,IAAQF,GAAA,GAAK,KAAKD,UAAA;QACxB,IAAMlD,GAAA,GAAKD,UAAA,CAASqD,MAAK;QACzB,IAAMnD,GAAA,GAAKF,UAAA,CAASsD,KAAI;QAGxB,IAAMC,KAAA,GAAOlC,QAAA,CAASpB,GAAA,EAAIC,GAAE;QAC5B,OAAOkC,YAAA,CAAamB,KAAI;QAExB,IAAMW,WAAA,GAAc7C,QAAA,CAASnB,GAAA,EAAID,GAAE;QACnC,IAAMkE,SAAA,GAAY/B,YAAA,CAAa8B,WAAW;QAC1C,IAAIC,SAAA,EAAW;UACb,IAAMC,QAAA,GAAWD,SAAA,CAAUjB,GAAA;UAC3B,IAAMmB,UAAA,GAAaF,SAAA,CAAUd,KAAA;UAC7B,IAAMiB,YAAA,GAAeF,QAAA,CAAS/B,OAAA;UAC9B,IAAMkC,cAAA,GAAiBD,YAAA,CAAaxE,MAAA;UACpC,IAAM0E,eAAA,GAAkBJ,QAAA,CAAS/D,UAAA;UAKjC,IAAIoE,IAAA,CAAKC,GAAA,CAAIN,QAAA,CAAS/D,UAAA,CAAWqB,GAAA,CAAIwB,IAAA,CAAI7C,UAAU,CAAC,IAAI,MAAM;YAC5D;UACD;UAKD,IAAI6D,WAAA,IAAe9B,YAAA,EAAc;YAC/B2B,KAAA,CAAMd,IAAA,CAAKkB,SAAS;YACpB,OAAO/B,YAAA,CAAa8B,WAAW;UAChC;UAGD,IAAMS,SAAA,IAAaN,UAAA,GAAa,KAAKE,cAAA;UACrC,IAAIN,WAAA,CAAYZ,MAAK,KAAKiB,YAAA,CAAaK,SAAS,KAAKV,WAAA,CAAYZ,MAAK,MAAMiB,YAAA,CAAaK,SAAS,GAAG;YACnGL,YAAA,CAAaK,SAAS,EAAEC,IAAA,CAAKrC,GAAA,CAAI0B,WAAA,CAAYZ,MAAK,EAAEuB,IAAI;YACxDX,WAAA,CAAYZ,MAAK,EAAEuB,IAAA,GAAON,YAAA,CAAaK,SAAS,EAAEC,IAAA;UACnD;UAED,IAAIC,aAAA,GAAgBZ,WAAA,CAAYZ,MAAK,KAAKiB,YAAA,CAAaK,SAAS;UAChE,IAAIE,aAAA,KAAkB,MAAM;YAI1BA,aAAA,GAAgB;cAAED,IAAA,EAAM,IAAI9H,OAAA;YAAW;YACvCuF,OAAA,CAAQY,IAAA,CAAK4B,aAAA,CAAcD,IAAI;UAChC;UAED,IAAIX,WAAA,CAAYZ,MAAK,MAAM,MAAM;YAC/BY,WAAA,CAAYZ,MAAK,IAAIwB,aAAA;YACrBA,aAAA,CAAcD,IAAA,CAAKrC,GAAA,CAAIlC,UAAU;UAClC;UAED,IAAIiE,YAAA,CAAaK,SAAS,MAAM,MAAM;YACpCL,YAAA,CAAaK,SAAS,IAAIE,aAAA;YAC1BA,aAAA,CAAcD,IAAA,CAAKrC,GAAA,CAAIiC,eAAe;UACvC;UAGD,IAAIP,WAAA,CAAYX,KAAI,KAAKgB,YAAA,CAAaD,UAAU,KAAKJ,WAAA,CAAYX,KAAI,MAAMgB,YAAA,CAAaD,UAAU,GAAG;YACnGC,YAAA,CAAaD,UAAU,EAAEO,IAAA,CAAKrC,GAAA,CAAI0B,WAAA,CAAYX,KAAI,EAAEsB,IAAI;YACxDX,WAAA,CAAYX,KAAI,EAAEsB,IAAA,GAAON,YAAA,CAAaD,UAAU,EAAEO,IAAA;UACnD;UAED,IAAIE,aAAA,GAAgBb,WAAA,CAAYX,KAAI,KAAKgB,YAAA,CAAaD,UAAU;UAChE,IAAIS,aAAA,KAAkB,MAAM;YAC1BA,aAAA,GAAgB;cAAEF,IAAA,EAAM,IAAI9H,OAAA;YAAW;YACvCuF,OAAA,CAAQY,IAAA,CAAK6B,aAAA,CAAcF,IAAI;UAChC;UAED,IAAIX,WAAA,CAAYX,KAAI,MAAM,MAAM;YAC9BW,WAAA,CAAYX,KAAI,IAAIwB,aAAA;YACpBA,aAAA,CAAcF,IAAA,CAAKrC,GAAA,CAAIlC,UAAU;UAClC;UAED,IAAIiE,YAAA,CAAaD,UAAU,MAAM,MAAM;YACrCC,YAAA,CAAaD,UAAU,IAAIS,aAAA;YAC3BA,aAAA,CAAcF,IAAA,CAAKrC,GAAA,CAAIiC,eAAe;UACvC;QACF;MACF;IACF;EACF;EAGD,SAAS5E,GAAA,GAAI,GAAGC,GAAA,GAAIwC,OAAA,CAAQvC,MAAA,EAAQF,GAAA,GAAIC,GAAA,EAAGD,GAAA,IAAK;IAC9CyC,OAAA,CAAQzC,GAAC,EAAEW,SAAA,CAAW;EACvB;AACH;AAEA,SAASwE,WAAWC,IAAA,EAAM;EACxB,OAAOA,IAAA,KAAS,UAAUA,IAAA,KAAS;AACrC;AAEA,SAASC,gBAAgBD,IAAA,EAAM;EAC7B,OAAO,aAAaE,IAAA,CAAKF,IAAI,KAAKA,IAAA,KAAS;AAC7C;AAAA,IAEMG,UAAA;EACJ,SAAAA,WAAYC,IAAA,EAAMC,UAAA,EAAY;IAAA9H,eAAA,OAAA4H,UAAA;IAC5B,KAAKC,IAAA,GAAOA,IAAA;IACZ,KAAKE,UAAA,GAAaF,IAAA,CAAKtF,MAAA;IACvB,KAAKyF,gBAAA,GAAmB;IACxB,KAAKC,WAAA,GAAc;IACnB,KAAKH,UAAA,GAAaA,UAAA;EACnB;EAAArG,YAAA,CAAAmG,UAAA;IAAArB,GAAA;IAAA/F,KAAA,EAED,SAAA0H,aAAA,EAAe;MACb,OAAO,KAAKF,gBAAA,GAAmB,KAAKD,UAAA,EAAY;QAC9C,KAAKE,WAAA,GAAc,KAAKJ,IAAA,CAAKM,MAAA,CAAO,KAAKH,gBAAgB;QAEzD,IAAI,KAAKC,WAAA,KAAgB,OAAO,KAAKA,WAAA,KAAgB,KAAM;UACzD;QACD;QAED,KAAKD,gBAAA;MACN;IACF;EAAA;IAAAzB,GAAA;IAAA/F,KAAA,EAED,SAAA4H,SAAA,EAAW;MACT,IAAMC,IAAA,GAAO,KAAKL,gBAAA;MAGlB,OAAO,KAAKA,gBAAA,GAAmB,KAAKD,UAAA,EAAY;QAC9C,KAAKE,WAAA,GAAc,KAAKJ,IAAA,CAAKM,MAAA,CAAO,KAAKH,gBAAgB;QAEzD,IAAI,KAAKC,WAAA,KAAgB,OAAO,KAAKA,WAAA,KAAgB,KAAM;UACzD;QACD;QAED,KAAKD,gBAAA;MACN;MAED,IAAMM,IAAA,GAAO,KAAKN,gBAAA;MAElB,KAAKE,YAAA,CAAc;MAEnB,OAAO,KAAKL,IAAA,CAAKU,SAAA,CAAUF,IAAA,EAAMC,IAAI;IACtC;EAAA;IAAA/B,GAAA;IAAA/F,KAAA,EAED,SAAAgI,UAAA,EAAY;MACV,OAAO,IAAIjJ,OAAA,CAAQkJ,UAAA,CAAW,KAAKL,QAAA,CAAU,IAAGK,UAAA,CAAW,KAAKL,QAAA,CAAU,IAAGK,UAAA,CAAW,KAAKL,QAAA,CAAU,EAAC;IACzG;EAAA;IAAA7B,GAAA;IAAA/F,KAAA,EAED,SAAAkI,mBAAA,EAAqB;MACnB,OAAO,KAAKb,IAAA,CAAKU,SAAA,CAAU,KAAKP,gBAAA,EAAkB,KAAKD,UAAU;IAClE;EAAA;IAAAxB,GAAA;IAAA/F,KAAA,EAED,SAAAmI,WAAA,EAAa;MACX,OAAO,KAAKX,gBAAA,IAAoB,KAAKD,UAAA;IACtC;EAAA;IAAAxB,GAAA;IAAA/F,KAAA,EAED,SAAAoI,SAAA,EAAW;MACT,KAAKZ,gBAAA,GAAmB,KAAKD,UAAA;IAC9B;EAAA;IAAAxB,GAAA;IAAA/F,KAAA,EAED,SAAAqI,oBAAA,EAAsB;MACpB,OAAO,KAAKf,UAAA,IAAc,IAAI,cAAc,KAAKA,UAAA,GAAa;IAC/D;EAAA;EAAA,OAAAF,UAAA;AAAA;AAAA,IAIGkB,gBAAA;EACJ,SAAAA,iBAAYC,MAAA,EAAQ;IAAA/I,eAAA,OAAA8I,gBAAA;IAClB,KAAKC,MAAA,GAASA,MAAA;IACd,KAAKC,MAAA,GAAS,CAAE;EACjB;EAAAvH,YAAA,CAAAqH,gBAAA;IAAAvC,GAAA;IAAA/F,KAAA,EAED,SAAAyI,YAAYC,QAAA,EAAU;MACpB,IAAMC,MAAA,GAAS,CAAE;MAIjBA,MAAA,CAAO/G,KAAA,GAAQ8G,QAAA,CAAS9G,KAAA,CAAMgH,GAAA,CAAI,UAAC5G,IAAA,EAAS;QAC1C,OAAO;UACL6G,SAAA,EAAW7G,IAAA,CAAK6G,SAAA;UAChBtH,QAAA,EAAUS,IAAA,CAAKT,QAAA;UACfU,QAAA,EAAUD,IAAA,CAAKC,QAAA,CAAS2G,GAAA,CAAI,UAAC1F,CAAA;YAAA,OAAMA,CAAA,CAAE4F,KAAA,EAAO;UAAA;UAC5CxE,OAAA,EAAStC,IAAA,CAAKsC,OAAA,CAAQsE,GAAA,CAAI;YAAA,OAAM,IAAI;UAAA;UACpCtG,UAAA,EAAY;QACb;MACP,CAAK;MAEDqG,MAAA,CAAOI,mBAAA,GAAsBL,QAAA,CAASK,mBAAA,CAAoBH,GAAA,CAAI,UAAC5G,IAAA,EAAS;QACtE,OAAO;UACL6G,SAAA,EAAW7G,IAAA,CAAK6G,SAAA;UAChBtH,QAAA,EAAUS,IAAA,CAAKT,QAAA;UACfU,QAAA,EAAUD,IAAA,CAAKC,QAAA,CAAS2G,GAAA,CAAI,UAAC1F,CAAA;YAAA,OAAMA,CAAA,CAAE4F,KAAA,EAAO;UAAA;UAC5CE,aAAA,EAAehH,IAAA,CAAKgH,aAAA,CAAcJ,GAAA,CAAI,UAAC1F,CAAA;YAAA,OAAMA,CAAA,CAAE4F,KAAA,EAAO;UAAA;QACvD;MACP,CAAK;MAEDH,MAAA,CAAO/F,YAAA,GAAe8F,QAAA,CAAS9F,YAAA,CAAagG,GAAA,CAAI,UAAC5G,IAAA,EAAS;QACxD,OAAO;UACL6G,SAAA,EAAW7G,IAAA,CAAK6G,SAAA;UAChBtH,QAAA,EAAUS,IAAA,CAAKT,QAAA;UACfU,QAAA,EAAUD,IAAA,CAAKC,QAAA,CAAS2G,GAAA,CAAI,UAAC1F,CAAA;YAAA,OAAMA,CAAA,CAAE4F,KAAA,EAAO;UAAA;QAC7C;MACP,CAAK;MAGDH,MAAA,CAAO1B,IAAA,GAAOyB,QAAA,CAASzB,IAAA;MACvB0B,MAAA,CAAOM,QAAA,GAAWP,QAAA,CAASO,QAAA;MAC3BN,MAAA,CAAOO,QAAA,GAAWR,QAAA,CAASQ,QAAA;MAC3BP,MAAA,CAAOQ,UAAA,GAAaT,QAAA,CAASS,UAAA;MAC7BR,MAAA,CAAOS,UAAA,GAAaV,QAAA,CAASU,UAAA;MAC7BT,MAAA,CAAOU,wBAAA,GAA2BX,QAAA,CAASW,wBAAA;MAC3CV,MAAA,CAAOW,SAAA,GAAYZ,QAAA,CAASY,SAAA;MAC5BX,MAAA,CAAOY,KAAA,GAAQ;MACf,OAAOZ,MAAA;IACR;EAAA;IAAA5C,GAAA;IAAA/F,KAAA;MAAA,IAAAwJ,UAAA,GAAAC,iBAAA,eAAAC,mBAAA,GAAAC,IAAA,CAED,SAAAC,QAAgBC,QAAA;QAAA,IAAAC,cAAA,EAAAC,aAAA,EAAAC,YAAA,EAAAzB,MAAA,EAAA0B,UAAA,EAAAC,IAAA;QAAA,OAAAR,mBAAA,GAAAS,IAAA,UAAAC,SAAAC,QAAA;UAAA,kBAAAA,QAAA,CAAAC,IAAA,GAAAD,QAAA,CAAA9E,IAAA;YAAA;cACVuE,cAAA,GAAiB;cACjBC,aAAA,GAAgB1L,mBAAA;YAAA;cAAA,MACb0L,aAAA,KAAkBpL,uBAAA;gBAAA0L,QAAA,CAAA9E,IAAA;gBAAA;cAAA;cACnByE,YAAA,GAAeH,QAAA;cAAAQ,QAAA,CAAAE,EAAA,GACXR,aAAA;cAAAM,QAAA,CAAA9E,IAAA,GAAA8E,QAAA,CAAAE,EAAA,KACDlM,mBAAA,OAAAgM,QAAA,CAAAE,EAAA,KAIAjM,uBAAA,OAAA+L,QAAA,CAAAE,EAAA,KAKAhM,mBAAA,QAAA8L,QAAA,CAAAE,EAAA,KAKA/L,wBAAA,QAAA6L,QAAA,CAAAE,EAAA,KAKA9L,0BAAA,QAAA4L,QAAA,CAAAE,EAAA,KAKA7L,0BAAA;cAAA;YAAA;cAvBHqL,aAAA,GAAgBA,aAAA,GAAgB;cAAA,OAAAM,QAAA,CAAAG,MAAA;YAAA;cAIhCR,YAAA,GAAe,WAAWA,YAAA;cAC1BD,aAAA,GAAgBA,aAAA,GAAgB;cAAA,OAAAM,QAAA,CAAAG,MAAA;YAAA;cAIhCR,YAAA,GAAe,OAAOA,YAAA;cACtBD,aAAA,GAAgBA,aAAA,GAAgB;cAAA,OAAAM,QAAA,CAAAG,MAAA;YAAA;cAIhCR,YAAA,GAAe,YAAYA,YAAA;cAC3BD,aAAA,GAAgBA,aAAA,GAAgB;cAAA,OAAAM,QAAA,CAAAG,MAAA;YAAA;cAIhCR,YAAA,GAAeH,QAAA,CAAS9B,SAAA,CAAU,GAAG8B,QAAA,CAASY,WAAA,CAAY,GAAG,IAAI,CAAC,IAAIT,YAAA;cACtED,aAAA,GAAgBA,aAAA,GAAgB;cAAA,OAAAM,QAAA,CAAAG,MAAA;YAAA;cAIhC,IAAIV,cAAA,EAAgB;gBAElBC,aAAA,GAAgBpL,uBAAA;cAC5B,OAAiB;gBAELkL,QAAA,GAAWA,QAAA,CAASa,WAAA,CAAa;gBACjCV,YAAA,GAAeH,QAAA;gBACfC,cAAA,GAAiB;gBACjBC,aAAA,GAAgB1L,mBAAA;cACjB;cAAA,OAAAgM,QAAA,CAAAG,MAAA;YAAA;cAKCjC,MAAA,GAAS,KAAKA,MAAA;cACd0B,UAAA,GAAa,IAAIU,UAAA,CAAWpC,MAAA,CAAOqC,OAAO;cAChDX,UAAA,CAAWY,OAAA,CAAQtC,MAAA,CAAOuC,gBAAgB;cAC1Cb,UAAA,CAAWc,gBAAA,CAAiBxC,MAAA,CAAOyC,aAAa;cAChDf,UAAA,CAAWgB,kBAAA,CAAmB1C,MAAA,CAAO2C,eAAe;cAAAb,QAAA,CAAAC,IAAA;cAAAD,QAAA,CAAA9E,IAAA;cAAA,OAG/B0E,UAAA,CAAWkB,SAAA,CAAUnB,YAAY;YAAA;cAA9CE,IAAA,GAAAG,QAAA,CAAAe,IAAA;cAAA,OAAAf,QAAA,CAAAG,MAAA,WACCN,IAAA;YAAA;cAAAG,QAAA,CAAAC,IAAA;cAAAD,QAAA,CAAAgB,EAAA,GAAAhB,QAAA;cAAA,OAAAA,QAAA,CAAAG,MAAA;YAAA;cAAAH,QAAA,CAAA9E,IAAA;cAAA;YAAA;cAAA,MAML,IAAI+F,KAAA,CAAM,6BAA6BzB,QAAA,GAAW,wBAAwB;YAAA;YAAA;cAAA,OAAAQ,QAAA,CAAAkB,IAAA;UAAA;QAAA,GAAA3B,OAAA;MAAA,CACjF;MAAA,SAAA4B,UAAAC,EAAA;QAAA,OAAAjC,UAAA,CAAAkC,KAAA,OAAA5I,SAAA;MAAA;MAAA,OAAA0I,SAAA;IAAA;EAAA;IAAAzF,GAAA;IAAA/F,KAAA,EAED,SAAA2L,MAAMzB,IAAA,EAAuB;MAAA,IAAjBL,QAAA,GAAA/G,SAAA,CAAAf,MAAA,QAAAe,SAAA,QAAAC,SAAA,GAAAD,SAAA,MAAW;MACrB,IAAMyF,MAAA,GAAS,KAAKA,MAAA;MAGpB,IAAM3G,KAAA,GAAQ,EAAE;MAChB,IAAMgB,YAAA,GAAe,EAAE;MACvB,IAAMmG,mBAAA,GAAsB,EAAE;MAC9B,IAAMI,UAAA,GAAa,EAAE;MACrB,IAAMG,SAAA,GAAY,CAAE;MAEpB,IAAMsC,gBAAA,GAAmB,SAAnBA,iBAAoB/C,SAAA,EAAc;QACtC,OAAOS,SAAA,CAAUT,SAAS,KAAK;MAChC;MAED,IAAI5B,IAAA,GAAO;MACX,IAAIgC,QAAA,GAAW;MACf,IAAIC,QAAA,GAAW;MACf,IAAIE,UAAA,GAAa;MAGjB,IAAIc,IAAA,CAAK2B,OAAA,CAAQ,MAAM,MAAM,IAAI;QAE/B3B,IAAA,GAAOA,IAAA,CAAK1J,OAAA,CAAQ,SAAS,IAAI;MAClC;MAED,IAAMsL,KAAA,GAAQ5B,IAAA,CAAK6B,KAAA,CAAM,IAAI;MAC7B,IAAMC,QAAA,GAAWF,KAAA,CAAM/J,MAAA;MAEvB,IAAIkK,oBAAA,GAAuB;MAC3B,IAAIC,uBAAA,GAA0B;MAC9B,IAAIC,mBAAA,GAAsB;MAE1B,IAAIC,YAAA,GAAe;MACnB,IAAIC,MAAA,GAAS;MACb,IAAIC,WAAA,GAAc;MAClB,IAAIC,OAAA,GAAU;MAEd,IAAIlD,wBAAA,GAA2B;MAG/B,SAASmD,SAAA,GAAY,GAAGA,SAAA,GAAYR,QAAA,EAAUQ,SAAA,IAAa;QACzD,IAAMnF,IAAA,GAAOyE,KAAA,CAAMU,SAAS;QAE5B,IAAInF,IAAA,CAAKtF,MAAA,KAAW,GAAG;QAEvB,IAAIkK,oBAAA,EAAsB;UACxB,IAAI5E,IAAA,CAAKoF,UAAA,CAAW,SAAS,GAAG;YAE9B,KAAKC,OAAA,CAAQR,uBAAA,EAAyBC,mBAAmB;YAGzDD,uBAAA,GAA0B7E,IAAA,CAAKU,SAAA,CAAU,CAAC;YAC1CoE,mBAAA,GAAsB;UAChC,OAAe;YACLA,mBAAA,IAAuB9E,IAAA,GAAO;UAC/B;UAED;QACD;QAED,IAAMsF,EAAA,GAAK,IAAIvF,UAAA,CAAWC,IAAA,EAAMmF,SAAA,GAAY,CAAC;QAC7CG,EAAA,CAAGjF,YAAA,CAAc;QAEjB,IAAIiF,EAAA,CAAGxE,UAAA,IAAc;UAEnB;QACD;QAGD,IAAMyE,QAAA,GAAWD,EAAA,CAAG/E,QAAA,CAAU;QAE9B,IAAIrG,QAAA;QACJ,IAAIsH,SAAA;QACJ,IAAIgE,OAAA;QACJ,IAAIC,GAAA;QACJ,IAAIC,WAAA;QACJ,IAAI7K,EAAA;UAAIC,EAAA;UAAIC,EAAA;UAAI4K,EAAA;UAAIC,EAAA;UAAIC,EAAA;QAExB,QAAQN,QAAA;UAEN,KAAK;YAEH,IAAMO,IAAA,GAAOR,EAAA,CAAG/E,QAAA,CAAU;YAE1B,IAAIuF,IAAA,EAAM;cACR,QAAQA,IAAA;gBACN,KAAK;kBACHlG,IAAA,GAAO0F,EAAA,CAAG/E,QAAA,CAAU;kBACpB;gBAEF,KAAK;kBACHrG,QAAA,GAAWgH,MAAA,CAAO6E,uBAAA,CAAwBT,EAAE;kBAC5C,IAAIpL,QAAA,EAAU;oBACZ+H,SAAA,CAAU/H,QAAA,CAAS8L,QAAA,CAASC,IAAI,IAAI/L,QAAA;kBACtD,OAAuB;oBACLgM,OAAA,CAAQC,IAAA,CAAK,wCAAwCb,EAAA,CAAGtE,mBAAA,CAAmB,CAAE;kBAC9E;kBAED;gBAEF,KAAK;kBACHY,QAAA,GAAW0D,EAAA,CAAG/E,QAAA,CAAU;kBACxB;gBAEF,KAAK;kBACH,IAAM6F,WAAA,GAAcd,EAAA,CAAGzE,kBAAA,CAAkB,EAAG6D,KAAA,CAAM,GAAG;kBACrD,IAAI0B,WAAA,CAAY1L,MAAA,GAAS,GAAG;oBAC1B,IAAI,CAACmH,QAAA,EAAU;sBACbA,QAAA,GAAW,EAAE;oBACd;oBAEDuE,WAAA,CAAYC,OAAA,CAAQ,UAAUC,OAAA,EAAS;sBACrCzE,QAAA,CAAShE,IAAA,CAAKyI,OAAA,CAAQC,IAAA,EAAM;oBAChD,CAAmB;kBACF;kBAED;gBAEF,KAAK;kBACH,IAAIpB,SAAA,GAAY,GAAG;oBAEjBP,oBAAA,GAAuB;oBACvBC,uBAAA,GAA0BS,EAAA,CAAGzE,kBAAA,CAAoB;oBACjDiE,mBAAA,GAAsB;oBAEtBC,YAAA,GAAe;oBACfC,MAAA,GAAS;kBACV;kBAED;gBAEF,KAAK;kBAEH,OAAO,CAACM,EAAA,CAAGxE,UAAA,IAAc;oBACvB,IAAM0F,KAAA,GAAQlB,EAAA,CAAG/E,QAAA,CAAU;oBAE3B,QAAQiG,KAAA;sBACN,KAAK;sBACL,KAAK;wBACHzB,YAAA,GAAeyB,KAAA,KAAU;wBACzBxB,MAAA,GAAS;wBAET;sBAEF,KAAK;sBACL,KAAK;wBACHA,MAAA,GAASwB,KAAA,KAAU;wBAEnB;sBAEF,KAAK;wBACHvB,WAAA,GAAc;wBAEd;sBAEF,KAAK;sBACL,KAAK;wBACHC,OAAA,GAAUsB,KAAA,KAAU;wBAEpB;sBAEF;wBACEN,OAAA,CAAQC,IAAA,CAAK,uCAAuCK,KAAA,GAAQ,eAAe;wBAE3E;oBACH;kBACF;kBAED;gBAEF,KAAK;kBACHxE,wBAAA,GAA2B;kBAE3B;cAKH;YACF;YAED;UAGF,KAAK;YACHR,SAAA,GAAY8D,EAAA,CAAG/E,QAAA,CAAU;YACzBrG,QAAA,GAAWqK,gBAAA,CAAiB/C,SAAS;YAErC,IAAMiF,IAAA,GAAO7F,UAAA,CAAW0E,EAAA,CAAG/E,QAAA,CAAQ,CAAE;YACrC,IAAMmG,IAAA,GAAO9F,UAAA,CAAW0E,EAAA,CAAG/E,QAAA,CAAQ,CAAE;YACrC,IAAMoG,IAAA,GAAO/F,UAAA,CAAW0E,EAAA,CAAG/E,QAAA,CAAQ,CAAE;YACrC,IAAMqG,EAAA,GAAKhG,UAAA,CAAW0E,EAAA,CAAG/E,QAAA,CAAQ,CAAE;YACnC,IAAMsG,EAAA,GAAKjG,UAAA,CAAW0E,EAAA,CAAG/E,QAAA,CAAQ,CAAE;YACnC,IAAMuG,EAAA,GAAKlG,UAAA,CAAW0E,EAAA,CAAG/E,QAAA,CAAQ,CAAE;YACnC,IAAMwG,EAAA,GAAKnG,UAAA,CAAW0E,EAAA,CAAG/E,QAAA,CAAQ,CAAE;YACnC,IAAMyG,EAAA,GAAKpG,UAAA,CAAW0E,EAAA,CAAG/E,QAAA,CAAQ,CAAE;YACnC,IAAM0G,EAAA,GAAKrG,UAAA,CAAW0E,EAAA,CAAG/E,QAAA,CAAQ,CAAE;YACnC,IAAM2G,EAAA,GAAKtG,UAAA,CAAW0E,EAAA,CAAG/E,QAAA,CAAQ,CAAE;YACnC,IAAM4G,EAAA,GAAKvG,UAAA,CAAW0E,EAAA,CAAG/E,QAAA,CAAQ,CAAE;YACnC,IAAM6G,EAAA,GAAKxG,UAAA,CAAW0E,EAAA,CAAG/E,QAAA,CAAQ,CAAE;YAEnC,IAAM8G,MAAA,GAAS,IAAIC,OAAA,CAAO,EAAG9N,GAAA,CAAIoN,EAAA,EAAIC,EAAA,EAAIC,EAAA,EAAIL,IAAA,EAAMM,EAAA,EAAIC,EAAA,EAAIC,EAAA,EAAIP,IAAA,EAAMQ,EAAA,EAAIC,EAAA,EAAIC,EAAA,EAAIT,IAAA,EAAM,GAAG,GAAG,GAAG,CAAC;YAEjG,IAAIY,SAAA,GAAWjC,EAAA,CAAGzE,kBAAA,CAAoB,EAAC0F,IAAA,CAAI,EAAGpN,OAAA,CAAQ,OAAO,GAAG;YAEhE,IAAI+H,MAAA,CAAOsG,OAAA,CAAQD,SAAQ,GAAG;cAE5BA,SAAA,GAAWrG,MAAA,CAAOsG,OAAA,CAAQD,SAAQ;YAC9C,OAAiB;cAEL,IAAIA,SAAA,CAASnC,UAAA,CAAW,IAAI,GAAG;gBAC7BmC,SAAA,GAAW,WAAWA,SAAA;cACvB,WAAUA,SAAA,CAASnC,UAAA,CAAW,KAAK,GAAG;gBACrCmC,SAAA,GAAW,OAAOA,SAAA;cACnB;YACF;YAEDzF,UAAA,CAAWjE,IAAA,CAAK;cACd3D,QAAA,EAAAA,QAAA;cACAsH,SAAA,EAAAA,SAAA;cACA6F,MAAA,EAAAA,MAAA;cACA7E,QAAA,EAAU+E,SAAA;cACVE,QAAA,EAAUxC,WAAA;cACVjD,wBAAA,EAAAA;YACZ,CAAW;YAEDiD,WAAA,GAAc;YAEd;UAGF,KAAK;YACHzD,SAAA,GAAY8D,EAAA,CAAG/E,QAAA,CAAU;YACzBrG,QAAA,GAAWqK,gBAAA,CAAiB/C,SAAS;YACrC3G,EAAA,GAAKyK,EAAA,CAAG3E,SAAA,CAAW;YACnB7F,EAAA,GAAKwK,EAAA,CAAG3E,SAAA,CAAW;YAEnB6E,OAAA,GAAU;cACRtL,QAAA,EAAAA,QAAA;cACAsH,SAAA,EAAAA,SAAA;cACA5G,QAAA,EAAU,CAACC,EAAA,EAAIC,EAAE;YAClB;YAEDS,YAAA,CAAasC,IAAA,CAAK2H,OAAO;YAEzB;UAGF,KAAK;YACHhE,SAAA,GAAY8D,EAAA,CAAG/E,QAAA,CAAU;YACzBrG,QAAA,GAAWqK,gBAAA,CAAiB/C,SAAS;YACrC3G,EAAA,GAAKyK,EAAA,CAAG3E,SAAA,CAAW;YACnB7F,EAAA,GAAKwK,EAAA,CAAG3E,SAAA,CAAW;YACnBiF,EAAA,GAAKN,EAAA,CAAG3E,SAAA,CAAW;YACnBkF,EAAA,GAAKP,EAAA,CAAG3E,SAAA,CAAW;YAEnB6E,OAAA,GAAU;cACRtL,QAAA,EAAAA,QAAA;cACAsH,SAAA,EAAAA,SAAA;cACA5G,QAAA,EAAU,CAACC,EAAA,EAAIC,EAAE;cACjB6G,aAAA,EAAe,CAACiE,EAAA,EAAIC,EAAE;YACvB;YAEDnE,mBAAA,CAAoB7D,IAAA,CAAK2H,OAAO;YAEhC;UAGF,KAAK;YACHhE,SAAA,GAAY8D,EAAA,CAAG/E,QAAA,CAAU;YACzBrG,QAAA,GAAWqK,gBAAA,CAAiB/C,SAAS;YACrCiE,GAAA,GAAMT,MAAA;YACNU,WAAA,GAAc,CAACX,YAAA,IAAgB,CAACG,OAAA;YAEhC,IAAIO,GAAA,KAAQ,MAAM;cAChB5K,EAAA,GAAKyK,EAAA,CAAG3E,SAAA,CAAW;cACnB7F,EAAA,GAAKwK,EAAA,CAAG3E,SAAA,CAAW;cACnB5F,EAAA,GAAKuK,EAAA,CAAG3E,SAAA,CAAW;YAC/B,OAAiB;cACL5F,EAAA,GAAKuK,EAAA,CAAG3E,SAAA,CAAW;cACnB7F,EAAA,GAAKwK,EAAA,CAAG3E,SAAA,CAAW;cACnB9F,EAAA,GAAKyK,EAAA,CAAG3E,SAAA,CAAW;YACpB;YAEDpG,KAAA,CAAMsD,IAAA,CAAK;cACT3D,QAAA,EAAAA,QAAA;cACAsH,SAAA,EAAAA,SAAA;cACAvG,UAAA,EAAY;cACZL,QAAA,EAAU,CAACC,EAAA,EAAIC,EAAA,EAAIC,EAAE;cACrBkC,OAAA,EAAS,CAAC,MAAM,MAAM,IAAI;YACtC,CAAW;YACD8E,UAAA;YAEA,IAAI2D,WAAA,KAAgB,MAAM;cACxBnL,KAAA,CAAMsD,IAAA,CAAK;gBACT3D,QAAA,EAAAA,QAAA;gBACAsH,SAAA,EAAAA,SAAA;gBACAvG,UAAA,EAAY;gBACZL,QAAA,EAAU,CAACG,EAAA,EAAID,EAAA,EAAID,EAAE;gBACrBoC,OAAA,EAAS,CAAC,MAAM,MAAM,IAAI;cACxC,CAAa;cACD8E,UAAA;YACD;YAED;UAGF,KAAK;YACHP,SAAA,GAAY8D,EAAA,CAAG/E,QAAA,CAAU;YACzBrG,QAAA,GAAWqK,gBAAA,CAAiB/C,SAAS;YACrCiE,GAAA,GAAMT,MAAA;YACNU,WAAA,GAAc,CAACX,YAAA,IAAgB,CAACG,OAAA;YAEhC,IAAIO,GAAA,KAAQ,MAAM;cAChB5K,EAAA,GAAKyK,EAAA,CAAG3E,SAAA,CAAW;cACnB7F,EAAA,GAAKwK,EAAA,CAAG3E,SAAA,CAAW;cACnB5F,EAAA,GAAKuK,EAAA,CAAG3E,SAAA,CAAW;cACnBgF,EAAA,GAAKL,EAAA,CAAG3E,SAAA,CAAW;YAC/B,OAAiB;cACLgF,EAAA,GAAKL,EAAA,CAAG3E,SAAA,CAAW;cACnB5F,EAAA,GAAKuK,EAAA,CAAG3E,SAAA,CAAW;cACnB7F,EAAA,GAAKwK,EAAA,CAAG3E,SAAA,CAAW;cACnB9F,EAAA,GAAKyK,EAAA,CAAG3E,SAAA,CAAW;YACpB;YAIDpG,KAAA,CAAMsD,IAAA,CAAK;cACT3D,QAAA,EAAAA,QAAA;cACAsH,SAAA,EAAAA,SAAA;cACAvG,UAAA,EAAY;cACZL,QAAA,EAAU,CAACC,EAAA,EAAIC,EAAA,EAAIC,EAAA,EAAI4K,EAAE;cACzB1I,OAAA,EAAS,CAAC,MAAM,MAAM,MAAM,IAAI;YAC5C,CAAW;YACD8E,UAAA,IAAc;YAEd,IAAI2D,WAAA,KAAgB,MAAM;cACxBnL,KAAA,CAAMsD,IAAA,CAAK;gBACT3D,QAAA,EAAAA,QAAA;gBACAsH,SAAA,EAAAA,SAAA;gBACAvG,UAAA,EAAY;gBACZL,QAAA,EAAU,CAAC+K,EAAA,EAAI5K,EAAA,EAAID,EAAA,EAAID,EAAE;gBACzBoC,OAAA,EAAS,CAAC,MAAM,MAAM,MAAM,IAAI;cAC9C,CAAa;cACD8E,UAAA,IAAc;YACf;YAED;UAEF;YACE,MAAM,IAAIkC,KAAA,CAAM,qCAAqCsB,QAAA,GAAW,MAAMD,EAAA,CAAGtE,mBAAA,CAAqB,IAAG,GAAG;QACvG;MACF;MAED,IAAI4D,oBAAA,EAAsB;QACxB,KAAKS,OAAA,CAAQR,uBAAA,EAAyBC,mBAAmB;MAC1D;MAED,OAAO;QACLvK,KAAA,EAAAA,KAAA;QACAmH,mBAAA,EAAAA,mBAAA;QACAnG,YAAA,EAAAA,YAAA;QACAqE,IAAA,EAAAA,IAAA;QACAgC,QAAA,EAAAA,QAAA;QACAC,QAAA,EAAAA,QAAA;QACAC,UAAA,EAAAA,UAAA;QACAC,UAAA,EAAAA,UAAA;QACAC,wBAAA,EAAAA,wBAAA;QACAC,SAAA,EAAAA,SAAA;QACAO,QAAA,EAAAA,QAAA;QACAN,KAAA,EAAO;MACR;IACF;IAAA;EAAA;IAAAxD,GAAA;IAAA/F,KAAA,EAGD,SAAA+O,QAAQlF,QAAA,EAAwB;MAAA,IAAdf,KAAA,GAAAhG,SAAA,CAAAf,MAAA,QAAAe,SAAA,QAAAC,SAAA,GAAAD,SAAA,MAAQ;MACxB,IAAMiD,GAAA,GAAM8D,QAAA,CAASa,WAAA,CAAa;MAClC,IAAM/B,MAAA,GAAS,KAAKH,MAAA,CAAOzC,GAAG;MAC9B,IAAI4C,MAAA,KAAW,QAAQA,MAAA,YAAkBqG,OAAA,EAAS;QAChD,OAAO;MACR;MAED,IAAIlG,KAAA,EAAO;QACT,OAAO,KAAKL,WAAA,CAAYE,MAAM;MACpC,OAAW;QACL,OAAOA,MAAA;MACR;IACF;IAAA;IAAA;EAAA;IAAA5C,GAAA;IAAA/F,KAAA;MAAA,IAAAiP,iBAAA,GAAAxF,iBAAA,eAAAC,mBAAA,GAAAC,IAAA,CAID,SAAAuF,SAAuBrF,QAAA;QAAA,IAAAsF,MAAA;QAAA,IAAApJ,GAAA;QAAA,OAAA2D,mBAAA,GAAAS,IAAA,UAAAiF,UAAAC,SAAA;UAAA,kBAAAA,SAAA,CAAA/E,IAAA,GAAA+E,SAAA,CAAA9J,IAAA;YAAA;cACfQ,GAAA,GAAM8D,QAAA,CAASa,WAAA,CAAa;cAClC,IAAI,EAAE3E,GAAA,IAAO,KAAKyC,MAAA,GAAS;gBAEzB,KAAKA,MAAA,CAAOzC,GAAG,IAAI,KAAKyF,SAAA,CAAU3B,QAAQ,EAAEyF,IAAA,CAAK,UAACpF,IAAA,EAAS;kBACzD,IAAMpF,IAAA,GAAOqK,MAAA,CAAKxD,KAAA,CAAMzB,IAAA,EAAML,QAAQ;kBACtCsF,MAAA,CAAK3G,MAAA,CAAOzC,GAAG,IAAIjB,IAAA;kBACnB,OAAOA,IAAA;gBACf,CAAO;cACF;cAAAuK,SAAA,CAAA9J,IAAA;cAAA,OAEK,KAAKiD,MAAA,CAAOzC,GAAG;YAAA;YAAA;cAAA,OAAAsJ,SAAA,CAAA9D,IAAA;UAAA;QAAA,GAAA2D,QAAA;MAAA,CACtB;MAAA,SAAAK,iBAAAC,GAAA;QAAA,OAAAP,iBAAA,CAAAvD,KAAA,OAAA5I,SAAA;MAAA;MAAA,OAAAyM,gBAAA;IAAA;EAAA;IAAAxJ,GAAA;IAAA/F,KAAA,EAGD,SAAA0M,QAAQ7C,QAAA,EAAUK,IAAA,EAAM;MACtB,IAAMnE,GAAA,GAAM8D,QAAA,CAASa,WAAA,CAAa;MAClC,KAAKlC,MAAA,CAAOzC,GAAG,IAAI,KAAK4F,KAAA,CAAMzB,IAAA,EAAML,QAAQ;IAC7C;EAAA;EAAA,OAAAvB,gBAAA;AAAA;AAKH,SAASmH,oBAAoB5G,SAAA,EAAW6G,eAAA,EAAiBC,iBAAA,EAAmBC,OAAA,EAAS;EACnF,IAAMC,aAAA,GAAiB,CAACD,OAAA,IAAW/G,SAAA,KAAcjK,gBAAA,IAAsBgR,OAAA,IAAW/G,SAAA,KAAchK,qBAAA;EAChG,IAAIgR,aAAA,EAAe;IACjBhH,SAAA,GAAY6G,eAAA;EACb;EAED,OAAOC,iBAAA,CAAkB9G,SAAS,KAAK;AACzC;AAAA,IAGMiH,uBAAA;EACJ,SAAAA,wBAAYvH,MAAA,EAAQ;IAAA/I,eAAA,OAAAsQ,uBAAA;IAClB,KAAKvH,MAAA,GAASA,MAAA;IACd,KAAKwH,UAAA,GAAa,IAAIzH,gBAAA,CAAiBC,MAAM;IAC7C,KAAKC,MAAA,GAAS,CAAE;EACjB;EAAA;EAAAvH,YAAA,CAAA6O,uBAAA;IAAA/J,GAAA;IAAA/F,KAAA;MAAA,IAAAgQ,gBAAA,GAAAvG,iBAAA,eAAAC,mBAAA,GAAAC,IAAA,CAGD,SAAAsG,SAAsBnL,IAAA;QAAA,IAAAoL,MAAA;QAAA,IAAA3H,MAAA,EAAAwH,UAAA,EAAAI,aAAA,EAAAC,qBAAA,EAAAvO,CAAA,EAAAC,CAAA,EAAAe,gBAAA,EAAA0G,KAAA;QAAA,OAAAG,mBAAA,GAAAS,IAAA,UAAAkG,UAAAC,SAAA;UAAA,kBAAAA,SAAA,CAAAhG,IAAA,GAAAgG,SAAA,CAAA/K,IAAA;YAAA;cACdgD,MAAA,GAAS,KAAKA,MAAA;cACdwH,UAAA,GAAa,KAAKA,UAAA;cAClBI,aAAA,GAAgB,mBAAIjM,GAAA,CAAK;cAIzBkM,qBAAA;gBAAA,IAAAG,KAAA,GAAA9G,iBAAA,eAAAC,mBAAA,GAAAC,IAAA,CAAwB,SAAA6G,SAAO5L,KAAA;kBAAA,IAAA6L,SAAA;oBAAAtH,UAAA;oBAAAuH,QAAA;oBAAAC,KAAA;oBAAA9O,CAAA;oBAAAC,CAAA;oBAAA8O,MAAA;oBAAAC,cAAA;oBAAAC,GAAA;oBAAAC,GAAA;oBAAAC,UAAA;oBAAAC,aAAA;oBAAAC,cAAA;oBAAAC,kBAAA;oBAAAC,yBAAA;oBAAAC,WAAA;oBAAAzO,YAAA;oBAAAmG,mBAAA;oBAAAnH,KAAA;oBAAA8M,MAAA;oBAAAI,QAAA;oBAAAwC,mBAAA;oBAAAzI,SAAA;oBAAA0I,aAAA;oBAAAlM,EAAA;oBAAAQ,EAAA;oBAAAtB,EAAA;oBAAAtC,QAAA;oBAAAuP,GAAA;oBAAAC,GAAA;oBAAAC,EAAA;oBAAAC,UAAA;oBAAA3I,aAAA;oBAAA4I,GAAA;oBAAAC,GAAA;oBAAA1M,GAAA;oBAAA2M,UAAA;oBAAAlM,EAAA;oBAAAmM,EAAA;oBAAAC,MAAA,GAAAlP,SAAA;kBAAA,OAAA4G,mBAAA,GAAAS,IAAA,UAAA8H,UAAAC,SAAA;oBAAA,kBAAAA,SAAA,CAAA5H,IAAA,GAAA4H,SAAA,CAAA3M,IAAA;sBAAA;wBAAMkL,SAAA,GAAAuB,MAAA,CAAAjQ,MAAA,QAAAiQ,MAAA,QAAAjP,SAAA,GAAAiP,MAAA,MAAY;wBAC/C7I,UAAA,GAAavE,KAAA,CAAKuE,UAAA;wBAClBuH,QAAA,GAAW,EAAE;wBAAAC,KAAA,gBAAAjH,mBAAA,GAAAC,IAAA,UAAAgH,MAAA;0BAAA,IAAAK,UAAA,EAAAmB,OAAA;0BAAA,OAAAzI,mBAAA,GAAAS,IAAA,UAAAiI,OAAAC,SAAA;4BAAA,kBAAAA,SAAA,CAAA/H,IAAA,GAAA+H,SAAA,CAAA9M,IAAA;8BAAA;gCAKXyL,UAAA,GAAY7H,UAAA,CAAWtH,CAAC;gCACxBsQ,OAAA,GAAUpC,UAAA,CAAWR,gBAAA,CAAiByB,UAAA,CAAUnH,QAAQ,EAAEyF,IAAA,CAAK,YAAM;kCACzE,IAAM2B,aAAA,GAAgBlB,UAAA,CAAWhB,OAAA,CAAQiC,UAAA,CAAUnH,QAAA,EAAU,KAAK;kCAClE,IAAI,CAAC3C,eAAA,CAAgB+J,aAAA,CAAchK,IAAI,GAAG;oCACxC,OAAOiJ,MAAA,CAAKoC,SAAA,CAAUtB,UAAA,CAAUnH,QAAQ,EAAE0I,KAAA,CAAM,UAACC,KAAA,EAAU;sCACzDjF,OAAA,CAAQC,IAAA,CAAKgF,KAAK;sCAClB,OAAO;oCACrB,CAAa;kCACF;kCAED,OAAOpC,qBAAA,CAAsBL,UAAA,CAAWhB,OAAA,CAAQiC,UAAA,CAAUnH,QAAQ,GAAGmH,UAAS;gCACxF,CAAS;gCAEDN,QAAA,CAASxL,IAAA,CAAKiN,OAAO;8BAAA;8BAAA;gCAAA,OAAAE,SAAA,CAAA9G,IAAA;4BAAA;0BAAA,GAAAoF,KAAA;wBAAA;wBAdd9O,CAAA,GAAI,GAAGC,CAAA,GAAIqH,UAAA,CAAWpH,MAAA;sBAAA;wBAAA,MAAQF,CAAA,GAAIC,CAAA;0BAAAoQ,SAAA,CAAA3M,IAAA;0BAAA;wBAAA;wBAAA,OAAA2M,SAAA,CAAAO,aAAA,CAAA9B,KAAA;sBAAA;wBAAG9O,CAAA;wBAAAqQ,SAAA,CAAA3M,IAAA;wBAAA;sBAAA;wBAiBxCqL,MAAA,GAAQ,IAAI8B,KAAA,CAAO;wBACzB9B,MAAA,CAAMvD,QAAA,CAASpE,QAAA,GAAWrE,KAAA,CAAKqE,QAAA;wBAC/B2H,MAAA,CAAMvD,QAAA,CAASnE,QAAA,GAAWtE,KAAA,CAAKsE,QAAA;wBAC/BtE,KAAA,CAAK2E,KAAA,GAAQqH,MAAA;wBAAAsB,SAAA,CAAA3M,IAAA;wBAAA,OAEgByJ,OAAA,CAAQ2D,GAAA,CAAIjC,QAAQ;sBAAA;wBAA3CG,cAAA,GAAAqB,SAAA,CAAA9G,IAAA;wBACGvJ,GAAA,GAAI,GAAGC,GAAA,GAAI+O,cAAA,CAAe9O,MAAA;sBAAA;wBAAA,MAAQF,GAAA,GAAIC,GAAA;0BAAAoQ,SAAA,CAAA3M,IAAA;0BAAA;wBAAA;wBACvCyL,UAAA,GAAYpM,KAAA,CAAKuE,UAAA,CAAWtH,GAAC;wBAC7BoP,aAAA,GAAgBJ,cAAA,CAAehP,GAAC;wBAAA,MAElCoP,aAAA,KAAkB;0BAAAiB,SAAA,CAAA3M,IAAA;0BAAA;wBAAA;wBAAA,OAAA2M,SAAA,CAAA1H,MAAA;sBAAA;wBAAA,KAMlByG,aAAA,CAAc2B,OAAA;0BAAAV,SAAA,CAAA3M,IAAA;0BAAA;wBAAA;wBACV2L,cAAA,GAAiBD,aAAA;wBACvBD,UAAA,CAAUtC,MAAA,CAAOmE,SAAA,CAAU3B,cAAA,CAAe4B,QAAA,EAAU5B,cAAA,CAAe6B,UAAA,EAAY7B,cAAA,CAAe8B,KAAK;wBACnG9B,cAAA,CAAe7D,QAAA,CAAShE,wBAAA,GAA2B2H,UAAA,CAAU3H,wBAAA;wBAC7D6H,cAAA,CAAe+B,IAAA,GAAOjC,UAAA,CAAUnH,QAAA;wBAEhCtB,MAAA,CAAO2K,oBAAA,CAAqBhC,cAAA,EAAgBF,UAAA,CAAUnI,SAAA,EAAWjE,KAAA,CAAK0E,SAAS;wBAE/EsH,MAAA,CAAMpM,GAAA,CAAI0M,cAAc;wBAAA,OAAAgB,SAAA,CAAA1H,MAAA;sBAAA;wBAK1B,IAAIyG,aAAA,CAAc1H,KAAA,CAAM4J,QAAA,CAASpR,MAAA,EAAQ;0BACvC6O,MAAA,CAAMpM,GAAA,CAAIyM,aAAA,CAAc1H,KAAK;wBAC9B;wBAIK4H,kBAAA,GAAqBvM,KAAA,CAAKhC,YAAA;wBAC1BwO,yBAAA,GAA4BxM,KAAA,CAAKmE,mBAAA;wBACjCsI,WAAA,GAAczM,KAAA,CAAKhD,KAAA;wBAEnBgB,YAAA,GAAeqO,aAAA,CAAcrO,YAAA;wBAC7BmG,mBAAA,GAAsBkI,aAAA,CAAclI,mBAAA;wBAEpCnH,KAAA,GAAQqP,aAAA,CAAcrP,KAAA;wBACtB8M,MAAA,GAASsC,UAAA,CAAUtC,MAAA;wBACnBI,QAAA,GAAWkC,UAAA,CAAUlC,QAAA;wBACrBwC,mBAAA,GAAsB5C,MAAA,CAAO0E,WAAA,CAAW,IAAK;wBAC7CvK,SAAA,GAAYmI,UAAA,CAAUnI,SAAA;wBAEtB0I,aAAA,GAAgB1I,SAAA,KAAcjK,gBAAA,GAAmBC,qBAAA,GAAwBgK,SAAA;wBAC/E,KAASxD,EAAA,GAAI,GAAGQ,EAAA,GAAIjD,YAAA,CAAab,MAAA,EAAQsD,EAAA,GAAIQ,EAAA,EAAGR,EAAA,IAAK;0BAC7Cd,EAAA,GAAK3B,YAAA,CAAayC,EAAC;0BACnBpD,QAAA,GAAWsC,EAAA,CAAGtC,QAAA;0BACpBA,QAAA,CAAS,CAAC,EAAEoR,YAAA,CAAa3E,MAAM;0BAC/BzM,QAAA,CAAS,CAAC,EAAEoR,YAAA,CAAa3E,MAAM;0BAC/BnK,EAAA,CAAGsE,SAAA,GAAYtE,EAAA,CAAGsE,SAAA,KAAchK,qBAAA,GAAwB0S,aAAA,GAAgBhN,EAAA,CAAGsE,SAAA;0BAC3EtE,EAAA,CAAGhD,QAAA,GAAWgD,EAAA,CAAGhD,QAAA,IAAYkO,mBAAA,CAAoBlL,EAAA,CAAGsE,SAAA,EAAWtE,EAAA,CAAGsE,SAAA,EAAWjE,KAAA,CAAK0E,SAAA,EAAW,IAAI;0BAEjG6H,kBAAA,CAAmBjM,IAAA,CAAKX,EAAE;wBAC3B;wBAED,KAASc,GAAA,GAAI,GAAGQ,GAAA,GAAIkD,mBAAA,CAAoBhH,MAAA,EAAQsD,GAAA,GAAIQ,GAAA,EAAGR,GAAA,IAAK;0BACpDqM,EAAA,GAAK3I,mBAAA,CAAoB1D,GAAC;0BAC1BpD,UAAA,GAAWyP,EAAA,CAAGzP,QAAA;0BACd+G,aAAA,GAAgB0I,EAAA,CAAG1I,aAAA;0BACzB/G,UAAA,CAAS,CAAC,EAAEoR,YAAA,CAAa3E,MAAM;0BAC/BzM,UAAA,CAAS,CAAC,EAAEoR,YAAA,CAAa3E,MAAM;0BAC/B1F,aAAA,CAAc,CAAC,EAAEqK,YAAA,CAAa3E,MAAM;0BACpC1F,aAAA,CAAc,CAAC,EAAEqK,YAAA,CAAa3E,MAAM;0BACpCgD,EAAA,CAAG7I,SAAA,GAAY6I,EAAA,CAAG7I,SAAA,KAAchK,qBAAA,GAAwB0S,aAAA,GAAgBG,EAAA,CAAG7I,SAAA;0BAC3E6I,EAAA,CAAGnQ,QAAA,GAAWmQ,EAAA,CAAGnQ,QAAA,IAAYkO,mBAAA,CAAoBiC,EAAA,CAAG7I,SAAA,EAAW6I,EAAA,CAAG7I,SAAA,EAAWjE,KAAA,CAAK0E,SAAA,EAAW,IAAI;0BAEjG8H,yBAAA,CAA0BlM,IAAA,CAAKwM,EAAE;wBAClC;wBAED,KAASrM,GAAA,GAAI,GAAGQ,GAAA,GAAIjE,KAAA,CAAMG,MAAA,EAAQsD,GAAA,GAAIQ,GAAA,EAAGR,GAAA,IAAK;0BACtCF,GAAA,GAAMvD,KAAA,CAAMyD,GAAC;0BACbpD,UAAA,GAAWkD,GAAA,CAAIlD,QAAA;0BACrB,KAAS2D,EAAA,GAAI,GAAGmM,EAAA,GAAI9P,UAAA,CAASF,MAAA,EAAQ6D,EAAA,GAAImM,EAAA,EAAGnM,EAAA,IAAK;4BAC/C3D,UAAA,CAAS2D,EAAC,EAAEyN,YAAA,CAAa3E,MAAM;0BAChC;0BAEDvJ,GAAA,CAAI0D,SAAA,GAAY1D,GAAA,CAAI0D,SAAA,KAAcjK,gBAAA,GAAmBiK,SAAA,GAAY1D,GAAA,CAAI0D,SAAA;0BACrE1D,GAAA,CAAI5D,QAAA,GAAW4D,GAAA,CAAI5D,QAAA,IAAYkO,mBAAA,CAAoBtK,GAAA,CAAI0D,SAAA,EAAWA,SAAA,EAAWjE,KAAA,CAAK0E,SAAA,EAAW,KAAK;0BAClG6G,aAAA,CAAc3L,GAAA,CAAIW,GAAA,CAAI0D,SAAS;0BAI/B,IAAIyI,mBAAA,KAAwBxC,QAAA,EAAU;4BACpC7M,UAAA,CAASqR,OAAA,CAAS;0BACnB;0BAEDjC,WAAA,CAAYnM,IAAA,CAAKC,GAAG;wBACrB;wBAEDP,KAAA,CAAKwE,UAAA,IAAc6H,aAAA,CAAc7H,UAAA;sBAAA;wBAxFevH,GAAA;wBAAAqQ,SAAA,CAAA3M,IAAA;wBAAA;sBAAA;wBA6FlD,IAAIkL,SAAA,EAAW;0BACblI,MAAA,CAAO2K,oBAAA,CAAqBtC,MAAA,EAAOH,SAAA,CAAU5H,SAAA,EAAWjE,KAAA,CAAK0E,SAAS;wBACvE;wBAAA,OAAA4I,SAAA,CAAA1H,MAAA,WAEM5F,KAAA;sBAAA;sBAAA;wBAAA,OAAAsN,SAAA,CAAA3G,IAAA;oBAAA;kBAAA,GAAAiF,QAAA;gBAAA,CACR;gBAAA,gBA/HKJ,sBAAAmD,GAAA;kBAAA,OAAAhD,KAAA,CAAA7E,KAAA,OAAA5I,SAAA;gBAAA;cAAA;cAkIN,KAASjB,CAAA,GAAI,GAAGC,CAAA,GAAIgD,IAAA,CAAKlD,KAAA,EAAOC,CAAA,GAAIC,CAAA,EAAGD,CAAA,IAAK;gBAC1CsO,aAAA,CAAc3L,GAAA,CAAIM,IAAA,CAAKlD,KAAA,CAAMC,CAAC,EAAEgH,SAAS;cAC1C;cAAAyH,SAAA,CAAA/K,IAAA;cAAA,OAEK6K,qBAAA,CAAsBtL,IAAI;YAAA;cAEhC,IAAIyD,MAAA,CAAO5F,aAAA,EAAe;gBAClBE,gBAAA,GAAmBsN,aAAA,CAAcqD,IAAA,GAAO;gBAC9C7R,mBAAA,CAAoBmD,IAAA,CAAKlD,KAAK;gBAC9Be,aAAA,CAAcmC,IAAA,CAAKlD,KAAA,EAAOkD,IAAA,CAAKlC,YAAA,EAAcC,gBAAgB;cAC9D;cAGK0G,KAAA,GAAQzE,IAAA,CAAKyE,KAAA;cACnB,IAAIzE,IAAA,CAAKlD,KAAA,CAAMG,MAAA,GAAS,GAAG;gBACzBwH,KAAA,CAAM/E,GAAA,CAAIiP,YAAA,CAAa3O,IAAA,CAAKlD,KAAA,EAAO,GAAG,OAAOkD,IAAA,CAAKsE,UAAU,CAAC;cAC9D;cAED,IAAItE,IAAA,CAAKlC,YAAA,CAAab,MAAA,GAAS,GAAG;gBAChCwH,KAAA,CAAM/E,GAAA,CAAIiP,YAAA,CAAa3O,IAAA,CAAKlC,YAAA,EAAc,CAAC,CAAC;cAC7C;cAED,IAAIkC,IAAA,CAAKiE,mBAAA,CAAoBhH,MAAA,GAAS,GAAG;gBACvCwH,KAAA,CAAM/E,GAAA,CAAIiP,YAAA,CAAa3O,IAAA,CAAKiE,mBAAA,EAAqB,GAAG,IAAI,CAAC;cAC1D;cAAA,OAAAuH,SAAA,CAAA9F,MAAA,WAEMjB,KAAA;YAAA;YAAA;cAAA,OAAA+G,SAAA,CAAA/E,IAAA;UAAA;QAAA,GAAA0E,QAAA;MAAA,CACR;MAAA,SAAAyD,gBAAAC,GAAA;QAAA,OAAA3D,gBAAA,CAAAtE,KAAA,OAAA5I,SAAA;MAAA;MAAA,OAAA4Q,eAAA;IAAA;EAAA;IAAA3N,GAAA;IAAA/F,KAAA,EAED,SAAA4T,eAAe/J,QAAA,EAAU;MACvB,OAAOA,QAAA,KAAa,QAAQA,QAAA,CAASa,WAAA,CAAa,KAAI,KAAKlC,MAAA;IAC5D;EAAA;IAAAzC,GAAA;IAAA/F,KAAA;MAAA,IAAA6T,eAAA,GAAApK,iBAAA,eAAAC,mBAAA,GAAAC,IAAA,CAED,SAAAmK,SAAqBjK,QAAA;QAAA,IAAA9D,GAAA,EAAAwD,KAAA;QAAA,OAAAG,mBAAA,GAAAS,IAAA,UAAA4J,UAAAC,SAAA;UAAA,kBAAAA,SAAA,CAAA1J,IAAA,GAAA0J,SAAA,CAAAzO,IAAA;YAAA;cAAA,MACfsE,QAAA,KAAa,QAAQ,KAAK+J,cAAA,CAAe/J,QAAQ;gBAAAmK,SAAA,CAAAzO,IAAA;gBAAA;cAAA;cAC7CQ,GAAA,GAAM8D,QAAA,CAASa,WAAA,CAAa;cAAAsJ,SAAA,CAAAzO,IAAA;cAAA,OACd,KAAKiD,MAAA,CAAOzC,GAAG;YAAA;cAA7BwD,KAAA,GAAAyK,SAAA,CAAA5I,IAAA;cAAA,OAAA4I,SAAA,CAAAxJ,MAAA,WACCjB,KAAA,CAAMT,KAAA,CAAO;YAAA;cAAA,OAAAkL,SAAA,CAAAxJ,MAAA,WAEb;YAAA;YAAA;cAAA,OAAAwJ,SAAA,CAAAzI,IAAA;UAAA;QAAA,GAAAuI,QAAA;MAAA,CAEV;MAAA,SAAAG,eAAAC,GAAA;QAAA,OAAAL,eAAA,CAAAnI,KAAA,OAAA5I,SAAA;MAAA;MAAA,OAAAmR,cAAA;IAAA;EAAA;IAAAlO,GAAA;IAAA/F,KAAA;MAAA,IAAAmU,UAAA,GAAA1K,iBAAA,eAAAC,mBAAA,GAAAC,IAAA,CAGD,SAAAyK,SAAgBvK,QAAA;QAAA,IAAAkG,UAAA,EAAAhK,GAAA,EAAAjB,IAAA,EAAAqN,OAAA,EAAA5I,KAAA;QAAA,OAAAG,mBAAA,GAAAS,IAAA,UAAAkK,UAAAC,SAAA;UAAA,kBAAAA,SAAA,CAAAhK,IAAA,GAAAgK,SAAA,CAAA/O,IAAA;YAAA;cACRwK,UAAA,GAAa,KAAKA,UAAA;cAClBhK,GAAA,GAAM8D,QAAA,CAASa,WAAA,CAAa;cAAA,KAC9B,KAAKkJ,cAAA,CAAe/J,QAAQ;gBAAAyK,SAAA,CAAA/O,IAAA;gBAAA;cAAA;cAAA,OAAA+O,SAAA,CAAA9J,MAAA,WAEvB,KAAKyJ,cAAA,CAAepK,QAAQ;YAAA;cAAAyK,SAAA,CAAA/O,IAAA;cAAA,OAI7BwK,UAAA,CAAWR,gBAAA,CAAiB1F,QAAQ;YAAA;cAEpC/E,IAAA,GAAOiL,UAAA,CAAWhB,OAAA,CAAQlF,QAAQ;cAClCsI,OAAA,GAAU,KAAKuB,eAAA,CAAgB5O,IAAI;cAAA,KAKrC,KAAK8O,cAAA,CAAe/J,QAAQ;gBAAAyK,SAAA,CAAA/O,IAAA;gBAAA;cAAA;cAAA,OAAA+O,SAAA,CAAA9J,MAAA,WACvB,KAAKyJ,cAAA,CAAepK,QAAQ;YAAA;cAIrC,IAAI7C,UAAA,CAAWlC,IAAA,CAAKmC,IAAI,GAAG;gBACzB,KAAKuB,MAAA,CAAOzC,GAAG,IAAIoM,OAAA;cACpB;cAAAmC,SAAA,CAAA/O,IAAA;cAAA,OAGmB4M,OAAA;YAAA;cAAd5I,KAAA,GAAA+K,SAAA,CAAAlJ,IAAA;cAAA,OAAAkJ,SAAA,CAAA9J,MAAA,WACCjB,KAAA,CAAMT,KAAA,CAAO;YAAA;YAAA;cAAA,OAAAwL,SAAA,CAAA/I,IAAA;UAAA;QAAA,GAAA6I,QAAA;MAAA,CAEvB;MAAA,SAAA9B,UAAAiC,GAAA;QAAA,OAAAJ,UAAA,CAAAzI,KAAA,OAAA5I,SAAA;MAAA;MAAA,OAAAwP,SAAA;IAAA;EAAA;IAAAvM,GAAA;IAAA/F,KAAA;MAAA,IAAAwU,WAAA,GAAA/K,iBAAA,eAAAC,mBAAA,GAAAC,IAAA,CAGD,SAAA8K,SAAiBvK,IAAA;QAAA,IAAA6F,UAAA,EAAAjL,IAAA;QAAA,OAAA4E,mBAAA,GAAAS,IAAA,UAAAuK,UAAAC,SAAA;UAAA,kBAAAA,SAAA,CAAArK,IAAA,GAAAqK,SAAA,CAAApP,IAAA;YAAA;cACTwK,UAAA,GAAa,KAAKA,UAAA;cAClBjL,IAAA,GAAOiL,UAAA,CAAWpE,KAAA,CAAMzB,IAAI;cAAA,MAC9BlD,UAAA,CAAWlC,IAAA,CAAKmC,IAAI,KAAK,KAAK2M,cAAA,CAAe9O,IAAA,CAAK+E,QAAQ;gBAAA8K,SAAA,CAAApP,IAAA;gBAAA;cAAA;cAAA,OAAAoP,SAAA,CAAAnK,MAAA,WACrD,KAAKyJ,cAAA,CAAenP,IAAA,CAAK+E,QAAQ;YAAA;cAAA,OAAA8K,SAAA,CAAAnK,MAAA,WAGnC,KAAKkJ,eAAA,CAAgB5O,IAAI;YAAA;YAAA;cAAA,OAAA6P,SAAA,CAAApJ,IAAA;UAAA;QAAA,GAAAkJ,QAAA;MAAA,CACjC;MAAA,SAAAG,WAAAC,GAAA;QAAA,OAAAL,WAAA,CAAA9I,KAAA,OAAA5I,SAAA;MAAA;MAAA,OAAA8R,UAAA;IAAA;EAAA;EAAA,OAAA9E,uBAAA;AAAA;AAGH,SAASgF,eAAeC,CAAA,EAAGC,CAAA,EAAG;EAC5B,IAAID,CAAA,CAAElM,SAAA,KAAcmM,CAAA,CAAEnM,SAAA,EAAW;IAC/B,OAAO;EACR;EAED,IAAIkM,CAAA,CAAElM,SAAA,GAAYmM,CAAA,CAAEnM,SAAA,EAAW;IAC7B,OAAO;EACR;EAED,OAAO;AACT;AAEA,SAAS4K,aAAawB,QAAA,EAAUC,WAAA,EAAkE;EAAA,IAArDC,qBAAA,GAAArS,SAAA,CAAAf,MAAA,QAAAe,SAAA,QAAAC,SAAA,GAAAD,SAAA,MAAwB;EAAA,IAAOsS,aAAA,GAAAtS,SAAA,CAAAf,MAAA,QAAAe,SAAA,QAAAC,SAAA,GAAAD,SAAA,MAAgB;EAK1FmS,QAAA,CAASI,IAAA,CAAKP,cAAc;EAE5B,IAAIM,aAAA,KAAkB,MAAM;IAC1BA,aAAA,GAAgBH,QAAA,CAASlT,MAAA;EAC1B;EAED,IAAMuT,SAAA,GAAY,IAAIC,YAAA,CAAaL,WAAA,GAAcE,aAAA,GAAgB,CAAC;EAClE,IAAM9Q,OAAA,GAAU4Q,WAAA,KAAgB,IAAI,IAAIK,YAAA,CAAaL,WAAA,GAAcE,aAAA,GAAgB,CAAC,IAAI;EACxF,IAAM9L,SAAA,GAAY,EAAE;EAEpB,IAAMkM,SAAA,GAAY,IAAIC,KAAA,CAAM,CAAC;EAC7B,IAAMC,cAAA,GAAiB,IAAIC,cAAA,CAAgB;EAC3C,IAAIC,YAAA,GAAe;EACnB,IAAIC,MAAA,GAAS;EACb,IAAIC,aAAA,GAAgB;EACpB,IAAIC,MAAA,GAAS;EAEb,SAASC,KAAA,GAAQ,GAAGC,KAAA,GAAQhB,QAAA,CAASlT,MAAA,EAAQiU,KAAA,GAAQC,KAAA,EAAOD,KAAA,IAAS;IACnE,IAAME,IAAA,GAAOjB,QAAA,CAASe,KAAK;IAC3B,IAAI/T,QAAA,GAAWiU,IAAA,CAAKjU,QAAA;IACpB,IAAIA,QAAA,CAASF,MAAA,KAAW,GAAG;MACzByT,SAAA,CAAU,CAAC,IAAIvT,QAAA,CAAS,CAAC;MACzBuT,SAAA,CAAU,CAAC,IAAIvT,QAAA,CAAS,CAAC;MACzBuT,SAAA,CAAU,CAAC,IAAIvT,QAAA,CAAS,CAAC;MACzBuT,SAAA,CAAU,CAAC,IAAIvT,QAAA,CAAS,CAAC;MACzBuT,SAAA,CAAU,CAAC,IAAIvT,QAAA,CAAS,CAAC;MACzBuT,SAAA,CAAU,CAAC,IAAIvT,QAAA,CAAS,CAAC;MACzBA,QAAA,GAAWuT,SAAA;IACZ;IAED,SAASW,CAAA,GAAI,GAAGrU,CAAA,GAAIG,QAAA,CAASF,MAAA,EAAQoU,CAAA,GAAIrU,CAAA,EAAGqU,CAAA,IAAK;MAC/C,IAAMjT,CAAA,GAAIjB,QAAA,CAASkU,CAAC;MACpB,IAAM7Q,KAAA,GAAQyQ,MAAA,GAASI,CAAA,GAAI;MAC3Bb,SAAA,CAAUhQ,KAAA,GAAQ,CAAC,IAAIpC,CAAA,CAAEC,CAAA;MACzBmS,SAAA,CAAUhQ,KAAA,GAAQ,CAAC,IAAIpC,CAAA,CAAEE,CAAA;MACzBkS,SAAA,CAAUhQ,KAAA,GAAQ,CAAC,IAAIpC,CAAA,CAAEG,CAAA;IAC1B;IAGD,IAAI6R,WAAA,KAAgB,GAAG;MACrB,IAAI,CAACgB,IAAA,CAAK5T,UAAA,EAAY;QACpB,IAAMJ,EAAA,GAAKD,QAAA,CAAS,CAAC;QACrB,IAAME,EAAA,GAAKF,QAAA,CAAS,CAAC;QACrB,IAAMG,EAAA,GAAKH,QAAA,CAAS,CAAC;QACrBnD,SAAA,CAAUuD,UAAA,CAAWF,EAAA,EAAID,EAAE;QAC3BlD,SAAA,CAAUqD,UAAA,CAAWD,EAAA,EAAID,EAAE;QAC3B+T,IAAA,CAAK5T,UAAA,GAAa,IAAIvD,OAAA,CAAS,EAACwD,YAAA,CAAazD,SAAA,EAAWE,SAAS,EAAEwD,SAAA,CAAW;MAC/E;MAED,IAAI4T,WAAA,GAAcF,IAAA,CAAK5R,OAAA;MACvB,IAAI8R,WAAA,CAAYrU,MAAA,KAAW,GAAG;QAC5ByT,SAAA,CAAU,CAAC,IAAIY,WAAA,CAAY,CAAC;QAC5BZ,SAAA,CAAU,CAAC,IAAIY,WAAA,CAAY,CAAC;QAC5BZ,SAAA,CAAU,CAAC,IAAIY,WAAA,CAAY,CAAC;QAC5BZ,SAAA,CAAU,CAAC,IAAIY,WAAA,CAAY,CAAC;QAC5BZ,SAAA,CAAU,CAAC,IAAIY,WAAA,CAAY,CAAC;QAC5BZ,SAAA,CAAU,CAAC,IAAIY,WAAA,CAAY,CAAC;QAC5BA,WAAA,GAAcZ,SAAA;MACf;MAED,SAASW,EAAA,GAAI,GAAGrU,GAAA,GAAIsU,WAAA,CAAYrU,MAAA,EAAQoU,EAAA,GAAIrU,GAAA,EAAGqU,EAAA,IAAK;QAElD,IAAIE,CAAA,GAAIH,IAAA,CAAK5T,UAAA;QACb,IAAI8T,WAAA,CAAYD,EAAC,GAAG;UAClBE,CAAA,GAAID,WAAA,CAAYD,EAAC,EAAEtP,IAAA;QACpB;QAED,IAAMvB,OAAA,GAAQyQ,MAAA,GAASI,EAAA,GAAI;QAC3B7R,OAAA,CAAQgB,OAAA,GAAQ,CAAC,IAAI+Q,CAAA,CAAElT,CAAA;QACvBmB,OAAA,CAAQgB,OAAA,GAAQ,CAAC,IAAI+Q,CAAA,CAAEjT,CAAA;QACvBkB,OAAA,CAAQgB,OAAA,GAAQ,CAAC,IAAI+Q,CAAA,CAAEhT,CAAA;MACxB;IACF;IAED,IAAIuS,YAAA,KAAiBM,IAAA,CAAKrN,SAAA,EAAW;MACnC,IAAI+M,YAAA,KAAiB,MAAM;QACzBF,cAAA,CAAeY,QAAA,CAAST,MAAA,EAAQC,aAAA,EAAexM,SAAA,CAAUvH,MAAA,GAAS,CAAC;MACpE;MAED,IAAMR,QAAA,GAAW2U,IAAA,CAAK3U,QAAA;MACtB,IAAIA,QAAA,KAAa,MAAM;QACrB,IAAI2T,WAAA,KAAgB,GAAG;UACrB5L,SAAA,CAAUpE,IAAA,CAAK3D,QAAQ;QACjC,WAAmB2T,WAAA,KAAgB,GAAG;UAC5B,IAAI3T,QAAA,KAAa,MAAM;YACrB,IAAI4T,qBAAA,EAAuB;cACzB7L,SAAA,CAAUpE,IAAA,CAAK3D,QAAA,CAAS8L,QAAA,CAASkJ,YAAA,CAAalJ,QAAA,CAASmJ,uBAAuB;YAC5F,OAAmB;cACLlN,SAAA,CAAUpE,IAAA,CAAK3D,QAAA,CAAS8L,QAAA,CAASkJ,YAAY;YAC9C;UACb,OAAiB;YACLjN,SAAA,CAAUpE,IAAA,CAAK,IAAI;UACpB;QACF;MACT,OAAa;QAGLoE,SAAA,CAAUpE,IAAA,CAAKgR,IAAA,CAAKrN,SAAS;MAC9B;MAED+M,YAAA,GAAeM,IAAA,CAAKrN,SAAA;MACpBgN,MAAA,GAASE,MAAA,GAAS;MAClBD,aAAA,GAAgB7T,QAAA,CAASF,MAAA;IAC/B,OAAW;MACL+T,aAAA,IAAiB7T,QAAA,CAASF,MAAA;IAC3B;IAEDgU,MAAA,IAAU,IAAI9T,QAAA,CAASF,MAAA;EACxB;EAED,IAAI+T,aAAA,GAAgB,GAAG;IACrBJ,cAAA,CAAeY,QAAA,CAAST,MAAA,EAAQY,QAAA,EAAUnN,SAAA,CAAUvH,MAAA,GAAS,CAAC;EAC/D;EAED2T,cAAA,CAAegB,YAAA,CAAa,YAAY,IAAIC,eAAA,CAAgBrB,SAAA,EAAW,CAAC,CAAC;EAEzE,IAAIhR,OAAA,KAAY,MAAM;IACpBoR,cAAA,CAAegB,YAAA,CAAa,UAAU,IAAIC,eAAA,CAAgBrS,OAAA,EAAS,CAAC,CAAC;EACtE;EAED,IAAIsS,QAAA,GAAW;EAEf,IAAI1B,WAAA,KAAgB,GAAG;IACrB,IAAIC,qBAAA,EAAuB;MACzByB,QAAA,GAAW,IAAIzV,uBAAA,CAAwBuU,cAAA,EAAgBpM,SAAA,CAAUvH,MAAA,KAAW,IAAIuH,SAAA,CAAU,CAAC,IAAIA,SAAS;IAC9G,OAAW;MACLsN,QAAA,GAAW,IAAIlV,YAAA,CAAagU,cAAA,EAAgBpM,SAAA,CAAUvH,MAAA,KAAW,IAAIuH,SAAA,CAAU,CAAC,IAAIA,SAAS;IAC9F;EACL,WAAa4L,WAAA,KAAgB,GAAG;IAC5B0B,QAAA,GAAW,IAAIC,IAAA,CAAKnB,cAAA,EAAgBpM,SAAA,CAAUvH,MAAA,KAAW,IAAIuH,SAAA,CAAU,CAAC,IAAIA,SAAS;EACtF;EAED,IAAI6L,qBAAA,EAAuB;IACzByB,QAAA,CAASnV,iBAAA,GAAoB;IAE7B,IAAMqV,aAAA,GAAgB,IAAIvB,YAAA,CAAaN,QAAA,CAASlT,MAAA,GAAS,IAAI,CAAC;IAC9D,IAAMgV,aAAA,GAAgB,IAAIxB,YAAA,CAAaN,QAAA,CAASlT,MAAA,GAAS,IAAI,CAAC;IAC9D,IAAMiV,cAAA,GAAiB,IAAIzB,YAAA,CAAaN,QAAA,CAASlT,MAAA,GAAS,IAAI,CAAC;IAC/D,SAASF,CAAA,GAAI,GAAGC,GAAA,GAAImT,QAAA,CAASlT,MAAA,EAAQF,CAAA,GAAIC,GAAA,EAAGD,CAAA,IAAK;MAC/C,IAAM6P,EAAA,GAAKuD,QAAA,CAASpT,CAAC;MACrB,IAAMI,UAAA,GAAWyP,EAAA,CAAGzP,QAAA;MACpB,IAAM+G,aAAA,GAAgB0I,EAAA,CAAG1I,aAAA;MACzB,IAAMiE,EAAA,GAAKjE,aAAA,CAAc,CAAC;MAC1B,IAAMkE,EAAA,GAAKlE,aAAA,CAAc,CAAC;MAC1B,IAAM9G,GAAA,GAAKD,UAAA,CAAS,CAAC;MACrB,IAAME,GAAA,GAAKF,UAAA,CAAS,CAAC;MACrB,IAAMqD,OAAA,GAAQzD,CAAA,GAAI,IAAI;MACtBiV,aAAA,CAAcxR,OAAA,GAAQ,CAAC,IAAI2H,EAAA,CAAG9J,CAAA;MAC9B2T,aAAA,CAAcxR,OAAA,GAAQ,CAAC,IAAI2H,EAAA,CAAG7J,CAAA;MAC9B0T,aAAA,CAAcxR,OAAA,GAAQ,CAAC,IAAI2H,EAAA,CAAG5J,CAAA;MAC9ByT,aAAA,CAAcxR,OAAA,GAAQ,CAAC,IAAI2H,EAAA,CAAG9J,CAAA;MAC9B2T,aAAA,CAAcxR,OAAA,GAAQ,CAAC,IAAI2H,EAAA,CAAG7J,CAAA;MAC9B0T,aAAA,CAAcxR,OAAA,GAAQ,CAAC,IAAI2H,EAAA,CAAG5J,CAAA;MAE9B0T,aAAA,CAAczR,OAAA,GAAQ,CAAC,IAAI4H,EAAA,CAAG/J,CAAA;MAC9B4T,aAAA,CAAczR,OAAA,GAAQ,CAAC,IAAI4H,EAAA,CAAG9J,CAAA;MAC9B2T,aAAA,CAAczR,OAAA,GAAQ,CAAC,IAAI4H,EAAA,CAAG7J,CAAA;MAC9B0T,aAAA,CAAczR,OAAA,GAAQ,CAAC,IAAI4H,EAAA,CAAG/J,CAAA;MAC9B4T,aAAA,CAAczR,OAAA,GAAQ,CAAC,IAAI4H,EAAA,CAAG9J,CAAA;MAC9B2T,aAAA,CAAczR,OAAA,GAAQ,CAAC,IAAI4H,EAAA,CAAG7J,CAAA;MAE9B2T,cAAA,CAAe1R,OAAA,GAAQ,CAAC,IAAInD,GAAA,CAAGgB,CAAA,GAAIjB,GAAA,CAAGiB,CAAA;MACtC6T,cAAA,CAAe1R,OAAA,GAAQ,CAAC,IAAInD,GAAA,CAAGiB,CAAA,GAAIlB,GAAA,CAAGkB,CAAA;MACtC4T,cAAA,CAAe1R,OAAA,GAAQ,CAAC,IAAInD,GAAA,CAAGkB,CAAA,GAAInB,GAAA,CAAGmB,CAAA;MACtC2T,cAAA,CAAe1R,OAAA,GAAQ,CAAC,IAAInD,GAAA,CAAGgB,CAAA,GAAIjB,GAAA,CAAGiB,CAAA;MACtC6T,cAAA,CAAe1R,OAAA,GAAQ,CAAC,IAAInD,GAAA,CAAGiB,CAAA,GAAIlB,GAAA,CAAGkB,CAAA;MACtC4T,cAAA,CAAe1R,OAAA,GAAQ,CAAC,IAAInD,GAAA,CAAGkB,CAAA,GAAInB,GAAA,CAAGmB,CAAA;IACvC;IAEDqS,cAAA,CAAegB,YAAA,CAAa,YAAY,IAAIC,eAAA,CAAgBG,aAAA,EAAe,GAAG,KAAK,CAAC;IACpFpB,cAAA,CAAegB,YAAA,CAAa,YAAY,IAAIC,eAAA,CAAgBI,aAAA,EAAe,GAAG,KAAK,CAAC;IACpFrB,cAAA,CAAegB,YAAA,CAAa,aAAa,IAAIC,eAAA,CAAgBK,cAAA,EAAgB,GAAG,KAAK,CAAC;EACvF;EAED,OAAOJ,QAAA;AACT;AAAA,IAIMK,WAAA,0BAAAC,OAAA;EAAA/X,SAAA,CAAA8X,WAAA,EAAAC,OAAA;EAAA,IAAAC,OAAA,GAAA9X,YAAA,CAAA4X,WAAA;EACJ,SAAAA,YAAYrM,OAAA,EAAS;IAAA,IAAAwM,MAAA;IAAA5X,eAAA,OAAAyX,WAAA;IACnBG,MAAA,GAAAD,OAAA,CAAA1X,IAAA,OAAMmL,OAAO;IAGbwM,MAAA,CAAK9N,SAAA,GAAY,EAAE;IACnB8N,MAAA,CAAKC,eAAA,GAAkB,CAAE;IAGzBD,MAAA,CAAKE,UAAA,GAAa,IAAIxH,uBAAA,CAAAnP,sBAAA,CAAAyW,MAAA,CAA4B;IAGlDA,MAAA,CAAKvI,OAAA,GAAU,CAAE;IAGjBuI,MAAA,CAAKG,YAAA,CAAa,EAAE;IAGpBH,MAAA,CAAKzU,aAAA,GAAgB;IAGrByU,MAAA,CAAKtM,gBAAA,GAAmB;IAAA,OAAAsM,MAAA;EACzB;EAAAnW,YAAA,CAAAgW,WAAA;IAAAlR,GAAA;IAAA/F,KAAA,EAED,SAAAwX,oBAAoBC,IAAA,EAAM;MACxB,KAAK3M,gBAAA,GAAmB2M,IAAA;MACxB,OAAO;IACR;EAAA;IAAA1R,GAAA;IAAA/F,KAAA;MAAA,IAAA0X,iBAAA,GAAAjO,iBAAA,eAAAC,mBAAA,GAAAC,IAAA,CAED,SAAAgO,SAAuBC,GAAA;QAAA,IAAA3N,UAAA,EAAAC,IAAA,EAAA2N,cAAA,EAAA/L,KAAA,EAAAxC,SAAA,EAAAzH,CAAA,EAAAC,CAAA,EAAAuF,IAAA,EAAAyQ,SAAA,EAAAvW,QAAA;QAAA,OAAAmI,mBAAA,GAAAS,IAAA,UAAA4N,UAAAC,SAAA;UAAA,kBAAAA,SAAA,CAAA1N,IAAA,GAAA0N,SAAA,CAAAzS,IAAA;YAAA;cACf0E,UAAA,GAAa,IAAIU,UAAA,CAAW,KAAKC,OAAO;cAC9CX,UAAA,CAAWY,OAAA,CAAQ,KAAK4M,IAAI;cAC5BxN,UAAA,CAAWc,gBAAA,CAAiB,KAAKC,aAAa;cAC9Cf,UAAA,CAAWgB,kBAAA,CAAmB,KAAKC,eAAe;cAAA8M,SAAA,CAAAzS,IAAA;cAAA,OAE/B0E,UAAA,CAAWkB,SAAA,CAAUyM,GAAG;YAAA;cAArC1N,IAAA,GAAA8N,SAAA,CAAA5M,IAAA;cACAyM,cAAA,GAAiB;cACjB/L,KAAA,GAAQ5B,IAAA,CAAK6B,KAAA,CAAM,SAAS;cAC5BzC,SAAA,GAAY,EAAE;cACpB,KAASzH,CAAA,GAAI,GAAGC,CAAA,GAAIgK,KAAA,CAAM/J,MAAA,EAAQF,CAAA,GAAIC,CAAA,EAAGD,CAAA,IAAK;gBACtCwF,IAAA,GAAOyE,KAAA,CAAMjK,CAAC;gBACpB,IAAIgW,cAAA,CAAe1Q,IAAA,CAAKE,IAAI,GAAG;kBACvByQ,SAAA,GAAYzQ,IAAA,CAAK7G,OAAA,CAAQqX,cAAA,EAAgB,EAAE;kBAC3CtW,QAAA,GAAW,KAAK6L,uBAAA,CAAwB,IAAIhG,UAAA,CAAW0Q,SAAS,CAAC;kBACvExO,SAAA,CAAUpE,IAAA,CAAK3D,QAAQ;gBACxB;cACF;cAED,KAAKgW,YAAA,CAAajO,SAAS;YAAA;YAAA;cAAA,OAAA0O,SAAA,CAAAzM,IAAA;UAAA;QAAA,GAAAoM,QAAA;MAAA,CAC5B;MAAA,SAAAM,iBAAAC,GAAA;QAAA,OAAAR,iBAAA,CAAAhM,KAAA,OAAA5I,SAAA;MAAA;MAAA,OAAAmV,gBAAA;IAAA;EAAA;IAAAlS,GAAA;IAAA/F,KAAA,EAED,SAAAmY,KAAKP,GAAA,EAAKQ,MAAA,EAAQC,UAAA,EAAYC,OAAA,EAAS;MAAA,IAAAC,MAAA;MACrC,IAAMtO,UAAA,GAAa,IAAIU,UAAA,CAAW,KAAKC,OAAO;MAC9CX,UAAA,CAAWY,OAAA,CAAQ,KAAK4M,IAAI;MAC5BxN,UAAA,CAAWc,gBAAA,CAAiB,KAAKC,aAAa;MAC9Cf,UAAA,CAAWgB,kBAAA,CAAmB,KAAKC,eAAe;MAClDjB,UAAA,CAAWkO,IAAA,CACTP,GAAA,EACA,UAAC1N,IAAA,EAAS;QACRqO,MAAA,CAAKjB,UAAA,CACF1C,UAAA,CAAW1K,IAAA,EAAMqO,MAAA,CAAKlB,eAAe,EACrC/H,IAAA,CAAK,UAAC/F,KAAA,EAAU;UACfgP,MAAA,CAAKrF,oBAAA,CAAqB3J,KAAA,EAAO3K,gBAAA,EAAkB2Z,MAAA,CAAKlB,eAAA,EAAiB,IAAI;UAC7EkB,MAAA,CAAKC,wBAAA,CAAyBjP,KAAK;UACnC6O,MAAA,CAAO7O,KAAK;QACxB,CAAW,EACAgJ,KAAA,CAAM+F,OAAO;MACjB,GACDD,UAAA,EACAC,OACD;IACF;EAAA;IAAAvS,GAAA;IAAA/F,KAAA,EAED,SAAA2L,MAAMzB,IAAA,EAAMkO,MAAA,EAAQ;MAAA,IAAAK,MAAA;MAClB,KAAKnB,UAAA,CAAW1C,UAAA,CAAW1K,IAAA,EAAM,KAAKmN,eAAe,EAAE/H,IAAA,CAAK,UAAC/F,KAAA,EAAU;QACrEkP,MAAA,CAAKD,wBAAA,CAAyBjP,KAAK;QACnC6O,MAAA,CAAO7O,KAAK;MAClB,CAAK;IACF;EAAA;IAAAxD,GAAA;IAAA/F,KAAA,EAED,SAAAuX,aAAajO,SAAA,EAAW;MACtB,KAAK+N,eAAA,GAAkB,CAAE;MACzB,KAAK/N,SAAA,GAAY,EAAE;MACnB,SAASzH,CAAA,GAAI,GAAGC,CAAA,GAAIwH,SAAA,CAAUvH,MAAA,EAAQF,CAAA,GAAIC,CAAA,EAAGD,CAAA,IAAK;QAChD,KAAK6W,WAAA,CAAYpP,SAAA,CAAUzH,CAAC,CAAC;MAC9B;MAGD,KAAK6W,WAAA,CAAY,KAAKtL,uBAAA,CAAwB,IAAIhG,UAAA,CAAW,gDAAgD,CAAC,CAAC;MAC/G,KAAKsR,WAAA,CAAY,KAAKtL,uBAAA,CAAwB,IAAIhG,UAAA,CAAW,gDAAgD,CAAC,CAAC;MAE/G,OAAO;IACR;EAAA;IAAArB,GAAA;IAAA/F,KAAA,EAED,SAAA2Y,WAAW9J,OAAA,EAAS;MAClB,KAAKA,OAAA,GAAUA,OAAA;MAEf,OAAO;IACR;EAAA;IAAA9I,GAAA;IAAA/F,KAAA,EAED,SAAA0Y,YAAYnX,QAAA,EAAU;MAGpB,IAAMqX,MAAA,GAAS,KAAKvB,eAAA;MACpB,IAAI,CAACuB,MAAA,CAAOrX,QAAA,CAAS8L,QAAA,CAASC,IAAI,GAAG;QACnC,KAAKhE,SAAA,CAAUpE,IAAA,CAAK3D,QAAQ;QAC5BqX,MAAA,CAAOrX,QAAA,CAAS8L,QAAA,CAASC,IAAI,IAAI/L,QAAA;MAClC;MAED,OAAO;IACR;EAAA;IAAAwE,GAAA;IAAA/F,KAAA,EAED,SAAA6Y,YAAYhQ,SAAA,EAAW;MACrB,IAAIA,SAAA,CAAU4D,UAAA,CAAW,KAAK,GAAG;QAE/B,IAAM3L,KAAA,GAAQ+H,SAAA,CAAUd,SAAA,CAAU,CAAC;QAEnC,OAAO,KAAKqF,uBAAA,CACV,IAAIhG,UAAA,CAAW,kBAAkBtG,KAAA,GAAQ,qBAAqBA,KAAA,GAAQ,YAAYA,KAAU,CAC7F;MACF;MAED,OAAO,KAAKuW,eAAA,CAAgBxO,SAAS,KAAK;IAC3C;IAAA;IAAA;EAAA;IAAA9C,GAAA;IAAA/F,KAAA,EAID,SAAAkT,qBAAqB3J,KAAA,EAAOmG,eAAA,EAAiBC,iBAAA,EAA8C;MAAA,IAA3BmJ,iBAAA,GAAAhW,SAAA,CAAAf,MAAA,QAAAe,SAAA,QAAAC,SAAA,GAAAD,SAAA,MAAoB;MAElF,IAAMyF,MAAA,GAAS;MACf,IAAMwQ,mBAAA,GAAsBrJ,eAAA,KAAoB9Q,gBAAA;MAChD2K,KAAA,CAAMyP,QAAA,CAAS,UAACC,CAAA,EAAM;QACpB,IAAIA,CAAA,CAAEC,MAAA,IAAUD,CAAA,CAAEE,cAAA,EAAgB;UAChC,IAAI1D,KAAA,CAAM2D,OAAA,CAAQH,CAAA,CAAE1X,QAAQ,GAAG;YAC7B,SAASM,CAAA,GAAI,GAAGC,CAAA,GAAImX,CAAA,CAAE1X,QAAA,CAASQ,MAAA,EAAQF,CAAA,GAAIC,CAAA,EAAGD,CAAA,IAAK;cACjD,IAAI,CAACoX,CAAA,CAAE1X,QAAA,CAASM,CAAC,EAAEwX,UAAA,EAAY;gBAC7BJ,CAAA,CAAE1X,QAAA,CAASM,CAAC,IAAIgX,WAAA,CAAYI,CAAA,EAAGA,CAAA,CAAE1X,QAAA,CAASM,CAAC,CAAC;cAC7C;YACF;UACF,WAAU,CAACoX,CAAA,CAAE1X,QAAA,CAAS8X,UAAA,EAAY;YACjCJ,CAAA,CAAE1X,QAAA,GAAWsX,WAAA,CAAYI,CAAA,EAAGA,CAAA,CAAE1X,QAAQ;UACvC;QACF;MACP,CAAK;MAKD,SAASsX,YAAYI,CAAA,EAAGpQ,SAAA,EAAW;QAGjC,IAAIkQ,mBAAA,IAAuB,EAAElQ,SAAA,IAAa8G,iBAAA,KAAsB,CAACmJ,iBAAA,EAAmB;UAClF,OAAOjQ,SAAA;QACR;QAED,IAAM+G,OAAA,GAAUqJ,CAAA,CAAEE,cAAA,IAAkBF,CAAA,CAAExX,iBAAA;QACtC,IAAMoO,aAAA,GACH,CAACD,OAAA,IAAW/G,SAAA,KAAcjK,gBAAA,IAAsBgR,OAAA,IAAW/G,SAAA,KAAchK,qBAAA;QAC5E,IAAIgR,aAAA,EAAe;UACjBhH,SAAA,GAAY6G,eAAA;QACb;QAED,IAAInO,QAAA,GAAW;QACf,IAAIsH,SAAA,IAAa8G,iBAAA,EAAmB;UAClCpO,QAAA,GAAWoO,iBAAA,CAAkB9G,SAAS;QACvC,WAAUiQ,iBAAA,EAAmB;UAG5BvX,QAAA,GAAWgH,MAAA,CAAOsQ,WAAA,CAAYhQ,SAAS;UACvC,IAAItH,QAAA,KAAa,MAAM;YAErB,MAAM,IAAI+J,KAAA,8CAAAjL,MAAA,CAAmDwI,SAAA,oBAA0B;UACxF;QACT,OAAa;UACL,OAAOA,SAAA;QACR;QAED,IAAIoQ,CAAA,CAAEE,cAAA,EAAgB;UACpB5X,QAAA,GAAWA,QAAA,CAAS8L,QAAA,CAASkJ,YAAA;UAE7B,IAAI0C,CAAA,CAAExX,iBAAA,EAAmB;YACvBF,QAAA,GAAWA,QAAA,CAAS8L,QAAA,CAASmJ,uBAAA;UAC9B;QACF;QAED,OAAOjV,QAAA;MACR;IACF;EAAA;IAAAwE,GAAA;IAAA/F,KAAA,EAED,SAAAsZ,gBAAA,EAAkB;MAChB,OAAO,KAAKT,WAAA,CAAYja,gBAAgB;IACzC;EAAA;IAAAmH,GAAA;IAAA/F,KAAA,EAED,SAAAuZ,oBAAA,EAAsB;MACpB,OAAO,KAAKV,WAAA,CAAYha,qBAAqB;IAC9C;EAAA;IAAAkH,GAAA;IAAA/F,KAAA,EAED,SAAAoN,wBAAwBoM,UAAA,EAAY;MAGlC,IAAIlM,IAAA,GAAO;MAGX,IAAIxM,KAAA,GAAQ;MACZ,IAAI2Y,SAAA,GAAY;MAGhB,IAAIC,KAAA,GAAQ;MACZ,IAAIC,aAAA,GAAgB;MAEpB,IAAIC,SAAA,GAAY;MAEhB,IAAIC,UAAA,GAAa9b,mBAAA;MAEjB,IAAIwY,YAAA,GAAe;MAEnB,IAAMtD,IAAA,GAAOuG,UAAA,CAAW5R,QAAA,CAAU;MAClC,IAAI,CAACqL,IAAA,EAAM;QACT,MAAM,IAAI3H,KAAA,CACR,+DAA+DkO,UAAA,CAAWnR,mBAAA,CAAmB,IAAK,GACnG;MACF;MAGD,IAAIwF,KAAA,GAAQ;MACZ,OAAO,MAAM;QACXA,KAAA,GAAQ2L,UAAA,CAAW5R,QAAA,CAAU;QAE7B,IAAI,CAACiG,KAAA,EAAO;UACV;QACD;QAED,QAAQA,KAAA,CAAMiM,WAAA,CAAa;UACzB,KAAK;YACHxM,IAAA,GAAOkM,UAAA,CAAW5R,QAAA,CAAU;YAC5B;UAEF,KAAK;YACH9G,KAAA,GAAQ0Y,UAAA,CAAW5R,QAAA,CAAU;YAC7B,IAAI9G,KAAA,CAAM2L,UAAA,CAAW,IAAI,GAAG;cAC1B3L,KAAA,GAAQ,MAAMA,KAAA,CAAMiH,SAAA,CAAU,CAAC;YAChC,WAAU,CAACjH,KAAA,CAAM2L,UAAA,CAAW,GAAG,GAAG;cACjC,MAAM,IAAInB,KAAA,CACR,sDAAsDkO,UAAA,CAAWnR,mBAAA,CAAmB,IAAK,GAC1F;YACF;YAED;UAEF,KAAK;YACHoR,SAAA,GAAYD,UAAA,CAAW5R,QAAA,CAAU;YACjC,IAAI6R,SAAA,CAAUhN,UAAA,CAAW,IAAI,GAAG;cAC9BgN,SAAA,GAAY,MAAMA,SAAA,CAAU1R,SAAA,CAAU,CAAC;YACxC,WAAU,CAAC0R,SAAA,CAAUhN,UAAA,CAAW,GAAG,GAAG;cAErC8J,YAAA,GAAe,KAAKsC,WAAA,CAAYY,SAAS;cACzC,IAAI,CAAClD,YAAA,EAAc;gBACjB,MAAM,IAAIjL,KAAA,CACR,2DAA2DkO,UAAA,CAAWnR,mBAAA,CAAmB,IAAK,GAC/F;cACF;cAGDkO,YAAA,GAAeA,YAAA,CAAalJ,QAAA,CAASkJ,YAAA;YACtC;YAED;UAEF,KAAK;YACHmD,KAAA,GAAQpZ,QAAA,CAASkZ,UAAA,CAAW5R,QAAA,EAAU;YAEtC,IAAImS,KAAA,CAAML,KAAK,GAAG;cAChB,MAAM,IAAIpO,KAAA,CACR,4DAA4DkO,UAAA,CAAWnR,mBAAA,CAAmB,IAAK,GAChG;YACF;YAEDqR,KAAA,GAAQhT,IAAA,CAAKsT,GAAA,CAAI,GAAGtT,IAAA,CAAKuT,GAAA,CAAI,GAAGP,KAAA,GAAQ,GAAG,CAAC;YAE5C,IAAIA,KAAA,GAAQ,GAAG;cACbC,aAAA,GAAgB;YACjB;YAED;UAEF,KAAK;YACHC,SAAA,GAAYtZ,QAAA,CAASkZ,UAAA,CAAW5R,QAAA,EAAU;YAE1C,IAAImS,KAAA,CAAMH,SAAS,GAAG;cACpB,MAAM,IAAItO,KAAA,CACR,gEAAgElE,UAAA,CAAWiB,mBAAA,CAAmB,IAAK,GACpG;YACF;YAEDuR,SAAA,GAAYlT,IAAA,CAAKsT,GAAA,CAAI,GAAGtT,IAAA,CAAKuT,GAAA,CAAI,GAAGL,SAAA,GAAY,GAAG,CAAC;YAEpD;UAEF,KAAK;YACHC,UAAA,GAAa7b,kBAAA;YACb;UAEF,KAAK;YACH6b,UAAA,GAAa5b,uBAAA;YACb;UAEF,KAAK;YACH4b,UAAA,GAAa3b,kBAAA;YACb;UAEF,KAAK;YACH2b,UAAA,GAAa1b,0BAAA;YACb;UAEF,KAAK;YACH0b,UAAA,GAAazb,iBAAA;YACb;UAEF,KAAK;YAEHob,UAAA,CAAWpR,QAAA,CAAU;YACrB;UAEF;YACE,MAAM,IAAIkD,KAAA,CACR,iCACEuC,KAAA,GACA,6BACA2L,UAAA,CAAWnR,mBAAA,CAAqB,IAChC,GACH;QACJ;MACF;MAED,IAAI9G,QAAA,GAAW;MAEf,QAAQsY,UAAA;QACN,KAAK9b,mBAAA;UACHwD,QAAA,GAAW,IAAI2Y,oBAAA,CAAqB;YAAEpZ,KAAA,EAAAA,KAAA;YAAcqZ,SAAA,EAAW;YAAKC,SAAA,EAAW;UAAA,CAAG;UAClF;QAEF,KAAKnc,uBAAA;UAEHsD,QAAA,GAAW,IAAI2Y,oBAAA,CAAqB;YAAEpZ,KAAA,EAAAA,KAAA;YAAcqZ,SAAA,EAAW;YAAKC,SAAA,EAAW;UAAA,CAAM;UACrF;QAEF,KAAKpc,kBAAA;UAEHuD,QAAA,GAAW,IAAI2Y,oBAAA,CAAqB;YAAEpZ,KAAA,EAAAA,KAAA;YAAcqZ,SAAA,EAAW;YAAGC,SAAA,EAAW;UAAA,CAAG;UAChF;QAEF,KAAKlc,kBAAA;UAEHqD,QAAA,GAAW,IAAI2Y,oBAAA,CAAqB;YAAEpZ,KAAA,EAAAA,KAAA;YAAcqZ,SAAA,EAAW;YAAKC,SAAA,EAAW;UAAA,CAAG;UAClF;QAEF,KAAKjc,0BAAA;UAEHoD,QAAA,GAAW,IAAI2Y,oBAAA,CAAqB;YAAEpZ,KAAA,EAAAA,KAAA;YAAcqZ,SAAA,EAAW;YAAKC,SAAA,EAAW;UAAA,CAAK;UACpF;QAEF,KAAKhc,iBAAA;UAEHmD,QAAA,GAAW,IAAI2Y,oBAAA,CAAqB;YAAEpZ,KAAA,EAAAA,KAAA;YAAcqZ,SAAA,EAAW;YAAKC,SAAA,EAAW;UAAA,CAAM;UACrF;MAKH;MAED7Y,QAAA,CAAS8Y,WAAA,GAAcV,aAAA;MACvBpY,QAAA,CAAS+Y,kBAAA,GAAqB;MAC9B/Y,QAAA,CAASrB,OAAA,GAAUwZ,KAAA;MACnBnY,QAAA,CAASgZ,UAAA,GAAa,CAACZ,aAAA;MAEvBpY,QAAA,CAASiZ,aAAA,GAAgB;MACzBjZ,QAAA,CAASkZ,mBAAA,GAAsB;MAE/B,IAAIb,SAAA,KAAc,GAAG;QACnBrY,QAAA,CAASmZ,QAAA,CAAS7Z,GAAA,CAAIU,QAAA,CAAST,KAAK,EAAE6Z,cAAA,CAAef,SAAS;MAC/D;MAED,IAAI,CAACrD,YAAA,EAAc;QAEjBA,YAAA,GAAe,IAAIqE,iBAAA,CAAkB;UACnC9Z,KAAA,EAAO2Y,SAAA;UACPY,WAAA,EAAaV,aAAA;UACbzZ,OAAA,EAASwZ,KAAA;UACTa,UAAA,EAAY,CAACZ;QACrB,CAAO;QACDpD,YAAA,CAAalJ,QAAA,CAASC,IAAA,GAAOA,IAAA;QAC7BiJ,YAAA,CAAatD,IAAA,GAAOA,IAAA,GAAO;QAG3BsD,YAAA,CAAalJ,QAAA,CAASmJ,uBAAA,GAA0B,IAAIvX,4BAAA,CAA6B;UAC/Ea,GAAA,EAAK;UACLua,WAAA,EAAaV,aAAA;UACbY,UAAA,EAAY,CAACZ,aAAA;UACb7Y,KAAA,EAAO2Y,SAAA;UACPvZ,OAAA,EAASwZ;QACjB,CAAO;MACF;MAEDnY,QAAA,CAAS8L,QAAA,CAASC,IAAA,GAAOA,IAAA;MACzB/L,QAAA,CAAS0R,IAAA,GAAOA,IAAA;MAEhB1R,QAAA,CAAS8L,QAAA,CAASkJ,YAAA,GAAeA,YAAA;MAEjC,KAAKmC,WAAA,CAAYnX,QAAQ;MAEzB,OAAOA,QAAA;IACR;EAAA;IAAAwE,GAAA;IAAA/F,KAAA,EAED,SAAAwY,yBAAyBqC,KAAA,EAAO;MAG9B,IAAIC,UAAA,GAAa;MAEjBD,KAAA,CAAM7B,QAAA,CAAS,UAACC,CAAA,EAAM;QACpB,IAAIA,CAAA,CAAErG,OAAA,EAAS;UACb,IAAIqG,CAAA,CAAE5L,QAAA,CAAShE,wBAAA,EAA0B;YACvCyR,UAAA;UACD;UAED7B,CAAA,CAAE5L,QAAA,CAAS0N,gBAAA,GAAmBD,UAAA;QAC/B;MACP,CAAK;MAEDD,KAAA,CAAMxN,QAAA,CAAS2N,oBAAA,GAAuBF,UAAA,GAAa;IACpD;EAAA;EAAA,OAAA7D,WAAA;AAAA,EA9auBgE,MAAA"},"metadata":{},"sourceType":"module","externalDependencies":[]}