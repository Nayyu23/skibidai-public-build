{"ast":null,"code":"import _slicedToArray from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _classCallCheck from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _inherits from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport { Loader, FileLoader, Matrix3, Vector2, Vector3, ShapeUtils, Box2, Shape, Path, BufferGeometry, Float32BufferAttribute, ShapePath } from \"three\";\nvar COLOR_SPACE_SVG = \"srgb\";\nvar SVGLoader = /*#__PURE__*/function (_Loader) {\n  _inherits(SVGLoader, _Loader);\n  var _super = _createSuper(SVGLoader);\n  function SVGLoader(manager) {\n    var _this;\n    _classCallCheck(this, SVGLoader);\n    _this = _super.call(this, manager);\n    _this.defaultDPI = 90;\n    _this.defaultUnit = \"px\";\n    return _this;\n  }\n  _createClass(SVGLoader, [{\n    key: \"load\",\n    value: function load(url, onLoad, onProgress, onError) {\n      var scope = this;\n      var loader = new FileLoader(scope.manager);\n      loader.setPath(scope.path);\n      loader.setRequestHeader(scope.requestHeader);\n      loader.setWithCredentials(scope.withCredentials);\n      loader.load(url, function (text) {\n        try {\n          onLoad(scope.parse(text));\n        } catch (e) {\n          if (onError) {\n            onError(e);\n          } else {\n            console.error(e);\n          }\n          scope.manager.itemError(url);\n        }\n      }, onProgress, onError);\n    }\n  }, {\n    key: \"parse\",\n    value: function parse(text) {\n      var scope = this;\n      function parseNode(node, style) {\n        if (node.nodeType !== 1) return;\n        var transform = getNodeTransform(node);\n        var isDefsNode = false;\n        var path = null;\n        switch (node.nodeName) {\n          case \"svg\":\n            style = parseStyle(node, style);\n            break;\n          case \"style\":\n            parseCSSStylesheet(node);\n            break;\n          case \"g\":\n            style = parseStyle(node, style);\n            break;\n          case \"path\":\n            style = parseStyle(node, style);\n            if (node.hasAttribute(\"d\")) path = parsePathNode(node);\n            break;\n          case \"rect\":\n            style = parseStyle(node, style);\n            path = parseRectNode(node);\n            break;\n          case \"polygon\":\n            style = parseStyle(node, style);\n            path = parsePolygonNode(node);\n            break;\n          case \"polyline\":\n            style = parseStyle(node, style);\n            path = parsePolylineNode(node);\n            break;\n          case \"circle\":\n            style = parseStyle(node, style);\n            path = parseCircleNode(node);\n            break;\n          case \"ellipse\":\n            style = parseStyle(node, style);\n            path = parseEllipseNode(node);\n            break;\n          case \"line\":\n            style = parseStyle(node, style);\n            path = parseLineNode(node);\n            break;\n          case \"defs\":\n            isDefsNode = true;\n            break;\n          case \"use\":\n            style = parseStyle(node, style);\n            var href = node.getAttributeNS(\"http://www.w3.org/1999/xlink\", \"href\") || \"\";\n            var usedNodeId = href.substring(1);\n            var usedNode = node.viewportElement.getElementById(usedNodeId);\n            if (usedNode) {\n              parseNode(usedNode, style);\n            } else {\n              console.warn(\"SVGLoader: 'use node' references non-existent node id: \" + usedNodeId);\n            }\n            break;\n        }\n        if (path) {\n          if (style.fill !== void 0 && style.fill !== \"none\") {\n            path.color.setStyle(style.fill, COLOR_SPACE_SVG);\n          }\n          transformPath(path, currentTransform);\n          paths.push(path);\n          path.userData = {\n            node: node,\n            style: style\n          };\n        }\n        var childNodes = node.childNodes;\n        for (var i = 0; i < childNodes.length; i++) {\n          var node2 = childNodes[i];\n          if (isDefsNode && node2.nodeName !== \"style\" && node2.nodeName !== \"defs\") {\n            continue;\n          }\n          parseNode(node2, style);\n        }\n        if (transform) {\n          transformStack.pop();\n          if (transformStack.length > 0) {\n            currentTransform.copy(transformStack[transformStack.length - 1]);\n          } else {\n            currentTransform.identity();\n          }\n        }\n      }\n      function parsePathNode(node) {\n        var path = new ShapePath();\n        var point = new Vector2();\n        var control = new Vector2();\n        var firstPoint = new Vector2();\n        var isFirstPoint = true;\n        var doSetFirstPoint = false;\n        var d = node.getAttribute(\"d\");\n        if (d === \"\" || d === \"none\") return null;\n        var commands = d.match(/[a-df-z][^a-df-z]*/gi);\n        for (var i = 0, l = commands.length; i < l; i++) {\n          var command = commands[i];\n          var type = command.charAt(0);\n          var data2 = command.slice(1).trim();\n          if (isFirstPoint === true) {\n            doSetFirstPoint = true;\n            isFirstPoint = false;\n          }\n          var numbers = void 0;\n          switch (type) {\n            case \"M\":\n              numbers = parseFloats(data2);\n              for (var j = 0, jl = numbers.length; j < jl; j += 2) {\n                point.x = numbers[j + 0];\n                point.y = numbers[j + 1];\n                control.x = point.x;\n                control.y = point.y;\n                if (j === 0) {\n                  path.moveTo(point.x, point.y);\n                } else {\n                  path.lineTo(point.x, point.y);\n                }\n                if (j === 0) firstPoint.copy(point);\n              }\n              break;\n            case \"H\":\n              numbers = parseFloats(data2);\n              for (var _j = 0, _jl = numbers.length; _j < _jl; _j++) {\n                point.x = numbers[_j];\n                control.x = point.x;\n                control.y = point.y;\n                path.lineTo(point.x, point.y);\n                if (_j === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n              }\n              break;\n            case \"V\":\n              numbers = parseFloats(data2);\n              for (var _j2 = 0, _jl2 = numbers.length; _j2 < _jl2; _j2++) {\n                point.y = numbers[_j2];\n                control.x = point.x;\n                control.y = point.y;\n                path.lineTo(point.x, point.y);\n                if (_j2 === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n              }\n              break;\n            case \"L\":\n              numbers = parseFloats(data2);\n              for (var _j3 = 0, _jl3 = numbers.length; _j3 < _jl3; _j3 += 2) {\n                point.x = numbers[_j3 + 0];\n                point.y = numbers[_j3 + 1];\n                control.x = point.x;\n                control.y = point.y;\n                path.lineTo(point.x, point.y);\n                if (_j3 === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n              }\n              break;\n            case \"C\":\n              numbers = parseFloats(data2);\n              for (var _j4 = 0, _jl4 = numbers.length; _j4 < _jl4; _j4 += 6) {\n                path.bezierCurveTo(numbers[_j4 + 0], numbers[_j4 + 1], numbers[_j4 + 2], numbers[_j4 + 3], numbers[_j4 + 4], numbers[_j4 + 5]);\n                control.x = numbers[_j4 + 2];\n                control.y = numbers[_j4 + 3];\n                point.x = numbers[_j4 + 4];\n                point.y = numbers[_j4 + 5];\n                if (_j4 === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n              }\n              break;\n            case \"S\":\n              numbers = parseFloats(data2);\n              for (var _j5 = 0, _jl5 = numbers.length; _j5 < _jl5; _j5 += 4) {\n                path.bezierCurveTo(getReflection(point.x, control.x), getReflection(point.y, control.y), numbers[_j5 + 0], numbers[_j5 + 1], numbers[_j5 + 2], numbers[_j5 + 3]);\n                control.x = numbers[_j5 + 0];\n                control.y = numbers[_j5 + 1];\n                point.x = numbers[_j5 + 2];\n                point.y = numbers[_j5 + 3];\n                if (_j5 === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n              }\n              break;\n            case \"Q\":\n              numbers = parseFloats(data2);\n              for (var _j6 = 0, _jl6 = numbers.length; _j6 < _jl6; _j6 += 4) {\n                path.quadraticCurveTo(numbers[_j6 + 0], numbers[_j6 + 1], numbers[_j6 + 2], numbers[_j6 + 3]);\n                control.x = numbers[_j6 + 0];\n                control.y = numbers[_j6 + 1];\n                point.x = numbers[_j6 + 2];\n                point.y = numbers[_j6 + 3];\n                if (_j6 === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n              }\n              break;\n            case \"T\":\n              numbers = parseFloats(data2);\n              for (var _j7 = 0, _jl7 = numbers.length; _j7 < _jl7; _j7 += 2) {\n                var rx = getReflection(point.x, control.x);\n                var ry = getReflection(point.y, control.y);\n                path.quadraticCurveTo(rx, ry, numbers[_j7 + 0], numbers[_j7 + 1]);\n                control.x = rx;\n                control.y = ry;\n                point.x = numbers[_j7 + 0];\n                point.y = numbers[_j7 + 1];\n                if (_j7 === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n              }\n              break;\n            case \"A\":\n              numbers = parseFloats(data2, [3, 4], 7);\n              for (var _j8 = 0, _jl8 = numbers.length; _j8 < _jl8; _j8 += 7) {\n                if (numbers[_j8 + 5] == point.x && numbers[_j8 + 6] == point.y) continue;\n                var start = point.clone();\n                point.x = numbers[_j8 + 5];\n                point.y = numbers[_j8 + 6];\n                control.x = point.x;\n                control.y = point.y;\n                parseArcCommand(path, numbers[_j8], numbers[_j8 + 1], numbers[_j8 + 2], numbers[_j8 + 3], numbers[_j8 + 4], start, point);\n                if (_j8 === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n              }\n              break;\n            case \"m\":\n              numbers = parseFloats(data2);\n              for (var _j9 = 0, _jl9 = numbers.length; _j9 < _jl9; _j9 += 2) {\n                point.x += numbers[_j9 + 0];\n                point.y += numbers[_j9 + 1];\n                control.x = point.x;\n                control.y = point.y;\n                if (_j9 === 0) {\n                  path.moveTo(point.x, point.y);\n                } else {\n                  path.lineTo(point.x, point.y);\n                }\n                if (_j9 === 0) firstPoint.copy(point);\n              }\n              break;\n            case \"h\":\n              numbers = parseFloats(data2);\n              for (var _j10 = 0, _jl10 = numbers.length; _j10 < _jl10; _j10++) {\n                point.x += numbers[_j10];\n                control.x = point.x;\n                control.y = point.y;\n                path.lineTo(point.x, point.y);\n                if (_j10 === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n              }\n              break;\n            case \"v\":\n              numbers = parseFloats(data2);\n              for (var _j11 = 0, _jl11 = numbers.length; _j11 < _jl11; _j11++) {\n                point.y += numbers[_j11];\n                control.x = point.x;\n                control.y = point.y;\n                path.lineTo(point.x, point.y);\n                if (_j11 === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n              }\n              break;\n            case \"l\":\n              numbers = parseFloats(data2);\n              for (var _j12 = 0, _jl12 = numbers.length; _j12 < _jl12; _j12 += 2) {\n                point.x += numbers[_j12 + 0];\n                point.y += numbers[_j12 + 1];\n                control.x = point.x;\n                control.y = point.y;\n                path.lineTo(point.x, point.y);\n                if (_j12 === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n              }\n              break;\n            case \"c\":\n              numbers = parseFloats(data2);\n              for (var _j13 = 0, _jl13 = numbers.length; _j13 < _jl13; _j13 += 6) {\n                path.bezierCurveTo(point.x + numbers[_j13 + 0], point.y + numbers[_j13 + 1], point.x + numbers[_j13 + 2], point.y + numbers[_j13 + 3], point.x + numbers[_j13 + 4], point.y + numbers[_j13 + 5]);\n                control.x = point.x + numbers[_j13 + 2];\n                control.y = point.y + numbers[_j13 + 3];\n                point.x += numbers[_j13 + 4];\n                point.y += numbers[_j13 + 5];\n                if (_j13 === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n              }\n              break;\n            case \"s\":\n              numbers = parseFloats(data2);\n              for (var _j14 = 0, _jl14 = numbers.length; _j14 < _jl14; _j14 += 4) {\n                path.bezierCurveTo(getReflection(point.x, control.x), getReflection(point.y, control.y), point.x + numbers[_j14 + 0], point.y + numbers[_j14 + 1], point.x + numbers[_j14 + 2], point.y + numbers[_j14 + 3]);\n                control.x = point.x + numbers[_j14 + 0];\n                control.y = point.y + numbers[_j14 + 1];\n                point.x += numbers[_j14 + 2];\n                point.y += numbers[_j14 + 3];\n                if (_j14 === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n              }\n              break;\n            case \"q\":\n              numbers = parseFloats(data2);\n              for (var _j15 = 0, _jl15 = numbers.length; _j15 < _jl15; _j15 += 4) {\n                path.quadraticCurveTo(point.x + numbers[_j15 + 0], point.y + numbers[_j15 + 1], point.x + numbers[_j15 + 2], point.y + numbers[_j15 + 3]);\n                control.x = point.x + numbers[_j15 + 0];\n                control.y = point.y + numbers[_j15 + 1];\n                point.x += numbers[_j15 + 2];\n                point.y += numbers[_j15 + 3];\n                if (_j15 === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n              }\n              break;\n            case \"t\":\n              numbers = parseFloats(data2);\n              for (var _j16 = 0, _jl16 = numbers.length; _j16 < _jl16; _j16 += 2) {\n                var _rx = getReflection(point.x, control.x);\n                var _ry = getReflection(point.y, control.y);\n                path.quadraticCurveTo(_rx, _ry, point.x + numbers[_j16 + 0], point.y + numbers[_j16 + 1]);\n                control.x = _rx;\n                control.y = _ry;\n                point.x = point.x + numbers[_j16 + 0];\n                point.y = point.y + numbers[_j16 + 1];\n                if (_j16 === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n              }\n              break;\n            case \"a\":\n              numbers = parseFloats(data2, [3, 4], 7);\n              for (var _j17 = 0, _jl17 = numbers.length; _j17 < _jl17; _j17 += 7) {\n                if (numbers[_j17 + 5] == 0 && numbers[_j17 + 6] == 0) continue;\n                var _start = point.clone();\n                point.x += numbers[_j17 + 5];\n                point.y += numbers[_j17 + 6];\n                control.x = point.x;\n                control.y = point.y;\n                parseArcCommand(path, numbers[_j17], numbers[_j17 + 1], numbers[_j17 + 2], numbers[_j17 + 3], numbers[_j17 + 4], _start, point);\n                if (_j17 === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n              }\n              break;\n            case \"Z\":\n            case \"z\":\n              path.currentPath.autoClose = true;\n              if (path.currentPath.curves.length > 0) {\n                point.copy(firstPoint);\n                path.currentPath.currentPoint.copy(point);\n                isFirstPoint = true;\n              }\n              break;\n            default:\n              console.warn(command);\n          }\n          doSetFirstPoint = false;\n        }\n        return path;\n      }\n      function parseCSSStylesheet(node) {\n        if (!node.sheet || !node.sheet.cssRules || !node.sheet.cssRules.length) return;\n        for (var i = 0; i < node.sheet.cssRules.length; i++) {\n          var stylesheet = node.sheet.cssRules[i];\n          if (stylesheet.type !== 1) continue;\n          var selectorList = stylesheet.selectorText.split(/,/gm).filter(Boolean).map(function (i2) {\n            return i2.trim();\n          });\n          for (var j = 0; j < selectorList.length; j++) {\n            var definitions = Object.fromEntries(Object.entries(stylesheet.style).filter(function (_ref) {\n              var _ref2 = _slicedToArray(_ref, 2),\n                v = _ref2[1];\n              return v !== \"\";\n            }));\n            stylesheets[selectorList[j]] = Object.assign(stylesheets[selectorList[j]] || {}, definitions);\n          }\n        }\n      }\n      function parseArcCommand(path, rx, ry, x_axis_rotation, large_arc_flag, sweep_flag, start, end) {\n        if (rx == 0 || ry == 0) {\n          path.lineTo(end.x, end.y);\n          return;\n        }\n        x_axis_rotation = x_axis_rotation * Math.PI / 180;\n        rx = Math.abs(rx);\n        ry = Math.abs(ry);\n        var dx2 = (start.x - end.x) / 2;\n        var dy2 = (start.y - end.y) / 2;\n        var x1p = Math.cos(x_axis_rotation) * dx2 + Math.sin(x_axis_rotation) * dy2;\n        var y1p = -Math.sin(x_axis_rotation) * dx2 + Math.cos(x_axis_rotation) * dy2;\n        var rxs = rx * rx;\n        var rys = ry * ry;\n        var x1ps = x1p * x1p;\n        var y1ps = y1p * y1p;\n        var cr = x1ps / rxs + y1ps / rys;\n        if (cr > 1) {\n          var s = Math.sqrt(cr);\n          rx = s * rx;\n          ry = s * ry;\n          rxs = rx * rx;\n          rys = ry * ry;\n        }\n        var dq = rxs * y1ps + rys * x1ps;\n        var pq = (rxs * rys - dq) / dq;\n        var q = Math.sqrt(Math.max(0, pq));\n        if (large_arc_flag === sweep_flag) q = -q;\n        var cxp = q * rx * y1p / ry;\n        var cyp = -q * ry * x1p / rx;\n        var cx = Math.cos(x_axis_rotation) * cxp - Math.sin(x_axis_rotation) * cyp + (start.x + end.x) / 2;\n        var cy = Math.sin(x_axis_rotation) * cxp + Math.cos(x_axis_rotation) * cyp + (start.y + end.y) / 2;\n        var theta = svgAngle(1, 0, (x1p - cxp) / rx, (y1p - cyp) / ry);\n        var delta = svgAngle((x1p - cxp) / rx, (y1p - cyp) / ry, (-x1p - cxp) / rx, (-y1p - cyp) / ry) % (Math.PI * 2);\n        path.currentPath.absellipse(cx, cy, rx, ry, theta, theta + delta, sweep_flag === 0, x_axis_rotation);\n      }\n      function svgAngle(ux, uy, vx, vy) {\n        var dot = ux * vx + uy * vy;\n        var len = Math.sqrt(ux * ux + uy * uy) * Math.sqrt(vx * vx + vy * vy);\n        var ang = Math.acos(Math.max(-1, Math.min(1, dot / len)));\n        if (ux * vy - uy * vx < 0) ang = -ang;\n        return ang;\n      }\n      function parseRectNode(node) {\n        var x = parseFloatWithUnits(node.getAttribute(\"x\") || 0);\n        var y = parseFloatWithUnits(node.getAttribute(\"y\") || 0);\n        var rx = parseFloatWithUnits(node.getAttribute(\"rx\") || node.getAttribute(\"ry\") || 0);\n        var ry = parseFloatWithUnits(node.getAttribute(\"ry\") || node.getAttribute(\"rx\") || 0);\n        var w = parseFloatWithUnits(node.getAttribute(\"width\"));\n        var h = parseFloatWithUnits(node.getAttribute(\"height\"));\n        var bci = 1 - 0.551915024494;\n        var path = new ShapePath();\n        path.moveTo(x + rx, y);\n        path.lineTo(x + w - rx, y);\n        if (rx !== 0 || ry !== 0) {\n          path.bezierCurveTo(x + w - rx * bci, y, x + w, y + ry * bci, x + w, y + ry);\n        }\n        path.lineTo(x + w, y + h - ry);\n        if (rx !== 0 || ry !== 0) {\n          path.bezierCurveTo(x + w, y + h - ry * bci, x + w - rx * bci, y + h, x + w - rx, y + h);\n        }\n        path.lineTo(x + rx, y + h);\n        if (rx !== 0 || ry !== 0) {\n          path.bezierCurveTo(x + rx * bci, y + h, x, y + h - ry * bci, x, y + h - ry);\n        }\n        path.lineTo(x, y + ry);\n        if (rx !== 0 || ry !== 0) {\n          path.bezierCurveTo(x, y + ry * bci, x + rx * bci, y, x + rx, y);\n        }\n        return path;\n      }\n      function parsePolygonNode(node) {\n        function iterator(match, a, b) {\n          var x = parseFloatWithUnits(a);\n          var y = parseFloatWithUnits(b);\n          if (index === 0) {\n            path.moveTo(x, y);\n          } else {\n            path.lineTo(x, y);\n          }\n          index++;\n        }\n        var regex = /([+-]?\\d*\\.?\\d+(?:e[+-]?\\d+)?)(?:,|\\s)([+-]?\\d*\\.?\\d+(?:e[+-]?\\d+)?)/g;\n        var path = new ShapePath();\n        var index = 0;\n        node.getAttribute(\"points\").replace(regex, iterator);\n        path.currentPath.autoClose = true;\n        return path;\n      }\n      function parsePolylineNode(node) {\n        function iterator(match, a, b) {\n          var x = parseFloatWithUnits(a);\n          var y = parseFloatWithUnits(b);\n          if (index === 0) {\n            path.moveTo(x, y);\n          } else {\n            path.lineTo(x, y);\n          }\n          index++;\n        }\n        var regex = /([+-]?\\d*\\.?\\d+(?:e[+-]?\\d+)?)(?:,|\\s)([+-]?\\d*\\.?\\d+(?:e[+-]?\\d+)?)/g;\n        var path = new ShapePath();\n        var index = 0;\n        node.getAttribute(\"points\").replace(regex, iterator);\n        path.currentPath.autoClose = false;\n        return path;\n      }\n      function parseCircleNode(node) {\n        var x = parseFloatWithUnits(node.getAttribute(\"cx\") || 0);\n        var y = parseFloatWithUnits(node.getAttribute(\"cy\") || 0);\n        var r = parseFloatWithUnits(node.getAttribute(\"r\") || 0);\n        var subpath = new Path();\n        subpath.absarc(x, y, r, 0, Math.PI * 2);\n        var path = new ShapePath();\n        path.subPaths.push(subpath);\n        return path;\n      }\n      function parseEllipseNode(node) {\n        var x = parseFloatWithUnits(node.getAttribute(\"cx\") || 0);\n        var y = parseFloatWithUnits(node.getAttribute(\"cy\") || 0);\n        var rx = parseFloatWithUnits(node.getAttribute(\"rx\") || 0);\n        var ry = parseFloatWithUnits(node.getAttribute(\"ry\") || 0);\n        var subpath = new Path();\n        subpath.absellipse(x, y, rx, ry, 0, Math.PI * 2);\n        var path = new ShapePath();\n        path.subPaths.push(subpath);\n        return path;\n      }\n      function parseLineNode(node) {\n        var x1 = parseFloatWithUnits(node.getAttribute(\"x1\") || 0);\n        var y1 = parseFloatWithUnits(node.getAttribute(\"y1\") || 0);\n        var x2 = parseFloatWithUnits(node.getAttribute(\"x2\") || 0);\n        var y2 = parseFloatWithUnits(node.getAttribute(\"y2\") || 0);\n        var path = new ShapePath();\n        path.moveTo(x1, y1);\n        path.lineTo(x2, y2);\n        path.currentPath.autoClose = false;\n        return path;\n      }\n      function parseStyle(node, style) {\n        style = Object.assign({}, style);\n        var stylesheetStyles = {};\n        if (node.hasAttribute(\"class\")) {\n          var classSelectors = node.getAttribute(\"class\").split(/\\s/).filter(Boolean).map(function (i) {\n            return i.trim();\n          });\n          for (var i = 0; i < classSelectors.length; i++) {\n            stylesheetStyles = Object.assign(stylesheetStyles, stylesheets[\".\" + classSelectors[i]]);\n          }\n        }\n        if (node.hasAttribute(\"id\")) {\n          stylesheetStyles = Object.assign(stylesheetStyles, stylesheets[\"#\" + node.getAttribute(\"id\")]);\n        }\n        function addStyle(svgName, jsName, adjustFunction) {\n          if (adjustFunction === void 0) adjustFunction = function copy(v) {\n            if (v.startsWith(\"url\")) console.warn(\"SVGLoader: url access in attributes is not implemented.\");\n            return v;\n          };\n          if (node.hasAttribute(svgName)) style[jsName] = adjustFunction(node.getAttribute(svgName));\n          if (stylesheetStyles[svgName]) style[jsName] = adjustFunction(stylesheetStyles[svgName]);\n          if (node.style && node.style[svgName] !== \"\") style[jsName] = adjustFunction(node.style[svgName]);\n        }\n        function clamp(v) {\n          return Math.max(0, Math.min(1, parseFloatWithUnits(v)));\n        }\n        function positive(v) {\n          return Math.max(0, parseFloatWithUnits(v));\n        }\n        addStyle(\"fill\", \"fill\");\n        addStyle(\"fill-opacity\", \"fillOpacity\", clamp);\n        addStyle(\"fill-rule\", \"fillRule\");\n        addStyle(\"opacity\", \"opacity\", clamp);\n        addStyle(\"stroke\", \"stroke\");\n        addStyle(\"stroke-opacity\", \"strokeOpacity\", clamp);\n        addStyle(\"stroke-width\", \"strokeWidth\", positive);\n        addStyle(\"stroke-linejoin\", \"strokeLineJoin\");\n        addStyle(\"stroke-linecap\", \"strokeLineCap\");\n        addStyle(\"stroke-miterlimit\", \"strokeMiterLimit\", positive);\n        addStyle(\"visibility\", \"visibility\");\n        return style;\n      }\n      function getReflection(a, b) {\n        return a - (b - a);\n      }\n      function parseFloats(input, flags, stride) {\n        if (typeof input !== \"string\") {\n          throw new TypeError(\"Invalid input: \" + typeof input);\n        }\n        var RE = {\n          SEPARATOR: /[ \\t\\r\\n\\,.\\-+]/,\n          WHITESPACE: /[ \\t\\r\\n]/,\n          DIGIT: /[\\d]/,\n          SIGN: /[-+]/,\n          POINT: /\\./,\n          COMMA: /,/,\n          EXP: /e/i,\n          FLAGS: /[01]/\n        };\n        var SEP = 0;\n        var INT = 1;\n        var FLOAT = 2;\n        var EXP = 3;\n        var state = SEP;\n        var seenComma = true;\n        var number = \"\",\n          exponent = \"\";\n        var result = [];\n        function throwSyntaxError(current2, i, partial) {\n          var error = new SyntaxError('Unexpected character \"' + current2 + '\" at index ' + i + \".\");\n          error.partial = partial;\n          throw error;\n        }\n        function newNumber() {\n          if (number !== \"\") {\n            if (exponent === \"\") result.push(Number(number));else result.push(Number(number) * Math.pow(10, Number(exponent)));\n          }\n          number = \"\";\n          exponent = \"\";\n        }\n        var current;\n        var length = input.length;\n        for (var i = 0; i < length; i++) {\n          current = input[i];\n          if (Array.isArray(flags) && flags.includes(result.length % stride) && RE.FLAGS.test(current)) {\n            state = INT;\n            number = current;\n            newNumber();\n            continue;\n          }\n          if (state === SEP) {\n            if (RE.WHITESPACE.test(current)) {\n              continue;\n            }\n            if (RE.DIGIT.test(current) || RE.SIGN.test(current)) {\n              state = INT;\n              number = current;\n              continue;\n            }\n            if (RE.POINT.test(current)) {\n              state = FLOAT;\n              number = current;\n              continue;\n            }\n            if (RE.COMMA.test(current)) {\n              if (seenComma) {\n                throwSyntaxError(current, i, result);\n              }\n              seenComma = true;\n            }\n          }\n          if (state === INT) {\n            if (RE.DIGIT.test(current)) {\n              number += current;\n              continue;\n            }\n            if (RE.POINT.test(current)) {\n              number += current;\n              state = FLOAT;\n              continue;\n            }\n            if (RE.EXP.test(current)) {\n              state = EXP;\n              continue;\n            }\n            if (RE.SIGN.test(current) && number.length === 1 && RE.SIGN.test(number[0])) {\n              throwSyntaxError(current, i, result);\n            }\n          }\n          if (state === FLOAT) {\n            if (RE.DIGIT.test(current)) {\n              number += current;\n              continue;\n            }\n            if (RE.EXP.test(current)) {\n              state = EXP;\n              continue;\n            }\n            if (RE.POINT.test(current) && number[number.length - 1] === \".\") {\n              throwSyntaxError(current, i, result);\n            }\n          }\n          if (state === EXP) {\n            if (RE.DIGIT.test(current)) {\n              exponent += current;\n              continue;\n            }\n            if (RE.SIGN.test(current)) {\n              if (exponent === \"\") {\n                exponent += current;\n                continue;\n              }\n              if (exponent.length === 1 && RE.SIGN.test(exponent)) {\n                throwSyntaxError(current, i, result);\n              }\n            }\n          }\n          if (RE.WHITESPACE.test(current)) {\n            newNumber();\n            state = SEP;\n            seenComma = false;\n          } else if (RE.COMMA.test(current)) {\n            newNumber();\n            state = SEP;\n            seenComma = true;\n          } else if (RE.SIGN.test(current)) {\n            newNumber();\n            state = INT;\n            number = current;\n          } else if (RE.POINT.test(current)) {\n            newNumber();\n            state = FLOAT;\n            number = current;\n          } else {\n            throwSyntaxError(current, i, result);\n          }\n        }\n        newNumber();\n        return result;\n      }\n      var units = [\"mm\", \"cm\", \"in\", \"pt\", \"pc\", \"px\"];\n      var unitConversion = {\n        mm: {\n          mm: 1,\n          cm: 0.1,\n          in: 1 / 25.4,\n          pt: 72 / 25.4,\n          pc: 6 / 25.4,\n          px: -1\n        },\n        cm: {\n          mm: 10,\n          cm: 1,\n          in: 1 / 2.54,\n          pt: 72 / 2.54,\n          pc: 6 / 2.54,\n          px: -1\n        },\n        in: {\n          mm: 25.4,\n          cm: 2.54,\n          in: 1,\n          pt: 72,\n          pc: 6,\n          px: -1\n        },\n        pt: {\n          mm: 25.4 / 72,\n          cm: 2.54 / 72,\n          in: 1 / 72,\n          pt: 1,\n          pc: 6 / 72,\n          px: -1\n        },\n        pc: {\n          mm: 25.4 / 6,\n          cm: 2.54 / 6,\n          in: 1 / 6,\n          pt: 72 / 6,\n          pc: 1,\n          px: -1\n        },\n        px: {\n          px: 1\n        }\n      };\n      function parseFloatWithUnits(string) {\n        var theUnit = \"px\";\n        if (typeof string === \"string\" || string instanceof String) {\n          for (var i = 0, n = units.length; i < n; i++) {\n            var u = units[i];\n            if (string.endsWith(u)) {\n              theUnit = u;\n              string = string.substring(0, string.length - u.length);\n              break;\n            }\n          }\n        }\n        var scale = void 0;\n        if (theUnit === \"px\" && scope.defaultUnit !== \"px\") {\n          scale = unitConversion[\"in\"][scope.defaultUnit] / scope.defaultDPI;\n        } else {\n          scale = unitConversion[theUnit][scope.defaultUnit];\n          if (scale < 0) {\n            scale = unitConversion[theUnit][\"in\"] * scope.defaultDPI;\n          }\n        }\n        return scale * parseFloat(string);\n      }\n      function getNodeTransform(node) {\n        if (!(node.hasAttribute(\"transform\") || node.nodeName === \"use\" && (node.hasAttribute(\"x\") || node.hasAttribute(\"y\")))) {\n          return null;\n        }\n        var transform = parseNodeTransform(node);\n        if (transformStack.length > 0) {\n          transform.premultiply(transformStack[transformStack.length - 1]);\n        }\n        currentTransform.copy(transform);\n        transformStack.push(transform);\n        return transform;\n      }\n      function parseNodeTransform(node) {\n        var transform = new Matrix3();\n        var currentTransform2 = tempTransform0;\n        if (node.nodeName === \"use\" && (node.hasAttribute(\"x\") || node.hasAttribute(\"y\"))) {\n          var tx = parseFloatWithUnits(node.getAttribute(\"x\"));\n          var ty = parseFloatWithUnits(node.getAttribute(\"y\"));\n          transform.translate(tx, ty);\n        }\n        if (node.hasAttribute(\"transform\")) {\n          var transformsTexts = node.getAttribute(\"transform\").split(\")\");\n          for (var tIndex = transformsTexts.length - 1; tIndex >= 0; tIndex--) {\n            var transformText = transformsTexts[tIndex].trim();\n            if (transformText === \"\") continue;\n            var openParPos = transformText.indexOf(\"(\");\n            var closeParPos = transformText.length;\n            if (openParPos > 0 && openParPos < closeParPos) {\n              var transformType = transformText.slice(0, openParPos);\n              var array = parseFloats(transformText.slice(openParPos + 1));\n              currentTransform2.identity();\n              switch (transformType) {\n                case \"translate\":\n                  if (array.length >= 1) {\n                    var _tx = array[0];\n                    var _ty = 0;\n                    if (array.length >= 2) {\n                      _ty = array[1];\n                    }\n                    currentTransform2.translate(_tx, _ty);\n                  }\n                  break;\n                case \"rotate\":\n                  if (array.length >= 1) {\n                    var angle = 0;\n                    var cx = 0;\n                    var cy = 0;\n                    angle = array[0] * Math.PI / 180;\n                    if (array.length >= 3) {\n                      cx = array[1];\n                      cy = array[2];\n                    }\n                    tempTransform1.makeTranslation(-cx, -cy);\n                    tempTransform2.makeRotation(angle);\n                    tempTransform3.multiplyMatrices(tempTransform2, tempTransform1);\n                    tempTransform1.makeTranslation(cx, cy);\n                    currentTransform2.multiplyMatrices(tempTransform1, tempTransform3);\n                  }\n                  break;\n                case \"scale\":\n                  if (array.length >= 1) {\n                    var scaleX = array[0];\n                    var scaleY = scaleX;\n                    if (array.length >= 2) {\n                      scaleY = array[1];\n                    }\n                    currentTransform2.scale(scaleX, scaleY);\n                  }\n                  break;\n                case \"skewX\":\n                  if (array.length === 1) {\n                    currentTransform2.set(1, Math.tan(array[0] * Math.PI / 180), 0, 0, 1, 0, 0, 0, 1);\n                  }\n                  break;\n                case \"skewY\":\n                  if (array.length === 1) {\n                    currentTransform2.set(1, 0, 0, Math.tan(array[0] * Math.PI / 180), 1, 0, 0, 0, 1);\n                  }\n                  break;\n                case \"matrix\":\n                  if (array.length === 6) {\n                    currentTransform2.set(array[0], array[2], array[4], array[1], array[3], array[5], 0, 0, 1);\n                  }\n                  break;\n              }\n            }\n            transform.premultiply(currentTransform2);\n          }\n        }\n        return transform;\n      }\n      function transformPath(path, m) {\n        function transfVec2(v2) {\n          tempV3.set(v2.x, v2.y, 1).applyMatrix3(m);\n          v2.set(tempV3.x, tempV3.y);\n        }\n        function transfEllipseGeneric(curve) {\n          var a = curve.xRadius;\n          var b = curve.yRadius;\n          var cosTheta = Math.cos(curve.aRotation);\n          var sinTheta = Math.sin(curve.aRotation);\n          var v1 = new Vector3(a * cosTheta, a * sinTheta, 0);\n          var v2 = new Vector3(-b * sinTheta, b * cosTheta, 0);\n          var f1 = v1.applyMatrix3(m);\n          var f2 = v2.applyMatrix3(m);\n          var mF = tempTransform0.set(f1.x, f2.x, 0, f1.y, f2.y, 0, 0, 0, 1);\n          var mFInv = tempTransform1.copy(mF).invert();\n          var mFInvT = tempTransform2.copy(mFInv).transpose();\n          var mQ = mFInvT.multiply(mFInv);\n          var mQe = mQ.elements;\n          var ed = eigenDecomposition(mQe[0], mQe[1], mQe[4]);\n          var rt1sqrt = Math.sqrt(ed.rt1);\n          var rt2sqrt = Math.sqrt(ed.rt2);\n          curve.xRadius = 1 / rt1sqrt;\n          curve.yRadius = 1 / rt2sqrt;\n          curve.aRotation = Math.atan2(ed.sn, ed.cs);\n          var isFullEllipse = (curve.aEndAngle - curve.aStartAngle) % (2 * Math.PI) < Number.EPSILON;\n          if (!isFullEllipse) {\n            var mDsqrt = tempTransform1.set(rt1sqrt, 0, 0, 0, rt2sqrt, 0, 0, 0, 1);\n            var mRT = tempTransform2.set(ed.cs, ed.sn, 0, -ed.sn, ed.cs, 0, 0, 0, 1);\n            var mDRF = mDsqrt.multiply(mRT).multiply(mF);\n            var transformAngle = function transformAngle(phi) {\n              var _Vector3$applyMatrix = new Vector3(Math.cos(phi), Math.sin(phi), 0).applyMatrix3(mDRF),\n                cosR = _Vector3$applyMatrix.x,\n                sinR = _Vector3$applyMatrix.y;\n              return Math.atan2(sinR, cosR);\n            };\n            curve.aStartAngle = transformAngle(curve.aStartAngle);\n            curve.aEndAngle = transformAngle(curve.aEndAngle);\n            if (isTransformFlipped(m)) {\n              curve.aClockwise = !curve.aClockwise;\n            }\n          }\n        }\n        function transfEllipseNoSkew(curve) {\n          var sx = getTransformScaleX(m);\n          var sy = getTransformScaleY(m);\n          curve.xRadius *= sx;\n          curve.yRadius *= sy;\n          var theta = sx > Number.EPSILON ? Math.atan2(m.elements[1], m.elements[0]) : Math.atan2(-m.elements[3], m.elements[4]);\n          curve.aRotation += theta;\n          if (isTransformFlipped(m)) {\n            curve.aStartAngle *= -1;\n            curve.aEndAngle *= -1;\n            curve.aClockwise = !curve.aClockwise;\n          }\n        }\n        var subPaths = path.subPaths;\n        for (var i = 0, n = subPaths.length; i < n; i++) {\n          var subPath = subPaths[i];\n          var curves = subPath.curves;\n          for (var j = 0; j < curves.length; j++) {\n            var curve = curves[j];\n            if (curve.isLineCurve) {\n              transfVec2(curve.v1);\n              transfVec2(curve.v2);\n            } else if (curve.isCubicBezierCurve) {\n              transfVec2(curve.v0);\n              transfVec2(curve.v1);\n              transfVec2(curve.v2);\n              transfVec2(curve.v3);\n            } else if (curve.isQuadraticBezierCurve) {\n              transfVec2(curve.v0);\n              transfVec2(curve.v1);\n              transfVec2(curve.v2);\n            } else if (curve.isEllipseCurve) {\n              tempV2.set(curve.aX, curve.aY);\n              transfVec2(tempV2);\n              curve.aX = tempV2.x;\n              curve.aY = tempV2.y;\n              if (isTransformSkewed(m)) {\n                transfEllipseGeneric(curve);\n              } else {\n                transfEllipseNoSkew(curve);\n              }\n            }\n          }\n        }\n      }\n      function isTransformFlipped(m) {\n        var te = m.elements;\n        return te[0] * te[4] - te[1] * te[3] < 0;\n      }\n      function isTransformSkewed(m) {\n        var te = m.elements;\n        var basisDot = te[0] * te[3] + te[1] * te[4];\n        if (basisDot === 0) return false;\n        var sx = getTransformScaleX(m);\n        var sy = getTransformScaleY(m);\n        return Math.abs(basisDot / (sx * sy)) > Number.EPSILON;\n      }\n      function getTransformScaleX(m) {\n        var te = m.elements;\n        return Math.sqrt(te[0] * te[0] + te[1] * te[1]);\n      }\n      function getTransformScaleY(m) {\n        var te = m.elements;\n        return Math.sqrt(te[3] * te[3] + te[4] * te[4]);\n      }\n      function eigenDecomposition(A, B, C) {\n        var rt1, rt2, cs, sn, t;\n        var sm = A + C;\n        var df = A - C;\n        var rt = Math.sqrt(df * df + 4 * B * B);\n        if (sm > 0) {\n          rt1 = 0.5 * (sm + rt);\n          t = 1 / rt1;\n          rt2 = A * t * C - B * t * B;\n        } else if (sm < 0) {\n          rt2 = 0.5 * (sm - rt);\n        } else {\n          rt1 = 0.5 * rt;\n          rt2 = -0.5 * rt;\n        }\n        if (df > 0) {\n          cs = df + rt;\n        } else {\n          cs = df - rt;\n        }\n        if (Math.abs(cs) > 2 * Math.abs(B)) {\n          t = -2 * B / cs;\n          sn = 1 / Math.sqrt(1 + t * t);\n          cs = t * sn;\n        } else if (Math.abs(B) === 0) {\n          cs = 1;\n          sn = 0;\n        } else {\n          t = -0.5 * cs / B;\n          cs = 1 / Math.sqrt(1 + t * t);\n          sn = t * cs;\n        }\n        if (df > 0) {\n          t = cs;\n          cs = -sn;\n          sn = t;\n        }\n        return {\n          rt1: rt1,\n          rt2: rt2,\n          cs: cs,\n          sn: sn\n        };\n      }\n      var paths = [];\n      var stylesheets = {};\n      var transformStack = [];\n      var tempTransform0 = new Matrix3();\n      var tempTransform1 = new Matrix3();\n      var tempTransform2 = new Matrix3();\n      var tempTransform3 = new Matrix3();\n      var tempV2 = new Vector2();\n      var tempV3 = new Vector3();\n      var currentTransform = new Matrix3();\n      var xml = new DOMParser().parseFromString(text, \"image/svg+xml\");\n      parseNode(xml.documentElement, {\n        fill: \"#000\",\n        fillOpacity: 1,\n        strokeOpacity: 1,\n        strokeWidth: 1,\n        strokeLineJoin: \"miter\",\n        strokeLineCap: \"butt\",\n        strokeMiterLimit: 4\n      });\n      var data = {\n        paths: paths,\n        xml: xml.documentElement\n      };\n      return data;\n    }\n  }], [{\n    key: \"createShapes\",\n    value: function createShapes(shapePath) {\n      var BIGNUMBER = 999999999;\n      var IntersectionLocationType = {\n        ORIGIN: 0,\n        DESTINATION: 1,\n        BETWEEN: 2,\n        LEFT: 3,\n        RIGHT: 4,\n        BEHIND: 5,\n        BEYOND: 6\n      };\n      var classifyResult = {\n        loc: IntersectionLocationType.ORIGIN,\n        t: 0\n      };\n      function findEdgeIntersection(a0, a1, b0, b1) {\n        var x1 = a0.x;\n        var x2 = a1.x;\n        var x3 = b0.x;\n        var x4 = b1.x;\n        var y1 = a0.y;\n        var y2 = a1.y;\n        var y3 = b0.y;\n        var y4 = b1.y;\n        var nom1 = (x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3);\n        var nom2 = (x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3);\n        var denom = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1);\n        var t1 = nom1 / denom;\n        var t2 = nom2 / denom;\n        if (denom === 0 && nom1 !== 0 || t1 <= 0 || t1 >= 1 || t2 < 0 || t2 > 1) {\n          return null;\n        } else if (nom1 === 0 && denom === 0) {\n          for (var i = 0; i < 2; i++) {\n            classifyPoint(i === 0 ? b0 : b1, a0, a1);\n            if (classifyResult.loc == IntersectionLocationType.ORIGIN) {\n              var point = i === 0 ? b0 : b1;\n              return {\n                x: point.x,\n                y: point.y,\n                t: classifyResult.t\n              };\n            } else if (classifyResult.loc == IntersectionLocationType.BETWEEN) {\n              var x = +(x1 + classifyResult.t * (x2 - x1)).toPrecision(10);\n              var y = +(y1 + classifyResult.t * (y2 - y1)).toPrecision(10);\n              return {\n                x: x,\n                y: y,\n                t: classifyResult.t\n              };\n            }\n          }\n          return null;\n        } else {\n          for (var _i = 0; _i < 2; _i++) {\n            classifyPoint(_i === 0 ? b0 : b1, a0, a1);\n            if (classifyResult.loc == IntersectionLocationType.ORIGIN) {\n              var _point = _i === 0 ? b0 : b1;\n              return {\n                x: _point.x,\n                y: _point.y,\n                t: classifyResult.t\n              };\n            }\n          }\n          var _x = +(x1 + t1 * (x2 - x1)).toPrecision(10);\n          var _y = +(y1 + t1 * (y2 - y1)).toPrecision(10);\n          return {\n            x: _x,\n            y: _y,\n            t: t1\n          };\n        }\n      }\n      function classifyPoint(p, edgeStart, edgeEnd) {\n        var ax = edgeEnd.x - edgeStart.x;\n        var ay = edgeEnd.y - edgeStart.y;\n        var bx = p.x - edgeStart.x;\n        var by = p.y - edgeStart.y;\n        var sa = ax * by - bx * ay;\n        if (p.x === edgeStart.x && p.y === edgeStart.y) {\n          classifyResult.loc = IntersectionLocationType.ORIGIN;\n          classifyResult.t = 0;\n          return;\n        }\n        if (p.x === edgeEnd.x && p.y === edgeEnd.y) {\n          classifyResult.loc = IntersectionLocationType.DESTINATION;\n          classifyResult.t = 1;\n          return;\n        }\n        if (sa < -Number.EPSILON) {\n          classifyResult.loc = IntersectionLocationType.LEFT;\n          return;\n        }\n        if (sa > Number.EPSILON) {\n          classifyResult.loc = IntersectionLocationType.RIGHT;\n          return;\n        }\n        if (ax * bx < 0 || ay * by < 0) {\n          classifyResult.loc = IntersectionLocationType.BEHIND;\n          return;\n        }\n        if (Math.sqrt(ax * ax + ay * ay) < Math.sqrt(bx * bx + by * by)) {\n          classifyResult.loc = IntersectionLocationType.BEYOND;\n          return;\n        }\n        var t;\n        if (ax !== 0) {\n          t = bx / ax;\n        } else {\n          t = by / ay;\n        }\n        classifyResult.loc = IntersectionLocationType.BETWEEN;\n        classifyResult.t = t;\n      }\n      function getIntersections(path1, path2) {\n        var intersectionsRaw = [];\n        var intersections = [];\n        for (var index = 1; index < path1.length; index++) {\n          var path1EdgeStart = path1[index - 1];\n          var path1EdgeEnd = path1[index];\n          var _loop = function _loop() {\n            var path2EdgeStart = path2[index2 - 1];\n            var path2EdgeEnd = path2[index2];\n            var intersection = findEdgeIntersection(path1EdgeStart, path1EdgeEnd, path2EdgeStart, path2EdgeEnd);\n            if (intersection !== null && intersectionsRaw.find(function (i) {\n              return i.t <= intersection.t + Number.EPSILON && i.t >= intersection.t - Number.EPSILON;\n            }) === void 0) {\n              intersectionsRaw.push(intersection);\n              intersections.push(new Vector2(intersection.x, intersection.y));\n            }\n          };\n          for (var index2 = 1; index2 < path2.length; index2++) {\n            _loop();\n          }\n        }\n        return intersections;\n      }\n      function getScanlineIntersections(scanline, boundingBox, paths) {\n        var center = new Vector2();\n        boundingBox.getCenter(center);\n        var allIntersections = [];\n        paths.forEach(function (path) {\n          if (path.boundingBox.containsPoint(center)) {\n            var intersections = getIntersections(scanline, path.points);\n            intersections.forEach(function (p) {\n              allIntersections.push({\n                identifier: path.identifier,\n                isCW: path.isCW,\n                point: p\n              });\n            });\n          }\n        });\n        allIntersections.sort(function (i1, i2) {\n          return i1.point.x - i2.point.x;\n        });\n        return allIntersections;\n      }\n      function isHoleTo(simplePath, allPaths, scanlineMinX2, scanlineMaxX2, _fillRule) {\n        if (_fillRule === null || _fillRule === void 0 || _fillRule === \"\") {\n          _fillRule = \"nonzero\";\n        }\n        var centerBoundingBox = new Vector2();\n        simplePath.boundingBox.getCenter(centerBoundingBox);\n        var scanline = [new Vector2(scanlineMinX2, centerBoundingBox.y), new Vector2(scanlineMaxX2, centerBoundingBox.y)];\n        var scanlineIntersections = getScanlineIntersections(scanline, simplePath.boundingBox, allPaths);\n        scanlineIntersections.sort(function (i1, i2) {\n          return i1.point.x - i2.point.x;\n        });\n        var baseIntersections = [];\n        var otherIntersections = [];\n        scanlineIntersections.forEach(function (i2) {\n          if (i2.identifier === simplePath.identifier) {\n            baseIntersections.push(i2);\n          } else {\n            otherIntersections.push(i2);\n          }\n        });\n        var firstXOfPath = baseIntersections[0].point.x;\n        var stack = [];\n        var i = 0;\n        while (i < otherIntersections.length && otherIntersections[i].point.x < firstXOfPath) {\n          if (stack.length > 0 && stack[stack.length - 1] === otherIntersections[i].identifier) {\n            stack.pop();\n          } else {\n            stack.push(otherIntersections[i].identifier);\n          }\n          i++;\n        }\n        stack.push(simplePath.identifier);\n        if (_fillRule === \"evenodd\") {\n          var isHole = stack.length % 2 === 0 ? true : false;\n          var isHoleFor = stack[stack.length - 2];\n          return {\n            identifier: simplePath.identifier,\n            isHole: isHole,\n            for: isHoleFor\n          };\n        } else if (_fillRule === \"nonzero\") {\n          var _isHole = true;\n          var _isHoleFor = null;\n          var lastCWValue = null;\n          for (var i2 = 0; i2 < stack.length; i2++) {\n            var identifier = stack[i2];\n            if (_isHole) {\n              lastCWValue = allPaths[identifier].isCW;\n              _isHole = false;\n              _isHoleFor = identifier;\n            } else if (lastCWValue !== allPaths[identifier].isCW) {\n              lastCWValue = allPaths[identifier].isCW;\n              _isHole = true;\n            }\n          }\n          return {\n            identifier: simplePath.identifier,\n            isHole: _isHole,\n            for: _isHoleFor\n          };\n        } else {\n          console.warn('fill-rule: \"' + _fillRule + '\" is currently not implemented.');\n        }\n      }\n      var scanlineMinX = BIGNUMBER;\n      var scanlineMaxX = -BIGNUMBER;\n      var simplePaths = shapePath.subPaths.map(function (p) {\n        var points = p.getPoints();\n        var maxY = -BIGNUMBER;\n        var minY = BIGNUMBER;\n        var maxX = -BIGNUMBER;\n        var minX = BIGNUMBER;\n        for (var i = 0; i < points.length; i++) {\n          var p2 = points[i];\n          if (p2.y > maxY) {\n            maxY = p2.y;\n          }\n          if (p2.y < minY) {\n            minY = p2.y;\n          }\n          if (p2.x > maxX) {\n            maxX = p2.x;\n          }\n          if (p2.x < minX) {\n            minX = p2.x;\n          }\n        }\n        if (scanlineMaxX <= maxX) {\n          scanlineMaxX = maxX + 1;\n        }\n        if (scanlineMinX >= minX) {\n          scanlineMinX = minX - 1;\n        }\n        return {\n          curves: p.curves,\n          points: points,\n          isCW: ShapeUtils.isClockWise(points),\n          identifier: -1,\n          boundingBox: new Box2(new Vector2(minX, minY), new Vector2(maxX, maxY))\n        };\n      });\n      simplePaths = simplePaths.filter(function (sp) {\n        return sp.points.length > 1;\n      });\n      for (var identifier = 0; identifier < simplePaths.length; identifier++) {\n        simplePaths[identifier].identifier = identifier;\n      }\n      var isAHole = simplePaths.map(function (p) {\n        return isHoleTo(p, simplePaths, scanlineMinX, scanlineMaxX, shapePath.userData ? shapePath.userData.style.fillRule : void 0);\n      });\n      var shapesToReturn = [];\n      simplePaths.forEach(function (p) {\n        var amIAHole = isAHole[p.identifier];\n        if (!amIAHole.isHole) {\n          var shape = new Shape();\n          shape.curves = p.curves;\n          var holes = isAHole.filter(function (h) {\n            return h.isHole && h.for === p.identifier;\n          });\n          holes.forEach(function (h) {\n            var hole = simplePaths[h.identifier];\n            var path = new Path();\n            path.curves = hole.curves;\n            shape.holes.push(path);\n          });\n          shapesToReturn.push(shape);\n        }\n      });\n      return shapesToReturn;\n    }\n  }, {\n    key: \"getStrokeStyle\",\n    value: function getStrokeStyle(width, color, lineJoin, lineCap, miterLimit) {\n      width = width !== void 0 ? width : 1;\n      color = color !== void 0 ? color : \"#000\";\n      lineJoin = lineJoin !== void 0 ? lineJoin : \"miter\";\n      lineCap = lineCap !== void 0 ? lineCap : \"butt\";\n      miterLimit = miterLimit !== void 0 ? miterLimit : 4;\n      return {\n        strokeColor: color,\n        strokeWidth: width,\n        strokeLineJoin: lineJoin,\n        strokeLineCap: lineCap,\n        strokeMiterLimit: miterLimit\n      };\n    }\n  }, {\n    key: \"pointsToStroke\",\n    value: function pointsToStroke(points, style, arcDivisions, minDistance) {\n      var vertices = [];\n      var normals = [];\n      var uvs = [];\n      if (SVGLoader.pointsToStrokeWithBuffers(points, style, arcDivisions, minDistance, vertices, normals, uvs) === 0) {\n        return null;\n      }\n      var geometry = new BufferGeometry();\n      geometry.setAttribute(\"position\", new Float32BufferAttribute(vertices, 3));\n      geometry.setAttribute(\"normal\", new Float32BufferAttribute(normals, 3));\n      geometry.setAttribute(\"uv\", new Float32BufferAttribute(uvs, 2));\n      return geometry;\n    }\n  }, {\n    key: \"pointsToStrokeWithBuffers\",\n    value: function pointsToStrokeWithBuffers(points, style, arcDivisions, minDistance, vertices, normals, uvs, vertexOffset) {\n      var tempV2_1 = new Vector2();\n      var tempV2_2 = new Vector2();\n      var tempV2_3 = new Vector2();\n      var tempV2_4 = new Vector2();\n      var tempV2_5 = new Vector2();\n      var tempV2_6 = new Vector2();\n      var tempV2_7 = new Vector2();\n      var lastPointL = new Vector2();\n      var lastPointR = new Vector2();\n      var point0L = new Vector2();\n      var point0R = new Vector2();\n      var currentPointL = new Vector2();\n      var currentPointR = new Vector2();\n      var nextPointL = new Vector2();\n      var nextPointR = new Vector2();\n      var innerPoint = new Vector2();\n      var outerPoint = new Vector2();\n      arcDivisions = arcDivisions !== void 0 ? arcDivisions : 12;\n      minDistance = minDistance !== void 0 ? minDistance : 1e-3;\n      vertexOffset = vertexOffset !== void 0 ? vertexOffset : 0;\n      points = removeDuplicatedPoints(points);\n      var numPoints = points.length;\n      if (numPoints < 2) return 0;\n      var isClosed = points[0].equals(points[numPoints - 1]);\n      var currentPoint;\n      var previousPoint = points[0];\n      var nextPoint;\n      var strokeWidth2 = style.strokeWidth / 2;\n      var deltaU = 1 / (numPoints - 1);\n      var u0 = 0,\n        u1;\n      var innerSideModified;\n      var joinIsOnLeftSide;\n      var isMiter;\n      var initialJoinIsOnLeftSide = false;\n      var numVertices = 0;\n      var currentCoordinate = vertexOffset * 3;\n      var currentCoordinateUV = vertexOffset * 2;\n      getNormal(points[0], points[1], tempV2_1).multiplyScalar(strokeWidth2);\n      lastPointL.copy(points[0]).sub(tempV2_1);\n      lastPointR.copy(points[0]).add(tempV2_1);\n      point0L.copy(lastPointL);\n      point0R.copy(lastPointR);\n      for (var iPoint = 1; iPoint < numPoints; iPoint++) {\n        currentPoint = points[iPoint];\n        if (iPoint === numPoints - 1) {\n          if (isClosed) {\n            nextPoint = points[1];\n          } else nextPoint = void 0;\n        } else {\n          nextPoint = points[iPoint + 1];\n        }\n        var normal1 = tempV2_1;\n        getNormal(previousPoint, currentPoint, normal1);\n        tempV2_3.copy(normal1).multiplyScalar(strokeWidth2);\n        currentPointL.copy(currentPoint).sub(tempV2_3);\n        currentPointR.copy(currentPoint).add(tempV2_3);\n        u1 = u0 + deltaU;\n        innerSideModified = false;\n        if (nextPoint !== void 0) {\n          getNormal(currentPoint, nextPoint, tempV2_2);\n          tempV2_3.copy(tempV2_2).multiplyScalar(strokeWidth2);\n          nextPointL.copy(currentPoint).sub(tempV2_3);\n          nextPointR.copy(currentPoint).add(tempV2_3);\n          joinIsOnLeftSide = true;\n          tempV2_3.subVectors(nextPoint, previousPoint);\n          if (normal1.dot(tempV2_3) < 0) {\n            joinIsOnLeftSide = false;\n          }\n          if (iPoint === 1) initialJoinIsOnLeftSide = joinIsOnLeftSide;\n          tempV2_3.subVectors(nextPoint, currentPoint);\n          tempV2_3.normalize();\n          var dot = Math.abs(normal1.dot(tempV2_3));\n          if (dot > Number.EPSILON) {\n            var miterSide = strokeWidth2 / dot;\n            tempV2_3.multiplyScalar(-miterSide);\n            tempV2_4.subVectors(currentPoint, previousPoint);\n            tempV2_5.copy(tempV2_4).setLength(miterSide).add(tempV2_3);\n            innerPoint.copy(tempV2_5).negate();\n            var miterLength2 = tempV2_5.length();\n            var segmentLengthPrev = tempV2_4.length();\n            tempV2_4.divideScalar(segmentLengthPrev);\n            tempV2_6.subVectors(nextPoint, currentPoint);\n            var segmentLengthNext = tempV2_6.length();\n            tempV2_6.divideScalar(segmentLengthNext);\n            if (tempV2_4.dot(innerPoint) < segmentLengthPrev && tempV2_6.dot(innerPoint) < segmentLengthNext) {\n              innerSideModified = true;\n            }\n            outerPoint.copy(tempV2_5).add(currentPoint);\n            innerPoint.add(currentPoint);\n            isMiter = false;\n            if (innerSideModified) {\n              if (joinIsOnLeftSide) {\n                nextPointR.copy(innerPoint);\n                currentPointR.copy(innerPoint);\n              } else {\n                nextPointL.copy(innerPoint);\n                currentPointL.copy(innerPoint);\n              }\n            } else {\n              makeSegmentTriangles();\n            }\n            switch (style.strokeLineJoin) {\n              case \"bevel\":\n                makeSegmentWithBevelJoin(joinIsOnLeftSide, innerSideModified, u1);\n                break;\n              case \"round\":\n                createSegmentTrianglesWithMiddleSection(joinIsOnLeftSide, innerSideModified);\n                if (joinIsOnLeftSide) {\n                  makeCircularSector(currentPoint, currentPointL, nextPointL, u1, 0);\n                } else {\n                  makeCircularSector(currentPoint, nextPointR, currentPointR, u1, 1);\n                }\n                break;\n              case \"miter\":\n              case \"miter-clip\":\n              default:\n                var miterFraction = strokeWidth2 * style.strokeMiterLimit / miterLength2;\n                if (miterFraction < 1) {\n                  if (style.strokeLineJoin !== \"miter-clip\") {\n                    makeSegmentWithBevelJoin(joinIsOnLeftSide, innerSideModified, u1);\n                    break;\n                  } else {\n                    createSegmentTrianglesWithMiddleSection(joinIsOnLeftSide, innerSideModified);\n                    if (joinIsOnLeftSide) {\n                      tempV2_6.subVectors(outerPoint, currentPointL).multiplyScalar(miterFraction).add(currentPointL);\n                      tempV2_7.subVectors(outerPoint, nextPointL).multiplyScalar(miterFraction).add(nextPointL);\n                      addVertex(currentPointL, u1, 0);\n                      addVertex(tempV2_6, u1, 0);\n                      addVertex(currentPoint, u1, 0.5);\n                      addVertex(currentPoint, u1, 0.5);\n                      addVertex(tempV2_6, u1, 0);\n                      addVertex(tempV2_7, u1, 0);\n                      addVertex(currentPoint, u1, 0.5);\n                      addVertex(tempV2_7, u1, 0);\n                      addVertex(nextPointL, u1, 0);\n                    } else {\n                      tempV2_6.subVectors(outerPoint, currentPointR).multiplyScalar(miterFraction).add(currentPointR);\n                      tempV2_7.subVectors(outerPoint, nextPointR).multiplyScalar(miterFraction).add(nextPointR);\n                      addVertex(currentPointR, u1, 1);\n                      addVertex(tempV2_6, u1, 1);\n                      addVertex(currentPoint, u1, 0.5);\n                      addVertex(currentPoint, u1, 0.5);\n                      addVertex(tempV2_6, u1, 1);\n                      addVertex(tempV2_7, u1, 1);\n                      addVertex(currentPoint, u1, 0.5);\n                      addVertex(tempV2_7, u1, 1);\n                      addVertex(nextPointR, u1, 1);\n                    }\n                  }\n                } else {\n                  if (innerSideModified) {\n                    if (joinIsOnLeftSide) {\n                      addVertex(lastPointR, u0, 1);\n                      addVertex(lastPointL, u0, 0);\n                      addVertex(outerPoint, u1, 0);\n                      addVertex(lastPointR, u0, 1);\n                      addVertex(outerPoint, u1, 0);\n                      addVertex(innerPoint, u1, 1);\n                    } else {\n                      addVertex(lastPointR, u0, 1);\n                      addVertex(lastPointL, u0, 0);\n                      addVertex(outerPoint, u1, 1);\n                      addVertex(lastPointL, u0, 0);\n                      addVertex(innerPoint, u1, 0);\n                      addVertex(outerPoint, u1, 1);\n                    }\n                    if (joinIsOnLeftSide) {\n                      nextPointL.copy(outerPoint);\n                    } else {\n                      nextPointR.copy(outerPoint);\n                    }\n                  } else {\n                    if (joinIsOnLeftSide) {\n                      addVertex(currentPointL, u1, 0);\n                      addVertex(outerPoint, u1, 0);\n                      addVertex(currentPoint, u1, 0.5);\n                      addVertex(currentPoint, u1, 0.5);\n                      addVertex(outerPoint, u1, 0);\n                      addVertex(nextPointL, u1, 0);\n                    } else {\n                      addVertex(currentPointR, u1, 1);\n                      addVertex(outerPoint, u1, 1);\n                      addVertex(currentPoint, u1, 0.5);\n                      addVertex(currentPoint, u1, 0.5);\n                      addVertex(outerPoint, u1, 1);\n                      addVertex(nextPointR, u1, 1);\n                    }\n                  }\n                  isMiter = true;\n                }\n                break;\n            }\n          } else {\n            makeSegmentTriangles();\n          }\n        } else {\n          makeSegmentTriangles();\n        }\n        if (!isClosed && iPoint === numPoints - 1) {\n          addCapGeometry(points[0], point0L, point0R, joinIsOnLeftSide, true, u0);\n        }\n        u0 = u1;\n        previousPoint = currentPoint;\n        lastPointL.copy(nextPointL);\n        lastPointR.copy(nextPointR);\n      }\n      if (!isClosed) {\n        addCapGeometry(currentPoint, currentPointL, currentPointR, joinIsOnLeftSide, false, u1);\n      } else if (innerSideModified && vertices) {\n        var lastOuter = outerPoint;\n        var lastInner = innerPoint;\n        if (initialJoinIsOnLeftSide !== joinIsOnLeftSide) {\n          lastOuter = innerPoint;\n          lastInner = outerPoint;\n        }\n        if (joinIsOnLeftSide) {\n          if (isMiter || initialJoinIsOnLeftSide) {\n            lastInner.toArray(vertices, 0 * 3);\n            lastInner.toArray(vertices, 3 * 3);\n            if (isMiter) {\n              lastOuter.toArray(vertices, 1 * 3);\n            }\n          }\n        } else {\n          if (isMiter || !initialJoinIsOnLeftSide) {\n            lastInner.toArray(vertices, 1 * 3);\n            lastInner.toArray(vertices, 3 * 3);\n            if (isMiter) {\n              lastOuter.toArray(vertices, 0 * 3);\n            }\n          }\n        }\n      }\n      return numVertices;\n      function getNormal(p1, p2, result) {\n        result.subVectors(p2, p1);\n        return result.set(-result.y, result.x).normalize();\n      }\n      function addVertex(position, u, v) {\n        if (vertices) {\n          vertices[currentCoordinate] = position.x;\n          vertices[currentCoordinate + 1] = position.y;\n          vertices[currentCoordinate + 2] = 0;\n          if (normals) {\n            normals[currentCoordinate] = 0;\n            normals[currentCoordinate + 1] = 0;\n            normals[currentCoordinate + 2] = 1;\n          }\n          currentCoordinate += 3;\n          if (uvs) {\n            uvs[currentCoordinateUV] = u;\n            uvs[currentCoordinateUV + 1] = v;\n            currentCoordinateUV += 2;\n          }\n        }\n        numVertices += 3;\n      }\n      function makeCircularSector(center, p1, p2, u, v) {\n        tempV2_1.copy(p1).sub(center).normalize();\n        tempV2_2.copy(p2).sub(center).normalize();\n        var angle = Math.PI;\n        var dot = tempV2_1.dot(tempV2_2);\n        if (Math.abs(dot) < 1) angle = Math.abs(Math.acos(dot));\n        angle /= arcDivisions;\n        tempV2_3.copy(p1);\n        for (var i = 0, il = arcDivisions - 1; i < il; i++) {\n          tempV2_4.copy(tempV2_3).rotateAround(center, angle);\n          addVertex(tempV2_3, u, v);\n          addVertex(tempV2_4, u, v);\n          addVertex(center, u, 0.5);\n          tempV2_3.copy(tempV2_4);\n        }\n        addVertex(tempV2_4, u, v);\n        addVertex(p2, u, v);\n        addVertex(center, u, 0.5);\n      }\n      function makeSegmentTriangles() {\n        addVertex(lastPointR, u0, 1);\n        addVertex(lastPointL, u0, 0);\n        addVertex(currentPointL, u1, 0);\n        addVertex(lastPointR, u0, 1);\n        addVertex(currentPointL, u1, 0);\n        addVertex(currentPointR, u1, 1);\n      }\n      function makeSegmentWithBevelJoin(joinIsOnLeftSide2, innerSideModified2, u) {\n        if (innerSideModified2) {\n          if (joinIsOnLeftSide2) {\n            addVertex(lastPointR, u0, 1);\n            addVertex(lastPointL, u0, 0);\n            addVertex(currentPointL, u1, 0);\n            addVertex(lastPointR, u0, 1);\n            addVertex(currentPointL, u1, 0);\n            addVertex(innerPoint, u1, 1);\n            addVertex(currentPointL, u, 0);\n            addVertex(nextPointL, u, 0);\n            addVertex(innerPoint, u, 0.5);\n          } else {\n            addVertex(lastPointR, u0, 1);\n            addVertex(lastPointL, u0, 0);\n            addVertex(currentPointR, u1, 1);\n            addVertex(lastPointL, u0, 0);\n            addVertex(innerPoint, u1, 0);\n            addVertex(currentPointR, u1, 1);\n            addVertex(currentPointR, u, 1);\n            addVertex(innerPoint, u, 0);\n            addVertex(nextPointR, u, 1);\n          }\n        } else {\n          if (joinIsOnLeftSide2) {\n            addVertex(currentPointL, u, 0);\n            addVertex(nextPointL, u, 0);\n            addVertex(currentPoint, u, 0.5);\n          } else {\n            addVertex(currentPointR, u, 1);\n            addVertex(nextPointR, u, 0);\n            addVertex(currentPoint, u, 0.5);\n          }\n        }\n      }\n      function createSegmentTrianglesWithMiddleSection(joinIsOnLeftSide2, innerSideModified2) {\n        if (innerSideModified2) {\n          if (joinIsOnLeftSide2) {\n            addVertex(lastPointR, u0, 1);\n            addVertex(lastPointL, u0, 0);\n            addVertex(currentPointL, u1, 0);\n            addVertex(lastPointR, u0, 1);\n            addVertex(currentPointL, u1, 0);\n            addVertex(innerPoint, u1, 1);\n            addVertex(currentPointL, u0, 0);\n            addVertex(currentPoint, u1, 0.5);\n            addVertex(innerPoint, u1, 1);\n            addVertex(currentPoint, u1, 0.5);\n            addVertex(nextPointL, u0, 0);\n            addVertex(innerPoint, u1, 1);\n          } else {\n            addVertex(lastPointR, u0, 1);\n            addVertex(lastPointL, u0, 0);\n            addVertex(currentPointR, u1, 1);\n            addVertex(lastPointL, u0, 0);\n            addVertex(innerPoint, u1, 0);\n            addVertex(currentPointR, u1, 1);\n            addVertex(currentPointR, u0, 1);\n            addVertex(innerPoint, u1, 0);\n            addVertex(currentPoint, u1, 0.5);\n            addVertex(currentPoint, u1, 0.5);\n            addVertex(innerPoint, u1, 0);\n            addVertex(nextPointR, u0, 1);\n          }\n        }\n      }\n      function addCapGeometry(center, p1, p2, joinIsOnLeftSide2, start, u) {\n        switch (style.strokeLineCap) {\n          case \"round\":\n            if (start) {\n              makeCircularSector(center, p2, p1, u, 0.5);\n            } else {\n              makeCircularSector(center, p1, p2, u, 0.5);\n            }\n            break;\n          case \"square\":\n            if (start) {\n              tempV2_1.subVectors(p1, center);\n              tempV2_2.set(tempV2_1.y, -tempV2_1.x);\n              tempV2_3.addVectors(tempV2_1, tempV2_2).add(center);\n              tempV2_4.subVectors(tempV2_2, tempV2_1).add(center);\n              if (joinIsOnLeftSide2) {\n                tempV2_3.toArray(vertices, 1 * 3);\n                tempV2_4.toArray(vertices, 0 * 3);\n                tempV2_4.toArray(vertices, 3 * 3);\n              } else {\n                tempV2_3.toArray(vertices, 1 * 3);\n                uvs[3 * 2 + 1] === 1 ? tempV2_4.toArray(vertices, 3 * 3) : tempV2_3.toArray(vertices, 3 * 3);\n                tempV2_4.toArray(vertices, 0 * 3);\n              }\n            } else {\n              tempV2_1.subVectors(p2, center);\n              tempV2_2.set(tempV2_1.y, -tempV2_1.x);\n              tempV2_3.addVectors(tempV2_1, tempV2_2).add(center);\n              tempV2_4.subVectors(tempV2_2, tempV2_1).add(center);\n              var vl = vertices.length;\n              if (joinIsOnLeftSide2) {\n                tempV2_3.toArray(vertices, vl - 1 * 3);\n                tempV2_4.toArray(vertices, vl - 2 * 3);\n                tempV2_4.toArray(vertices, vl - 4 * 3);\n              } else {\n                tempV2_4.toArray(vertices, vl - 2 * 3);\n                tempV2_3.toArray(vertices, vl - 1 * 3);\n                tempV2_4.toArray(vertices, vl - 4 * 3);\n              }\n            }\n            break;\n        }\n      }\n      function removeDuplicatedPoints(points2) {\n        var dupPoints = false;\n        for (var i = 1, n = points2.length - 1; i < n; i++) {\n          if (points2[i].distanceTo(points2[i + 1]) < minDistance) {\n            dupPoints = true;\n            break;\n          }\n        }\n        if (!dupPoints) return points2;\n        var newPoints = [];\n        newPoints.push(points2[0]);\n        for (var _i2 = 1, _n = points2.length - 1; _i2 < _n; _i2++) {\n          if (points2[_i2].distanceTo(points2[_i2 + 1]) >= minDistance) {\n            newPoints.push(points2[_i2]);\n          }\n        }\n        newPoints.push(points2[points2.length - 1]);\n        return newPoints;\n      }\n    }\n  }]);\n  return SVGLoader;\n}(Loader);\nexport { SVGLoader };","map":{"version":3,"names":["COLOR_SPACE_SVG","SVGLoader","_Loader","_inherits","_super","_createSuper","manager","_this","_classCallCheck","call","defaultDPI","defaultUnit","_createClass","key","value","load","url","onLoad","onProgress","onError","scope","loader","FileLoader","setPath","path","setRequestHeader","requestHeader","setWithCredentials","withCredentials","text","parse","e","console","error","itemError","parseNode","node","style","nodeType","transform","getNodeTransform","isDefsNode","nodeName","parseStyle","parseCSSStylesheet","hasAttribute","parsePathNode","parseRectNode","parsePolygonNode","parsePolylineNode","parseCircleNode","parseEllipseNode","parseLineNode","href","getAttributeNS","usedNodeId","substring","usedNode","viewportElement","getElementById","warn","fill","color","setStyle","transformPath","currentTransform","paths","push","userData","childNodes","i","length","node2","transformStack","pop","copy","identity","ShapePath","point","Vector2","control","firstPoint","isFirstPoint","doSetFirstPoint","d","getAttribute","commands","match","l","command","type","charAt","data2","slice","trim","numbers","parseFloats","j","jl","x","y","moveTo","lineTo","bezierCurveTo","getReflection","quadraticCurveTo","rx","ry","start","clone","parseArcCommand","currentPath","autoClose","curves","currentPoint","sheet","cssRules","stylesheet","selectorList","selectorText","split","filter","Boolean","map","i2","definitions","Object","fromEntries","entries","_ref","_ref2","_slicedToArray","v","stylesheets","assign","x_axis_rotation","large_arc_flag","sweep_flag","end","Math","PI","abs","dx2","dy2","x1p","cos","sin","y1p","rxs","rys","x1ps","y1ps","cr","s","sqrt","dq","pq","q","max","cxp","cyp","cx","cy","theta","svgAngle","delta","absellipse","ux","uy","vx","vy","dot","len","ang","acos","min","parseFloatWithUnits","w","h","bci","iterator","a","b","index","regex","replace","r","subpath","Path","absarc","subPaths","x1","y1","x2","y2","stylesheetStyles","classSelectors","addStyle","svgName","jsName","adjustFunction","startsWith","clamp","positive","input","flags","stride","TypeError","RE","SEPARATOR","WHITESPACE","DIGIT","SIGN","POINT","COMMA","EXP","FLAGS","SEP","INT","FLOAT","state","seenComma","number","exponent","result","throwSyntaxError","current2","partial","SyntaxError","newNumber","Number","pow","current","Array","isArray","includes","test","units","unitConversion","mm","cm","in","pt","pc","px","string","theUnit","String","n","u","endsWith","scale","parseFloat","parseNodeTransform","premultiply","Matrix3","currentTransform2","tempTransform0","tx","ty","translate","transformsTexts","tIndex","transformText","openParPos","indexOf","closeParPos","transformType","array","angle","tempTransform1","makeTranslation","tempTransform2","makeRotation","tempTransform3","multiplyMatrices","scaleX","scaleY","set","tan","m","transfVec2","v2","tempV3","applyMatrix3","transfEllipseGeneric","curve","xRadius","yRadius","cosTheta","aRotation","sinTheta","v1","Vector3","f1","f2","mF","mFInv","invert","mFInvT","transpose","mQ","multiply","mQe","elements","ed","eigenDecomposition","rt1sqrt","rt1","rt2sqrt","rt2","atan2","sn","cs","isFullEllipse","aEndAngle","aStartAngle","EPSILON","mDsqrt","mRT","mDRF","transformAngle","phi","_Vector3$applyMatrix","cosR","sinR","isTransformFlipped","aClockwise","transfEllipseNoSkew","sx","getTransformScaleX","sy","getTransformScaleY","subPath","isLineCurve","isCubicBezierCurve","v0","v3","isQuadraticBezierCurve","isEllipseCurve","tempV2","aX","aY","isTransformSkewed","te","basisDot","A","B","C","t","sm","df","rt","xml","DOMParser","parseFromString","documentElement","fillOpacity","strokeOpacity","strokeWidth","strokeLineJoin","strokeLineCap","strokeMiterLimit","data","createShapes","shapePath","BIGNUMBER","IntersectionLocationType","ORIGIN","DESTINATION","BETWEEN","LEFT","RIGHT","BEHIND","BEYOND","classifyResult","loc","findEdgeIntersection","a0","a1","b0","b1","x3","x4","y3","y4","nom1","nom2","denom","t1","t2","classifyPoint","toPrecision","p","edgeStart","edgeEnd","ax","ay","bx","by","sa","getIntersections","path1","path2","intersectionsRaw","intersections","path1EdgeStart","path1EdgeEnd","_loop","path2EdgeStart","index2","path2EdgeEnd","intersection","find","getScanlineIntersections","scanline","boundingBox","center","getCenter","allIntersections","forEach","containsPoint","points","identifier","isCW","sort","i1","isHoleTo","simplePath","allPaths","scanlineMinX2","scanlineMaxX2","_fillRule","centerBoundingBox","scanlineIntersections","baseIntersections","otherIntersections","firstXOfPath","stack","isHole","isHoleFor","for","lastCWValue","scanlineMinX","scanlineMaxX","simplePaths","getPoints","maxY","minY","maxX","minX","p2","ShapeUtils","isClockWise","Box2","sp","isAHole","fillRule","shapesToReturn","amIAHole","shape","Shape","holes","hole","getStrokeStyle","width","lineJoin","lineCap","miterLimit","strokeColor","pointsToStroke","arcDivisions","minDistance","vertices","normals","uvs","pointsToStrokeWithBuffers","geometry","BufferGeometry","setAttribute","Float32BufferAttribute","vertexOffset","tempV2_1","tempV2_2","tempV2_3","tempV2_4","tempV2_5","tempV2_6","tempV2_7","lastPointL","lastPointR","point0L","point0R","currentPointL","currentPointR","nextPointL","nextPointR","innerPoint","outerPoint","removeDuplicatedPoints","numPoints","isClosed","equals","previousPoint","nextPoint","strokeWidth2","deltaU","u0","u1","innerSideModified","joinIsOnLeftSide","isMiter","initialJoinIsOnLeftSide","numVertices","currentCoordinate","currentCoordinateUV","getNormal","multiplyScalar","sub","add","iPoint","normal1","subVectors","normalize","miterSide","setLength","negate","miterLength2","segmentLengthPrev","divideScalar","segmentLengthNext","makeSegmentTriangles","makeSegmentWithBevelJoin","createSegmentTrianglesWithMiddleSection","makeCircularSector","miterFraction","addVertex","addCapGeometry","lastOuter","lastInner","toArray","p1","position","il","rotateAround","joinIsOnLeftSide2","innerSideModified2","addVectors","vl","points2","dupPoints","distanceTo","newPoints","Loader"],"sources":["C:\\Users\\Nayyu\\Desktop\\skibidai-public-build\\node_modules\\src\\loaders\\SVGLoader.js"],"sourcesContent":["import {\n  Box2,\n  BufferGeometry,\n  FileLoader,\n  Float32BufferAttribute,\n  Loader,\n  Matrix3,\n  Path,\n  Shape,\n  ShapePath,\n  ShapeUtils,\n  Vector2,\n  Vector3,\n} from 'three'\n\nconst COLOR_SPACE_SVG = 'srgb'\n\nclass SVGLoader extends Loader {\n  constructor(manager) {\n    super(manager)\n\n    // Default dots per inch\n    this.defaultDPI = 90\n\n    // Accepted units: 'mm', 'cm', 'in', 'pt', 'pc', 'px'\n    this.defaultUnit = 'px'\n  }\n\n  load(url, onLoad, onProgress, onError) {\n    const scope = this\n\n    const loader = new FileLoader(scope.manager)\n    loader.setPath(scope.path)\n    loader.setRequestHeader(scope.requestHeader)\n    loader.setWithCredentials(scope.withCredentials)\n    loader.load(\n      url,\n      function (text) {\n        try {\n          onLoad(scope.parse(text))\n        } catch (e) {\n          if (onError) {\n            onError(e)\n          } else {\n            console.error(e)\n          }\n\n          scope.manager.itemError(url)\n        }\n      },\n      onProgress,\n      onError,\n    )\n  }\n\n  parse(text) {\n    const scope = this\n\n    function parseNode(node, style) {\n      if (node.nodeType !== 1) return\n\n      const transform = getNodeTransform(node)\n\n      let isDefsNode = false\n\n      let path = null\n\n      switch (node.nodeName) {\n        case 'svg':\n          style = parseStyle(node, style)\n          break\n\n        case 'style':\n          parseCSSStylesheet(node)\n          break\n\n        case 'g':\n          style = parseStyle(node, style)\n          break\n\n        case 'path':\n          style = parseStyle(node, style)\n          if (node.hasAttribute('d')) path = parsePathNode(node)\n          break\n\n        case 'rect':\n          style = parseStyle(node, style)\n          path = parseRectNode(node)\n          break\n\n        case 'polygon':\n          style = parseStyle(node, style)\n          path = parsePolygonNode(node)\n          break\n\n        case 'polyline':\n          style = parseStyle(node, style)\n          path = parsePolylineNode(node)\n          break\n\n        case 'circle':\n          style = parseStyle(node, style)\n          path = parseCircleNode(node)\n          break\n\n        case 'ellipse':\n          style = parseStyle(node, style)\n          path = parseEllipseNode(node)\n          break\n\n        case 'line':\n          style = parseStyle(node, style)\n          path = parseLineNode(node)\n          break\n\n        case 'defs':\n          isDefsNode = true\n          break\n\n        case 'use':\n          style = parseStyle(node, style)\n\n          const href = node.getAttributeNS('http://www.w3.org/1999/xlink', 'href') || ''\n          const usedNodeId = href.substring(1)\n          const usedNode = node.viewportElement.getElementById(usedNodeId)\n          if (usedNode) {\n            parseNode(usedNode, style)\n          } else {\n            console.warn(\"SVGLoader: 'use node' references non-existent node id: \" + usedNodeId)\n          }\n\n          break\n\n        default:\n        // console.log( node );\n      }\n\n      if (path) {\n        if (style.fill !== undefined && style.fill !== 'none') {\n          path.color.setStyle(style.fill, COLOR_SPACE_SVG)\n        }\n\n        transformPath(path, currentTransform)\n\n        paths.push(path)\n\n        path.userData = { node: node, style: style }\n      }\n\n      const childNodes = node.childNodes\n\n      for (let i = 0; i < childNodes.length; i++) {\n        const node = childNodes[i]\n\n        if (isDefsNode && node.nodeName !== 'style' && node.nodeName !== 'defs') {\n          // Ignore everything in defs except CSS style definitions\n          // and nested defs, because it is OK by the standard to have\n          // <style/> there.\n          continue\n        }\n\n        parseNode(node, style)\n      }\n\n      if (transform) {\n        transformStack.pop()\n\n        if (transformStack.length > 0) {\n          currentTransform.copy(transformStack[transformStack.length - 1])\n        } else {\n          currentTransform.identity()\n        }\n      }\n    }\n\n    function parsePathNode(node) {\n      const path = new ShapePath()\n\n      const point = new Vector2()\n      const control = new Vector2()\n\n      const firstPoint = new Vector2()\n      let isFirstPoint = true\n      let doSetFirstPoint = false\n\n      const d = node.getAttribute('d')\n\n      if (d === '' || d === 'none') return null\n\n      // console.log( d );\n\n      const commands = d.match(/[a-df-z][^a-df-z]*/gi)\n\n      for (let i = 0, l = commands.length; i < l; i++) {\n        const command = commands[i]\n\n        const type = command.charAt(0)\n        const data = command.slice(1).trim()\n\n        if (isFirstPoint === true) {\n          doSetFirstPoint = true\n          isFirstPoint = false\n        }\n\n        let numbers\n\n        switch (type) {\n          case 'M':\n            numbers = parseFloats(data)\n            for (let j = 0, jl = numbers.length; j < jl; j += 2) {\n              point.x = numbers[j + 0]\n              point.y = numbers[j + 1]\n              control.x = point.x\n              control.y = point.y\n\n              if (j === 0) {\n                path.moveTo(point.x, point.y)\n              } else {\n                path.lineTo(point.x, point.y)\n              }\n\n              if (j === 0) firstPoint.copy(point)\n            }\n\n            break\n\n          case 'H':\n            numbers = parseFloats(data)\n\n            for (let j = 0, jl = numbers.length; j < jl; j++) {\n              point.x = numbers[j]\n              control.x = point.x\n              control.y = point.y\n              path.lineTo(point.x, point.y)\n\n              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point)\n            }\n\n            break\n\n          case 'V':\n            numbers = parseFloats(data)\n\n            for (let j = 0, jl = numbers.length; j < jl; j++) {\n              point.y = numbers[j]\n              control.x = point.x\n              control.y = point.y\n              path.lineTo(point.x, point.y)\n\n              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point)\n            }\n\n            break\n\n          case 'L':\n            numbers = parseFloats(data)\n\n            for (let j = 0, jl = numbers.length; j < jl; j += 2) {\n              point.x = numbers[j + 0]\n              point.y = numbers[j + 1]\n              control.x = point.x\n              control.y = point.y\n              path.lineTo(point.x, point.y)\n\n              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point)\n            }\n\n            break\n\n          case 'C':\n            numbers = parseFloats(data)\n\n            for (let j = 0, jl = numbers.length; j < jl; j += 6) {\n              path.bezierCurveTo(\n                numbers[j + 0],\n                numbers[j + 1],\n                numbers[j + 2],\n                numbers[j + 3],\n                numbers[j + 4],\n                numbers[j + 5],\n              )\n              control.x = numbers[j + 2]\n              control.y = numbers[j + 3]\n              point.x = numbers[j + 4]\n              point.y = numbers[j + 5]\n\n              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point)\n            }\n\n            break\n\n          case 'S':\n            numbers = parseFloats(data)\n\n            for (let j = 0, jl = numbers.length; j < jl; j += 4) {\n              path.bezierCurveTo(\n                getReflection(point.x, control.x),\n                getReflection(point.y, control.y),\n                numbers[j + 0],\n                numbers[j + 1],\n                numbers[j + 2],\n                numbers[j + 3],\n              )\n              control.x = numbers[j + 0]\n              control.y = numbers[j + 1]\n              point.x = numbers[j + 2]\n              point.y = numbers[j + 3]\n\n              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point)\n            }\n\n            break\n\n          case 'Q':\n            numbers = parseFloats(data)\n\n            for (let j = 0, jl = numbers.length; j < jl; j += 4) {\n              path.quadraticCurveTo(numbers[j + 0], numbers[j + 1], numbers[j + 2], numbers[j + 3])\n              control.x = numbers[j + 0]\n              control.y = numbers[j + 1]\n              point.x = numbers[j + 2]\n              point.y = numbers[j + 3]\n\n              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point)\n            }\n\n            break\n\n          case 'T':\n            numbers = parseFloats(data)\n\n            for (let j = 0, jl = numbers.length; j < jl; j += 2) {\n              const rx = getReflection(point.x, control.x)\n              const ry = getReflection(point.y, control.y)\n              path.quadraticCurveTo(rx, ry, numbers[j + 0], numbers[j + 1])\n              control.x = rx\n              control.y = ry\n              point.x = numbers[j + 0]\n              point.y = numbers[j + 1]\n\n              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point)\n            }\n\n            break\n\n          case 'A':\n            numbers = parseFloats(data, [3, 4], 7)\n\n            for (let j = 0, jl = numbers.length; j < jl; j += 7) {\n              // skip command if start point == end point\n              if (numbers[j + 5] == point.x && numbers[j + 6] == point.y) continue\n\n              const start = point.clone()\n              point.x = numbers[j + 5]\n              point.y = numbers[j + 6]\n              control.x = point.x\n              control.y = point.y\n              parseArcCommand(\n                path,\n                numbers[j],\n                numbers[j + 1],\n                numbers[j + 2],\n                numbers[j + 3],\n                numbers[j + 4],\n                start,\n                point,\n              )\n\n              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point)\n            }\n\n            break\n\n          case 'm':\n            numbers = parseFloats(data)\n\n            for (let j = 0, jl = numbers.length; j < jl; j += 2) {\n              point.x += numbers[j + 0]\n              point.y += numbers[j + 1]\n              control.x = point.x\n              control.y = point.y\n\n              if (j === 0) {\n                path.moveTo(point.x, point.y)\n              } else {\n                path.lineTo(point.x, point.y)\n              }\n\n              if (j === 0) firstPoint.copy(point)\n            }\n\n            break\n\n          case 'h':\n            numbers = parseFloats(data)\n\n            for (let j = 0, jl = numbers.length; j < jl; j++) {\n              point.x += numbers[j]\n              control.x = point.x\n              control.y = point.y\n              path.lineTo(point.x, point.y)\n\n              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point)\n            }\n\n            break\n\n          case 'v':\n            numbers = parseFloats(data)\n\n            for (let j = 0, jl = numbers.length; j < jl; j++) {\n              point.y += numbers[j]\n              control.x = point.x\n              control.y = point.y\n              path.lineTo(point.x, point.y)\n\n              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point)\n            }\n\n            break\n\n          case 'l':\n            numbers = parseFloats(data)\n\n            for (let j = 0, jl = numbers.length; j < jl; j += 2) {\n              point.x += numbers[j + 0]\n              point.y += numbers[j + 1]\n              control.x = point.x\n              control.y = point.y\n              path.lineTo(point.x, point.y)\n\n              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point)\n            }\n\n            break\n\n          case 'c':\n            numbers = parseFloats(data)\n\n            for (let j = 0, jl = numbers.length; j < jl; j += 6) {\n              path.bezierCurveTo(\n                point.x + numbers[j + 0],\n                point.y + numbers[j + 1],\n                point.x + numbers[j + 2],\n                point.y + numbers[j + 3],\n                point.x + numbers[j + 4],\n                point.y + numbers[j + 5],\n              )\n              control.x = point.x + numbers[j + 2]\n              control.y = point.y + numbers[j + 3]\n              point.x += numbers[j + 4]\n              point.y += numbers[j + 5]\n\n              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point)\n            }\n\n            break\n\n          case 's':\n            numbers = parseFloats(data)\n\n            for (let j = 0, jl = numbers.length; j < jl; j += 4) {\n              path.bezierCurveTo(\n                getReflection(point.x, control.x),\n                getReflection(point.y, control.y),\n                point.x + numbers[j + 0],\n                point.y + numbers[j + 1],\n                point.x + numbers[j + 2],\n                point.y + numbers[j + 3],\n              )\n              control.x = point.x + numbers[j + 0]\n              control.y = point.y + numbers[j + 1]\n              point.x += numbers[j + 2]\n              point.y += numbers[j + 3]\n\n              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point)\n            }\n\n            break\n\n          case 'q':\n            numbers = parseFloats(data)\n\n            for (let j = 0, jl = numbers.length; j < jl; j += 4) {\n              path.quadraticCurveTo(\n                point.x + numbers[j + 0],\n                point.y + numbers[j + 1],\n                point.x + numbers[j + 2],\n                point.y + numbers[j + 3],\n              )\n              control.x = point.x + numbers[j + 0]\n              control.y = point.y + numbers[j + 1]\n              point.x += numbers[j + 2]\n              point.y += numbers[j + 3]\n\n              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point)\n            }\n\n            break\n\n          case 't':\n            numbers = parseFloats(data)\n\n            for (let j = 0, jl = numbers.length; j < jl; j += 2) {\n              const rx = getReflection(point.x, control.x)\n              const ry = getReflection(point.y, control.y)\n              path.quadraticCurveTo(rx, ry, point.x + numbers[j + 0], point.y + numbers[j + 1])\n              control.x = rx\n              control.y = ry\n              point.x = point.x + numbers[j + 0]\n              point.y = point.y + numbers[j + 1]\n\n              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point)\n            }\n\n            break\n\n          case 'a':\n            numbers = parseFloats(data, [3, 4], 7)\n\n            for (let j = 0, jl = numbers.length; j < jl; j += 7) {\n              // skip command if no displacement\n              if (numbers[j + 5] == 0 && numbers[j + 6] == 0) continue\n\n              const start = point.clone()\n              point.x += numbers[j + 5]\n              point.y += numbers[j + 6]\n              control.x = point.x\n              control.y = point.y\n              parseArcCommand(\n                path,\n                numbers[j],\n                numbers[j + 1],\n                numbers[j + 2],\n                numbers[j + 3],\n                numbers[j + 4],\n                start,\n                point,\n              )\n\n              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point)\n            }\n\n            break\n\n          case 'Z':\n          case 'z':\n            path.currentPath.autoClose = true\n\n            if (path.currentPath.curves.length > 0) {\n              // Reset point to beginning of Path\n              point.copy(firstPoint)\n              path.currentPath.currentPoint.copy(point)\n              isFirstPoint = true\n            }\n\n            break\n\n          default:\n            console.warn(command)\n        }\n\n        // console.log( type, parseFloats( data ), parseFloats( data ).length  )\n\n        doSetFirstPoint = false\n      }\n\n      return path\n    }\n\n    function parseCSSStylesheet(node) {\n      if (!node.sheet || !node.sheet.cssRules || !node.sheet.cssRules.length) return\n\n      for (let i = 0; i < node.sheet.cssRules.length; i++) {\n        const stylesheet = node.sheet.cssRules[i]\n\n        if (stylesheet.type !== 1) continue\n\n        const selectorList = stylesheet.selectorText\n          .split(/,/gm)\n          .filter(Boolean)\n          .map((i) => i.trim())\n\n        for (let j = 0; j < selectorList.length; j++) {\n          // Remove empty rules\n          const definitions = Object.fromEntries(Object.entries(stylesheet.style).filter(([, v]) => v !== ''))\n\n          stylesheets[selectorList[j]] = Object.assign(stylesheets[selectorList[j]] || {}, definitions)\n        }\n      }\n    }\n\n    /**\n     * https://www.w3.org/TR/SVG/implnote.html#ArcImplementationNotes\n     * https://mortoray.com/2017/02/16/rendering-an-svg-elliptical-arc-as-bezier-curves/ Appendix: Endpoint to center arc conversion\n     * From\n     * rx ry x-axis-rotation large-arc-flag sweep-flag x y\n     * To\n     * aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation\n     */\n\n    function parseArcCommand(path, rx, ry, x_axis_rotation, large_arc_flag, sweep_flag, start, end) {\n      if (rx == 0 || ry == 0) {\n        // draw a line if either of the radii == 0\n        path.lineTo(end.x, end.y)\n        return\n      }\n\n      x_axis_rotation = (x_axis_rotation * Math.PI) / 180\n\n      // Ensure radii are positive\n      rx = Math.abs(rx)\n      ry = Math.abs(ry)\n\n      // Compute (x1', y1')\n      const dx2 = (start.x - end.x) / 2.0\n      const dy2 = (start.y - end.y) / 2.0\n      const x1p = Math.cos(x_axis_rotation) * dx2 + Math.sin(x_axis_rotation) * dy2\n      const y1p = -Math.sin(x_axis_rotation) * dx2 + Math.cos(x_axis_rotation) * dy2\n\n      // Compute (cx', cy')\n      let rxs = rx * rx\n      let rys = ry * ry\n      const x1ps = x1p * x1p\n      const y1ps = y1p * y1p\n\n      // Ensure radii are large enough\n      const cr = x1ps / rxs + y1ps / rys\n\n      if (cr > 1) {\n        // scale up rx,ry equally so cr == 1\n        const s = Math.sqrt(cr)\n        rx = s * rx\n        ry = s * ry\n        rxs = rx * rx\n        rys = ry * ry\n      }\n\n      const dq = rxs * y1ps + rys * x1ps\n      const pq = (rxs * rys - dq) / dq\n      let q = Math.sqrt(Math.max(0, pq))\n      if (large_arc_flag === sweep_flag) q = -q\n      const cxp = (q * rx * y1p) / ry\n      const cyp = (-q * ry * x1p) / rx\n\n      // Step 3: Compute (cx, cy) from (cx', cy')\n      const cx = Math.cos(x_axis_rotation) * cxp - Math.sin(x_axis_rotation) * cyp + (start.x + end.x) / 2\n      const cy = Math.sin(x_axis_rotation) * cxp + Math.cos(x_axis_rotation) * cyp + (start.y + end.y) / 2\n\n      // Step 4: Compute θ1 and Δθ\n      const theta = svgAngle(1, 0, (x1p - cxp) / rx, (y1p - cyp) / ry)\n      const delta = svgAngle((x1p - cxp) / rx, (y1p - cyp) / ry, (-x1p - cxp) / rx, (-y1p - cyp) / ry) % (Math.PI * 2)\n\n      path.currentPath.absellipse(cx, cy, rx, ry, theta, theta + delta, sweep_flag === 0, x_axis_rotation)\n    }\n\n    function svgAngle(ux, uy, vx, vy) {\n      const dot = ux * vx + uy * vy\n      const len = Math.sqrt(ux * ux + uy * uy) * Math.sqrt(vx * vx + vy * vy)\n      let ang = Math.acos(Math.max(-1, Math.min(1, dot / len))) // floating point precision, slightly over values appear\n      if (ux * vy - uy * vx < 0) ang = -ang\n      return ang\n    }\n\n    /*\n     * According to https://www.w3.org/TR/SVG/shapes.html#RectElementRXAttribute\n     * rounded corner should be rendered to elliptical arc, but bezier curve does the job well enough\n     */\n    function parseRectNode(node) {\n      const x = parseFloatWithUnits(node.getAttribute('x') || 0)\n      const y = parseFloatWithUnits(node.getAttribute('y') || 0)\n      const rx = parseFloatWithUnits(node.getAttribute('rx') || node.getAttribute('ry') || 0)\n      const ry = parseFloatWithUnits(node.getAttribute('ry') || node.getAttribute('rx') || 0)\n      const w = parseFloatWithUnits(node.getAttribute('width'))\n      const h = parseFloatWithUnits(node.getAttribute('height'))\n\n      // Ellipse arc to Bezier approximation Coefficient (Inversed). See:\n      // https://spencermortensen.com/articles/bezier-circle/\n      const bci = 1 - 0.551915024494\n\n      const path = new ShapePath()\n\n      // top left\n      path.moveTo(x + rx, y)\n\n      // top right\n      path.lineTo(x + w - rx, y)\n      if (rx !== 0 || ry !== 0) {\n        path.bezierCurveTo(x + w - rx * bci, y, x + w, y + ry * bci, x + w, y + ry)\n      }\n\n      // bottom right\n      path.lineTo(x + w, y + h - ry)\n      if (rx !== 0 || ry !== 0) {\n        path.bezierCurveTo(x + w, y + h - ry * bci, x + w - rx * bci, y + h, x + w - rx, y + h)\n      }\n\n      // bottom left\n      path.lineTo(x + rx, y + h)\n      if (rx !== 0 || ry !== 0) {\n        path.bezierCurveTo(x + rx * bci, y + h, x, y + h - ry * bci, x, y + h - ry)\n      }\n\n      // back to top left\n      path.lineTo(x, y + ry)\n      if (rx !== 0 || ry !== 0) {\n        path.bezierCurveTo(x, y + ry * bci, x + rx * bci, y, x + rx, y)\n      }\n\n      return path\n    }\n\n    function parsePolygonNode(node) {\n      function iterator(match, a, b) {\n        const x = parseFloatWithUnits(a)\n        const y = parseFloatWithUnits(b)\n\n        if (index === 0) {\n          path.moveTo(x, y)\n        } else {\n          path.lineTo(x, y)\n        }\n\n        index++\n      }\n\n      const regex = /([+-]?\\d*\\.?\\d+(?:e[+-]?\\d+)?)(?:,|\\s)([+-]?\\d*\\.?\\d+(?:e[+-]?\\d+)?)/g\n\n      const path = new ShapePath()\n\n      let index = 0\n\n      node.getAttribute('points').replace(regex, iterator)\n\n      path.currentPath.autoClose = true\n\n      return path\n    }\n\n    function parsePolylineNode(node) {\n      function iterator(match, a, b) {\n        const x = parseFloatWithUnits(a)\n        const y = parseFloatWithUnits(b)\n\n        if (index === 0) {\n          path.moveTo(x, y)\n        } else {\n          path.lineTo(x, y)\n        }\n\n        index++\n      }\n\n      const regex = /([+-]?\\d*\\.?\\d+(?:e[+-]?\\d+)?)(?:,|\\s)([+-]?\\d*\\.?\\d+(?:e[+-]?\\d+)?)/g\n\n      const path = new ShapePath()\n\n      let index = 0\n\n      node.getAttribute('points').replace(regex, iterator)\n\n      path.currentPath.autoClose = false\n\n      return path\n    }\n\n    function parseCircleNode(node) {\n      const x = parseFloatWithUnits(node.getAttribute('cx') || 0)\n      const y = parseFloatWithUnits(node.getAttribute('cy') || 0)\n      const r = parseFloatWithUnits(node.getAttribute('r') || 0)\n\n      const subpath = new Path()\n      subpath.absarc(x, y, r, 0, Math.PI * 2)\n\n      const path = new ShapePath()\n      path.subPaths.push(subpath)\n\n      return path\n    }\n\n    function parseEllipseNode(node) {\n      const x = parseFloatWithUnits(node.getAttribute('cx') || 0)\n      const y = parseFloatWithUnits(node.getAttribute('cy') || 0)\n      const rx = parseFloatWithUnits(node.getAttribute('rx') || 0)\n      const ry = parseFloatWithUnits(node.getAttribute('ry') || 0)\n\n      const subpath = new Path()\n      subpath.absellipse(x, y, rx, ry, 0, Math.PI * 2)\n\n      const path = new ShapePath()\n      path.subPaths.push(subpath)\n\n      return path\n    }\n\n    function parseLineNode(node) {\n      const x1 = parseFloatWithUnits(node.getAttribute('x1') || 0)\n      const y1 = parseFloatWithUnits(node.getAttribute('y1') || 0)\n      const x2 = parseFloatWithUnits(node.getAttribute('x2') || 0)\n      const y2 = parseFloatWithUnits(node.getAttribute('y2') || 0)\n\n      const path = new ShapePath()\n      path.moveTo(x1, y1)\n      path.lineTo(x2, y2)\n      path.currentPath.autoClose = false\n\n      return path\n    }\n\n    //\n\n    function parseStyle(node, style) {\n      style = Object.assign({}, style) // clone style\n\n      let stylesheetStyles = {}\n\n      if (node.hasAttribute('class')) {\n        const classSelectors = node\n          .getAttribute('class')\n          .split(/\\s/)\n          .filter(Boolean)\n          .map((i) => i.trim())\n\n        for (let i = 0; i < classSelectors.length; i++) {\n          stylesheetStyles = Object.assign(stylesheetStyles, stylesheets['.' + classSelectors[i]])\n        }\n      }\n\n      if (node.hasAttribute('id')) {\n        stylesheetStyles = Object.assign(stylesheetStyles, stylesheets['#' + node.getAttribute('id')])\n      }\n\n      function addStyle(svgName, jsName, adjustFunction) {\n        if (adjustFunction === undefined)\n          adjustFunction = function copy(v) {\n            if (v.startsWith('url')) console.warn('SVGLoader: url access in attributes is not implemented.')\n\n            return v\n          }\n\n        if (node.hasAttribute(svgName)) style[jsName] = adjustFunction(node.getAttribute(svgName))\n        if (stylesheetStyles[svgName]) style[jsName] = adjustFunction(stylesheetStyles[svgName])\n        if (node.style && node.style[svgName] !== '') style[jsName] = adjustFunction(node.style[svgName])\n      }\n\n      function clamp(v) {\n        return Math.max(0, Math.min(1, parseFloatWithUnits(v)))\n      }\n\n      function positive(v) {\n        return Math.max(0, parseFloatWithUnits(v))\n      }\n\n      addStyle('fill', 'fill')\n      addStyle('fill-opacity', 'fillOpacity', clamp)\n      addStyle('fill-rule', 'fillRule')\n      addStyle('opacity', 'opacity', clamp)\n      addStyle('stroke', 'stroke')\n      addStyle('stroke-opacity', 'strokeOpacity', clamp)\n      addStyle('stroke-width', 'strokeWidth', positive)\n      addStyle('stroke-linejoin', 'strokeLineJoin')\n      addStyle('stroke-linecap', 'strokeLineCap')\n      addStyle('stroke-miterlimit', 'strokeMiterLimit', positive)\n      addStyle('visibility', 'visibility')\n\n      return style\n    }\n\n    // http://www.w3.org/TR/SVG11/implnote.html#PathElementImplementationNotes\n\n    function getReflection(a, b) {\n      return a - (b - a)\n    }\n\n    // from https://github.com/ppvg/svg-numbers (MIT License)\n\n    function parseFloats(input, flags, stride) {\n      if (typeof input !== 'string') {\n        throw new TypeError('Invalid input: ' + typeof input)\n      }\n\n      // Character groups\n      const RE = {\n        SEPARATOR: /[ \\t\\r\\n\\,.\\-+]/,\n        WHITESPACE: /[ \\t\\r\\n]/,\n        DIGIT: /[\\d]/,\n        SIGN: /[-+]/,\n        POINT: /\\./,\n        COMMA: /,/,\n        EXP: /e/i,\n        FLAGS: /[01]/,\n      }\n\n      // States\n      const SEP = 0\n      const INT = 1\n      const FLOAT = 2\n      const EXP = 3\n\n      let state = SEP\n      let seenComma = true\n      let number = '',\n        exponent = ''\n      const result = []\n\n      function throwSyntaxError(current, i, partial) {\n        const error = new SyntaxError('Unexpected character \"' + current + '\" at index ' + i + '.')\n        error.partial = partial\n        throw error\n      }\n\n      function newNumber() {\n        if (number !== '') {\n          if (exponent === '') result.push(Number(number))\n          else result.push(Number(number) * Math.pow(10, Number(exponent)))\n        }\n\n        number = ''\n        exponent = ''\n      }\n\n      let current\n      const length = input.length\n\n      for (let i = 0; i < length; i++) {\n        current = input[i]\n\n        // check for flags\n        if (Array.isArray(flags) && flags.includes(result.length % stride) && RE.FLAGS.test(current)) {\n          state = INT\n          number = current\n          newNumber()\n          continue\n        }\n\n        // parse until next number\n        if (state === SEP) {\n          // eat whitespace\n          if (RE.WHITESPACE.test(current)) {\n            continue\n          }\n\n          // start new number\n          if (RE.DIGIT.test(current) || RE.SIGN.test(current)) {\n            state = INT\n            number = current\n            continue\n          }\n\n          if (RE.POINT.test(current)) {\n            state = FLOAT\n            number = current\n            continue\n          }\n\n          // throw on double commas (e.g. \"1, , 2\")\n          if (RE.COMMA.test(current)) {\n            if (seenComma) {\n              throwSyntaxError(current, i, result)\n            }\n\n            seenComma = true\n          }\n        }\n\n        // parse integer part\n        if (state === INT) {\n          if (RE.DIGIT.test(current)) {\n            number += current\n            continue\n          }\n\n          if (RE.POINT.test(current)) {\n            number += current\n            state = FLOAT\n            continue\n          }\n\n          if (RE.EXP.test(current)) {\n            state = EXP\n            continue\n          }\n\n          // throw on double signs (\"-+1\"), but not on sign as separator (\"-1-2\")\n          if (RE.SIGN.test(current) && number.length === 1 && RE.SIGN.test(number[0])) {\n            throwSyntaxError(current, i, result)\n          }\n        }\n\n        // parse decimal part\n        if (state === FLOAT) {\n          if (RE.DIGIT.test(current)) {\n            number += current\n            continue\n          }\n\n          if (RE.EXP.test(current)) {\n            state = EXP\n            continue\n          }\n\n          // throw on double decimal points (e.g. \"1..2\")\n          if (RE.POINT.test(current) && number[number.length - 1] === '.') {\n            throwSyntaxError(current, i, result)\n          }\n        }\n\n        // parse exponent part\n        if (state === EXP) {\n          if (RE.DIGIT.test(current)) {\n            exponent += current\n            continue\n          }\n\n          if (RE.SIGN.test(current)) {\n            if (exponent === '') {\n              exponent += current\n              continue\n            }\n\n            if (exponent.length === 1 && RE.SIGN.test(exponent)) {\n              throwSyntaxError(current, i, result)\n            }\n          }\n        }\n\n        // end of number\n        if (RE.WHITESPACE.test(current)) {\n          newNumber()\n          state = SEP\n          seenComma = false\n        } else if (RE.COMMA.test(current)) {\n          newNumber()\n          state = SEP\n          seenComma = true\n        } else if (RE.SIGN.test(current)) {\n          newNumber()\n          state = INT\n          number = current\n        } else if (RE.POINT.test(current)) {\n          newNumber()\n          state = FLOAT\n          number = current\n        } else {\n          throwSyntaxError(current, i, result)\n        }\n      }\n\n      // add the last number found (if any)\n      newNumber()\n\n      return result\n    }\n\n    // Units\n\n    const units = ['mm', 'cm', 'in', 'pt', 'pc', 'px']\n\n    // Conversion: [ fromUnit ][ toUnit ] (-1 means dpi dependent)\n    const unitConversion = {\n      mm: {\n        mm: 1,\n        cm: 0.1,\n        in: 1 / 25.4,\n        pt: 72 / 25.4,\n        pc: 6 / 25.4,\n        px: -1,\n      },\n      cm: {\n        mm: 10,\n        cm: 1,\n        in: 1 / 2.54,\n        pt: 72 / 2.54,\n        pc: 6 / 2.54,\n        px: -1,\n      },\n      in: {\n        mm: 25.4,\n        cm: 2.54,\n        in: 1,\n        pt: 72,\n        pc: 6,\n        px: -1,\n      },\n      pt: {\n        mm: 25.4 / 72,\n        cm: 2.54 / 72,\n        in: 1 / 72,\n        pt: 1,\n        pc: 6 / 72,\n        px: -1,\n      },\n      pc: {\n        mm: 25.4 / 6,\n        cm: 2.54 / 6,\n        in: 1 / 6,\n        pt: 72 / 6,\n        pc: 1,\n        px: -1,\n      },\n      px: {\n        px: 1,\n      },\n    }\n\n    function parseFloatWithUnits(string) {\n      let theUnit = 'px'\n\n      if (typeof string === 'string' || string instanceof String) {\n        for (let i = 0, n = units.length; i < n; i++) {\n          const u = units[i]\n\n          if (string.endsWith(u)) {\n            theUnit = u\n            string = string.substring(0, string.length - u.length)\n            break\n          }\n        }\n      }\n\n      let scale = undefined\n\n      if (theUnit === 'px' && scope.defaultUnit !== 'px') {\n        // Conversion scale from  pixels to inches, then to default units\n\n        scale = unitConversion['in'][scope.defaultUnit] / scope.defaultDPI\n      } else {\n        scale = unitConversion[theUnit][scope.defaultUnit]\n\n        if (scale < 0) {\n          // Conversion scale to pixels\n\n          scale = unitConversion[theUnit]['in'] * scope.defaultDPI\n        }\n      }\n\n      return scale * parseFloat(string)\n    }\n\n    // Transforms\n\n    function getNodeTransform(node) {\n      if (\n        !(\n          node.hasAttribute('transform') ||\n          (node.nodeName === 'use' && (node.hasAttribute('x') || node.hasAttribute('y')))\n        )\n      ) {\n        return null\n      }\n\n      const transform = parseNodeTransform(node)\n\n      if (transformStack.length > 0) {\n        transform.premultiply(transformStack[transformStack.length - 1])\n      }\n\n      currentTransform.copy(transform)\n      transformStack.push(transform)\n\n      return transform\n    }\n\n    function parseNodeTransform(node) {\n      const transform = new Matrix3()\n      const currentTransform = tempTransform0\n\n      if (node.nodeName === 'use' && (node.hasAttribute('x') || node.hasAttribute('y'))) {\n        const tx = parseFloatWithUnits(node.getAttribute('x'))\n        const ty = parseFloatWithUnits(node.getAttribute('y'))\n\n        transform.translate(tx, ty)\n      }\n\n      if (node.hasAttribute('transform')) {\n        const transformsTexts = node.getAttribute('transform').split(')')\n\n        for (let tIndex = transformsTexts.length - 1; tIndex >= 0; tIndex--) {\n          const transformText = transformsTexts[tIndex].trim()\n\n          if (transformText === '') continue\n\n          const openParPos = transformText.indexOf('(')\n          const closeParPos = transformText.length\n\n          if (openParPos > 0 && openParPos < closeParPos) {\n            const transformType = transformText.slice(0, openParPos)\n\n            const array = parseFloats(transformText.slice(openParPos + 1))\n\n            currentTransform.identity()\n\n            switch (transformType) {\n              case 'translate':\n                if (array.length >= 1) {\n                  const tx = array[0]\n                  let ty = 0\n\n                  if (array.length >= 2) {\n                    ty = array[1]\n                  }\n\n                  currentTransform.translate(tx, ty)\n                }\n\n                break\n\n              case 'rotate':\n                if (array.length >= 1) {\n                  let angle = 0\n                  let cx = 0\n                  let cy = 0\n\n                  // Angle\n                  angle = (array[0] * Math.PI) / 180\n\n                  if (array.length >= 3) {\n                    // Center x, y\n                    cx = array[1]\n                    cy = array[2]\n                  }\n\n                  // Rotate around center (cx, cy)\n                  tempTransform1.makeTranslation(-cx, -cy)\n                  tempTransform2.makeRotation(angle)\n                  tempTransform3.multiplyMatrices(tempTransform2, tempTransform1)\n                  tempTransform1.makeTranslation(cx, cy)\n                  currentTransform.multiplyMatrices(tempTransform1, tempTransform3)\n                }\n\n                break\n\n              case 'scale':\n                if (array.length >= 1) {\n                  const scaleX = array[0]\n                  let scaleY = scaleX\n\n                  if (array.length >= 2) {\n                    scaleY = array[1]\n                  }\n\n                  currentTransform.scale(scaleX, scaleY)\n                }\n\n                break\n\n              case 'skewX':\n                if (array.length === 1) {\n                  currentTransform.set(1, Math.tan((array[0] * Math.PI) / 180), 0, 0, 1, 0, 0, 0, 1)\n                }\n\n                break\n\n              case 'skewY':\n                if (array.length === 1) {\n                  currentTransform.set(1, 0, 0, Math.tan((array[0] * Math.PI) / 180), 1, 0, 0, 0, 1)\n                }\n\n                break\n\n              case 'matrix':\n                if (array.length === 6) {\n                  currentTransform.set(array[0], array[2], array[4], array[1], array[3], array[5], 0, 0, 1)\n                }\n\n                break\n            }\n          }\n\n          transform.premultiply(currentTransform)\n        }\n      }\n\n      return transform\n    }\n\n    function transformPath(path, m) {\n      function transfVec2(v2) {\n        tempV3.set(v2.x, v2.y, 1).applyMatrix3(m)\n\n        v2.set(tempV3.x, tempV3.y)\n      }\n\n      function transfEllipseGeneric(curve) {\n        // For math description see:\n        // https://math.stackexchange.com/questions/4544164\n\n        const a = curve.xRadius\n        const b = curve.yRadius\n\n        const cosTheta = Math.cos(curve.aRotation)\n        const sinTheta = Math.sin(curve.aRotation)\n\n        const v1 = new Vector3(a * cosTheta, a * sinTheta, 0)\n        const v2 = new Vector3(-b * sinTheta, b * cosTheta, 0)\n\n        const f1 = v1.applyMatrix3(m)\n        const f2 = v2.applyMatrix3(m)\n\n        const mF = tempTransform0.set(f1.x, f2.x, 0, f1.y, f2.y, 0, 0, 0, 1)\n\n        const mFInv = tempTransform1.copy(mF).invert()\n        const mFInvT = tempTransform2.copy(mFInv).transpose()\n        const mQ = mFInvT.multiply(mFInv)\n        const mQe = mQ.elements\n\n        const ed = eigenDecomposition(mQe[0], mQe[1], mQe[4])\n        const rt1sqrt = Math.sqrt(ed.rt1)\n        const rt2sqrt = Math.sqrt(ed.rt2)\n\n        curve.xRadius = 1 / rt1sqrt\n        curve.yRadius = 1 / rt2sqrt\n        curve.aRotation = Math.atan2(ed.sn, ed.cs)\n\n        const isFullEllipse = (curve.aEndAngle - curve.aStartAngle) % (2 * Math.PI) < Number.EPSILON\n\n        // Do not touch angles of a full ellipse because after transformation they\n        // would converge to a sinle value effectively removing the whole curve\n\n        if (!isFullEllipse) {\n          const mDsqrt = tempTransform1.set(rt1sqrt, 0, 0, 0, rt2sqrt, 0, 0, 0, 1)\n\n          const mRT = tempTransform2.set(ed.cs, ed.sn, 0, -ed.sn, ed.cs, 0, 0, 0, 1)\n\n          const mDRF = mDsqrt.multiply(mRT).multiply(mF)\n\n          const transformAngle = (phi) => {\n            const { x: cosR, y: sinR } = new Vector3(Math.cos(phi), Math.sin(phi), 0).applyMatrix3(mDRF)\n\n            return Math.atan2(sinR, cosR)\n          }\n\n          curve.aStartAngle = transformAngle(curve.aStartAngle)\n          curve.aEndAngle = transformAngle(curve.aEndAngle)\n\n          if (isTransformFlipped(m)) {\n            curve.aClockwise = !curve.aClockwise\n          }\n        }\n      }\n\n      function transfEllipseNoSkew(curve) {\n        // Faster shortcut if no skew is applied\n        // (e.g, a euclidean transform of a group containing the ellipse)\n\n        const sx = getTransformScaleX(m)\n        const sy = getTransformScaleY(m)\n\n        curve.xRadius *= sx\n        curve.yRadius *= sy\n\n        // Extract rotation angle from the matrix of form:\n        //\n        //  | cosθ sx   -sinθ sy |\n        //  | sinθ sx    cosθ sy |\n        //\n        // Remembering that tanθ = sinθ / cosθ; and that\n        // `sx`, `sy`, or both might be zero.\n        const theta =\n          sx > Number.EPSILON ? Math.atan2(m.elements[1], m.elements[0]) : Math.atan2(-m.elements[3], m.elements[4])\n\n        curve.aRotation += theta\n\n        if (isTransformFlipped(m)) {\n          curve.aStartAngle *= -1\n          curve.aEndAngle *= -1\n          curve.aClockwise = !curve.aClockwise\n        }\n      }\n\n      const subPaths = path.subPaths\n\n      for (let i = 0, n = subPaths.length; i < n; i++) {\n        const subPath = subPaths[i]\n        const curves = subPath.curves\n\n        for (let j = 0; j < curves.length; j++) {\n          const curve = curves[j]\n\n          if (curve.isLineCurve) {\n            transfVec2(curve.v1)\n            transfVec2(curve.v2)\n          } else if (curve.isCubicBezierCurve) {\n            transfVec2(curve.v0)\n            transfVec2(curve.v1)\n            transfVec2(curve.v2)\n            transfVec2(curve.v3)\n          } else if (curve.isQuadraticBezierCurve) {\n            transfVec2(curve.v0)\n            transfVec2(curve.v1)\n            transfVec2(curve.v2)\n          } else if (curve.isEllipseCurve) {\n            // Transform ellipse center point\n\n            tempV2.set(curve.aX, curve.aY)\n            transfVec2(tempV2)\n            curve.aX = tempV2.x\n            curve.aY = tempV2.y\n\n            // Transform ellipse shape parameters\n\n            if (isTransformSkewed(m)) {\n              transfEllipseGeneric(curve)\n            } else {\n              transfEllipseNoSkew(curve)\n            }\n          }\n        }\n      }\n    }\n\n    function isTransformFlipped(m) {\n      const te = m.elements\n      return te[0] * te[4] - te[1] * te[3] < 0\n    }\n\n    function isTransformSkewed(m) {\n      const te = m.elements\n      const basisDot = te[0] * te[3] + te[1] * te[4]\n\n      // Shortcut for trivial rotations and transformations\n      if (basisDot === 0) return false\n\n      const sx = getTransformScaleX(m)\n      const sy = getTransformScaleY(m)\n\n      return Math.abs(basisDot / (sx * sy)) > Number.EPSILON\n    }\n\n    function getTransformScaleX(m) {\n      const te = m.elements\n      return Math.sqrt(te[0] * te[0] + te[1] * te[1])\n    }\n\n    function getTransformScaleY(m) {\n      const te = m.elements\n      return Math.sqrt(te[3] * te[3] + te[4] * te[4])\n    }\n\n    // Calculates the eigensystem of a real symmetric 2x2 matrix\n    //    [ A  B ]\n    //    [ B  C ]\n    // in the form\n    //    [ A  B ]  =  [ cs  -sn ] [ rt1   0  ] [  cs  sn ]\n    //    [ B  C ]     [ sn   cs ] [  0   rt2 ] [ -sn  cs ]\n    // where rt1 >= rt2.\n    //\n    // Adapted from: https://www.mpi-hd.mpg.de/personalhomes/globes/3x3/index.html\n    // -> Algorithms for real symmetric matrices -> Analytical (2x2 symmetric)\n    function eigenDecomposition(A, B, C) {\n      let rt1, rt2, cs, sn, t\n      const sm = A + C\n      const df = A - C\n      const rt = Math.sqrt(df * df + 4 * B * B)\n\n      if (sm > 0) {\n        rt1 = 0.5 * (sm + rt)\n        t = 1 / rt1\n        rt2 = A * t * C - B * t * B\n      } else if (sm < 0) {\n        rt2 = 0.5 * (sm - rt)\n      } else {\n        // This case needs to be treated separately to avoid div by 0\n\n        rt1 = 0.5 * rt\n        rt2 = -0.5 * rt\n      }\n\n      // Calculate eigenvectors\n\n      if (df > 0) {\n        cs = df + rt\n      } else {\n        cs = df - rt\n      }\n\n      if (Math.abs(cs) > 2 * Math.abs(B)) {\n        t = (-2 * B) / cs\n        sn = 1 / Math.sqrt(1 + t * t)\n        cs = t * sn\n      } else if (Math.abs(B) === 0) {\n        cs = 1\n        sn = 0\n      } else {\n        t = (-0.5 * cs) / B\n        cs = 1 / Math.sqrt(1 + t * t)\n        sn = t * cs\n      }\n\n      if (df > 0) {\n        t = cs\n        cs = -sn\n        sn = t\n      }\n\n      return { rt1, rt2, cs, sn }\n    }\n\n    //\n\n    const paths = []\n    const stylesheets = {}\n\n    const transformStack = []\n\n    const tempTransform0 = new Matrix3()\n    const tempTransform1 = new Matrix3()\n    const tempTransform2 = new Matrix3()\n    const tempTransform3 = new Matrix3()\n    const tempV2 = new Vector2()\n    const tempV3 = new Vector3()\n\n    const currentTransform = new Matrix3()\n\n    const xml = new DOMParser().parseFromString(text, 'image/svg+xml') // application/xml\n\n    parseNode(xml.documentElement, {\n      fill: '#000',\n      fillOpacity: 1,\n      strokeOpacity: 1,\n      strokeWidth: 1,\n      strokeLineJoin: 'miter',\n      strokeLineCap: 'butt',\n      strokeMiterLimit: 4,\n    })\n\n    const data = { paths: paths, xml: xml.documentElement }\n\n    // console.log( paths );\n    return data\n  }\n\n  static createShapes(shapePath) {\n    // Param shapePath: a shapepath as returned by the parse function of this class\n    // Returns Shape object\n\n    const BIGNUMBER = 999999999\n\n    const IntersectionLocationType = {\n      ORIGIN: 0,\n      DESTINATION: 1,\n      BETWEEN: 2,\n      LEFT: 3,\n      RIGHT: 4,\n      BEHIND: 5,\n      BEYOND: 6,\n    }\n\n    const classifyResult = {\n      loc: IntersectionLocationType.ORIGIN,\n      t: 0,\n    }\n\n    function findEdgeIntersection(a0, a1, b0, b1) {\n      const x1 = a0.x\n      const x2 = a1.x\n      const x3 = b0.x\n      const x4 = b1.x\n      const y1 = a0.y\n      const y2 = a1.y\n      const y3 = b0.y\n      const y4 = b1.y\n      const nom1 = (x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3)\n      const nom2 = (x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3)\n      const denom = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1)\n      const t1 = nom1 / denom\n      const t2 = nom2 / denom\n\n      if ((denom === 0 && nom1 !== 0) || t1 <= 0 || t1 >= 1 || t2 < 0 || t2 > 1) {\n        //1. lines are parallel or edges don't intersect\n\n        return null\n      } else if (nom1 === 0 && denom === 0) {\n        //2. lines are colinear\n\n        //check if endpoints of edge2 (b0-b1) lies on edge1 (a0-a1)\n        for (let i = 0; i < 2; i++) {\n          classifyPoint(i === 0 ? b0 : b1, a0, a1)\n          //find position of this endpoints relatively to edge1\n          if (classifyResult.loc == IntersectionLocationType.ORIGIN) {\n            const point = i === 0 ? b0 : b1\n            return { x: point.x, y: point.y, t: classifyResult.t }\n          } else if (classifyResult.loc == IntersectionLocationType.BETWEEN) {\n            const x = +(x1 + classifyResult.t * (x2 - x1)).toPrecision(10)\n            const y = +(y1 + classifyResult.t * (y2 - y1)).toPrecision(10)\n            return { x: x, y: y, t: classifyResult.t }\n          }\n        }\n\n        return null\n      } else {\n        //3. edges intersect\n\n        for (let i = 0; i < 2; i++) {\n          classifyPoint(i === 0 ? b0 : b1, a0, a1)\n\n          if (classifyResult.loc == IntersectionLocationType.ORIGIN) {\n            const point = i === 0 ? b0 : b1\n            return { x: point.x, y: point.y, t: classifyResult.t }\n          }\n        }\n\n        const x = +(x1 + t1 * (x2 - x1)).toPrecision(10)\n        const y = +(y1 + t1 * (y2 - y1)).toPrecision(10)\n        return { x: x, y: y, t: t1 }\n      }\n    }\n\n    function classifyPoint(p, edgeStart, edgeEnd) {\n      const ax = edgeEnd.x - edgeStart.x\n      const ay = edgeEnd.y - edgeStart.y\n      const bx = p.x - edgeStart.x\n      const by = p.y - edgeStart.y\n      const sa = ax * by - bx * ay\n\n      if (p.x === edgeStart.x && p.y === edgeStart.y) {\n        classifyResult.loc = IntersectionLocationType.ORIGIN\n        classifyResult.t = 0\n        return\n      }\n\n      if (p.x === edgeEnd.x && p.y === edgeEnd.y) {\n        classifyResult.loc = IntersectionLocationType.DESTINATION\n        classifyResult.t = 1\n        return\n      }\n\n      if (sa < -Number.EPSILON) {\n        classifyResult.loc = IntersectionLocationType.LEFT\n        return\n      }\n\n      if (sa > Number.EPSILON) {\n        classifyResult.loc = IntersectionLocationType.RIGHT\n        return\n      }\n\n      if (ax * bx < 0 || ay * by < 0) {\n        classifyResult.loc = IntersectionLocationType.BEHIND\n        return\n      }\n\n      if (Math.sqrt(ax * ax + ay * ay) < Math.sqrt(bx * bx + by * by)) {\n        classifyResult.loc = IntersectionLocationType.BEYOND\n        return\n      }\n\n      let t\n\n      if (ax !== 0) {\n        t = bx / ax\n      } else {\n        t = by / ay\n      }\n\n      classifyResult.loc = IntersectionLocationType.BETWEEN\n      classifyResult.t = t\n    }\n\n    function getIntersections(path1, path2) {\n      const intersectionsRaw = []\n      const intersections = []\n\n      for (let index = 1; index < path1.length; index++) {\n        const path1EdgeStart = path1[index - 1]\n        const path1EdgeEnd = path1[index]\n\n        for (let index2 = 1; index2 < path2.length; index2++) {\n          const path2EdgeStart = path2[index2 - 1]\n          const path2EdgeEnd = path2[index2]\n\n          const intersection = findEdgeIntersection(path1EdgeStart, path1EdgeEnd, path2EdgeStart, path2EdgeEnd)\n\n          if (\n            intersection !== null &&\n            intersectionsRaw.find(\n              (i) => i.t <= intersection.t + Number.EPSILON && i.t >= intersection.t - Number.EPSILON,\n            ) === undefined\n          ) {\n            intersectionsRaw.push(intersection)\n            intersections.push(new Vector2(intersection.x, intersection.y))\n          }\n        }\n      }\n\n      return intersections\n    }\n\n    function getScanlineIntersections(scanline, boundingBox, paths) {\n      const center = new Vector2()\n      boundingBox.getCenter(center)\n\n      const allIntersections = []\n\n      paths.forEach((path) => {\n        // check if the center of the bounding box is in the bounding box of the paths.\n        // this is a pruning method to limit the search of intersections in paths that can't envelop of the current path.\n        // if a path envelops another path. The center of that oter path, has to be inside the bounding box of the enveloping path.\n        if (path.boundingBox.containsPoint(center)) {\n          const intersections = getIntersections(scanline, path.points)\n\n          intersections.forEach((p) => {\n            allIntersections.push({ identifier: path.identifier, isCW: path.isCW, point: p })\n          })\n        }\n      })\n\n      allIntersections.sort((i1, i2) => {\n        return i1.point.x - i2.point.x\n      })\n\n      return allIntersections\n    }\n\n    function isHoleTo(simplePath, allPaths, scanlineMinX, scanlineMaxX, _fillRule) {\n      if (_fillRule === null || _fillRule === undefined || _fillRule === '') {\n        _fillRule = 'nonzero'\n      }\n\n      const centerBoundingBox = new Vector2()\n      simplePath.boundingBox.getCenter(centerBoundingBox)\n\n      const scanline = [new Vector2(scanlineMinX, centerBoundingBox.y), new Vector2(scanlineMaxX, centerBoundingBox.y)]\n\n      const scanlineIntersections = getScanlineIntersections(scanline, simplePath.boundingBox, allPaths)\n\n      scanlineIntersections.sort((i1, i2) => {\n        return i1.point.x - i2.point.x\n      })\n\n      const baseIntersections = []\n      const otherIntersections = []\n\n      scanlineIntersections.forEach((i) => {\n        if (i.identifier === simplePath.identifier) {\n          baseIntersections.push(i)\n        } else {\n          otherIntersections.push(i)\n        }\n      })\n\n      const firstXOfPath = baseIntersections[0].point.x\n\n      // build up the path hierarchy\n      const stack = []\n      let i = 0\n\n      while (i < otherIntersections.length && otherIntersections[i].point.x < firstXOfPath) {\n        if (stack.length > 0 && stack[stack.length - 1] === otherIntersections[i].identifier) {\n          stack.pop()\n        } else {\n          stack.push(otherIntersections[i].identifier)\n        }\n\n        i++\n      }\n\n      stack.push(simplePath.identifier)\n\n      if (_fillRule === 'evenodd') {\n        const isHole = stack.length % 2 === 0 ? true : false\n        const isHoleFor = stack[stack.length - 2]\n\n        return { identifier: simplePath.identifier, isHole: isHole, for: isHoleFor }\n      } else if (_fillRule === 'nonzero') {\n        // check if path is a hole by counting the amount of paths with alternating rotations it has to cross.\n        let isHole = true\n        let isHoleFor = null\n        let lastCWValue = null\n\n        for (let i = 0; i < stack.length; i++) {\n          const identifier = stack[i]\n          if (isHole) {\n            lastCWValue = allPaths[identifier].isCW\n            isHole = false\n            isHoleFor = identifier\n          } else if (lastCWValue !== allPaths[identifier].isCW) {\n            lastCWValue = allPaths[identifier].isCW\n            isHole = true\n          }\n        }\n\n        return { identifier: simplePath.identifier, isHole: isHole, for: isHoleFor }\n      } else {\n        console.warn('fill-rule: \"' + _fillRule + '\" is currently not implemented.')\n      }\n    }\n\n    // check for self intersecting paths\n    // TODO\n\n    // check intersecting paths\n    // TODO\n\n    // prepare paths for hole detection\n    let scanlineMinX = BIGNUMBER\n    let scanlineMaxX = -BIGNUMBER\n\n    let simplePaths = shapePath.subPaths.map((p) => {\n      const points = p.getPoints()\n      let maxY = -BIGNUMBER\n      let minY = BIGNUMBER\n      let maxX = -BIGNUMBER\n      let minX = BIGNUMBER\n\n      //points.forEach(p => p.y *= -1);\n\n      for (let i = 0; i < points.length; i++) {\n        const p = points[i]\n\n        if (p.y > maxY) {\n          maxY = p.y\n        }\n\n        if (p.y < minY) {\n          minY = p.y\n        }\n\n        if (p.x > maxX) {\n          maxX = p.x\n        }\n\n        if (p.x < minX) {\n          minX = p.x\n        }\n      }\n\n      //\n      if (scanlineMaxX <= maxX) {\n        scanlineMaxX = maxX + 1\n      }\n\n      if (scanlineMinX >= minX) {\n        scanlineMinX = minX - 1\n      }\n\n      return {\n        curves: p.curves,\n        points: points,\n        isCW: ShapeUtils.isClockWise(points),\n        identifier: -1,\n        boundingBox: new Box2(new Vector2(minX, minY), new Vector2(maxX, maxY)),\n      }\n    })\n\n    simplePaths = simplePaths.filter((sp) => sp.points.length > 1)\n\n    for (let identifier = 0; identifier < simplePaths.length; identifier++) {\n      simplePaths[identifier].identifier = identifier\n    }\n\n    // check if path is solid or a hole\n    const isAHole = simplePaths.map((p) =>\n      isHoleTo(\n        p,\n        simplePaths,\n        scanlineMinX,\n        scanlineMaxX,\n        shapePath.userData ? shapePath.userData.style.fillRule : undefined,\n      ),\n    )\n\n    const shapesToReturn = []\n    simplePaths.forEach((p) => {\n      const amIAHole = isAHole[p.identifier]\n\n      if (!amIAHole.isHole) {\n        const shape = new Shape()\n        shape.curves = p.curves\n        const holes = isAHole.filter((h) => h.isHole && h.for === p.identifier)\n        holes.forEach((h) => {\n          const hole = simplePaths[h.identifier]\n          const path = new Path()\n          path.curves = hole.curves\n          shape.holes.push(path)\n        })\n        shapesToReturn.push(shape)\n      }\n    })\n\n    return shapesToReturn\n  }\n\n  static getStrokeStyle(width, color, lineJoin, lineCap, miterLimit) {\n    // Param width: Stroke width\n    // Param color: As returned by THREE.Color.getStyle()\n    // Param lineJoin: One of \"round\", \"bevel\", \"miter\" or \"miter-limit\"\n    // Param lineCap: One of \"round\", \"square\" or \"butt\"\n    // Param miterLimit: Maximum join length, in multiples of the \"width\" parameter (join is truncated if it exceeds that distance)\n    // Returns style object\n\n    width = width !== undefined ? width : 1\n    color = color !== undefined ? color : '#000'\n    lineJoin = lineJoin !== undefined ? lineJoin : 'miter'\n    lineCap = lineCap !== undefined ? lineCap : 'butt'\n    miterLimit = miterLimit !== undefined ? miterLimit : 4\n\n    return {\n      strokeColor: color,\n      strokeWidth: width,\n      strokeLineJoin: lineJoin,\n      strokeLineCap: lineCap,\n      strokeMiterLimit: miterLimit,\n    }\n  }\n\n  static pointsToStroke(points, style, arcDivisions, minDistance) {\n    // Generates a stroke with some width around the given path.\n    // The path can be open or closed (last point equals to first point)\n    // Param points: Array of Vector2D (the path). Minimum 2 points.\n    // Param style: Object with SVG properties as returned by SVGLoader.getStrokeStyle(), or SVGLoader.parse() in the path.userData.style object\n    // Params arcDivisions: Arc divisions for round joins and endcaps. (Optional)\n    // Param minDistance: Points closer to this distance will be merged. (Optional)\n    // Returns BufferGeometry with stroke triangles (In plane z = 0). UV coordinates are generated ('u' along path. 'v' across it, from left to right)\n\n    const vertices = []\n    const normals = []\n    const uvs = []\n\n    if (SVGLoader.pointsToStrokeWithBuffers(points, style, arcDivisions, minDistance, vertices, normals, uvs) === 0) {\n      return null\n    }\n\n    const geometry = new BufferGeometry()\n    geometry.setAttribute('position', new Float32BufferAttribute(vertices, 3))\n    geometry.setAttribute('normal', new Float32BufferAttribute(normals, 3))\n    geometry.setAttribute('uv', new Float32BufferAttribute(uvs, 2))\n\n    return geometry\n  }\n\n  static pointsToStrokeWithBuffers(points, style, arcDivisions, minDistance, vertices, normals, uvs, vertexOffset) {\n    // This function can be called to update existing arrays or buffers.\n    // Accepts same parameters as pointsToStroke, plus the buffers and optional offset.\n    // Param vertexOffset: Offset vertices to start writing in the buffers (3 elements/vertex for vertices and normals, and 2 elements/vertex for uvs)\n    // Returns number of written vertices / normals / uvs pairs\n    // if 'vertices' parameter is undefined no triangles will be generated, but the returned vertices count will still be valid (useful to preallocate the buffers)\n    // 'normals' and 'uvs' buffers are optional\n\n    const tempV2_1 = new Vector2()\n    const tempV2_2 = new Vector2()\n    const tempV2_3 = new Vector2()\n    const tempV2_4 = new Vector2()\n    const tempV2_5 = new Vector2()\n    const tempV2_6 = new Vector2()\n    const tempV2_7 = new Vector2()\n    const lastPointL = new Vector2()\n    const lastPointR = new Vector2()\n    const point0L = new Vector2()\n    const point0R = new Vector2()\n    const currentPointL = new Vector2()\n    const currentPointR = new Vector2()\n    const nextPointL = new Vector2()\n    const nextPointR = new Vector2()\n    const innerPoint = new Vector2()\n    const outerPoint = new Vector2()\n\n    arcDivisions = arcDivisions !== undefined ? arcDivisions : 12\n    minDistance = minDistance !== undefined ? minDistance : 0.001\n    vertexOffset = vertexOffset !== undefined ? vertexOffset : 0\n\n    // First ensure there are no duplicated points\n    points = removeDuplicatedPoints(points)\n\n    const numPoints = points.length\n\n    if (numPoints < 2) return 0\n\n    const isClosed = points[0].equals(points[numPoints - 1])\n\n    let currentPoint\n    let previousPoint = points[0]\n    let nextPoint\n\n    const strokeWidth2 = style.strokeWidth / 2\n\n    const deltaU = 1 / (numPoints - 1)\n    let u0 = 0,\n      u1\n\n    let innerSideModified\n    let joinIsOnLeftSide\n    let isMiter\n    let initialJoinIsOnLeftSide = false\n\n    let numVertices = 0\n    let currentCoordinate = vertexOffset * 3\n    let currentCoordinateUV = vertexOffset * 2\n\n    // Get initial left and right stroke points\n    getNormal(points[0], points[1], tempV2_1).multiplyScalar(strokeWidth2)\n    lastPointL.copy(points[0]).sub(tempV2_1)\n    lastPointR.copy(points[0]).add(tempV2_1)\n    point0L.copy(lastPointL)\n    point0R.copy(lastPointR)\n\n    for (let iPoint = 1; iPoint < numPoints; iPoint++) {\n      currentPoint = points[iPoint]\n\n      // Get next point\n      if (iPoint === numPoints - 1) {\n        if (isClosed) {\n          // Skip duplicated initial point\n          nextPoint = points[1]\n        } else nextPoint = undefined\n      } else {\n        nextPoint = points[iPoint + 1]\n      }\n\n      // Normal of previous segment in tempV2_1\n      const normal1 = tempV2_1\n      getNormal(previousPoint, currentPoint, normal1)\n\n      tempV2_3.copy(normal1).multiplyScalar(strokeWidth2)\n      currentPointL.copy(currentPoint).sub(tempV2_3)\n      currentPointR.copy(currentPoint).add(tempV2_3)\n\n      u1 = u0 + deltaU\n\n      innerSideModified = false\n\n      if (nextPoint !== undefined) {\n        // Normal of next segment in tempV2_2\n        getNormal(currentPoint, nextPoint, tempV2_2)\n\n        tempV2_3.copy(tempV2_2).multiplyScalar(strokeWidth2)\n        nextPointL.copy(currentPoint).sub(tempV2_3)\n        nextPointR.copy(currentPoint).add(tempV2_3)\n\n        joinIsOnLeftSide = true\n        tempV2_3.subVectors(nextPoint, previousPoint)\n        if (normal1.dot(tempV2_3) < 0) {\n          joinIsOnLeftSide = false\n        }\n\n        if (iPoint === 1) initialJoinIsOnLeftSide = joinIsOnLeftSide\n\n        tempV2_3.subVectors(nextPoint, currentPoint)\n        tempV2_3.normalize()\n        const dot = Math.abs(normal1.dot(tempV2_3))\n\n        // If path is straight, don't create join\n        if (dot > Number.EPSILON) {\n          // Compute inner and outer segment intersections\n          const miterSide = strokeWidth2 / dot\n          tempV2_3.multiplyScalar(-miterSide)\n          tempV2_4.subVectors(currentPoint, previousPoint)\n          tempV2_5.copy(tempV2_4).setLength(miterSide).add(tempV2_3)\n          innerPoint.copy(tempV2_5).negate()\n          const miterLength2 = tempV2_5.length()\n          const segmentLengthPrev = tempV2_4.length()\n          tempV2_4.divideScalar(segmentLengthPrev)\n          tempV2_6.subVectors(nextPoint, currentPoint)\n          const segmentLengthNext = tempV2_6.length()\n          tempV2_6.divideScalar(segmentLengthNext)\n          // Check that previous and next segments doesn't overlap with the innerPoint of intersection\n          if (tempV2_4.dot(innerPoint) < segmentLengthPrev && tempV2_6.dot(innerPoint) < segmentLengthNext) {\n            innerSideModified = true\n          }\n\n          outerPoint.copy(tempV2_5).add(currentPoint)\n          innerPoint.add(currentPoint)\n\n          isMiter = false\n\n          if (innerSideModified) {\n            if (joinIsOnLeftSide) {\n              nextPointR.copy(innerPoint)\n              currentPointR.copy(innerPoint)\n            } else {\n              nextPointL.copy(innerPoint)\n              currentPointL.copy(innerPoint)\n            }\n          } else {\n            // The segment triangles are generated here if there was overlapping\n\n            makeSegmentTriangles()\n          }\n\n          switch (style.strokeLineJoin) {\n            case 'bevel':\n              makeSegmentWithBevelJoin(joinIsOnLeftSide, innerSideModified, u1)\n\n              break\n\n            case 'round':\n              // Segment triangles\n\n              createSegmentTrianglesWithMiddleSection(joinIsOnLeftSide, innerSideModified)\n\n              // Join triangles\n\n              if (joinIsOnLeftSide) {\n                makeCircularSector(currentPoint, currentPointL, nextPointL, u1, 0)\n              } else {\n                makeCircularSector(currentPoint, nextPointR, currentPointR, u1, 1)\n              }\n\n              break\n\n            case 'miter':\n            case 'miter-clip':\n            default:\n              const miterFraction = (strokeWidth2 * style.strokeMiterLimit) / miterLength2\n\n              if (miterFraction < 1) {\n                // The join miter length exceeds the miter limit\n\n                if (style.strokeLineJoin !== 'miter-clip') {\n                  makeSegmentWithBevelJoin(joinIsOnLeftSide, innerSideModified, u1)\n                  break\n                } else {\n                  // Segment triangles\n\n                  createSegmentTrianglesWithMiddleSection(joinIsOnLeftSide, innerSideModified)\n\n                  // Miter-clip join triangles\n\n                  if (joinIsOnLeftSide) {\n                    tempV2_6.subVectors(outerPoint, currentPointL).multiplyScalar(miterFraction).add(currentPointL)\n                    tempV2_7.subVectors(outerPoint, nextPointL).multiplyScalar(miterFraction).add(nextPointL)\n\n                    addVertex(currentPointL, u1, 0)\n                    addVertex(tempV2_6, u1, 0)\n                    addVertex(currentPoint, u1, 0.5)\n\n                    addVertex(currentPoint, u1, 0.5)\n                    addVertex(tempV2_6, u1, 0)\n                    addVertex(tempV2_7, u1, 0)\n\n                    addVertex(currentPoint, u1, 0.5)\n                    addVertex(tempV2_7, u1, 0)\n                    addVertex(nextPointL, u1, 0)\n                  } else {\n                    tempV2_6.subVectors(outerPoint, currentPointR).multiplyScalar(miterFraction).add(currentPointR)\n                    tempV2_7.subVectors(outerPoint, nextPointR).multiplyScalar(miterFraction).add(nextPointR)\n\n                    addVertex(currentPointR, u1, 1)\n                    addVertex(tempV2_6, u1, 1)\n                    addVertex(currentPoint, u1, 0.5)\n\n                    addVertex(currentPoint, u1, 0.5)\n                    addVertex(tempV2_6, u1, 1)\n                    addVertex(tempV2_7, u1, 1)\n\n                    addVertex(currentPoint, u1, 0.5)\n                    addVertex(tempV2_7, u1, 1)\n                    addVertex(nextPointR, u1, 1)\n                  }\n                }\n              } else {\n                // Miter join segment triangles\n\n                if (innerSideModified) {\n                  // Optimized segment + join triangles\n\n                  if (joinIsOnLeftSide) {\n                    addVertex(lastPointR, u0, 1)\n                    addVertex(lastPointL, u0, 0)\n                    addVertex(outerPoint, u1, 0)\n\n                    addVertex(lastPointR, u0, 1)\n                    addVertex(outerPoint, u1, 0)\n                    addVertex(innerPoint, u1, 1)\n                  } else {\n                    addVertex(lastPointR, u0, 1)\n                    addVertex(lastPointL, u0, 0)\n                    addVertex(outerPoint, u1, 1)\n\n                    addVertex(lastPointL, u0, 0)\n                    addVertex(innerPoint, u1, 0)\n                    addVertex(outerPoint, u1, 1)\n                  }\n\n                  if (joinIsOnLeftSide) {\n                    nextPointL.copy(outerPoint)\n                  } else {\n                    nextPointR.copy(outerPoint)\n                  }\n                } else {\n                  // Add extra miter join triangles\n\n                  if (joinIsOnLeftSide) {\n                    addVertex(currentPointL, u1, 0)\n                    addVertex(outerPoint, u1, 0)\n                    addVertex(currentPoint, u1, 0.5)\n\n                    addVertex(currentPoint, u1, 0.5)\n                    addVertex(outerPoint, u1, 0)\n                    addVertex(nextPointL, u1, 0)\n                  } else {\n                    addVertex(currentPointR, u1, 1)\n                    addVertex(outerPoint, u1, 1)\n                    addVertex(currentPoint, u1, 0.5)\n\n                    addVertex(currentPoint, u1, 0.5)\n                    addVertex(outerPoint, u1, 1)\n                    addVertex(nextPointR, u1, 1)\n                  }\n                }\n\n                isMiter = true\n              }\n\n              break\n          }\n        } else {\n          // The segment triangles are generated here when two consecutive points are collinear\n\n          makeSegmentTriangles()\n        }\n      } else {\n        // The segment triangles are generated here if it is the ending segment\n\n        makeSegmentTriangles()\n      }\n\n      if (!isClosed && iPoint === numPoints - 1) {\n        // Start line endcap\n        addCapGeometry(points[0], point0L, point0R, joinIsOnLeftSide, true, u0)\n      }\n\n      // Increment loop variables\n\n      u0 = u1\n\n      previousPoint = currentPoint\n\n      lastPointL.copy(nextPointL)\n      lastPointR.copy(nextPointR)\n    }\n\n    if (!isClosed) {\n      // Ending line endcap\n      addCapGeometry(currentPoint, currentPointL, currentPointR, joinIsOnLeftSide, false, u1)\n    } else if (innerSideModified && vertices) {\n      // Modify path first segment vertices to adjust to the segments inner and outer intersections\n\n      let lastOuter = outerPoint\n      let lastInner = innerPoint\n\n      if (initialJoinIsOnLeftSide !== joinIsOnLeftSide) {\n        lastOuter = innerPoint\n        lastInner = outerPoint\n      }\n\n      if (joinIsOnLeftSide) {\n        if (isMiter || initialJoinIsOnLeftSide) {\n          lastInner.toArray(vertices, 0 * 3)\n          lastInner.toArray(vertices, 3 * 3)\n\n          if (isMiter) {\n            lastOuter.toArray(vertices, 1 * 3)\n          }\n        }\n      } else {\n        if (isMiter || !initialJoinIsOnLeftSide) {\n          lastInner.toArray(vertices, 1 * 3)\n          lastInner.toArray(vertices, 3 * 3)\n\n          if (isMiter) {\n            lastOuter.toArray(vertices, 0 * 3)\n          }\n        }\n      }\n    }\n\n    return numVertices\n\n    // -- End of algorithm\n\n    // -- Functions\n\n    function getNormal(p1, p2, result) {\n      result.subVectors(p2, p1)\n      return result.set(-result.y, result.x).normalize()\n    }\n\n    function addVertex(position, u, v) {\n      if (vertices) {\n        vertices[currentCoordinate] = position.x\n        vertices[currentCoordinate + 1] = position.y\n        vertices[currentCoordinate + 2] = 0\n\n        if (normals) {\n          normals[currentCoordinate] = 0\n          normals[currentCoordinate + 1] = 0\n          normals[currentCoordinate + 2] = 1\n        }\n\n        currentCoordinate += 3\n\n        if (uvs) {\n          uvs[currentCoordinateUV] = u\n          uvs[currentCoordinateUV + 1] = v\n\n          currentCoordinateUV += 2\n        }\n      }\n\n      numVertices += 3\n    }\n\n    function makeCircularSector(center, p1, p2, u, v) {\n      // param p1, p2: Points in the circle arc.\n      // p1 and p2 are in clockwise direction.\n\n      tempV2_1.copy(p1).sub(center).normalize()\n      tempV2_2.copy(p2).sub(center).normalize()\n\n      let angle = Math.PI\n      const dot = tempV2_1.dot(tempV2_2)\n      if (Math.abs(dot) < 1) angle = Math.abs(Math.acos(dot))\n\n      angle /= arcDivisions\n\n      tempV2_3.copy(p1)\n\n      for (let i = 0, il = arcDivisions - 1; i < il; i++) {\n        tempV2_4.copy(tempV2_3).rotateAround(center, angle)\n\n        addVertex(tempV2_3, u, v)\n        addVertex(tempV2_4, u, v)\n        addVertex(center, u, 0.5)\n\n        tempV2_3.copy(tempV2_4)\n      }\n\n      addVertex(tempV2_4, u, v)\n      addVertex(p2, u, v)\n      addVertex(center, u, 0.5)\n    }\n\n    function makeSegmentTriangles() {\n      addVertex(lastPointR, u0, 1)\n      addVertex(lastPointL, u0, 0)\n      addVertex(currentPointL, u1, 0)\n\n      addVertex(lastPointR, u0, 1)\n      addVertex(currentPointL, u1, 0)\n      addVertex(currentPointR, u1, 1)\n    }\n\n    function makeSegmentWithBevelJoin(joinIsOnLeftSide, innerSideModified, u) {\n      if (innerSideModified) {\n        // Optimized segment + bevel triangles\n\n        if (joinIsOnLeftSide) {\n          // Path segments triangles\n\n          addVertex(lastPointR, u0, 1)\n          addVertex(lastPointL, u0, 0)\n          addVertex(currentPointL, u1, 0)\n\n          addVertex(lastPointR, u0, 1)\n          addVertex(currentPointL, u1, 0)\n          addVertex(innerPoint, u1, 1)\n\n          // Bevel join triangle\n\n          addVertex(currentPointL, u, 0)\n          addVertex(nextPointL, u, 0)\n          addVertex(innerPoint, u, 0.5)\n        } else {\n          // Path segments triangles\n\n          addVertex(lastPointR, u0, 1)\n          addVertex(lastPointL, u0, 0)\n          addVertex(currentPointR, u1, 1)\n\n          addVertex(lastPointL, u0, 0)\n          addVertex(innerPoint, u1, 0)\n          addVertex(currentPointR, u1, 1)\n\n          // Bevel join triangle\n\n          addVertex(currentPointR, u, 1)\n          addVertex(innerPoint, u, 0)\n          addVertex(nextPointR, u, 1)\n        }\n      } else {\n        // Bevel join triangle. The segment triangles are done in the main loop\n\n        if (joinIsOnLeftSide) {\n          addVertex(currentPointL, u, 0)\n          addVertex(nextPointL, u, 0)\n          addVertex(currentPoint, u, 0.5)\n        } else {\n          addVertex(currentPointR, u, 1)\n          addVertex(nextPointR, u, 0)\n          addVertex(currentPoint, u, 0.5)\n        }\n      }\n    }\n\n    function createSegmentTrianglesWithMiddleSection(joinIsOnLeftSide, innerSideModified) {\n      if (innerSideModified) {\n        if (joinIsOnLeftSide) {\n          addVertex(lastPointR, u0, 1)\n          addVertex(lastPointL, u0, 0)\n          addVertex(currentPointL, u1, 0)\n\n          addVertex(lastPointR, u0, 1)\n          addVertex(currentPointL, u1, 0)\n          addVertex(innerPoint, u1, 1)\n\n          addVertex(currentPointL, u0, 0)\n          addVertex(currentPoint, u1, 0.5)\n          addVertex(innerPoint, u1, 1)\n\n          addVertex(currentPoint, u1, 0.5)\n          addVertex(nextPointL, u0, 0)\n          addVertex(innerPoint, u1, 1)\n        } else {\n          addVertex(lastPointR, u0, 1)\n          addVertex(lastPointL, u0, 0)\n          addVertex(currentPointR, u1, 1)\n\n          addVertex(lastPointL, u0, 0)\n          addVertex(innerPoint, u1, 0)\n          addVertex(currentPointR, u1, 1)\n\n          addVertex(currentPointR, u0, 1)\n          addVertex(innerPoint, u1, 0)\n          addVertex(currentPoint, u1, 0.5)\n\n          addVertex(currentPoint, u1, 0.5)\n          addVertex(innerPoint, u1, 0)\n          addVertex(nextPointR, u0, 1)\n        }\n      }\n    }\n\n    function addCapGeometry(center, p1, p2, joinIsOnLeftSide, start, u) {\n      // param center: End point of the path\n      // param p1, p2: Left and right cap points\n\n      switch (style.strokeLineCap) {\n        case 'round':\n          if (start) {\n            makeCircularSector(center, p2, p1, u, 0.5)\n          } else {\n            makeCircularSector(center, p1, p2, u, 0.5)\n          }\n\n          break\n\n        case 'square':\n          if (start) {\n            tempV2_1.subVectors(p1, center)\n            tempV2_2.set(tempV2_1.y, -tempV2_1.x)\n\n            tempV2_3.addVectors(tempV2_1, tempV2_2).add(center)\n            tempV2_4.subVectors(tempV2_2, tempV2_1).add(center)\n\n            // Modify already existing vertices\n            if (joinIsOnLeftSide) {\n              tempV2_3.toArray(vertices, 1 * 3)\n              tempV2_4.toArray(vertices, 0 * 3)\n              tempV2_4.toArray(vertices, 3 * 3)\n            } else {\n              tempV2_3.toArray(vertices, 1 * 3)\n              // using tempV2_4 to update 3rd vertex if the uv.y of 3rd vertex is 1\n              uvs[3 * 2 + 1] === 1 ? tempV2_4.toArray(vertices, 3 * 3) : tempV2_3.toArray(vertices, 3 * 3)\n              tempV2_4.toArray(vertices, 0 * 3)\n            }\n          } else {\n            tempV2_1.subVectors(p2, center)\n            tempV2_2.set(tempV2_1.y, -tempV2_1.x)\n\n            tempV2_3.addVectors(tempV2_1, tempV2_2).add(center)\n            tempV2_4.subVectors(tempV2_2, tempV2_1).add(center)\n\n            const vl = vertices.length\n\n            // Modify already existing vertices\n            if (joinIsOnLeftSide) {\n              tempV2_3.toArray(vertices, vl - 1 * 3)\n              tempV2_4.toArray(vertices, vl - 2 * 3)\n              tempV2_4.toArray(vertices, vl - 4 * 3)\n            } else {\n              tempV2_4.toArray(vertices, vl - 2 * 3)\n              tempV2_3.toArray(vertices, vl - 1 * 3)\n              tempV2_4.toArray(vertices, vl - 4 * 3)\n            }\n          }\n\n          break\n\n        case 'butt':\n        default:\n          // Nothing to do here\n          break\n      }\n    }\n\n    function removeDuplicatedPoints(points) {\n      // Creates a new array if necessary with duplicated points removed.\n      // This does not remove duplicated initial and ending points of a closed path.\n\n      let dupPoints = false\n      for (let i = 1, n = points.length - 1; i < n; i++) {\n        if (points[i].distanceTo(points[i + 1]) < minDistance) {\n          dupPoints = true\n          break\n        }\n      }\n\n      if (!dupPoints) return points\n\n      const newPoints = []\n      newPoints.push(points[0])\n\n      for (let i = 1, n = points.length - 1; i < n; i++) {\n        if (points[i].distanceTo(points[i + 1]) >= minDistance) {\n          newPoints.push(points[i])\n        }\n      }\n\n      newPoints.push(points[points.length - 1])\n\n      return newPoints\n    }\n  }\n}\n\nexport { SVGLoader }\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}