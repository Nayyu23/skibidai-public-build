{"ast":null,"code":"import _createClass from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _classCallCheck from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _possibleConstructorReturn from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js\";\nimport _inherits from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport { Vector3, BoxGeometry } from \"three\";\nvar tempNormal = new Vector3();\nfunction getUv(faceDirVector, normal, uvAxis, projectionAxis, radius, sideLength) {\n  var totArcLength = 2 * Math.PI * radius / 4;\n  var centerLength = Math.max(sideLength - 2 * radius, 0);\n  var halfArc = Math.PI / 4;\n  tempNormal.copy(normal);\n  tempNormal[projectionAxis] = 0;\n  tempNormal.normalize();\n  var arcUvRatio = 0.5 * totArcLength / (totArcLength + centerLength);\n  var arcAngleRatio = 1 - tempNormal.angleTo(faceDirVector) / halfArc;\n  if (Math.sign(tempNormal[uvAxis]) === 1) {\n    return arcAngleRatio * arcUvRatio;\n  } else {\n    var lenUv = centerLength / (totArcLength + centerLength);\n    return lenUv + arcUvRatio + arcUvRatio * (1 - arcAngleRatio);\n  }\n}\nvar RoundedBoxGeometry = /*#__PURE__*/function (_BoxGeometry) {\n  _inherits(RoundedBoxGeometry, _BoxGeometry);\n  var _super = _createSuper(RoundedBoxGeometry);\n  function RoundedBoxGeometry() {\n    var _this;\n    var width = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n    var height = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n    var depth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n    var segments = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 2;\n    var radius = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0.1;\n    _classCallCheck(this, RoundedBoxGeometry);\n    segments = segments * 2 + 1;\n    radius = Math.min(width / 2, height / 2, depth / 2, radius);\n    _this = _super.call(this, 1, 1, 1, segments, segments, segments);\n    if (segments === 1) return _possibleConstructorReturn(_this);\n    var geometry2 = _this.toNonIndexed();\n    _this.index = null;\n    _this.attributes.position = geometry2.attributes.position;\n    _this.attributes.normal = geometry2.attributes.normal;\n    _this.attributes.uv = geometry2.attributes.uv;\n    var position = new Vector3();\n    var normal = new Vector3();\n    var box = new Vector3(width, height, depth).divideScalar(2).subScalar(radius);\n    var positions = _this.attributes.position.array;\n    var normals = _this.attributes.normal.array;\n    var uvs = _this.attributes.uv.array;\n    var faceTris = positions.length / 6;\n    var faceDirVector = new Vector3();\n    var halfSegmentSize = 0.5 / segments;\n    for (var i = 0, j = 0; i < positions.length; i += 3, j += 2) {\n      position.fromArray(positions, i);\n      normal.copy(position);\n      normal.x -= Math.sign(normal.x) * halfSegmentSize;\n      normal.y -= Math.sign(normal.y) * halfSegmentSize;\n      normal.z -= Math.sign(normal.z) * halfSegmentSize;\n      normal.normalize();\n      positions[i + 0] = box.x * Math.sign(position.x) + normal.x * radius;\n      positions[i + 1] = box.y * Math.sign(position.y) + normal.y * radius;\n      positions[i + 2] = box.z * Math.sign(position.z) + normal.z * radius;\n      normals[i + 0] = normal.x;\n      normals[i + 1] = normal.y;\n      normals[i + 2] = normal.z;\n      var side = Math.floor(i / faceTris);\n      switch (side) {\n        case 0:\n          faceDirVector.set(1, 0, 0);\n          uvs[j + 0] = getUv(faceDirVector, normal, \"z\", \"y\", radius, depth);\n          uvs[j + 1] = 1 - getUv(faceDirVector, normal, \"y\", \"z\", radius, height);\n          break;\n        case 1:\n          faceDirVector.set(-1, 0, 0);\n          uvs[j + 0] = 1 - getUv(faceDirVector, normal, \"z\", \"y\", radius, depth);\n          uvs[j + 1] = 1 - getUv(faceDirVector, normal, \"y\", \"z\", radius, height);\n          break;\n        case 2:\n          faceDirVector.set(0, 1, 0);\n          uvs[j + 0] = 1 - getUv(faceDirVector, normal, \"x\", \"z\", radius, width);\n          uvs[j + 1] = getUv(faceDirVector, normal, \"z\", \"x\", radius, depth);\n          break;\n        case 3:\n          faceDirVector.set(0, -1, 0);\n          uvs[j + 0] = 1 - getUv(faceDirVector, normal, \"x\", \"z\", radius, width);\n          uvs[j + 1] = 1 - getUv(faceDirVector, normal, \"z\", \"x\", radius, depth);\n          break;\n        case 4:\n          faceDirVector.set(0, 0, 1);\n          uvs[j + 0] = 1 - getUv(faceDirVector, normal, \"x\", \"y\", radius, width);\n          uvs[j + 1] = 1 - getUv(faceDirVector, normal, \"y\", \"x\", radius, height);\n          break;\n        case 5:\n          faceDirVector.set(0, 0, -1);\n          uvs[j + 0] = getUv(faceDirVector, normal, \"x\", \"y\", radius, width);\n          uvs[j + 1] = 1 - getUv(faceDirVector, normal, \"y\", \"x\", radius, height);\n          break;\n      }\n    }\n    return _this;\n  }\n  return _createClass(RoundedBoxGeometry);\n}(BoxGeometry);\nexport { RoundedBoxGeometry };","map":{"version":3,"names":["tempNormal","Vector3","getUv","faceDirVector","normal","uvAxis","projectionAxis","radius","sideLength","totArcLength","Math","PI","centerLength","max","halfArc","copy","normalize","arcUvRatio","arcAngleRatio","angleTo","sign","lenUv","RoundedBoxGeometry","_BoxGeometry","_inherits","_super","_createSuper","_this","width","arguments","length","undefined","height","depth","segments","_classCallCheck","min","call","_possibleConstructorReturn","geometry2","toNonIndexed","index","attributes","position","uv","box","divideScalar","subScalar","positions","array","normals","uvs","faceTris","halfSegmentSize","i","j","fromArray","x","y","z","side","floor","set","_createClass","BoxGeometry"],"sources":["C:\\Users\\Nayyu\\Desktop\\skibidai-public-build\\node_modules\\src\\geometries\\RoundedBoxGeometry.js"],"sourcesContent":["import { BoxGeometry, Vector3 } from 'three'\n\nconst tempNormal = new Vector3()\n\nfunction getUv(faceDirVector, normal, uvAxis, projectionAxis, radius, sideLength) {\n  const totArcLength = (2 * Math.PI * radius) / 4\n\n  // length of the planes between the arcs on each axis\n  const centerLength = Math.max(sideLength - 2 * radius, 0)\n  const halfArc = Math.PI / 4\n\n  // Get the vector projected onto the Y plane\n  tempNormal.copy(normal)\n  tempNormal[projectionAxis] = 0\n  tempNormal.normalize()\n\n  // total amount of UV space alloted to a single arc\n  const arcUvRatio = (0.5 * totArcLength) / (totArcLength + centerLength)\n\n  // the distance along one arc the point is at\n  const arcAngleRatio = 1.0 - tempNormal.angleTo(faceDirVector) / halfArc\n\n  if (Math.sign(tempNormal[uvAxis]) === 1) {\n    return arcAngleRatio * arcUvRatio\n  } else {\n    // total amount of UV space alloted to the plane between the arcs\n    const lenUv = centerLength / (totArcLength + centerLength)\n    return lenUv + arcUvRatio + arcUvRatio * (1.0 - arcAngleRatio)\n  }\n}\n\nclass RoundedBoxGeometry extends BoxGeometry {\n  constructor(width = 1, height = 1, depth = 1, segments = 2, radius = 0.1) {\n    // ensure segments is odd so we have a plane connecting the rounded corners\n    segments = segments * 2 + 1\n\n    // ensure radius isn't bigger than shortest side\n    radius = Math.min(width / 2, height / 2, depth / 2, radius)\n\n    super(1, 1, 1, segments, segments, segments)\n\n    // if we just have one segment we're the same as a regular box\n    if (segments === 1) return\n\n    const geometry2 = this.toNonIndexed()\n\n    this.index = null\n    this.attributes.position = geometry2.attributes.position\n    this.attributes.normal = geometry2.attributes.normal\n    this.attributes.uv = geometry2.attributes.uv\n\n    //\n\n    const position = new Vector3()\n    const normal = new Vector3()\n\n    const box = new Vector3(width, height, depth).divideScalar(2).subScalar(radius)\n\n    const positions = this.attributes.position.array\n    const normals = this.attributes.normal.array\n    const uvs = this.attributes.uv.array\n\n    const faceTris = positions.length / 6\n    const faceDirVector = new Vector3()\n    const halfSegmentSize = 0.5 / segments\n\n    for (let i = 0, j = 0; i < positions.length; i += 3, j += 2) {\n      position.fromArray(positions, i)\n      normal.copy(position)\n      normal.x -= Math.sign(normal.x) * halfSegmentSize\n      normal.y -= Math.sign(normal.y) * halfSegmentSize\n      normal.z -= Math.sign(normal.z) * halfSegmentSize\n      normal.normalize()\n\n      positions[i + 0] = box.x * Math.sign(position.x) + normal.x * radius\n      positions[i + 1] = box.y * Math.sign(position.y) + normal.y * radius\n      positions[i + 2] = box.z * Math.sign(position.z) + normal.z * radius\n\n      normals[i + 0] = normal.x\n      normals[i + 1] = normal.y\n      normals[i + 2] = normal.z\n\n      const side = Math.floor(i / faceTris)\n\n      switch (side) {\n        case 0: // right\n          // generate UVs along Z then Y\n          faceDirVector.set(1, 0, 0)\n          uvs[j + 0] = getUv(faceDirVector, normal, 'z', 'y', radius, depth)\n          uvs[j + 1] = 1.0 - getUv(faceDirVector, normal, 'y', 'z', radius, height)\n          break\n\n        case 1: // left\n          // generate UVs along Z then Y\n          faceDirVector.set(-1, 0, 0)\n          uvs[j + 0] = 1.0 - getUv(faceDirVector, normal, 'z', 'y', radius, depth)\n          uvs[j + 1] = 1.0 - getUv(faceDirVector, normal, 'y', 'z', radius, height)\n          break\n\n        case 2: // top\n          // generate UVs along X then Z\n          faceDirVector.set(0, 1, 0)\n          uvs[j + 0] = 1.0 - getUv(faceDirVector, normal, 'x', 'z', radius, width)\n          uvs[j + 1] = getUv(faceDirVector, normal, 'z', 'x', radius, depth)\n          break\n\n        case 3: // bottom\n          // generate UVs along X then Z\n          faceDirVector.set(0, -1, 0)\n          uvs[j + 0] = 1.0 - getUv(faceDirVector, normal, 'x', 'z', radius, width)\n          uvs[j + 1] = 1.0 - getUv(faceDirVector, normal, 'z', 'x', radius, depth)\n          break\n\n        case 4: // front\n          // generate UVs along X then Y\n          faceDirVector.set(0, 0, 1)\n          uvs[j + 0] = 1.0 - getUv(faceDirVector, normal, 'x', 'y', radius, width)\n          uvs[j + 1] = 1.0 - getUv(faceDirVector, normal, 'y', 'x', radius, height)\n          break\n\n        case 5: // back\n          // generate UVs along X then Y\n          faceDirVector.set(0, 0, -1)\n          uvs[j + 0] = getUv(faceDirVector, normal, 'x', 'y', radius, width)\n          uvs[j + 1] = 1.0 - getUv(faceDirVector, normal, 'y', 'x', radius, height)\n          break\n      }\n    }\n  }\n}\n\nexport { RoundedBoxGeometry }\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}