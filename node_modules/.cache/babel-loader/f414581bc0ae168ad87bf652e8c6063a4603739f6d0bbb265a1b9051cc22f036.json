{"ast":null,"code":"import _createClass from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _classCallCheck from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport { Vector3, Color, Vector2, Vector4, Box3, Matrix4, Frustum, Matrix3, DoubleSide } from \"three\";\nvar RenderableObject = /*#__PURE__*/_createClass(function RenderableObject() {\n  _classCallCheck(this, RenderableObject);\n  this.id = 0;\n  this.object = null;\n  this.z = 0;\n  this.renderOrder = 0;\n});\nvar RenderableFace = /*#__PURE__*/_createClass(function RenderableFace() {\n  _classCallCheck(this, RenderableFace);\n  this.id = 0;\n  this.v1 = new RenderableVertex();\n  this.v2 = new RenderableVertex();\n  this.v3 = new RenderableVertex();\n  this.normalModel = new Vector3();\n  this.vertexNormalsModel = [new Vector3(), new Vector3(), new Vector3()];\n  this.vertexNormalsLength = 0;\n  this.color = new Color();\n  this.material = null;\n  this.uvs = [new Vector2(), new Vector2(), new Vector2()];\n  this.z = 0;\n  this.renderOrder = 0;\n});\nvar RenderableVertex = /*#__PURE__*/function () {\n  function RenderableVertex() {\n    _classCallCheck(this, RenderableVertex);\n    this.position = new Vector3();\n    this.positionWorld = new Vector3();\n    this.positionScreen = new Vector4();\n    this.visible = true;\n  }\n  _createClass(RenderableVertex, [{\n    key: \"copy\",\n    value: function copy(vertex) {\n      this.positionWorld.copy(vertex.positionWorld);\n      this.positionScreen.copy(vertex.positionScreen);\n    }\n  }]);\n  return RenderableVertex;\n}();\nvar RenderableLine = /*#__PURE__*/_createClass(function RenderableLine() {\n  _classCallCheck(this, RenderableLine);\n  this.id = 0;\n  this.v1 = new RenderableVertex();\n  this.v2 = new RenderableVertex();\n  this.vertexColors = [new Color(), new Color()];\n  this.material = null;\n  this.z = 0;\n  this.renderOrder = 0;\n});\nvar RenderableSprite = /*#__PURE__*/_createClass(function RenderableSprite() {\n  _classCallCheck(this, RenderableSprite);\n  this.id = 0;\n  this.object = null;\n  this.x = 0;\n  this.y = 0;\n  this.z = 0;\n  this.rotation = 0;\n  this.scale = new Vector2();\n  this.material = null;\n  this.renderOrder = 0;\n});\nvar Projector = /*#__PURE__*/_createClass(function Projector() {\n  _classCallCheck(this, Projector);\n  var _object,\n    _objectCount,\n    _objectPoolLength = 0,\n    _vertex,\n    _vertexCount,\n    _vertexPoolLength = 0,\n    _face,\n    _faceCount,\n    _facePoolLength = 0,\n    _line,\n    _lineCount,\n    _linePoolLength = 0,\n    _sprite,\n    _spriteCount,\n    _spritePoolLength = 0,\n    _modelMatrix;\n  var _renderData = {\n      objects: [],\n      lights: [],\n      elements: []\n    },\n    _vector3 = new Vector3(),\n    _vector4 = new Vector4(),\n    _clipBox = new Box3(new Vector3(-1, -1, -1), new Vector3(1, 1, 1)),\n    _boundingBox = new Box3(),\n    _points3 = new Array(3),\n    _viewMatrix = new Matrix4(),\n    _viewProjectionMatrix = new Matrix4(),\n    _modelViewProjectionMatrix = new Matrix4(),\n    _frustum = new Frustum(),\n    _objectPool = [],\n    _vertexPool = [],\n    _facePool = [],\n    _linePool = [],\n    _spritePool = [];\n  function RenderList() {\n    var normals = [];\n    var colors = [];\n    var uvs = [];\n    var object = null;\n    var normalMatrix = new Matrix3();\n    function setObject(value) {\n      object = value;\n      normalMatrix.getNormalMatrix(object.matrixWorld);\n      normals.length = 0;\n      colors.length = 0;\n      uvs.length = 0;\n    }\n    function projectVertex(vertex) {\n      var position = vertex.position;\n      var positionWorld = vertex.positionWorld;\n      var positionScreen = vertex.positionScreen;\n      positionWorld.copy(position).applyMatrix4(_modelMatrix);\n      positionScreen.copy(positionWorld).applyMatrix4(_viewProjectionMatrix);\n      var invW = 1 / positionScreen.w;\n      positionScreen.x *= invW;\n      positionScreen.y *= invW;\n      positionScreen.z *= invW;\n      vertex.visible = positionScreen.x >= -1 && positionScreen.x <= 1 && positionScreen.y >= -1 && positionScreen.y <= 1 && positionScreen.z >= -1 && positionScreen.z <= 1;\n    }\n    function pushVertex(x, y, z) {\n      _vertex = getNextVertexInPool();\n      _vertex.position.set(x, y, z);\n      projectVertex(_vertex);\n    }\n    function pushNormal(x, y, z) {\n      normals.push(x, y, z);\n    }\n    function pushColor(r, g, b) {\n      colors.push(r, g, b);\n    }\n    function pushUv(x, y) {\n      uvs.push(x, y);\n    }\n    function checkTriangleVisibility(v1, v2, v3) {\n      if (v1.visible === true || v2.visible === true || v3.visible === true) return true;\n      _points3[0] = v1.positionScreen;\n      _points3[1] = v2.positionScreen;\n      _points3[2] = v3.positionScreen;\n      return _clipBox.intersectsBox(_boundingBox.setFromPoints(_points3));\n    }\n    function checkBackfaceCulling(v1, v2, v3) {\n      return (v3.positionScreen.x - v1.positionScreen.x) * (v2.positionScreen.y - v1.positionScreen.y) - (v3.positionScreen.y - v1.positionScreen.y) * (v2.positionScreen.x - v1.positionScreen.x) < 0;\n    }\n    function pushLine(a, b) {\n      var v1 = _vertexPool[a];\n      var v2 = _vertexPool[b];\n      v1.positionScreen.copy(v1.position).applyMatrix4(_modelViewProjectionMatrix);\n      v2.positionScreen.copy(v2.position).applyMatrix4(_modelViewProjectionMatrix);\n      if (clipLine(v1.positionScreen, v2.positionScreen) === true) {\n        v1.positionScreen.multiplyScalar(1 / v1.positionScreen.w);\n        v2.positionScreen.multiplyScalar(1 / v2.positionScreen.w);\n        _line = getNextLineInPool();\n        _line.id = object.id;\n        _line.v1.copy(v1);\n        _line.v2.copy(v2);\n        _line.z = Math.max(v1.positionScreen.z, v2.positionScreen.z);\n        _line.renderOrder = object.renderOrder;\n        _line.material = object.material;\n        if (object.material.vertexColors) {\n          _line.vertexColors[0].fromArray(colors, a * 3);\n          _line.vertexColors[1].fromArray(colors, b * 3);\n        }\n        _renderData.elements.push(_line);\n      }\n    }\n    function pushTriangle(a, b, c, material) {\n      var v1 = _vertexPool[a];\n      var v2 = _vertexPool[b];\n      var v3 = _vertexPool[c];\n      if (checkTriangleVisibility(v1, v2, v3) === false) return;\n      if (material.side === DoubleSide || checkBackfaceCulling(v1, v2, v3) === true) {\n        _face = getNextFaceInPool();\n        _face.id = object.id;\n        _face.v1.copy(v1);\n        _face.v2.copy(v2);\n        _face.v3.copy(v3);\n        _face.z = (v1.positionScreen.z + v2.positionScreen.z + v3.positionScreen.z) / 3;\n        _face.renderOrder = object.renderOrder;\n        _vector3.subVectors(v3.position, v2.position);\n        _vector4.subVectors(v1.position, v2.position);\n        _vector3.cross(_vector4);\n        _face.normalModel.copy(_vector3);\n        _face.normalModel.applyMatrix3(normalMatrix).normalize();\n        for (var i = 0; i < 3; i++) {\n          var normal = _face.vertexNormalsModel[i];\n          normal.fromArray(normals, arguments[i] * 3);\n          normal.applyMatrix3(normalMatrix).normalize();\n          var uv = _face.uvs[i];\n          uv.fromArray(uvs, arguments[i] * 2);\n        }\n        _face.vertexNormalsLength = 3;\n        _face.material = material;\n        if (material.vertexColors) {\n          _face.color.fromArray(colors, a * 3);\n        }\n        _renderData.elements.push(_face);\n      }\n    }\n    return {\n      setObject: setObject,\n      projectVertex: projectVertex,\n      checkTriangleVisibility: checkTriangleVisibility,\n      checkBackfaceCulling: checkBackfaceCulling,\n      pushVertex: pushVertex,\n      pushNormal: pushNormal,\n      pushColor: pushColor,\n      pushUv: pushUv,\n      pushLine: pushLine,\n      pushTriangle: pushTriangle\n    };\n  }\n  var renderList = new RenderList();\n  function projectObject(object) {\n    if (object.visible === false) return;\n    if (object.isLight) {\n      _renderData.lights.push(object);\n    } else if (object.isMesh || object.isLine || object.isPoints) {\n      if (object.material.visible === false) return;\n      if (object.frustumCulled === true && _frustum.intersectsObject(object) === false) return;\n      addObject(object);\n    } else if (object.isSprite) {\n      if (object.material.visible === false) return;\n      if (object.frustumCulled === true && _frustum.intersectsSprite(object) === false) return;\n      addObject(object);\n    }\n    var children = object.children;\n    for (var i = 0, l = children.length; i < l; i++) {\n      projectObject(children[i]);\n    }\n  }\n  function addObject(object) {\n    _object = getNextObjectInPool();\n    _object.id = object.id;\n    _object.object = object;\n    _vector3.setFromMatrixPosition(object.matrixWorld);\n    _vector3.applyMatrix4(_viewProjectionMatrix);\n    _object.z = _vector3.z;\n    _object.renderOrder = object.renderOrder;\n    _renderData.objects.push(_object);\n  }\n  this.projectScene = function (scene, camera, sortObjects, sortElements) {\n    _faceCount = 0;\n    _lineCount = 0;\n    _spriteCount = 0;\n    _renderData.elements.length = 0;\n    if (scene.matrixWorldAutoUpdate === true) scene.updateMatrixWorld();\n    if (camera.parent === null && camera.matrixWorldAutoUpdate === true) camera.updateMatrixWorld();\n    _viewMatrix.copy(camera.matrixWorldInverse);\n    _viewProjectionMatrix.multiplyMatrices(camera.projectionMatrix, _viewMatrix);\n    _frustum.setFromProjectionMatrix(_viewProjectionMatrix);\n    _objectCount = 0;\n    _renderData.objects.length = 0;\n    _renderData.lights.length = 0;\n    projectObject(scene);\n    if (sortObjects === true) {\n      _renderData.objects.sort(painterSort);\n    }\n    var objects = _renderData.objects;\n    for (var o = 0, ol = objects.length; o < ol; o++) {\n      var object = objects[o].object;\n      var geometry = object.geometry;\n      renderList.setObject(object);\n      _modelMatrix = object.matrixWorld;\n      _vertexCount = 0;\n      if (object.isMesh) {\n        var material = object.material;\n        var isMultiMaterial = Array.isArray(material);\n        var attributes = geometry.attributes;\n        var groups = geometry.groups;\n        if (attributes.position === void 0) continue;\n        var positions = attributes.position.array;\n        for (var i = 0, l = positions.length; i < l; i += 3) {\n          var x = positions[i];\n          var y = positions[i + 1];\n          var z = positions[i + 2];\n          var morphTargets = geometry.morphAttributes.position;\n          if (morphTargets !== void 0) {\n            var morphTargetsRelative = geometry.morphTargetsRelative;\n            var morphInfluences = object.morphTargetInfluences;\n            for (var t = 0, tl = morphTargets.length; t < tl; t++) {\n              var influence = morphInfluences[t];\n              if (influence === 0) continue;\n              var target = morphTargets[t];\n              if (morphTargetsRelative) {\n                x += target.getX(i / 3) * influence;\n                y += target.getY(i / 3) * influence;\n                z += target.getZ(i / 3) * influence;\n              } else {\n                x += (target.getX(i / 3) - positions[i]) * influence;\n                y += (target.getY(i / 3) - positions[i + 1]) * influence;\n                z += (target.getZ(i / 3) - positions[i + 2]) * influence;\n              }\n            }\n          }\n          renderList.pushVertex(x, y, z);\n        }\n        if (attributes.normal !== void 0) {\n          var normals = attributes.normal.array;\n          for (var _i = 0, _l = normals.length; _i < _l; _i += 3) {\n            renderList.pushNormal(normals[_i], normals[_i + 1], normals[_i + 2]);\n          }\n        }\n        if (attributes.color !== void 0) {\n          var colors = attributes.color.array;\n          for (var _i2 = 0, _l2 = colors.length; _i2 < _l2; _i2 += 3) {\n            renderList.pushColor(colors[_i2], colors[_i2 + 1], colors[_i2 + 2]);\n          }\n        }\n        if (attributes.uv !== void 0) {\n          var uvs = attributes.uv.array;\n          for (var _i3 = 0, _l3 = uvs.length; _i3 < _l3; _i3 += 2) {\n            renderList.pushUv(uvs[_i3], uvs[_i3 + 1]);\n          }\n        }\n        if (geometry.index !== null) {\n          var indices = geometry.index.array;\n          if (groups.length > 0) {\n            for (var g = 0; g < groups.length; g++) {\n              var group = groups[g];\n              material = isMultiMaterial === true ? object.material[group.materialIndex] : object.material;\n              if (material === void 0) continue;\n              for (var _i4 = group.start, _l4 = group.start + group.count; _i4 < _l4; _i4 += 3) {\n                renderList.pushTriangle(indices[_i4], indices[_i4 + 1], indices[_i4 + 2], material);\n              }\n            }\n          } else {\n            for (var _i5 = 0, _l5 = indices.length; _i5 < _l5; _i5 += 3) {\n              renderList.pushTriangle(indices[_i5], indices[_i5 + 1], indices[_i5 + 2], material);\n            }\n          }\n        } else {\n          if (groups.length > 0) {\n            for (var _g = 0; _g < groups.length; _g++) {\n              var _group = groups[_g];\n              material = isMultiMaterial === true ? object.material[_group.materialIndex] : object.material;\n              if (material === void 0) continue;\n              for (var _i6 = _group.start, _l6 = _group.start + _group.count; _i6 < _l6; _i6 += 3) {\n                renderList.pushTriangle(_i6, _i6 + 1, _i6 + 2, material);\n              }\n            }\n          } else {\n            for (var _i7 = 0, _l7 = positions.length / 3; _i7 < _l7; _i7 += 3) {\n              renderList.pushTriangle(_i7, _i7 + 1, _i7 + 2, material);\n            }\n          }\n        }\n      } else if (object.isLine) {\n        _modelViewProjectionMatrix.multiplyMatrices(_viewProjectionMatrix, _modelMatrix);\n        var _attributes = geometry.attributes;\n        if (_attributes.position !== void 0) {\n          var _positions = _attributes.position.array;\n          for (var _i8 = 0, _l8 = _positions.length; _i8 < _l8; _i8 += 3) {\n            renderList.pushVertex(_positions[_i8], _positions[_i8 + 1], _positions[_i8 + 2]);\n          }\n          if (_attributes.color !== void 0) {\n            var _colors = _attributes.color.array;\n            for (var _i9 = 0, _l9 = _colors.length; _i9 < _l9; _i9 += 3) {\n              renderList.pushColor(_colors[_i9], _colors[_i9 + 1], _colors[_i9 + 2]);\n            }\n          }\n          if (geometry.index !== null) {\n            var _indices = geometry.index.array;\n            for (var _i10 = 0, _l10 = _indices.length; _i10 < _l10; _i10 += 2) {\n              renderList.pushLine(_indices[_i10], _indices[_i10 + 1]);\n            }\n          } else {\n            var step = object.isLineSegments ? 2 : 1;\n            for (var _i11 = 0, _l11 = _positions.length / 3 - 1; _i11 < _l11; _i11 += step) {\n              renderList.pushLine(_i11, _i11 + 1);\n            }\n          }\n        }\n      } else if (object.isPoints) {\n        _modelViewProjectionMatrix.multiplyMatrices(_viewProjectionMatrix, _modelMatrix);\n        var _attributes2 = geometry.attributes;\n        if (_attributes2.position !== void 0) {\n          var _positions2 = _attributes2.position.array;\n          for (var _i12 = 0, _l12 = _positions2.length; _i12 < _l12; _i12 += 3) {\n            _vector4.set(_positions2[_i12], _positions2[_i12 + 1], _positions2[_i12 + 2], 1);\n            _vector4.applyMatrix4(_modelViewProjectionMatrix);\n            pushPoint(_vector4, object, camera);\n          }\n        }\n      } else if (object.isSprite) {\n        object.modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse, object.matrixWorld);\n        _vector4.set(_modelMatrix.elements[12], _modelMatrix.elements[13], _modelMatrix.elements[14], 1);\n        _vector4.applyMatrix4(_viewProjectionMatrix);\n        pushPoint(_vector4, object, camera);\n      }\n    }\n    if (sortElements === true) {\n      _renderData.elements.sort(painterSort);\n    }\n    return _renderData;\n  };\n  function pushPoint(_vector42, object, camera) {\n    var invW = 1 / _vector42.w;\n    _vector42.z *= invW;\n    if (_vector42.z >= -1 && _vector42.z <= 1) {\n      _sprite = getNextSpriteInPool();\n      _sprite.id = object.id;\n      _sprite.x = _vector42.x * invW;\n      _sprite.y = _vector42.y * invW;\n      _sprite.z = _vector42.z;\n      _sprite.renderOrder = object.renderOrder;\n      _sprite.object = object;\n      _sprite.rotation = object.rotation;\n      _sprite.scale.x = object.scale.x * Math.abs(_sprite.x - (_vector42.x + camera.projectionMatrix.elements[0]) / (_vector42.w + camera.projectionMatrix.elements[12]));\n      _sprite.scale.y = object.scale.y * Math.abs(_sprite.y - (_vector42.y + camera.projectionMatrix.elements[5]) / (_vector42.w + camera.projectionMatrix.elements[13]));\n      _sprite.material = object.material;\n      _renderData.elements.push(_sprite);\n    }\n  }\n  function getNextObjectInPool() {\n    if (_objectCount === _objectPoolLength) {\n      var object = new RenderableObject();\n      _objectPool.push(object);\n      _objectPoolLength++;\n      _objectCount++;\n      return object;\n    }\n    return _objectPool[_objectCount++];\n  }\n  function getNextVertexInPool() {\n    if (_vertexCount === _vertexPoolLength) {\n      var vertex = new RenderableVertex();\n      _vertexPool.push(vertex);\n      _vertexPoolLength++;\n      _vertexCount++;\n      return vertex;\n    }\n    return _vertexPool[_vertexCount++];\n  }\n  function getNextFaceInPool() {\n    if (_faceCount === _facePoolLength) {\n      var face = new RenderableFace();\n      _facePool.push(face);\n      _facePoolLength++;\n      _faceCount++;\n      return face;\n    }\n    return _facePool[_faceCount++];\n  }\n  function getNextLineInPool() {\n    if (_lineCount === _linePoolLength) {\n      var line = new RenderableLine();\n      _linePool.push(line);\n      _linePoolLength++;\n      _lineCount++;\n      return line;\n    }\n    return _linePool[_lineCount++];\n  }\n  function getNextSpriteInPool() {\n    if (_spriteCount === _spritePoolLength) {\n      var sprite = new RenderableSprite();\n      _spritePool.push(sprite);\n      _spritePoolLength++;\n      _spriteCount++;\n      return sprite;\n    }\n    return _spritePool[_spriteCount++];\n  }\n  function painterSort(a, b) {\n    if (a.renderOrder !== b.renderOrder) {\n      return a.renderOrder - b.renderOrder;\n    } else if (a.z !== b.z) {\n      return b.z - a.z;\n    } else if (a.id !== b.id) {\n      return a.id - b.id;\n    } else {\n      return 0;\n    }\n  }\n  function clipLine(s1, s2) {\n    var alpha1 = 0,\n      alpha2 = 1;\n    var bc1near = s1.z + s1.w,\n      bc2near = s2.z + s2.w,\n      bc1far = -s1.z + s1.w,\n      bc2far = -s2.z + s2.w;\n    if (bc1near >= 0 && bc2near >= 0 && bc1far >= 0 && bc2far >= 0) {\n      return true;\n    } else if (bc1near < 0 && bc2near < 0 || bc1far < 0 && bc2far < 0) {\n      return false;\n    } else {\n      if (bc1near < 0) {\n        alpha1 = Math.max(alpha1, bc1near / (bc1near - bc2near));\n      } else if (bc2near < 0) {\n        alpha2 = Math.min(alpha2, bc1near / (bc1near - bc2near));\n      }\n      if (bc1far < 0) {\n        alpha1 = Math.max(alpha1, bc1far / (bc1far - bc2far));\n      } else if (bc2far < 0) {\n        alpha2 = Math.min(alpha2, bc1far / (bc1far - bc2far));\n      }\n      if (alpha2 < alpha1) {\n        return false;\n      } else {\n        s1.lerp(s2, alpha1);\n        s2.lerp(s1, 1 - alpha2);\n        return true;\n      }\n    }\n  }\n});\nexport { Projector, RenderableFace, RenderableLine, RenderableObject, RenderableSprite, RenderableVertex };","map":{"version":3,"names":["RenderableObject","_createClass","_classCallCheck","id","object","z","renderOrder","RenderableFace","v1","RenderableVertex","v2","v3","normalModel","Vector3","vertexNormalsModel","vertexNormalsLength","color","Color","material","uvs","Vector2","position","positionWorld","positionScreen","Vector4","visible","key","value","copy","vertex","RenderableLine","vertexColors","RenderableSprite","x","y","rotation","scale","Projector","_object","_objectCount","_objectPoolLength","_vertex","_vertexCount","_vertexPoolLength","_face","_faceCount","_facePoolLength","_line","_lineCount","_linePoolLength","_sprite","_spriteCount","_spritePoolLength","_modelMatrix","_renderData","objects","lights","elements","_vector3","_vector4","_clipBox","Box3","_boundingBox","_points3","Array","_viewMatrix","Matrix4","_viewProjectionMatrix","_modelViewProjectionMatrix","_frustum","Frustum","_objectPool","_vertexPool","_facePool","_linePool","_spritePool","RenderList","normals","colors","normalMatrix","Matrix3","setObject","getNormalMatrix","matrixWorld","length","projectVertex","applyMatrix4","invW","w","pushVertex","getNextVertexInPool","set","pushNormal","push","pushColor","r","g","b","pushUv","checkTriangleVisibility","intersectsBox","setFromPoints","checkBackfaceCulling","pushLine","a","clipLine","multiplyScalar","getNextLineInPool","Math","max","fromArray","pushTriangle","c","side","DoubleSide","getNextFaceInPool","subVectors","cross","applyMatrix3","normalize","i","normal","arguments","uv","renderList","projectObject","isLight","isMesh","isLine","isPoints","frustumCulled","intersectsObject","addObject","isSprite","intersectsSprite","children","l","getNextObjectInPool","setFromMatrixPosition","projectScene","scene","camera","sortObjects","sortElements","matrixWorldAutoUpdate","updateMatrixWorld","parent","matrixWorldInverse","multiplyMatrices","projectionMatrix","setFromProjectionMatrix","sort","painterSort","o","ol","geometry","isMultiMaterial","isArray","attributes","groups","positions","array","morphTargets","morphAttributes","morphTargetsRelative","morphInfluences","morphTargetInfluences","t","tl","influence","target","getX","getY","getZ","index","indices","group","materialIndex","start","count","step","isLineSegments","pushPoint","modelViewMatrix","_vector42","getNextSpriteInPool","abs","face","line","sprite","s1","s2","alpha1","alpha2","bc1near","bc2near","bc1far","bc2far","min","lerp"],"sources":["C:\\Users\\Nayyu\\Desktop\\skibidai-public-build\\node_modules\\src\\renderers\\Projector.js"],"sourcesContent":["import { Box3, Color, DoubleSide, Frustum, Matrix3, Matrix4, Vector2, Vector3, Vector4 } from 'three'\n\nclass RenderableObject {\n  constructor() {\n    this.id = 0\n\n    this.object = null\n    this.z = 0\n    this.renderOrder = 0\n  }\n}\n\n//\n\nclass RenderableFace {\n  constructor() {\n    this.id = 0\n\n    this.v1 = new RenderableVertex()\n    this.v2 = new RenderableVertex()\n    this.v3 = new RenderableVertex()\n\n    this.normalModel = new Vector3()\n\n    this.vertexNormalsModel = [new Vector3(), new Vector3(), new Vector3()]\n    this.vertexNormalsLength = 0\n\n    this.color = new Color()\n    this.material = null\n    this.uvs = [new Vector2(), new Vector2(), new Vector2()]\n\n    this.z = 0\n    this.renderOrder = 0\n  }\n}\n\n//\n\nclass RenderableVertex {\n  constructor() {\n    this.position = new Vector3()\n    this.positionWorld = new Vector3()\n    this.positionScreen = new Vector4()\n\n    this.visible = true\n  }\n\n  copy(vertex) {\n    this.positionWorld.copy(vertex.positionWorld)\n    this.positionScreen.copy(vertex.positionScreen)\n  }\n}\n\n//\n\nclass RenderableLine {\n  constructor() {\n    this.id = 0\n\n    this.v1 = new RenderableVertex()\n    this.v2 = new RenderableVertex()\n\n    this.vertexColors = [new Color(), new Color()]\n    this.material = null\n\n    this.z = 0\n    this.renderOrder = 0\n  }\n}\n\n//\n\nclass RenderableSprite {\n  constructor() {\n    this.id = 0\n\n    this.object = null\n\n    this.x = 0\n    this.y = 0\n    this.z = 0\n\n    this.rotation = 0\n    this.scale = new Vector2()\n\n    this.material = null\n    this.renderOrder = 0\n  }\n}\n\n//\n\nclass Projector {\n  constructor() {\n    let _object,\n      _objectCount,\n      _objectPoolLength = 0,\n      _vertex,\n      _vertexCount,\n      _vertexPoolLength = 0,\n      _face,\n      _faceCount,\n      _facePoolLength = 0,\n      _line,\n      _lineCount,\n      _linePoolLength = 0,\n      _sprite,\n      _spriteCount,\n      _spritePoolLength = 0,\n      _modelMatrix\n\n    const _renderData = { objects: [], lights: [], elements: [] },\n      _vector3 = new Vector3(),\n      _vector4 = new Vector4(),\n      _clipBox = new Box3(new Vector3(-1, -1, -1), new Vector3(1, 1, 1)),\n      _boundingBox = new Box3(),\n      _points3 = new Array(3),\n      _viewMatrix = new Matrix4(),\n      _viewProjectionMatrix = new Matrix4(),\n      _modelViewProjectionMatrix = new Matrix4(),\n      _frustum = new Frustum(),\n      _objectPool = [],\n      _vertexPool = [],\n      _facePool = [],\n      _linePool = [],\n      _spritePool = []\n\n    //\n\n    function RenderList() {\n      const normals = []\n      const colors = []\n      const uvs = []\n\n      let object = null\n\n      const normalMatrix = new Matrix3()\n\n      function setObject(value) {\n        object = value\n\n        normalMatrix.getNormalMatrix(object.matrixWorld)\n\n        normals.length = 0\n        colors.length = 0\n        uvs.length = 0\n      }\n\n      function projectVertex(vertex) {\n        const position = vertex.position\n        const positionWorld = vertex.positionWorld\n        const positionScreen = vertex.positionScreen\n\n        positionWorld.copy(position).applyMatrix4(_modelMatrix)\n        positionScreen.copy(positionWorld).applyMatrix4(_viewProjectionMatrix)\n\n        const invW = 1 / positionScreen.w\n\n        positionScreen.x *= invW\n        positionScreen.y *= invW\n        positionScreen.z *= invW\n\n        vertex.visible =\n          positionScreen.x >= -1 &&\n          positionScreen.x <= 1 &&\n          positionScreen.y >= -1 &&\n          positionScreen.y <= 1 &&\n          positionScreen.z >= -1 &&\n          positionScreen.z <= 1\n      }\n\n      function pushVertex(x, y, z) {\n        _vertex = getNextVertexInPool()\n        _vertex.position.set(x, y, z)\n\n        projectVertex(_vertex)\n      }\n\n      function pushNormal(x, y, z) {\n        normals.push(x, y, z)\n      }\n\n      function pushColor(r, g, b) {\n        colors.push(r, g, b)\n      }\n\n      function pushUv(x, y) {\n        uvs.push(x, y)\n      }\n\n      function checkTriangleVisibility(v1, v2, v3) {\n        if (v1.visible === true || v2.visible === true || v3.visible === true) return true\n\n        _points3[0] = v1.positionScreen\n        _points3[1] = v2.positionScreen\n        _points3[2] = v3.positionScreen\n\n        return _clipBox.intersectsBox(_boundingBox.setFromPoints(_points3))\n      }\n\n      function checkBackfaceCulling(v1, v2, v3) {\n        return (\n          (v3.positionScreen.x - v1.positionScreen.x) * (v2.positionScreen.y - v1.positionScreen.y) -\n            (v3.positionScreen.y - v1.positionScreen.y) * (v2.positionScreen.x - v1.positionScreen.x) <\n          0\n        )\n      }\n\n      function pushLine(a, b) {\n        const v1 = _vertexPool[a]\n        const v2 = _vertexPool[b]\n\n        // Clip\n\n        v1.positionScreen.copy(v1.position).applyMatrix4(_modelViewProjectionMatrix)\n        v2.positionScreen.copy(v2.position).applyMatrix4(_modelViewProjectionMatrix)\n\n        if (clipLine(v1.positionScreen, v2.positionScreen) === true) {\n          // Perform the perspective divide\n          v1.positionScreen.multiplyScalar(1 / v1.positionScreen.w)\n          v2.positionScreen.multiplyScalar(1 / v2.positionScreen.w)\n\n          _line = getNextLineInPool()\n          _line.id = object.id\n          _line.v1.copy(v1)\n          _line.v2.copy(v2)\n          _line.z = Math.max(v1.positionScreen.z, v2.positionScreen.z)\n          _line.renderOrder = object.renderOrder\n\n          _line.material = object.material\n\n          if (object.material.vertexColors) {\n            _line.vertexColors[0].fromArray(colors, a * 3)\n            _line.vertexColors[1].fromArray(colors, b * 3)\n          }\n\n          _renderData.elements.push(_line)\n        }\n      }\n\n      function pushTriangle(a, b, c, material) {\n        const v1 = _vertexPool[a]\n        const v2 = _vertexPool[b]\n        const v3 = _vertexPool[c]\n\n        if (checkTriangleVisibility(v1, v2, v3) === false) return\n\n        if (material.side === DoubleSide || checkBackfaceCulling(v1, v2, v3) === true) {\n          _face = getNextFaceInPool()\n\n          _face.id = object.id\n          _face.v1.copy(v1)\n          _face.v2.copy(v2)\n          _face.v3.copy(v3)\n          _face.z = (v1.positionScreen.z + v2.positionScreen.z + v3.positionScreen.z) / 3\n          _face.renderOrder = object.renderOrder\n\n          // face normal\n          _vector3.subVectors(v3.position, v2.position)\n          _vector4.subVectors(v1.position, v2.position)\n          _vector3.cross(_vector4)\n          _face.normalModel.copy(_vector3)\n          _face.normalModel.applyMatrix3(normalMatrix).normalize()\n\n          for (let i = 0; i < 3; i++) {\n            const normal = _face.vertexNormalsModel[i]\n            normal.fromArray(normals, arguments[i] * 3)\n            normal.applyMatrix3(normalMatrix).normalize()\n\n            const uv = _face.uvs[i]\n            uv.fromArray(uvs, arguments[i] * 2)\n          }\n\n          _face.vertexNormalsLength = 3\n\n          _face.material = material\n\n          if (material.vertexColors) {\n            _face.color.fromArray(colors, a * 3)\n          }\n\n          _renderData.elements.push(_face)\n        }\n      }\n\n      return {\n        setObject: setObject,\n        projectVertex: projectVertex,\n        checkTriangleVisibility: checkTriangleVisibility,\n        checkBackfaceCulling: checkBackfaceCulling,\n        pushVertex: pushVertex,\n        pushNormal: pushNormal,\n        pushColor: pushColor,\n        pushUv: pushUv,\n        pushLine: pushLine,\n        pushTriangle: pushTriangle,\n      }\n    }\n\n    const renderList = new RenderList()\n\n    function projectObject(object) {\n      if (object.visible === false) return\n\n      if (object.isLight) {\n        _renderData.lights.push(object)\n      } else if (object.isMesh || object.isLine || object.isPoints) {\n        if (object.material.visible === false) return\n        if (object.frustumCulled === true && _frustum.intersectsObject(object) === false) return\n\n        addObject(object)\n      } else if (object.isSprite) {\n        if (object.material.visible === false) return\n        if (object.frustumCulled === true && _frustum.intersectsSprite(object) === false) return\n\n        addObject(object)\n      }\n\n      const children = object.children\n\n      for (let i = 0, l = children.length; i < l; i++) {\n        projectObject(children[i])\n      }\n    }\n\n    function addObject(object) {\n      _object = getNextObjectInPool()\n      _object.id = object.id\n      _object.object = object\n\n      _vector3.setFromMatrixPosition(object.matrixWorld)\n      _vector3.applyMatrix4(_viewProjectionMatrix)\n      _object.z = _vector3.z\n      _object.renderOrder = object.renderOrder\n\n      _renderData.objects.push(_object)\n    }\n\n    this.projectScene = function (scene, camera, sortObjects, sortElements) {\n      _faceCount = 0\n      _lineCount = 0\n      _spriteCount = 0\n\n      _renderData.elements.length = 0\n\n      if (scene.matrixWorldAutoUpdate === true) scene.updateMatrixWorld()\n      if (camera.parent === null && camera.matrixWorldAutoUpdate === true) camera.updateMatrixWorld()\n\n      _viewMatrix.copy(camera.matrixWorldInverse)\n      _viewProjectionMatrix.multiplyMatrices(camera.projectionMatrix, _viewMatrix)\n\n      _frustum.setFromProjectionMatrix(_viewProjectionMatrix)\n\n      //\n\n      _objectCount = 0\n\n      _renderData.objects.length = 0\n      _renderData.lights.length = 0\n\n      projectObject(scene)\n\n      if (sortObjects === true) {\n        _renderData.objects.sort(painterSort)\n      }\n\n      //\n\n      const objects = _renderData.objects\n\n      for (let o = 0, ol = objects.length; o < ol; o++) {\n        const object = objects[o].object\n        const geometry = object.geometry\n\n        renderList.setObject(object)\n\n        _modelMatrix = object.matrixWorld\n\n        _vertexCount = 0\n\n        if (object.isMesh) {\n          let material = object.material\n\n          const isMultiMaterial = Array.isArray(material)\n\n          const attributes = geometry.attributes\n          const groups = geometry.groups\n\n          if (attributes.position === undefined) continue\n\n          const positions = attributes.position.array\n\n          for (let i = 0, l = positions.length; i < l; i += 3) {\n            let x = positions[i]\n            let y = positions[i + 1]\n            let z = positions[i + 2]\n\n            const morphTargets = geometry.morphAttributes.position\n\n            if (morphTargets !== undefined) {\n              const morphTargetsRelative = geometry.morphTargetsRelative\n              const morphInfluences = object.morphTargetInfluences\n\n              for (let t = 0, tl = morphTargets.length; t < tl; t++) {\n                const influence = morphInfluences[t]\n\n                if (influence === 0) continue\n\n                const target = morphTargets[t]\n\n                if (morphTargetsRelative) {\n                  x += target.getX(i / 3) * influence\n                  y += target.getY(i / 3) * influence\n                  z += target.getZ(i / 3) * influence\n                } else {\n                  x += (target.getX(i / 3) - positions[i]) * influence\n                  y += (target.getY(i / 3) - positions[i + 1]) * influence\n                  z += (target.getZ(i / 3) - positions[i + 2]) * influence\n                }\n              }\n            }\n\n            renderList.pushVertex(x, y, z)\n          }\n\n          if (attributes.normal !== undefined) {\n            const normals = attributes.normal.array\n\n            for (let i = 0, l = normals.length; i < l; i += 3) {\n              renderList.pushNormal(normals[i], normals[i + 1], normals[i + 2])\n            }\n          }\n\n          if (attributes.color !== undefined) {\n            const colors = attributes.color.array\n\n            for (let i = 0, l = colors.length; i < l; i += 3) {\n              renderList.pushColor(colors[i], colors[i + 1], colors[i + 2])\n            }\n          }\n\n          if (attributes.uv !== undefined) {\n            const uvs = attributes.uv.array\n\n            for (let i = 0, l = uvs.length; i < l; i += 2) {\n              renderList.pushUv(uvs[i], uvs[i + 1])\n            }\n          }\n\n          if (geometry.index !== null) {\n            const indices = geometry.index.array\n\n            if (groups.length > 0) {\n              for (let g = 0; g < groups.length; g++) {\n                const group = groups[g]\n\n                material = isMultiMaterial === true ? object.material[group.materialIndex] : object.material\n\n                if (material === undefined) continue\n\n                for (let i = group.start, l = group.start + group.count; i < l; i += 3) {\n                  renderList.pushTriangle(indices[i], indices[i + 1], indices[i + 2], material)\n                }\n              }\n            } else {\n              for (let i = 0, l = indices.length; i < l; i += 3) {\n                renderList.pushTriangle(indices[i], indices[i + 1], indices[i + 2], material)\n              }\n            }\n          } else {\n            if (groups.length > 0) {\n              for (let g = 0; g < groups.length; g++) {\n                const group = groups[g]\n\n                material = isMultiMaterial === true ? object.material[group.materialIndex] : object.material\n\n                if (material === undefined) continue\n\n                for (let i = group.start, l = group.start + group.count; i < l; i += 3) {\n                  renderList.pushTriangle(i, i + 1, i + 2, material)\n                }\n              }\n            } else {\n              for (let i = 0, l = positions.length / 3; i < l; i += 3) {\n                renderList.pushTriangle(i, i + 1, i + 2, material)\n              }\n            }\n          }\n        } else if (object.isLine) {\n          _modelViewProjectionMatrix.multiplyMatrices(_viewProjectionMatrix, _modelMatrix)\n\n          const attributes = geometry.attributes\n\n          if (attributes.position !== undefined) {\n            const positions = attributes.position.array\n\n            for (let i = 0, l = positions.length; i < l; i += 3) {\n              renderList.pushVertex(positions[i], positions[i + 1], positions[i + 2])\n            }\n\n            if (attributes.color !== undefined) {\n              const colors = attributes.color.array\n\n              for (let i = 0, l = colors.length; i < l; i += 3) {\n                renderList.pushColor(colors[i], colors[i + 1], colors[i + 2])\n              }\n            }\n\n            if (geometry.index !== null) {\n              const indices = geometry.index.array\n\n              for (let i = 0, l = indices.length; i < l; i += 2) {\n                renderList.pushLine(indices[i], indices[i + 1])\n              }\n            } else {\n              const step = object.isLineSegments ? 2 : 1\n\n              for (let i = 0, l = positions.length / 3 - 1; i < l; i += step) {\n                renderList.pushLine(i, i + 1)\n              }\n            }\n          }\n        } else if (object.isPoints) {\n          _modelViewProjectionMatrix.multiplyMatrices(_viewProjectionMatrix, _modelMatrix)\n\n          const attributes = geometry.attributes\n\n          if (attributes.position !== undefined) {\n            const positions = attributes.position.array\n\n            for (let i = 0, l = positions.length; i < l; i += 3) {\n              _vector4.set(positions[i], positions[i + 1], positions[i + 2], 1)\n              _vector4.applyMatrix4(_modelViewProjectionMatrix)\n\n              pushPoint(_vector4, object, camera)\n            }\n          }\n        } else if (object.isSprite) {\n          object.modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse, object.matrixWorld)\n          _vector4.set(_modelMatrix.elements[12], _modelMatrix.elements[13], _modelMatrix.elements[14], 1)\n          _vector4.applyMatrix4(_viewProjectionMatrix)\n\n          pushPoint(_vector4, object, camera)\n        }\n      }\n\n      if (sortElements === true) {\n        _renderData.elements.sort(painterSort)\n      }\n\n      return _renderData\n    }\n\n    function pushPoint(_vector4, object, camera) {\n      const invW = 1 / _vector4.w\n\n      _vector4.z *= invW\n\n      if (_vector4.z >= -1 && _vector4.z <= 1) {\n        _sprite = getNextSpriteInPool()\n        _sprite.id = object.id\n        _sprite.x = _vector4.x * invW\n        _sprite.y = _vector4.y * invW\n        _sprite.z = _vector4.z\n        _sprite.renderOrder = object.renderOrder\n        _sprite.object = object\n\n        _sprite.rotation = object.rotation\n\n        _sprite.scale.x =\n          object.scale.x *\n          Math.abs(\n            _sprite.x -\n              (_vector4.x + camera.projectionMatrix.elements[0]) / (_vector4.w + camera.projectionMatrix.elements[12]),\n          )\n        _sprite.scale.y =\n          object.scale.y *\n          Math.abs(\n            _sprite.y -\n              (_vector4.y + camera.projectionMatrix.elements[5]) / (_vector4.w + camera.projectionMatrix.elements[13]),\n          )\n\n        _sprite.material = object.material\n\n        _renderData.elements.push(_sprite)\n      }\n    }\n\n    // Pools\n\n    function getNextObjectInPool() {\n      if (_objectCount === _objectPoolLength) {\n        const object = new RenderableObject()\n        _objectPool.push(object)\n        _objectPoolLength++\n        _objectCount++\n        return object\n      }\n\n      return _objectPool[_objectCount++]\n    }\n\n    function getNextVertexInPool() {\n      if (_vertexCount === _vertexPoolLength) {\n        const vertex = new RenderableVertex()\n        _vertexPool.push(vertex)\n        _vertexPoolLength++\n        _vertexCount++\n        return vertex\n      }\n\n      return _vertexPool[_vertexCount++]\n    }\n\n    function getNextFaceInPool() {\n      if (_faceCount === _facePoolLength) {\n        const face = new RenderableFace()\n        _facePool.push(face)\n        _facePoolLength++\n        _faceCount++\n        return face\n      }\n\n      return _facePool[_faceCount++]\n    }\n\n    function getNextLineInPool() {\n      if (_lineCount === _linePoolLength) {\n        const line = new RenderableLine()\n        _linePool.push(line)\n        _linePoolLength++\n        _lineCount++\n        return line\n      }\n\n      return _linePool[_lineCount++]\n    }\n\n    function getNextSpriteInPool() {\n      if (_spriteCount === _spritePoolLength) {\n        const sprite = new RenderableSprite()\n        _spritePool.push(sprite)\n        _spritePoolLength++\n        _spriteCount++\n        return sprite\n      }\n\n      return _spritePool[_spriteCount++]\n    }\n\n    //\n\n    function painterSort(a, b) {\n      if (a.renderOrder !== b.renderOrder) {\n        return a.renderOrder - b.renderOrder\n      } else if (a.z !== b.z) {\n        return b.z - a.z\n      } else if (a.id !== b.id) {\n        return a.id - b.id\n      } else {\n        return 0\n      }\n    }\n\n    function clipLine(s1, s2) {\n      let alpha1 = 0,\n        alpha2 = 1\n\n      // Calculate the boundary coordinate of each vertex for the near and far clip planes,\n      // Z = -1 and Z = +1, respectively.\n\n      const bc1near = s1.z + s1.w,\n        bc2near = s2.z + s2.w,\n        bc1far = -s1.z + s1.w,\n        bc2far = -s2.z + s2.w\n\n      if (bc1near >= 0 && bc2near >= 0 && bc1far >= 0 && bc2far >= 0) {\n        // Both vertices lie entirely within all clip planes.\n        return true\n      } else if ((bc1near < 0 && bc2near < 0) || (bc1far < 0 && bc2far < 0)) {\n        // Both vertices lie entirely outside one of the clip planes.\n        return false\n      } else {\n        // The line segment spans at least one clip plane.\n\n        if (bc1near < 0) {\n          // v1 lies outside the near plane, v2 inside\n          alpha1 = Math.max(alpha1, bc1near / (bc1near - bc2near))\n        } else if (bc2near < 0) {\n          // v2 lies outside the near plane, v1 inside\n          alpha2 = Math.min(alpha2, bc1near / (bc1near - bc2near))\n        }\n\n        if (bc1far < 0) {\n          // v1 lies outside the far plane, v2 inside\n          alpha1 = Math.max(alpha1, bc1far / (bc1far - bc2far))\n        } else if (bc2far < 0) {\n          // v2 lies outside the far plane, v2 inside\n          alpha2 = Math.min(alpha2, bc1far / (bc1far - bc2far))\n        }\n\n        if (alpha2 < alpha1) {\n          // The line segment spans two boundaries, but is outside both of them.\n          // (This can't happen when we're only clipping against just near/far but good\n          //  to leave the check here for future usage if other clip planes are added.)\n          return false\n        } else {\n          // Update the s1 and s2 vertices to match the clipped line segment.\n          s1.lerp(s2, alpha1)\n          s2.lerp(s1, 1 - alpha2)\n\n          return true\n        }\n      }\n    }\n  }\n}\n\nexport { RenderableObject, RenderableFace, RenderableVertex, RenderableLine, RenderableSprite, Projector }\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}