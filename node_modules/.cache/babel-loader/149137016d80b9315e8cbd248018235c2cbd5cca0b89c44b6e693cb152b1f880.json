{"ast":null,"code":"import _classCallCheck from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _get from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/get.js\";\nimport _getPrototypeOf from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js\";\nimport _inherits from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport { WebGLRenderTarget, HalfFloatType } from \"three\";\nimport { SSAARenderPass } from \"./SSAARenderPass.js\";\nvar TAARenderPass = /*#__PURE__*/function (_SSAARenderPass) {\n  _inherits(TAARenderPass, _SSAARenderPass);\n  var _super = _createSuper(TAARenderPass);\n  function TAARenderPass(scene, camera, clearColor, clearAlpha) {\n    var _this;\n    _classCallCheck(this, TAARenderPass);\n    _this = _super.call(this, scene, camera, clearColor, clearAlpha);\n    _this.sampleLevel = 0;\n    _this.accumulate = false;\n    _this.accumulateIndex = -1;\n    return _this;\n  }\n  _createClass(TAARenderPass, [{\n    key: \"render\",\n    value: function render(renderer, writeBuffer, readBuffer, deltaTime) {\n      if (this.accumulate === false) {\n        _get(_getPrototypeOf(TAARenderPass.prototype), \"render\", this).call(this, renderer, writeBuffer, readBuffer, deltaTime);\n        this.accumulateIndex = -1;\n        return;\n      }\n      var jitterOffsets = _JitterVectors[5];\n      if (this.sampleRenderTarget === void 0) {\n        this.sampleRenderTarget = new WebGLRenderTarget(readBuffer.width, readBuffer.height, {\n          type: HalfFloatType\n        });\n        this.sampleRenderTarget.texture.name = \"TAARenderPass.sample\";\n      }\n      if (this.holdRenderTarget === void 0) {\n        this.holdRenderTarget = new WebGLRenderTarget(readBuffer.width, readBuffer.height, {\n          type: HalfFloatType\n        });\n        this.holdRenderTarget.texture.name = \"TAARenderPass.hold\";\n      }\n      if (this.accumulateIndex === -1) {\n        _get(_getPrototypeOf(TAARenderPass.prototype), \"render\", this).call(this, renderer, this.holdRenderTarget, readBuffer, deltaTime);\n        this.accumulateIndex = 0;\n      }\n      var autoClear = renderer.autoClear;\n      renderer.autoClear = false;\n      renderer.getClearColor(this._oldClearColor);\n      var oldClearAlpha = renderer.getClearAlpha();\n      var sampleWeight = 1 / jitterOffsets.length;\n      if (this.accumulateIndex >= 0 && this.accumulateIndex < jitterOffsets.length) {\n        this.copyUniforms[\"opacity\"].value = sampleWeight;\n        this.copyUniforms[\"tDiffuse\"].value = writeBuffer.texture;\n        var numSamplesPerFrame = Math.pow(2, this.sampleLevel);\n        for (var i = 0; i < numSamplesPerFrame; i++) {\n          var j = this.accumulateIndex;\n          var jitterOffset = jitterOffsets[j];\n          if (this.camera.setViewOffset) {\n            this.camera.setViewOffset(readBuffer.width, readBuffer.height, jitterOffset[0] * 0.0625, jitterOffset[1] * 0.0625,\n            // 0.0625 = 1 / 16\n            readBuffer.width, readBuffer.height);\n          }\n          renderer.setRenderTarget(writeBuffer);\n          renderer.setClearColor(this.clearColor, this.clearAlpha);\n          renderer.clear();\n          renderer.render(this.scene, this.camera);\n          renderer.setRenderTarget(this.sampleRenderTarget);\n          if (this.accumulateIndex === 0) {\n            renderer.setClearColor(0, 0);\n            renderer.clear();\n          }\n          this.fsQuad.render(renderer);\n          this.accumulateIndex++;\n          if (this.accumulateIndex >= jitterOffsets.length) break;\n        }\n        if (this.camera.clearViewOffset) this.camera.clearViewOffset();\n      }\n      renderer.setClearColor(this.clearColor, this.clearAlpha);\n      var accumulationWeight = this.accumulateIndex * sampleWeight;\n      if (accumulationWeight > 0) {\n        this.copyUniforms[\"opacity\"].value = 1;\n        this.copyUniforms[\"tDiffuse\"].value = this.sampleRenderTarget.texture;\n        renderer.setRenderTarget(writeBuffer);\n        renderer.clear();\n        this.fsQuad.render(renderer);\n      }\n      if (accumulationWeight < 1) {\n        this.copyUniforms[\"opacity\"].value = 1 - accumulationWeight;\n        this.copyUniforms[\"tDiffuse\"].value = this.holdRenderTarget.texture;\n        renderer.setRenderTarget(writeBuffer);\n        this.fsQuad.render(renderer);\n      }\n      renderer.autoClear = autoClear;\n      renderer.setClearColor(this._oldClearColor, oldClearAlpha);\n    }\n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      _get(_getPrototypeOf(TAARenderPass.prototype), \"dispose\", this).call(this);\n      if (this.sampleRenderTarget !== void 0) this.sampleRenderTarget.dispose();\n      if (this.holdRenderTarget !== void 0) this.holdRenderTarget.dispose();\n    }\n  }]);\n  return TAARenderPass;\n}(SSAARenderPass);\nvar _JitterVectors = [[[0, 0]], [[4, 4], [-4, -4]], [[-2, -6], [6, -2], [-6, 2], [2, 6]], [[1, -3], [-1, 3], [5, 1], [-3, -5], [-5, 5], [-7, -1], [3, 7], [7, -7]], [[1, 1], [-1, -3], [-3, 2], [4, -1], [-5, -2], [2, 5], [5, 3], [3, -5], [-2, 6], [0, -7], [-4, -6], [-6, 4], [-8, 0], [7, -4], [6, 7], [-7, -8]], [[-4, -7], [-7, -5], [-3, -5], [-5, -4], [-1, -4], [-2, -2], [-6, -1], [-4, 0], [-7, 1], [-1, 2], [-6, 3], [-3, 3], [-7, 6], [-3, 6], [-5, 7], [-1, 7], [5, -7], [1, -6], [6, -5], [4, -4], [2, -3], [7, -2], [1, -1], [4, -1], [2, 1], [6, 2], [0, 4], [4, 4], [2, 5], [7, 5], [5, 6], [3, 7]]];\nexport { TAARenderPass };","map":{"version":3,"names":["TAARenderPass","_SSAARenderPass","_inherits","_super","_createSuper","scene","camera","clearColor","clearAlpha","_this","_classCallCheck","call","sampleLevel","accumulate","accumulateIndex","_createClass","key","value","render","renderer","writeBuffer","readBuffer","deltaTime","_get","_getPrototypeOf","prototype","jitterOffsets","_JitterVectors","sampleRenderTarget","WebGLRenderTarget","width","height","type","HalfFloatType","texture","name","holdRenderTarget","autoClear","getClearColor","_oldClearColor","oldClearAlpha","getClearAlpha","sampleWeight","length","copyUniforms","numSamplesPerFrame","Math","pow","i","j","jitterOffset","setViewOffset","setRenderTarget","setClearColor","clear","fsQuad","clearViewOffset","accumulationWeight","dispose","SSAARenderPass"],"sources":["C:\\Users\\Nayyu\\Desktop\\skibidai-public-build\\node_modules\\src\\postprocessing\\TAARenderPass.js"],"sourcesContent":["import { HalfFloatType, WebGLRenderTarget } from 'three'\nimport { SSAARenderPass } from './SSAARenderPass'\n\n/**\n *\n * Temporal Anti-Aliasing Render Pass\n *\n * When there is no motion in the scene, the TAA render pass accumulates jittered camera samples across frames to create a high quality anti-aliased result.\n *\n * References:\n *\n * TODO: Add support for motion vector pas so that accumulation of samples across frames can occur on dynamics scenes.\n *\n */\n\nclass TAARenderPass extends SSAARenderPass {\n  constructor(scene, camera, clearColor, clearAlpha) {\n    super(scene, camera, clearColor, clearAlpha)\n\n    this.sampleLevel = 0\n    this.accumulate = false\n    this.accumulateIndex = -1\n  }\n\n  render(renderer, writeBuffer, readBuffer, deltaTime) {\n    if (this.accumulate === false) {\n      super.render(renderer, writeBuffer, readBuffer, deltaTime)\n\n      this.accumulateIndex = -1\n      return\n    }\n\n    const jitterOffsets = _JitterVectors[5]\n\n    if (this.sampleRenderTarget === undefined) {\n      this.sampleRenderTarget = new WebGLRenderTarget(readBuffer.width, readBuffer.height, { type: HalfFloatType })\n      this.sampleRenderTarget.texture.name = 'TAARenderPass.sample'\n    }\n\n    if (this.holdRenderTarget === undefined) {\n      this.holdRenderTarget = new WebGLRenderTarget(readBuffer.width, readBuffer.height, { type: HalfFloatType })\n      this.holdRenderTarget.texture.name = 'TAARenderPass.hold'\n    }\n\n    if (this.accumulateIndex === -1) {\n      super.render(renderer, this.holdRenderTarget, readBuffer, deltaTime)\n\n      this.accumulateIndex = 0\n    }\n\n    const autoClear = renderer.autoClear\n    renderer.autoClear = false\n\n    renderer.getClearColor(this._oldClearColor)\n    const oldClearAlpha = renderer.getClearAlpha()\n\n    const sampleWeight = 1.0 / jitterOffsets.length\n\n    if (this.accumulateIndex >= 0 && this.accumulateIndex < jitterOffsets.length) {\n      this.copyUniforms['opacity'].value = sampleWeight\n      this.copyUniforms['tDiffuse'].value = writeBuffer.texture\n\n      // render the scene multiple times, each slightly jitter offset from the last and accumulate the results.\n      const numSamplesPerFrame = Math.pow(2, this.sampleLevel)\n      for (let i = 0; i < numSamplesPerFrame; i++) {\n        const j = this.accumulateIndex\n        const jitterOffset = jitterOffsets[j]\n\n        if (this.camera.setViewOffset) {\n          this.camera.setViewOffset(\n            readBuffer.width,\n            readBuffer.height,\n            jitterOffset[0] * 0.0625,\n            jitterOffset[1] * 0.0625, // 0.0625 = 1 / 16\n            readBuffer.width,\n            readBuffer.height,\n          )\n        }\n\n        renderer.setRenderTarget(writeBuffer)\n        renderer.setClearColor(this.clearColor, this.clearAlpha)\n        renderer.clear()\n        renderer.render(this.scene, this.camera)\n\n        renderer.setRenderTarget(this.sampleRenderTarget)\n        if (this.accumulateIndex === 0) {\n          renderer.setClearColor(0x000000, 0.0)\n          renderer.clear()\n        }\n\n        this.fsQuad.render(renderer)\n\n        this.accumulateIndex++\n\n        if (this.accumulateIndex >= jitterOffsets.length) break\n      }\n\n      if (this.camera.clearViewOffset) this.camera.clearViewOffset()\n    }\n\n    renderer.setClearColor(this.clearColor, this.clearAlpha)\n    const accumulationWeight = this.accumulateIndex * sampleWeight\n\n    if (accumulationWeight > 0) {\n      this.copyUniforms['opacity'].value = 1.0\n      this.copyUniforms['tDiffuse'].value = this.sampleRenderTarget.texture\n      renderer.setRenderTarget(writeBuffer)\n      renderer.clear()\n      this.fsQuad.render(renderer)\n    }\n\n    if (accumulationWeight < 1.0) {\n      this.copyUniforms['opacity'].value = 1.0 - accumulationWeight\n      this.copyUniforms['tDiffuse'].value = this.holdRenderTarget.texture\n      renderer.setRenderTarget(writeBuffer)\n      this.fsQuad.render(renderer)\n    }\n\n    renderer.autoClear = autoClear\n    renderer.setClearColor(this._oldClearColor, oldClearAlpha)\n  }\n\n  dispose() {\n    super.dispose()\n\n    if (this.sampleRenderTarget !== undefined) this.sampleRenderTarget.dispose()\n    if (this.holdRenderTarget !== undefined) this.holdRenderTarget.dispose()\n  }\n}\n\n// prettier-ignore\nconst _JitterVectors = [\n\t[\n\t\t[ 0, 0 ]\n\t],\n\t[\n\t\t[ 4, 4 ], [ - 4, - 4 ]\n\t],\n\t[\n\t\t[ - 2, - 6 ], [ 6, - 2 ], [ - 6, 2 ], [ 2, 6 ]\n\t],\n\t[\n\t\t[ 1, - 3 ], [ - 1, 3 ], [ 5, 1 ], [ - 3, - 5 ],\n\t\t[ - 5, 5 ], [ - 7, - 1 ], [ 3, 7 ], [ 7, - 7 ]\n\t],\n\t[\n\t\t[ 1, 1 ], [ - 1, - 3 ], [ - 3, 2 ], [ 4, - 1 ],\n\t\t[ - 5, - 2 ], [ 2, 5 ], [ 5, 3 ], [ 3, - 5 ],\n\t\t[ - 2, 6 ], [ 0, - 7 ], [ - 4, - 6 ], [ - 6, 4 ],\n\t\t[ - 8, 0 ], [ 7, - 4 ], [ 6, 7 ], [ - 7, - 8 ]\n\t],\n\t[\n\t\t[ - 4, - 7 ], [ - 7, - 5 ], [ - 3, - 5 ], [ - 5, - 4 ],\n\t\t[ - 1, - 4 ], [ - 2, - 2 ], [ - 6, - 1 ], [ - 4, 0 ],\n\t\t[ - 7, 1 ], [ - 1, 2 ], [ - 6, 3 ], [ - 3, 3 ],\n\t\t[ - 7, 6 ], [ - 3, 6 ], [ - 5, 7 ], [ - 1, 7 ],\n\t\t[ 5, - 7 ], [ 1, - 6 ], [ 6, - 5 ], [ 4, - 4 ],\n\t\t[ 2, - 3 ], [ 7, - 2 ], [ 1, - 1 ], [ 4, - 1 ],\n\t\t[ 2, 1 ], [ 6, 2 ], [ 0, 4 ], [ 4, 4 ],\n\t\t[ 2, 5 ], [ 7, 5 ], [ 5, 6 ], [ 3, 7 ]\n\t]\n];\n\nexport { TAARenderPass }\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}