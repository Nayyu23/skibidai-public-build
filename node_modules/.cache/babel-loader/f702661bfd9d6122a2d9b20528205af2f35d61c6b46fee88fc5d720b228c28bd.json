{"ast":null,"code":"import _classCallCheck from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _assertThisInitialized from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js\";\nimport _inherits from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = function __defNormalProp(obj, key, value) {\n  return key in obj ? __defProp(obj, key, {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: value\n  }) : obj[key] = value;\n};\nvar __publicField = function __publicField(obj, key, value) {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nimport { Matrix4, Mesh, BufferGeometry, MathUtils, DataTexture, RGBAFormat, FloatType, BufferAttribute } from \"three\";\nvar ID_ATTR_NAME = \"_batch_id_\";\nvar _identityMatrix = new Matrix4();\nvar _zeroScaleMatrix = new Matrix4().set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1);\nvar batchingParsVertex = /* glsl */\"\\n#ifdef BATCHING\\n\\tattribute float \".concat(ID_ATTR_NAME, \";\\n\\tuniform highp sampler2D batchingTexture;\\n\\tmat4 getBatchingMatrix( const in float i ) {\\n\\n\\t\\tint size = textureSize( batchingTexture, 0 ).x;\\n\\t\\tint j = int( i ) * 4;\\n\\t\\tint x = j % size;\\n\\t\\tint y = j / size;\\n\\t\\tvec4 v1 = texelFetch( batchingTexture, ivec2( x, y ), 0 );\\n\\t\\tvec4 v2 = texelFetch( batchingTexture, ivec2( x + 1, y ), 0 );\\n\\t\\tvec4 v3 = texelFetch( batchingTexture, ivec2( x + 2, y ), 0 );\\n\\t\\tvec4 v4 = texelFetch( batchingTexture, ivec2( x + 3, y ), 0 );\\n\\t\\treturn mat4( v1, v2, v3, v4 );\\n\\n\\t}\\n#endif\\n\");\nvar batchingbaseVertex = /* glsl */\"\\n#ifdef BATCHING\\n\\tmat4 batchingMatrix = getBatchingMatrix( \".concat(ID_ATTR_NAME, \" );\\n#endif\\n\");\nvar batchingnormalVertex = /* glsl */\"\\n#ifdef BATCHING\\n\\tobjectNormal = vec4( batchingMatrix * vec4( objectNormal, 0.0 ) ).xyz;\\n\\t#ifdef USE_TANGENT\\n\\t\\tobjectTangent = vec4( batchingMatrix * vec4( objectTangent, 0.0 ) ).xyz;\\n\\t#endif\\n#endif\\n\";\nvar batchingVertex = /* glsl */\"\\n#ifdef BATCHING\\n\\ttransformed = ( batchingMatrix * vec4( transformed, 1.0 ) ).xyz;\\n#endif\\n\";\nfunction copyAttributeData(src, target) {\n  var targetOffset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  var itemSize = target.itemSize;\n  if (src.isInterleavedBufferAttribute || src.array.constructor !== target.array.constructor) {\n    var vertexCount = src.count;\n    for (var i = 0; i < vertexCount; i++) {\n      for (var c = 0; c < itemSize; c++) {\n        target.setComponent(i + targetOffset, c, src.getComponent(i, c));\n      }\n    }\n  } else {\n    target.array.set(src.array, targetOffset * itemSize);\n  }\n  target.needsUpdate = true;\n}\nvar BatchedMesh = /*#__PURE__*/function (_Mesh) {\n  _inherits(BatchedMesh, _Mesh);\n  var _super = _createSuper(BatchedMesh);\n  function BatchedMesh(maxGeometryCount, maxVertexCount) {\n    var _this;\n    var maxIndexCount = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : maxVertexCount * 2;\n    var material = arguments.length > 3 ? arguments[3] : undefined;\n    _classCallCheck(this, BatchedMesh);\n    _this = _super.call(this, new BufferGeometry(), material);\n    __publicField(_assertThisInitialized(_this), \"_vertexStarts\");\n    __publicField(_assertThisInitialized(_this), \"_vertexCounts\");\n    __publicField(_assertThisInitialized(_this), \"_indexStarts\");\n    __publicField(_assertThisInitialized(_this), \"_indexCounts\");\n    __publicField(_assertThisInitialized(_this), \"_reservedRanges\");\n    __publicField(_assertThisInitialized(_this), \"_visible\");\n    __publicField(_assertThisInitialized(_this), \"_active\");\n    __publicField(_assertThisInitialized(_this), \"_maxGeometryCount\");\n    __publicField(_assertThisInitialized(_this), \"_maxVertexCount\");\n    __publicField(_assertThisInitialized(_this), \"_maxIndexCount\");\n    __publicField(_assertThisInitialized(_this), \"_geometryInitialized\");\n    __publicField(_assertThisInitialized(_this), \"_geometryCount\");\n    __publicField(_assertThisInitialized(_this), \"_matrices\");\n    __publicField(_assertThisInitialized(_this), \"_matricesTexture\");\n    __publicField(_assertThisInitialized(_this), \"_customUniforms\");\n    _this._vertexStarts = [];\n    _this._vertexCounts = [];\n    _this._indexStarts = [];\n    _this._indexCounts = [];\n    _this._reservedRanges = [];\n    _this._visible = [];\n    _this._active = [];\n    _this._maxGeometryCount = maxGeometryCount;\n    _this._maxVertexCount = maxVertexCount;\n    _this._maxIndexCount = maxIndexCount;\n    _this._geometryInitialized = false;\n    _this._geometryCount = 0;\n    _this._matrices = [];\n    _this._matricesTexture = null;\n    _this.frustumCulled = false;\n    _this._customUniforms = {\n      batchingTexture: {\n        value: null\n      }\n    };\n    _this._initMatricesTexture();\n    _this._initShader();\n    _this.onBeforeRender = function () {\n      if (this.material.defines) {\n        this.material.defines.BATCHING = true;\n      }\n    };\n    _this.onAfterRender = function () {\n      if (this.material.defines) {\n        this.material.defines.BATCHING = false;\n      }\n    };\n    return _this;\n  }\n  _createClass(BatchedMesh, [{\n    key: \"_initMatricesTexture\",\n    value: function _initMatricesTexture() {\n      var size = Math.sqrt(this._maxGeometryCount * 4);\n      size = MathUtils.ceilPowerOfTwo(size);\n      size = Math.max(size, 4);\n      var matricesArray = new Float32Array(size * size * 4);\n      var matricesTexture = new DataTexture(matricesArray, size, size, RGBAFormat, FloatType);\n      this._matricesTexture = matricesTexture;\n      this._customUniforms.batchingTexture.value = this._matricesTexture;\n    }\n  }, {\n    key: \"_initShader\",\n    value: function _initShader() {\n      var material = this.material;\n      var currentOnBeforeCompile = material.onBeforeCompile;\n      var customUniforms = this._customUniforms;\n      material.onBeforeCompile = function onBeforeCompile(parameters, renderer) {\n        parameters.vertexShader = parameters.vertexShader.replace(\"#include <skinning_pars_vertex>\", \"#include <skinning_pars_vertex>\\n\" + batchingParsVertex).replace(\"#include <uv_vertex>\", \"#include <uv_vertex>\\n\" + batchingbaseVertex).replace(\"#include <skinnormal_vertex>\", \"#include <skinnormal_vertex>\\n\" + batchingnormalVertex).replace(\"#include <skinning_vertex>\", \"#include <skinning_vertex>\\n\" + batchingVertex);\n        for (var uniformName in customUniforms) {\n          parameters.uniforms[uniformName] = customUniforms[uniformName];\n        }\n        currentOnBeforeCompile.call(this, parameters, renderer);\n      };\n      material.defines = material.defines || {};\n      material.defines.BATCHING = false;\n    }\n  }, {\n    key: \"_initializeGeometry\",\n    value: function _initializeGeometry(reference) {\n      var geometry = this.geometry;\n      var maxVertexCount = this._maxVertexCount;\n      var maxGeometryCount = this._maxGeometryCount;\n      var maxIndexCount = this._maxIndexCount;\n      if (this._geometryInitialized === false) {\n        for (var attributeName in reference.attributes) {\n          var srcAttribute = reference.getAttribute(attributeName);\n          var array = srcAttribute.array,\n            itemSize = srcAttribute.itemSize,\n            normalized = srcAttribute.normalized;\n          var dstArray = new array.constructor(maxVertexCount * itemSize);\n          var dstAttribute = new srcAttribute.constructor(dstArray, itemSize, normalized);\n          dstAttribute.setUsage(srcAttribute.usage);\n          geometry.setAttribute(attributeName, dstAttribute);\n        }\n        if (reference.getIndex() !== null) {\n          var indexArray = maxVertexCount > 65536 ? new Uint32Array(maxIndexCount) : new Uint16Array(maxIndexCount);\n          geometry.setIndex(new BufferAttribute(indexArray, 1));\n        }\n        var idArray = maxGeometryCount > 65536 ? new Uint32Array(maxVertexCount) : new Uint16Array(maxVertexCount);\n        geometry.setAttribute(ID_ATTR_NAME, new BufferAttribute(idArray, 1));\n        this._geometryInitialized = true;\n      }\n    }\n    // Make sure the geometry is compatible with the existing combined geometry atributes\n  }, {\n    key: \"_validateGeometry\",\n    value: function _validateGeometry(geometry) {\n      if (geometry.getAttribute(ID_ATTR_NAME)) {\n        throw new Error(\"BatchedMesh: Geometry cannot use attribute \\\"\".concat(ID_ATTR_NAME, \"\\\"\"));\n      }\n      var batchGeometry = this.geometry;\n      if (Boolean(geometry.getIndex()) !== Boolean(batchGeometry.getIndex())) {\n        throw new Error('BatchedMesh: All geometries must consistently have \"index\".');\n      }\n      for (var attributeName in batchGeometry.attributes) {\n        if (attributeName === ID_ATTR_NAME) {\n          continue;\n        }\n        if (!geometry.hasAttribute(attributeName)) {\n          throw new Error(\"BatchedMesh: Added geometry missing \\\"\".concat(attributeName, \"\\\". All geometries must have consistent attributes.\"));\n        }\n        var srcAttribute = geometry.getAttribute(attributeName);\n        var dstAttribute = batchGeometry.getAttribute(attributeName);\n        if (srcAttribute.itemSize !== dstAttribute.itemSize || srcAttribute.normalized !== dstAttribute.normalized) {\n          throw new Error(\"BatchedMesh: All attributes must have a consistent itemSize and normalized value.\");\n        }\n      }\n    }\n  }, {\n    key: \"getGeometryCount\",\n    value: function getGeometryCount() {\n      return this._geometryCount;\n    }\n  }, {\n    key: \"getVertexCount\",\n    value: function getVertexCount() {\n      var reservedRanges = this._reservedRanges;\n      if (reservedRanges.length === 0) {\n        return 0;\n      } else {\n        var finalRange = reservedRanges[reservedRanges.length - 1];\n        return finalRange.vertexStart + finalRange.vertexCount;\n      }\n    }\n  }, {\n    key: \"getIndexCount\",\n    value: function getIndexCount() {\n      var reservedRanges = this._reservedRanges;\n      var geometry = this.geometry;\n      if (geometry.getIndex() === null || reservedRanges.length === 0) {\n        return 0;\n      } else {\n        var finalRange = reservedRanges[reservedRanges.length - 1];\n        return finalRange.indexStart + finalRange.indexCount;\n      }\n    }\n  }, {\n    key: \"addGeometry\",\n    value: function addGeometry(geometry) {\n      var vertexCount = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : -1;\n      var indexCount = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : -1;\n      this._initializeGeometry(geometry);\n      this._validateGeometry(geometry);\n      if (this._geometryCount >= this._maxGeometryCount) {\n        throw new Error(\"BatchedMesh: Maximum geometry count reached.\");\n      }\n      var range = {\n        vertexStart: -1,\n        vertexCount: -1,\n        indexStart: -1,\n        indexCount: -1\n      };\n      var lastRange = null;\n      var reservedRanges = this._reservedRanges;\n      if (this._geometryCount !== 0) {\n        lastRange = reservedRanges[reservedRanges.length - 1];\n      }\n      if (vertexCount === -1) {\n        range.vertexCount = geometry.getAttribute(\"position\").count;\n      } else {\n        range.vertexCount = vertexCount;\n      }\n      if (lastRange === null) {\n        range.vertexStart = 0;\n      } else {\n        range.vertexStart = lastRange.vertexStart + lastRange.vertexCount;\n      }\n      if (geometry.getIndex() !== null) {\n        if (indexCount === -1) {\n          range.indexCount = geometry.getIndex().count;\n        } else {\n          range.indexCount = indexCount;\n        }\n        if (lastRange === null) {\n          range.indexStart = 0;\n        } else {\n          range.indexStart = lastRange.indexStart + lastRange.indexCount;\n        }\n      }\n      if (range.indexStart !== -1 && range.indexStart + range.indexCount > this._maxIndexCount || range.vertexStart + range.vertexCount > this._maxVertexCount) {\n        throw new Error(\"BatchedMesh: Reserved space request exceeds the maximum buffer size.\");\n      }\n      var indexCounts = this._indexCounts;\n      var indexStarts = this._indexStarts;\n      var vertexCounts = this._vertexCounts;\n      var vertexStarts = this._vertexStarts;\n      var visible = this._visible;\n      var active = this._active;\n      var matricesTexture = this._matricesTexture;\n      var matrices = this._matrices;\n      var matricesArray = this._matricesTexture.image.data;\n      visible.push(true);\n      active.push(true);\n      var geometryId = this._geometryCount;\n      this._geometryCount++;\n      matrices.push(new Matrix4());\n      _identityMatrix.toArray(matricesArray, geometryId * 16);\n      matricesTexture.needsUpdate = true;\n      reservedRanges.push(range);\n      vertexStarts.push(range.vertexStart);\n      vertexCounts.push(range.vertexCount);\n      if (geometry.getIndex() !== null) {\n        indexStarts.push(range.indexCount);\n        indexCounts.push(range.indexCount);\n      }\n      var idAttribute = this.geometry.getAttribute(ID_ATTR_NAME);\n      for (var i = 0; i < range.vertexCount; i++) {\n        idAttribute.setX(range.vertexStart + i, geometryId);\n      }\n      idAttribute.needsUpdate = true;\n      this.setGeometryAt(geometryId, geometry);\n      return geometryId;\n    }\n    /**\n     * @deprecated use `addGeometry` instead.\n     */\n  }, {\n    key: \"applyGeometry\",\n    value: function applyGeometry(geometry) {\n      return this.addGeometry(geometry);\n    }\n  }, {\n    key: \"setGeometryAt\",\n    value: function setGeometryAt(id, geometry) {\n      if (id >= this._geometryCount) {\n        throw new Error(\"BatchedMesh: Maximum geometry count reached.\");\n      }\n      this._validateGeometry(geometry);\n      var range = this._reservedRanges[id];\n      if (geometry.getIndex() !== null && geometry.getIndex().count > range.indexCount || geometry.attributes.position.count > range.vertexCount) {\n        throw new Error(\"BatchedMesh: Reserved space not large enough for provided geometry.\");\n      }\n      var batchGeometry = this.geometry;\n      var srcPositionAttribute = geometry.getAttribute(\"position\");\n      var hasIndex = batchGeometry.getIndex() !== null;\n      var dstIndex = batchGeometry.getIndex();\n      var srcIndex = geometry.getIndex();\n      var vertexStart = range.vertexStart;\n      var vertexCount = range.vertexCount;\n      for (var attributeName in batchGeometry.attributes) {\n        if (attributeName === ID_ATTR_NAME) {\n          continue;\n        }\n        var srcAttribute = geometry.getAttribute(attributeName);\n        var dstAttribute = batchGeometry.getAttribute(attributeName);\n        copyAttributeData(srcAttribute, dstAttribute, vertexStart);\n        var itemSize = srcAttribute.itemSize;\n        for (var i = srcAttribute.count, l = vertexCount; i < l; i++) {\n          var index = vertexStart + i;\n          for (var c = 0; c < itemSize; c++) {\n            dstAttribute.setComponent(index, c, 0);\n          }\n        }\n        dstAttribute.needsUpdate = true;\n      }\n      this._vertexCounts[id] = srcPositionAttribute.count;\n      if (hasIndex) {\n        var indexStart = range.indexStart;\n        for (var _i = 0; _i < srcIndex.count; _i++) {\n          dstIndex.setX(indexStart + _i, vertexStart + srcIndex.getX(_i));\n        }\n        for (var _i2 = srcIndex.count, _l = range.indexCount; _i2 < _l; _i2++) {\n          dstIndex.setX(indexStart + _i2, vertexStart);\n        }\n        dstIndex.needsUpdate = true;\n        this._indexCounts[id] = srcIndex.count;\n      }\n      return id;\n    }\n  }, {\n    key: \"deleteGeometry\",\n    value: function deleteGeometry(geometryId) {\n      var active = this._active;\n      var matricesTexture = this._matricesTexture;\n      var matricesArray = matricesTexture.image.data;\n      if (geometryId >= active.length || active[geometryId] === false) {\n        return this;\n      }\n      active[geometryId] = false;\n      _zeroScaleMatrix.toArray(matricesArray, geometryId * 16);\n      matricesTexture.needsUpdate = true;\n      return this;\n    }\n  }, {\n    key: \"optimize\",\n    value: function optimize() {\n      throw new Error(\"BatchedMesh: Optimize function not implemented.\");\n    }\n  }, {\n    key: \"setMatrixAt\",\n    value: function setMatrixAt(geometryId, matrix) {\n      var visible = this._visible;\n      var active = this._active;\n      var matricesTexture = this._matricesTexture;\n      var matrices = this._matrices;\n      var matricesArray = matricesTexture.image.data;\n      if (geometryId >= matrices.length || active[geometryId] === false) {\n        return this;\n      }\n      if (visible[geometryId] === true) {\n        matrix.toArray(matricesArray, geometryId * 16);\n        matricesTexture.needsUpdate = true;\n      }\n      matrices[geometryId].copy(matrix);\n      return this;\n    }\n  }, {\n    key: \"getMatrixAt\",\n    value: function getMatrixAt(geometryId, matrix) {\n      var matrices = this._matrices;\n      var active = this._active;\n      if (geometryId >= matrices.length || active[geometryId] === false) {\n        return matrix;\n      }\n      return matrix.copy(matrices[geometryId]);\n    }\n  }, {\n    key: \"setVisibleAt\",\n    value: function setVisibleAt(geometryId, value) {\n      var visible = this._visible;\n      var active = this._active;\n      var matricesTexture = this._matricesTexture;\n      var matrices = this._matrices;\n      var matricesArray = matricesTexture.image.data;\n      if (geometryId >= visible.length || active[geometryId] === false || visible[geometryId] === value) {\n        return this;\n      }\n      if (value === true) {\n        matrices[geometryId].toArray(matricesArray, geometryId * 16);\n      } else {\n        _zeroScaleMatrix.toArray(matricesArray, geometryId * 16);\n      }\n      matricesTexture.needsUpdate = true;\n      visible[geometryId] = value;\n      return this;\n    }\n  }, {\n    key: \"getVisibleAt\",\n    value: function getVisibleAt(geometryId) {\n      var visible = this._visible;\n      var active = this._active;\n      if (geometryId >= visible.length || active[geometryId] === false) {\n        return false;\n      }\n      return visible[geometryId];\n    }\n  }, {\n    key: \"raycast\",\n    value: function raycast() {\n      console.warn(\"BatchedMesh: Raycast function not implemented.\");\n    }\n  }, {\n    key: \"copy\",\n    value: function copy() {\n      throw new Error(\"BatchedMesh: Copy function not implemented.\");\n    }\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      throw new Error(\"BatchedMesh: toJSON function not implemented.\");\n    }\n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      this.geometry.dispose();\n      this._matricesTexture.dispose();\n      this._matricesTexture = null;\n      return this;\n    }\n  }]);\n  return BatchedMesh;\n}(Mesh);\nexport { BatchedMesh };","map":{"version":3,"names":["ID_ATTR_NAME","_identityMatrix","Matrix4","_zeroScaleMatrix","set","batchingParsVertex","concat","batchingbaseVertex","batchingnormalVertex","batchingVertex","copyAttributeData","src","target","targetOffset","arguments","length","undefined","itemSize","isInterleavedBufferAttribute","array","constructor","vertexCount","count","i","c","setComponent","getComponent","needsUpdate","BatchedMesh","_Mesh","_inherits","_super","_createSuper","maxGeometryCount","maxVertexCount","_this","maxIndexCount","material","_classCallCheck","call","BufferGeometry","__publicField","_assertThisInitialized","_vertexStarts","_vertexCounts","_indexStarts","_indexCounts","_reservedRanges","_visible","_active","_maxGeometryCount","_maxVertexCount","_maxIndexCount","_geometryInitialized","_geometryCount","_matrices","_matricesTexture","frustumCulled","_customUniforms","batchingTexture","value","_initMatricesTexture","_initShader","onBeforeRender","defines","BATCHING","onAfterRender","_createClass","key","size","Math","sqrt","MathUtils","ceilPowerOfTwo","max","matricesArray","Float32Array","matricesTexture","DataTexture","RGBAFormat","FloatType","currentOnBeforeCompile","onBeforeCompile","customUniforms","parameters","renderer","vertexShader","replace","uniformName","uniforms","_initializeGeometry","reference","geometry","attributeName","attributes","srcAttribute","getAttribute","normalized","dstArray","dstAttribute","setUsage","usage","setAttribute","getIndex","indexArray","Uint32Array","Uint16Array","setIndex","BufferAttribute","idArray","_validateGeometry","Error","batchGeometry","Boolean","hasAttribute","getGeometryCount","getVertexCount","reservedRanges","finalRange","vertexStart","getIndexCount","indexStart","indexCount","addGeometry","range","lastRange","indexCounts","indexStarts","vertexCounts","vertexStarts","visible","active","matrices","image","data","push","geometryId","toArray","idAttribute","setX","setGeometryAt","applyGeometry","id","position","srcPositionAttribute","hasIndex","dstIndex","srcIndex","l","index","getX","deleteGeometry","optimize","setMatrixAt","matrix","copy","getMatrixAt","setVisibleAt","getVisibleAt","raycast","console","warn","toJSON","dispose","Mesh"],"sources":["C:\\Users\\Nayyu\\Desktop\\skibidai-public-build\\node_modules\\src\\objects\\BatchedMesh.ts"],"sourcesContent":["import {\n  Matrix4,\n  BufferAttribute,\n  InterleavedBufferAttribute,\n  Mesh,\n  BufferGeometry,\n  Material,\n  DataTexture,\n  IUniform,\n  MathUtils,\n  RGBAFormat,\n  FloatType,\n} from 'three'\n\nconst ID_ATTR_NAME = '_batch_id_'\nconst _identityMatrix = new Matrix4()\nconst _zeroScaleMatrix = new Matrix4().set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1)\n\n// Custom shaders\nconst batchingParsVertex = /* glsl */ `\n#ifdef BATCHING\n\tattribute float ${ID_ATTR_NAME};\n\tuniform highp sampler2D batchingTexture;\n\tmat4 getBatchingMatrix( const in float i ) {\n\n\t\tint size = textureSize( batchingTexture, 0 ).x;\n\t\tint j = int( i ) * 4;\n\t\tint x = j % size;\n\t\tint y = j / size;\n\t\tvec4 v1 = texelFetch( batchingTexture, ivec2( x, y ), 0 );\n\t\tvec4 v2 = texelFetch( batchingTexture, ivec2( x + 1, y ), 0 );\n\t\tvec4 v3 = texelFetch( batchingTexture, ivec2( x + 2, y ), 0 );\n\t\tvec4 v4 = texelFetch( batchingTexture, ivec2( x + 3, y ), 0 );\n\t\treturn mat4( v1, v2, v3, v4 );\n\n\t}\n#endif\n`\n\nconst batchingbaseVertex = /* glsl */ `\n#ifdef BATCHING\n\tmat4 batchingMatrix = getBatchingMatrix( ${ID_ATTR_NAME} );\n#endif\n`\n\nconst batchingnormalVertex = /* glsl */ `\n#ifdef BATCHING\n\tobjectNormal = vec4( batchingMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( batchingMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif\n`\n\nconst batchingVertex = /* glsl */ `\n#ifdef BATCHING\n\ttransformed = ( batchingMatrix * vec4( transformed, 1.0 ) ).xyz;\n#endif\n`\n\n// @TODO: SkinnedMesh support?\n// @TODO: Future work if needed. Move into the core. Can be optimized more with WEBGL_multi_draw.\n\n// copies data from attribute \"src\" into \"target\" starting at \"targetOffset\"\nfunction copyAttributeData(\n  src: BufferAttribute | InterleavedBufferAttribute,\n  target: BufferAttribute | InterleavedBufferAttribute,\n  targetOffset = 0,\n): void {\n  const itemSize = target.itemSize\n  if (\n    (src as InterleavedBufferAttribute).isInterleavedBufferAttribute ||\n    src.array.constructor !== target.array.constructor\n  ) {\n    // use the component getters and setters if the array data cannot\n    // be copied directly\n    const vertexCount = src.count\n    for (let i = 0; i < vertexCount; i++) {\n      for (let c = 0; c < itemSize; c++) {\n        // @ts-ignore\n        target.setComponent(i + targetOffset, c, src.getComponent(i, c))\n      }\n    }\n  } else {\n    // faster copy approach using typed array set function\n    // @ts-ignore\n    target.array.set(src.array, targetOffset * itemSize)\n  }\n\n  target.needsUpdate = true\n}\n\nclass BatchedMesh extends Mesh<BufferGeometry, Material> {\n  _vertexStarts: number[]\n  _vertexCounts: number[]\n  _indexStarts: number[]\n  _indexCounts: number[]\n  _reservedRanges: { vertexStart: number; vertexCount: number; indexStart: number; indexCount: number }[]\n  _visible: boolean[]\n  _active: boolean[]\n  _maxGeometryCount: number\n  _maxVertexCount: number\n  _maxIndexCount: number\n  _geometryInitialized: boolean\n  _geometryCount: number\n  _matrices: Matrix4[]\n  _matricesTexture: DataTexture | null\n  _customUniforms: Record<string, IUniform>\n\n  constructor(\n    maxGeometryCount: number,\n    maxVertexCount: number,\n    maxIndexCount = maxVertexCount * 2,\n    material?: Material,\n  ) {\n    super(new BufferGeometry(), material)\n\n    this._vertexStarts = []\n    this._vertexCounts = []\n    this._indexStarts = []\n    this._indexCounts = []\n    this._reservedRanges = []\n\n    this._visible = []\n    this._active = []\n\n    this._maxGeometryCount = maxGeometryCount\n    this._maxVertexCount = maxVertexCount\n    this._maxIndexCount = maxIndexCount\n\n    this._geometryInitialized = false\n    this._geometryCount = 0\n\n    // Local matrix per geometry by using data texture\n    // @TODO: Support uniform parameter per geometry\n\n    this._matrices = []\n    this._matricesTexture = null!\n\n    // @TODO: Calculate the entire binding box and make frustumCulled true\n    this.frustumCulled = false\n\n    this._customUniforms = {\n      batchingTexture: { value: null },\n    }\n\n    this._initMatricesTexture()\n    this._initShader()\n\n    this.onBeforeRender = function () {\n      if (this.material.defines) {\n        this.material.defines.BATCHING = true\n      }\n\n      // @TODO: Implement frustum culling for each geometry\n    }\n\n    this.onAfterRender = function () {\n      if (this.material.defines) {\n        this.material.defines.BATCHING = false\n      }\n    }\n  }\n\n  _initMatricesTexture(): void {\n    // layout (1 matrix = 4 pixels)\n    //      RGBA RGBA RGBA RGBA (=> column1, column2, column3, column4)\n    //  with  8x8  pixel texture max   16 matrices * 4 pixels =  (8 * 8)\n    //       16x16 pixel texture max   64 matrices * 4 pixels = (16 * 16)\n    //       32x32 pixel texture max  256 matrices * 4 pixels = (32 * 32)\n    //       64x64 pixel texture max 1024 matrices * 4 pixels = (64 * 64)\n\n    let size = Math.sqrt(this._maxGeometryCount * 4) // 4 pixels needed for 1 matrix\n    size = MathUtils.ceilPowerOfTwo(size)\n    size = Math.max(size, 4)\n\n    const matricesArray = new Float32Array(size * size * 4) // 4 floats per RGBA pixel\n    const matricesTexture = new DataTexture(matricesArray, size, size, RGBAFormat, FloatType)\n\n    this._matricesTexture = matricesTexture\n    this._customUniforms.batchingTexture.value = this._matricesTexture\n  }\n\n  _initShader(): void {\n    const material = this.material\n    const currentOnBeforeCompile = material.onBeforeCompile\n    const customUniforms = this._customUniforms\n\n    material.onBeforeCompile = function onBeforeCompile(parameters, renderer) {\n      // Is this replacement stable across any materials?\n      parameters.vertexShader = parameters.vertexShader\n        .replace('#include <skinning_pars_vertex>', '#include <skinning_pars_vertex>\\n' + batchingParsVertex)\n        .replace('#include <uv_vertex>', '#include <uv_vertex>\\n' + batchingbaseVertex)\n        .replace('#include <skinnormal_vertex>', '#include <skinnormal_vertex>\\n' + batchingnormalVertex)\n        .replace('#include <skinning_vertex>', '#include <skinning_vertex>\\n' + batchingVertex)\n\n      for (const uniformName in customUniforms) {\n        parameters.uniforms[uniformName] = customUniforms[uniformName]\n      }\n\n      currentOnBeforeCompile.call(this, parameters, renderer)\n    }\n\n    material.defines = material.defines || {}\n    material.defines.BATCHING = false\n  }\n\n  _initializeGeometry(reference: BufferGeometry): void {\n    // @TODO: geometry.groups support?\n    // @TODO: geometry.drawRange support?\n    // @TODO: geometry.morphAttributes support?\n\n    const geometry = this.geometry\n    const maxVertexCount = this._maxVertexCount\n    const maxGeometryCount = this._maxGeometryCount\n    const maxIndexCount = this._maxIndexCount\n    if (this._geometryInitialized === false) {\n      for (const attributeName in reference.attributes) {\n        const srcAttribute = reference.getAttribute(attributeName)\n        const { array, itemSize, normalized } = srcAttribute\n\n        const dstArray = new (array.constructor as Float32ArrayConstructor)(maxVertexCount * itemSize)\n        const dstAttribute = new (srcAttribute.constructor as any)(dstArray, itemSize, normalized)\n\n        // TODO: add usage in @types/three\n        // @ts-ignore\n        dstAttribute.setUsage(srcAttribute.usage)\n\n        geometry.setAttribute(attributeName, dstAttribute)\n      }\n\n      if (reference.getIndex() !== null) {\n        const indexArray = maxVertexCount > 65536 ? new Uint32Array(maxIndexCount) : new Uint16Array(maxIndexCount)\n\n        geometry.setIndex(new BufferAttribute(indexArray, 1))\n      }\n\n      const idArray = maxGeometryCount > 65536 ? new Uint32Array(maxVertexCount) : new Uint16Array(maxVertexCount)\n      geometry.setAttribute(ID_ATTR_NAME, new BufferAttribute(idArray, 1))\n\n      this._geometryInitialized = true\n    }\n  }\n\n  // Make sure the geometry is compatible with the existing combined geometry atributes\n  _validateGeometry(geometry: BufferGeometry): void {\n    // check that the geometry doesn't have a version of our reserved id attribute\n    if (geometry.getAttribute(ID_ATTR_NAME)) {\n      throw new Error(`BatchedMesh: Geometry cannot use attribute \"${ID_ATTR_NAME}\"`)\n    }\n\n    // check to ensure the geometries are using consistent attributes and indices\n    const batchGeometry = this.geometry\n    if (Boolean(geometry.getIndex()) !== Boolean(batchGeometry.getIndex())) {\n      throw new Error('BatchedMesh: All geometries must consistently have \"index\".')\n    }\n\n    for (const attributeName in batchGeometry.attributes) {\n      if (attributeName === ID_ATTR_NAME) {\n        continue\n      }\n\n      if (!geometry.hasAttribute(attributeName)) {\n        throw new Error(\n          `BatchedMesh: Added geometry missing \"${attributeName}\". All geometries must have consistent attributes.`,\n        )\n      }\n\n      const srcAttribute = geometry.getAttribute(attributeName)\n      const dstAttribute = batchGeometry.getAttribute(attributeName)\n      if (srcAttribute.itemSize !== dstAttribute.itemSize || srcAttribute.normalized !== dstAttribute.normalized) {\n        throw new Error('BatchedMesh: All attributes must have a consistent itemSize and normalized value.')\n      }\n    }\n  }\n\n  getGeometryCount(): number {\n    return this._geometryCount\n  }\n\n  getVertexCount(): number {\n    const reservedRanges = this._reservedRanges\n    if (reservedRanges.length === 0) {\n      return 0\n    } else {\n      const finalRange = reservedRanges[reservedRanges.length - 1]\n      return finalRange.vertexStart + finalRange.vertexCount\n    }\n  }\n\n  getIndexCount(): number {\n    const reservedRanges = this._reservedRanges\n    const geometry = this.geometry\n    if (geometry.getIndex() === null || reservedRanges.length === 0) {\n      return 0\n    } else {\n      const finalRange = reservedRanges[reservedRanges.length - 1]\n      return finalRange.indexStart + finalRange.indexCount\n    }\n  }\n\n  addGeometry(geometry: BufferGeometry, vertexCount = -1, indexCount = -1): number {\n    this._initializeGeometry(geometry)\n\n    this._validateGeometry(geometry)\n\n    // ensure we're not over geometry\n    if (this._geometryCount >= this._maxGeometryCount) {\n      throw new Error('BatchedMesh: Maximum geometry count reached.')\n    }\n\n    // get the necessary range fo the geometry\n    const range = {\n      vertexStart: -1,\n      vertexCount: -1,\n      indexStart: -1,\n      indexCount: -1,\n    }\n\n    let lastRange = null\n    const reservedRanges = this._reservedRanges\n    if (this._geometryCount !== 0) {\n      lastRange = reservedRanges[reservedRanges.length - 1]\n    }\n\n    if (vertexCount === -1) {\n      range.vertexCount = geometry.getAttribute('position').count\n    } else {\n      range.vertexCount = vertexCount\n    }\n\n    if (lastRange === null) {\n      range.vertexStart = 0\n    } else {\n      range.vertexStart = lastRange.vertexStart + lastRange.vertexCount\n    }\n\n    if (geometry.getIndex() !== null) {\n      if (indexCount === -1) {\n        range.indexCount = geometry.getIndex()!.count\n      } else {\n        range.indexCount = indexCount\n      }\n\n      if (lastRange === null) {\n        range.indexStart = 0\n      } else {\n        range.indexStart = lastRange.indexStart + lastRange.indexCount\n      }\n    }\n\n    if (\n      (range.indexStart !== -1 && range.indexStart + range.indexCount > this._maxIndexCount) ||\n      range.vertexStart + range.vertexCount > this._maxVertexCount\n    ) {\n      throw new Error('BatchedMesh: Reserved space request exceeds the maximum buffer size.')\n    }\n\n    const indexCounts = this._indexCounts\n    const indexStarts = this._indexStarts\n    const vertexCounts = this._vertexCounts\n    const vertexStarts = this._vertexStarts\n\n    const visible = this._visible\n    const active = this._active\n    const matricesTexture = this._matricesTexture\n    const matrices = this._matrices\n    const matricesArray = this._matricesTexture!.image.data\n\n    // push new visibility states\n    visible.push(true)\n    active.push(true)\n\n    // update id\n    const geometryId = this._geometryCount\n    this._geometryCount++\n\n    // initialize matrix information\n    matrices.push(new Matrix4())\n    _identityMatrix.toArray(matricesArray, geometryId * 16)\n    matricesTexture!.needsUpdate = true\n\n    // add the reserved range\n    reservedRanges.push(range)\n\n    // push new geometry data range\n    vertexStarts.push(range.vertexStart)\n    vertexCounts.push(range.vertexCount)\n\n    if (geometry.getIndex() !== null) {\n      // push new index range\n      indexStarts.push(range.indexCount)\n      indexCounts.push(range.indexCount)\n    }\n\n    // set the id for the geometry\n    const idAttribute = this.geometry.getAttribute(ID_ATTR_NAME)\n    for (let i = 0; i < range.vertexCount; i++) {\n      idAttribute.setX(range.vertexStart + i, geometryId)\n    }\n\n    idAttribute.needsUpdate = true\n\n    // update the geometry\n    this.setGeometryAt(geometryId, geometry)\n\n    return geometryId\n  }\n\n  /**\n   * @deprecated use `addGeometry` instead.\n   */\n  applyGeometry(geometry: BufferGeometry): number {\n    return this.addGeometry(geometry)\n  }\n\n  setGeometryAt(id: number, geometry: BufferGeometry): number {\n    if (id >= this._geometryCount) {\n      throw new Error('BatchedMesh: Maximum geometry count reached.')\n    }\n\n    this._validateGeometry(geometry)\n\n    const range = this._reservedRanges[id]\n    if (\n      (geometry.getIndex() !== null && geometry.getIndex()!.count > range.indexCount) ||\n      geometry.attributes.position.count > range.vertexCount\n    ) {\n      throw new Error('BatchedMesh: Reserved space not large enough for provided geometry.')\n    }\n\n    // copy geometry over\n    const batchGeometry = this.geometry\n    const srcPositionAttribute = geometry.getAttribute('position')\n    const hasIndex = batchGeometry.getIndex() !== null\n    const dstIndex = batchGeometry.getIndex()!\n    const srcIndex = geometry.getIndex()!\n\n    // copy attribute data over\n    const vertexStart = range.vertexStart\n    const vertexCount = range.vertexCount\n    for (const attributeName in batchGeometry.attributes) {\n      if (attributeName === ID_ATTR_NAME) {\n        continue\n      }\n\n      const srcAttribute = geometry.getAttribute(attributeName)\n      const dstAttribute = batchGeometry.getAttribute(attributeName)\n      copyAttributeData(srcAttribute, dstAttribute, vertexStart)\n\n      // fill the rest in with zeroes\n      const itemSize = srcAttribute.itemSize\n      for (let i = srcAttribute.count, l = vertexCount; i < l; i++) {\n        const index = vertexStart + i\n        for (let c = 0; c < itemSize; c++) {\n          // @ts-ignore\n          dstAttribute.setComponent(index, c, 0)\n        }\n      }\n\n      dstAttribute.needsUpdate = true\n    }\n\n    this._vertexCounts[id] = srcPositionAttribute.count\n\n    if (hasIndex) {\n      // fill the rest in with zeroes\n      const indexStart = range.indexStart\n\n      // copy index data over\n      for (let i = 0; i < srcIndex.count; i++) {\n        dstIndex.setX(indexStart + i, vertexStart + srcIndex.getX(i))\n      }\n\n      // fill the rest in with zeroes\n      for (let i = srcIndex.count, l = range.indexCount; i < l; i++) {\n        dstIndex.setX(indexStart + i, vertexStart)\n      }\n\n      dstIndex.needsUpdate = true\n      this._indexCounts[id] = srcIndex.count\n    }\n\n    return id\n  }\n\n  deleteGeometry(geometryId: number): this {\n    // Note: User needs to call optimize() afterward to pack the data.\n\n    const active = this._active\n    const matricesTexture = this._matricesTexture!\n    const matricesArray = matricesTexture.image.data\n    if (geometryId >= active.length || active[geometryId] === false) {\n      return this\n    }\n\n    active[geometryId] = false\n    _zeroScaleMatrix.toArray(matricesArray, geometryId * 16)\n    matricesTexture!.needsUpdate = true\n\n    return this\n  }\n\n  optimize(): never {\n    throw new Error('BatchedMesh: Optimize function not implemented.')\n  }\n\n  setMatrixAt(geometryId: number, matrix: Matrix4): this {\n    // @TODO: Map geometryId to index of the arrays because\n    //        optimize() can make geometryId mismatch the index\n\n    const visible = this._visible\n    const active = this._active\n    const matricesTexture = this._matricesTexture!\n    const matrices = this._matrices\n    const matricesArray = matricesTexture.image.data\n    if (geometryId >= matrices.length || active[geometryId] === false) {\n      return this\n    }\n\n    if (visible[geometryId] === true) {\n      matrix.toArray(matricesArray, geometryId * 16)\n      matricesTexture.needsUpdate = true\n    }\n\n    matrices[geometryId].copy(matrix)\n\n    return this\n  }\n\n  getMatrixAt(geometryId: number, matrix: Matrix4): Matrix4 {\n    const matrices = this._matrices\n    const active = this._active\n    if (geometryId >= matrices.length || active[geometryId] === false) {\n      return matrix\n    }\n\n    return matrix.copy(matrices[geometryId])\n  }\n\n  setVisibleAt(geometryId: number, value: boolean): this {\n    const visible = this._visible\n    const active = this._active\n    const matricesTexture = this._matricesTexture!\n    const matrices = this._matrices\n    const matricesArray = matricesTexture.image.data\n\n    // if the geometry is out of range, not active, or visibility state\n    // does not change then return early\n    if (geometryId >= visible.length || active[geometryId] === false || visible[geometryId] === value) {\n      return this\n    }\n\n    // scale the matrix to zero if it's hidden\n    if (value === true) {\n      matrices[geometryId].toArray(matricesArray, geometryId * 16)\n    } else {\n      _zeroScaleMatrix.toArray(matricesArray, geometryId * 16)\n    }\n\n    matricesTexture.needsUpdate = true\n    visible[geometryId] = value\n\n    return this\n  }\n\n  getVisibleAt(geometryId: number): boolean {\n    const visible = this._visible\n    const active = this._active\n\n    // return early if the geometry is out of range or not active\n    if (geometryId >= visible.length || active[geometryId] === false) {\n      return false\n    }\n\n    return visible[geometryId]\n  }\n\n  raycast(): void {\n    console.warn('BatchedMesh: Raycast function not implemented.')\n  }\n\n  copy(): never {\n    // super.copy( source );\n\n    throw new Error('BatchedMesh: Copy function not implemented.')\n  }\n\n  toJSON(): never {\n    throw new Error('BatchedMesh: toJSON function not implemented.')\n  }\n\n  dispose(): this {\n    // Assuming the geometry is not shared with other meshes\n    this.geometry.dispose()\n\n    this._matricesTexture!.dispose()\n    this._matricesTexture = null!\n\n    return this\n  }\n}\n\nexport { BatchedMesh }\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}