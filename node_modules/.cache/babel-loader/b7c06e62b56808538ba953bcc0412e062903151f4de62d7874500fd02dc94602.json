{"ast":null,"code":"import _classCallCheck from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _inherits from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport { Loader, FileLoader, BufferGeometry, Float32BufferAttribute, PointsMaterial, Points } from \"three\";\nimport { decodeText } from \"../_polyfill/LoaderUtils.js\";\nvar PCDLoader = /*#__PURE__*/function (_Loader) {\n  _inherits(PCDLoader, _Loader);\n  var _super = _createSuper(PCDLoader);\n  function PCDLoader(manager) {\n    var _this;\n    _classCallCheck(this, PCDLoader);\n    _this = _super.call(this, manager);\n    _this.littleEndian = true;\n    return _this;\n  }\n  _createClass(PCDLoader, [{\n    key: \"load\",\n    value: function load(url, onLoad, onProgress, onError) {\n      var scope = this;\n      var loader = new FileLoader(scope.manager);\n      loader.setPath(scope.path);\n      loader.setResponseType(\"arraybuffer\");\n      loader.setRequestHeader(scope.requestHeader);\n      loader.setWithCredentials(scope.withCredentials);\n      loader.load(url, function (data) {\n        try {\n          onLoad(scope.parse(data, url));\n        } catch (e) {\n          if (onError) {\n            onError(e);\n          } else {\n            console.error(e);\n          }\n          scope.manager.itemError(url);\n        }\n      }, onProgress, onError);\n    }\n  }, {\n    key: \"parse\",\n    value: function parse(data, url) {\n      function decompressLZF(inData, outLength) {\n        var inLength = inData.length;\n        var outData = new Uint8Array(outLength);\n        var inPtr = 0;\n        var outPtr = 0;\n        var ctrl;\n        var len;\n        var ref;\n        do {\n          ctrl = inData[inPtr++];\n          if (ctrl < 1 << 5) {\n            ctrl++;\n            if (outPtr + ctrl > outLength) throw new Error(\"Output buffer is not large enough\");\n            if (inPtr + ctrl > inLength) throw new Error(\"Invalid compressed data\");\n            do {\n              outData[outPtr++] = inData[inPtr++];\n            } while (--ctrl);\n          } else {\n            len = ctrl >> 5;\n            ref = outPtr - ((ctrl & 31) << 8) - 1;\n            if (inPtr >= inLength) throw new Error(\"Invalid compressed data\");\n            if (len === 7) {\n              len += inData[inPtr++];\n              if (inPtr >= inLength) throw new Error(\"Invalid compressed data\");\n            }\n            ref -= inData[inPtr++];\n            if (outPtr + len + 2 > outLength) throw new Error(\"Output buffer is not large enough\");\n            if (ref < 0) throw new Error(\"Invalid compressed data\");\n            if (ref >= outPtr) throw new Error(\"Invalid compressed data\");\n            do {\n              outData[outPtr++] = outData[ref++];\n            } while (--len + 2);\n          }\n        } while (inPtr < inLength);\n        return outData;\n      }\n      function parseHeader(data2) {\n        var PCDheader2 = {};\n        var result1 = data2.search(/[\\r\\n]DATA\\s(\\S*)\\s/i);\n        var result2 = /[\\r\\n]DATA\\s(\\S*)\\s/i.exec(data2.substr(result1 - 1));\n        PCDheader2.data = result2[1];\n        PCDheader2.headerLen = result2[0].length + result1;\n        PCDheader2.str = data2.substr(0, PCDheader2.headerLen);\n        PCDheader2.str = PCDheader2.str.replace(/\\#.*/gi, \"\");\n        PCDheader2.version = /VERSION (.*)/i.exec(PCDheader2.str);\n        PCDheader2.fields = /FIELDS (.*)/i.exec(PCDheader2.str);\n        PCDheader2.size = /SIZE (.*)/i.exec(PCDheader2.str);\n        PCDheader2.type = /TYPE (.*)/i.exec(PCDheader2.str);\n        PCDheader2.count = /COUNT (.*)/i.exec(PCDheader2.str);\n        PCDheader2.width = /WIDTH (.*)/i.exec(PCDheader2.str);\n        PCDheader2.height = /HEIGHT (.*)/i.exec(PCDheader2.str);\n        PCDheader2.viewpoint = /VIEWPOINT (.*)/i.exec(PCDheader2.str);\n        PCDheader2.points = /POINTS (.*)/i.exec(PCDheader2.str);\n        if (PCDheader2.version !== null) PCDheader2.version = parseFloat(PCDheader2.version[1]);\n        if (PCDheader2.fields !== null) PCDheader2.fields = PCDheader2.fields[1].split(\" \");\n        if (PCDheader2.type !== null) PCDheader2.type = PCDheader2.type[1].split(\" \");\n        if (PCDheader2.width !== null) PCDheader2.width = parseInt(PCDheader2.width[1]);\n        if (PCDheader2.height !== null) PCDheader2.height = parseInt(PCDheader2.height[1]);\n        if (PCDheader2.viewpoint !== null) PCDheader2.viewpoint = PCDheader2.viewpoint[1];\n        if (PCDheader2.points !== null) PCDheader2.points = parseInt(PCDheader2.points[1], 10);\n        if (PCDheader2.points === null) PCDheader2.points = PCDheader2.width * PCDheader2.height;\n        if (PCDheader2.size !== null) {\n          PCDheader2.size = PCDheader2.size[1].split(\" \").map(function (x) {\n            return parseInt(x, 10);\n          });\n        }\n        if (PCDheader2.count !== null) {\n          PCDheader2.count = PCDheader2.count[1].split(\" \").map(function (x) {\n            return parseInt(x, 10);\n          });\n        } else {\n          PCDheader2.count = [];\n          for (var i = 0, l = PCDheader2.fields.length; i < l; i++) {\n            PCDheader2.count.push(1);\n          }\n        }\n        PCDheader2.offset = {};\n        var sizeSum = 0;\n        for (var _i = 0, _l = PCDheader2.fields.length; _i < _l; _i++) {\n          if (PCDheader2.data === \"ascii\") {\n            PCDheader2.offset[PCDheader2.fields[_i]] = _i;\n          } else {\n            PCDheader2.offset[PCDheader2.fields[_i]] = sizeSum;\n            sizeSum += PCDheader2.size[_i] * PCDheader2.count[_i];\n          }\n        }\n        PCDheader2.rowSize = sizeSum;\n        return PCDheader2;\n      }\n      var textData = decodeText(new Uint8Array(data));\n      var PCDheader = parseHeader(textData);\n      var position = [];\n      var normal = [];\n      var color = [];\n      if (PCDheader.data === \"ascii\") {\n        var offset = PCDheader.offset;\n        var pcdData = textData.substr(PCDheader.headerLen);\n        var lines = pcdData.split(\"\\n\");\n        for (var i = 0, l = lines.length; i < l; i++) {\n          if (lines[i] === \"\") continue;\n          var line = lines[i].split(\" \");\n          if (offset.x !== void 0) {\n            position.push(parseFloat(line[offset.x]));\n            position.push(parseFloat(line[offset.y]));\n            position.push(parseFloat(line[offset.z]));\n          }\n          if (offset.rgb !== void 0) {\n            var rgb = parseFloat(line[offset.rgb]);\n            var r = rgb >> 16 & 255;\n            var g = rgb >> 8 & 255;\n            var b = rgb >> 0 & 255;\n            color.push(r / 255, g / 255, b / 255);\n          }\n          if (offset.normal_x !== void 0) {\n            normal.push(parseFloat(line[offset.normal_x]));\n            normal.push(parseFloat(line[offset.normal_y]));\n            normal.push(parseFloat(line[offset.normal_z]));\n          }\n        }\n      }\n      if (PCDheader.data === \"binary_compressed\") {\n        var sizes = new Uint32Array(data.slice(PCDheader.headerLen, PCDheader.headerLen + 8));\n        var compressedSize = sizes[0];\n        var decompressedSize = sizes[1];\n        var decompressed = decompressLZF(new Uint8Array(data, PCDheader.headerLen + 8, compressedSize), decompressedSize);\n        var dataview = new DataView(decompressed.buffer);\n        var _offset = PCDheader.offset;\n        for (var _i2 = 0; _i2 < PCDheader.points; _i2++) {\n          if (_offset.x !== void 0) {\n            position.push(dataview.getFloat32(PCDheader.points * _offset.x + PCDheader.size[0] * _i2, this.littleEndian));\n            position.push(dataview.getFloat32(PCDheader.points * _offset.y + PCDheader.size[1] * _i2, this.littleEndian));\n            position.push(dataview.getFloat32(PCDheader.points * _offset.z + PCDheader.size[2] * _i2, this.littleEndian));\n          }\n          if (_offset.rgb !== void 0) {\n            color.push(dataview.getUint8(PCDheader.points * _offset.rgb + PCDheader.size[3] * _i2 + 2) / 255);\n            color.push(dataview.getUint8(PCDheader.points * _offset.rgb + PCDheader.size[3] * _i2 + 1) / 255);\n            color.push(dataview.getUint8(PCDheader.points * _offset.rgb + PCDheader.size[3] * _i2 + 0) / 255);\n          }\n          if (_offset.normal_x !== void 0) {\n            normal.push(dataview.getFloat32(PCDheader.points * _offset.normal_x + PCDheader.size[4] * _i2, this.littleEndian));\n            normal.push(dataview.getFloat32(PCDheader.points * _offset.normal_y + PCDheader.size[5] * _i2, this.littleEndian));\n            normal.push(dataview.getFloat32(PCDheader.points * _offset.normal_z + PCDheader.size[6] * _i2, this.littleEndian));\n          }\n        }\n      }\n      if (PCDheader.data === \"binary\") {\n        var _dataview = new DataView(data, PCDheader.headerLen);\n        var _offset2 = PCDheader.offset;\n        for (var _i3 = 0, row = 0; _i3 < PCDheader.points; _i3++, row += PCDheader.rowSize) {\n          if (_offset2.x !== void 0) {\n            position.push(_dataview.getFloat32(row + _offset2.x, this.littleEndian));\n            position.push(_dataview.getFloat32(row + _offset2.y, this.littleEndian));\n            position.push(_dataview.getFloat32(row + _offset2.z, this.littleEndian));\n          }\n          if (_offset2.rgb !== void 0) {\n            color.push(_dataview.getUint8(row + _offset2.rgb + 2) / 255);\n            color.push(_dataview.getUint8(row + _offset2.rgb + 1) / 255);\n            color.push(_dataview.getUint8(row + _offset2.rgb + 0) / 255);\n          }\n          if (_offset2.normal_x !== void 0) {\n            normal.push(_dataview.getFloat32(row + _offset2.normal_x, this.littleEndian));\n            normal.push(_dataview.getFloat32(row + _offset2.normal_y, this.littleEndian));\n            normal.push(_dataview.getFloat32(row + _offset2.normal_z, this.littleEndian));\n          }\n        }\n      }\n      var geometry = new BufferGeometry();\n      if (position.length > 0) geometry.setAttribute(\"position\", new Float32BufferAttribute(position, 3));\n      if (normal.length > 0) geometry.setAttribute(\"normal\", new Float32BufferAttribute(normal, 3));\n      if (color.length > 0) geometry.setAttribute(\"color\", new Float32BufferAttribute(color, 3));\n      geometry.computeBoundingSphere();\n      var material = new PointsMaterial({\n        size: 5e-3\n      });\n      if (color.length > 0) {\n        material.vertexColors = true;\n      } else {\n        material.color.setHex(Math.random() * 16777215);\n      }\n      var mesh = new Points(geometry, material);\n      var name = url.split(\"\").reverse().join(\"\");\n      name = /([^\\/]*)/.exec(name);\n      name = name[1].split(\"\").reverse().join(\"\");\n      mesh.name = name;\n      return mesh;\n    }\n  }]);\n  return PCDLoader;\n}(Loader);\nexport { PCDLoader };","map":{"version":3,"names":["PCDLoader","_Loader","_inherits","_super","_createSuper","manager","_this","_classCallCheck","call","littleEndian","_createClass","key","value","load","url","onLoad","onProgress","onError","scope","loader","FileLoader","setPath","path","setResponseType","setRequestHeader","requestHeader","setWithCredentials","withCredentials","data","parse","e","console","error","itemError","decompressLZF","inData","outLength","inLength","length","outData","Uint8Array","inPtr","outPtr","ctrl","len","ref","Error","parseHeader","data2","PCDheader2","result1","search","result2","exec","substr","headerLen","str","replace","version","fields","size","type","count","width","height","viewpoint","points","parseFloat","split","parseInt","map","x","i","l","push","offset","sizeSum","rowSize","textData","decodeText","PCDheader","position","normal","color","pcdData","lines","line","y","z","rgb","r","g","b","normal_x","normal_y","normal_z","sizes","Uint32Array","slice","compressedSize","decompressedSize","decompressed","dataview","DataView","buffer","getFloat32","getUint8","row","geometry","BufferGeometry","setAttribute","Float32BufferAttribute","computeBoundingSphere","material","PointsMaterial","vertexColors","setHex","Math","random","mesh","Points","name","reverse","join","Loader"],"sources":["C:\\Users\\Nayyu\\Desktop\\skibidai-public-build\\node_modules\\src\\loaders\\PCDLoader.js"],"sourcesContent":["import { BufferGeometry, FileLoader, Float32BufferAttribute, Loader, LoaderUtils, Points, PointsMaterial } from 'three'\nimport { decodeText } from '../_polyfill/LoaderUtils'\n\nclass PCDLoader extends Loader {\n  constructor(manager) {\n    super(manager)\n\n    this.littleEndian = true\n  }\n\n  load(url, onLoad, onProgress, onError) {\n    const scope = this\n\n    const loader = new FileLoader(scope.manager)\n    loader.setPath(scope.path)\n    loader.setResponseType('arraybuffer')\n    loader.setRequestHeader(scope.requestHeader)\n    loader.setWithCredentials(scope.withCredentials)\n    loader.load(\n      url,\n      function (data) {\n        try {\n          onLoad(scope.parse(data, url))\n        } catch (e) {\n          if (onError) {\n            onError(e)\n          } else {\n            console.error(e)\n          }\n\n          scope.manager.itemError(url)\n        }\n      },\n      onProgress,\n      onError,\n    )\n  }\n\n  parse(data, url) {\n    // from https://gitlab.com/taketwo/three-pcd-loader/blob/master/decompress-lzf.js\n\n    function decompressLZF(inData, outLength) {\n      const inLength = inData.length\n      const outData = new Uint8Array(outLength)\n      let inPtr = 0\n      let outPtr = 0\n      let ctrl\n      let len\n      let ref\n      do {\n        ctrl = inData[inPtr++]\n        if (ctrl < 1 << 5) {\n          ctrl++\n          if (outPtr + ctrl > outLength) throw new Error('Output buffer is not large enough')\n          if (inPtr + ctrl > inLength) throw new Error('Invalid compressed data')\n          do {\n            outData[outPtr++] = inData[inPtr++]\n          } while (--ctrl)\n        } else {\n          len = ctrl >> 5\n          ref = outPtr - ((ctrl & 0x1f) << 8) - 1\n          if (inPtr >= inLength) throw new Error('Invalid compressed data')\n          if (len === 7) {\n            len += inData[inPtr++]\n            if (inPtr >= inLength) throw new Error('Invalid compressed data')\n          }\n\n          ref -= inData[inPtr++]\n          if (outPtr + len + 2 > outLength) throw new Error('Output buffer is not large enough')\n          if (ref < 0) throw new Error('Invalid compressed data')\n          if (ref >= outPtr) throw new Error('Invalid compressed data')\n          do {\n            outData[outPtr++] = outData[ref++]\n          } while (--len + 2)\n        }\n      } while (inPtr < inLength)\n\n      return outData\n    }\n\n    function parseHeader(data) {\n      const PCDheader = {}\n      const result1 = data.search(/[\\r\\n]DATA\\s(\\S*)\\s/i)\n      const result2 = /[\\r\\n]DATA\\s(\\S*)\\s/i.exec(data.substr(result1 - 1))\n\n      PCDheader.data = result2[1]\n      PCDheader.headerLen = result2[0].length + result1\n      PCDheader.str = data.substr(0, PCDheader.headerLen)\n\n      // remove comments\n\n      PCDheader.str = PCDheader.str.replace(/\\#.*/gi, '')\n\n      // parse\n\n      PCDheader.version = /VERSION (.*)/i.exec(PCDheader.str)\n      PCDheader.fields = /FIELDS (.*)/i.exec(PCDheader.str)\n      PCDheader.size = /SIZE (.*)/i.exec(PCDheader.str)\n      PCDheader.type = /TYPE (.*)/i.exec(PCDheader.str)\n      PCDheader.count = /COUNT (.*)/i.exec(PCDheader.str)\n      PCDheader.width = /WIDTH (.*)/i.exec(PCDheader.str)\n      PCDheader.height = /HEIGHT (.*)/i.exec(PCDheader.str)\n      PCDheader.viewpoint = /VIEWPOINT (.*)/i.exec(PCDheader.str)\n      PCDheader.points = /POINTS (.*)/i.exec(PCDheader.str)\n\n      // evaluate\n\n      if (PCDheader.version !== null) PCDheader.version = parseFloat(PCDheader.version[1])\n\n      if (PCDheader.fields !== null) PCDheader.fields = PCDheader.fields[1].split(' ')\n\n      if (PCDheader.type !== null) PCDheader.type = PCDheader.type[1].split(' ')\n\n      if (PCDheader.width !== null) PCDheader.width = parseInt(PCDheader.width[1])\n\n      if (PCDheader.height !== null) PCDheader.height = parseInt(PCDheader.height[1])\n\n      if (PCDheader.viewpoint !== null) PCDheader.viewpoint = PCDheader.viewpoint[1]\n\n      if (PCDheader.points !== null) PCDheader.points = parseInt(PCDheader.points[1], 10)\n\n      if (PCDheader.points === null) PCDheader.points = PCDheader.width * PCDheader.height\n\n      if (PCDheader.size !== null) {\n        PCDheader.size = PCDheader.size[1].split(' ').map(function (x) {\n          return parseInt(x, 10)\n        })\n      }\n\n      if (PCDheader.count !== null) {\n        PCDheader.count = PCDheader.count[1].split(' ').map(function (x) {\n          return parseInt(x, 10)\n        })\n      } else {\n        PCDheader.count = []\n\n        for (let i = 0, l = PCDheader.fields.length; i < l; i++) {\n          PCDheader.count.push(1)\n        }\n      }\n\n      PCDheader.offset = {}\n\n      let sizeSum = 0\n\n      for (let i = 0, l = PCDheader.fields.length; i < l; i++) {\n        if (PCDheader.data === 'ascii') {\n          PCDheader.offset[PCDheader.fields[i]] = i\n        } else {\n          PCDheader.offset[PCDheader.fields[i]] = sizeSum\n          sizeSum += PCDheader.size[i] * PCDheader.count[i]\n        }\n      }\n\n      // for binary only\n\n      PCDheader.rowSize = sizeSum\n\n      return PCDheader\n    }\n\n    const textData = decodeText(new Uint8Array(data))\n\n    // parse header (always ascii format)\n\n    const PCDheader = parseHeader(textData)\n\n    // parse data\n\n    const position = []\n    const normal = []\n    const color = []\n\n    // ascii\n\n    if (PCDheader.data === 'ascii') {\n      const offset = PCDheader.offset\n      const pcdData = textData.substr(PCDheader.headerLen)\n      const lines = pcdData.split('\\n')\n\n      for (let i = 0, l = lines.length; i < l; i++) {\n        if (lines[i] === '') continue\n\n        const line = lines[i].split(' ')\n\n        if (offset.x !== undefined) {\n          position.push(parseFloat(line[offset.x]))\n          position.push(parseFloat(line[offset.y]))\n          position.push(parseFloat(line[offset.z]))\n        }\n\n        if (offset.rgb !== undefined) {\n          const rgb = parseFloat(line[offset.rgb])\n          const r = (rgb >> 16) & 0x0000ff\n          const g = (rgb >> 8) & 0x0000ff\n          const b = (rgb >> 0) & 0x0000ff\n          color.push(r / 255, g / 255, b / 255)\n        }\n\n        if (offset.normal_x !== undefined) {\n          normal.push(parseFloat(line[offset.normal_x]))\n          normal.push(parseFloat(line[offset.normal_y]))\n          normal.push(parseFloat(line[offset.normal_z]))\n        }\n      }\n    }\n\n    // binary-compressed\n\n    // normally data in PCD files are organized as array of structures: XYZRGBXYZRGB\n    // binary compressed PCD files organize their data as structure of arrays: XXYYZZRGBRGB\n    // that requires a totally different parsing approach compared to non-compressed data\n\n    if (PCDheader.data === 'binary_compressed') {\n      const sizes = new Uint32Array(data.slice(PCDheader.headerLen, PCDheader.headerLen + 8))\n      const compressedSize = sizes[0]\n      const decompressedSize = sizes[1]\n      const decompressed = decompressLZF(\n        new Uint8Array(data, PCDheader.headerLen + 8, compressedSize),\n        decompressedSize,\n      )\n      const dataview = new DataView(decompressed.buffer)\n\n      const offset = PCDheader.offset\n\n      for (let i = 0; i < PCDheader.points; i++) {\n        if (offset.x !== undefined) {\n          position.push(dataview.getFloat32(PCDheader.points * offset.x + PCDheader.size[0] * i, this.littleEndian))\n          position.push(dataview.getFloat32(PCDheader.points * offset.y + PCDheader.size[1] * i, this.littleEndian))\n          position.push(dataview.getFloat32(PCDheader.points * offset.z + PCDheader.size[2] * i, this.littleEndian))\n        }\n\n        if (offset.rgb !== undefined) {\n          color.push(dataview.getUint8(PCDheader.points * offset.rgb + PCDheader.size[3] * i + 2) / 255.0)\n          color.push(dataview.getUint8(PCDheader.points * offset.rgb + PCDheader.size[3] * i + 1) / 255.0)\n          color.push(dataview.getUint8(PCDheader.points * offset.rgb + PCDheader.size[3] * i + 0) / 255.0)\n        }\n\n        if (offset.normal_x !== undefined) {\n          normal.push(\n            dataview.getFloat32(PCDheader.points * offset.normal_x + PCDheader.size[4] * i, this.littleEndian),\n          )\n          normal.push(\n            dataview.getFloat32(PCDheader.points * offset.normal_y + PCDheader.size[5] * i, this.littleEndian),\n          )\n          normal.push(\n            dataview.getFloat32(PCDheader.points * offset.normal_z + PCDheader.size[6] * i, this.littleEndian),\n          )\n        }\n      }\n    }\n\n    // binary\n\n    if (PCDheader.data === 'binary') {\n      const dataview = new DataView(data, PCDheader.headerLen)\n      const offset = PCDheader.offset\n\n      for (let i = 0, row = 0; i < PCDheader.points; i++, row += PCDheader.rowSize) {\n        if (offset.x !== undefined) {\n          position.push(dataview.getFloat32(row + offset.x, this.littleEndian))\n          position.push(dataview.getFloat32(row + offset.y, this.littleEndian))\n          position.push(dataview.getFloat32(row + offset.z, this.littleEndian))\n        }\n\n        if (offset.rgb !== undefined) {\n          color.push(dataview.getUint8(row + offset.rgb + 2) / 255.0)\n          color.push(dataview.getUint8(row + offset.rgb + 1) / 255.0)\n          color.push(dataview.getUint8(row + offset.rgb + 0) / 255.0)\n        }\n\n        if (offset.normal_x !== undefined) {\n          normal.push(dataview.getFloat32(row + offset.normal_x, this.littleEndian))\n          normal.push(dataview.getFloat32(row + offset.normal_y, this.littleEndian))\n          normal.push(dataview.getFloat32(row + offset.normal_z, this.littleEndian))\n        }\n      }\n    }\n\n    // build geometry\n\n    const geometry = new BufferGeometry()\n\n    if (position.length > 0) geometry.setAttribute('position', new Float32BufferAttribute(position, 3))\n    if (normal.length > 0) geometry.setAttribute('normal', new Float32BufferAttribute(normal, 3))\n    if (color.length > 0) geometry.setAttribute('color', new Float32BufferAttribute(color, 3))\n\n    geometry.computeBoundingSphere()\n\n    // build material\n\n    const material = new PointsMaterial({ size: 0.005 })\n\n    if (color.length > 0) {\n      material.vertexColors = true\n    } else {\n      material.color.setHex(Math.random() * 0xffffff)\n    }\n\n    // build point cloud\n\n    const mesh = new Points(geometry, material)\n    let name = url.split('').reverse().join('')\n    name = /([^\\/]*)/.exec(name)\n    name = name[1].split('').reverse().join('')\n    mesh.name = name\n\n    return mesh\n  }\n}\n\nexport { PCDLoader }\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}