{"ast":null,"code":"import _classCallCheck from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _inherits from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport { UniformsUtils, ShaderMaterial, NoBlending, WebGLRenderTarget, MeshBasicMaterial, LinearMipmapLinearFilter } from \"three\";\nimport { Pass, FullScreenQuad } from \"./Pass.js\";\nimport { CopyShader } from \"../shaders/CopyShader.js\";\nimport { LuminosityShader } from \"../shaders/LuminosityShader.js\";\nimport { ToneMapShader } from \"../shaders/ToneMapShader.js\";\nvar AdaptiveToneMappingPass = /*#__PURE__*/function (_Pass) {\n  _inherits(AdaptiveToneMappingPass, _Pass);\n  var _super = _createSuper(AdaptiveToneMappingPass);\n  function AdaptiveToneMappingPass(adaptive, resolution) {\n    var _this;\n    _classCallCheck(this, AdaptiveToneMappingPass);\n    _this = _super.call(this);\n    _this.resolution = resolution !== void 0 ? resolution : 256;\n    _this.needsInit = true;\n    _this.adaptive = adaptive !== void 0 ? !!adaptive : true;\n    _this.luminanceRT = null;\n    _this.previousLuminanceRT = null;\n    _this.currentLuminanceRT = null;\n    var copyShader = CopyShader;\n    _this.copyUniforms = UniformsUtils.clone(copyShader.uniforms);\n    _this.materialCopy = new ShaderMaterial({\n      uniforms: _this.copyUniforms,\n      vertexShader: copyShader.vertexShader,\n      fragmentShader: copyShader.fragmentShader,\n      blending: NoBlending,\n      depthTest: false\n    });\n    _this.materialLuminance = new ShaderMaterial({\n      uniforms: UniformsUtils.clone(LuminosityShader.uniforms),\n      vertexShader: LuminosityShader.vertexShader,\n      fragmentShader: LuminosityShader.fragmentShader,\n      blending: NoBlending\n    });\n    _this.adaptLuminanceShader = {\n      defines: {\n        MIP_LEVEL_1X1: (Math.log(_this.resolution) / Math.log(2)).toFixed(1)\n      },\n      uniforms: {\n        lastLum: {\n          value: null\n        },\n        currentLum: {\n          value: null\n        },\n        minLuminance: {\n          value: 0.01\n        },\n        delta: {\n          value: 0.016\n        },\n        tau: {\n          value: 1\n        }\n      },\n      vertexShader: \"varying vec2 vUv;\\n\\n\\t\\t\\t\\tvoid main() {\\n\\n\\t\\t\\t\\t\\tvUv = uv;\\n\\t\\t\\t\\t\\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n\\n\\t\\t\\t\\t}\",\n      fragmentShader: \"varying vec2 vUv;\\n\\n\\t\\t\\t\\tuniform sampler2D lastLum;\\n\\t\\t\\t\\tuniform sampler2D currentLum;\\n\\t\\t\\t\\tuniform float minLuminance;\\n\\t\\t\\t\\tuniform float delta;\\n\\t\\t\\t\\tuniform float tau;\\n\\n\\t\\t\\t\\tvoid main() {\\n\\n\\t\\t\\t\\t\\tvec4 lastLum = texture2D( lastLum, vUv, MIP_LEVEL_1X1 );\\n\\t\\t\\t\\t\\tvec4 currentLum = texture2D( currentLum, vUv, MIP_LEVEL_1X1 );\\n\\n\\t\\t\\t\\t\\tfloat fLastLum = max( minLuminance, lastLum.r );\\n\\t\\t\\t\\t\\tfloat fCurrentLum = max( minLuminance, currentLum.r );\\n\\n\\t\\t\\t\\t\\t//The adaption seems to work better in extreme lighting differences\\n\\t\\t\\t\\t\\t//if the input luminance is squared.\\n\\t\\t\\t\\t\\tfCurrentLum *= fCurrentLum;\\n\\n\\t\\t\\t\\t\\t// Adapt the luminance using Pattanaik's technique\\n\\t\\t\\t\\t\\tfloat fAdaptedLum = fLastLum + (fCurrentLum - fLastLum) * (1.0 - exp(-delta * tau));\\n\\t\\t\\t\\t\\t// \\\"fAdaptedLum = sqrt(fAdaptedLum);\\n\\t\\t\\t\\t\\tgl_FragColor.r = fAdaptedLum;\\n\\t\\t\\t\\t}\"\n    };\n    _this.materialAdaptiveLum = new ShaderMaterial({\n      uniforms: UniformsUtils.clone(_this.adaptLuminanceShader.uniforms),\n      vertexShader: _this.adaptLuminanceShader.vertexShader,\n      fragmentShader: _this.adaptLuminanceShader.fragmentShader,\n      defines: Object.assign({}, _this.adaptLuminanceShader.defines),\n      blending: NoBlending\n    });\n    _this.materialToneMap = new ShaderMaterial({\n      uniforms: UniformsUtils.clone(ToneMapShader.uniforms),\n      vertexShader: ToneMapShader.vertexShader,\n      fragmentShader: ToneMapShader.fragmentShader,\n      blending: NoBlending\n    });\n    _this.fsQuad = new FullScreenQuad(null);\n    return _this;\n  }\n  _createClass(AdaptiveToneMappingPass, [{\n    key: \"render\",\n    value: function render(renderer, writeBuffer, readBuffer, deltaTime) {\n      if (this.needsInit) {\n        this.reset(renderer);\n        this.luminanceRT.texture.type = readBuffer.texture.type;\n        this.previousLuminanceRT.texture.type = readBuffer.texture.type;\n        this.currentLuminanceRT.texture.type = readBuffer.texture.type;\n        this.needsInit = false;\n      }\n      if (this.adaptive) {\n        this.fsQuad.material = this.materialLuminance;\n        this.materialLuminance.uniforms.tDiffuse.value = readBuffer.texture;\n        renderer.setRenderTarget(this.currentLuminanceRT);\n        this.fsQuad.render(renderer);\n        this.fsQuad.material = this.materialAdaptiveLum;\n        this.materialAdaptiveLum.uniforms.delta.value = deltaTime;\n        this.materialAdaptiveLum.uniforms.lastLum.value = this.previousLuminanceRT.texture;\n        this.materialAdaptiveLum.uniforms.currentLum.value = this.currentLuminanceRT.texture;\n        renderer.setRenderTarget(this.luminanceRT);\n        this.fsQuad.render(renderer);\n        this.fsQuad.material = this.materialCopy;\n        this.copyUniforms.tDiffuse.value = this.luminanceRT.texture;\n        renderer.setRenderTarget(this.previousLuminanceRT);\n        this.fsQuad.render(renderer);\n      }\n      this.fsQuad.material = this.materialToneMap;\n      this.materialToneMap.uniforms.tDiffuse.value = readBuffer.texture;\n      if (this.renderToScreen) {\n        renderer.setRenderTarget(null);\n        this.fsQuad.render(renderer);\n      } else {\n        renderer.setRenderTarget(writeBuffer);\n        if (this.clear) renderer.clear();\n        this.fsQuad.render(renderer);\n      }\n    }\n  }, {\n    key: \"reset\",\n    value: function reset() {\n      if (this.luminanceRT) {\n        this.luminanceRT.dispose();\n      }\n      if (this.currentLuminanceRT) {\n        this.currentLuminanceRT.dispose();\n      }\n      if (this.previousLuminanceRT) {\n        this.previousLuminanceRT.dispose();\n      }\n      this.luminanceRT = new WebGLRenderTarget(this.resolution, this.resolution);\n      this.luminanceRT.texture.name = \"AdaptiveToneMappingPass.l\";\n      this.luminanceRT.texture.generateMipmaps = false;\n      this.previousLuminanceRT = new WebGLRenderTarget(this.resolution, this.resolution);\n      this.previousLuminanceRT.texture.name = \"AdaptiveToneMappingPass.pl\";\n      this.previousLuminanceRT.texture.generateMipmaps = false;\n      var pars = {\n        minFilter: LinearMipmapLinearFilter,\n        generateMipmaps: true\n      };\n      this.currentLuminanceRT = new WebGLRenderTarget(this.resolution, this.resolution, pars);\n      this.currentLuminanceRT.texture.name = \"AdaptiveToneMappingPass.cl\";\n      if (this.adaptive) {\n        this.materialToneMap.defines[\"ADAPTED_LUMINANCE\"] = \"\";\n        this.materialToneMap.uniforms.luminanceMap.value = this.luminanceRT.texture;\n      }\n      this.fsQuad.material = new MeshBasicMaterial({\n        color: 7829367\n      });\n      this.materialLuminance.needsUpdate = true;\n      this.materialAdaptiveLum.needsUpdate = true;\n      this.materialToneMap.needsUpdate = true;\n    }\n  }, {\n    key: \"setAdaptive\",\n    value: function setAdaptive(adaptive) {\n      if (adaptive) {\n        this.adaptive = true;\n        this.materialToneMap.defines[\"ADAPTED_LUMINANCE\"] = \"\";\n        this.materialToneMap.uniforms.luminanceMap.value = this.luminanceRT.texture;\n      } else {\n        this.adaptive = false;\n        delete this.materialToneMap.defines[\"ADAPTED_LUMINANCE\"];\n        this.materialToneMap.uniforms.luminanceMap.value = null;\n      }\n      this.materialToneMap.needsUpdate = true;\n    }\n  }, {\n    key: \"setAdaptionRate\",\n    value: function setAdaptionRate(rate) {\n      if (rate) {\n        this.materialAdaptiveLum.uniforms.tau.value = Math.abs(rate);\n      }\n    }\n  }, {\n    key: \"setMinLuminance\",\n    value: function setMinLuminance(minLum) {\n      if (minLum) {\n        this.materialToneMap.uniforms.minLuminance.value = minLum;\n        this.materialAdaptiveLum.uniforms.minLuminance.value = minLum;\n      }\n    }\n  }, {\n    key: \"setMaxLuminance\",\n    value: function setMaxLuminance(maxLum) {\n      if (maxLum) {\n        this.materialToneMap.uniforms.maxLuminance.value = maxLum;\n      }\n    }\n  }, {\n    key: \"setAverageLuminance\",\n    value: function setAverageLuminance(avgLum) {\n      if (avgLum) {\n        this.materialToneMap.uniforms.averageLuminance.value = avgLum;\n      }\n    }\n  }, {\n    key: \"setMiddleGrey\",\n    value: function setMiddleGrey(middleGrey) {\n      if (middleGrey) {\n        this.materialToneMap.uniforms.middleGrey.value = middleGrey;\n      }\n    }\n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      if (this.luminanceRT) {\n        this.luminanceRT.dispose();\n      }\n      if (this.previousLuminanceRT) {\n        this.previousLuminanceRT.dispose();\n      }\n      if (this.currentLuminanceRT) {\n        this.currentLuminanceRT.dispose();\n      }\n      if (this.materialLuminance) {\n        this.materialLuminance.dispose();\n      }\n      if (this.materialAdaptiveLum) {\n        this.materialAdaptiveLum.dispose();\n      }\n      if (this.materialCopy) {\n        this.materialCopy.dispose();\n      }\n      if (this.materialToneMap) {\n        this.materialToneMap.dispose();\n      }\n    }\n  }]);\n  return AdaptiveToneMappingPass;\n}(Pass);\nexport { AdaptiveToneMappingPass };","map":{"version":3,"names":["AdaptiveToneMappingPass","_Pass","_inherits","_super","_createSuper","adaptive","resolution","_this","_classCallCheck","call","needsInit","luminanceRT","previousLuminanceRT","currentLuminanceRT","copyShader","CopyShader","copyUniforms","UniformsUtils","clone","uniforms","materialCopy","ShaderMaterial","vertexShader","fragmentShader","blending","NoBlending","depthTest","materialLuminance","LuminosityShader","adaptLuminanceShader","defines","MIP_LEVEL_1X1","Math","log","toFixed","lastLum","value","currentLum","minLuminance","delta","tau","materialAdaptiveLum","Object","assign","materialToneMap","ToneMapShader","fsQuad","FullScreenQuad","_createClass","key","render","renderer","writeBuffer","readBuffer","deltaTime","reset","texture","type","material","tDiffuse","setRenderTarget","renderToScreen","clear","dispose","WebGLRenderTarget","name","generateMipmaps","pars","minFilter","LinearMipmapLinearFilter","luminanceMap","MeshBasicMaterial","color","needsUpdate","setAdaptive","setAdaptionRate","rate","abs","setMinLuminance","minLum","setMaxLuminance","maxLum","maxLuminance","setAverageLuminance","avgLum","averageLuminance","setMiddleGrey","middleGrey","Pass"],"sources":["C:\\Users\\Nayyu\\Desktop\\skibidai-public-build\\node_modules\\src\\postprocessing\\AdaptiveToneMappingPass.js"],"sourcesContent":["import {\n  LinearMipmapLinearFilter,\n  MeshBasicMaterial,\n  NoBlending,\n  ShaderMaterial,\n  UniformsUtils,\n  WebGLRenderTarget,\n} from 'three'\nimport { Pass, FullScreenQuad } from './Pass'\nimport { CopyShader } from '../shaders/CopyShader'\nimport { LuminosityShader } from '../shaders/LuminosityShader'\nimport { ToneMapShader } from '../shaders/ToneMapShader'\n\n/**\n * Generate a texture that represents the luminosity of the current scene, adapted over time\n * to simulate the optic nerve responding to the amount of light it is receiving.\n * Based on a GDC2007 presentation by Wolfgang Engel titled \"Post-Processing Pipeline\"\n *\n * Full-screen tone-mapping shader based on http://www.graphics.cornell.edu/~jaf/publications/sig02_paper.pdf\n */\n\nclass AdaptiveToneMappingPass extends Pass {\n  constructor(adaptive, resolution) {\n    super()\n\n    this.resolution = resolution !== undefined ? resolution : 256\n    this.needsInit = true\n    this.adaptive = adaptive !== undefined ? !!adaptive : true\n\n    this.luminanceRT = null\n    this.previousLuminanceRT = null\n    this.currentLuminanceRT = null\n\n    const copyShader = CopyShader\n\n    this.copyUniforms = UniformsUtils.clone(copyShader.uniforms)\n\n    this.materialCopy = new ShaderMaterial({\n      uniforms: this.copyUniforms,\n      vertexShader: copyShader.vertexShader,\n      fragmentShader: copyShader.fragmentShader,\n      blending: NoBlending,\n      depthTest: false,\n    })\n\n    this.materialLuminance = new ShaderMaterial({\n      uniforms: UniformsUtils.clone(LuminosityShader.uniforms),\n      vertexShader: LuminosityShader.vertexShader,\n      fragmentShader: LuminosityShader.fragmentShader,\n      blending: NoBlending,\n    })\n\n    this.adaptLuminanceShader = {\n      defines: {\n        MIP_LEVEL_1X1: (Math.log(this.resolution) / Math.log(2.0)).toFixed(1),\n      },\n      uniforms: {\n        lastLum: { value: null },\n        currentLum: { value: null },\n        minLuminance: { value: 0.01 },\n        delta: { value: 0.016 },\n        tau: { value: 1.0 },\n      },\n      vertexShader: `varying vec2 vUv;\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t\t\t}`,\n\n      fragmentShader: `varying vec2 vUv;\n\n\t\t\t\tuniform sampler2D lastLum;\n\t\t\t\tuniform sampler2D currentLum;\n\t\t\t\tuniform float minLuminance;\n\t\t\t\tuniform float delta;\n\t\t\t\tuniform float tau;\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec4 lastLum = texture2D( lastLum, vUv, MIP_LEVEL_1X1 );\n\t\t\t\t\tvec4 currentLum = texture2D( currentLum, vUv, MIP_LEVEL_1X1 );\n\n\t\t\t\t\tfloat fLastLum = max( minLuminance, lastLum.r );\n\t\t\t\t\tfloat fCurrentLum = max( minLuminance, currentLum.r );\n\n\t\t\t\t\t//The adaption seems to work better in extreme lighting differences\n\t\t\t\t\t//if the input luminance is squared.\n\t\t\t\t\tfCurrentLum *= fCurrentLum;\n\n\t\t\t\t\t// Adapt the luminance using Pattanaik's technique\n\t\t\t\t\tfloat fAdaptedLum = fLastLum + (fCurrentLum - fLastLum) * (1.0 - exp(-delta * tau));\n\t\t\t\t\t// \"fAdaptedLum = sqrt(fAdaptedLum);\n\t\t\t\t\tgl_FragColor.r = fAdaptedLum;\n\t\t\t\t}`,\n    }\n\n    this.materialAdaptiveLum = new ShaderMaterial({\n      uniforms: UniformsUtils.clone(this.adaptLuminanceShader.uniforms),\n      vertexShader: this.adaptLuminanceShader.vertexShader,\n      fragmentShader: this.adaptLuminanceShader.fragmentShader,\n      defines: Object.assign({}, this.adaptLuminanceShader.defines),\n      blending: NoBlending,\n    })\n\n    this.materialToneMap = new ShaderMaterial({\n      uniforms: UniformsUtils.clone(ToneMapShader.uniforms),\n      vertexShader: ToneMapShader.vertexShader,\n      fragmentShader: ToneMapShader.fragmentShader,\n      blending: NoBlending,\n    })\n\n    this.fsQuad = new FullScreenQuad(null)\n  }\n\n  render(renderer, writeBuffer, readBuffer, deltaTime /*, maskActive*/) {\n    if (this.needsInit) {\n      this.reset(renderer)\n\n      this.luminanceRT.texture.type = readBuffer.texture.type\n      this.previousLuminanceRT.texture.type = readBuffer.texture.type\n      this.currentLuminanceRT.texture.type = readBuffer.texture.type\n      this.needsInit = false\n    }\n\n    if (this.adaptive) {\n      //Render the luminance of the current scene into a render target with mipmapping enabled\n      this.fsQuad.material = this.materialLuminance\n      this.materialLuminance.uniforms.tDiffuse.value = readBuffer.texture\n      renderer.setRenderTarget(this.currentLuminanceRT)\n      this.fsQuad.render(renderer)\n\n      //Use the new luminance values, the previous luminance and the frame delta to\n      //adapt the luminance over time.\n      this.fsQuad.material = this.materialAdaptiveLum\n      this.materialAdaptiveLum.uniforms.delta.value = deltaTime\n      this.materialAdaptiveLum.uniforms.lastLum.value = this.previousLuminanceRT.texture\n      this.materialAdaptiveLum.uniforms.currentLum.value = this.currentLuminanceRT.texture\n      renderer.setRenderTarget(this.luminanceRT)\n      this.fsQuad.render(renderer)\n\n      //Copy the new adapted luminance value so that it can be used by the next frame.\n      this.fsQuad.material = this.materialCopy\n      this.copyUniforms.tDiffuse.value = this.luminanceRT.texture\n      renderer.setRenderTarget(this.previousLuminanceRT)\n      this.fsQuad.render(renderer)\n    }\n\n    this.fsQuad.material = this.materialToneMap\n    this.materialToneMap.uniforms.tDiffuse.value = readBuffer.texture\n\n    if (this.renderToScreen) {\n      renderer.setRenderTarget(null)\n      this.fsQuad.render(renderer)\n    } else {\n      renderer.setRenderTarget(writeBuffer)\n\n      if (this.clear) renderer.clear()\n\n      this.fsQuad.render(renderer)\n    }\n  }\n\n  reset() {\n    // render targets\n    if (this.luminanceRT) {\n      this.luminanceRT.dispose()\n    }\n\n    if (this.currentLuminanceRT) {\n      this.currentLuminanceRT.dispose()\n    }\n\n    if (this.previousLuminanceRT) {\n      this.previousLuminanceRT.dispose()\n    }\n\n    this.luminanceRT = new WebGLRenderTarget(this.resolution, this.resolution)\n    this.luminanceRT.texture.name = 'AdaptiveToneMappingPass.l'\n    this.luminanceRT.texture.generateMipmaps = false\n\n    this.previousLuminanceRT = new WebGLRenderTarget(this.resolution, this.resolution)\n    this.previousLuminanceRT.texture.name = 'AdaptiveToneMappingPass.pl'\n    this.previousLuminanceRT.texture.generateMipmaps = false\n\n    // We only need mipmapping for the current luminosity because we want a down-sampled version to sample in our adaptive shader\n\n    const pars = { minFilter: LinearMipmapLinearFilter, generateMipmaps: true }\n\n    this.currentLuminanceRT = new WebGLRenderTarget(this.resolution, this.resolution, pars)\n    this.currentLuminanceRT.texture.name = 'AdaptiveToneMappingPass.cl'\n\n    if (this.adaptive) {\n      this.materialToneMap.defines['ADAPTED_LUMINANCE'] = ''\n      this.materialToneMap.uniforms.luminanceMap.value = this.luminanceRT.texture\n    }\n\n    //Put something in the adaptive luminance texture so that the scene can render initially\n    this.fsQuad.material = new MeshBasicMaterial({ color: 0x777777 })\n    this.materialLuminance.needsUpdate = true\n    this.materialAdaptiveLum.needsUpdate = true\n    this.materialToneMap.needsUpdate = true\n    // renderer.render( this.scene, this.camera, this.luminanceRT );\n    // renderer.render( this.scene, this.camera, this.previousLuminanceRT );\n    // renderer.render( this.scene, this.camera, this.currentLuminanceRT );\n  }\n\n  setAdaptive(adaptive) {\n    if (adaptive) {\n      this.adaptive = true\n      this.materialToneMap.defines['ADAPTED_LUMINANCE'] = ''\n      this.materialToneMap.uniforms.luminanceMap.value = this.luminanceRT.texture\n    } else {\n      this.adaptive = false\n      delete this.materialToneMap.defines['ADAPTED_LUMINANCE']\n      this.materialToneMap.uniforms.luminanceMap.value = null\n    }\n\n    this.materialToneMap.needsUpdate = true\n  }\n\n  setAdaptionRate(rate) {\n    if (rate) {\n      this.materialAdaptiveLum.uniforms.tau.value = Math.abs(rate)\n    }\n  }\n\n  setMinLuminance(minLum) {\n    if (minLum) {\n      this.materialToneMap.uniforms.minLuminance.value = minLum\n      this.materialAdaptiveLum.uniforms.minLuminance.value = minLum\n    }\n  }\n\n  setMaxLuminance(maxLum) {\n    if (maxLum) {\n      this.materialToneMap.uniforms.maxLuminance.value = maxLum\n    }\n  }\n\n  setAverageLuminance(avgLum) {\n    if (avgLum) {\n      this.materialToneMap.uniforms.averageLuminance.value = avgLum\n    }\n  }\n\n  setMiddleGrey(middleGrey) {\n    if (middleGrey) {\n      this.materialToneMap.uniforms.middleGrey.value = middleGrey\n    }\n  }\n\n  dispose() {\n    if (this.luminanceRT) {\n      this.luminanceRT.dispose()\n    }\n\n    if (this.previousLuminanceRT) {\n      this.previousLuminanceRT.dispose()\n    }\n\n    if (this.currentLuminanceRT) {\n      this.currentLuminanceRT.dispose()\n    }\n\n    if (this.materialLuminance) {\n      this.materialLuminance.dispose()\n    }\n\n    if (this.materialAdaptiveLum) {\n      this.materialAdaptiveLum.dispose()\n    }\n\n    if (this.materialCopy) {\n      this.materialCopy.dispose()\n    }\n\n    if (this.materialToneMap) {\n      this.materialToneMap.dispose()\n    }\n  }\n}\n\nexport { AdaptiveToneMappingPass }\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}