{"ast":null,"code":"import _slicedToArray from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _classCallCheck from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport { Vector3, Plane, Line3, Sphere, Box3, Triangle } from \"three\";\nimport { Capsule } from \"./Capsule.js\";\nvar _v1 = new Vector3();\nvar _v2 = new Vector3();\nvar _plane = new Plane();\nvar _line1 = new Line3();\nvar _line2 = new Line3();\nvar _sphere = new Sphere();\nvar _capsule = new Capsule();\nvar Octree = /*#__PURE__*/function () {\n  function Octree(box) {\n    _classCallCheck(this, Octree);\n    this.triangles = [];\n    this.box = box;\n    this.subTrees = [];\n  }\n  _createClass(Octree, [{\n    key: \"addTriangle\",\n    value: function addTriangle(triangle) {\n      if (!this.bounds) this.bounds = new Box3();\n      this.bounds.min.x = Math.min(this.bounds.min.x, triangle.a.x, triangle.b.x, triangle.c.x);\n      this.bounds.min.y = Math.min(this.bounds.min.y, triangle.a.y, triangle.b.y, triangle.c.y);\n      this.bounds.min.z = Math.min(this.bounds.min.z, triangle.a.z, triangle.b.z, triangle.c.z);\n      this.bounds.max.x = Math.max(this.bounds.max.x, triangle.a.x, triangle.b.x, triangle.c.x);\n      this.bounds.max.y = Math.max(this.bounds.max.y, triangle.a.y, triangle.b.y, triangle.c.y);\n      this.bounds.max.z = Math.max(this.bounds.max.z, triangle.a.z, triangle.b.z, triangle.c.z);\n      this.triangles.push(triangle);\n      return this;\n    }\n  }, {\n    key: \"calcBox\",\n    value: function calcBox() {\n      this.box = this.bounds.clone();\n      this.box.min.x -= 0.01;\n      this.box.min.y -= 0.01;\n      this.box.min.z -= 0.01;\n      return this;\n    }\n  }, {\n    key: \"split\",\n    value: function split(level) {\n      if (!this.box) return;\n      var subTrees = [];\n      var halfsize = _v2.copy(this.box.max).sub(this.box.min).multiplyScalar(0.5);\n      for (var x = 0; x < 2; x++) {\n        for (var y = 0; y < 2; y++) {\n          for (var z = 0; z < 2; z++) {\n            var box = new Box3();\n            var v = _v1.set(x, y, z);\n            box.min.copy(this.box.min).add(v.multiply(halfsize));\n            box.max.copy(box.min).add(halfsize);\n            subTrees.push(new Octree(box));\n          }\n        }\n      }\n      var triangle;\n      while (triangle = this.triangles.pop()) {\n        for (var i = 0; i < subTrees.length; i++) {\n          if (subTrees[i].box.intersectsTriangle(triangle)) {\n            subTrees[i].triangles.push(triangle);\n          }\n        }\n      }\n      for (var _i = 0; _i < subTrees.length; _i++) {\n        var len = subTrees[_i].triangles.length;\n        if (len > 8 && level < 16) {\n          subTrees[_i].split(level + 1);\n        }\n        if (len !== 0) {\n          this.subTrees.push(subTrees[_i]);\n        }\n      }\n      return this;\n    }\n  }, {\n    key: \"build\",\n    value: function build() {\n      this.calcBox();\n      this.split(0);\n      return this;\n    }\n  }, {\n    key: \"getRayTriangles\",\n    value: function getRayTriangles(ray, triangles) {\n      for (var i = 0; i < this.subTrees.length; i++) {\n        var subTree = this.subTrees[i];\n        if (!ray.intersectsBox(subTree.box)) continue;\n        if (subTree.triangles.length > 0) {\n          for (var j = 0; j < subTree.triangles.length; j++) {\n            if (triangles.indexOf(subTree.triangles[j]) === -1) triangles.push(subTree.triangles[j]);\n          }\n        } else {\n          subTree.getRayTriangles(ray, triangles);\n        }\n      }\n      return triangles;\n    }\n  }, {\n    key: \"triangleCapsuleIntersect\",\n    value: function triangleCapsuleIntersect(capsule, triangle) {\n      triangle.getPlane(_plane);\n      var d1 = _plane.distanceToPoint(capsule.start) - capsule.radius;\n      var d2 = _plane.distanceToPoint(capsule.end) - capsule.radius;\n      if (d1 > 0 && d2 > 0 || d1 < -capsule.radius && d2 < -capsule.radius) {\n        return false;\n      }\n      var delta = Math.abs(d1 / (Math.abs(d1) + Math.abs(d2)));\n      var intersectPoint = _v1.copy(capsule.start).lerp(capsule.end, delta);\n      if (triangle.containsPoint(intersectPoint)) {\n        return {\n          normal: _plane.normal.clone(),\n          point: intersectPoint.clone(),\n          depth: Math.abs(Math.min(d1, d2))\n        };\n      }\n      var r2 = capsule.radius * capsule.radius;\n      var line1 = _line1.set(capsule.start, capsule.end);\n      var lines = [[triangle.a, triangle.b], [triangle.b, triangle.c], [triangle.c, triangle.a]];\n      for (var i = 0; i < lines.length; i++) {\n        var line2 = _line2.set(lines[i][0], lines[i][1]);\n        var _capsule$lineLineMini = capsule.lineLineMinimumPoints(line1, line2),\n          _capsule$lineLineMini2 = _slicedToArray(_capsule$lineLineMini, 2),\n          point1 = _capsule$lineLineMini2[0],\n          point2 = _capsule$lineLineMini2[1];\n        if (point1.distanceToSquared(point2) < r2) {\n          return {\n            normal: point1.clone().sub(point2).normalize(),\n            point: point2.clone(),\n            depth: capsule.radius - point1.distanceTo(point2)\n          };\n        }\n      }\n      return false;\n    }\n  }, {\n    key: \"triangleSphereIntersect\",\n    value: function triangleSphereIntersect(sphere, triangle) {\n      triangle.getPlane(_plane);\n      if (!sphere.intersectsPlane(_plane)) return false;\n      var depth = Math.abs(_plane.distanceToSphere(sphere));\n      var r2 = sphere.radius * sphere.radius - depth * depth;\n      var plainPoint = _plane.projectPoint(sphere.center, _v1);\n      if (triangle.containsPoint(sphere.center)) {\n        return {\n          normal: _plane.normal.clone(),\n          point: plainPoint.clone(),\n          depth: Math.abs(_plane.distanceToSphere(sphere))\n        };\n      }\n      var lines = [[triangle.a, triangle.b], [triangle.b, triangle.c], [triangle.c, triangle.a]];\n      for (var i = 0; i < lines.length; i++) {\n        _line1.set(lines[i][0], lines[i][1]);\n        _line1.closestPointToPoint(plainPoint, true, _v2);\n        var d = _v2.distanceToSquared(sphere.center);\n        if (d < r2) {\n          return {\n            normal: sphere.center.clone().sub(_v2).normalize(),\n            point: _v2.clone(),\n            depth: sphere.radius - Math.sqrt(d)\n          };\n        }\n      }\n      return false;\n    }\n  }, {\n    key: \"getSphereTriangles\",\n    value: function getSphereTriangles(sphere, triangles) {\n      for (var i = 0; i < this.subTrees.length; i++) {\n        var subTree = this.subTrees[i];\n        if (!sphere.intersectsBox(subTree.box)) continue;\n        if (subTree.triangles.length > 0) {\n          for (var j = 0; j < subTree.triangles.length; j++) {\n            if (triangles.indexOf(subTree.triangles[j]) === -1) triangles.push(subTree.triangles[j]);\n          }\n        } else {\n          subTree.getSphereTriangles(sphere, triangles);\n        }\n      }\n    }\n  }, {\n    key: \"getCapsuleTriangles\",\n    value: function getCapsuleTriangles(capsule, triangles) {\n      for (var i = 0; i < this.subTrees.length; i++) {\n        var subTree = this.subTrees[i];\n        if (!capsule.intersectsBox(subTree.box)) continue;\n        if (subTree.triangles.length > 0) {\n          for (var j = 0; j < subTree.triangles.length; j++) {\n            if (triangles.indexOf(subTree.triangles[j]) === -1) triangles.push(subTree.triangles[j]);\n          }\n        } else {\n          subTree.getCapsuleTriangles(capsule, triangles);\n        }\n      }\n    }\n  }, {\n    key: \"sphereIntersect\",\n    value: function sphereIntersect(sphere) {\n      _sphere.copy(sphere);\n      var triangles = [];\n      var result,\n        hit = false;\n      this.getSphereTriangles(sphere, triangles);\n      for (var i = 0; i < triangles.length; i++) {\n        if (result = this.triangleSphereIntersect(_sphere, triangles[i])) {\n          hit = true;\n          _sphere.center.add(result.normal.multiplyScalar(result.depth));\n        }\n      }\n      if (hit) {\n        var collisionVector = _sphere.center.clone().sub(sphere.center);\n        var depth = collisionVector.length();\n        return {\n          normal: collisionVector.normalize(),\n          depth: depth\n        };\n      }\n      return false;\n    }\n  }, {\n    key: \"capsuleIntersect\",\n    value: function capsuleIntersect(capsule) {\n      _capsule.copy(capsule);\n      var triangles = [];\n      var result,\n        hit = false;\n      this.getCapsuleTriangles(_capsule, triangles);\n      for (var i = 0; i < triangles.length; i++) {\n        if (result = this.triangleCapsuleIntersect(_capsule, triangles[i])) {\n          hit = true;\n          _capsule.translate(result.normal.multiplyScalar(result.depth));\n        }\n      }\n      if (hit) {\n        var collisionVector = _capsule.getCenter(new Vector3()).sub(capsule.getCenter(_v1));\n        var depth = collisionVector.length();\n        return {\n          normal: collisionVector.normalize(),\n          depth: depth\n        };\n      }\n      return false;\n    }\n  }, {\n    key: \"rayIntersect\",\n    value: function rayIntersect(ray) {\n      if (ray.direction.length() === 0) return;\n      var triangles = [];\n      var triangle,\n        position,\n        distance = 1e100;\n      this.getRayTriangles(ray, triangles);\n      for (var i = 0; i < triangles.length; i++) {\n        var result = ray.intersectTriangle(triangles[i].a, triangles[i].b, triangles[i].c, true, _v1);\n        if (result) {\n          var newdistance = result.sub(ray.origin).length();\n          if (distance > newdistance) {\n            position = result.clone().add(ray.origin);\n            distance = newdistance;\n            triangle = triangles[i];\n          }\n        }\n      }\n      return distance < 1e100 ? {\n        distance: distance,\n        triangle: triangle,\n        position: position\n      } : false;\n    }\n  }, {\n    key: \"fromGraphNode\",\n    value: function fromGraphNode(group) {\n      var _this = this;\n      group.updateWorldMatrix(true, true);\n      group.traverse(function (obj) {\n        if (obj.isMesh === true) {\n          var geometry,\n            isTemp = false;\n          if (obj.geometry.index !== null) {\n            isTemp = true;\n            geometry = obj.geometry.toNonIndexed();\n          } else {\n            geometry = obj.geometry;\n          }\n          var positionAttribute = geometry.getAttribute(\"position\");\n          for (var i = 0; i < positionAttribute.count; i += 3) {\n            var v1 = new Vector3().fromBufferAttribute(positionAttribute, i);\n            var v2 = new Vector3().fromBufferAttribute(positionAttribute, i + 1);\n            var v3 = new Vector3().fromBufferAttribute(positionAttribute, i + 2);\n            v1.applyMatrix4(obj.matrixWorld);\n            v2.applyMatrix4(obj.matrixWorld);\n            v3.applyMatrix4(obj.matrixWorld);\n            _this.addTriangle(new Triangle(v1, v2, v3));\n          }\n          if (isTemp) {\n            geometry.dispose();\n          }\n        }\n      });\n      this.build();\n      return this;\n    }\n  }]);\n  return Octree;\n}();\nexport { Octree };","map":{"version":3,"names":["_v1","Vector3","_v2","_plane","Plane","_line1","Line3","_line2","_sphere","Sphere","_capsule","Capsule","Octree","box","_classCallCheck","triangles","subTrees","_createClass","key","value","addTriangle","triangle","bounds","Box3","min","x","Math","a","b","c","y","z","max","push","calcBox","clone","split","level","halfsize","copy","sub","multiplyScalar","v","set","add","multiply","pop","i","length","intersectsTriangle","len","build","getRayTriangles","ray","subTree","intersectsBox","j","indexOf","triangleCapsuleIntersect","capsule","getPlane","d1","distanceToPoint","start","radius","d2","end","delta","abs","intersectPoint","lerp","containsPoint","normal","point","depth","r2","line1","lines","line2","_capsule$lineLineMini","lineLineMinimumPoints","_capsule$lineLineMini2","_slicedToArray","point1","point2","distanceToSquared","normalize","distanceTo","triangleSphereIntersect","sphere","intersectsPlane","distanceToSphere","plainPoint","projectPoint","center","closestPointToPoint","d","sqrt","getSphereTriangles","getCapsuleTriangles","sphereIntersect","result","hit","collisionVector","capsuleIntersect","translate","getCenter","rayIntersect","direction","position","distance","intersectTriangle","newdistance","origin","fromGraphNode","group","_this","updateWorldMatrix","traverse","obj","isMesh","geometry","isTemp","index","toNonIndexed","positionAttribute","getAttribute","count","v1","fromBufferAttribute","v2","v3","applyMatrix4","matrixWorld","Triangle","dispose"],"sources":["C:\\Users\\Nayyu\\Desktop\\skibidai-public-build\\node_modules\\src\\math\\Octree.js"],"sourcesContent":["import { Box3, Line3, Plane, Sphere, Triangle, Vector3 } from 'three'\nimport { Capsule } from '../math/Capsule'\n\nconst _v1 = new Vector3()\nconst _v2 = new Vector3()\nconst _plane = new Plane()\nconst _line1 = new Line3()\nconst _line2 = new Line3()\nconst _sphere = new Sphere()\nconst _capsule = new Capsule()\n\nclass Octree {\n  constructor(box) {\n    this.triangles = []\n    this.box = box\n    this.subTrees = []\n  }\n\n  addTriangle(triangle) {\n    if (!this.bounds) this.bounds = new Box3()\n\n    this.bounds.min.x = Math.min(this.bounds.min.x, triangle.a.x, triangle.b.x, triangle.c.x)\n    this.bounds.min.y = Math.min(this.bounds.min.y, triangle.a.y, triangle.b.y, triangle.c.y)\n    this.bounds.min.z = Math.min(this.bounds.min.z, triangle.a.z, triangle.b.z, triangle.c.z)\n    this.bounds.max.x = Math.max(this.bounds.max.x, triangle.a.x, triangle.b.x, triangle.c.x)\n    this.bounds.max.y = Math.max(this.bounds.max.y, triangle.a.y, triangle.b.y, triangle.c.y)\n    this.bounds.max.z = Math.max(this.bounds.max.z, triangle.a.z, triangle.b.z, triangle.c.z)\n\n    this.triangles.push(triangle)\n\n    return this\n  }\n\n  calcBox() {\n    this.box = this.bounds.clone()\n\n    // offset small amount to account for regular grid\n    this.box.min.x -= 0.01\n    this.box.min.y -= 0.01\n    this.box.min.z -= 0.01\n\n    return this\n  }\n\n  split(level) {\n    if (!this.box) return\n\n    const subTrees = []\n    const halfsize = _v2.copy(this.box.max).sub(this.box.min).multiplyScalar(0.5)\n\n    for (let x = 0; x < 2; x++) {\n      for (let y = 0; y < 2; y++) {\n        for (let z = 0; z < 2; z++) {\n          const box = new Box3()\n          const v = _v1.set(x, y, z)\n\n          box.min.copy(this.box.min).add(v.multiply(halfsize))\n          box.max.copy(box.min).add(halfsize)\n\n          subTrees.push(new Octree(box))\n        }\n      }\n    }\n\n    let triangle\n\n    while ((triangle = this.triangles.pop())) {\n      for (let i = 0; i < subTrees.length; i++) {\n        if (subTrees[i].box.intersectsTriangle(triangle)) {\n          subTrees[i].triangles.push(triangle)\n        }\n      }\n    }\n\n    for (let i = 0; i < subTrees.length; i++) {\n      const len = subTrees[i].triangles.length\n\n      if (len > 8 && level < 16) {\n        subTrees[i].split(level + 1)\n      }\n\n      if (len !== 0) {\n        this.subTrees.push(subTrees[i])\n      }\n    }\n\n    return this\n  }\n\n  build() {\n    this.calcBox()\n    this.split(0)\n\n    return this\n  }\n\n  getRayTriangles(ray, triangles) {\n    for (let i = 0; i < this.subTrees.length; i++) {\n      const subTree = this.subTrees[i]\n      if (!ray.intersectsBox(subTree.box)) continue\n\n      if (subTree.triangles.length > 0) {\n        for (let j = 0; j < subTree.triangles.length; j++) {\n          if (triangles.indexOf(subTree.triangles[j]) === -1) triangles.push(subTree.triangles[j])\n        }\n      } else {\n        subTree.getRayTriangles(ray, triangles)\n      }\n    }\n\n    return triangles\n  }\n\n  triangleCapsuleIntersect(capsule, triangle) {\n    triangle.getPlane(_plane)\n\n    const d1 = _plane.distanceToPoint(capsule.start) - capsule.radius\n    const d2 = _plane.distanceToPoint(capsule.end) - capsule.radius\n\n    if ((d1 > 0 && d2 > 0) || (d1 < -capsule.radius && d2 < -capsule.radius)) {\n      return false\n    }\n\n    const delta = Math.abs(d1 / (Math.abs(d1) + Math.abs(d2)))\n    const intersectPoint = _v1.copy(capsule.start).lerp(capsule.end, delta)\n\n    if (triangle.containsPoint(intersectPoint)) {\n      return { normal: _plane.normal.clone(), point: intersectPoint.clone(), depth: Math.abs(Math.min(d1, d2)) }\n    }\n\n    const r2 = capsule.radius * capsule.radius\n\n    const line1 = _line1.set(capsule.start, capsule.end)\n\n    const lines = [\n      [triangle.a, triangle.b],\n      [triangle.b, triangle.c],\n      [triangle.c, triangle.a],\n    ]\n\n    for (let i = 0; i < lines.length; i++) {\n      const line2 = _line2.set(lines[i][0], lines[i][1])\n\n      const [point1, point2] = capsule.lineLineMinimumPoints(line1, line2)\n\n      if (point1.distanceToSquared(point2) < r2) {\n        return {\n          normal: point1.clone().sub(point2).normalize(),\n          point: point2.clone(),\n          depth: capsule.radius - point1.distanceTo(point2),\n        }\n      }\n    }\n\n    return false\n  }\n\n  triangleSphereIntersect(sphere, triangle) {\n    triangle.getPlane(_plane)\n\n    if (!sphere.intersectsPlane(_plane)) return false\n\n    const depth = Math.abs(_plane.distanceToSphere(sphere))\n    const r2 = sphere.radius * sphere.radius - depth * depth\n\n    const plainPoint = _plane.projectPoint(sphere.center, _v1)\n\n    if (triangle.containsPoint(sphere.center)) {\n      return {\n        normal: _plane.normal.clone(),\n        point: plainPoint.clone(),\n        depth: Math.abs(_plane.distanceToSphere(sphere)),\n      }\n    }\n\n    const lines = [\n      [triangle.a, triangle.b],\n      [triangle.b, triangle.c],\n      [triangle.c, triangle.a],\n    ]\n\n    for (let i = 0; i < lines.length; i++) {\n      _line1.set(lines[i][0], lines[i][1])\n      _line1.closestPointToPoint(plainPoint, true, _v2)\n\n      const d = _v2.distanceToSquared(sphere.center)\n\n      if (d < r2) {\n        return {\n          normal: sphere.center.clone().sub(_v2).normalize(),\n          point: _v2.clone(),\n          depth: sphere.radius - Math.sqrt(d),\n        }\n      }\n    }\n\n    return false\n  }\n\n  getSphereTriangles(sphere, triangles) {\n    for (let i = 0; i < this.subTrees.length; i++) {\n      const subTree = this.subTrees[i]\n\n      if (!sphere.intersectsBox(subTree.box)) continue\n\n      if (subTree.triangles.length > 0) {\n        for (let j = 0; j < subTree.triangles.length; j++) {\n          if (triangles.indexOf(subTree.triangles[j]) === -1) triangles.push(subTree.triangles[j])\n        }\n      } else {\n        subTree.getSphereTriangles(sphere, triangles)\n      }\n    }\n  }\n\n  getCapsuleTriangles(capsule, triangles) {\n    for (let i = 0; i < this.subTrees.length; i++) {\n      const subTree = this.subTrees[i]\n\n      if (!capsule.intersectsBox(subTree.box)) continue\n\n      if (subTree.triangles.length > 0) {\n        for (let j = 0; j < subTree.triangles.length; j++) {\n          if (triangles.indexOf(subTree.triangles[j]) === -1) triangles.push(subTree.triangles[j])\n        }\n      } else {\n        subTree.getCapsuleTriangles(capsule, triangles)\n      }\n    }\n  }\n\n  sphereIntersect(sphere) {\n    _sphere.copy(sphere)\n\n    const triangles = []\n    let result,\n      hit = false\n\n    this.getSphereTriangles(sphere, triangles)\n\n    for (let i = 0; i < triangles.length; i++) {\n      if ((result = this.triangleSphereIntersect(_sphere, triangles[i]))) {\n        hit = true\n\n        _sphere.center.add(result.normal.multiplyScalar(result.depth))\n      }\n    }\n\n    if (hit) {\n      const collisionVector = _sphere.center.clone().sub(sphere.center)\n      const depth = collisionVector.length()\n\n      return { normal: collisionVector.normalize(), depth: depth }\n    }\n\n    return false\n  }\n\n  capsuleIntersect(capsule) {\n    _capsule.copy(capsule)\n\n    const triangles = []\n    let result,\n      hit = false\n\n    this.getCapsuleTriangles(_capsule, triangles)\n\n    for (let i = 0; i < triangles.length; i++) {\n      if ((result = this.triangleCapsuleIntersect(_capsule, triangles[i]))) {\n        hit = true\n\n        _capsule.translate(result.normal.multiplyScalar(result.depth))\n      }\n    }\n\n    if (hit) {\n      const collisionVector = _capsule.getCenter(new Vector3()).sub(capsule.getCenter(_v1))\n      const depth = collisionVector.length()\n\n      return { normal: collisionVector.normalize(), depth: depth }\n    }\n\n    return false\n  }\n\n  rayIntersect(ray) {\n    if (ray.direction.length() === 0) return\n\n    const triangles = []\n    let triangle,\n      position,\n      distance = 1e100\n\n    this.getRayTriangles(ray, triangles)\n\n    for (let i = 0; i < triangles.length; i++) {\n      const result = ray.intersectTriangle(triangles[i].a, triangles[i].b, triangles[i].c, true, _v1)\n\n      if (result) {\n        const newdistance = result.sub(ray.origin).length()\n\n        if (distance > newdistance) {\n          position = result.clone().add(ray.origin)\n          distance = newdistance\n          triangle = triangles[i]\n        }\n      }\n    }\n\n    return distance < 1e100 ? { distance: distance, triangle: triangle, position: position } : false\n  }\n\n  fromGraphNode(group) {\n    group.updateWorldMatrix(true, true)\n\n    group.traverse((obj) => {\n      if (obj.isMesh === true) {\n        let geometry,\n          isTemp = false\n\n        if (obj.geometry.index !== null) {\n          isTemp = true\n          geometry = obj.geometry.toNonIndexed()\n        } else {\n          geometry = obj.geometry\n        }\n\n        const positionAttribute = geometry.getAttribute('position')\n\n        for (let i = 0; i < positionAttribute.count; i += 3) {\n          const v1 = new Vector3().fromBufferAttribute(positionAttribute, i)\n          const v2 = new Vector3().fromBufferAttribute(positionAttribute, i + 1)\n          const v3 = new Vector3().fromBufferAttribute(positionAttribute, i + 2)\n\n          v1.applyMatrix4(obj.matrixWorld)\n          v2.applyMatrix4(obj.matrixWorld)\n          v3.applyMatrix4(obj.matrixWorld)\n\n          this.addTriangle(new Triangle(v1, v2, v3))\n        }\n\n        if (isTemp) {\n          geometry.dispose()\n        }\n      }\n    })\n\n    this.build()\n\n    return this\n  }\n}\n\nexport { Octree }\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}