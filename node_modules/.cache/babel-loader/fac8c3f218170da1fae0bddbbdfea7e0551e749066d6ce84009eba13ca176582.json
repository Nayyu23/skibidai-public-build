{"ast":null,"code":"import _classCallCheck from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _inherits from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport { Vector3, Loader, FileLoader, Group, BufferGeometry, Float32BufferAttribute, LineBasicMaterial, Material, PointsMaterial, MeshPhongMaterial, LineSegments, Points, Mesh } from \"three\";\nvar _object_pattern = /^[og]\\s*(.+)?/;\nvar _material_library_pattern = /^mtllib /;\nvar _material_use_pattern = /^usemtl /;\nvar _map_use_pattern = /^usemap /;\nvar _vA = new Vector3();\nvar _vB = new Vector3();\nvar _vC = new Vector3();\nvar _ab = new Vector3();\nvar _cb = new Vector3();\nfunction ParserState() {\n  var state = {\n    objects: [],\n    object: {},\n    vertices: [],\n    normals: [],\n    colors: [],\n    uvs: [],\n    materials: {},\n    materialLibraries: [],\n    startObject: function startObject(name, fromDeclaration) {\n      if (this.object && this.object.fromDeclaration === false) {\n        this.object.name = name;\n        this.object.fromDeclaration = fromDeclaration !== false;\n        return;\n      }\n      var previousMaterial = this.object && typeof this.object.currentMaterial === \"function\" ? this.object.currentMaterial() : void 0;\n      if (this.object && typeof this.object._finalize === \"function\") {\n        this.object._finalize(true);\n      }\n      this.object = {\n        name: name || \"\",\n        fromDeclaration: fromDeclaration !== false,\n        geometry: {\n          vertices: [],\n          normals: [],\n          colors: [],\n          uvs: [],\n          hasUVIndices: false\n        },\n        materials: [],\n        smooth: true,\n        startMaterial: function startMaterial(name2, libraries) {\n          var previous = this._finalize(false);\n          if (previous && (previous.inherited || previous.groupCount <= 0)) {\n            this.materials.splice(previous.index, 1);\n          }\n          var material = {\n            index: this.materials.length,\n            name: name2 || \"\",\n            mtllib: Array.isArray(libraries) && libraries.length > 0 ? libraries[libraries.length - 1] : \"\",\n            smooth: previous !== void 0 ? previous.smooth : this.smooth,\n            groupStart: previous !== void 0 ? previous.groupEnd : 0,\n            groupEnd: -1,\n            groupCount: -1,\n            inherited: false,\n            clone: function clone(index) {\n              var cloned = {\n                index: typeof index === \"number\" ? index : this.index,\n                name: this.name,\n                mtllib: this.mtllib,\n                smooth: this.smooth,\n                groupStart: 0,\n                groupEnd: -1,\n                groupCount: -1,\n                inherited: false\n              };\n              cloned.clone = this.clone.bind(cloned);\n              return cloned;\n            }\n          };\n          this.materials.push(material);\n          return material;\n        },\n        currentMaterial: function currentMaterial() {\n          if (this.materials.length > 0) {\n            return this.materials[this.materials.length - 1];\n          }\n          return void 0;\n        },\n        _finalize: function _finalize(end) {\n          var lastMultiMaterial = this.currentMaterial();\n          if (lastMultiMaterial && lastMultiMaterial.groupEnd === -1) {\n            lastMultiMaterial.groupEnd = this.geometry.vertices.length / 3;\n            lastMultiMaterial.groupCount = lastMultiMaterial.groupEnd - lastMultiMaterial.groupStart;\n            lastMultiMaterial.inherited = false;\n          }\n          if (end && this.materials.length > 1) {\n            for (var mi = this.materials.length - 1; mi >= 0; mi--) {\n              if (this.materials[mi].groupCount <= 0) {\n                this.materials.splice(mi, 1);\n              }\n            }\n          }\n          if (end && this.materials.length === 0) {\n            this.materials.push({\n              name: \"\",\n              smooth: this.smooth\n            });\n          }\n          return lastMultiMaterial;\n        }\n      };\n      if (previousMaterial && previousMaterial.name && typeof previousMaterial.clone === \"function\") {\n        var declared = previousMaterial.clone(0);\n        declared.inherited = true;\n        this.object.materials.push(declared);\n      }\n      this.objects.push(this.object);\n    },\n    finalize: function finalize() {\n      if (this.object && typeof this.object._finalize === \"function\") {\n        this.object._finalize(true);\n      }\n    },\n    parseVertexIndex: function parseVertexIndex(value, len) {\n      var index = parseInt(value, 10);\n      return (index >= 0 ? index - 1 : index + len / 3) * 3;\n    },\n    parseNormalIndex: function parseNormalIndex(value, len) {\n      var index = parseInt(value, 10);\n      return (index >= 0 ? index - 1 : index + len / 3) * 3;\n    },\n    parseUVIndex: function parseUVIndex(value, len) {\n      var index = parseInt(value, 10);\n      return (index >= 0 ? index - 1 : index + len / 2) * 2;\n    },\n    addVertex: function addVertex(a, b, c) {\n      var src = this.vertices;\n      var dst = this.object.geometry.vertices;\n      dst.push(src[a + 0], src[a + 1], src[a + 2]);\n      dst.push(src[b + 0], src[b + 1], src[b + 2]);\n      dst.push(src[c + 0], src[c + 1], src[c + 2]);\n    },\n    addVertexPoint: function addVertexPoint(a) {\n      var src = this.vertices;\n      var dst = this.object.geometry.vertices;\n      dst.push(src[a + 0], src[a + 1], src[a + 2]);\n    },\n    addVertexLine: function addVertexLine(a) {\n      var src = this.vertices;\n      var dst = this.object.geometry.vertices;\n      dst.push(src[a + 0], src[a + 1], src[a + 2]);\n    },\n    addNormal: function addNormal(a, b, c) {\n      var src = this.normals;\n      var dst = this.object.geometry.normals;\n      dst.push(src[a + 0], src[a + 1], src[a + 2]);\n      dst.push(src[b + 0], src[b + 1], src[b + 2]);\n      dst.push(src[c + 0], src[c + 1], src[c + 2]);\n    },\n    addFaceNormal: function addFaceNormal(a, b, c) {\n      var src = this.vertices;\n      var dst = this.object.geometry.normals;\n      _vA.fromArray(src, a);\n      _vB.fromArray(src, b);\n      _vC.fromArray(src, c);\n      _cb.subVectors(_vC, _vB);\n      _ab.subVectors(_vA, _vB);\n      _cb.cross(_ab);\n      _cb.normalize();\n      dst.push(_cb.x, _cb.y, _cb.z);\n      dst.push(_cb.x, _cb.y, _cb.z);\n      dst.push(_cb.x, _cb.y, _cb.z);\n    },\n    addColor: function addColor(a, b, c) {\n      var src = this.colors;\n      var dst = this.object.geometry.colors;\n      if (src[a] !== void 0) dst.push(src[a + 0], src[a + 1], src[a + 2]);\n      if (src[b] !== void 0) dst.push(src[b + 0], src[b + 1], src[b + 2]);\n      if (src[c] !== void 0) dst.push(src[c + 0], src[c + 1], src[c + 2]);\n    },\n    addUV: function addUV(a, b, c) {\n      var src = this.uvs;\n      var dst = this.object.geometry.uvs;\n      dst.push(src[a + 0], src[a + 1]);\n      dst.push(src[b + 0], src[b + 1]);\n      dst.push(src[c + 0], src[c + 1]);\n    },\n    addDefaultUV: function addDefaultUV() {\n      var dst = this.object.geometry.uvs;\n      dst.push(0, 0);\n      dst.push(0, 0);\n      dst.push(0, 0);\n    },\n    addUVLine: function addUVLine(a) {\n      var src = this.uvs;\n      var dst = this.object.geometry.uvs;\n      dst.push(src[a + 0], src[a + 1]);\n    },\n    addFace: function addFace(a, b, c, ua, ub, uc, na, nb, nc) {\n      var vLen = this.vertices.length;\n      var ia = this.parseVertexIndex(a, vLen);\n      var ib = this.parseVertexIndex(b, vLen);\n      var ic = this.parseVertexIndex(c, vLen);\n      this.addVertex(ia, ib, ic);\n      this.addColor(ia, ib, ic);\n      if (na !== void 0 && na !== \"\") {\n        var nLen = this.normals.length;\n        ia = this.parseNormalIndex(na, nLen);\n        ib = this.parseNormalIndex(nb, nLen);\n        ic = this.parseNormalIndex(nc, nLen);\n        this.addNormal(ia, ib, ic);\n      } else {\n        this.addFaceNormal(ia, ib, ic);\n      }\n      if (ua !== void 0 && ua !== \"\") {\n        var uvLen = this.uvs.length;\n        ia = this.parseUVIndex(ua, uvLen);\n        ib = this.parseUVIndex(ub, uvLen);\n        ic = this.parseUVIndex(uc, uvLen);\n        this.addUV(ia, ib, ic);\n        this.object.geometry.hasUVIndices = true;\n      } else {\n        this.addDefaultUV();\n      }\n    },\n    addPointGeometry: function addPointGeometry(vertices) {\n      this.object.geometry.type = \"Points\";\n      var vLen = this.vertices.length;\n      for (var vi = 0, l = vertices.length; vi < l; vi++) {\n        var index = this.parseVertexIndex(vertices[vi], vLen);\n        this.addVertexPoint(index);\n        this.addColor(index);\n      }\n    },\n    addLineGeometry: function addLineGeometry(vertices, uvs) {\n      this.object.geometry.type = \"Line\";\n      var vLen = this.vertices.length;\n      var uvLen = this.uvs.length;\n      for (var vi = 0, l = vertices.length; vi < l; vi++) {\n        this.addVertexLine(this.parseVertexIndex(vertices[vi], vLen));\n      }\n      for (var uvi = 0, _l = uvs.length; uvi < _l; uvi++) {\n        this.addUVLine(this.parseUVIndex(uvs[uvi], uvLen));\n      }\n    }\n  };\n  state.startObject(\"\", false);\n  return state;\n}\nvar OBJLoader = /*#__PURE__*/function (_Loader) {\n  _inherits(OBJLoader, _Loader);\n  var _super = _createSuper(OBJLoader);\n  function OBJLoader(manager) {\n    var _this;\n    _classCallCheck(this, OBJLoader);\n    _this = _super.call(this, manager);\n    _this.materials = null;\n    return _this;\n  }\n  _createClass(OBJLoader, [{\n    key: \"load\",\n    value: function load(url, onLoad, onProgress, onError) {\n      var scope = this;\n      var loader = new FileLoader(this.manager);\n      loader.setPath(this.path);\n      loader.setRequestHeader(this.requestHeader);\n      loader.setWithCredentials(this.withCredentials);\n      loader.load(url, function (text) {\n        try {\n          onLoad(scope.parse(text));\n        } catch (e) {\n          if (onError) {\n            onError(e);\n          } else {\n            console.error(e);\n          }\n          scope.manager.itemError(url);\n        }\n      }, onProgress, onError);\n    }\n  }, {\n    key: \"setMaterials\",\n    value: function setMaterials(materials) {\n      this.materials = materials;\n      return this;\n    }\n  }, {\n    key: \"parse\",\n    value: function parse(text) {\n      var state = new ParserState();\n      if (text.indexOf(\"\\r\\n\") !== -1) {\n        text = text.replace(/\\r\\n/g, \"\\n\");\n      }\n      if (text.indexOf(\"\\\\\\n\") !== -1) {\n        text = text.replace(/\\\\\\n/g, \"\");\n      }\n      var lines = text.split(\"\\n\");\n      var line = \"\",\n        lineFirstChar = \"\";\n      var lineLength = 0;\n      var result = [];\n      var trimLeft = typeof \"\".trimLeft === \"function\";\n      for (var i = 0, l = lines.length; i < l; i++) {\n        line = lines[i];\n        line = trimLeft ? line.trimLeft() : line.trim();\n        lineLength = line.length;\n        if (lineLength === 0) continue;\n        lineFirstChar = line.charAt(0);\n        if (lineFirstChar === \"#\") continue;\n        if (lineFirstChar === \"v\") {\n          var data = line.split(/\\s+/);\n          switch (data[0]) {\n            case \"v\":\n              state.vertices.push(parseFloat(data[1]), parseFloat(data[2]), parseFloat(data[3]));\n              if (data.length >= 7) {\n                state.colors.push(parseFloat(data[4]), parseFloat(data[5]), parseFloat(data[6]));\n              } else {\n                state.colors.push(void 0, void 0, void 0);\n              }\n              break;\n            case \"vn\":\n              state.normals.push(parseFloat(data[1]), parseFloat(data[2]), parseFloat(data[3]));\n              break;\n            case \"vt\":\n              state.uvs.push(parseFloat(data[1]), parseFloat(data[2]));\n              break;\n          }\n        } else if (lineFirstChar === \"f\") {\n          var lineData = line.substr(1).trim();\n          var vertexData = lineData.split(/\\s+/);\n          var faceVertices = [];\n          for (var j = 0, jl = vertexData.length; j < jl; j++) {\n            var vertex = vertexData[j];\n            if (vertex.length > 0) {\n              var vertexParts = vertex.split(\"/\");\n              faceVertices.push(vertexParts);\n            }\n          }\n          var v1 = faceVertices[0];\n          for (var _j = 1, _jl = faceVertices.length - 1; _j < _jl; _j++) {\n            var v2 = faceVertices[_j];\n            var v3 = faceVertices[_j + 1];\n            state.addFace(v1[0], v2[0], v3[0], v1[1], v2[1], v3[1], v1[2], v2[2], v3[2]);\n          }\n        } else if (lineFirstChar === \"l\") {\n          var lineParts = line.substring(1).trim().split(\" \");\n          var lineVertices = [];\n          var lineUVs = [];\n          if (line.indexOf(\"/\") === -1) {\n            lineVertices = lineParts;\n          } else {\n            for (var li = 0, llen = lineParts.length; li < llen; li++) {\n              var parts = lineParts[li].split(\"/\");\n              if (parts[0] !== \"\") lineVertices.push(parts[0]);\n              if (parts[1] !== \"\") lineUVs.push(parts[1]);\n            }\n          }\n          state.addLineGeometry(lineVertices, lineUVs);\n        } else if (lineFirstChar === \"p\") {\n          var _lineData = line.substr(1).trim();\n          var pointData = _lineData.split(\" \");\n          state.addPointGeometry(pointData);\n        } else if ((result = _object_pattern.exec(line)) !== null) {\n          var name = (\" \" + result[0].substr(1).trim()).substr(1);\n          state.startObject(name);\n        } else if (_material_use_pattern.test(line)) {\n          state.object.startMaterial(line.substring(7).trim(), state.materialLibraries);\n        } else if (_material_library_pattern.test(line)) {\n          state.materialLibraries.push(line.substring(7).trim());\n        } else if (_map_use_pattern.test(line)) {\n          console.warn('THREE.OBJLoader: Rendering identifier \"usemap\" not supported. Textures must be defined in MTL files.');\n        } else if (lineFirstChar === \"s\") {\n          result = line.split(\" \");\n          if (result.length > 1) {\n            var value = result[1].trim().toLowerCase();\n            state.object.smooth = value !== \"0\" && value !== \"off\";\n          } else {\n            state.object.smooth = true;\n          }\n          var material = state.object.currentMaterial();\n          if (material) material.smooth = state.object.smooth;\n        } else {\n          if (line === \"\\0\") continue;\n          console.warn('THREE.OBJLoader: Unexpected line: \"' + line + '\"');\n        }\n      }\n      state.finalize();\n      var container = new Group();\n      container.materialLibraries = [].concat(state.materialLibraries);\n      var hasPrimitives = !(state.objects.length === 1 && state.objects[0].geometry.vertices.length === 0);\n      if (hasPrimitives === true) {\n        for (var _i = 0, _l2 = state.objects.length; _i < _l2; _i++) {\n          var object = state.objects[_i];\n          var geometry = object.geometry;\n          var materials = object.materials;\n          var isLine = geometry.type === \"Line\";\n          var isPoints = geometry.type === \"Points\";\n          var hasVertexColors = false;\n          if (geometry.vertices.length === 0) continue;\n          var buffergeometry = new BufferGeometry();\n          buffergeometry.setAttribute(\"position\", new Float32BufferAttribute(geometry.vertices, 3));\n          if (geometry.normals.length > 0) {\n            buffergeometry.setAttribute(\"normal\", new Float32BufferAttribute(geometry.normals, 3));\n          }\n          if (geometry.colors.length > 0) {\n            hasVertexColors = true;\n            buffergeometry.setAttribute(\"color\", new Float32BufferAttribute(geometry.colors, 3));\n          }\n          if (geometry.hasUVIndices === true) {\n            buffergeometry.setAttribute(\"uv\", new Float32BufferAttribute(geometry.uvs, 2));\n          }\n          var createdMaterials = [];\n          for (var mi = 0, miLen = materials.length; mi < miLen; mi++) {\n            var sourceMaterial = materials[mi];\n            var materialHash = sourceMaterial.name + \"_\" + sourceMaterial.smooth + \"_\" + hasVertexColors;\n            var _material = state.materials[materialHash];\n            if (this.materials !== null) {\n              _material = this.materials.create(sourceMaterial.name);\n              if (isLine && _material && !(_material instanceof LineBasicMaterial)) {\n                var materialLine = new LineBasicMaterial();\n                Material.prototype.copy.call(materialLine, _material);\n                materialLine.color.copy(_material.color);\n                _material = materialLine;\n              } else if (isPoints && _material && !(_material instanceof PointsMaterial)) {\n                var materialPoints = new PointsMaterial({\n                  size: 10,\n                  sizeAttenuation: false\n                });\n                Material.prototype.copy.call(materialPoints, _material);\n                materialPoints.color.copy(_material.color);\n                materialPoints.map = _material.map;\n                _material = materialPoints;\n              }\n            }\n            if (_material === void 0) {\n              if (isLine) {\n                _material = new LineBasicMaterial();\n              } else if (isPoints) {\n                _material = new PointsMaterial({\n                  size: 1,\n                  sizeAttenuation: false\n                });\n              } else {\n                _material = new MeshPhongMaterial();\n              }\n              _material.name = sourceMaterial.name;\n              _material.flatShading = sourceMaterial.smooth ? false : true;\n              _material.vertexColors = hasVertexColors;\n              state.materials[materialHash] = _material;\n            }\n            createdMaterials.push(_material);\n          }\n          var mesh = void 0;\n          if (createdMaterials.length > 1) {\n            for (var _mi = 0, _miLen = materials.length; _mi < _miLen; _mi++) {\n              var _sourceMaterial = materials[_mi];\n              buffergeometry.addGroup(_sourceMaterial.groupStart, _sourceMaterial.groupCount, _mi);\n            }\n            if (isLine) {\n              mesh = new LineSegments(buffergeometry, createdMaterials);\n            } else if (isPoints) {\n              mesh = new Points(buffergeometry, createdMaterials);\n            } else {\n              mesh = new Mesh(buffergeometry, createdMaterials);\n            }\n          } else {\n            if (isLine) {\n              mesh = new LineSegments(buffergeometry, createdMaterials[0]);\n            } else if (isPoints) {\n              mesh = new Points(buffergeometry, createdMaterials[0]);\n            } else {\n              mesh = new Mesh(buffergeometry, createdMaterials[0]);\n            }\n          }\n          mesh.name = object.name;\n          container.add(mesh);\n        }\n      } else {\n        if (state.vertices.length > 0) {\n          var _material2 = new PointsMaterial({\n            size: 1,\n            sizeAttenuation: false\n          });\n          var _buffergeometry = new BufferGeometry();\n          _buffergeometry.setAttribute(\"position\", new Float32BufferAttribute(state.vertices, 3));\n          if (state.colors.length > 0 && state.colors[0] !== void 0) {\n            _buffergeometry.setAttribute(\"color\", new Float32BufferAttribute(state.colors, 3));\n            _material2.vertexColors = true;\n          }\n          var points = new Points(_buffergeometry, _material2);\n          container.add(points);\n        }\n      }\n      return container;\n    }\n  }]);\n  return OBJLoader;\n}(Loader);\nexport { OBJLoader };","map":{"version":3,"names":["_object_pattern","_material_library_pattern","_material_use_pattern","_map_use_pattern","_vA","Vector3","_vB","_vC","_ab","_cb","ParserState","state","objects","object","vertices","normals","colors","uvs","materials","materialLibraries","startObject","name","fromDeclaration","previousMaterial","currentMaterial","_finalize","geometry","hasUVIndices","smooth","startMaterial","name2","libraries","previous","inherited","groupCount","splice","index","material","length","mtllib","Array","isArray","groupStart","groupEnd","clone","cloned","bind","push","end","lastMultiMaterial","mi","declared","finalize","parseVertexIndex","value","len","parseInt","parseNormalIndex","parseUVIndex","addVertex","a","b","c","src","dst","addVertexPoint","addVertexLine","addNormal","addFaceNormal","fromArray","subVectors","cross","normalize","x","y","z","addColor","addUV","addDefaultUV","addUVLine","addFace","ua","ub","uc","na","nb","nc","vLen","ia","ib","ic","nLen","uvLen","addPointGeometry","type","vi","l","addLineGeometry","uvi","OBJLoader","_Loader","_inherits","_super","_createSuper","manager","_this","_classCallCheck","call","_createClass","key","load","url","onLoad","onProgress","onError","scope","loader","FileLoader","setPath","path","setRequestHeader","requestHeader","setWithCredentials","withCredentials","text","parse","e","console","error","itemError","setMaterials","indexOf","replace","lines","split","line","lineFirstChar","lineLength","result","trimLeft","i","trim","charAt","data","parseFloat","lineData","substr","vertexData","faceVertices","j","jl","vertex","vertexParts","v1","v2","v3","lineParts","substring","lineVertices","lineUVs","li","llen","parts","pointData","exec","test","warn","toLowerCase","container","Group","concat","hasPrimitives","isLine","isPoints","hasVertexColors","buffergeometry","BufferGeometry","setAttribute","Float32BufferAttribute","createdMaterials","miLen","sourceMaterial","materialHash","create","LineBasicMaterial","materialLine","Material","prototype","copy","color","PointsMaterial","materialPoints","size","sizeAttenuation","map","MeshPhongMaterial","flatShading","vertexColors","mesh","addGroup","LineSegments","Points","Mesh","add","points","Loader"],"sources":["C:\\Users\\Nayyu\\Desktop\\skibidai-public-build\\node_modules\\src\\loaders\\OBJLoader.js"],"sourcesContent":["import {\n  BufferGeometry,\n  FileLoader,\n  Float32BufferAttribute,\n  Group,\n  LineBasicMaterial,\n  LineSegments,\n  Loader,\n  Material,\n  Mesh,\n  MeshPhongMaterial,\n  Points,\n  PointsMaterial,\n  Vector3,\n} from 'three'\n\n// o object_name | g group_name\nconst _object_pattern = /^[og]\\s*(.+)?/\n// mtllib file_reference\nconst _material_library_pattern = /^mtllib /\n// usemtl material_name\nconst _material_use_pattern = /^usemtl /\n// usemap map_name\nconst _map_use_pattern = /^usemap /\n\nconst _vA = new Vector3()\nconst _vB = new Vector3()\nconst _vC = new Vector3()\n\nconst _ab = new Vector3()\nconst _cb = new Vector3()\n\nfunction ParserState() {\n  const state = {\n    objects: [],\n    object: {},\n\n    vertices: [],\n    normals: [],\n    colors: [],\n    uvs: [],\n\n    materials: {},\n    materialLibraries: [],\n\n    startObject: function (name, fromDeclaration) {\n      // If the current object (initial from reset) is not from a g/o declaration in the parsed\n      // file. We need to use it for the first parsed g/o to keep things in sync.\n      if (this.object && this.object.fromDeclaration === false) {\n        this.object.name = name\n        this.object.fromDeclaration = fromDeclaration !== false\n        return\n      }\n\n      const previousMaterial =\n        this.object && typeof this.object.currentMaterial === 'function' ? this.object.currentMaterial() : undefined\n\n      if (this.object && typeof this.object._finalize === 'function') {\n        this.object._finalize(true)\n      }\n\n      this.object = {\n        name: name || '',\n        fromDeclaration: fromDeclaration !== false,\n\n        geometry: {\n          vertices: [],\n          normals: [],\n          colors: [],\n          uvs: [],\n          hasUVIndices: false,\n        },\n        materials: [],\n        smooth: true,\n\n        startMaterial: function (name, libraries) {\n          const previous = this._finalize(false)\n\n          // New usemtl declaration overwrites an inherited material, except if faces were declared\n          // after the material, then it must be preserved for proper MultiMaterial continuation.\n          if (previous && (previous.inherited || previous.groupCount <= 0)) {\n            this.materials.splice(previous.index, 1)\n          }\n\n          const material = {\n            index: this.materials.length,\n            name: name || '',\n            mtllib: Array.isArray(libraries) && libraries.length > 0 ? libraries[libraries.length - 1] : '',\n            smooth: previous !== undefined ? previous.smooth : this.smooth,\n            groupStart: previous !== undefined ? previous.groupEnd : 0,\n            groupEnd: -1,\n            groupCount: -1,\n            inherited: false,\n\n            clone: function (index) {\n              const cloned = {\n                index: typeof index === 'number' ? index : this.index,\n                name: this.name,\n                mtllib: this.mtllib,\n                smooth: this.smooth,\n                groupStart: 0,\n                groupEnd: -1,\n                groupCount: -1,\n                inherited: false,\n              }\n              cloned.clone = this.clone.bind(cloned)\n              return cloned\n            },\n          }\n\n          this.materials.push(material)\n\n          return material\n        },\n\n        currentMaterial: function () {\n          if (this.materials.length > 0) {\n            return this.materials[this.materials.length - 1]\n          }\n\n          return undefined\n        },\n\n        _finalize: function (end) {\n          const lastMultiMaterial = this.currentMaterial()\n          if (lastMultiMaterial && lastMultiMaterial.groupEnd === -1) {\n            lastMultiMaterial.groupEnd = this.geometry.vertices.length / 3\n            lastMultiMaterial.groupCount = lastMultiMaterial.groupEnd - lastMultiMaterial.groupStart\n            lastMultiMaterial.inherited = false\n          }\n\n          // Ignore objects tail materials if no face declarations followed them before a new o/g started.\n          if (end && this.materials.length > 1) {\n            for (let mi = this.materials.length - 1; mi >= 0; mi--) {\n              if (this.materials[mi].groupCount <= 0) {\n                this.materials.splice(mi, 1)\n              }\n            }\n          }\n\n          // Guarantee at least one empty material, this makes the creation later more straight forward.\n          if (end && this.materials.length === 0) {\n            this.materials.push({\n              name: '',\n              smooth: this.smooth,\n            })\n          }\n\n          return lastMultiMaterial\n        },\n      }\n\n      // Inherit previous objects material.\n      // Spec tells us that a declared material must be set to all objects until a new material is declared.\n      // If a usemtl declaration is encountered while this new object is being parsed, it will\n      // overwrite the inherited material. Exception being that there was already face declarations\n      // to the inherited material, then it will be preserved for proper MultiMaterial continuation.\n\n      if (previousMaterial && previousMaterial.name && typeof previousMaterial.clone === 'function') {\n        const declared = previousMaterial.clone(0)\n        declared.inherited = true\n        this.object.materials.push(declared)\n      }\n\n      this.objects.push(this.object)\n    },\n\n    finalize: function () {\n      if (this.object && typeof this.object._finalize === 'function') {\n        this.object._finalize(true)\n      }\n    },\n\n    parseVertexIndex: function (value, len) {\n      const index = parseInt(value, 10)\n      return (index >= 0 ? index - 1 : index + len / 3) * 3\n    },\n\n    parseNormalIndex: function (value, len) {\n      const index = parseInt(value, 10)\n      return (index >= 0 ? index - 1 : index + len / 3) * 3\n    },\n\n    parseUVIndex: function (value, len) {\n      const index = parseInt(value, 10)\n      return (index >= 0 ? index - 1 : index + len / 2) * 2\n    },\n\n    addVertex: function (a, b, c) {\n      const src = this.vertices\n      const dst = this.object.geometry.vertices\n\n      dst.push(src[a + 0], src[a + 1], src[a + 2])\n      dst.push(src[b + 0], src[b + 1], src[b + 2])\n      dst.push(src[c + 0], src[c + 1], src[c + 2])\n    },\n\n    addVertexPoint: function (a) {\n      const src = this.vertices\n      const dst = this.object.geometry.vertices\n\n      dst.push(src[a + 0], src[a + 1], src[a + 2])\n    },\n\n    addVertexLine: function (a) {\n      const src = this.vertices\n      const dst = this.object.geometry.vertices\n\n      dst.push(src[a + 0], src[a + 1], src[a + 2])\n    },\n\n    addNormal: function (a, b, c) {\n      const src = this.normals\n      const dst = this.object.geometry.normals\n\n      dst.push(src[a + 0], src[a + 1], src[a + 2])\n      dst.push(src[b + 0], src[b + 1], src[b + 2])\n      dst.push(src[c + 0], src[c + 1], src[c + 2])\n    },\n\n    addFaceNormal: function (a, b, c) {\n      const src = this.vertices\n      const dst = this.object.geometry.normals\n\n      _vA.fromArray(src, a)\n      _vB.fromArray(src, b)\n      _vC.fromArray(src, c)\n\n      _cb.subVectors(_vC, _vB)\n      _ab.subVectors(_vA, _vB)\n      _cb.cross(_ab)\n\n      _cb.normalize()\n\n      dst.push(_cb.x, _cb.y, _cb.z)\n      dst.push(_cb.x, _cb.y, _cb.z)\n      dst.push(_cb.x, _cb.y, _cb.z)\n    },\n\n    addColor: function (a, b, c) {\n      const src = this.colors\n      const dst = this.object.geometry.colors\n\n      if (src[a] !== undefined) dst.push(src[a + 0], src[a + 1], src[a + 2])\n      if (src[b] !== undefined) dst.push(src[b + 0], src[b + 1], src[b + 2])\n      if (src[c] !== undefined) dst.push(src[c + 0], src[c + 1], src[c + 2])\n    },\n\n    addUV: function (a, b, c) {\n      const src = this.uvs\n      const dst = this.object.geometry.uvs\n\n      dst.push(src[a + 0], src[a + 1])\n      dst.push(src[b + 0], src[b + 1])\n      dst.push(src[c + 0], src[c + 1])\n    },\n\n    addDefaultUV: function () {\n      const dst = this.object.geometry.uvs\n\n      dst.push(0, 0)\n      dst.push(0, 0)\n      dst.push(0, 0)\n    },\n\n    addUVLine: function (a) {\n      const src = this.uvs\n      const dst = this.object.geometry.uvs\n\n      dst.push(src[a + 0], src[a + 1])\n    },\n\n    addFace: function (a, b, c, ua, ub, uc, na, nb, nc) {\n      const vLen = this.vertices.length\n\n      let ia = this.parseVertexIndex(a, vLen)\n      let ib = this.parseVertexIndex(b, vLen)\n      let ic = this.parseVertexIndex(c, vLen)\n\n      this.addVertex(ia, ib, ic)\n      this.addColor(ia, ib, ic)\n\n      // normals\n\n      if (na !== undefined && na !== '') {\n        const nLen = this.normals.length\n\n        ia = this.parseNormalIndex(na, nLen)\n        ib = this.parseNormalIndex(nb, nLen)\n        ic = this.parseNormalIndex(nc, nLen)\n\n        this.addNormal(ia, ib, ic)\n      } else {\n        this.addFaceNormal(ia, ib, ic)\n      }\n\n      // uvs\n\n      if (ua !== undefined && ua !== '') {\n        const uvLen = this.uvs.length\n\n        ia = this.parseUVIndex(ua, uvLen)\n        ib = this.parseUVIndex(ub, uvLen)\n        ic = this.parseUVIndex(uc, uvLen)\n\n        this.addUV(ia, ib, ic)\n\n        this.object.geometry.hasUVIndices = true\n      } else {\n        // add placeholder values (for inconsistent face definitions)\n\n        this.addDefaultUV()\n      }\n    },\n\n    addPointGeometry: function (vertices) {\n      this.object.geometry.type = 'Points'\n\n      const vLen = this.vertices.length\n\n      for (let vi = 0, l = vertices.length; vi < l; vi++) {\n        const index = this.parseVertexIndex(vertices[vi], vLen)\n\n        this.addVertexPoint(index)\n        this.addColor(index)\n      }\n    },\n\n    addLineGeometry: function (vertices, uvs) {\n      this.object.geometry.type = 'Line'\n\n      const vLen = this.vertices.length\n      const uvLen = this.uvs.length\n\n      for (let vi = 0, l = vertices.length; vi < l; vi++) {\n        this.addVertexLine(this.parseVertexIndex(vertices[vi], vLen))\n      }\n\n      for (let uvi = 0, l = uvs.length; uvi < l; uvi++) {\n        this.addUVLine(this.parseUVIndex(uvs[uvi], uvLen))\n      }\n    },\n  }\n\n  state.startObject('', false)\n\n  return state\n}\n\n//\n\nclass OBJLoader extends Loader {\n  constructor(manager) {\n    super(manager)\n\n    this.materials = null\n  }\n\n  load(url, onLoad, onProgress, onError) {\n    const scope = this\n\n    const loader = new FileLoader(this.manager)\n    loader.setPath(this.path)\n    loader.setRequestHeader(this.requestHeader)\n    loader.setWithCredentials(this.withCredentials)\n    loader.load(\n      url,\n      function (text) {\n        try {\n          onLoad(scope.parse(text))\n        } catch (e) {\n          if (onError) {\n            onError(e)\n          } else {\n            console.error(e)\n          }\n\n          scope.manager.itemError(url)\n        }\n      },\n      onProgress,\n      onError,\n    )\n  }\n\n  setMaterials(materials) {\n    this.materials = materials\n\n    return this\n  }\n\n  parse(text) {\n    const state = new ParserState()\n\n    if (text.indexOf('\\r\\n') !== -1) {\n      // This is faster than String.split with regex that splits on both\n      text = text.replace(/\\r\\n/g, '\\n')\n    }\n\n    if (text.indexOf('\\\\\\n') !== -1) {\n      // join lines separated by a line continuation character (\\)\n      text = text.replace(/\\\\\\n/g, '')\n    }\n\n    const lines = text.split('\\n')\n    let line = '',\n      lineFirstChar = ''\n    let lineLength = 0\n    let result = []\n\n    // Faster to just trim left side of the line. Use if available.\n    const trimLeft = typeof ''.trimLeft === 'function'\n\n    for (let i = 0, l = lines.length; i < l; i++) {\n      line = lines[i]\n\n      line = trimLeft ? line.trimLeft() : line.trim()\n\n      lineLength = line.length\n\n      if (lineLength === 0) continue\n\n      lineFirstChar = line.charAt(0)\n\n      // @todo invoke passed in handler if any\n      if (lineFirstChar === '#') continue\n\n      if (lineFirstChar === 'v') {\n        const data = line.split(/\\s+/)\n\n        switch (data[0]) {\n          case 'v':\n            state.vertices.push(parseFloat(data[1]), parseFloat(data[2]), parseFloat(data[3]))\n            if (data.length >= 7) {\n              state.colors.push(parseFloat(data[4]), parseFloat(data[5]), parseFloat(data[6]))\n            } else {\n              // if no colors are defined, add placeholders so color and vertex indices match\n\n              state.colors.push(undefined, undefined, undefined)\n            }\n\n            break\n          case 'vn':\n            state.normals.push(parseFloat(data[1]), parseFloat(data[2]), parseFloat(data[3]))\n            break\n          case 'vt':\n            state.uvs.push(parseFloat(data[1]), parseFloat(data[2]))\n            break\n        }\n      } else if (lineFirstChar === 'f') {\n        const lineData = line.substr(1).trim()\n        const vertexData = lineData.split(/\\s+/)\n        const faceVertices = []\n\n        // Parse the face vertex data into an easy to work with format\n\n        for (let j = 0, jl = vertexData.length; j < jl; j++) {\n          const vertex = vertexData[j]\n\n          if (vertex.length > 0) {\n            const vertexParts = vertex.split('/')\n            faceVertices.push(vertexParts)\n          }\n        }\n\n        // Draw an edge between the first vertex and all subsequent vertices to form an n-gon\n\n        const v1 = faceVertices[0]\n\n        for (let j = 1, jl = faceVertices.length - 1; j < jl; j++) {\n          const v2 = faceVertices[j]\n          const v3 = faceVertices[j + 1]\n\n          state.addFace(v1[0], v2[0], v3[0], v1[1], v2[1], v3[1], v1[2], v2[2], v3[2])\n        }\n      } else if (lineFirstChar === 'l') {\n        const lineParts = line.substring(1).trim().split(' ')\n        let lineVertices = []\n        const lineUVs = []\n\n        if (line.indexOf('/') === -1) {\n          lineVertices = lineParts\n        } else {\n          for (let li = 0, llen = lineParts.length; li < llen; li++) {\n            const parts = lineParts[li].split('/')\n\n            if (parts[0] !== '') lineVertices.push(parts[0])\n            if (parts[1] !== '') lineUVs.push(parts[1])\n          }\n        }\n\n        state.addLineGeometry(lineVertices, lineUVs)\n      } else if (lineFirstChar === 'p') {\n        const lineData = line.substr(1).trim()\n        const pointData = lineData.split(' ')\n\n        state.addPointGeometry(pointData)\n      } else if ((result = _object_pattern.exec(line)) !== null) {\n        // o object_name\n        // or\n        // g group_name\n\n        // WORKAROUND: https://bugs.chromium.org/p/v8/issues/detail?id=2869\n        // let name = result[ 0 ].substr( 1 ).trim();\n        const name = (' ' + result[0].substr(1).trim()).substr(1)\n\n        state.startObject(name)\n      } else if (_material_use_pattern.test(line)) {\n        // material\n\n        state.object.startMaterial(line.substring(7).trim(), state.materialLibraries)\n      } else if (_material_library_pattern.test(line)) {\n        // mtl file\n\n        state.materialLibraries.push(line.substring(7).trim())\n      } else if (_map_use_pattern.test(line)) {\n        // the line is parsed but ignored since the loader assumes textures are defined MTL files\n        // (according to https://www.okino.com/conv/imp_wave.htm, 'usemap' is the old-style Wavefront texture reference method)\n\n        console.warn(\n          'THREE.OBJLoader: Rendering identifier \"usemap\" not supported. Textures must be defined in MTL files.',\n        )\n      } else if (lineFirstChar === 's') {\n        result = line.split(' ')\n\n        // smooth shading\n\n        // @todo Handle files that have varying smooth values for a set of faces inside one geometry,\n        // but does not define a usemtl for each face set.\n        // This should be detected and a dummy material created (later MultiMaterial and geometry groups).\n        // This requires some care to not create extra material on each smooth value for \"normal\" obj files.\n        // where explicit usemtl defines geometry groups.\n        // Example asset: examples/models/obj/cerberus/Cerberus.obj\n\n        /*\n         * http://paulbourke.net/dataformats/obj/\n         * or\n         * http://www.cs.utah.edu/~boulos/cs3505/obj_spec.pdf\n         *\n         * From chapter \"Grouping\" Syntax explanation \"s group_number\":\n         * \"group_number is the smoothing group number. To turn off smoothing groups, use a value of 0 or off.\n         * Polygonal elements use group numbers to put elements in different smoothing groups. For free-form\n         * surfaces, smoothing groups are either turned on or off; there is no difference between values greater\n         * than 0.\"\n         */\n        if (result.length > 1) {\n          const value = result[1].trim().toLowerCase()\n          state.object.smooth = value !== '0' && value !== 'off'\n        } else {\n          // ZBrush can produce \"s\" lines #11707\n          state.object.smooth = true\n        }\n\n        const material = state.object.currentMaterial()\n        if (material) material.smooth = state.object.smooth\n      } else {\n        // Handle null terminated files without exception\n        if (line === '\\0') continue\n\n        console.warn('THREE.OBJLoader: Unexpected line: \"' + line + '\"')\n      }\n    }\n\n    state.finalize()\n\n    const container = new Group()\n    container.materialLibraries = [].concat(state.materialLibraries)\n\n    const hasPrimitives = !(state.objects.length === 1 && state.objects[0].geometry.vertices.length === 0)\n\n    if (hasPrimitives === true) {\n      for (let i = 0, l = state.objects.length; i < l; i++) {\n        const object = state.objects[i]\n        const geometry = object.geometry\n        const materials = object.materials\n        const isLine = geometry.type === 'Line'\n        const isPoints = geometry.type === 'Points'\n        let hasVertexColors = false\n\n        // Skip o/g line declarations that did not follow with any faces\n        if (geometry.vertices.length === 0) continue\n\n        const buffergeometry = new BufferGeometry()\n\n        buffergeometry.setAttribute('position', new Float32BufferAttribute(geometry.vertices, 3))\n\n        if (geometry.normals.length > 0) {\n          buffergeometry.setAttribute('normal', new Float32BufferAttribute(geometry.normals, 3))\n        }\n\n        if (geometry.colors.length > 0) {\n          hasVertexColors = true\n          buffergeometry.setAttribute('color', new Float32BufferAttribute(geometry.colors, 3))\n        }\n\n        if (geometry.hasUVIndices === true) {\n          buffergeometry.setAttribute('uv', new Float32BufferAttribute(geometry.uvs, 2))\n        }\n\n        // Create materials\n\n        const createdMaterials = []\n\n        for (let mi = 0, miLen = materials.length; mi < miLen; mi++) {\n          const sourceMaterial = materials[mi]\n          const materialHash = sourceMaterial.name + '_' + sourceMaterial.smooth + '_' + hasVertexColors\n          let material = state.materials[materialHash]\n\n          if (this.materials !== null) {\n            material = this.materials.create(sourceMaterial.name)\n\n            // mtl etc. loaders probably can't create line materials correctly, copy properties to a line material.\n            if (isLine && material && !(material instanceof LineBasicMaterial)) {\n              const materialLine = new LineBasicMaterial()\n              Material.prototype.copy.call(materialLine, material)\n              materialLine.color.copy(material.color)\n              material = materialLine\n            } else if (isPoints && material && !(material instanceof PointsMaterial)) {\n              const materialPoints = new PointsMaterial({ size: 10, sizeAttenuation: false })\n              Material.prototype.copy.call(materialPoints, material)\n              materialPoints.color.copy(material.color)\n              materialPoints.map = material.map\n              material = materialPoints\n            }\n          }\n\n          if (material === undefined) {\n            if (isLine) {\n              material = new LineBasicMaterial()\n            } else if (isPoints) {\n              material = new PointsMaterial({ size: 1, sizeAttenuation: false })\n            } else {\n              material = new MeshPhongMaterial()\n            }\n\n            material.name = sourceMaterial.name\n            material.flatShading = sourceMaterial.smooth ? false : true\n            material.vertexColors = hasVertexColors\n\n            state.materials[materialHash] = material\n          }\n\n          createdMaterials.push(material)\n        }\n\n        // Create mesh\n\n        let mesh\n\n        if (createdMaterials.length > 1) {\n          for (let mi = 0, miLen = materials.length; mi < miLen; mi++) {\n            const sourceMaterial = materials[mi]\n            buffergeometry.addGroup(sourceMaterial.groupStart, sourceMaterial.groupCount, mi)\n          }\n\n          if (isLine) {\n            mesh = new LineSegments(buffergeometry, createdMaterials)\n          } else if (isPoints) {\n            mesh = new Points(buffergeometry, createdMaterials)\n          } else {\n            mesh = new Mesh(buffergeometry, createdMaterials)\n          }\n        } else {\n          if (isLine) {\n            mesh = new LineSegments(buffergeometry, createdMaterials[0])\n          } else if (isPoints) {\n            mesh = new Points(buffergeometry, createdMaterials[0])\n          } else {\n            mesh = new Mesh(buffergeometry, createdMaterials[0])\n          }\n        }\n\n        mesh.name = object.name\n\n        container.add(mesh)\n      }\n    } else {\n      // if there is only the default parser state object with no geometry data, interpret data as point cloud\n\n      if (state.vertices.length > 0) {\n        const material = new PointsMaterial({ size: 1, sizeAttenuation: false })\n\n        const buffergeometry = new BufferGeometry()\n\n        buffergeometry.setAttribute('position', new Float32BufferAttribute(state.vertices, 3))\n\n        if (state.colors.length > 0 && state.colors[0] !== undefined) {\n          buffergeometry.setAttribute('color', new Float32BufferAttribute(state.colors, 3))\n          material.vertexColors = true\n        }\n\n        const points = new Points(buffergeometry, material)\n        container.add(points)\n      }\n    }\n\n    return container\n  }\n}\n\nexport { OBJLoader }\n"],"mappings":";;;;;AAiBA,IAAMA,eAAA,GAAkB;AAExB,IAAMC,yBAAA,GAA4B;AAElC,IAAMC,qBAAA,GAAwB;AAE9B,IAAMC,gBAAA,GAAmB;AAEzB,IAAMC,GAAA,GAAM,IAAIC,OAAA,CAAS;AACzB,IAAMC,GAAA,GAAM,IAAID,OAAA,CAAS;AACzB,IAAME,GAAA,GAAM,IAAIF,OAAA,CAAS;AAEzB,IAAMG,GAAA,GAAM,IAAIH,OAAA,CAAS;AACzB,IAAMI,GAAA,GAAM,IAAIJ,OAAA,CAAS;AAEzB,SAASK,YAAA,EAAc;EACrB,IAAMC,KAAA,GAAQ;IACZC,OAAA,EAAS,EAAE;IACXC,MAAA,EAAQ,CAAE;IAEVC,QAAA,EAAU,EAAE;IACZC,OAAA,EAAS,EAAE;IACXC,MAAA,EAAQ,EAAE;IACVC,GAAA,EAAK,EAAE;IAEPC,SAAA,EAAW,CAAE;IACbC,iBAAA,EAAmB,EAAE;IAErBC,WAAA,EAAa,SAAAA,YAAUC,IAAA,EAAMC,eAAA,EAAiB;MAG5C,IAAI,KAAKT,MAAA,IAAU,KAAKA,MAAA,CAAOS,eAAA,KAAoB,OAAO;QACxD,KAAKT,MAAA,CAAOQ,IAAA,GAAOA,IAAA;QACnB,KAAKR,MAAA,CAAOS,eAAA,GAAkBA,eAAA,KAAoB;QAClD;MACD;MAED,IAAMC,gBAAA,GACJ,KAAKV,MAAA,IAAU,OAAO,KAAKA,MAAA,CAAOW,eAAA,KAAoB,aAAa,KAAKX,MAAA,CAAOW,eAAA,CAAe,IAAK;MAErG,IAAI,KAAKX,MAAA,IAAU,OAAO,KAAKA,MAAA,CAAOY,SAAA,KAAc,YAAY;QAC9D,KAAKZ,MAAA,CAAOY,SAAA,CAAU,IAAI;MAC3B;MAED,KAAKZ,MAAA,GAAS;QACZQ,IAAA,EAAMA,IAAA,IAAQ;QACdC,eAAA,EAAiBA,eAAA,KAAoB;QAErCI,QAAA,EAAU;UACRZ,QAAA,EAAU,EAAE;UACZC,OAAA,EAAS,EAAE;UACXC,MAAA,EAAQ,EAAE;UACVC,GAAA,EAAK,EAAE;UACPU,YAAA,EAAc;QACf;QACDT,SAAA,EAAW,EAAE;QACbU,MAAA,EAAQ;QAERC,aAAA,EAAe,SAAAA,cAAUC,KAAA,EAAMC,SAAA,EAAW;UACxC,IAAMC,QAAA,GAAW,KAAKP,SAAA,CAAU,KAAK;UAIrC,IAAIO,QAAA,KAAaA,QAAA,CAASC,SAAA,IAAaD,QAAA,CAASE,UAAA,IAAc,IAAI;YAChE,KAAKhB,SAAA,CAAUiB,MAAA,CAAOH,QAAA,CAASI,KAAA,EAAO,CAAC;UACxC;UAED,IAAMC,QAAA,GAAW;YACfD,KAAA,EAAO,KAAKlB,SAAA,CAAUoB,MAAA;YACtBjB,IAAA,EAAMS,KAAA,IAAQ;YACdS,MAAA,EAAQC,KAAA,CAAMC,OAAA,CAAQV,SAAS,KAAKA,SAAA,CAAUO,MAAA,GAAS,IAAIP,SAAA,CAAUA,SAAA,CAAUO,MAAA,GAAS,CAAC,IAAI;YAC7FV,MAAA,EAAQI,QAAA,KAAa,SAAYA,QAAA,CAASJ,MAAA,GAAS,KAAKA,MAAA;YACxDc,UAAA,EAAYV,QAAA,KAAa,SAAYA,QAAA,CAASW,QAAA,GAAW;YACzDA,QAAA,EAAU;YACVT,UAAA,EAAY;YACZD,SAAA,EAAW;YAEXW,KAAA,EAAO,SAAAA,MAAUR,KAAA,EAAO;cACtB,IAAMS,MAAA,GAAS;gBACbT,KAAA,EAAO,OAAOA,KAAA,KAAU,WAAWA,KAAA,GAAQ,KAAKA,KAAA;gBAChDf,IAAA,EAAM,KAAKA,IAAA;gBACXkB,MAAA,EAAQ,KAAKA,MAAA;gBACbX,MAAA,EAAQ,KAAKA,MAAA;gBACbc,UAAA,EAAY;gBACZC,QAAA,EAAU;gBACVT,UAAA,EAAY;gBACZD,SAAA,EAAW;cACZ;cACDY,MAAA,CAAOD,KAAA,GAAQ,KAAKA,KAAA,CAAME,IAAA,CAAKD,MAAM;cACrC,OAAOA,MAAA;YACR;UACF;UAED,KAAK3B,SAAA,CAAU6B,IAAA,CAAKV,QAAQ;UAE5B,OAAOA,QAAA;QACR;QAEDb,eAAA,EAAiB,SAAAA,gBAAA,EAAY;UAC3B,IAAI,KAAKN,SAAA,CAAUoB,MAAA,GAAS,GAAG;YAC7B,OAAO,KAAKpB,SAAA,CAAU,KAAKA,SAAA,CAAUoB,MAAA,GAAS,CAAC;UAChD;UAED,OAAO;QACR;QAEDb,SAAA,EAAW,SAAAA,UAAUuB,GAAA,EAAK;UACxB,IAAMC,iBAAA,GAAoB,KAAKzB,eAAA,CAAiB;UAChD,IAAIyB,iBAAA,IAAqBA,iBAAA,CAAkBN,QAAA,KAAa,IAAI;YAC1DM,iBAAA,CAAkBN,QAAA,GAAW,KAAKjB,QAAA,CAASZ,QAAA,CAASwB,MAAA,GAAS;YAC7DW,iBAAA,CAAkBf,UAAA,GAAae,iBAAA,CAAkBN,QAAA,GAAWM,iBAAA,CAAkBP,UAAA;YAC9EO,iBAAA,CAAkBhB,SAAA,GAAY;UAC/B;UAGD,IAAIe,GAAA,IAAO,KAAK9B,SAAA,CAAUoB,MAAA,GAAS,GAAG;YACpC,SAASY,EAAA,GAAK,KAAKhC,SAAA,CAAUoB,MAAA,GAAS,GAAGY,EAAA,IAAM,GAAGA,EAAA,IAAM;cACtD,IAAI,KAAKhC,SAAA,CAAUgC,EAAE,EAAEhB,UAAA,IAAc,GAAG;gBACtC,KAAKhB,SAAA,CAAUiB,MAAA,CAAOe,EAAA,EAAI,CAAC;cAC5B;YACF;UACF;UAGD,IAAIF,GAAA,IAAO,KAAK9B,SAAA,CAAUoB,MAAA,KAAW,GAAG;YACtC,KAAKpB,SAAA,CAAU6B,IAAA,CAAK;cAClB1B,IAAA,EAAM;cACNO,MAAA,EAAQ,KAAKA;YAC3B,CAAa;UACF;UAED,OAAOqB,iBAAA;QACR;MACF;MAQD,IAAI1B,gBAAA,IAAoBA,gBAAA,CAAiBF,IAAA,IAAQ,OAAOE,gBAAA,CAAiBqB,KAAA,KAAU,YAAY;QAC7F,IAAMO,QAAA,GAAW5B,gBAAA,CAAiBqB,KAAA,CAAM,CAAC;QACzCO,QAAA,CAASlB,SAAA,GAAY;QACrB,KAAKpB,MAAA,CAAOK,SAAA,CAAU6B,IAAA,CAAKI,QAAQ;MACpC;MAED,KAAKvC,OAAA,CAAQmC,IAAA,CAAK,KAAKlC,MAAM;IAC9B;IAEDuC,QAAA,EAAU,SAAAA,SAAA,EAAY;MACpB,IAAI,KAAKvC,MAAA,IAAU,OAAO,KAAKA,MAAA,CAAOY,SAAA,KAAc,YAAY;QAC9D,KAAKZ,MAAA,CAAOY,SAAA,CAAU,IAAI;MAC3B;IACF;IAED4B,gBAAA,EAAkB,SAAAA,iBAAUC,KAAA,EAAOC,GAAA,EAAK;MACtC,IAAMnB,KAAA,GAAQoB,QAAA,CAASF,KAAA,EAAO,EAAE;MAChC,QAAQlB,KAAA,IAAS,IAAIA,KAAA,GAAQ,IAAIA,KAAA,GAAQmB,GAAA,GAAM,KAAK;IACrD;IAEDE,gBAAA,EAAkB,SAAAA,iBAAUH,KAAA,EAAOC,GAAA,EAAK;MACtC,IAAMnB,KAAA,GAAQoB,QAAA,CAASF,KAAA,EAAO,EAAE;MAChC,QAAQlB,KAAA,IAAS,IAAIA,KAAA,GAAQ,IAAIA,KAAA,GAAQmB,GAAA,GAAM,KAAK;IACrD;IAEDG,YAAA,EAAc,SAAAA,aAAUJ,KAAA,EAAOC,GAAA,EAAK;MAClC,IAAMnB,KAAA,GAAQoB,QAAA,CAASF,KAAA,EAAO,EAAE;MAChC,QAAQlB,KAAA,IAAS,IAAIA,KAAA,GAAQ,IAAIA,KAAA,GAAQmB,GAAA,GAAM,KAAK;IACrD;IAEDI,SAAA,EAAW,SAAAA,UAAUC,CAAA,EAAGC,CAAA,EAAGC,CAAA,EAAG;MAC5B,IAAMC,GAAA,GAAM,KAAKjD,QAAA;MACjB,IAAMkD,GAAA,GAAM,KAAKnD,MAAA,CAAOa,QAAA,CAASZ,QAAA;MAEjCkD,GAAA,CAAIjB,IAAA,CAAKgB,GAAA,CAAIH,CAAA,GAAI,CAAC,GAAGG,GAAA,CAAIH,CAAA,GAAI,CAAC,GAAGG,GAAA,CAAIH,CAAA,GAAI,CAAC,CAAC;MAC3CI,GAAA,CAAIjB,IAAA,CAAKgB,GAAA,CAAIF,CAAA,GAAI,CAAC,GAAGE,GAAA,CAAIF,CAAA,GAAI,CAAC,GAAGE,GAAA,CAAIF,CAAA,GAAI,CAAC,CAAC;MAC3CG,GAAA,CAAIjB,IAAA,CAAKgB,GAAA,CAAID,CAAA,GAAI,CAAC,GAAGC,GAAA,CAAID,CAAA,GAAI,CAAC,GAAGC,GAAA,CAAID,CAAA,GAAI,CAAC,CAAC;IAC5C;IAEDG,cAAA,EAAgB,SAAAA,eAAUL,CAAA,EAAG;MAC3B,IAAMG,GAAA,GAAM,KAAKjD,QAAA;MACjB,IAAMkD,GAAA,GAAM,KAAKnD,MAAA,CAAOa,QAAA,CAASZ,QAAA;MAEjCkD,GAAA,CAAIjB,IAAA,CAAKgB,GAAA,CAAIH,CAAA,GAAI,CAAC,GAAGG,GAAA,CAAIH,CAAA,GAAI,CAAC,GAAGG,GAAA,CAAIH,CAAA,GAAI,CAAC,CAAC;IAC5C;IAEDM,aAAA,EAAe,SAAAA,cAAUN,CAAA,EAAG;MAC1B,IAAMG,GAAA,GAAM,KAAKjD,QAAA;MACjB,IAAMkD,GAAA,GAAM,KAAKnD,MAAA,CAAOa,QAAA,CAASZ,QAAA;MAEjCkD,GAAA,CAAIjB,IAAA,CAAKgB,GAAA,CAAIH,CAAA,GAAI,CAAC,GAAGG,GAAA,CAAIH,CAAA,GAAI,CAAC,GAAGG,GAAA,CAAIH,CAAA,GAAI,CAAC,CAAC;IAC5C;IAEDO,SAAA,EAAW,SAAAA,UAAUP,CAAA,EAAGC,CAAA,EAAGC,CAAA,EAAG;MAC5B,IAAMC,GAAA,GAAM,KAAKhD,OAAA;MACjB,IAAMiD,GAAA,GAAM,KAAKnD,MAAA,CAAOa,QAAA,CAASX,OAAA;MAEjCiD,GAAA,CAAIjB,IAAA,CAAKgB,GAAA,CAAIH,CAAA,GAAI,CAAC,GAAGG,GAAA,CAAIH,CAAA,GAAI,CAAC,GAAGG,GAAA,CAAIH,CAAA,GAAI,CAAC,CAAC;MAC3CI,GAAA,CAAIjB,IAAA,CAAKgB,GAAA,CAAIF,CAAA,GAAI,CAAC,GAAGE,GAAA,CAAIF,CAAA,GAAI,CAAC,GAAGE,GAAA,CAAIF,CAAA,GAAI,CAAC,CAAC;MAC3CG,GAAA,CAAIjB,IAAA,CAAKgB,GAAA,CAAID,CAAA,GAAI,CAAC,GAAGC,GAAA,CAAID,CAAA,GAAI,CAAC,GAAGC,GAAA,CAAID,CAAA,GAAI,CAAC,CAAC;IAC5C;IAEDM,aAAA,EAAe,SAAAA,cAAUR,CAAA,EAAGC,CAAA,EAAGC,CAAA,EAAG;MAChC,IAAMC,GAAA,GAAM,KAAKjD,QAAA;MACjB,IAAMkD,GAAA,GAAM,KAAKnD,MAAA,CAAOa,QAAA,CAASX,OAAA;MAEjCX,GAAA,CAAIiE,SAAA,CAAUN,GAAA,EAAKH,CAAC;MACpBtD,GAAA,CAAI+D,SAAA,CAAUN,GAAA,EAAKF,CAAC;MACpBtD,GAAA,CAAI8D,SAAA,CAAUN,GAAA,EAAKD,CAAC;MAEpBrD,GAAA,CAAI6D,UAAA,CAAW/D,GAAA,EAAKD,GAAG;MACvBE,GAAA,CAAI8D,UAAA,CAAWlE,GAAA,EAAKE,GAAG;MACvBG,GAAA,CAAI8D,KAAA,CAAM/D,GAAG;MAEbC,GAAA,CAAI+D,SAAA,CAAW;MAEfR,GAAA,CAAIjB,IAAA,CAAKtC,GAAA,CAAIgE,CAAA,EAAGhE,GAAA,CAAIiE,CAAA,EAAGjE,GAAA,CAAIkE,CAAC;MAC5BX,GAAA,CAAIjB,IAAA,CAAKtC,GAAA,CAAIgE,CAAA,EAAGhE,GAAA,CAAIiE,CAAA,EAAGjE,GAAA,CAAIkE,CAAC;MAC5BX,GAAA,CAAIjB,IAAA,CAAKtC,GAAA,CAAIgE,CAAA,EAAGhE,GAAA,CAAIiE,CAAA,EAAGjE,GAAA,CAAIkE,CAAC;IAC7B;IAEDC,QAAA,EAAU,SAAAA,SAAUhB,CAAA,EAAGC,CAAA,EAAGC,CAAA,EAAG;MAC3B,IAAMC,GAAA,GAAM,KAAK/C,MAAA;MACjB,IAAMgD,GAAA,GAAM,KAAKnD,MAAA,CAAOa,QAAA,CAASV,MAAA;MAEjC,IAAI+C,GAAA,CAAIH,CAAC,MAAM,QAAWI,GAAA,CAAIjB,IAAA,CAAKgB,GAAA,CAAIH,CAAA,GAAI,CAAC,GAAGG,GAAA,CAAIH,CAAA,GAAI,CAAC,GAAGG,GAAA,CAAIH,CAAA,GAAI,CAAC,CAAC;MACrE,IAAIG,GAAA,CAAIF,CAAC,MAAM,QAAWG,GAAA,CAAIjB,IAAA,CAAKgB,GAAA,CAAIF,CAAA,GAAI,CAAC,GAAGE,GAAA,CAAIF,CAAA,GAAI,CAAC,GAAGE,GAAA,CAAIF,CAAA,GAAI,CAAC,CAAC;MACrE,IAAIE,GAAA,CAAID,CAAC,MAAM,QAAWE,GAAA,CAAIjB,IAAA,CAAKgB,GAAA,CAAID,CAAA,GAAI,CAAC,GAAGC,GAAA,CAAID,CAAA,GAAI,CAAC,GAAGC,GAAA,CAAID,CAAA,GAAI,CAAC,CAAC;IACtE;IAEDe,KAAA,EAAO,SAAAA,MAAUjB,CAAA,EAAGC,CAAA,EAAGC,CAAA,EAAG;MACxB,IAAMC,GAAA,GAAM,KAAK9C,GAAA;MACjB,IAAM+C,GAAA,GAAM,KAAKnD,MAAA,CAAOa,QAAA,CAAST,GAAA;MAEjC+C,GAAA,CAAIjB,IAAA,CAAKgB,GAAA,CAAIH,CAAA,GAAI,CAAC,GAAGG,GAAA,CAAIH,CAAA,GAAI,CAAC,CAAC;MAC/BI,GAAA,CAAIjB,IAAA,CAAKgB,GAAA,CAAIF,CAAA,GAAI,CAAC,GAAGE,GAAA,CAAIF,CAAA,GAAI,CAAC,CAAC;MAC/BG,GAAA,CAAIjB,IAAA,CAAKgB,GAAA,CAAID,CAAA,GAAI,CAAC,GAAGC,GAAA,CAAID,CAAA,GAAI,CAAC,CAAC;IAChC;IAEDgB,YAAA,EAAc,SAAAA,aAAA,EAAY;MACxB,IAAMd,GAAA,GAAM,KAAKnD,MAAA,CAAOa,QAAA,CAAST,GAAA;MAEjC+C,GAAA,CAAIjB,IAAA,CAAK,GAAG,CAAC;MACbiB,GAAA,CAAIjB,IAAA,CAAK,GAAG,CAAC;MACbiB,GAAA,CAAIjB,IAAA,CAAK,GAAG,CAAC;IACd;IAEDgC,SAAA,EAAW,SAAAA,UAAUnB,CAAA,EAAG;MACtB,IAAMG,GAAA,GAAM,KAAK9C,GAAA;MACjB,IAAM+C,GAAA,GAAM,KAAKnD,MAAA,CAAOa,QAAA,CAAST,GAAA;MAEjC+C,GAAA,CAAIjB,IAAA,CAAKgB,GAAA,CAAIH,CAAA,GAAI,CAAC,GAAGG,GAAA,CAAIH,CAAA,GAAI,CAAC,CAAC;IAChC;IAEDoB,OAAA,EAAS,SAAAA,QAAUpB,CAAA,EAAGC,CAAA,EAAGC,CAAA,EAAGmB,EAAA,EAAIC,EAAA,EAAIC,EAAA,EAAIC,EAAA,EAAIC,EAAA,EAAIC,EAAA,EAAI;MAClD,IAAMC,IAAA,GAAO,KAAKzE,QAAA,CAASwB,MAAA;MAE3B,IAAIkD,EAAA,GAAK,KAAKnC,gBAAA,CAAiBO,CAAA,EAAG2B,IAAI;MACtC,IAAIE,EAAA,GAAK,KAAKpC,gBAAA,CAAiBQ,CAAA,EAAG0B,IAAI;MACtC,IAAIG,EAAA,GAAK,KAAKrC,gBAAA,CAAiBS,CAAA,EAAGyB,IAAI;MAEtC,KAAK5B,SAAA,CAAU6B,EAAA,EAAIC,EAAA,EAAIC,EAAE;MACzB,KAAKd,QAAA,CAASY,EAAA,EAAIC,EAAA,EAAIC,EAAE;MAIxB,IAAIN,EAAA,KAAO,UAAaA,EAAA,KAAO,IAAI;QACjC,IAAMO,IAAA,GAAO,KAAK5E,OAAA,CAAQuB,MAAA;QAE1BkD,EAAA,GAAK,KAAK/B,gBAAA,CAAiB2B,EAAA,EAAIO,IAAI;QACnCF,EAAA,GAAK,KAAKhC,gBAAA,CAAiB4B,EAAA,EAAIM,IAAI;QACnCD,EAAA,GAAK,KAAKjC,gBAAA,CAAiB6B,EAAA,EAAIK,IAAI;QAEnC,KAAKxB,SAAA,CAAUqB,EAAA,EAAIC,EAAA,EAAIC,EAAE;MACjC,OAAa;QACL,KAAKtB,aAAA,CAAcoB,EAAA,EAAIC,EAAA,EAAIC,EAAE;MAC9B;MAID,IAAIT,EAAA,KAAO,UAAaA,EAAA,KAAO,IAAI;QACjC,IAAMW,KAAA,GAAQ,KAAK3E,GAAA,CAAIqB,MAAA;QAEvBkD,EAAA,GAAK,KAAK9B,YAAA,CAAauB,EAAA,EAAIW,KAAK;QAChCH,EAAA,GAAK,KAAK/B,YAAA,CAAawB,EAAA,EAAIU,KAAK;QAChCF,EAAA,GAAK,KAAKhC,YAAA,CAAayB,EAAA,EAAIS,KAAK;QAEhC,KAAKf,KAAA,CAAMW,EAAA,EAAIC,EAAA,EAAIC,EAAE;QAErB,KAAK7E,MAAA,CAAOa,QAAA,CAASC,YAAA,GAAe;MAC5C,OAAa;QAGL,KAAKmD,YAAA,CAAc;MACpB;IACF;IAEDe,gBAAA,EAAkB,SAAAA,iBAAU/E,QAAA,EAAU;MACpC,KAAKD,MAAA,CAAOa,QAAA,CAASoE,IAAA,GAAO;MAE5B,IAAMP,IAAA,GAAO,KAAKzE,QAAA,CAASwB,MAAA;MAE3B,SAASyD,EAAA,GAAK,GAAGC,CAAA,GAAIlF,QAAA,CAASwB,MAAA,EAAQyD,EAAA,GAAKC,CAAA,EAAGD,EAAA,IAAM;QAClD,IAAM3D,KAAA,GAAQ,KAAKiB,gBAAA,CAAiBvC,QAAA,CAASiF,EAAE,GAAGR,IAAI;QAEtD,KAAKtB,cAAA,CAAe7B,KAAK;QACzB,KAAKwC,QAAA,CAASxC,KAAK;MACpB;IACF;IAED6D,eAAA,EAAiB,SAAAA,gBAAUnF,QAAA,EAAUG,GAAA,EAAK;MACxC,KAAKJ,MAAA,CAAOa,QAAA,CAASoE,IAAA,GAAO;MAE5B,IAAMP,IAAA,GAAO,KAAKzE,QAAA,CAASwB,MAAA;MAC3B,IAAMsD,KAAA,GAAQ,KAAK3E,GAAA,CAAIqB,MAAA;MAEvB,SAASyD,EAAA,GAAK,GAAGC,CAAA,GAAIlF,QAAA,CAASwB,MAAA,EAAQyD,EAAA,GAAKC,CAAA,EAAGD,EAAA,IAAM;QAClD,KAAK7B,aAAA,CAAc,KAAKb,gBAAA,CAAiBvC,QAAA,CAASiF,EAAE,GAAGR,IAAI,CAAC;MAC7D;MAED,SAASW,GAAA,GAAM,GAAGF,EAAA,GAAI/E,GAAA,CAAIqB,MAAA,EAAQ4D,GAAA,GAAMF,EAAA,EAAGE,GAAA,IAAO;QAChD,KAAKnB,SAAA,CAAU,KAAKrB,YAAA,CAAazC,GAAA,CAAIiF,GAAG,GAAGN,KAAK,CAAC;MAClD;IACF;EACF;EAEDjF,KAAA,CAAMS,WAAA,CAAY,IAAI,KAAK;EAE3B,OAAOT,KAAA;AACT;AAAA,IAIMwF,SAAA,0BAAAC,OAAA;EAAAC,SAAA,CAAAF,SAAA,EAAAC,OAAA;EAAA,IAAAE,MAAA,GAAAC,YAAA,CAAAJ,SAAA;EACJ,SAAAA,UAAYK,OAAA,EAAS;IAAA,IAAAC,KAAA;IAAAC,eAAA,OAAAP,SAAA;IACnBM,KAAA,GAAAH,MAAA,CAAAK,IAAA,OAAMH,OAAO;IAEbC,KAAA,CAAKvF,SAAA,GAAY;IAAA,OAAAuF,KAAA;EAClB;EAAAG,YAAA,CAAAT,SAAA;IAAAU,GAAA;IAAAvD,KAAA,EAED,SAAAwD,KAAKC,GAAA,EAAKC,MAAA,EAAQC,UAAA,EAAYC,OAAA,EAAS;MACrC,IAAMC,KAAA,GAAQ;MAEd,IAAMC,MAAA,GAAS,IAAIC,UAAA,CAAW,KAAKb,OAAO;MAC1CY,MAAA,CAAOE,OAAA,CAAQ,KAAKC,IAAI;MACxBH,MAAA,CAAOI,gBAAA,CAAiB,KAAKC,aAAa;MAC1CL,MAAA,CAAOM,kBAAA,CAAmB,KAAKC,eAAe;MAC9CP,MAAA,CAAON,IAAA,CACLC,GAAA,EACA,UAAUa,IAAA,EAAM;QACd,IAAI;UACFZ,MAAA,CAAOG,KAAA,CAAMU,KAAA,CAAMD,IAAI,CAAC;QACzB,SAAQE,CAAA,EAAP;UACA,IAAIZ,OAAA,EAAS;YACXA,OAAA,CAAQY,CAAC;UACrB,OAAiB;YACLC,OAAA,CAAQC,KAAA,CAAMF,CAAC;UAChB;UAEDX,KAAA,CAAMX,OAAA,CAAQyB,SAAA,CAAUlB,GAAG;QAC5B;MACF,GACDE,UAAA,EACAC,OACD;IACF;EAAA;IAAAL,GAAA;IAAAvD,KAAA,EAED,SAAA4E,aAAahH,SAAA,EAAW;MACtB,KAAKA,SAAA,GAAYA,SAAA;MAEjB,OAAO;IACR;EAAA;IAAA2F,GAAA;IAAAvD,KAAA,EAED,SAAAuE,MAAMD,IAAA,EAAM;MACV,IAAMjH,KAAA,GAAQ,IAAID,WAAA,CAAa;MAE/B,IAAIkH,IAAA,CAAKO,OAAA,CAAQ,MAAM,MAAM,IAAI;QAE/BP,IAAA,GAAOA,IAAA,CAAKQ,OAAA,CAAQ,SAAS,IAAI;MAClC;MAED,IAAIR,IAAA,CAAKO,OAAA,CAAQ,MAAM,MAAM,IAAI;QAE/BP,IAAA,GAAOA,IAAA,CAAKQ,OAAA,CAAQ,SAAS,EAAE;MAChC;MAED,IAAMC,KAAA,GAAQT,IAAA,CAAKU,KAAA,CAAM,IAAI;MAC7B,IAAIC,IAAA,GAAO;QACTC,aAAA,GAAgB;MAClB,IAAIC,UAAA,GAAa;MACjB,IAAIC,MAAA,GAAS,EAAE;MAGf,IAAMC,QAAA,GAAW,OAAO,GAAGA,QAAA,KAAa;MAExC,SAASC,CAAA,GAAI,GAAG5C,CAAA,GAAIqC,KAAA,CAAM/F,MAAA,EAAQsG,CAAA,GAAI5C,CAAA,EAAG4C,CAAA,IAAK;QAC5CL,IAAA,GAAOF,KAAA,CAAMO,CAAC;QAEdL,IAAA,GAAOI,QAAA,GAAWJ,IAAA,CAAKI,QAAA,CAAQ,IAAKJ,IAAA,CAAKM,IAAA,CAAM;QAE/CJ,UAAA,GAAaF,IAAA,CAAKjG,MAAA;QAElB,IAAImG,UAAA,KAAe,GAAG;QAEtBD,aAAA,GAAgBD,IAAA,CAAKO,MAAA,CAAO,CAAC;QAG7B,IAAIN,aAAA,KAAkB,KAAK;QAE3B,IAAIA,aAAA,KAAkB,KAAK;UACzB,IAAMO,IAAA,GAAOR,IAAA,CAAKD,KAAA,CAAM,KAAK;UAE7B,QAAQS,IAAA,CAAK,CAAC;YACZ,KAAK;cACHpI,KAAA,CAAMG,QAAA,CAASiC,IAAA,CAAKiG,UAAA,CAAWD,IAAA,CAAK,CAAC,CAAC,GAAGC,UAAA,CAAWD,IAAA,CAAK,CAAC,CAAC,GAAGC,UAAA,CAAWD,IAAA,CAAK,CAAC,CAAC,CAAC;cACjF,IAAIA,IAAA,CAAKzG,MAAA,IAAU,GAAG;gBACpB3B,KAAA,CAAMK,MAAA,CAAO+B,IAAA,CAAKiG,UAAA,CAAWD,IAAA,CAAK,CAAC,CAAC,GAAGC,UAAA,CAAWD,IAAA,CAAK,CAAC,CAAC,GAAGC,UAAA,CAAWD,IAAA,CAAK,CAAC,CAAC,CAAC;cAC7F,OAAmB;gBAGLpI,KAAA,CAAMK,MAAA,CAAO+B,IAAA,CAAK,QAAW,QAAW,MAAS;cAClD;cAED;YACF,KAAK;cACHpC,KAAA,CAAMI,OAAA,CAAQgC,IAAA,CAAKiG,UAAA,CAAWD,IAAA,CAAK,CAAC,CAAC,GAAGC,UAAA,CAAWD,IAAA,CAAK,CAAC,CAAC,GAAGC,UAAA,CAAWD,IAAA,CAAK,CAAC,CAAC,CAAC;cAChF;YACF,KAAK;cACHpI,KAAA,CAAMM,GAAA,CAAI8B,IAAA,CAAKiG,UAAA,CAAWD,IAAA,CAAK,CAAC,CAAC,GAAGC,UAAA,CAAWD,IAAA,CAAK,CAAC,CAAC,CAAC;cACvD;UACH;QACT,WAAiBP,aAAA,KAAkB,KAAK;UAChC,IAAMS,QAAA,GAAWV,IAAA,CAAKW,MAAA,CAAO,CAAC,EAAEL,IAAA,CAAM;UACtC,IAAMM,UAAA,GAAaF,QAAA,CAASX,KAAA,CAAM,KAAK;UACvC,IAAMc,YAAA,GAAe,EAAE;UAIvB,SAASC,CAAA,GAAI,GAAGC,EAAA,GAAKH,UAAA,CAAW7G,MAAA,EAAQ+G,CAAA,GAAIC,EAAA,EAAID,CAAA,IAAK;YACnD,IAAME,MAAA,GAASJ,UAAA,CAAWE,CAAC;YAE3B,IAAIE,MAAA,CAAOjH,MAAA,GAAS,GAAG;cACrB,IAAMkH,WAAA,GAAcD,MAAA,CAAOjB,KAAA,CAAM,GAAG;cACpCc,YAAA,CAAarG,IAAA,CAAKyG,WAAW;YAC9B;UACF;UAID,IAAMC,EAAA,GAAKL,YAAA,CAAa,CAAC;UAEzB,SAASC,EAAA,GAAI,GAAGC,GAAA,GAAKF,YAAA,CAAa9G,MAAA,GAAS,GAAG+G,EAAA,GAAIC,GAAA,EAAID,EAAA,IAAK;YACzD,IAAMK,EAAA,GAAKN,YAAA,CAAaC,EAAC;YACzB,IAAMM,EAAA,GAAKP,YAAA,CAAaC,EAAA,GAAI,CAAC;YAE7B1I,KAAA,CAAMqE,OAAA,CAAQyE,EAAA,CAAG,CAAC,GAAGC,EAAA,CAAG,CAAC,GAAGC,EAAA,CAAG,CAAC,GAAGF,EAAA,CAAG,CAAC,GAAGC,EAAA,CAAG,CAAC,GAAGC,EAAA,CAAG,CAAC,GAAGF,EAAA,CAAG,CAAC,GAAGC,EAAA,CAAG,CAAC,GAAGC,EAAA,CAAG,CAAC,CAAC;UAC5E;QACT,WAAiBnB,aAAA,KAAkB,KAAK;UAChC,IAAMoB,SAAA,GAAYrB,IAAA,CAAKsB,SAAA,CAAU,CAAC,EAAEhB,IAAA,CAAM,EAACP,KAAA,CAAM,GAAG;UACpD,IAAIwB,YAAA,GAAe,EAAE;UACrB,IAAMC,OAAA,GAAU,EAAE;UAElB,IAAIxB,IAAA,CAAKJ,OAAA,CAAQ,GAAG,MAAM,IAAI;YAC5B2B,YAAA,GAAeF,SAAA;UACzB,OAAe;YACL,SAASI,EAAA,GAAK,GAAGC,IAAA,GAAOL,SAAA,CAAUtH,MAAA,EAAQ0H,EAAA,GAAKC,IAAA,EAAMD,EAAA,IAAM;cACzD,IAAME,KAAA,GAAQN,SAAA,CAAUI,EAAE,EAAE1B,KAAA,CAAM,GAAG;cAErC,IAAI4B,KAAA,CAAM,CAAC,MAAM,IAAIJ,YAAA,CAAa/G,IAAA,CAAKmH,KAAA,CAAM,CAAC,CAAC;cAC/C,IAAIA,KAAA,CAAM,CAAC,MAAM,IAAIH,OAAA,CAAQhH,IAAA,CAAKmH,KAAA,CAAM,CAAC,CAAC;YAC3C;UACF;UAEDvJ,KAAA,CAAMsF,eAAA,CAAgB6D,YAAA,EAAcC,OAAO;QACnD,WAAiBvB,aAAA,KAAkB,KAAK;UAChC,IAAMS,SAAA,GAAWV,IAAA,CAAKW,MAAA,CAAO,CAAC,EAAEL,IAAA,CAAM;UACtC,IAAMsB,SAAA,GAAYlB,SAAA,CAASX,KAAA,CAAM,GAAG;UAEpC3H,KAAA,CAAMkF,gBAAA,CAAiBsE,SAAS;QACxC,YAAkBzB,MAAA,GAAS1I,eAAA,CAAgBoK,IAAA,CAAK7B,IAAI,OAAO,MAAM;UAOzD,IAAMlH,IAAA,IAAQ,MAAMqH,MAAA,CAAO,CAAC,EAAEQ,MAAA,CAAO,CAAC,EAAEL,IAAA,IAAQK,MAAA,CAAO,CAAC;UAExDvI,KAAA,CAAMS,WAAA,CAAYC,IAAI;QACvB,WAAUnB,qBAAA,CAAsBmK,IAAA,CAAK9B,IAAI,GAAG;UAG3C5H,KAAA,CAAME,MAAA,CAAOgB,aAAA,CAAc0G,IAAA,CAAKsB,SAAA,CAAU,CAAC,EAAEhB,IAAA,CAAI,GAAIlI,KAAA,CAAMQ,iBAAiB;QAC7E,WAAUlB,yBAAA,CAA0BoK,IAAA,CAAK9B,IAAI,GAAG;UAG/C5H,KAAA,CAAMQ,iBAAA,CAAkB4B,IAAA,CAAKwF,IAAA,CAAKsB,SAAA,CAAU,CAAC,EAAEhB,IAAA,EAAM;QACtD,WAAU1I,gBAAA,CAAiBkK,IAAA,CAAK9B,IAAI,GAAG;UAItCR,OAAA,CAAQuC,IAAA,CACN,sGACD;QACT,WAAiB9B,aAAA,KAAkB,KAAK;UAChCE,MAAA,GAASH,IAAA,CAAKD,KAAA,CAAM,GAAG;UAsBvB,IAAII,MAAA,CAAOpG,MAAA,GAAS,GAAG;YACrB,IAAMgB,KAAA,GAAQoF,MAAA,CAAO,CAAC,EAAEG,IAAA,CAAI,EAAG0B,WAAA,CAAa;YAC5C5J,KAAA,CAAME,MAAA,CAAOe,MAAA,GAAS0B,KAAA,KAAU,OAAOA,KAAA,KAAU;UAC3D,OAAe;YAEL3C,KAAA,CAAME,MAAA,CAAOe,MAAA,GAAS;UACvB;UAED,IAAMS,QAAA,GAAW1B,KAAA,CAAME,MAAA,CAAOW,eAAA,CAAiB;UAC/C,IAAIa,QAAA,EAAUA,QAAA,CAAST,MAAA,GAASjB,KAAA,CAAME,MAAA,CAAOe,MAAA;QACrD,OAAa;UAEL,IAAI2G,IAAA,KAAS,MAAM;UAEnBR,OAAA,CAAQuC,IAAA,CAAK,wCAAwC/B,IAAA,GAAO,GAAG;QAChE;MACF;MAED5H,KAAA,CAAMyC,QAAA,CAAU;MAEhB,IAAMoH,SAAA,GAAY,IAAIC,KAAA,CAAO;MAC7BD,SAAA,CAAUrJ,iBAAA,GAAoB,GAAGuJ,MAAA,CAAO/J,KAAA,CAAMQ,iBAAiB;MAE/D,IAAMwJ,aAAA,GAAgB,EAAEhK,KAAA,CAAMC,OAAA,CAAQ0B,MAAA,KAAW,KAAK3B,KAAA,CAAMC,OAAA,CAAQ,CAAC,EAAEc,QAAA,CAASZ,QAAA,CAASwB,MAAA,KAAW;MAEpG,IAAIqI,aAAA,KAAkB,MAAM;QAC1B,SAAS/B,EAAA,GAAI,GAAG5C,GAAA,GAAIrF,KAAA,CAAMC,OAAA,CAAQ0B,MAAA,EAAQsG,EAAA,GAAI5C,GAAA,EAAG4C,EAAA,IAAK;UACpD,IAAM/H,MAAA,GAASF,KAAA,CAAMC,OAAA,CAAQgI,EAAC;UAC9B,IAAMlH,QAAA,GAAWb,MAAA,CAAOa,QAAA;UACxB,IAAMR,SAAA,GAAYL,MAAA,CAAOK,SAAA;UACzB,IAAM0J,MAAA,GAASlJ,QAAA,CAASoE,IAAA,KAAS;UACjC,IAAM+E,QAAA,GAAWnJ,QAAA,CAASoE,IAAA,KAAS;UACnC,IAAIgF,eAAA,GAAkB;UAGtB,IAAIpJ,QAAA,CAASZ,QAAA,CAASwB,MAAA,KAAW,GAAG;UAEpC,IAAMyI,cAAA,GAAiB,IAAIC,cAAA,CAAgB;UAE3CD,cAAA,CAAeE,YAAA,CAAa,YAAY,IAAIC,sBAAA,CAAuBxJ,QAAA,CAASZ,QAAA,EAAU,CAAC,CAAC;UAExF,IAAIY,QAAA,CAASX,OAAA,CAAQuB,MAAA,GAAS,GAAG;YAC/ByI,cAAA,CAAeE,YAAA,CAAa,UAAU,IAAIC,sBAAA,CAAuBxJ,QAAA,CAASX,OAAA,EAAS,CAAC,CAAC;UACtF;UAED,IAAIW,QAAA,CAASV,MAAA,CAAOsB,MAAA,GAAS,GAAG;YAC9BwI,eAAA,GAAkB;YAClBC,cAAA,CAAeE,YAAA,CAAa,SAAS,IAAIC,sBAAA,CAAuBxJ,QAAA,CAASV,MAAA,EAAQ,CAAC,CAAC;UACpF;UAED,IAAIU,QAAA,CAASC,YAAA,KAAiB,MAAM;YAClCoJ,cAAA,CAAeE,YAAA,CAAa,MAAM,IAAIC,sBAAA,CAAuBxJ,QAAA,CAAST,GAAA,EAAK,CAAC,CAAC;UAC9E;UAID,IAAMkK,gBAAA,GAAmB,EAAE;UAE3B,SAASjI,EAAA,GAAK,GAAGkI,KAAA,GAAQlK,SAAA,CAAUoB,MAAA,EAAQY,EAAA,GAAKkI,KAAA,EAAOlI,EAAA,IAAM;YAC3D,IAAMmI,cAAA,GAAiBnK,SAAA,CAAUgC,EAAE;YACnC,IAAMoI,YAAA,GAAeD,cAAA,CAAehK,IAAA,GAAO,MAAMgK,cAAA,CAAezJ,MAAA,GAAS,MAAMkJ,eAAA;YAC/E,IAAIzI,SAAA,GAAW1B,KAAA,CAAMO,SAAA,CAAUoK,YAAY;YAE3C,IAAI,KAAKpK,SAAA,KAAc,MAAM;cAC3BmB,SAAA,GAAW,KAAKnB,SAAA,CAAUqK,MAAA,CAAOF,cAAA,CAAehK,IAAI;cAGpD,IAAIuJ,MAAA,IAAUvI,SAAA,IAAY,EAAEA,SAAA,YAAoBmJ,iBAAA,GAAoB;gBAClE,IAAMC,YAAA,GAAe,IAAID,iBAAA,CAAmB;gBAC5CE,QAAA,CAASC,SAAA,CAAUC,IAAA,CAAKjF,IAAA,CAAK8E,YAAA,EAAcpJ,SAAQ;gBACnDoJ,YAAA,CAAaI,KAAA,CAAMD,IAAA,CAAKvJ,SAAA,CAASwJ,KAAK;gBACtCxJ,SAAA,GAAWoJ,YAAA;cACZ,WAAUZ,QAAA,IAAYxI,SAAA,IAAY,EAAEA,SAAA,YAAoByJ,cAAA,GAAiB;gBACxE,IAAMC,cAAA,GAAiB,IAAID,cAAA,CAAe;kBAAEE,IAAA,EAAM;kBAAIC,eAAA,EAAiB;gBAAA,CAAO;gBAC9EP,QAAA,CAASC,SAAA,CAAUC,IAAA,CAAKjF,IAAA,CAAKoF,cAAA,EAAgB1J,SAAQ;gBACrD0J,cAAA,CAAeF,KAAA,CAAMD,IAAA,CAAKvJ,SAAA,CAASwJ,KAAK;gBACxCE,cAAA,CAAeG,GAAA,GAAM7J,SAAA,CAAS6J,GAAA;gBAC9B7J,SAAA,GAAW0J,cAAA;cACZ;YACF;YAED,IAAI1J,SAAA,KAAa,QAAW;cAC1B,IAAIuI,MAAA,EAAQ;gBACVvI,SAAA,GAAW,IAAImJ,iBAAA,CAAmB;cACnC,WAAUX,QAAA,EAAU;gBACnBxI,SAAA,GAAW,IAAIyJ,cAAA,CAAe;kBAAEE,IAAA,EAAM;kBAAGC,eAAA,EAAiB;gBAAA,CAAO;cAC/E,OAAmB;gBACL5J,SAAA,GAAW,IAAI8J,iBAAA,CAAmB;cACnC;cAED9J,SAAA,CAAShB,IAAA,GAAOgK,cAAA,CAAehK,IAAA;cAC/BgB,SAAA,CAAS+J,WAAA,GAAcf,cAAA,CAAezJ,MAAA,GAAS,QAAQ;cACvDS,SAAA,CAASgK,YAAA,GAAevB,eAAA;cAExBnK,KAAA,CAAMO,SAAA,CAAUoK,YAAY,IAAIjJ,SAAA;YACjC;YAED8I,gBAAA,CAAiBpI,IAAA,CAAKV,SAAQ;UAC/B;UAID,IAAIiK,IAAA;UAEJ,IAAInB,gBAAA,CAAiB7I,MAAA,GAAS,GAAG;YAC/B,SAASY,GAAA,GAAK,GAAGkI,MAAA,GAAQlK,SAAA,CAAUoB,MAAA,EAAQY,GAAA,GAAKkI,MAAA,EAAOlI,GAAA,IAAM;cAC3D,IAAMmI,eAAA,GAAiBnK,SAAA,CAAUgC,GAAE;cACnC6H,cAAA,CAAewB,QAAA,CAASlB,eAAA,CAAe3I,UAAA,EAAY2I,eAAA,CAAenJ,UAAA,EAAYgB,GAAE;YACjF;YAED,IAAI0H,MAAA,EAAQ;cACV0B,IAAA,GAAO,IAAIE,YAAA,CAAazB,cAAA,EAAgBI,gBAAgB;YACzD,WAAUN,QAAA,EAAU;cACnByB,IAAA,GAAO,IAAIG,MAAA,CAAO1B,cAAA,EAAgBI,gBAAgB;YAC9D,OAAiB;cACLmB,IAAA,GAAO,IAAII,IAAA,CAAK3B,cAAA,EAAgBI,gBAAgB;YACjD;UACX,OAAe;YACL,IAAIP,MAAA,EAAQ;cACV0B,IAAA,GAAO,IAAIE,YAAA,CAAazB,cAAA,EAAgBI,gBAAA,CAAiB,CAAC,CAAC;YAC5D,WAAUN,QAAA,EAAU;cACnByB,IAAA,GAAO,IAAIG,MAAA,CAAO1B,cAAA,EAAgBI,gBAAA,CAAiB,CAAC,CAAC;YACjE,OAAiB;cACLmB,IAAA,GAAO,IAAII,IAAA,CAAK3B,cAAA,EAAgBI,gBAAA,CAAiB,CAAC,CAAC;YACpD;UACF;UAEDmB,IAAA,CAAKjL,IAAA,GAAOR,MAAA,CAAOQ,IAAA;UAEnBmJ,SAAA,CAAUmC,GAAA,CAAIL,IAAI;QACnB;MACP,OAAW;QAGL,IAAI3L,KAAA,CAAMG,QAAA,CAASwB,MAAA,GAAS,GAAG;UAC7B,IAAMD,UAAA,GAAW,IAAIyJ,cAAA,CAAe;YAAEE,IAAA,EAAM;YAAGC,eAAA,EAAiB;UAAA,CAAO;UAEvE,IAAMlB,eAAA,GAAiB,IAAIC,cAAA,CAAgB;UAE3CD,eAAA,CAAeE,YAAA,CAAa,YAAY,IAAIC,sBAAA,CAAuBvK,KAAA,CAAMG,QAAA,EAAU,CAAC,CAAC;UAErF,IAAIH,KAAA,CAAMK,MAAA,CAAOsB,MAAA,GAAS,KAAK3B,KAAA,CAAMK,MAAA,CAAO,CAAC,MAAM,QAAW;YAC5D+J,eAAA,CAAeE,YAAA,CAAa,SAAS,IAAIC,sBAAA,CAAuBvK,KAAA,CAAMK,MAAA,EAAQ,CAAC,CAAC;YAChFqB,UAAA,CAASgK,YAAA,GAAe;UACzB;UAED,IAAMO,MAAA,GAAS,IAAIH,MAAA,CAAO1B,eAAA,EAAgB1I,UAAQ;UAClDmI,SAAA,CAAUmC,GAAA,CAAIC,MAAM;QACrB;MACF;MAED,OAAOpC,SAAA;IACR;EAAA;EAAA,OAAArE,SAAA;AAAA,EA1VqB0G,MAAA"},"metadata":{},"sourceType":"module","externalDependencies":[]}