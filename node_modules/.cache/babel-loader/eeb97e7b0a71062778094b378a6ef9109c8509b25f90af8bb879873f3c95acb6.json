{"ast":null,"code":"import _defineProperty from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport _classCallCheck from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _get from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/get.js\";\nimport _getPrototypeOf from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js\";\nimport _inherits from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport { Texture, DataTextureLoader, HalfFloatType, FloatType, RGBAFormat, RedFormat, LinearFilter, DataUtils } from \"three\";\nimport { unzlibSync } from \"fflate\";\nvar hasColorSpace = (\"colorSpace\" in new Texture());\nvar EXRLoader = /*#__PURE__*/function (_DataTextureLoader) {\n  _inherits(EXRLoader, _DataTextureLoader);\n  var _super = _createSuper(EXRLoader);\n  function EXRLoader(manager) {\n    var _this;\n    _classCallCheck(this, EXRLoader);\n    _this = _super.call(this, manager);\n    _this.type = HalfFloatType;\n    return _this;\n  }\n  _createClass(EXRLoader, [{\n    key: \"parse\",\n    value: function parse(buffer) {\n      var _ref;\n      var USHORT_RANGE = 1 << 16;\n      var BITMAP_SIZE = USHORT_RANGE >> 3;\n      var HUF_ENCBITS = 16;\n      var HUF_DECBITS = 14;\n      var HUF_ENCSIZE = (1 << HUF_ENCBITS) + 1;\n      var HUF_DECSIZE = 1 << HUF_DECBITS;\n      var HUF_DECMASK = HUF_DECSIZE - 1;\n      var NBITS = 16;\n      var A_OFFSET = 1 << NBITS - 1;\n      var MOD_MASK = (1 << NBITS) - 1;\n      var SHORT_ZEROCODE_RUN = 59;\n      var LONG_ZEROCODE_RUN = 63;\n      var SHORTEST_LONG_RUN = 2 + LONG_ZEROCODE_RUN - SHORT_ZEROCODE_RUN;\n      var ULONG_SIZE = 8;\n      var FLOAT32_SIZE = 4;\n      var INT32_SIZE = 4;\n      var INT16_SIZE = 2;\n      var INT8_SIZE = 1;\n      var STATIC_HUFFMAN = 0;\n      var DEFLATE = 1;\n      var UNKNOWN = 0;\n      var LOSSY_DCT = 1;\n      var RLE = 2;\n      var logBase = Math.pow(2.7182818, 2.2);\n      function reverseLutFromBitmap(bitmap, lut) {\n        var k = 0;\n        for (var i = 0; i < USHORT_RANGE; ++i) {\n          if (i == 0 || bitmap[i >> 3] & 1 << (i & 7)) {\n            lut[k++] = i;\n          }\n        }\n        var n = k - 1;\n        while (k < USHORT_RANGE) lut[k++] = 0;\n        return n;\n      }\n      function hufClearDecTable(hdec) {\n        for (var i = 0; i < HUF_DECSIZE; i++) {\n          hdec[i] = {};\n          hdec[i].len = 0;\n          hdec[i].lit = 0;\n          hdec[i].p = null;\n        }\n      }\n      var getBitsReturn = {\n        l: 0,\n        c: 0,\n        lc: 0\n      };\n      function getBits(nBits, c, lc, uInt8Array2, inOffset) {\n        while (lc < nBits) {\n          c = c << 8 | parseUint8Array(uInt8Array2, inOffset);\n          lc += 8;\n        }\n        lc -= nBits;\n        getBitsReturn.l = c >> lc & (1 << nBits) - 1;\n        getBitsReturn.c = c;\n        getBitsReturn.lc = lc;\n      }\n      var hufTableBuffer = new Array(59);\n      function hufCanonicalCodeTable(hcode) {\n        for (var i = 0; i <= 58; ++i) hufTableBuffer[i] = 0;\n        for (var i = 0; i < HUF_ENCSIZE; ++i) hufTableBuffer[hcode[i]] += 1;\n        var c = 0;\n        for (var i = 58; i > 0; --i) {\n          var nc = c + hufTableBuffer[i] >> 1;\n          hufTableBuffer[i] = c;\n          c = nc;\n        }\n        for (var i = 0; i < HUF_ENCSIZE; ++i) {\n          var l = hcode[i];\n          if (l > 0) hcode[i] = l | hufTableBuffer[l]++ << 6;\n        }\n      }\n      function hufUnpackEncTable(uInt8Array2, inDataView, inOffset, ni, im, iM, hcode) {\n        var p = inOffset;\n        var c = 0;\n        var lc = 0;\n        for (; im <= iM; im++) {\n          if (p.value - inOffset.value > ni) return false;\n          getBits(6, c, lc, uInt8Array2, p);\n          var l = getBitsReturn.l;\n          c = getBitsReturn.c;\n          lc = getBitsReturn.lc;\n          hcode[im] = l;\n          if (l == LONG_ZEROCODE_RUN) {\n            if (p.value - inOffset.value > ni) {\n              throw \"Something wrong with hufUnpackEncTable\";\n            }\n            getBits(8, c, lc, uInt8Array2, p);\n            var zerun = getBitsReturn.l + SHORTEST_LONG_RUN;\n            c = getBitsReturn.c;\n            lc = getBitsReturn.lc;\n            if (im + zerun > iM + 1) {\n              throw \"Something wrong with hufUnpackEncTable\";\n            }\n            while (zerun--) hcode[im++] = 0;\n            im--;\n          } else if (l >= SHORT_ZEROCODE_RUN) {\n            var zerun = l - SHORT_ZEROCODE_RUN + 2;\n            if (im + zerun > iM + 1) {\n              throw \"Something wrong with hufUnpackEncTable\";\n            }\n            while (zerun--) hcode[im++] = 0;\n            im--;\n          }\n        }\n        hufCanonicalCodeTable(hcode);\n      }\n      function hufLength(code) {\n        return code & 63;\n      }\n      function hufCode(code) {\n        return code >> 6;\n      }\n      function hufBuildDecTable(hcode, im, iM, hdecod) {\n        for (; im <= iM; im++) {\n          var c = hufCode(hcode[im]);\n          var l = hufLength(hcode[im]);\n          if (c >> l) {\n            throw \"Invalid table entry\";\n          }\n          if (l > HUF_DECBITS) {\n            var pl = hdecod[c >> l - HUF_DECBITS];\n            if (pl.len) {\n              throw \"Invalid table entry\";\n            }\n            pl.lit++;\n            if (pl.p) {\n              var p = pl.p;\n              pl.p = new Array(pl.lit);\n              for (var i = 0; i < pl.lit - 1; ++i) {\n                pl.p[i] = p[i];\n              }\n            } else {\n              pl.p = new Array(1);\n            }\n            pl.p[pl.lit - 1] = im;\n          } else if (l) {\n            var plOffset = 0;\n            for (var i = 1 << HUF_DECBITS - l; i > 0; i--) {\n              var pl = hdecod[(c << HUF_DECBITS - l) + plOffset];\n              if (pl.len || pl.p) {\n                throw \"Invalid table entry\";\n              }\n              pl.len = l;\n              pl.lit = im;\n              plOffset++;\n            }\n          }\n        }\n        return true;\n      }\n      var getCharReturn = {\n        c: 0,\n        lc: 0\n      };\n      function getChar(c, lc, uInt8Array2, inOffset) {\n        c = c << 8 | parseUint8Array(uInt8Array2, inOffset);\n        lc += 8;\n        getCharReturn.c = c;\n        getCharReturn.lc = lc;\n      }\n      var getCodeReturn = {\n        c: 0,\n        lc: 0\n      };\n      function getCode(po, rlc, c, lc, uInt8Array2, inDataView, inOffset, outBuffer, outBufferOffset, outBufferEndOffset) {\n        if (po == rlc) {\n          if (lc < 8) {\n            getChar(c, lc, uInt8Array2, inOffset);\n            c = getCharReturn.c;\n            lc = getCharReturn.lc;\n          }\n          lc -= 8;\n          var cs = c >> lc;\n          var cs = new Uint8Array([cs])[0];\n          if (outBufferOffset.value + cs > outBufferEndOffset) {\n            return false;\n          }\n          var s = outBuffer[outBufferOffset.value - 1];\n          while (cs-- > 0) {\n            outBuffer[outBufferOffset.value++] = s;\n          }\n        } else if (outBufferOffset.value < outBufferEndOffset) {\n          outBuffer[outBufferOffset.value++] = po;\n        } else {\n          return false;\n        }\n        getCodeReturn.c = c;\n        getCodeReturn.lc = lc;\n      }\n      function UInt16(value) {\n        return value & 65535;\n      }\n      function Int16(value) {\n        var ref = UInt16(value);\n        return ref > 32767 ? ref - 65536 : ref;\n      }\n      var wdec14Return = {\n        a: 0,\n        b: 0\n      };\n      function wdec14(l, h) {\n        var ls = Int16(l);\n        var hs = Int16(h);\n        var hi = hs;\n        var ai = ls + (hi & 1) + (hi >> 1);\n        var as = ai;\n        var bs = ai - hi;\n        wdec14Return.a = as;\n        wdec14Return.b = bs;\n      }\n      function wdec16(l, h) {\n        var m = UInt16(l);\n        var d = UInt16(h);\n        var bb = m - (d >> 1) & MOD_MASK;\n        var aa = d + bb - A_OFFSET & MOD_MASK;\n        wdec14Return.a = aa;\n        wdec14Return.b = bb;\n      }\n      function wav2Decode(buffer2, j, nx, ox, ny, oy, mx) {\n        var w14 = mx < 1 << 14;\n        var n = nx > ny ? ny : nx;\n        var p = 1;\n        var p2;\n        while (p <= n) p <<= 1;\n        p >>= 1;\n        p2 = p;\n        p >>= 1;\n        while (p >= 1) {\n          var py = 0;\n          var ey = py + oy * (ny - p2);\n          var oy1 = oy * p;\n          var oy2 = oy * p2;\n          var ox1 = ox * p;\n          var ox2 = ox * p2;\n          var i00, i01, i10, i11;\n          for (; py <= ey; py += oy2) {\n            var px = py;\n            var ex = py + ox * (nx - p2);\n            for (; px <= ex; px += ox2) {\n              var p01 = px + ox1;\n              var p10 = px + oy1;\n              var p11 = p10 + ox1;\n              if (w14) {\n                wdec14(buffer2[px + j], buffer2[p10 + j]);\n                i00 = wdec14Return.a;\n                i10 = wdec14Return.b;\n                wdec14(buffer2[p01 + j], buffer2[p11 + j]);\n                i01 = wdec14Return.a;\n                i11 = wdec14Return.b;\n                wdec14(i00, i01);\n                buffer2[px + j] = wdec14Return.a;\n                buffer2[p01 + j] = wdec14Return.b;\n                wdec14(i10, i11);\n                buffer2[p10 + j] = wdec14Return.a;\n                buffer2[p11 + j] = wdec14Return.b;\n              } else {\n                wdec16(buffer2[px + j], buffer2[p10 + j]);\n                i00 = wdec14Return.a;\n                i10 = wdec14Return.b;\n                wdec16(buffer2[p01 + j], buffer2[p11 + j]);\n                i01 = wdec14Return.a;\n                i11 = wdec14Return.b;\n                wdec16(i00, i01);\n                buffer2[px + j] = wdec14Return.a;\n                buffer2[p01 + j] = wdec14Return.b;\n                wdec16(i10, i11);\n                buffer2[p10 + j] = wdec14Return.a;\n                buffer2[p11 + j] = wdec14Return.b;\n              }\n            }\n            if (nx & p) {\n              var p10 = px + oy1;\n              if (w14) wdec14(buffer2[px + j], buffer2[p10 + j]);else wdec16(buffer2[px + j], buffer2[p10 + j]);\n              i00 = wdec14Return.a;\n              buffer2[p10 + j] = wdec14Return.b;\n              buffer2[px + j] = i00;\n            }\n          }\n          if (ny & p) {\n            var px = py;\n            var ex = py + ox * (nx - p2);\n            for (; px <= ex; px += ox2) {\n              var p01 = px + ox1;\n              if (w14) wdec14(buffer2[px + j], buffer2[p01 + j]);else wdec16(buffer2[px + j], buffer2[p01 + j]);\n              i00 = wdec14Return.a;\n              buffer2[p01 + j] = wdec14Return.b;\n              buffer2[px + j] = i00;\n            }\n          }\n          p2 = p;\n          p >>= 1;\n        }\n        return py;\n      }\n      function hufDecode(encodingTable, decodingTable, uInt8Array2, inDataView, inOffset, ni, rlc, no, outBuffer, outOffset) {\n        var c = 0;\n        var lc = 0;\n        var outBufferEndOffset = no;\n        var inOffsetEnd = Math.trunc(inOffset.value + (ni + 7) / 8);\n        while (inOffset.value < inOffsetEnd) {\n          getChar(c, lc, uInt8Array2, inOffset);\n          c = getCharReturn.c;\n          lc = getCharReturn.lc;\n          while (lc >= HUF_DECBITS) {\n            var index = c >> lc - HUF_DECBITS & HUF_DECMASK;\n            var pl = decodingTable[index];\n            if (pl.len) {\n              lc -= pl.len;\n              getCode(pl.lit, rlc, c, lc, uInt8Array2, inDataView, inOffset, outBuffer, outOffset, outBufferEndOffset);\n              c = getCodeReturn.c;\n              lc = getCodeReturn.lc;\n            } else {\n              if (!pl.p) {\n                throw \"hufDecode issues\";\n              }\n              var j;\n              for (j = 0; j < pl.lit; j++) {\n                var l = hufLength(encodingTable[pl.p[j]]);\n                while (lc < l && inOffset.value < inOffsetEnd) {\n                  getChar(c, lc, uInt8Array2, inOffset);\n                  c = getCharReturn.c;\n                  lc = getCharReturn.lc;\n                }\n                if (lc >= l) {\n                  if (hufCode(encodingTable[pl.p[j]]) == (c >> lc - l & (1 << l) - 1)) {\n                    lc -= l;\n                    getCode(pl.p[j], rlc, c, lc, uInt8Array2, inDataView, inOffset, outBuffer, outOffset, outBufferEndOffset);\n                    c = getCodeReturn.c;\n                    lc = getCodeReturn.lc;\n                    break;\n                  }\n                }\n              }\n              if (j == pl.lit) {\n                throw \"hufDecode issues\";\n              }\n            }\n          }\n        }\n        var i = 8 - ni & 7;\n        c >>= i;\n        lc -= i;\n        while (lc > 0) {\n          var pl = decodingTable[c << HUF_DECBITS - lc & HUF_DECMASK];\n          if (pl.len) {\n            lc -= pl.len;\n            getCode(pl.lit, rlc, c, lc, uInt8Array2, inDataView, inOffset, outBuffer, outOffset, outBufferEndOffset);\n            c = getCodeReturn.c;\n            lc = getCodeReturn.lc;\n          } else {\n            throw \"hufDecode issues\";\n          }\n        }\n        return true;\n      }\n      function hufUncompress(uInt8Array2, inDataView, inOffset, nCompressed, outBuffer, nRaw) {\n        var outOffset = {\n          value: 0\n        };\n        var initialInOffset = inOffset.value;\n        var im = parseUint32(inDataView, inOffset);\n        var iM = parseUint32(inDataView, inOffset);\n        inOffset.value += 4;\n        var nBits = parseUint32(inDataView, inOffset);\n        inOffset.value += 4;\n        if (im < 0 || im >= HUF_ENCSIZE || iM < 0 || iM >= HUF_ENCSIZE) {\n          throw \"Something wrong with HUF_ENCSIZE\";\n        }\n        var freq = new Array(HUF_ENCSIZE);\n        var hdec = new Array(HUF_DECSIZE);\n        hufClearDecTable(hdec);\n        var ni = nCompressed - (inOffset.value - initialInOffset);\n        hufUnpackEncTable(uInt8Array2, inDataView, inOffset, ni, im, iM, freq);\n        if (nBits > 8 * (nCompressed - (inOffset.value - initialInOffset))) {\n          throw \"Something wrong with hufUncompress\";\n        }\n        hufBuildDecTable(freq, im, iM, hdec);\n        hufDecode(freq, hdec, uInt8Array2, inDataView, inOffset, nBits, iM, nRaw, outBuffer, outOffset);\n      }\n      function applyLut(lut, data, nData) {\n        for (var i = 0; i < nData; ++i) {\n          data[i] = lut[data[i]];\n        }\n      }\n      function predictor(source) {\n        for (var t = 1; t < source.length; t++) {\n          var d = source[t - 1] + source[t] - 128;\n          source[t] = d;\n        }\n      }\n      function interleaveScalar(source, out) {\n        var t1 = 0;\n        var t2 = Math.floor((source.length + 1) / 2);\n        var s = 0;\n        var stop = source.length - 1;\n        while (true) {\n          if (s > stop) break;\n          out[s++] = source[t1++];\n          if (s > stop) break;\n          out[s++] = source[t2++];\n        }\n      }\n      function decodeRunLength(source) {\n        var size = source.byteLength;\n        var out = new Array();\n        var p = 0;\n        var reader = new DataView(source);\n        while (size > 0) {\n          var l = reader.getInt8(p++);\n          if (l < 0) {\n            var count = -l;\n            size -= count + 1;\n            for (var i = 0; i < count; i++) {\n              out.push(reader.getUint8(p++));\n            }\n          } else {\n            var count = l;\n            size -= 2;\n            var value = reader.getUint8(p++);\n            for (var i = 0; i < count + 1; i++) {\n              out.push(value);\n            }\n          }\n        }\n        return out;\n      }\n      function lossyDctDecode(cscSet, rowPtrs, channelData, acBuffer, dcBuffer, outBuffer) {\n        var dataView = new DataView(outBuffer.buffer);\n        var width = channelData[cscSet.idx[0]].width;\n        var height = channelData[cscSet.idx[0]].height;\n        var numComp = 3;\n        var numFullBlocksX = Math.floor(width / 8);\n        var numBlocksX = Math.ceil(width / 8);\n        var numBlocksY = Math.ceil(height / 8);\n        var leftoverX = width - (numBlocksX - 1) * 8;\n        var leftoverY = height - (numBlocksY - 1) * 8;\n        var currAcComp = {\n          value: 0\n        };\n        var currDcComp = new Array(numComp);\n        var dctData = new Array(numComp);\n        var halfZigBlock = new Array(numComp);\n        var rowBlock = new Array(numComp);\n        var rowOffsets = new Array(numComp);\n        for (var comp2 = 0; comp2 < numComp; ++comp2) {\n          rowOffsets[comp2] = rowPtrs[cscSet.idx[comp2]];\n          currDcComp[comp2] = comp2 < 1 ? 0 : currDcComp[comp2 - 1] + numBlocksX * numBlocksY;\n          dctData[comp2] = new Float32Array(64);\n          halfZigBlock[comp2] = new Uint16Array(64);\n          rowBlock[comp2] = new Uint16Array(numBlocksX * 64);\n        }\n        for (var blocky = 0; blocky < numBlocksY; ++blocky) {\n          var maxY = 8;\n          if (blocky == numBlocksY - 1) maxY = leftoverY;\n          var maxX = 8;\n          for (var blockx = 0; blockx < numBlocksX; ++blockx) {\n            if (blockx == numBlocksX - 1) maxX = leftoverX;\n            for (var _comp = 0; _comp < numComp; ++_comp) {\n              halfZigBlock[_comp].fill(0);\n              halfZigBlock[_comp][0] = dcBuffer[currDcComp[_comp]++];\n              unRleAC(currAcComp, acBuffer, halfZigBlock[_comp]);\n              unZigZag(halfZigBlock[_comp], dctData[_comp]);\n              dctInverse(dctData[_comp]);\n            }\n            {\n              csc709Inverse(dctData);\n            }\n            for (var _comp2 = 0; _comp2 < numComp; ++_comp2) {\n              convertToHalf(dctData[_comp2], rowBlock[_comp2], blockx * 64);\n            }\n          }\n          var offset2 = 0;\n          for (var _comp3 = 0; _comp3 < numComp; ++_comp3) {\n            var type2 = channelData[cscSet.idx[_comp3]].type;\n            for (var y2 = 8 * blocky; y2 < 8 * blocky + maxY; ++y2) {\n              offset2 = rowOffsets[_comp3][y2];\n              for (var _blockx = 0; _blockx < numFullBlocksX; ++_blockx) {\n                var src = _blockx * 64 + (y2 & 7) * 8;\n                dataView.setUint16(offset2 + 0 * INT16_SIZE * type2, rowBlock[_comp3][src + 0], true);\n                dataView.setUint16(offset2 + 1 * INT16_SIZE * type2, rowBlock[_comp3][src + 1], true);\n                dataView.setUint16(offset2 + 2 * INT16_SIZE * type2, rowBlock[_comp3][src + 2], true);\n                dataView.setUint16(offset2 + 3 * INT16_SIZE * type2, rowBlock[_comp3][src + 3], true);\n                dataView.setUint16(offset2 + 4 * INT16_SIZE * type2, rowBlock[_comp3][src + 4], true);\n                dataView.setUint16(offset2 + 5 * INT16_SIZE * type2, rowBlock[_comp3][src + 5], true);\n                dataView.setUint16(offset2 + 6 * INT16_SIZE * type2, rowBlock[_comp3][src + 6], true);\n                dataView.setUint16(offset2 + 7 * INT16_SIZE * type2, rowBlock[_comp3][src + 7], true);\n                offset2 += 8 * INT16_SIZE * type2;\n              }\n            }\n            if (numFullBlocksX != numBlocksX) {\n              for (var _y = 8 * blocky; _y < 8 * blocky + maxY; ++_y) {\n                var offset3 = rowOffsets[_comp3][_y] + 8 * numFullBlocksX * INT16_SIZE * type2;\n                var _src = numFullBlocksX * 64 + (_y & 7) * 8;\n                for (var x2 = 0; x2 < maxX; ++x2) {\n                  dataView.setUint16(offset3 + x2 * INT16_SIZE * type2, rowBlock[_comp3][_src + x2], true);\n                }\n              }\n            }\n          }\n        }\n        var halfRow = new Uint16Array(width);\n        var dataView = new DataView(outBuffer.buffer);\n        for (var comp = 0; comp < numComp; ++comp) {\n          channelData[cscSet.idx[comp]].decoded = true;\n          var type = channelData[cscSet.idx[comp]].type;\n          if (channelData[comp].type != 2) continue;\n          for (var y = 0; y < height; ++y) {\n            var _offset = rowOffsets[comp][y];\n            for (var x = 0; x < width; ++x) {\n              halfRow[x] = dataView.getUint16(_offset + x * INT16_SIZE * type, true);\n            }\n            for (var x = 0; x < width; ++x) {\n              dataView.setFloat32(_offset + x * INT16_SIZE * type, decodeFloat16(halfRow[x]), true);\n            }\n          }\n        }\n      }\n      function unRleAC(currAcComp, acBuffer, halfZigBlock) {\n        var acValue;\n        var dctComp = 1;\n        while (dctComp < 64) {\n          acValue = acBuffer[currAcComp.value];\n          if (acValue == 65280) {\n            dctComp = 64;\n          } else if (acValue >> 8 == 255) {\n            dctComp += acValue & 255;\n          } else {\n            halfZigBlock[dctComp] = acValue;\n            dctComp++;\n          }\n          currAcComp.value++;\n        }\n      }\n      function unZigZag(src, dst) {\n        dst[0] = decodeFloat16(src[0]);\n        dst[1] = decodeFloat16(src[1]);\n        dst[2] = decodeFloat16(src[5]);\n        dst[3] = decodeFloat16(src[6]);\n        dst[4] = decodeFloat16(src[14]);\n        dst[5] = decodeFloat16(src[15]);\n        dst[6] = decodeFloat16(src[27]);\n        dst[7] = decodeFloat16(src[28]);\n        dst[8] = decodeFloat16(src[2]);\n        dst[9] = decodeFloat16(src[4]);\n        dst[10] = decodeFloat16(src[7]);\n        dst[11] = decodeFloat16(src[13]);\n        dst[12] = decodeFloat16(src[16]);\n        dst[13] = decodeFloat16(src[26]);\n        dst[14] = decodeFloat16(src[29]);\n        dst[15] = decodeFloat16(src[42]);\n        dst[16] = decodeFloat16(src[3]);\n        dst[17] = decodeFloat16(src[8]);\n        dst[18] = decodeFloat16(src[12]);\n        dst[19] = decodeFloat16(src[17]);\n        dst[20] = decodeFloat16(src[25]);\n        dst[21] = decodeFloat16(src[30]);\n        dst[22] = decodeFloat16(src[41]);\n        dst[23] = decodeFloat16(src[43]);\n        dst[24] = decodeFloat16(src[9]);\n        dst[25] = decodeFloat16(src[11]);\n        dst[26] = decodeFloat16(src[18]);\n        dst[27] = decodeFloat16(src[24]);\n        dst[28] = decodeFloat16(src[31]);\n        dst[29] = decodeFloat16(src[40]);\n        dst[30] = decodeFloat16(src[44]);\n        dst[31] = decodeFloat16(src[53]);\n        dst[32] = decodeFloat16(src[10]);\n        dst[33] = decodeFloat16(src[19]);\n        dst[34] = decodeFloat16(src[23]);\n        dst[35] = decodeFloat16(src[32]);\n        dst[36] = decodeFloat16(src[39]);\n        dst[37] = decodeFloat16(src[45]);\n        dst[38] = decodeFloat16(src[52]);\n        dst[39] = decodeFloat16(src[54]);\n        dst[40] = decodeFloat16(src[20]);\n        dst[41] = decodeFloat16(src[22]);\n        dst[42] = decodeFloat16(src[33]);\n        dst[43] = decodeFloat16(src[38]);\n        dst[44] = decodeFloat16(src[46]);\n        dst[45] = decodeFloat16(src[51]);\n        dst[46] = decodeFloat16(src[55]);\n        dst[47] = decodeFloat16(src[60]);\n        dst[48] = decodeFloat16(src[21]);\n        dst[49] = decodeFloat16(src[34]);\n        dst[50] = decodeFloat16(src[37]);\n        dst[51] = decodeFloat16(src[47]);\n        dst[52] = decodeFloat16(src[50]);\n        dst[53] = decodeFloat16(src[56]);\n        dst[54] = decodeFloat16(src[59]);\n        dst[55] = decodeFloat16(src[61]);\n        dst[56] = decodeFloat16(src[35]);\n        dst[57] = decodeFloat16(src[36]);\n        dst[58] = decodeFloat16(src[48]);\n        dst[59] = decodeFloat16(src[49]);\n        dst[60] = decodeFloat16(src[57]);\n        dst[61] = decodeFloat16(src[58]);\n        dst[62] = decodeFloat16(src[62]);\n        dst[63] = decodeFloat16(src[63]);\n      }\n      function dctInverse(data) {\n        var a = 0.5 * Math.cos(3.14159 / 4);\n        var b = 0.5 * Math.cos(3.14159 / 16);\n        var c = 0.5 * Math.cos(3.14159 / 8);\n        var d = 0.5 * Math.cos(3 * 3.14159 / 16);\n        var e = 0.5 * Math.cos(5 * 3.14159 / 16);\n        var f = 0.5 * Math.cos(3 * 3.14159 / 8);\n        var g = 0.5 * Math.cos(7 * 3.14159 / 16);\n        var alpha = new Array(4);\n        var beta = new Array(4);\n        var theta = new Array(4);\n        var gamma = new Array(4);\n        for (var row = 0; row < 8; ++row) {\n          var rowPtr = row * 8;\n          alpha[0] = c * data[rowPtr + 2];\n          alpha[1] = f * data[rowPtr + 2];\n          alpha[2] = c * data[rowPtr + 6];\n          alpha[3] = f * data[rowPtr + 6];\n          beta[0] = b * data[rowPtr + 1] + d * data[rowPtr + 3] + e * data[rowPtr + 5] + g * data[rowPtr + 7];\n          beta[1] = d * data[rowPtr + 1] - g * data[rowPtr + 3] - b * data[rowPtr + 5] - e * data[rowPtr + 7];\n          beta[2] = e * data[rowPtr + 1] - b * data[rowPtr + 3] + g * data[rowPtr + 5] + d * data[rowPtr + 7];\n          beta[3] = g * data[rowPtr + 1] - e * data[rowPtr + 3] + d * data[rowPtr + 5] - b * data[rowPtr + 7];\n          theta[0] = a * (data[rowPtr + 0] + data[rowPtr + 4]);\n          theta[3] = a * (data[rowPtr + 0] - data[rowPtr + 4]);\n          theta[1] = alpha[0] + alpha[3];\n          theta[2] = alpha[1] - alpha[2];\n          gamma[0] = theta[0] + theta[1];\n          gamma[1] = theta[3] + theta[2];\n          gamma[2] = theta[3] - theta[2];\n          gamma[3] = theta[0] - theta[1];\n          data[rowPtr + 0] = gamma[0] + beta[0];\n          data[rowPtr + 1] = gamma[1] + beta[1];\n          data[rowPtr + 2] = gamma[2] + beta[2];\n          data[rowPtr + 3] = gamma[3] + beta[3];\n          data[rowPtr + 4] = gamma[3] - beta[3];\n          data[rowPtr + 5] = gamma[2] - beta[2];\n          data[rowPtr + 6] = gamma[1] - beta[1];\n          data[rowPtr + 7] = gamma[0] - beta[0];\n        }\n        for (var column = 0; column < 8; ++column) {\n          alpha[0] = c * data[16 + column];\n          alpha[1] = f * data[16 + column];\n          alpha[2] = c * data[48 + column];\n          alpha[3] = f * data[48 + column];\n          beta[0] = b * data[8 + column] + d * data[24 + column] + e * data[40 + column] + g * data[56 + column];\n          beta[1] = d * data[8 + column] - g * data[24 + column] - b * data[40 + column] - e * data[56 + column];\n          beta[2] = e * data[8 + column] - b * data[24 + column] + g * data[40 + column] + d * data[56 + column];\n          beta[3] = g * data[8 + column] - e * data[24 + column] + d * data[40 + column] - b * data[56 + column];\n          theta[0] = a * (data[column] + data[32 + column]);\n          theta[3] = a * (data[column] - data[32 + column]);\n          theta[1] = alpha[0] + alpha[3];\n          theta[2] = alpha[1] - alpha[2];\n          gamma[0] = theta[0] + theta[1];\n          gamma[1] = theta[3] + theta[2];\n          gamma[2] = theta[3] - theta[2];\n          gamma[3] = theta[0] - theta[1];\n          data[0 + column] = gamma[0] + beta[0];\n          data[8 + column] = gamma[1] + beta[1];\n          data[16 + column] = gamma[2] + beta[2];\n          data[24 + column] = gamma[3] + beta[3];\n          data[32 + column] = gamma[3] - beta[3];\n          data[40 + column] = gamma[2] - beta[2];\n          data[48 + column] = gamma[1] - beta[1];\n          data[56 + column] = gamma[0] - beta[0];\n        }\n      }\n      function csc709Inverse(data) {\n        for (var i = 0; i < 64; ++i) {\n          var y = data[0][i];\n          var cb = data[1][i];\n          var cr = data[2][i];\n          data[0][i] = y + 1.5747 * cr;\n          data[1][i] = y - 0.1873 * cb - 0.4682 * cr;\n          data[2][i] = y + 1.8556 * cb;\n        }\n      }\n      function convertToHalf(src, dst, idx) {\n        for (var i = 0; i < 64; ++i) {\n          dst[idx + i] = DataUtils.toHalfFloat(toLinear(src[i]));\n        }\n      }\n      function toLinear(float) {\n        if (float <= 1) {\n          return Math.sign(float) * Math.pow(Math.abs(float), 2.2);\n        } else {\n          return Math.sign(float) * Math.pow(logBase, Math.abs(float) - 1);\n        }\n      }\n      function uncompressRAW(info) {\n        return new DataView(info.array.buffer, info.offset.value, info.size);\n      }\n      function uncompressRLE(info) {\n        var compressed = info.viewer.buffer.slice(info.offset.value, info.offset.value + info.size);\n        var rawBuffer = new Uint8Array(decodeRunLength(compressed));\n        var tmpBuffer = new Uint8Array(rawBuffer.length);\n        predictor(rawBuffer);\n        interleaveScalar(rawBuffer, tmpBuffer);\n        return new DataView(tmpBuffer.buffer);\n      }\n      function uncompressZIP(info) {\n        var compressed = info.array.slice(info.offset.value, info.offset.value + info.size);\n        var rawBuffer = unzlibSync(compressed);\n        var tmpBuffer = new Uint8Array(rawBuffer.length);\n        predictor(rawBuffer);\n        interleaveScalar(rawBuffer, tmpBuffer);\n        return new DataView(tmpBuffer.buffer);\n      }\n      function uncompressPIZ(info) {\n        var inDataView = info.viewer;\n        var inOffset = {\n          value: info.offset.value\n        };\n        var outBuffer = new Uint16Array(info.width * info.scanlineBlockSize * (info.channels * info.type));\n        var bitmap = new Uint8Array(BITMAP_SIZE);\n        var outBufferEnd = 0;\n        var pizChannelData = new Array(info.channels);\n        for (var i = 0; i < info.channels; i++) {\n          pizChannelData[i] = {};\n          pizChannelData[i][\"start\"] = outBufferEnd;\n          pizChannelData[i][\"end\"] = pizChannelData[i][\"start\"];\n          pizChannelData[i][\"nx\"] = info.width;\n          pizChannelData[i][\"ny\"] = info.lines;\n          pizChannelData[i][\"size\"] = info.type;\n          outBufferEnd += pizChannelData[i].nx * pizChannelData[i].ny * pizChannelData[i].size;\n        }\n        var minNonZero = parseUint16(inDataView, inOffset);\n        var maxNonZero = parseUint16(inDataView, inOffset);\n        if (maxNonZero >= BITMAP_SIZE) {\n          throw \"Something is wrong with PIZ_COMPRESSION BITMAP_SIZE\";\n        }\n        if (minNonZero <= maxNonZero) {\n          for (var i = 0; i < maxNonZero - minNonZero + 1; i++) {\n            bitmap[i + minNonZero] = parseUint8(inDataView, inOffset);\n          }\n        }\n        var lut = new Uint16Array(USHORT_RANGE);\n        var maxValue = reverseLutFromBitmap(bitmap, lut);\n        var length = parseUint32(inDataView, inOffset);\n        hufUncompress(info.array, inDataView, inOffset, length, outBuffer, outBufferEnd);\n        for (var i = 0; i < info.channels; ++i) {\n          var cd = pizChannelData[i];\n          for (var j = 0; j < pizChannelData[i].size; ++j) {\n            wav2Decode(outBuffer, cd.start + j, cd.nx, cd.size, cd.ny, cd.nx * cd.size, maxValue);\n          }\n        }\n        applyLut(lut, outBuffer, outBufferEnd);\n        var tmpOffset2 = 0;\n        var tmpBuffer = new Uint8Array(outBuffer.buffer.byteLength);\n        for (var y = 0; y < info.lines; y++) {\n          for (var c = 0; c < info.channels; c++) {\n            var cd = pizChannelData[c];\n            var n = cd.nx * cd.size;\n            var cp = new Uint8Array(outBuffer.buffer, cd.end * INT16_SIZE, n * INT16_SIZE);\n            tmpBuffer.set(cp, tmpOffset2);\n            tmpOffset2 += n * INT16_SIZE;\n            cd.end += n;\n          }\n        }\n        return new DataView(tmpBuffer.buffer);\n      }\n      function uncompressPXR(info) {\n        var compressed = info.array.slice(info.offset.value, info.offset.value + info.size);\n        var rawBuffer = unzlibSync(compressed);\n        var sz = info.lines * info.channels * info.width;\n        var tmpBuffer = info.type == 1 ? new Uint16Array(sz) : new Uint32Array(sz);\n        var tmpBufferEnd = 0;\n        var writePtr = 0;\n        var ptr = new Array(4);\n        for (var y = 0; y < info.lines; y++) {\n          for (var c = 0; c < info.channels; c++) {\n            var pixel = 0;\n            switch (info.type) {\n              case 1:\n                ptr[0] = tmpBufferEnd;\n                ptr[1] = ptr[0] + info.width;\n                tmpBufferEnd = ptr[1] + info.width;\n                for (var j = 0; j < info.width; ++j) {\n                  var diff = rawBuffer[ptr[0]++] << 8 | rawBuffer[ptr[1]++];\n                  pixel += diff;\n                  tmpBuffer[writePtr] = pixel;\n                  writePtr++;\n                }\n                break;\n              case 2:\n                ptr[0] = tmpBufferEnd;\n                ptr[1] = ptr[0] + info.width;\n                ptr[2] = ptr[1] + info.width;\n                tmpBufferEnd = ptr[2] + info.width;\n                for (var _j = 0; _j < info.width; ++_j) {\n                  var _diff = rawBuffer[ptr[0]++] << 24 | rawBuffer[ptr[1]++] << 16 | rawBuffer[ptr[2]++] << 8;\n                  pixel += _diff;\n                  tmpBuffer[writePtr] = pixel;\n                  writePtr++;\n                }\n                break;\n            }\n          }\n        }\n        return new DataView(tmpBuffer.buffer);\n      }\n      function uncompressDWA(info) {\n        var inDataView = info.viewer;\n        var inOffset = {\n          value: info.offset.value\n        };\n        var outBuffer = new Uint8Array(info.width * info.lines * (info.channels * info.type * INT16_SIZE));\n        var dwaHeader = {\n          version: parseInt64(inDataView, inOffset),\n          unknownUncompressedSize: parseInt64(inDataView, inOffset),\n          unknownCompressedSize: parseInt64(inDataView, inOffset),\n          acCompressedSize: parseInt64(inDataView, inOffset),\n          dcCompressedSize: parseInt64(inDataView, inOffset),\n          rleCompressedSize: parseInt64(inDataView, inOffset),\n          rleUncompressedSize: parseInt64(inDataView, inOffset),\n          rleRawSize: parseInt64(inDataView, inOffset),\n          totalAcUncompressedCount: parseInt64(inDataView, inOffset),\n          totalDcUncompressedCount: parseInt64(inDataView, inOffset),\n          acCompression: parseInt64(inDataView, inOffset)\n        };\n        if (dwaHeader.version < 2) {\n          throw \"EXRLoader.parse: \" + EXRHeader.compression + \" version \" + dwaHeader.version + \" is unsupported\";\n        }\n        var channelRules = new Array();\n        var ruleSize = parseUint16(inDataView, inOffset) - INT16_SIZE;\n        while (ruleSize > 0) {\n          var name = parseNullTerminatedString(inDataView.buffer, inOffset);\n          var value = parseUint8(inDataView, inOffset);\n          var compression = value >> 2 & 3;\n          var csc = (value >> 4) - 1;\n          var index = new Int8Array([csc])[0];\n          var type = parseUint8(inDataView, inOffset);\n          channelRules.push({\n            name: name,\n            index: index,\n            type: type,\n            compression: compression\n          });\n          ruleSize -= name.length + 3;\n        }\n        var channels = EXRHeader.channels;\n        var channelData = new Array(info.channels);\n        for (var i = 0; i < info.channels; ++i) {\n          var cd = channelData[i] = {};\n          var channel = channels[i];\n          cd.name = channel.name;\n          cd.compression = UNKNOWN;\n          cd.decoded = false;\n          cd.type = channel.pixelType;\n          cd.pLinear = channel.pLinear;\n          cd.width = info.width;\n          cd.height = info.lines;\n        }\n        var cscSet = {\n          idx: new Array(3)\n        };\n        for (var offset2 = 0; offset2 < info.channels; ++offset2) {\n          var cd = channelData[offset2];\n          for (var i = 0; i < channelRules.length; ++i) {\n            var rule = channelRules[i];\n            if (cd.name == rule.name) {\n              cd.compression = rule.compression;\n              if (rule.index >= 0) {\n                cscSet.idx[rule.index] = offset2;\n              }\n              cd.offset = offset2;\n            }\n          }\n        }\n        if (dwaHeader.acCompressedSize > 0) {\n          switch (dwaHeader.acCompression) {\n            case STATIC_HUFFMAN:\n              var acBuffer = new Uint16Array(dwaHeader.totalAcUncompressedCount);\n              hufUncompress(info.array, inDataView, inOffset, dwaHeader.acCompressedSize, acBuffer, dwaHeader.totalAcUncompressedCount);\n              break;\n            case DEFLATE:\n              var compressed = info.array.slice(inOffset.value, inOffset.value + dwaHeader.totalAcUncompressedCount);\n              var data = unzlibSync(compressed);\n              var acBuffer = new Uint16Array(data.buffer);\n              inOffset.value += dwaHeader.totalAcUncompressedCount;\n              break;\n          }\n        }\n        if (dwaHeader.dcCompressedSize > 0) {\n          var zlibInfo = {\n            array: info.array,\n            offset: inOffset,\n            size: dwaHeader.dcCompressedSize\n          };\n          var dcBuffer = new Uint16Array(uncompressZIP(zlibInfo).buffer);\n          inOffset.value += dwaHeader.dcCompressedSize;\n        }\n        if (dwaHeader.rleRawSize > 0) {\n          var compressed = info.array.slice(inOffset.value, inOffset.value + dwaHeader.rleCompressedSize);\n          var data = unzlibSync(compressed);\n          var rleBuffer = decodeRunLength(data.buffer);\n          inOffset.value += dwaHeader.rleCompressedSize;\n        }\n        var outBufferEnd = 0;\n        var rowOffsets = new Array(channelData.length);\n        for (var i = 0; i < rowOffsets.length; ++i) {\n          rowOffsets[i] = new Array();\n        }\n        for (var y = 0; y < info.lines; ++y) {\n          for (var chan = 0; chan < channelData.length; ++chan) {\n            rowOffsets[chan].push(outBufferEnd);\n            outBufferEnd += channelData[chan].width * info.type * INT16_SIZE;\n          }\n        }\n        lossyDctDecode(cscSet, rowOffsets, channelData, acBuffer, dcBuffer, outBuffer);\n        for (var i = 0; i < channelData.length; ++i) {\n          var cd = channelData[i];\n          if (cd.decoded) continue;\n          switch (cd.compression) {\n            case RLE:\n              var row = 0;\n              var rleOffset = 0;\n              for (var y = 0; y < info.lines; ++y) {\n                var rowOffsetBytes = rowOffsets[i][row];\n                for (var x = 0; x < cd.width; ++x) {\n                  for (var byte = 0; byte < INT16_SIZE * cd.type; ++byte) {\n                    outBuffer[rowOffsetBytes++] = rleBuffer[rleOffset + byte * cd.width * cd.height];\n                  }\n                  rleOffset++;\n                }\n                row++;\n              }\n              break;\n            case LOSSY_DCT:\n            default:\n              throw \"EXRLoader.parse: unsupported channel compression\";\n          }\n        }\n        return new DataView(outBuffer.buffer);\n      }\n      function parseNullTerminatedString(buffer2, offset2) {\n        var uintBuffer = new Uint8Array(buffer2);\n        var endOffset = 0;\n        while (uintBuffer[offset2.value + endOffset] != 0) {\n          endOffset += 1;\n        }\n        var stringValue = new TextDecoder().decode(uintBuffer.slice(offset2.value, offset2.value + endOffset));\n        offset2.value = offset2.value + endOffset + 1;\n        return stringValue;\n      }\n      function parseFixedLengthString(buffer2, offset2, size) {\n        var stringValue = new TextDecoder().decode(new Uint8Array(buffer2).slice(offset2.value, offset2.value + size));\n        offset2.value = offset2.value + size;\n        return stringValue;\n      }\n      function parseRational(dataView, offset2) {\n        var x = parseInt32(dataView, offset2);\n        var y = parseUint32(dataView, offset2);\n        return [x, y];\n      }\n      function parseTimecode(dataView, offset2) {\n        var x = parseUint32(dataView, offset2);\n        var y = parseUint32(dataView, offset2);\n        return [x, y];\n      }\n      function parseInt32(dataView, offset2) {\n        var Int32 = dataView.getInt32(offset2.value, true);\n        offset2.value = offset2.value + INT32_SIZE;\n        return Int32;\n      }\n      function parseUint32(dataView, offset2) {\n        var Uint32 = dataView.getUint32(offset2.value, true);\n        offset2.value = offset2.value + INT32_SIZE;\n        return Uint32;\n      }\n      function parseUint8Array(uInt8Array2, offset2) {\n        var Uint8 = uInt8Array2[offset2.value];\n        offset2.value = offset2.value + INT8_SIZE;\n        return Uint8;\n      }\n      function parseUint8(dataView, offset2) {\n        var Uint8 = dataView.getUint8(offset2.value);\n        offset2.value = offset2.value + INT8_SIZE;\n        return Uint8;\n      }\n      var parseInt64 = function parseInt64(dataView, offset2) {\n        var int;\n        if (\"getBigInt64\" in DataView.prototype) {\n          int = Number(dataView.getBigInt64(offset2.value, true));\n        } else {\n          int = dataView.getUint32(offset2.value + 4, true) + Number(dataView.getUint32(offset2.value, true) << 32);\n        }\n        offset2.value += ULONG_SIZE;\n        return int;\n      };\n      function parseFloat32(dataView, offset2) {\n        var float = dataView.getFloat32(offset2.value, true);\n        offset2.value += FLOAT32_SIZE;\n        return float;\n      }\n      function decodeFloat32(dataView, offset2) {\n        return DataUtils.toHalfFloat(parseFloat32(dataView, offset2));\n      }\n      function decodeFloat16(binary) {\n        var exponent = (binary & 31744) >> 10,\n          fraction = binary & 1023;\n        return (binary >> 15 ? -1 : 1) * (exponent ? exponent === 31 ? fraction ? NaN : Infinity : Math.pow(2, exponent - 15) * (1 + fraction / 1024) : 6103515625e-14 * (fraction / 1024));\n      }\n      function parseUint16(dataView, offset2) {\n        var Uint16 = dataView.getUint16(offset2.value, true);\n        offset2.value += INT16_SIZE;\n        return Uint16;\n      }\n      function parseFloat16(buffer2, offset2) {\n        return decodeFloat16(parseUint16(buffer2, offset2));\n      }\n      function parseChlist(dataView, buffer2, offset2, size) {\n        var startOffset = offset2.value;\n        var channels = [];\n        while (offset2.value < startOffset + size - 1) {\n          var name = parseNullTerminatedString(buffer2, offset2);\n          var pixelType = parseInt32(dataView, offset2);\n          var pLinear = parseUint8(dataView, offset2);\n          offset2.value += 3;\n          var xSampling = parseInt32(dataView, offset2);\n          var ySampling = parseInt32(dataView, offset2);\n          channels.push({\n            name: name,\n            pixelType: pixelType,\n            pLinear: pLinear,\n            xSampling: xSampling,\n            ySampling: ySampling\n          });\n        }\n        offset2.value += 1;\n        return channels;\n      }\n      function parseChromaticities(dataView, offset2) {\n        var redX = parseFloat32(dataView, offset2);\n        var redY = parseFloat32(dataView, offset2);\n        var greenX = parseFloat32(dataView, offset2);\n        var greenY = parseFloat32(dataView, offset2);\n        var blueX = parseFloat32(dataView, offset2);\n        var blueY = parseFloat32(dataView, offset2);\n        var whiteX = parseFloat32(dataView, offset2);\n        var whiteY = parseFloat32(dataView, offset2);\n        return {\n          redX: redX,\n          redY: redY,\n          greenX: greenX,\n          greenY: greenY,\n          blueX: blueX,\n          blueY: blueY,\n          whiteX: whiteX,\n          whiteY: whiteY\n        };\n      }\n      function parseCompression(dataView, offset2) {\n        var compressionCodes = [\"NO_COMPRESSION\", \"RLE_COMPRESSION\", \"ZIPS_COMPRESSION\", \"ZIP_COMPRESSION\", \"PIZ_COMPRESSION\", \"PXR24_COMPRESSION\", \"B44_COMPRESSION\", \"B44A_COMPRESSION\", \"DWAA_COMPRESSION\", \"DWAB_COMPRESSION\"];\n        var compression = parseUint8(dataView, offset2);\n        return compressionCodes[compression];\n      }\n      function parseBox2i(dataView, offset2) {\n        var xMin = parseUint32(dataView, offset2);\n        var yMin = parseUint32(dataView, offset2);\n        var xMax = parseUint32(dataView, offset2);\n        var yMax = parseUint32(dataView, offset2);\n        return {\n          xMin: xMin,\n          yMin: yMin,\n          xMax: xMax,\n          yMax: yMax\n        };\n      }\n      function parseLineOrder(dataView, offset2) {\n        var lineOrders = [\"INCREASING_Y\"];\n        var lineOrder = parseUint8(dataView, offset2);\n        return lineOrders[lineOrder];\n      }\n      function parseV2f(dataView, offset2) {\n        var x = parseFloat32(dataView, offset2);\n        var y = parseFloat32(dataView, offset2);\n        return [x, y];\n      }\n      function parseV3f(dataView, offset2) {\n        var x = parseFloat32(dataView, offset2);\n        var y = parseFloat32(dataView, offset2);\n        var z = parseFloat32(dataView, offset2);\n        return [x, y, z];\n      }\n      function parseValue(dataView, buffer2, offset2, type, size) {\n        if (type === \"string\" || type === \"stringvector\" || type === \"iccProfile\") {\n          return parseFixedLengthString(buffer2, offset2, size);\n        } else if (type === \"chlist\") {\n          return parseChlist(dataView, buffer2, offset2, size);\n        } else if (type === \"chromaticities\") {\n          return parseChromaticities(dataView, offset2);\n        } else if (type === \"compression\") {\n          return parseCompression(dataView, offset2);\n        } else if (type === \"box2i\") {\n          return parseBox2i(dataView, offset2);\n        } else if (type === \"lineOrder\") {\n          return parseLineOrder(dataView, offset2);\n        } else if (type === \"float\") {\n          return parseFloat32(dataView, offset2);\n        } else if (type === \"v2f\") {\n          return parseV2f(dataView, offset2);\n        } else if (type === \"v3f\") {\n          return parseV3f(dataView, offset2);\n        } else if (type === \"int\") {\n          return parseInt32(dataView, offset2);\n        } else if (type === \"rational\") {\n          return parseRational(dataView, offset2);\n        } else if (type === \"timecode\") {\n          return parseTimecode(dataView, offset2);\n        } else if (type === \"preview\") {\n          offset2.value += size;\n          return \"skipped\";\n        } else {\n          offset2.value += size;\n          return void 0;\n        }\n      }\n      function parseHeader(dataView, buffer2, offset2) {\n        var EXRHeader2 = {};\n        if (dataView.getUint32(0, true) != 20000630) {\n          throw \"THREE.EXRLoader: provided file doesn't appear to be in OpenEXR format.\";\n        }\n        EXRHeader2.version = dataView.getUint8(4);\n        var spec = dataView.getUint8(5);\n        EXRHeader2.spec = {\n          singleTile: !!(spec & 2),\n          longName: !!(spec & 4),\n          deepFormat: !!(spec & 8),\n          multiPart: !!(spec & 16)\n        };\n        offset2.value = 8;\n        var keepReading = true;\n        while (keepReading) {\n          var attributeName = parseNullTerminatedString(buffer2, offset2);\n          if (attributeName == 0) {\n            keepReading = false;\n          } else {\n            var attributeType = parseNullTerminatedString(buffer2, offset2);\n            var attributeSize = parseUint32(dataView, offset2);\n            var attributeValue = parseValue(dataView, buffer2, offset2, attributeType, attributeSize);\n            if (attributeValue === void 0) {\n              console.warn(\"EXRLoader.parse: skipped unknown header attribute type '\".concat(attributeType, \"'.\"));\n            } else {\n              EXRHeader2[attributeName] = attributeValue;\n            }\n          }\n        }\n        if ((spec & ~4) != 0) {\n          console.error(\"EXRHeader:\", EXRHeader2);\n          throw \"THREE.EXRLoader: provided file is currently unsupported.\";\n        }\n        return EXRHeader2;\n      }\n      function setupDecoder(EXRHeader2, dataView, uInt8Array2, offset2, outputType) {\n        var EXRDecoder2 = _defineProperty({\n          size: 0,\n          viewer: dataView,\n          array: uInt8Array2,\n          offset: offset2,\n          width: EXRHeader2.dataWindow.xMax - EXRHeader2.dataWindow.xMin + 1,\n          height: EXRHeader2.dataWindow.yMax - EXRHeader2.dataWindow.yMin + 1,\n          channels: EXRHeader2.channels.length,\n          bytesPerLine: null,\n          lines: null,\n          inputSize: null,\n          type: EXRHeader2.channels[0].pixelType,\n          uncompress: null,\n          getter: null,\n          format: null\n        }, hasColorSpace ? \"colorSpace\" : \"encoding\", null);\n        switch (EXRHeader2.compression) {\n          case \"NO_COMPRESSION\":\n            EXRDecoder2.lines = 1;\n            EXRDecoder2.uncompress = uncompressRAW;\n            break;\n          case \"RLE_COMPRESSION\":\n            EXRDecoder2.lines = 1;\n            EXRDecoder2.uncompress = uncompressRLE;\n            break;\n          case \"ZIPS_COMPRESSION\":\n            EXRDecoder2.lines = 1;\n            EXRDecoder2.uncompress = uncompressZIP;\n            break;\n          case \"ZIP_COMPRESSION\":\n            EXRDecoder2.lines = 16;\n            EXRDecoder2.uncompress = uncompressZIP;\n            break;\n          case \"PIZ_COMPRESSION\":\n            EXRDecoder2.lines = 32;\n            EXRDecoder2.uncompress = uncompressPIZ;\n            break;\n          case \"PXR24_COMPRESSION\":\n            EXRDecoder2.lines = 16;\n            EXRDecoder2.uncompress = uncompressPXR;\n            break;\n          case \"DWAA_COMPRESSION\":\n            EXRDecoder2.lines = 32;\n            EXRDecoder2.uncompress = uncompressDWA;\n            break;\n          case \"DWAB_COMPRESSION\":\n            EXRDecoder2.lines = 256;\n            EXRDecoder2.uncompress = uncompressDWA;\n            break;\n          default:\n            throw \"EXRLoader.parse: \" + EXRHeader2.compression + \" is unsupported\";\n        }\n        EXRDecoder2.scanlineBlockSize = EXRDecoder2.lines;\n        if (EXRDecoder2.type == 1) {\n          switch (outputType) {\n            case FloatType:\n              EXRDecoder2.getter = parseFloat16;\n              EXRDecoder2.inputSize = INT16_SIZE;\n              break;\n            case HalfFloatType:\n              EXRDecoder2.getter = parseUint16;\n              EXRDecoder2.inputSize = INT16_SIZE;\n              break;\n          }\n        } else if (EXRDecoder2.type == 2) {\n          switch (outputType) {\n            case FloatType:\n              EXRDecoder2.getter = parseFloat32;\n              EXRDecoder2.inputSize = FLOAT32_SIZE;\n              break;\n            case HalfFloatType:\n              EXRDecoder2.getter = decodeFloat32;\n              EXRDecoder2.inputSize = FLOAT32_SIZE;\n          }\n        } else {\n          throw \"EXRLoader.parse: unsupported pixelType \" + EXRDecoder2.type + \" for \" + EXRHeader2.compression + \".\";\n        }\n        EXRDecoder2.blockCount = (EXRHeader2.dataWindow.yMax + 1) / EXRDecoder2.scanlineBlockSize;\n        for (var i = 0; i < EXRDecoder2.blockCount; i++) parseInt64(dataView, offset2);\n        EXRDecoder2.outputChannels = EXRDecoder2.channels == 3 ? 4 : EXRDecoder2.channels;\n        var size = EXRDecoder2.width * EXRDecoder2.height * EXRDecoder2.outputChannels;\n        switch (outputType) {\n          case FloatType:\n            EXRDecoder2.byteArray = new Float32Array(size);\n            if (EXRDecoder2.channels < EXRDecoder2.outputChannels) EXRDecoder2.byteArray.fill(1, 0, size);\n            break;\n          case HalfFloatType:\n            EXRDecoder2.byteArray = new Uint16Array(size);\n            if (EXRDecoder2.channels < EXRDecoder2.outputChannels) EXRDecoder2.byteArray.fill(15360, 0, size);\n            break;\n          default:\n            console.error(\"THREE.EXRLoader: unsupported type: \", outputType);\n            break;\n        }\n        EXRDecoder2.bytesPerLine = EXRDecoder2.width * EXRDecoder2.inputSize * EXRDecoder2.channels;\n        if (EXRDecoder2.outputChannels == 4) EXRDecoder2.format = RGBAFormat;else EXRDecoder2.format = RedFormat;\n        if (hasColorSpace) EXRDecoder2.colorSpace = \"srgb-linear\";else EXRDecoder2.encoding = 3e3;\n        return EXRDecoder2;\n      }\n      var bufferDataView = new DataView(buffer);\n      var uInt8Array = new Uint8Array(buffer);\n      var offset = {\n        value: 0\n      };\n      var EXRHeader = parseHeader(bufferDataView, buffer, offset);\n      var EXRDecoder = setupDecoder(EXRHeader, bufferDataView, uInt8Array, offset, this.type);\n      var tmpOffset = {\n        value: 0\n      };\n      var channelOffsets = {\n        R: 0,\n        G: 1,\n        B: 2,\n        A: 3,\n        Y: 0\n      };\n      for (var scanlineBlockIdx = 0; scanlineBlockIdx < EXRDecoder.height / EXRDecoder.scanlineBlockSize; scanlineBlockIdx++) {\n        var line = parseUint32(bufferDataView, offset);\n        EXRDecoder.size = parseUint32(bufferDataView, offset);\n        EXRDecoder.lines = line + EXRDecoder.scanlineBlockSize > EXRDecoder.height ? EXRDecoder.height - line : EXRDecoder.scanlineBlockSize;\n        var isCompressed = EXRDecoder.size < EXRDecoder.lines * EXRDecoder.bytesPerLine;\n        var viewer = isCompressed ? EXRDecoder.uncompress(EXRDecoder) : uncompressRAW(EXRDecoder);\n        offset.value += EXRDecoder.size;\n        for (var line_y = 0; line_y < EXRDecoder.scanlineBlockSize; line_y++) {\n          var true_y = line_y + scanlineBlockIdx * EXRDecoder.scanlineBlockSize;\n          if (true_y >= EXRDecoder.height) break;\n          for (var channelID = 0; channelID < EXRDecoder.channels; channelID++) {\n            var cOff = channelOffsets[EXRHeader.channels[channelID].name];\n            for (var x = 0; x < EXRDecoder.width; x++) {\n              tmpOffset.value = (line_y * (EXRDecoder.channels * EXRDecoder.width) + channelID * EXRDecoder.width + x) * EXRDecoder.inputSize;\n              var outIndex = (EXRDecoder.height - 1 - true_y) * (EXRDecoder.width * EXRDecoder.outputChannels) + x * EXRDecoder.outputChannels + cOff;\n              EXRDecoder.byteArray[outIndex] = EXRDecoder.getter(viewer, tmpOffset);\n            }\n          }\n        }\n      }\n      return _ref = {\n        header: EXRHeader,\n        width: EXRDecoder.width,\n        height: EXRDecoder.height,\n        data: EXRDecoder.byteArray,\n        format: EXRDecoder.format\n      }, _defineProperty(_ref, hasColorSpace ? \"colorSpace\" : \"encoding\", EXRDecoder[hasColorSpace ? \"colorSpace\" : \"encoding\"]), _defineProperty(_ref, \"type\", this.type), _ref;\n    }\n  }, {\n    key: \"setDataType\",\n    value: function setDataType(value) {\n      this.type = value;\n      return this;\n    }\n  }, {\n    key: \"load\",\n    value: function load(url, onLoad, onProgress, onError) {\n      function onLoadCallback(texture, texData) {\n        if (hasColorSpace) texture.colorSpace = texData.colorSpace;else texture.encoding = texData.encoding;\n        texture.minFilter = LinearFilter;\n        texture.magFilter = LinearFilter;\n        texture.generateMipmaps = false;\n        texture.flipY = false;\n        if (onLoad) onLoad(texture, texData);\n      }\n      return _get(_getPrototypeOf(EXRLoader.prototype), \"load\", this).call(this, url, onLoadCallback, onProgress, onError);\n    }\n  }]);\n  return EXRLoader;\n}(DataTextureLoader);\nexport { EXRLoader };","map":{"version":3,"names":["hasColorSpace","Texture","EXRLoader","_DataTextureLoader","_inherits","_super","_createSuper","manager","_this","_classCallCheck","call","type","HalfFloatType","_createClass","key","value","parse","buffer","_ref","USHORT_RANGE","BITMAP_SIZE","HUF_ENCBITS","HUF_DECBITS","HUF_ENCSIZE","HUF_DECSIZE","HUF_DECMASK","NBITS","A_OFFSET","MOD_MASK","SHORT_ZEROCODE_RUN","LONG_ZEROCODE_RUN","SHORTEST_LONG_RUN","ULONG_SIZE","FLOAT32_SIZE","INT32_SIZE","INT16_SIZE","INT8_SIZE","STATIC_HUFFMAN","DEFLATE","UNKNOWN","LOSSY_DCT","RLE","logBase","Math","pow","reverseLutFromBitmap","bitmap","lut","k","i","n","hufClearDecTable","hdec","len","lit","p","getBitsReturn","l","c","lc","getBits","nBits","uInt8Array2","inOffset","parseUint8Array","hufTableBuffer","Array","hufCanonicalCodeTable","hcode","nc","hufUnpackEncTable","inDataView","ni","im","iM","zerun","hufLength","code","hufCode","hufBuildDecTable","hdecod","pl","plOffset","getCharReturn","getChar","getCodeReturn","getCode","po","rlc","outBuffer","outBufferOffset","outBufferEndOffset","cs","Uint8Array","s","UInt16","Int16","ref","wdec14Return","a","b","wdec14","h","ls","hs","hi","ai","as","bs","wdec16","m","d","bb","aa","wav2Decode","buffer2","j","nx","ox","ny","oy","mx","w14","p2","py","ey","oy1","oy2","ox1","ox2","i00","i01","i10","i11","px","ex","p01","p10","p11","hufDecode","encodingTable","decodingTable","no","outOffset","inOffsetEnd","trunc","index","hufUncompress","nCompressed","nRaw","initialInOffset","parseUint32","freq","applyLut","data","nData","predictor","source","t","length","interleaveScalar","out","t1","t2","floor","stop","decodeRunLength","size","byteLength","reader","DataView","getInt8","count","push","getUint8","lossyDctDecode","cscSet","rowPtrs","channelData","acBuffer","dcBuffer","dataView","width","idx","height","numComp","numFullBlocksX","numBlocksX","ceil","numBlocksY","leftoverX","leftoverY","currAcComp","currDcComp","dctData","halfZigBlock","rowBlock","rowOffsets","comp2","Float32Array","Uint16Array","blocky","maxY","maxX","blockx","fill","unRleAC","unZigZag","dctInverse","csc709Inverse","convertToHalf","offset2","type2","y2","src","setUint16","offset3","x2","halfRow","comp","decoded","y","x","getUint16","setFloat32","decodeFloat16","acValue","dctComp","dst","cos","e","f","g","alpha","beta","theta","gamma","row","rowPtr","column","cb","cr","DataUtils","toHalfFloat","toLinear","float","sign","abs","uncompressRAW","info","array","offset","uncompressRLE","compressed","viewer","slice","rawBuffer","tmpBuffer","uncompressZIP","unzlibSync","uncompressPIZ","scanlineBlockSize","channels","outBufferEnd","pizChannelData","lines","minNonZero","parseUint16","maxNonZero","parseUint8","maxValue","cd","start","tmpOffset2","cp","end","set","uncompressPXR","sz","Uint32Array","tmpBufferEnd","writePtr","ptr","pixel","diff","uncompressDWA","dwaHeader","version","parseInt64","unknownUncompressedSize","unknownCompressedSize","acCompressedSize","dcCompressedSize","rleCompressedSize","rleUncompressedSize","rleRawSize","totalAcUncompressedCount","totalDcUncompressedCount","acCompression","EXRHeader","compression","channelRules","ruleSize","name","parseNullTerminatedString","csc","Int8Array","channel","pixelType","pLinear","rule","zlibInfo","rleBuffer","chan","rleOffset","rowOffsetBytes","byte","uintBuffer","endOffset","stringValue","TextDecoder","decode","parseFixedLengthString","parseRational","parseInt32","parseTimecode","Int32","getInt32","Uint32","getUint32","Uint8","int","prototype","Number","getBigInt64","parseFloat32","getFloat32","decodeFloat32","binary","exponent","fraction","NaN","Infinity","Uint16","parseFloat16","parseChlist","startOffset","xSampling","ySampling","parseChromaticities","redX","redY","greenX","greenY","blueX","blueY","whiteX","whiteY","parseCompression","compressionCodes","parseBox2i","xMin","yMin","xMax","yMax","parseLineOrder","lineOrders","lineOrder","parseV2f","parseV3f","z","parseValue","parseHeader","EXRHeader2","spec","singleTile","longName","deepFormat","multiPart","keepReading","attributeName","attributeType","attributeSize","attributeValue","console","warn","concat","error","setupDecoder","outputType","EXRDecoder2","_defineProperty","dataWindow","bytesPerLine","inputSize","uncompress","getter","format","FloatType","blockCount","outputChannels","byteArray","RGBAFormat","RedFormat","colorSpace","encoding","bufferDataView","uInt8Array","EXRDecoder","tmpOffset","channelOffsets","R","G","B","A","Y","scanlineBlockIdx","line","isCompressed","line_y","true_y","channelID","cOff","outIndex","header","setDataType","load","url","onLoad","onProgress","onError","onLoadCallback","texture","texData","minFilter","LinearFilter","magFilter","generateMipmaps","flipY","_get","_getPrototypeOf","DataTextureLoader"],"sources":["C:\\Users\\Nayyu\\Desktop\\skibidai-public-build\\node_modules\\src\\loaders\\EXRLoader.js"],"sourcesContent":["import {\n  Texture,\n  DataTextureLoader,\n  DataUtils,\n  FloatType,\n  HalfFloatType,\n  LinearFilter,\n  RedFormat,\n  RGBAFormat,\n} from 'three'\nimport { unzlibSync } from 'fflate'\n\n/**\n * OpenEXR loader currently supports uncompressed, ZIP(S), RLE, PIZ and DWA/B compression.\n * Supports reading as UnsignedByte, HalfFloat and Float type data texture.\n *\n * Referred to the original Industrial Light & Magic OpenEXR implementation and the TinyEXR / Syoyo Fujita\n * implementation, so I have preserved their copyright notices.\n */\n\n// /*\n// Copyright (c) 2014 - 2017, Syoyo Fujita\n// All rights reserved.\n\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are met:\n//     * Redistributions of source code must retain the above copyright\n//       notice, this list of conditions and the following disclaimer.\n//     * Redistributions in binary form must reproduce the above copyright\n//       notice, this list of conditions and the following disclaimer in the\n//       documentation and/or other materials provided with the distribution.\n//     * Neither the name of the Syoyo Fujita nor the\n//       names of its contributors may be used to endorse or promote products\n//       derived from this software without specific prior written permission.\n\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n// DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY\n// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n// */\n\n// // TinyEXR contains some OpenEXR code, which is licensed under ------------\n\n// ///////////////////////////////////////////////////////////////////////////\n// //\n// // Copyright (c) 2002, Industrial Light & Magic, a division of Lucas\n// // Digital Ltd. LLC\n// //\n// // All rights reserved.\n// //\n// // Redistribution and use in source and binary forms, with or without\n// // modification, are permitted provided that the following conditions are\n// // met:\n// // *       Redistributions of source code must retain the above copyright\n// // notice, this list of conditions and the following disclaimer.\n// // *       Redistributions in binary form must reproduce the above\n// // copyright notice, this list of conditions and the following disclaimer\n// // in the documentation and/or other materials provided with the\n// // distribution.\n// // *       Neither the name of Industrial Light & Magic nor the names of\n// // its contributors may be used to endorse or promote products derived\n// // from this software without specific prior written permission.\n// //\n// // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// // \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// // LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// // A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// // OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// // SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// // LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// // DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// // THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n// //\n// ///////////////////////////////////////////////////////////////////////////\n\n// // End of OpenEXR license -------------------------------------------------\n\nconst hasColorSpace = 'colorSpace' in new Texture()\n\nclass EXRLoader extends DataTextureLoader {\n  constructor(manager) {\n    super(manager)\n\n    this.type = HalfFloatType\n  }\n\n  parse(buffer) {\n    const USHORT_RANGE = 1 << 16\n    const BITMAP_SIZE = USHORT_RANGE >> 3\n\n    const HUF_ENCBITS = 16 // literal (value) bit length\n    const HUF_DECBITS = 14 // decoding bit size (>= 8)\n\n    const HUF_ENCSIZE = (1 << HUF_ENCBITS) + 1 // encoding table size\n    const HUF_DECSIZE = 1 << HUF_DECBITS // decoding table size\n    const HUF_DECMASK = HUF_DECSIZE - 1\n\n    const NBITS = 16\n    const A_OFFSET = 1 << (NBITS - 1)\n    const MOD_MASK = (1 << NBITS) - 1\n\n    const SHORT_ZEROCODE_RUN = 59\n    const LONG_ZEROCODE_RUN = 63\n    const SHORTEST_LONG_RUN = 2 + LONG_ZEROCODE_RUN - SHORT_ZEROCODE_RUN\n\n    const ULONG_SIZE = 8\n    const FLOAT32_SIZE = 4\n    const INT32_SIZE = 4\n    const INT16_SIZE = 2\n    const INT8_SIZE = 1\n\n    const STATIC_HUFFMAN = 0\n    const DEFLATE = 1\n\n    const UNKNOWN = 0\n    const LOSSY_DCT = 1\n    const RLE = 2\n\n    const logBase = Math.pow(2.7182818, 2.2)\n\n    function reverseLutFromBitmap(bitmap, lut) {\n      var k = 0\n\n      for (var i = 0; i < USHORT_RANGE; ++i) {\n        if (i == 0 || bitmap[i >> 3] & (1 << (i & 7))) {\n          lut[k++] = i\n        }\n      }\n\n      var n = k - 1\n\n      while (k < USHORT_RANGE) lut[k++] = 0\n\n      return n\n    }\n\n    function hufClearDecTable(hdec) {\n      for (var i = 0; i < HUF_DECSIZE; i++) {\n        hdec[i] = {}\n        hdec[i].len = 0\n        hdec[i].lit = 0\n        hdec[i].p = null\n      }\n    }\n\n    const getBitsReturn = { l: 0, c: 0, lc: 0 }\n\n    function getBits(nBits, c, lc, uInt8Array, inOffset) {\n      while (lc < nBits) {\n        c = (c << 8) | parseUint8Array(uInt8Array, inOffset)\n        lc += 8\n      }\n\n      lc -= nBits\n\n      getBitsReturn.l = (c >> lc) & ((1 << nBits) - 1)\n      getBitsReturn.c = c\n      getBitsReturn.lc = lc\n    }\n\n    const hufTableBuffer = new Array(59)\n\n    function hufCanonicalCodeTable(hcode) {\n      for (var i = 0; i <= 58; ++i) hufTableBuffer[i] = 0\n      for (var i = 0; i < HUF_ENCSIZE; ++i) hufTableBuffer[hcode[i]] += 1\n\n      var c = 0\n\n      for (var i = 58; i > 0; --i) {\n        var nc = (c + hufTableBuffer[i]) >> 1\n        hufTableBuffer[i] = c\n        c = nc\n      }\n\n      for (var i = 0; i < HUF_ENCSIZE; ++i) {\n        var l = hcode[i]\n        if (l > 0) hcode[i] = l | (hufTableBuffer[l]++ << 6)\n      }\n    }\n\n    function hufUnpackEncTable(uInt8Array, inDataView, inOffset, ni, im, iM, hcode) {\n      var p = inOffset\n      var c = 0\n      var lc = 0\n\n      for (; im <= iM; im++) {\n        if (p.value - inOffset.value > ni) return false\n\n        getBits(6, c, lc, uInt8Array, p)\n\n        var l = getBitsReturn.l\n        c = getBitsReturn.c\n        lc = getBitsReturn.lc\n\n        hcode[im] = l\n\n        if (l == LONG_ZEROCODE_RUN) {\n          if (p.value - inOffset.value > ni) {\n            throw 'Something wrong with hufUnpackEncTable'\n          }\n\n          getBits(8, c, lc, uInt8Array, p)\n\n          var zerun = getBitsReturn.l + SHORTEST_LONG_RUN\n          c = getBitsReturn.c\n          lc = getBitsReturn.lc\n\n          if (im + zerun > iM + 1) {\n            throw 'Something wrong with hufUnpackEncTable'\n          }\n\n          while (zerun--) hcode[im++] = 0\n\n          im--\n        } else if (l >= SHORT_ZEROCODE_RUN) {\n          var zerun = l - SHORT_ZEROCODE_RUN + 2\n\n          if (im + zerun > iM + 1) {\n            throw 'Something wrong with hufUnpackEncTable'\n          }\n\n          while (zerun--) hcode[im++] = 0\n\n          im--\n        }\n      }\n\n      hufCanonicalCodeTable(hcode)\n    }\n\n    function hufLength(code) {\n      return code & 63\n    }\n\n    function hufCode(code) {\n      return code >> 6\n    }\n\n    function hufBuildDecTable(hcode, im, iM, hdecod) {\n      for (; im <= iM; im++) {\n        var c = hufCode(hcode[im])\n        var l = hufLength(hcode[im])\n\n        if (c >> l) {\n          throw 'Invalid table entry'\n        }\n\n        if (l > HUF_DECBITS) {\n          var pl = hdecod[c >> (l - HUF_DECBITS)]\n\n          if (pl.len) {\n            throw 'Invalid table entry'\n          }\n\n          pl.lit++\n\n          if (pl.p) {\n            var p = pl.p\n            pl.p = new Array(pl.lit)\n\n            for (var i = 0; i < pl.lit - 1; ++i) {\n              pl.p[i] = p[i]\n            }\n          } else {\n            pl.p = new Array(1)\n          }\n\n          pl.p[pl.lit - 1] = im\n        } else if (l) {\n          var plOffset = 0\n\n          for (var i = 1 << (HUF_DECBITS - l); i > 0; i--) {\n            var pl = hdecod[(c << (HUF_DECBITS - l)) + plOffset]\n\n            if (pl.len || pl.p) {\n              throw 'Invalid table entry'\n            }\n\n            pl.len = l\n            pl.lit = im\n\n            plOffset++\n          }\n        }\n      }\n\n      return true\n    }\n\n    const getCharReturn = { c: 0, lc: 0 }\n\n    function getChar(c, lc, uInt8Array, inOffset) {\n      c = (c << 8) | parseUint8Array(uInt8Array, inOffset)\n      lc += 8\n\n      getCharReturn.c = c\n      getCharReturn.lc = lc\n    }\n\n    const getCodeReturn = { c: 0, lc: 0 }\n\n    function getCode(po, rlc, c, lc, uInt8Array, inDataView, inOffset, outBuffer, outBufferOffset, outBufferEndOffset) {\n      if (po == rlc) {\n        if (lc < 8) {\n          getChar(c, lc, uInt8Array, inOffset)\n          c = getCharReturn.c\n          lc = getCharReturn.lc\n        }\n\n        lc -= 8\n\n        var cs = c >> lc\n        var cs = new Uint8Array([cs])[0]\n\n        if (outBufferOffset.value + cs > outBufferEndOffset) {\n          return false\n        }\n\n        var s = outBuffer[outBufferOffset.value - 1]\n\n        while (cs-- > 0) {\n          outBuffer[outBufferOffset.value++] = s\n        }\n      } else if (outBufferOffset.value < outBufferEndOffset) {\n        outBuffer[outBufferOffset.value++] = po\n      } else {\n        return false\n      }\n\n      getCodeReturn.c = c\n      getCodeReturn.lc = lc\n    }\n\n    function UInt16(value) {\n      return value & 0xffff\n    }\n\n    function Int16(value) {\n      var ref = UInt16(value)\n      return ref > 0x7fff ? ref - 0x10000 : ref\n    }\n\n    const wdec14Return = { a: 0, b: 0 }\n\n    function wdec14(l, h) {\n      var ls = Int16(l)\n      var hs = Int16(h)\n\n      var hi = hs\n      var ai = ls + (hi & 1) + (hi >> 1)\n\n      var as = ai\n      var bs = ai - hi\n\n      wdec14Return.a = as\n      wdec14Return.b = bs\n    }\n\n    function wdec16(l, h) {\n      var m = UInt16(l)\n      var d = UInt16(h)\n\n      var bb = (m - (d >> 1)) & MOD_MASK\n      var aa = (d + bb - A_OFFSET) & MOD_MASK\n\n      wdec14Return.a = aa\n      wdec14Return.b = bb\n    }\n\n    function wav2Decode(buffer, j, nx, ox, ny, oy, mx) {\n      var w14 = mx < 1 << 14\n      var n = nx > ny ? ny : nx\n      var p = 1\n      var p2\n\n      while (p <= n) p <<= 1\n\n      p >>= 1\n      p2 = p\n      p >>= 1\n\n      while (p >= 1) {\n        var py = 0\n        var ey = py + oy * (ny - p2)\n        var oy1 = oy * p\n        var oy2 = oy * p2\n        var ox1 = ox * p\n        var ox2 = ox * p2\n        var i00, i01, i10, i11\n\n        for (; py <= ey; py += oy2) {\n          var px = py\n          var ex = py + ox * (nx - p2)\n\n          for (; px <= ex; px += ox2) {\n            var p01 = px + ox1\n            var p10 = px + oy1\n            var p11 = p10 + ox1\n\n            if (w14) {\n              wdec14(buffer[px + j], buffer[p10 + j])\n\n              i00 = wdec14Return.a\n              i10 = wdec14Return.b\n\n              wdec14(buffer[p01 + j], buffer[p11 + j])\n\n              i01 = wdec14Return.a\n              i11 = wdec14Return.b\n\n              wdec14(i00, i01)\n\n              buffer[px + j] = wdec14Return.a\n              buffer[p01 + j] = wdec14Return.b\n\n              wdec14(i10, i11)\n\n              buffer[p10 + j] = wdec14Return.a\n              buffer[p11 + j] = wdec14Return.b\n            } else {\n              wdec16(buffer[px + j], buffer[p10 + j])\n\n              i00 = wdec14Return.a\n              i10 = wdec14Return.b\n\n              wdec16(buffer[p01 + j], buffer[p11 + j])\n\n              i01 = wdec14Return.a\n              i11 = wdec14Return.b\n\n              wdec16(i00, i01)\n\n              buffer[px + j] = wdec14Return.a\n              buffer[p01 + j] = wdec14Return.b\n\n              wdec16(i10, i11)\n\n              buffer[p10 + j] = wdec14Return.a\n              buffer[p11 + j] = wdec14Return.b\n            }\n          }\n\n          if (nx & p) {\n            var p10 = px + oy1\n\n            if (w14) wdec14(buffer[px + j], buffer[p10 + j])\n            else wdec16(buffer[px + j], buffer[p10 + j])\n\n            i00 = wdec14Return.a\n            buffer[p10 + j] = wdec14Return.b\n\n            buffer[px + j] = i00\n          }\n        }\n\n        if (ny & p) {\n          var px = py\n          var ex = py + ox * (nx - p2)\n\n          for (; px <= ex; px += ox2) {\n            var p01 = px + ox1\n\n            if (w14) wdec14(buffer[px + j], buffer[p01 + j])\n            else wdec16(buffer[px + j], buffer[p01 + j])\n\n            i00 = wdec14Return.a\n            buffer[p01 + j] = wdec14Return.b\n\n            buffer[px + j] = i00\n          }\n        }\n\n        p2 = p\n        p >>= 1\n      }\n\n      return py\n    }\n\n    function hufDecode(\n      encodingTable,\n      decodingTable,\n      uInt8Array,\n      inDataView,\n      inOffset,\n      ni,\n      rlc,\n      no,\n      outBuffer,\n      outOffset,\n    ) {\n      var c = 0\n      var lc = 0\n      var outBufferEndOffset = no\n      var inOffsetEnd = Math.trunc(inOffset.value + (ni + 7) / 8)\n\n      while (inOffset.value < inOffsetEnd) {\n        getChar(c, lc, uInt8Array, inOffset)\n\n        c = getCharReturn.c\n        lc = getCharReturn.lc\n\n        while (lc >= HUF_DECBITS) {\n          var index = (c >> (lc - HUF_DECBITS)) & HUF_DECMASK\n          var pl = decodingTable[index]\n\n          if (pl.len) {\n            lc -= pl.len\n\n            getCode(pl.lit, rlc, c, lc, uInt8Array, inDataView, inOffset, outBuffer, outOffset, outBufferEndOffset)\n\n            c = getCodeReturn.c\n            lc = getCodeReturn.lc\n          } else {\n            if (!pl.p) {\n              throw 'hufDecode issues'\n            }\n\n            var j\n\n            for (j = 0; j < pl.lit; j++) {\n              var l = hufLength(encodingTable[pl.p[j]])\n\n              while (lc < l && inOffset.value < inOffsetEnd) {\n                getChar(c, lc, uInt8Array, inOffset)\n\n                c = getCharReturn.c\n                lc = getCharReturn.lc\n              }\n\n              if (lc >= l) {\n                if (hufCode(encodingTable[pl.p[j]]) == ((c >> (lc - l)) & ((1 << l) - 1))) {\n                  lc -= l\n\n                  getCode(\n                    pl.p[j],\n                    rlc,\n                    c,\n                    lc,\n                    uInt8Array,\n                    inDataView,\n                    inOffset,\n                    outBuffer,\n                    outOffset,\n                    outBufferEndOffset,\n                  )\n\n                  c = getCodeReturn.c\n                  lc = getCodeReturn.lc\n\n                  break\n                }\n              }\n            }\n\n            if (j == pl.lit) {\n              throw 'hufDecode issues'\n            }\n          }\n        }\n      }\n\n      var i = (8 - ni) & 7\n\n      c >>= i\n      lc -= i\n\n      while (lc > 0) {\n        var pl = decodingTable[(c << (HUF_DECBITS - lc)) & HUF_DECMASK]\n\n        if (pl.len) {\n          lc -= pl.len\n\n          getCode(pl.lit, rlc, c, lc, uInt8Array, inDataView, inOffset, outBuffer, outOffset, outBufferEndOffset)\n\n          c = getCodeReturn.c\n          lc = getCodeReturn.lc\n        } else {\n          throw 'hufDecode issues'\n        }\n      }\n\n      return true\n    }\n\n    function hufUncompress(uInt8Array, inDataView, inOffset, nCompressed, outBuffer, nRaw) {\n      var outOffset = { value: 0 }\n      var initialInOffset = inOffset.value\n\n      var im = parseUint32(inDataView, inOffset)\n      var iM = parseUint32(inDataView, inOffset)\n\n      inOffset.value += 4\n\n      var nBits = parseUint32(inDataView, inOffset)\n\n      inOffset.value += 4\n\n      if (im < 0 || im >= HUF_ENCSIZE || iM < 0 || iM >= HUF_ENCSIZE) {\n        throw 'Something wrong with HUF_ENCSIZE'\n      }\n\n      var freq = new Array(HUF_ENCSIZE)\n      var hdec = new Array(HUF_DECSIZE)\n\n      hufClearDecTable(hdec)\n\n      var ni = nCompressed - (inOffset.value - initialInOffset)\n\n      hufUnpackEncTable(uInt8Array, inDataView, inOffset, ni, im, iM, freq)\n\n      if (nBits > 8 * (nCompressed - (inOffset.value - initialInOffset))) {\n        throw 'Something wrong with hufUncompress'\n      }\n\n      hufBuildDecTable(freq, im, iM, hdec)\n\n      hufDecode(freq, hdec, uInt8Array, inDataView, inOffset, nBits, iM, nRaw, outBuffer, outOffset)\n    }\n\n    function applyLut(lut, data, nData) {\n      for (var i = 0; i < nData; ++i) {\n        data[i] = lut[data[i]]\n      }\n    }\n\n    function predictor(source) {\n      for (var t = 1; t < source.length; t++) {\n        var d = source[t - 1] + source[t] - 128\n        source[t] = d\n      }\n    }\n\n    function interleaveScalar(source, out) {\n      var t1 = 0\n      var t2 = Math.floor((source.length + 1) / 2)\n      var s = 0\n      var stop = source.length - 1\n\n      while (true) {\n        if (s > stop) break\n        out[s++] = source[t1++]\n\n        if (s > stop) break\n        out[s++] = source[t2++]\n      }\n    }\n\n    function decodeRunLength(source) {\n      var size = source.byteLength\n      var out = new Array()\n      var p = 0\n\n      var reader = new DataView(source)\n\n      while (size > 0) {\n        var l = reader.getInt8(p++)\n\n        if (l < 0) {\n          var count = -l\n          size -= count + 1\n\n          for (var i = 0; i < count; i++) {\n            out.push(reader.getUint8(p++))\n          }\n        } else {\n          var count = l\n          size -= 2\n\n          var value = reader.getUint8(p++)\n\n          for (var i = 0; i < count + 1; i++) {\n            out.push(value)\n          }\n        }\n      }\n\n      return out\n    }\n\n    function lossyDctDecode(cscSet, rowPtrs, channelData, acBuffer, dcBuffer, outBuffer) {\n      var dataView = new DataView(outBuffer.buffer)\n\n      var width = channelData[cscSet.idx[0]].width\n      var height = channelData[cscSet.idx[0]].height\n\n      var numComp = 3\n\n      var numFullBlocksX = Math.floor(width / 8.0)\n      var numBlocksX = Math.ceil(width / 8.0)\n      var numBlocksY = Math.ceil(height / 8.0)\n      var leftoverX = width - (numBlocksX - 1) * 8\n      var leftoverY = height - (numBlocksY - 1) * 8\n\n      var currAcComp = { value: 0 }\n      var currDcComp = new Array(numComp)\n      var dctData = new Array(numComp)\n      var halfZigBlock = new Array(numComp)\n      var rowBlock = new Array(numComp)\n      var rowOffsets = new Array(numComp)\n\n      for (let comp = 0; comp < numComp; ++comp) {\n        rowOffsets[comp] = rowPtrs[cscSet.idx[comp]]\n        currDcComp[comp] = comp < 1 ? 0 : currDcComp[comp - 1] + numBlocksX * numBlocksY\n        dctData[comp] = new Float32Array(64)\n        halfZigBlock[comp] = new Uint16Array(64)\n        rowBlock[comp] = new Uint16Array(numBlocksX * 64)\n      }\n\n      for (let blocky = 0; blocky < numBlocksY; ++blocky) {\n        var maxY = 8\n\n        if (blocky == numBlocksY - 1) maxY = leftoverY\n\n        var maxX = 8\n\n        for (let blockx = 0; blockx < numBlocksX; ++blockx) {\n          if (blockx == numBlocksX - 1) maxX = leftoverX\n\n          for (let comp = 0; comp < numComp; ++comp) {\n            halfZigBlock[comp].fill(0)\n\n            // set block DC component\n            halfZigBlock[comp][0] = dcBuffer[currDcComp[comp]++]\n            // set block AC components\n            unRleAC(currAcComp, acBuffer, halfZigBlock[comp])\n\n            // UnZigZag block to float\n            unZigZag(halfZigBlock[comp], dctData[comp])\n            // decode float dct\n            dctInverse(dctData[comp])\n          }\n\n          if (numComp == 3) {\n            csc709Inverse(dctData)\n          }\n\n          for (let comp = 0; comp < numComp; ++comp) {\n            convertToHalf(dctData[comp], rowBlock[comp], blockx * 64)\n          }\n        } // blockx\n\n        let offset = 0\n\n        for (let comp = 0; comp < numComp; ++comp) {\n          const type = channelData[cscSet.idx[comp]].type\n\n          for (let y = 8 * blocky; y < 8 * blocky + maxY; ++y) {\n            offset = rowOffsets[comp][y]\n\n            for (let blockx = 0; blockx < numFullBlocksX; ++blockx) {\n              const src = blockx * 64 + (y & 0x7) * 8\n\n              dataView.setUint16(offset + 0 * INT16_SIZE * type, rowBlock[comp][src + 0], true)\n              dataView.setUint16(offset + 1 * INT16_SIZE * type, rowBlock[comp][src + 1], true)\n              dataView.setUint16(offset + 2 * INT16_SIZE * type, rowBlock[comp][src + 2], true)\n              dataView.setUint16(offset + 3 * INT16_SIZE * type, rowBlock[comp][src + 3], true)\n\n              dataView.setUint16(offset + 4 * INT16_SIZE * type, rowBlock[comp][src + 4], true)\n              dataView.setUint16(offset + 5 * INT16_SIZE * type, rowBlock[comp][src + 5], true)\n              dataView.setUint16(offset + 6 * INT16_SIZE * type, rowBlock[comp][src + 6], true)\n              dataView.setUint16(offset + 7 * INT16_SIZE * type, rowBlock[comp][src + 7], true)\n\n              offset += 8 * INT16_SIZE * type\n            }\n          }\n\n          // handle partial X blocks\n          if (numFullBlocksX != numBlocksX) {\n            for (let y = 8 * blocky; y < 8 * blocky + maxY; ++y) {\n              const offset = rowOffsets[comp][y] + 8 * numFullBlocksX * INT16_SIZE * type\n              const src = numFullBlocksX * 64 + (y & 0x7) * 8\n\n              for (let x = 0; x < maxX; ++x) {\n                dataView.setUint16(offset + x * INT16_SIZE * type, rowBlock[comp][src + x], true)\n              }\n            }\n          }\n        } // comp\n      } // blocky\n\n      var halfRow = new Uint16Array(width)\n      var dataView = new DataView(outBuffer.buffer)\n\n      // convert channels back to float, if needed\n      for (var comp = 0; comp < numComp; ++comp) {\n        channelData[cscSet.idx[comp]].decoded = true\n        var type = channelData[cscSet.idx[comp]].type\n\n        if (channelData[comp].type != 2) continue\n\n        for (var y = 0; y < height; ++y) {\n          const offset = rowOffsets[comp][y]\n\n          for (var x = 0; x < width; ++x) {\n            halfRow[x] = dataView.getUint16(offset + x * INT16_SIZE * type, true)\n          }\n\n          for (var x = 0; x < width; ++x) {\n            dataView.setFloat32(offset + x * INT16_SIZE * type, decodeFloat16(halfRow[x]), true)\n          }\n        }\n      }\n    }\n\n    function unRleAC(currAcComp, acBuffer, halfZigBlock) {\n      var acValue\n      var dctComp = 1\n\n      while (dctComp < 64) {\n        acValue = acBuffer[currAcComp.value]\n\n        if (acValue == 0xff00) {\n          dctComp = 64\n        } else if (acValue >> 8 == 0xff) {\n          dctComp += acValue & 0xff\n        } else {\n          halfZigBlock[dctComp] = acValue\n          dctComp++\n        }\n\n        currAcComp.value++\n      }\n    }\n\n    function unZigZag(src, dst) {\n      dst[0] = decodeFloat16(src[0])\n      dst[1] = decodeFloat16(src[1])\n      dst[2] = decodeFloat16(src[5])\n      dst[3] = decodeFloat16(src[6])\n      dst[4] = decodeFloat16(src[14])\n      dst[5] = decodeFloat16(src[15])\n      dst[6] = decodeFloat16(src[27])\n      dst[7] = decodeFloat16(src[28])\n      dst[8] = decodeFloat16(src[2])\n      dst[9] = decodeFloat16(src[4])\n\n      dst[10] = decodeFloat16(src[7])\n      dst[11] = decodeFloat16(src[13])\n      dst[12] = decodeFloat16(src[16])\n      dst[13] = decodeFloat16(src[26])\n      dst[14] = decodeFloat16(src[29])\n      dst[15] = decodeFloat16(src[42])\n      dst[16] = decodeFloat16(src[3])\n      dst[17] = decodeFloat16(src[8])\n      dst[18] = decodeFloat16(src[12])\n      dst[19] = decodeFloat16(src[17])\n\n      dst[20] = decodeFloat16(src[25])\n      dst[21] = decodeFloat16(src[30])\n      dst[22] = decodeFloat16(src[41])\n      dst[23] = decodeFloat16(src[43])\n      dst[24] = decodeFloat16(src[9])\n      dst[25] = decodeFloat16(src[11])\n      dst[26] = decodeFloat16(src[18])\n      dst[27] = decodeFloat16(src[24])\n      dst[28] = decodeFloat16(src[31])\n      dst[29] = decodeFloat16(src[40])\n\n      dst[30] = decodeFloat16(src[44])\n      dst[31] = decodeFloat16(src[53])\n      dst[32] = decodeFloat16(src[10])\n      dst[33] = decodeFloat16(src[19])\n      dst[34] = decodeFloat16(src[23])\n      dst[35] = decodeFloat16(src[32])\n      dst[36] = decodeFloat16(src[39])\n      dst[37] = decodeFloat16(src[45])\n      dst[38] = decodeFloat16(src[52])\n      dst[39] = decodeFloat16(src[54])\n\n      dst[40] = decodeFloat16(src[20])\n      dst[41] = decodeFloat16(src[22])\n      dst[42] = decodeFloat16(src[33])\n      dst[43] = decodeFloat16(src[38])\n      dst[44] = decodeFloat16(src[46])\n      dst[45] = decodeFloat16(src[51])\n      dst[46] = decodeFloat16(src[55])\n      dst[47] = decodeFloat16(src[60])\n      dst[48] = decodeFloat16(src[21])\n      dst[49] = decodeFloat16(src[34])\n\n      dst[50] = decodeFloat16(src[37])\n      dst[51] = decodeFloat16(src[47])\n      dst[52] = decodeFloat16(src[50])\n      dst[53] = decodeFloat16(src[56])\n      dst[54] = decodeFloat16(src[59])\n      dst[55] = decodeFloat16(src[61])\n      dst[56] = decodeFloat16(src[35])\n      dst[57] = decodeFloat16(src[36])\n      dst[58] = decodeFloat16(src[48])\n      dst[59] = decodeFloat16(src[49])\n\n      dst[60] = decodeFloat16(src[57])\n      dst[61] = decodeFloat16(src[58])\n      dst[62] = decodeFloat16(src[62])\n      dst[63] = decodeFloat16(src[63])\n    }\n\n    function dctInverse(data) {\n      const a = 0.5 * Math.cos(3.14159 / 4.0)\n      const b = 0.5 * Math.cos(3.14159 / 16.0)\n      const c = 0.5 * Math.cos(3.14159 / 8.0)\n      const d = 0.5 * Math.cos((3.0 * 3.14159) / 16.0)\n      const e = 0.5 * Math.cos((5.0 * 3.14159) / 16.0)\n      const f = 0.5 * Math.cos((3.0 * 3.14159) / 8.0)\n      const g = 0.5 * Math.cos((7.0 * 3.14159) / 16.0)\n\n      var alpha = new Array(4)\n      var beta = new Array(4)\n      var theta = new Array(4)\n      var gamma = new Array(4)\n\n      for (var row = 0; row < 8; ++row) {\n        var rowPtr = row * 8\n\n        alpha[0] = c * data[rowPtr + 2]\n        alpha[1] = f * data[rowPtr + 2]\n        alpha[2] = c * data[rowPtr + 6]\n        alpha[3] = f * data[rowPtr + 6]\n\n        beta[0] = b * data[rowPtr + 1] + d * data[rowPtr + 3] + e * data[rowPtr + 5] + g * data[rowPtr + 7]\n        beta[1] = d * data[rowPtr + 1] - g * data[rowPtr + 3] - b * data[rowPtr + 5] - e * data[rowPtr + 7]\n        beta[2] = e * data[rowPtr + 1] - b * data[rowPtr + 3] + g * data[rowPtr + 5] + d * data[rowPtr + 7]\n        beta[3] = g * data[rowPtr + 1] - e * data[rowPtr + 3] + d * data[rowPtr + 5] - b * data[rowPtr + 7]\n\n        theta[0] = a * (data[rowPtr + 0] + data[rowPtr + 4])\n        theta[3] = a * (data[rowPtr + 0] - data[rowPtr + 4])\n        theta[1] = alpha[0] + alpha[3]\n        theta[2] = alpha[1] - alpha[2]\n\n        gamma[0] = theta[0] + theta[1]\n        gamma[1] = theta[3] + theta[2]\n        gamma[2] = theta[3] - theta[2]\n        gamma[3] = theta[0] - theta[1]\n\n        data[rowPtr + 0] = gamma[0] + beta[0]\n        data[rowPtr + 1] = gamma[1] + beta[1]\n        data[rowPtr + 2] = gamma[2] + beta[2]\n        data[rowPtr + 3] = gamma[3] + beta[3]\n\n        data[rowPtr + 4] = gamma[3] - beta[3]\n        data[rowPtr + 5] = gamma[2] - beta[2]\n        data[rowPtr + 6] = gamma[1] - beta[1]\n        data[rowPtr + 7] = gamma[0] - beta[0]\n      }\n\n      for (var column = 0; column < 8; ++column) {\n        alpha[0] = c * data[16 + column]\n        alpha[1] = f * data[16 + column]\n        alpha[2] = c * data[48 + column]\n        alpha[3] = f * data[48 + column]\n\n        beta[0] = b * data[8 + column] + d * data[24 + column] + e * data[40 + column] + g * data[56 + column]\n        beta[1] = d * data[8 + column] - g * data[24 + column] - b * data[40 + column] - e * data[56 + column]\n        beta[2] = e * data[8 + column] - b * data[24 + column] + g * data[40 + column] + d * data[56 + column]\n        beta[3] = g * data[8 + column] - e * data[24 + column] + d * data[40 + column] - b * data[56 + column]\n\n        theta[0] = a * (data[column] + data[32 + column])\n        theta[3] = a * (data[column] - data[32 + column])\n\n        theta[1] = alpha[0] + alpha[3]\n        theta[2] = alpha[1] - alpha[2]\n\n        gamma[0] = theta[0] + theta[1]\n        gamma[1] = theta[3] + theta[2]\n        gamma[2] = theta[3] - theta[2]\n        gamma[3] = theta[0] - theta[1]\n\n        data[0 + column] = gamma[0] + beta[0]\n        data[8 + column] = gamma[1] + beta[1]\n        data[16 + column] = gamma[2] + beta[2]\n        data[24 + column] = gamma[3] + beta[3]\n\n        data[32 + column] = gamma[3] - beta[3]\n        data[40 + column] = gamma[2] - beta[2]\n        data[48 + column] = gamma[1] - beta[1]\n        data[56 + column] = gamma[0] - beta[0]\n      }\n    }\n\n    function csc709Inverse(data) {\n      for (var i = 0; i < 64; ++i) {\n        var y = data[0][i]\n        var cb = data[1][i]\n        var cr = data[2][i]\n\n        data[0][i] = y + 1.5747 * cr\n        data[1][i] = y - 0.1873 * cb - 0.4682 * cr\n        data[2][i] = y + 1.8556 * cb\n      }\n    }\n\n    function convertToHalf(src, dst, idx) {\n      for (var i = 0; i < 64; ++i) {\n        dst[idx + i] = DataUtils.toHalfFloat(toLinear(src[i]))\n      }\n    }\n\n    function toLinear(float) {\n      if (float <= 1) {\n        return Math.sign(float) * Math.pow(Math.abs(float), 2.2)\n      } else {\n        return Math.sign(float) * Math.pow(logBase, Math.abs(float) - 1.0)\n      }\n    }\n\n    function uncompressRAW(info) {\n      return new DataView(info.array.buffer, info.offset.value, info.size)\n    }\n\n    function uncompressRLE(info) {\n      var compressed = info.viewer.buffer.slice(info.offset.value, info.offset.value + info.size)\n\n      var rawBuffer = new Uint8Array(decodeRunLength(compressed))\n      var tmpBuffer = new Uint8Array(rawBuffer.length)\n\n      predictor(rawBuffer) // revert predictor\n\n      interleaveScalar(rawBuffer, tmpBuffer) // interleave pixels\n\n      return new DataView(tmpBuffer.buffer)\n    }\n\n    function uncompressZIP(info) {\n      var compressed = info.array.slice(info.offset.value, info.offset.value + info.size)\n      var rawBuffer = unzlibSync(compressed)\n      var tmpBuffer = new Uint8Array(rawBuffer.length)\n\n      predictor(rawBuffer) // revert predictor\n\n      interleaveScalar(rawBuffer, tmpBuffer) // interleave pixels\n\n      return new DataView(tmpBuffer.buffer)\n    }\n\n    function uncompressPIZ(info) {\n      var inDataView = info.viewer\n      var inOffset = { value: info.offset.value }\n\n      var outBuffer = new Uint16Array(info.width * info.scanlineBlockSize * (info.channels * info.type))\n      var bitmap = new Uint8Array(BITMAP_SIZE)\n\n      // Setup channel info\n      var outBufferEnd = 0\n      var pizChannelData = new Array(info.channels)\n      for (var i = 0; i < info.channels; i++) {\n        pizChannelData[i] = {}\n        pizChannelData[i]['start'] = outBufferEnd\n        pizChannelData[i]['end'] = pizChannelData[i]['start']\n        pizChannelData[i]['nx'] = info.width\n        pizChannelData[i]['ny'] = info.lines\n        pizChannelData[i]['size'] = info.type\n\n        outBufferEnd += pizChannelData[i].nx * pizChannelData[i].ny * pizChannelData[i].size\n      }\n\n      // Read range compression data\n\n      var minNonZero = parseUint16(inDataView, inOffset)\n      var maxNonZero = parseUint16(inDataView, inOffset)\n\n      if (maxNonZero >= BITMAP_SIZE) {\n        throw 'Something is wrong with PIZ_COMPRESSION BITMAP_SIZE'\n      }\n\n      if (minNonZero <= maxNonZero) {\n        for (var i = 0; i < maxNonZero - minNonZero + 1; i++) {\n          bitmap[i + minNonZero] = parseUint8(inDataView, inOffset)\n        }\n      }\n\n      // Reverse LUT\n      var lut = new Uint16Array(USHORT_RANGE)\n      var maxValue = reverseLutFromBitmap(bitmap, lut)\n\n      var length = parseUint32(inDataView, inOffset)\n\n      // Huffman decoding\n      hufUncompress(info.array, inDataView, inOffset, length, outBuffer, outBufferEnd)\n\n      // Wavelet decoding\n      for (var i = 0; i < info.channels; ++i) {\n        var cd = pizChannelData[i]\n\n        for (var j = 0; j < pizChannelData[i].size; ++j) {\n          wav2Decode(outBuffer, cd.start + j, cd.nx, cd.size, cd.ny, cd.nx * cd.size, maxValue)\n        }\n      }\n\n      // Expand the pixel data to their original range\n      applyLut(lut, outBuffer, outBufferEnd)\n\n      // Rearrange the pixel data into the format expected by the caller.\n      var tmpOffset = 0\n      var tmpBuffer = new Uint8Array(outBuffer.buffer.byteLength)\n      for (var y = 0; y < info.lines; y++) {\n        for (var c = 0; c < info.channels; c++) {\n          var cd = pizChannelData[c]\n\n          var n = cd.nx * cd.size\n          var cp = new Uint8Array(outBuffer.buffer, cd.end * INT16_SIZE, n * INT16_SIZE)\n\n          tmpBuffer.set(cp, tmpOffset)\n          tmpOffset += n * INT16_SIZE\n          cd.end += n\n        }\n      }\n\n      return new DataView(tmpBuffer.buffer)\n    }\n\n    function uncompressPXR(info) {\n      var compressed = info.array.slice(info.offset.value, info.offset.value + info.size)\n      var rawBuffer = unzlibSync(compressed)\n\n      const sz = info.lines * info.channels * info.width\n      const tmpBuffer = info.type == 1 ? new Uint16Array(sz) : new Uint32Array(sz)\n\n      let tmpBufferEnd = 0\n      let writePtr = 0\n      const ptr = new Array(4)\n\n      for (let y = 0; y < info.lines; y++) {\n        for (let c = 0; c < info.channels; c++) {\n          let pixel = 0\n\n          switch (info.type) {\n            case 1:\n              ptr[0] = tmpBufferEnd\n              ptr[1] = ptr[0] + info.width\n              tmpBufferEnd = ptr[1] + info.width\n\n              for (let j = 0; j < info.width; ++j) {\n                const diff = (rawBuffer[ptr[0]++] << 8) | rawBuffer[ptr[1]++]\n\n                pixel += diff\n\n                tmpBuffer[writePtr] = pixel\n                writePtr++\n              }\n\n              break\n\n            case 2:\n              ptr[0] = tmpBufferEnd\n              ptr[1] = ptr[0] + info.width\n              ptr[2] = ptr[1] + info.width\n              tmpBufferEnd = ptr[2] + info.width\n\n              for (let j = 0; j < info.width; ++j) {\n                const diff = (rawBuffer[ptr[0]++] << 24) | (rawBuffer[ptr[1]++] << 16) | (rawBuffer[ptr[2]++] << 8)\n\n                pixel += diff\n\n                tmpBuffer[writePtr] = pixel\n                writePtr++\n              }\n\n              break\n          }\n        }\n      }\n\n      return new DataView(tmpBuffer.buffer)\n    }\n\n    function uncompressDWA(info) {\n      var inDataView = info.viewer\n      var inOffset = { value: info.offset.value }\n      var outBuffer = new Uint8Array(info.width * info.lines * (info.channels * info.type * INT16_SIZE))\n\n      // Read compression header information\n      var dwaHeader = {\n        version: parseInt64(inDataView, inOffset),\n        unknownUncompressedSize: parseInt64(inDataView, inOffset),\n        unknownCompressedSize: parseInt64(inDataView, inOffset),\n        acCompressedSize: parseInt64(inDataView, inOffset),\n        dcCompressedSize: parseInt64(inDataView, inOffset),\n        rleCompressedSize: parseInt64(inDataView, inOffset),\n        rleUncompressedSize: parseInt64(inDataView, inOffset),\n        rleRawSize: parseInt64(inDataView, inOffset),\n        totalAcUncompressedCount: parseInt64(inDataView, inOffset),\n        totalDcUncompressedCount: parseInt64(inDataView, inOffset),\n        acCompression: parseInt64(inDataView, inOffset),\n      }\n\n      if (dwaHeader.version < 2) {\n        throw 'EXRLoader.parse: ' + EXRHeader.compression + ' version ' + dwaHeader.version + ' is unsupported'\n      }\n\n      // Read channel ruleset information\n      var channelRules = new Array()\n      var ruleSize = parseUint16(inDataView, inOffset) - INT16_SIZE\n\n      while (ruleSize > 0) {\n        var name = parseNullTerminatedString(inDataView.buffer, inOffset)\n        var value = parseUint8(inDataView, inOffset)\n        var compression = (value >> 2) & 3\n        var csc = (value >> 4) - 1\n        var index = new Int8Array([csc])[0]\n        var type = parseUint8(inDataView, inOffset)\n\n        channelRules.push({\n          name: name,\n          index: index,\n          type: type,\n          compression: compression,\n        })\n\n        ruleSize -= name.length + 3\n      }\n\n      // Classify channels\n      var channels = EXRHeader.channels\n      var channelData = new Array(info.channels)\n\n      for (var i = 0; i < info.channels; ++i) {\n        var cd = (channelData[i] = {})\n        var channel = channels[i]\n\n        cd.name = channel.name\n        cd.compression = UNKNOWN\n        cd.decoded = false\n        cd.type = channel.pixelType\n        cd.pLinear = channel.pLinear\n        cd.width = info.width\n        cd.height = info.lines\n      }\n\n      var cscSet = {\n        idx: new Array(3),\n      }\n\n      for (var offset = 0; offset < info.channels; ++offset) {\n        var cd = channelData[offset]\n\n        for (var i = 0; i < channelRules.length; ++i) {\n          var rule = channelRules[i]\n\n          if (cd.name == rule.name) {\n            cd.compression = rule.compression\n\n            if (rule.index >= 0) {\n              cscSet.idx[rule.index] = offset\n            }\n\n            cd.offset = offset\n          }\n        }\n      }\n\n      // Read DCT - AC component data\n      if (dwaHeader.acCompressedSize > 0) {\n        switch (dwaHeader.acCompression) {\n          case STATIC_HUFFMAN:\n            var acBuffer = new Uint16Array(dwaHeader.totalAcUncompressedCount)\n            hufUncompress(\n              info.array,\n              inDataView,\n              inOffset,\n              dwaHeader.acCompressedSize,\n              acBuffer,\n              dwaHeader.totalAcUncompressedCount,\n            )\n            break\n\n          case DEFLATE:\n            var compressed = info.array.slice(inOffset.value, inOffset.value + dwaHeader.totalAcUncompressedCount)\n            var data = unzlibSync(compressed)\n            var acBuffer = new Uint16Array(data.buffer)\n            inOffset.value += dwaHeader.totalAcUncompressedCount\n            break\n        }\n      }\n\n      // Read DCT - DC component data\n      if (dwaHeader.dcCompressedSize > 0) {\n        var zlibInfo = {\n          array: info.array,\n          offset: inOffset,\n          size: dwaHeader.dcCompressedSize,\n        }\n        var dcBuffer = new Uint16Array(uncompressZIP(zlibInfo).buffer)\n        inOffset.value += dwaHeader.dcCompressedSize\n      }\n\n      // Read RLE compressed data\n      if (dwaHeader.rleRawSize > 0) {\n        var compressed = info.array.slice(inOffset.value, inOffset.value + dwaHeader.rleCompressedSize)\n        var data = unzlibSync(compressed)\n        var rleBuffer = decodeRunLength(data.buffer)\n\n        inOffset.value += dwaHeader.rleCompressedSize\n      }\n\n      // Prepare outbuffer data offset\n      var outBufferEnd = 0\n      var rowOffsets = new Array(channelData.length)\n      for (var i = 0; i < rowOffsets.length; ++i) {\n        rowOffsets[i] = new Array()\n      }\n\n      for (var y = 0; y < info.lines; ++y) {\n        for (var chan = 0; chan < channelData.length; ++chan) {\n          rowOffsets[chan].push(outBufferEnd)\n          outBufferEnd += channelData[chan].width * info.type * INT16_SIZE\n        }\n      }\n\n      // Lossy DCT decode RGB channels\n      lossyDctDecode(cscSet, rowOffsets, channelData, acBuffer, dcBuffer, outBuffer)\n\n      // Decode other channels\n      for (var i = 0; i < channelData.length; ++i) {\n        var cd = channelData[i]\n\n        if (cd.decoded) continue\n\n        switch (cd.compression) {\n          case RLE:\n            var row = 0\n            var rleOffset = 0\n\n            for (var y = 0; y < info.lines; ++y) {\n              var rowOffsetBytes = rowOffsets[i][row]\n\n              for (var x = 0; x < cd.width; ++x) {\n                for (var byte = 0; byte < INT16_SIZE * cd.type; ++byte) {\n                  outBuffer[rowOffsetBytes++] = rleBuffer[rleOffset + byte * cd.width * cd.height]\n                }\n\n                rleOffset++\n              }\n\n              row++\n            }\n\n            break\n\n          case LOSSY_DCT: // skip\n\n          default:\n            throw 'EXRLoader.parse: unsupported channel compression'\n        }\n      }\n\n      return new DataView(outBuffer.buffer)\n    }\n\n    function parseNullTerminatedString(buffer, offset) {\n      var uintBuffer = new Uint8Array(buffer)\n      var endOffset = 0\n\n      while (uintBuffer[offset.value + endOffset] != 0) {\n        endOffset += 1\n      }\n\n      var stringValue = new TextDecoder().decode(uintBuffer.slice(offset.value, offset.value + endOffset))\n\n      offset.value = offset.value + endOffset + 1\n\n      return stringValue\n    }\n\n    function parseFixedLengthString(buffer, offset, size) {\n      var stringValue = new TextDecoder().decode(new Uint8Array(buffer).slice(offset.value, offset.value + size))\n\n      offset.value = offset.value + size\n\n      return stringValue\n    }\n\n    function parseRational(dataView, offset) {\n      var x = parseInt32(dataView, offset)\n      var y = parseUint32(dataView, offset)\n\n      return [x, y]\n    }\n\n    function parseTimecode(dataView, offset) {\n      var x = parseUint32(dataView, offset)\n      var y = parseUint32(dataView, offset)\n\n      return [x, y]\n    }\n\n    function parseInt32(dataView, offset) {\n      var Int32 = dataView.getInt32(offset.value, true)\n\n      offset.value = offset.value + INT32_SIZE\n\n      return Int32\n    }\n\n    function parseUint32(dataView, offset) {\n      var Uint32 = dataView.getUint32(offset.value, true)\n\n      offset.value = offset.value + INT32_SIZE\n\n      return Uint32\n    }\n\n    function parseUint8Array(uInt8Array, offset) {\n      var Uint8 = uInt8Array[offset.value]\n\n      offset.value = offset.value + INT8_SIZE\n\n      return Uint8\n    }\n\n    function parseUint8(dataView, offset) {\n      var Uint8 = dataView.getUint8(offset.value)\n\n      offset.value = offset.value + INT8_SIZE\n\n      return Uint8\n    }\n\n    const parseInt64 = function (dataView, offset) {\n      let int\n\n      if ('getBigInt64' in DataView.prototype) {\n        int = Number(dataView.getBigInt64(offset.value, true))\n      } else {\n        int = dataView.getUint32(offset.value + 4, true) + Number(dataView.getUint32(offset.value, true) << 32)\n      }\n\n      offset.value += ULONG_SIZE\n\n      return int\n    }\n\n    function parseFloat32(dataView, offset) {\n      var float = dataView.getFloat32(offset.value, true)\n\n      offset.value += FLOAT32_SIZE\n\n      return float\n    }\n\n    function decodeFloat32(dataView, offset) {\n      return DataUtils.toHalfFloat(parseFloat32(dataView, offset))\n    }\n\n    // https://stackoverflow.com/questions/5678432/decompressing-half-precision-floats-in-javascript\n    function decodeFloat16(binary) {\n      var exponent = (binary & 0x7c00) >> 10,\n        fraction = binary & 0x03ff\n\n      return (\n        (binary >> 15 ? -1 : 1) *\n        (exponent\n          ? exponent === 0x1f\n            ? fraction\n              ? NaN\n              : Infinity\n            : Math.pow(2, exponent - 15) * (1 + fraction / 0x400)\n          : 6.103515625e-5 * (fraction / 0x400))\n      )\n    }\n\n    function parseUint16(dataView, offset) {\n      var Uint16 = dataView.getUint16(offset.value, true)\n\n      offset.value += INT16_SIZE\n\n      return Uint16\n    }\n\n    function parseFloat16(buffer, offset) {\n      return decodeFloat16(parseUint16(buffer, offset))\n    }\n\n    function parseChlist(dataView, buffer, offset, size) {\n      var startOffset = offset.value\n      var channels = []\n\n      while (offset.value < startOffset + size - 1) {\n        var name = parseNullTerminatedString(buffer, offset)\n        var pixelType = parseInt32(dataView, offset)\n        var pLinear = parseUint8(dataView, offset)\n        offset.value += 3 // reserved, three chars\n        var xSampling = parseInt32(dataView, offset)\n        var ySampling = parseInt32(dataView, offset)\n\n        channels.push({\n          name: name,\n          pixelType: pixelType,\n          pLinear: pLinear,\n          xSampling: xSampling,\n          ySampling: ySampling,\n        })\n      }\n\n      offset.value += 1\n\n      return channels\n    }\n\n    function parseChromaticities(dataView, offset) {\n      var redX = parseFloat32(dataView, offset)\n      var redY = parseFloat32(dataView, offset)\n      var greenX = parseFloat32(dataView, offset)\n      var greenY = parseFloat32(dataView, offset)\n      var blueX = parseFloat32(dataView, offset)\n      var blueY = parseFloat32(dataView, offset)\n      var whiteX = parseFloat32(dataView, offset)\n      var whiteY = parseFloat32(dataView, offset)\n\n      return {\n        redX: redX,\n        redY: redY,\n        greenX: greenX,\n        greenY: greenY,\n        blueX: blueX,\n        blueY: blueY,\n        whiteX: whiteX,\n        whiteY: whiteY,\n      }\n    }\n\n    function parseCompression(dataView, offset) {\n      var compressionCodes = [\n        'NO_COMPRESSION',\n        'RLE_COMPRESSION',\n        'ZIPS_COMPRESSION',\n        'ZIP_COMPRESSION',\n        'PIZ_COMPRESSION',\n        'PXR24_COMPRESSION',\n        'B44_COMPRESSION',\n        'B44A_COMPRESSION',\n        'DWAA_COMPRESSION',\n        'DWAB_COMPRESSION',\n      ]\n\n      var compression = parseUint8(dataView, offset)\n\n      return compressionCodes[compression]\n    }\n\n    function parseBox2i(dataView, offset) {\n      var xMin = parseUint32(dataView, offset)\n      var yMin = parseUint32(dataView, offset)\n      var xMax = parseUint32(dataView, offset)\n      var yMax = parseUint32(dataView, offset)\n\n      return { xMin: xMin, yMin: yMin, xMax: xMax, yMax: yMax }\n    }\n\n    function parseLineOrder(dataView, offset) {\n      var lineOrders = ['INCREASING_Y']\n\n      var lineOrder = parseUint8(dataView, offset)\n\n      return lineOrders[lineOrder]\n    }\n\n    function parseV2f(dataView, offset) {\n      var x = parseFloat32(dataView, offset)\n      var y = parseFloat32(dataView, offset)\n\n      return [x, y]\n    }\n\n    function parseV3f(dataView, offset) {\n      var x = parseFloat32(dataView, offset)\n      var y = parseFloat32(dataView, offset)\n      var z = parseFloat32(dataView, offset)\n\n      return [x, y, z]\n    }\n\n    function parseValue(dataView, buffer, offset, type, size) {\n      if (type === 'string' || type === 'stringvector' || type === 'iccProfile') {\n        return parseFixedLengthString(buffer, offset, size)\n      } else if (type === 'chlist') {\n        return parseChlist(dataView, buffer, offset, size)\n      } else if (type === 'chromaticities') {\n        return parseChromaticities(dataView, offset)\n      } else if (type === 'compression') {\n        return parseCompression(dataView, offset)\n      } else if (type === 'box2i') {\n        return parseBox2i(dataView, offset)\n      } else if (type === 'lineOrder') {\n        return parseLineOrder(dataView, offset)\n      } else if (type === 'float') {\n        return parseFloat32(dataView, offset)\n      } else if (type === 'v2f') {\n        return parseV2f(dataView, offset)\n      } else if (type === 'v3f') {\n        return parseV3f(dataView, offset)\n      } else if (type === 'int') {\n        return parseInt32(dataView, offset)\n      } else if (type === 'rational') {\n        return parseRational(dataView, offset)\n      } else if (type === 'timecode') {\n        return parseTimecode(dataView, offset)\n      } else if (type === 'preview') {\n        offset.value += size\n        return 'skipped'\n      } else {\n        offset.value += size\n        return undefined\n      }\n    }\n\n    function parseHeader(dataView, buffer, offset) {\n      const EXRHeader = {}\n\n      if (dataView.getUint32(0, true) != 20000630) {\n        // magic\n        throw \"THREE.EXRLoader: provided file doesn't appear to be in OpenEXR format.\"\n      }\n\n      EXRHeader.version = dataView.getUint8(4)\n\n      const spec = dataView.getUint8(5) // fullMask\n\n      EXRHeader.spec = {\n        singleTile: !!(spec & 2),\n        longName: !!(spec & 4),\n        deepFormat: !!(spec & 8),\n        multiPart: !!(spec & 16),\n      }\n\n      // start of header\n\n      offset.value = 8 // start at 8 - after pre-amble\n\n      var keepReading = true\n\n      while (keepReading) {\n        var attributeName = parseNullTerminatedString(buffer, offset)\n\n        if (attributeName == 0) {\n          keepReading = false\n        } else {\n          var attributeType = parseNullTerminatedString(buffer, offset)\n          var attributeSize = parseUint32(dataView, offset)\n          var attributeValue = parseValue(dataView, buffer, offset, attributeType, attributeSize)\n\n          if (attributeValue === undefined) {\n            console.warn(`EXRLoader.parse: skipped unknown header attribute type \\'${attributeType}\\'.`)\n          } else {\n            EXRHeader[attributeName] = attributeValue\n          }\n        }\n      }\n\n      if ((spec & ~0x04) != 0) {\n        // unsupported tiled, deep-image, multi-part\n        console.error('EXRHeader:', EXRHeader)\n        throw 'THREE.EXRLoader: provided file is currently unsupported.'\n      }\n\n      return EXRHeader\n    }\n\n    function setupDecoder(EXRHeader, dataView, uInt8Array, offset, outputType) {\n      const EXRDecoder = {\n        size: 0,\n        viewer: dataView,\n        array: uInt8Array,\n        offset: offset,\n        width: EXRHeader.dataWindow.xMax - EXRHeader.dataWindow.xMin + 1,\n        height: EXRHeader.dataWindow.yMax - EXRHeader.dataWindow.yMin + 1,\n        channels: EXRHeader.channels.length,\n        bytesPerLine: null,\n        lines: null,\n        inputSize: null,\n        type: EXRHeader.channels[0].pixelType,\n        uncompress: null,\n        getter: null,\n        format: null,\n        [hasColorSpace ? 'colorSpace' : 'encoding']: null,\n      }\n\n      switch (EXRHeader.compression) {\n        case 'NO_COMPRESSION':\n          EXRDecoder.lines = 1\n          EXRDecoder.uncompress = uncompressRAW\n          break\n\n        case 'RLE_COMPRESSION':\n          EXRDecoder.lines = 1\n          EXRDecoder.uncompress = uncompressRLE\n          break\n\n        case 'ZIPS_COMPRESSION':\n          EXRDecoder.lines = 1\n          EXRDecoder.uncompress = uncompressZIP\n          break\n\n        case 'ZIP_COMPRESSION':\n          EXRDecoder.lines = 16\n          EXRDecoder.uncompress = uncompressZIP\n          break\n\n        case 'PIZ_COMPRESSION':\n          EXRDecoder.lines = 32\n          EXRDecoder.uncompress = uncompressPIZ\n          break\n\n        case 'PXR24_COMPRESSION':\n          EXRDecoder.lines = 16\n          EXRDecoder.uncompress = uncompressPXR\n          break\n\n        case 'DWAA_COMPRESSION':\n          EXRDecoder.lines = 32\n          EXRDecoder.uncompress = uncompressDWA\n          break\n\n        case 'DWAB_COMPRESSION':\n          EXRDecoder.lines = 256\n          EXRDecoder.uncompress = uncompressDWA\n          break\n\n        default:\n          throw 'EXRLoader.parse: ' + EXRHeader.compression + ' is unsupported'\n      }\n\n      EXRDecoder.scanlineBlockSize = EXRDecoder.lines\n\n      if (EXRDecoder.type == 1) {\n        // half\n        switch (outputType) {\n          case FloatType:\n            EXRDecoder.getter = parseFloat16\n            EXRDecoder.inputSize = INT16_SIZE\n            break\n\n          case HalfFloatType:\n            EXRDecoder.getter = parseUint16\n            EXRDecoder.inputSize = INT16_SIZE\n            break\n        }\n      } else if (EXRDecoder.type == 2) {\n        // float\n        switch (outputType) {\n          case FloatType:\n            EXRDecoder.getter = parseFloat32\n            EXRDecoder.inputSize = FLOAT32_SIZE\n            break\n\n          case HalfFloatType:\n            EXRDecoder.getter = decodeFloat32\n            EXRDecoder.inputSize = FLOAT32_SIZE\n        }\n      } else {\n        throw 'EXRLoader.parse: unsupported pixelType ' + EXRDecoder.type + ' for ' + EXRHeader.compression + '.'\n      }\n\n      EXRDecoder.blockCount = (EXRHeader.dataWindow.yMax + 1) / EXRDecoder.scanlineBlockSize\n\n      for (var i = 0; i < EXRDecoder.blockCount; i++) parseInt64(dataView, offset) // scanlineOffset\n\n      // we should be passed the scanline offset table, ready to start reading pixel data.\n\n      // RGB images will be converted to RGBA format, preventing software emulation in select devices.\n      EXRDecoder.outputChannels = EXRDecoder.channels == 3 ? 4 : EXRDecoder.channels\n      const size = EXRDecoder.width * EXRDecoder.height * EXRDecoder.outputChannels\n\n      switch (outputType) {\n        case FloatType:\n          EXRDecoder.byteArray = new Float32Array(size)\n\n          // Fill initially with 1s for the alpha value if the texture is not RGBA, RGB values will be overwritten\n          if (EXRDecoder.channels < EXRDecoder.outputChannels) EXRDecoder.byteArray.fill(1, 0, size)\n\n          break\n\n        case HalfFloatType:\n          EXRDecoder.byteArray = new Uint16Array(size)\n\n          if (EXRDecoder.channels < EXRDecoder.outputChannels) EXRDecoder.byteArray.fill(0x3c00, 0, size) // Uint16Array holds half float data, 0x3C00 is 1\n\n          break\n\n        default:\n          console.error('THREE.EXRLoader: unsupported type: ', outputType)\n          break\n      }\n\n      EXRDecoder.bytesPerLine = EXRDecoder.width * EXRDecoder.inputSize * EXRDecoder.channels\n\n      if (EXRDecoder.outputChannels == 4) EXRDecoder.format = RGBAFormat\n      else EXRDecoder.format = RedFormat\n\n      if (hasColorSpace) EXRDecoder.colorSpace = 'srgb-linear'\n      else EXRDecoder.encoding = 3000 // LinearEncoding\n\n      return EXRDecoder\n    }\n\n    // start parsing file [START]\n\n    const bufferDataView = new DataView(buffer)\n    const uInt8Array = new Uint8Array(buffer)\n    const offset = { value: 0 }\n\n    // get header information and validate format.\n    const EXRHeader = parseHeader(bufferDataView, buffer, offset)\n\n    // get input compression information and prepare decoding.\n    const EXRDecoder = setupDecoder(EXRHeader, bufferDataView, uInt8Array, offset, this.type)\n\n    const tmpOffset = { value: 0 }\n    const channelOffsets = { R: 0, G: 1, B: 2, A: 3, Y: 0 }\n\n    for (\n      let scanlineBlockIdx = 0;\n      scanlineBlockIdx < EXRDecoder.height / EXRDecoder.scanlineBlockSize;\n      scanlineBlockIdx++\n    ) {\n      const line = parseUint32(bufferDataView, offset) // line_no\n      EXRDecoder.size = parseUint32(bufferDataView, offset) // data_len\n      EXRDecoder.lines =\n        line + EXRDecoder.scanlineBlockSize > EXRDecoder.height\n          ? EXRDecoder.height - line\n          : EXRDecoder.scanlineBlockSize\n\n      const isCompressed = EXRDecoder.size < EXRDecoder.lines * EXRDecoder.bytesPerLine\n      const viewer = isCompressed ? EXRDecoder.uncompress(EXRDecoder) : uncompressRAW(EXRDecoder)\n\n      offset.value += EXRDecoder.size\n\n      for (let line_y = 0; line_y < EXRDecoder.scanlineBlockSize; line_y++) {\n        const true_y = line_y + scanlineBlockIdx * EXRDecoder.scanlineBlockSize\n        if (true_y >= EXRDecoder.height) break\n\n        for (let channelID = 0; channelID < EXRDecoder.channels; channelID++) {\n          const cOff = channelOffsets[EXRHeader.channels[channelID].name]\n\n          for (let x = 0; x < EXRDecoder.width; x++) {\n            tmpOffset.value =\n              (line_y * (EXRDecoder.channels * EXRDecoder.width) + channelID * EXRDecoder.width + x) *\n              EXRDecoder.inputSize\n            const outIndex =\n              (EXRDecoder.height - 1 - true_y) * (EXRDecoder.width * EXRDecoder.outputChannels) +\n              x * EXRDecoder.outputChannels +\n              cOff\n            EXRDecoder.byteArray[outIndex] = EXRDecoder.getter(viewer, tmpOffset)\n          }\n        }\n      }\n    }\n\n    return {\n      header: EXRHeader,\n      width: EXRDecoder.width,\n      height: EXRDecoder.height,\n      data: EXRDecoder.byteArray,\n      format: EXRDecoder.format,\n      [hasColorSpace ? 'colorSpace' : 'encoding']: EXRDecoder[hasColorSpace ? 'colorSpace' : 'encoding'],\n      type: this.type,\n    }\n  }\n\n  setDataType(value) {\n    this.type = value\n    return this\n  }\n\n  load(url, onLoad, onProgress, onError) {\n    function onLoadCallback(texture, texData) {\n      if (hasColorSpace) texture.colorSpace = texData.colorSpace\n      else texture.encoding = texData.encoding\n      texture.minFilter = LinearFilter\n      texture.magFilter = LinearFilter\n      texture.generateMipmaps = false\n      texture.flipY = false\n\n      if (onLoad) onLoad(texture, texData)\n    }\n\n    return super.load(url, onLoadCallback, onProgress, onError)\n  }\n}\n\nexport { EXRLoader }\n"],"mappings":"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E,CAAC;QAC/Bc,GAAA,CAAI,EAAE,IAAIH,aAAA,CAAcX,GAAA,CAAI,EAAE,CAAC;QAE/Bc,GAAA,CAAI,EAAE,IAAIH,aAAA,CAAcX,GAAA,CAAI,EAAE,CAAC;QAC/Bc,GAAA,CAAI,EAAE,IAAIH,aAAA,CAAcX,GAAA,CAAI,EAAE,CAAC;QAC/Bc,GAAA,CAAI,EAAE,IAAIH,aAAA,CAAcX,GAAA,CAAI,EAAE,CAAC;QAC/Bc,GAAA,CAAI,EAAE,IAAIH,aAAA,CAAcX,GAAA,CAAI,EAAE,CAAC;QAC/Bc,GAAA,CAAI,EAAE,IAAIH,aAAA,CAAcX,GAAA,CAAI,EAAE,CAAC;QAC/Bc,GAAA,CAAI,EAAE,IAAIH,aAAA,CAAcX,GAAA,CAAI,EAAE,CAAC;QAC/Bc,GAAA,CAAI,EAAE,IAAIH,aAAA,CAAcX,GAAA,CAAI,EAAE,CAAC;QAC/Bc,GAAA,CAAI,EAAE,IAAIH,aAAA,CAAcX,GAAA,CAAI,EAAE,CAAC;QAC/Bc,GAAA,CAAI,EAAE,IAAIH,aAAA,CAAcX,GAAA,CAAI,EAAE,CAAC;QAC/Bc,GAAA,CAAI,EAAE,IAAIH,aAAA,CAAcX,GAAA,CAAI,EAAE,CAAC;QAE/Bc,GAAA,CAAI,EAAE,IAAIH,aAAA,CAAcX,GAAA,CAAI,EAAE,CAAC;QAC/Bc,GAAA,CAAI,EAAE,IAAIH,aAAA,CAAcX,GAAA,CAAI,EAAE,CAAC;QAC/Bc,GAAA,CAAI,EAAE,IAAIH,aAAA,CAAcX,GAAA,CAAI,EAAE,CAAC;QAC/Bc,GAAA,CAAI,EAAE,IAAIH,aAAA,CAAcX,GAAA,CAAI,EAAE,CAAC;QAC/Bc,GAAA,CAAI,EAAE,IAAIH,aAAA,CAAcX,GAAA,CAAI,EAAE,CAAC;QAC/Bc,GAAA,CAAI,EAAE,IAAIH,aAAA,CAAcX,GAAA,CAAI,EAAE,CAAC;QAC/Bc,GAAA,CAAI,EAAE,IAAIH,aAAA,CAAcX,GAAA,CAAI,EAAE,CAAC;QAC/Bc,GAAA,CAAI,EAAE,IAAIH,aAAA,CAAcX,GAAA,CAAI,EAAE,CAAC;QAC/Bc,GAAA,CAAI,EAAE,IAAIH,aAAA,CAAcX,GAAA,CAAI,EAAE,CAAC;QAC/Bc,GAAA,CAAI,EAAE,IAAIH,aAAA,CAAcX,GAAA,CAAI,EAAE,CAAC;QAE/Bc,GAAA,CAAI,EAAE,IAAIH,aAAA,CAAcX,GAAA,CAAI,EAAE,CAAC;QAC/Bc,GAAA,CAAI,EAAE,IAAIH,aAAA,CAAcX,GAAA,CAAI,EAAE,CAAC;QAC/Bc,GAAA,CAAI,EAAE,IAAIH,aAAA,CAAcX,GAAA,CAAI,EAAE,CAAC;QAC/Bc,GAAA,CAAI,EAAE,IAAIH,aAAA,CAAcX,GAAA,CAAI,EAAE,CAAC;QAC/Bc,GAAA,CAAI,EAAE,IAAIH,aAAA,CAAcX,GAAA,CAAI,EAAE,CAAC;QAC/Bc,GAAA,CAAI,EAAE,IAAIH,aAAA,CAAcX,GAAA,CAAI,EAAE,CAAC;QAC/Bc,GAAA,CAAI,EAAE,IAAIH,aAAA,CAAcX,GAAA,CAAI,EAAE,CAAC;QAC/Bc,GAAA,CAAI,EAAE,IAAIH,aAAA,CAAcX,GAAA,CAAI,EAAE,CAAC;QAC/Bc,GAAA,CAAI,EAAE,IAAIH,aAAA,CAAcX,GAAA,CAAI,EAAE,CAAC;QAC/Bc,GAAA,CAAI,EAAE,IAAIH,aAAA,CAAcX,GAAA,CAAI,EAAE,CAAC;QAE/Bc,GAAA,CAAI,EAAE,IAAIH,aAAA,CAAcX,GAAA,CAAI,EAAE,CAAC;QAC/Bc,GAAA,CAAI,EAAE,IAAIH,aAAA,CAAcX,GAAA,CAAI,EAAE,CAAC;QAC/Bc,GAAA,CAAI,EAAE,IAAIH,aAAA,CAAcX,GAAA,CAAI,EAAE,CAAC;QAC/Bc,GAAA,CAAI,EAAE,IAAIH,aAAA,CAAcX,GAAA,CAAI,EAAE,CAAC;MAChC;MAED,SAASN,WAAWtD,IAAA,EAAM;QACxB,IAAMvD,CAAA,GAAI,MAAMxD,IAAA,CAAK0L,GAAA,CAAI,UAAU,CAAG;QACtC,IAAMjI,CAAA,GAAI,MAAMzD,IAAA,CAAK0L,GAAA,CAAI,UAAU,EAAI;QACvC,IAAM3K,CAAA,GAAI,MAAMf,IAAA,CAAK0L,GAAA,CAAI,UAAU,CAAG;QACtC,IAAMtH,CAAA,GAAI,MAAMpE,IAAA,CAAK0L,GAAA,CAAK,IAAM,UAAW,EAAI;QAC/C,IAAMC,CAAA,GAAI,MAAM3L,IAAA,CAAK0L,GAAA,CAAK,IAAM,UAAW,EAAI;QAC/C,IAAME,CAAA,GAAI,MAAM5L,IAAA,CAAK0L,GAAA,CAAK,IAAM,UAAW,CAAG;QAC9C,IAAMG,CAAA,GAAI,MAAM7L,IAAA,CAAK0L,GAAA,CAAK,IAAM,UAAW,EAAI;QAE/C,IAAII,KAAA,GAAQ,IAAIvK,KAAA,CAAM,CAAC;QACvB,IAAIwK,IAAA,GAAO,IAAIxK,KAAA,CAAM,CAAC;QACtB,IAAIyK,KAAA,GAAQ,IAAIzK,KAAA,CAAM,CAAC;QACvB,IAAI0K,KAAA,GAAQ,IAAI1K,KAAA,CAAM,CAAC;QAEvB,SAAS2K,GAAA,GAAM,GAAGA,GAAA,GAAM,GAAG,EAAEA,GAAA,EAAK;UAChC,IAAIC,MAAA,GAASD,GAAA,GAAM;UAEnBJ,KAAA,CAAM,CAAC,IAAI/K,CAAA,GAAIgG,IAAA,CAAKoF,MAAA,GAAS,CAAC;UAC9BL,KAAA,CAAM,CAAC,IAAIF,CAAA,GAAI7E,IAAA,CAAKoF,MAAA,GAAS,CAAC;UAC9BL,KAAA,CAAM,CAAC,IAAI/K,CAAA,GAAIgG,IAAA,CAAKoF,MAAA,GAAS,CAAC;UAC9BL,KAAA,CAAM,CAAC,IAAIF,CAAA,GAAI7E,IAAA,CAAKoF,MAAA,GAAS,CAAC;UAE9BJ,IAAA,CAAK,CAAC,IAAItI,CAAA,GAAIsD,IAAA,CAAKoF,MAAA,GAAS,CAAC,IAAI/H,CAAA,GAAI2C,IAAA,CAAKoF,MAAA,GAAS,CAAC,IAAIR,CAAA,GAAI5E,IAAA,CAAKoF,MAAA,GAAS,CAAC,IAAIN,CAAA,GAAI9E,IAAA,CAAKoF,MAAA,GAAS,CAAC;UAClGJ,IAAA,CAAK,CAAC,IAAI3H,CAAA,GAAI2C,IAAA,CAAKoF,MAAA,GAAS,CAAC,IAAIN,CAAA,GAAI9E,IAAA,CAAKoF,MAAA,GAAS,CAAC,IAAI1I,CAAA,GAAIsD,IAAA,CAAKoF,MAAA,GAAS,CAAC,IAAIR,CAAA,GAAI5E,IAAA,CAAKoF,MAAA,GAAS,CAAC;UAClGJ,IAAA,CAAK,CAAC,IAAIJ,CAAA,GAAI5E,IAAA,CAAKoF,MAAA,GAAS,CAAC,IAAI1I,CAAA,GAAIsD,IAAA,CAAKoF,MAAA,GAAS,CAAC,IAAIN,CAAA,GAAI9E,IAAA,CAAKoF,MAAA,GAAS,CAAC,IAAI/H,CAAA,GAAI2C,IAAA,CAAKoF,MAAA,GAAS,CAAC;UAClGJ,IAAA,CAAK,CAAC,IAAIF,CAAA,GAAI9E,IAAA,CAAKoF,MAAA,GAAS,CAAC,IAAIR,CAAA,GAAI5E,IAAA,CAAKoF,MAAA,GAAS,CAAC,IAAI/H,CAAA,GAAI2C,IAAA,CAAKoF,MAAA,GAAS,CAAC,IAAI1I,CAAA,GAAIsD,IAAA,CAAKoF,MAAA,GAAS,CAAC;UAElGH,KAAA,CAAM,CAAC,IAAIxI,CAAA,IAAKuD,IAAA,CAAKoF,MAAA,GAAS,CAAC,IAAIpF,IAAA,CAAKoF,MAAA,GAAS,CAAC;UAClDH,KAAA,CAAM,CAAC,IAAIxI,CAAA,IAAKuD,IAAA,CAAKoF,MAAA,GAAS,CAAC,IAAIpF,IAAA,CAAKoF,MAAA,GAAS,CAAC;UAClDH,KAAA,CAAM,CAAC,IAAIF,KAAA,CAAM,CAAC,IAAIA,KAAA,CAAM,CAAC;UAC7BE,KAAA,CAAM,CAAC,IAAIF,KAAA,CAAM,CAAC,IAAIA,KAAA,CAAM,CAAC;UAE7BG,KAAA,CAAM,CAAC,IAAID,KAAA,CAAM,CAAC,IAAIA,KAAA,CAAM,CAAC;UAC7BC,KAAA,CAAM,CAAC,IAAID,KAAA,CAAM,CAAC,IAAIA,KAAA,CAAM,CAAC;UAC7BC,KAAA,CAAM,CAAC,IAAID,KAAA,CAAM,CAAC,IAAIA,KAAA,CAAM,CAAC;UAC7BC,KAAA,CAAM,CAAC,IAAID,KAAA,CAAM,CAAC,IAAIA,KAAA,CAAM,CAAC;UAE7BjF,IAAA,CAAKoF,MAAA,GAAS,CAAC,IAAIF,KAAA,CAAM,CAAC,IAAIF,IAAA,CAAK,CAAC;UACpChF,IAAA,CAAKoF,MAAA,GAAS,CAAC,IAAIF,KAAA,CAAM,CAAC,IAAIF,IAAA,CAAK,CAAC;UACpChF,IAAA,CAAKoF,MAAA,GAAS,CAAC,IAAIF,KAAA,CAAM,CAAC,IAAIF,IAAA,CAAK,CAAC;UACpChF,IAAA,CAAKoF,MAAA,GAAS,CAAC,IAAIF,KAAA,CAAM,CAAC,IAAIF,IAAA,CAAK,CAAC;UAEpChF,IAAA,CAAKoF,MAAA,GAAS,CAAC,IAAIF,KAAA,CAAM,CAAC,IAAIF,IAAA,CAAK,CAAC;UACpChF,IAAA,CAAKoF,MAAA,GAAS,CAAC,IAAIF,KAAA,CAAM,CAAC,IAAIF,IAAA,CAAK,CAAC;UACpChF,IAAA,CAAKoF,MAAA,GAAS,CAAC,IAAIF,KAAA,CAAM,CAAC,IAAIF,IAAA,CAAK,CAAC;UACpChF,IAAA,CAAKoF,MAAA,GAAS,CAAC,IAAIF,KAAA,CAAM,CAAC,IAAIF,IAAA,CAAK,CAAC;QACrC;QAED,SAASK,MAAA,GAAS,GAAGA,MAAA,GAAS,GAAG,EAAEA,MAAA,EAAQ;UACzCN,KAAA,CAAM,CAAC,IAAI/K,CAAA,GAAIgG,IAAA,CAAK,KAAKqF,MAAM;UAC/BN,KAAA,CAAM,CAAC,IAAIF,CAAA,GAAI7E,IAAA,CAAK,KAAKqF,MAAM;UAC/BN,KAAA,CAAM,CAAC,IAAI/K,CAAA,GAAIgG,IAAA,CAAK,KAAKqF,MAAM;UAC/BN,KAAA,CAAM,CAAC,IAAIF,CAAA,GAAI7E,IAAA,CAAK,KAAKqF,MAAM;UAE/BL,IAAA,CAAK,CAAC,IAAItI,CAAA,GAAIsD,IAAA,CAAK,IAAIqF,MAAM,IAAIhI,CAAA,GAAI2C,IAAA,CAAK,KAAKqF,MAAM,IAAIT,CAAA,GAAI5E,IAAA,CAAK,KAAKqF,MAAM,IAAIP,CAAA,GAAI9E,IAAA,CAAK,KAAKqF,MAAM;UACrGL,IAAA,CAAK,CAAC,IAAI3H,CAAA,GAAI2C,IAAA,CAAK,IAAIqF,MAAM,IAAIP,CAAA,GAAI9E,IAAA,CAAK,KAAKqF,MAAM,IAAI3I,CAAA,GAAIsD,IAAA,CAAK,KAAKqF,MAAM,IAAIT,CAAA,GAAI5E,IAAA,CAAK,KAAKqF,MAAM;UACrGL,IAAA,CAAK,CAAC,IAAIJ,CAAA,GAAI5E,IAAA,CAAK,IAAIqF,MAAM,IAAI3I,CAAA,GAAIsD,IAAA,CAAK,KAAKqF,MAAM,IAAIP,CAAA,GAAI9E,IAAA,CAAK,KAAKqF,MAAM,IAAIhI,CAAA,GAAI2C,IAAA,CAAK,KAAKqF,MAAM;UACrGL,IAAA,CAAK,CAAC,IAAIF,CAAA,GAAI9E,IAAA,CAAK,IAAIqF,MAAM,IAAIT,CAAA,GAAI5E,IAAA,CAAK,KAAKqF,MAAM,IAAIhI,CAAA,GAAI2C,IAAA,CAAK,KAAKqF,MAAM,IAAI3I,CAAA,GAAIsD,IAAA,CAAK,KAAKqF,MAAM;UAErGJ,KAAA,CAAM,CAAC,IAAIxI,CAAA,IAAKuD,IAAA,CAAKqF,MAAM,IAAIrF,IAAA,CAAK,KAAKqF,MAAM;UAC/CJ,KAAA,CAAM,CAAC,IAAIxI,CAAA,IAAKuD,IAAA,CAAKqF,MAAM,IAAIrF,IAAA,CAAK,KAAKqF,MAAM;UAE/CJ,KAAA,CAAM,CAAC,IAAIF,KAAA,CAAM,CAAC,IAAIA,KAAA,CAAM,CAAC;UAC7BE,KAAA,CAAM,CAAC,IAAIF,KAAA,CAAM,CAAC,IAAIA,KAAA,CAAM,CAAC;UAE7BG,KAAA,CAAM,CAAC,IAAID,KAAA,CAAM,CAAC,IAAIA,KAAA,CAAM,CAAC;UAC7BC,KAAA,CAAM,CAAC,IAAID,KAAA,CAAM,CAAC,IAAIA,KAAA,CAAM,CAAC;UAC7BC,KAAA,CAAM,CAAC,IAAID,KAAA,CAAM,CAAC,IAAIA,KAAA,CAAM,CAAC;UAC7BC,KAAA,CAAM,CAAC,IAAID,KAAA,CAAM,CAAC,IAAIA,KAAA,CAAM,CAAC;UAE7BjF,IAAA,CAAK,IAAIqF,MAAM,IAAIH,KAAA,CAAM,CAAC,IAAIF,IAAA,CAAK,CAAC;UACpChF,IAAA,CAAK,IAAIqF,MAAM,IAAIH,KAAA,CAAM,CAAC,IAAIF,IAAA,CAAK,CAAC;UACpChF,IAAA,CAAK,KAAKqF,MAAM,IAAIH,KAAA,CAAM,CAAC,IAAIF,IAAA,CAAK,CAAC;UACrChF,IAAA,CAAK,KAAKqF,MAAM,IAAIH,KAAA,CAAM,CAAC,IAAIF,IAAA,CAAK,CAAC;UAErChF,IAAA,CAAK,KAAKqF,MAAM,IAAIH,KAAA,CAAM,CAAC,IAAIF,IAAA,CAAK,CAAC;UACrChF,IAAA,CAAK,KAAKqF,MAAM,IAAIH,KAAA,CAAM,CAAC,IAAIF,IAAA,CAAK,CAAC;UACrChF,IAAA,CAAK,KAAKqF,MAAM,IAAIH,KAAA,CAAM,CAAC,IAAIF,IAAA,CAAK,CAAC;UACrChF,IAAA,CAAK,KAAKqF,MAAM,IAAIH,KAAA,CAAM,CAAC,IAAIF,IAAA,CAAK,CAAC;QACtC;MACF;MAED,SAASzB,cAAcvD,IAAA,EAAM;QAC3B,SAASzG,CAAA,GAAI,GAAGA,CAAA,GAAI,IAAI,EAAEA,CAAA,EAAG;UAC3B,IAAI4K,CAAA,GAAInE,IAAA,CAAK,CAAC,EAAEzG,CAAC;UACjB,IAAI+L,EAAA,GAAKtF,IAAA,CAAK,CAAC,EAAEzG,CAAC;UAClB,IAAIgM,EAAA,GAAKvF,IAAA,CAAK,CAAC,EAAEzG,CAAC;UAElByG,IAAA,CAAK,CAAC,EAAEzG,CAAC,IAAI4K,CAAA,GAAI,SAASoB,EAAA;UAC1BvF,IAAA,CAAK,CAAC,EAAEzG,CAAC,IAAI4K,CAAA,GAAI,SAASmB,EAAA,GAAK,SAASC,EAAA;UACxCvF,IAAA,CAAK,CAAC,EAAEzG,CAAC,IAAI4K,CAAA,GAAI,SAASmB,EAAA;QAC3B;MACF;MAED,SAAS9B,cAAcI,GAAA,EAAKc,GAAA,EAAK7C,GAAA,EAAK;QACpC,SAAStI,CAAA,GAAI,GAAGA,CAAA,GAAI,IAAI,EAAEA,CAAA,EAAG;UAC3BmL,GAAA,CAAI7C,GAAA,GAAMtI,CAAC,IAAIiM,SAAA,CAAUC,WAAA,CAAYC,QAAA,CAAS9B,GAAA,CAAIrK,CAAC,CAAC,CAAC;QACtD;MACF;MAED,SAASmM,SAASC,KAAA,EAAO;QACvB,IAAIA,KAAA,IAAS,GAAG;UACd,OAAO1M,IAAA,CAAK2M,IAAA,CAAKD,KAAK,IAAI1M,IAAA,CAAKC,GAAA,CAAID,IAAA,CAAK4M,GAAA,CAAIF,KAAK,GAAG,GAAG;QAC/D,OAAa;UACL,OAAO1M,IAAA,CAAK2M,IAAA,CAAKD,KAAK,IAAI1M,IAAA,CAAKC,GAAA,CAAIF,OAAA,EAASC,IAAA,CAAK4M,GAAA,CAAIF,KAAK,IAAI,CAAG;QAClE;MACF;MAED,SAASG,cAAcC,IAAA,EAAM;QAC3B,OAAO,IAAI/E,QAAA,CAAS+E,IAAA,CAAKC,KAAA,CAAMzO,MAAA,EAAQwO,IAAA,CAAKE,MAAA,CAAO5O,KAAA,EAAO0O,IAAA,CAAKlF,IAAI;MACpE;MAED,SAASqF,cAAcH,IAAA,EAAM;QAC3B,IAAII,UAAA,GAAaJ,IAAA,CAAKK,MAAA,CAAO7O,MAAA,CAAO8O,KAAA,CAAMN,IAAA,CAAKE,MAAA,CAAO5O,KAAA,EAAO0O,IAAA,CAAKE,MAAA,CAAO5O,KAAA,GAAQ0O,IAAA,CAAKlF,IAAI;QAE1F,IAAIyF,SAAA,GAAY,IAAInK,UAAA,CAAWyE,eAAA,CAAgBuF,UAAU,CAAC;QAC1D,IAAII,SAAA,GAAY,IAAIpK,UAAA,CAAWmK,SAAA,CAAUjG,MAAM;QAE/CH,SAAA,CAAUoG,SAAS;QAEnBhG,gBAAA,CAAiBgG,SAAA,EAAWC,SAAS;QAErC,OAAO,IAAIvF,QAAA,CAASuF,SAAA,CAAUhP,MAAM;MACrC;MAED,SAASiP,cAAcT,IAAA,EAAM;QAC3B,IAAII,UAAA,GAAaJ,IAAA,CAAKC,KAAA,CAAMK,KAAA,CAAMN,IAAA,CAAKE,MAAA,CAAO5O,KAAA,EAAO0O,IAAA,CAAKE,MAAA,CAAO5O,KAAA,GAAQ0O,IAAA,CAAKlF,IAAI;QAClF,IAAIyF,SAAA,GAAYG,UAAA,CAAWN,UAAU;QACrC,IAAII,SAAA,GAAY,IAAIpK,UAAA,CAAWmK,SAAA,CAAUjG,MAAM;QAE/CH,SAAA,CAAUoG,SAAS;QAEnBhG,gBAAA,CAAiBgG,SAAA,EAAWC,SAAS;QAErC,OAAO,IAAIvF,QAAA,CAASuF,SAAA,CAAUhP,MAAM;MACrC;MAED,SAASmP,cAAcX,IAAA,EAAM;QAC3B,IAAIlL,UAAA,GAAakL,IAAA,CAAKK,MAAA;QACtB,IAAI/L,QAAA,GAAW;UAAEhD,KAAA,EAAO0O,IAAA,CAAKE,MAAA,CAAO5O;QAAO;QAE3C,IAAI0E,SAAA,GAAY,IAAI+G,WAAA,CAAYiD,IAAA,CAAKnE,KAAA,GAAQmE,IAAA,CAAKY,iBAAA,IAAqBZ,IAAA,CAAKa,QAAA,GAAWb,IAAA,CAAK9O,IAAA,CAAK;QACjG,IAAImC,MAAA,GAAS,IAAI+C,UAAA,CAAWzE,WAAW;QAGvC,IAAImP,YAAA,GAAe;QACnB,IAAIC,cAAA,GAAiB,IAAItM,KAAA,CAAMuL,IAAA,CAAKa,QAAQ;QAC5C,SAASrN,CAAA,GAAI,GAAGA,CAAA,GAAIwM,IAAA,CAAKa,QAAA,EAAUrN,CAAA,IAAK;UACtCuN,cAAA,CAAevN,CAAC,IAAI,CAAE;UACtBuN,cAAA,CAAevN,CAAC,EAAE,OAAO,IAAIsN,YAAA;UAC7BC,cAAA,CAAevN,CAAC,EAAE,KAAK,IAAIuN,cAAA,CAAevN,CAAC,EAAE,OAAO;UACpDuN,cAAA,CAAevN,CAAC,EAAE,IAAI,IAAIwM,IAAA,CAAKnE,KAAA;UAC/BkF,cAAA,CAAevN,CAAC,EAAE,IAAI,IAAIwM,IAAA,CAAKgB,KAAA;UAC/BD,cAAA,CAAevN,CAAC,EAAE,MAAM,IAAIwM,IAAA,CAAK9O,IAAA;UAEjC4P,YAAA,IAAgBC,cAAA,CAAevN,CAAC,EAAEoE,EAAA,GAAKmJ,cAAA,CAAevN,CAAC,EAAEsE,EAAA,GAAKiJ,cAAA,CAAevN,CAAC,EAAEsH,IAAA;QACjF;QAID,IAAImG,UAAA,GAAaC,WAAA,CAAYpM,UAAA,EAAYR,QAAQ;QACjD,IAAI6M,UAAA,GAAaD,WAAA,CAAYpM,UAAA,EAAYR,QAAQ;QAEjD,IAAI6M,UAAA,IAAcxP,WAAA,EAAa;UAC7B,MAAM;QACP;QAED,IAAIsP,UAAA,IAAcE,UAAA,EAAY;UAC5B,SAAS3N,CAAA,GAAI,GAAGA,CAAA,GAAI2N,UAAA,GAAaF,UAAA,GAAa,GAAGzN,CAAA,IAAK;YACpDH,MAAA,CAAOG,CAAA,GAAIyN,UAAU,IAAIG,UAAA,CAAWtM,UAAA,EAAYR,QAAQ;UACzD;QACF;QAGD,IAAIhB,GAAA,GAAM,IAAIyJ,WAAA,CAAYrL,YAAY;QACtC,IAAI2P,QAAA,GAAWjO,oBAAA,CAAqBC,MAAA,EAAQC,GAAG;QAE/C,IAAIgH,MAAA,GAASR,WAAA,CAAYhF,UAAA,EAAYR,QAAQ;QAG7CoF,aAAA,CAAcsG,IAAA,CAAKC,KAAA,EAAOnL,UAAA,EAAYR,QAAA,EAAUgG,MAAA,EAAQtE,SAAA,EAAW8K,YAAY;QAG/E,SAAStN,CAAA,GAAI,GAAGA,CAAA,GAAIwM,IAAA,CAAKa,QAAA,EAAU,EAAErN,CAAA,EAAG;UACtC,IAAI8N,EAAA,GAAKP,cAAA,CAAevN,CAAC;UAEzB,SAASmE,CAAA,GAAI,GAAGA,CAAA,GAAIoJ,cAAA,CAAevN,CAAC,EAAEsH,IAAA,EAAM,EAAEnD,CAAA,EAAG;YAC/CF,UAAA,CAAWzB,SAAA,EAAWsL,EAAA,CAAGC,KAAA,GAAQ5J,CAAA,EAAG2J,EAAA,CAAG1J,EAAA,EAAI0J,EAAA,CAAGxG,IAAA,EAAMwG,EAAA,CAAGxJ,EAAA,EAAIwJ,EAAA,CAAG1J,EAAA,GAAK0J,EAAA,CAAGxG,IAAA,EAAMuG,QAAQ;UACrF;QACF;QAGDrH,QAAA,CAAS1G,GAAA,EAAK0C,SAAA,EAAW8K,YAAY;QAGrC,IAAIU,UAAA,GAAY;QAChB,IAAIhB,SAAA,GAAY,IAAIpK,UAAA,CAAWJ,SAAA,CAAUxE,MAAA,CAAOuJ,UAAU;QAC1D,SAASqD,CAAA,GAAI,GAAGA,CAAA,GAAI4B,IAAA,CAAKgB,KAAA,EAAO5C,CAAA,IAAK;UACnC,SAASnK,CAAA,GAAI,GAAGA,CAAA,GAAI+L,IAAA,CAAKa,QAAA,EAAU5M,CAAA,IAAK;YACtC,IAAIqN,EAAA,GAAKP,cAAA,CAAe9M,CAAC;YAEzB,IAAIR,CAAA,GAAI6N,EAAA,CAAG1J,EAAA,GAAK0J,EAAA,CAAGxG,IAAA;YACnB,IAAI2G,EAAA,GAAK,IAAIrL,UAAA,CAAWJ,SAAA,CAAUxE,MAAA,EAAQ8P,EAAA,CAAGI,GAAA,GAAMhP,UAAA,EAAYe,CAAA,GAAIf,UAAU;YAE7E8N,SAAA,CAAUmB,GAAA,CAAIF,EAAA,EAAID,UAAS;YAC3BA,UAAA,IAAa/N,CAAA,GAAIf,UAAA;YACjB4O,EAAA,CAAGI,GAAA,IAAOjO,CAAA;UACX;QACF;QAED,OAAO,IAAIwH,QAAA,CAASuF,SAAA,CAAUhP,MAAM;MACrC;MAED,SAASoQ,cAAc5B,IAAA,EAAM;QAC3B,IAAII,UAAA,GAAaJ,IAAA,CAAKC,KAAA,CAAMK,KAAA,CAAMN,IAAA,CAAKE,MAAA,CAAO5O,KAAA,EAAO0O,IAAA,CAAKE,MAAA,CAAO5O,KAAA,GAAQ0O,IAAA,CAAKlF,IAAI;QAClF,IAAIyF,SAAA,GAAYG,UAAA,CAAWN,UAAU;QAErC,IAAMyB,EAAA,GAAK7B,IAAA,CAAKgB,KAAA,GAAQhB,IAAA,CAAKa,QAAA,GAAWb,IAAA,CAAKnE,KAAA;QAC7C,IAAM2E,SAAA,GAAYR,IAAA,CAAK9O,IAAA,IAAQ,IAAI,IAAI6L,WAAA,CAAY8E,EAAE,IAAI,IAAIC,WAAA,CAAYD,EAAE;QAE3E,IAAIE,YAAA,GAAe;QACnB,IAAIC,QAAA,GAAW;QACf,IAAMC,GAAA,GAAM,IAAIxN,KAAA,CAAM,CAAC;QAEvB,SAAS2J,CAAA,GAAI,GAAGA,CAAA,GAAI4B,IAAA,CAAKgB,KAAA,EAAO5C,CAAA,IAAK;UACnC,SAASnK,CAAA,GAAI,GAAGA,CAAA,GAAI+L,IAAA,CAAKa,QAAA,EAAU5M,CAAA,IAAK;YACtC,IAAIiO,KAAA,GAAQ;YAEZ,QAAQlC,IAAA,CAAK9O,IAAA;cACX,KAAK;gBACH+Q,GAAA,CAAI,CAAC,IAAIF,YAAA;gBACTE,GAAA,CAAI,CAAC,IAAIA,GAAA,CAAI,CAAC,IAAIjC,IAAA,CAAKnE,KAAA;gBACvBkG,YAAA,GAAeE,GAAA,CAAI,CAAC,IAAIjC,IAAA,CAAKnE,KAAA;gBAE7B,SAASlE,CAAA,GAAI,GAAGA,CAAA,GAAIqI,IAAA,CAAKnE,KAAA,EAAO,EAAElE,CAAA,EAAG;kBACnC,IAAMwK,IAAA,GAAQ5B,SAAA,CAAU0B,GAAA,CAAI,CAAC,GAAG,KAAK,IAAK1B,SAAA,CAAU0B,GAAA,CAAI,CAAC,GAAG;kBAE5DC,KAAA,IAASC,IAAA;kBAET3B,SAAA,CAAUwB,QAAQ,IAAIE,KAAA;kBACtBF,QAAA;gBACD;gBAED;cAEF,KAAK;gBACHC,GAAA,CAAI,CAAC,IAAIF,YAAA;gBACTE,GAAA,CAAI,CAAC,IAAIA,GAAA,CAAI,CAAC,IAAIjC,IAAA,CAAKnE,KAAA;gBACvBoG,GAAA,CAAI,CAAC,IAAIA,GAAA,CAAI,CAAC,IAAIjC,IAAA,CAAKnE,KAAA;gBACvBkG,YAAA,GAAeE,GAAA,CAAI,CAAC,IAAIjC,IAAA,CAAKnE,KAAA;gBAE7B,SAASlE,EAAA,GAAI,GAAGA,EAAA,GAAIqI,IAAA,CAAKnE,KAAA,EAAO,EAAElE,EAAA,EAAG;kBACnC,IAAMwK,KAAA,GAAQ5B,SAAA,CAAU0B,GAAA,CAAI,CAAC,GAAG,KAAK,KAAO1B,SAAA,CAAU0B,GAAA,CAAI,CAAC,GAAG,KAAK,KAAO1B,SAAA,CAAU0B,GAAA,CAAI,CAAC,GAAG,KAAK;kBAEjGC,KAAA,IAASC,KAAA;kBAET3B,SAAA,CAAUwB,QAAQ,IAAIE,KAAA;kBACtBF,QAAA;gBACD;gBAED;YACH;UACF;QACF;QAED,OAAO,IAAI/G,QAAA,CAASuF,SAAA,CAAUhP,MAAM;MACrC;MAED,SAAS4Q,cAAcpC,IAAA,EAAM;QAC3B,IAAIlL,UAAA,GAAakL,IAAA,CAAKK,MAAA;QACtB,IAAI/L,QAAA,GAAW;UAAEhD,KAAA,EAAO0O,IAAA,CAAKE,MAAA,CAAO5O;QAAO;QAC3C,IAAI0E,SAAA,GAAY,IAAII,UAAA,CAAW4J,IAAA,CAAKnE,KAAA,GAAQmE,IAAA,CAAKgB,KAAA,IAAShB,IAAA,CAAKa,QAAA,GAAWb,IAAA,CAAK9O,IAAA,GAAOwB,UAAA,CAAW;QAGjG,IAAI2P,SAAA,GAAY;UACdC,OAAA,EAASC,UAAA,CAAWzN,UAAA,EAAYR,QAAQ;UACxCkO,uBAAA,EAAyBD,UAAA,CAAWzN,UAAA,EAAYR,QAAQ;UACxDmO,qBAAA,EAAuBF,UAAA,CAAWzN,UAAA,EAAYR,QAAQ;UACtDoO,gBAAA,EAAkBH,UAAA,CAAWzN,UAAA,EAAYR,QAAQ;UACjDqO,gBAAA,EAAkBJ,UAAA,CAAWzN,UAAA,EAAYR,QAAQ;UACjDsO,iBAAA,EAAmBL,UAAA,CAAWzN,UAAA,EAAYR,QAAQ;UAClDuO,mBAAA,EAAqBN,UAAA,CAAWzN,UAAA,EAAYR,QAAQ;UACpDwO,UAAA,EAAYP,UAAA,CAAWzN,UAAA,EAAYR,QAAQ;UAC3CyO,wBAAA,EAA0BR,UAAA,CAAWzN,UAAA,EAAYR,QAAQ;UACzD0O,wBAAA,EAA0BT,UAAA,CAAWzN,UAAA,EAAYR,QAAQ;UACzD2O,aAAA,EAAeV,UAAA,CAAWzN,UAAA,EAAYR,QAAQ;QAC/C;QAED,IAAI+N,SAAA,CAAUC,OAAA,GAAU,GAAG;UACzB,MAAM,sBAAsBY,SAAA,CAAUC,WAAA,GAAc,cAAcd,SAAA,CAAUC,OAAA,GAAU;QACvF;QAGD,IAAIc,YAAA,GAAe,IAAI3O,KAAA,CAAO;QAC9B,IAAI4O,QAAA,GAAWnC,WAAA,CAAYpM,UAAA,EAAYR,QAAQ,IAAI5B,UAAA;QAEnD,OAAO2Q,QAAA,GAAW,GAAG;UACnB,IAAIC,IAAA,GAAOC,yBAAA,CAA0BzO,UAAA,CAAWtD,MAAA,EAAQ8C,QAAQ;UAChE,IAAIhD,KAAA,GAAQ8P,UAAA,CAAWtM,UAAA,EAAYR,QAAQ;UAC3C,IAAI6O,WAAA,GAAe7R,KAAA,IAAS,IAAK;UACjC,IAAIkS,GAAA,IAAOlS,KAAA,IAAS,KAAK;UACzB,IAAImI,KAAA,GAAQ,IAAIgK,SAAA,CAAU,CAACD,GAAG,CAAC,EAAE,CAAC;UAClC,IAAItS,IAAA,GAAOkQ,UAAA,CAAWtM,UAAA,EAAYR,QAAQ;UAE1C8O,YAAA,CAAahI,IAAA,CAAK;YAChBkI,IAAA,EAAAA,IAAA;YACA7J,KAAA,EAAAA,KAAA;YACAvI,IAAA,EAAAA,IAAA;YACAiS,WAAA,EAAAA;UACV,CAAS;UAEDE,QAAA,IAAYC,IAAA,CAAKhJ,MAAA,GAAS;QAC3B;QAGD,IAAIuG,QAAA,GAAWqC,SAAA,CAAUrC,QAAA;QACzB,IAAIpF,WAAA,GAAc,IAAIhH,KAAA,CAAMuL,IAAA,CAAKa,QAAQ;QAEzC,SAASrN,CAAA,GAAI,GAAGA,CAAA,GAAIwM,IAAA,CAAKa,QAAA,EAAU,EAAErN,CAAA,EAAG;UACtC,IAAI8N,EAAA,GAAM7F,WAAA,CAAYjI,CAAC,IAAI;UAC3B,IAAIkQ,OAAA,GAAU7C,QAAA,CAASrN,CAAC;UAExB8N,EAAA,CAAGgC,IAAA,GAAOI,OAAA,CAAQJ,IAAA;UAClBhC,EAAA,CAAG6B,WAAA,GAAcrQ,OAAA;UACjBwO,EAAA,CAAGnD,OAAA,GAAU;UACbmD,EAAA,CAAGpQ,IAAA,GAAOwS,OAAA,CAAQC,SAAA;UAClBrC,EAAA,CAAGsC,OAAA,GAAUF,OAAA,CAAQE,OAAA;UACrBtC,EAAA,CAAGzF,KAAA,GAAQmE,IAAA,CAAKnE,KAAA;UAChByF,EAAA,CAAGvF,MAAA,GAASiE,IAAA,CAAKgB,KAAA;QAClB;QAED,IAAIzF,MAAA,GAAS;UACXO,GAAA,EAAK,IAAIrH,KAAA,CAAM,CAAC;QACjB;QAED,SAASiJ,OAAA,GAAS,GAAGA,OAAA,GAASsC,IAAA,CAAKa,QAAA,EAAU,EAAEnD,OAAA,EAAQ;UACrD,IAAI4D,EAAA,GAAK7F,WAAA,CAAYiC,OAAM;UAE3B,SAASlK,CAAA,GAAI,GAAGA,CAAA,GAAI4P,YAAA,CAAa9I,MAAA,EAAQ,EAAE9G,CAAA,EAAG;YAC5C,IAAIqQ,IAAA,GAAOT,YAAA,CAAa5P,CAAC;YAEzB,IAAI8N,EAAA,CAAGgC,IAAA,IAAQO,IAAA,CAAKP,IAAA,EAAM;cACxBhC,EAAA,CAAG6B,WAAA,GAAcU,IAAA,CAAKV,WAAA;cAEtB,IAAIU,IAAA,CAAKpK,KAAA,IAAS,GAAG;gBACnB8B,MAAA,CAAOO,GAAA,CAAI+H,IAAA,CAAKpK,KAAK,IAAIiE,OAAA;cAC1B;cAED4D,EAAA,CAAGpB,MAAA,GAASxC,OAAA;YACb;UACF;QACF;QAGD,IAAI2E,SAAA,CAAUK,gBAAA,GAAmB,GAAG;UAClC,QAAQL,SAAA,CAAUY,aAAA;YAChB,KAAKrQ,cAAA;cACH,IAAI8I,QAAA,GAAW,IAAIqB,WAAA,CAAYsF,SAAA,CAAUU,wBAAwB;cACjErJ,aAAA,CACEsG,IAAA,CAAKC,KAAA,EACLnL,UAAA,EACAR,QAAA,EACA+N,SAAA,CAAUK,gBAAA,EACVhH,QAAA,EACA2G,SAAA,CAAUU,wBACX;cACD;YAEF,KAAKlQ,OAAA;cACH,IAAIuN,UAAA,GAAaJ,IAAA,CAAKC,KAAA,CAAMK,KAAA,CAAMhM,QAAA,CAAShD,KAAA,EAAOgD,QAAA,CAAShD,KAAA,GAAQ+Q,SAAA,CAAUU,wBAAwB;cACrG,IAAI9I,IAAA,GAAOyG,UAAA,CAAWN,UAAU;cAChC,IAAI1E,QAAA,GAAW,IAAIqB,WAAA,CAAY9C,IAAA,CAAKzI,MAAM;cAC1C8C,QAAA,CAAShD,KAAA,IAAS+Q,SAAA,CAAUU,wBAAA;cAC5B;UACH;QACF;QAGD,IAAIV,SAAA,CAAUM,gBAAA,GAAmB,GAAG;UAClC,IAAImB,QAAA,GAAW;YACb7D,KAAA,EAAOD,IAAA,CAAKC,KAAA;YACZC,MAAA,EAAQ5L,QAAA;YACRwG,IAAA,EAAMuH,SAAA,CAAUM;UACjB;UACD,IAAIhH,QAAA,GAAW,IAAIoB,WAAA,CAAY0D,aAAA,CAAcqD,QAAQ,EAAEtS,MAAM;UAC7D8C,QAAA,CAAShD,KAAA,IAAS+Q,SAAA,CAAUM,gBAAA;QAC7B;QAGD,IAAIN,SAAA,CAAUS,UAAA,GAAa,GAAG;UAC5B,IAAI1C,UAAA,GAAaJ,IAAA,CAAKC,KAAA,CAAMK,KAAA,CAAMhM,QAAA,CAAShD,KAAA,EAAOgD,QAAA,CAAShD,KAAA,GAAQ+Q,SAAA,CAAUO,iBAAiB;UAC9F,IAAI3I,IAAA,GAAOyG,UAAA,CAAWN,UAAU;UAChC,IAAI2D,SAAA,GAAYlJ,eAAA,CAAgBZ,IAAA,CAAKzI,MAAM;UAE3C8C,QAAA,CAAShD,KAAA,IAAS+Q,SAAA,CAAUO,iBAAA;QAC7B;QAGD,IAAI9B,YAAA,GAAe;QACnB,IAAIlE,UAAA,GAAa,IAAInI,KAAA,CAAMgH,WAAA,CAAYnB,MAAM;QAC7C,SAAS9G,CAAA,GAAI,GAAGA,CAAA,GAAIoJ,UAAA,CAAWtC,MAAA,EAAQ,EAAE9G,CAAA,EAAG;UAC1CoJ,UAAA,CAAWpJ,CAAC,IAAI,IAAIiB,KAAA,CAAO;QAC5B;QAED,SAAS2J,CAAA,GAAI,GAAGA,CAAA,GAAI4B,IAAA,CAAKgB,KAAA,EAAO,EAAE5C,CAAA,EAAG;UACnC,SAAS4F,IAAA,GAAO,GAAGA,IAAA,GAAOvI,WAAA,CAAYnB,MAAA,EAAQ,EAAE0J,IAAA,EAAM;YACpDpH,UAAA,CAAWoH,IAAI,EAAE5I,IAAA,CAAK0F,YAAY;YAClCA,YAAA,IAAgBrF,WAAA,CAAYuI,IAAI,EAAEnI,KAAA,GAAQmE,IAAA,CAAK9O,IAAA,GAAOwB,UAAA;UACvD;QACF;QAGD4I,cAAA,CAAeC,MAAA,EAAQqB,UAAA,EAAYnB,WAAA,EAAaC,QAAA,EAAUC,QAAA,EAAU3F,SAAS;QAG7E,SAASxC,CAAA,GAAI,GAAGA,CAAA,GAAIiI,WAAA,CAAYnB,MAAA,EAAQ,EAAE9G,CAAA,EAAG;UAC3C,IAAI8N,EAAA,GAAK7F,WAAA,CAAYjI,CAAC;UAEtB,IAAI8N,EAAA,CAAGnD,OAAA,EAAS;UAEhB,QAAQmD,EAAA,CAAG6B,WAAA;YACT,KAAKnQ,GAAA;cACH,IAAIoM,GAAA,GAAM;cACV,IAAI6E,SAAA,GAAY;cAEhB,SAAS7F,CAAA,GAAI,GAAGA,CAAA,GAAI4B,IAAA,CAAKgB,KAAA,EAAO,EAAE5C,CAAA,EAAG;gBACnC,IAAI8F,cAAA,GAAiBtH,UAAA,CAAWpJ,CAAC,EAAE4L,GAAG;gBAEtC,SAASf,CAAA,GAAI,GAAGA,CAAA,GAAIiD,EAAA,CAAGzF,KAAA,EAAO,EAAEwC,CAAA,EAAG;kBACjC,SAAS8F,IAAA,GAAO,GAAGA,IAAA,GAAOzR,UAAA,GAAa4O,EAAA,CAAGpQ,IAAA,EAAM,EAAEiT,IAAA,EAAM;oBACtDnO,SAAA,CAAUkO,cAAA,EAAgB,IAAIH,SAAA,CAAUE,SAAA,GAAYE,IAAA,GAAO7C,EAAA,CAAGzF,KAAA,GAAQyF,EAAA,CAAGvF,MAAM;kBAChF;kBAEDkI,SAAA;gBACD;gBAED7E,GAAA;cACD;cAED;YAEF,KAAKrM,SAAA;YAEL;cACE,MAAM;UACT;QACF;QAED,OAAO,IAAIkI,QAAA,CAASjF,SAAA,CAAUxE,MAAM;MACrC;MAED,SAAS+R,0BAA0B7L,OAAA,EAAQgG,OAAA,EAAQ;QACjD,IAAI0G,UAAA,GAAa,IAAIhO,UAAA,CAAWsB,OAAM;QACtC,IAAI2M,SAAA,GAAY;QAEhB,OAAOD,UAAA,CAAW1G,OAAA,CAAOpM,KAAA,GAAQ+S,SAAS,KAAK,GAAG;UAChDA,SAAA,IAAa;QACd;QAED,IAAIC,WAAA,GAAc,IAAIC,WAAA,CAAa,EAACC,MAAA,CAAOJ,UAAA,CAAW9D,KAAA,CAAM5C,OAAA,CAAOpM,KAAA,EAAOoM,OAAA,CAAOpM,KAAA,GAAQ+S,SAAS,CAAC;QAEnG3G,OAAA,CAAOpM,KAAA,GAAQoM,OAAA,CAAOpM,KAAA,GAAQ+S,SAAA,GAAY;QAE1C,OAAOC,WAAA;MACR;MAED,SAASG,uBAAuB/M,OAAA,EAAQgG,OAAA,EAAQ5C,IAAA,EAAM;QACpD,IAAIwJ,WAAA,GAAc,IAAIC,WAAA,CAAa,EAACC,MAAA,CAAO,IAAIpO,UAAA,CAAWsB,OAAM,EAAE4I,KAAA,CAAM5C,OAAA,CAAOpM,KAAA,EAAOoM,OAAA,CAAOpM,KAAA,GAAQwJ,IAAI,CAAC;QAE1G4C,OAAA,CAAOpM,KAAA,GAAQoM,OAAA,CAAOpM,KAAA,GAAQwJ,IAAA;QAE9B,OAAOwJ,WAAA;MACR;MAED,SAASI,cAAc9I,QAAA,EAAU8B,OAAA,EAAQ;QACvC,IAAIW,CAAA,GAAIsG,UAAA,CAAW/I,QAAA,EAAU8B,OAAM;QACnC,IAAIU,CAAA,GAAItE,WAAA,CAAY8B,QAAA,EAAU8B,OAAM;QAEpC,OAAO,CAACW,CAAA,EAAGD,CAAC;MACb;MAED,SAASwG,cAAchJ,QAAA,EAAU8B,OAAA,EAAQ;QACvC,IAAIW,CAAA,GAAIvE,WAAA,CAAY8B,QAAA,EAAU8B,OAAM;QACpC,IAAIU,CAAA,GAAItE,WAAA,CAAY8B,QAAA,EAAU8B,OAAM;QAEpC,OAAO,CAACW,CAAA,EAAGD,CAAC;MACb;MAED,SAASuG,WAAW/I,QAAA,EAAU8B,OAAA,EAAQ;QACpC,IAAImH,KAAA,GAAQjJ,QAAA,CAASkJ,QAAA,CAASpH,OAAA,CAAOpM,KAAA,EAAO,IAAI;QAEhDoM,OAAA,CAAOpM,KAAA,GAAQoM,OAAA,CAAOpM,KAAA,GAAQmB,UAAA;QAE9B,OAAOoS,KAAA;MACR;MAED,SAAS/K,YAAY8B,QAAA,EAAU8B,OAAA,EAAQ;QACrC,IAAIqH,MAAA,GAASnJ,QAAA,CAASoJ,SAAA,CAAUtH,OAAA,CAAOpM,KAAA,EAAO,IAAI;QAElDoM,OAAA,CAAOpM,KAAA,GAAQoM,OAAA,CAAOpM,KAAA,GAAQmB,UAAA;QAE9B,OAAOsS,MAAA;MACR;MAED,SAASxQ,gBAAgBF,WAAA,EAAYqJ,OAAA,EAAQ;QAC3C,IAAIuH,KAAA,GAAQ5Q,WAAA,CAAWqJ,OAAA,CAAOpM,KAAK;QAEnCoM,OAAA,CAAOpM,KAAA,GAAQoM,OAAA,CAAOpM,KAAA,GAAQqB,SAAA;QAE9B,OAAOsS,KAAA;MACR;MAED,SAAS7D,WAAWxF,QAAA,EAAU8B,OAAA,EAAQ;QACpC,IAAIuH,KAAA,GAAQrJ,QAAA,CAASP,QAAA,CAASqC,OAAA,CAAOpM,KAAK;QAE1CoM,OAAA,CAAOpM,KAAA,GAAQoM,OAAA,CAAOpM,KAAA,GAAQqB,SAAA;QAE9B,OAAOsS,KAAA;MACR;MAED,IAAM1C,UAAA,GAAa,SAAbA,WAAuB3G,QAAA,EAAU8B,OAAA,EAAQ;QAC7C,IAAIwH,GAAA;QAEJ,IAAI,iBAAiBjK,QAAA,CAASkK,SAAA,EAAW;UACvCD,GAAA,GAAME,MAAA,CAAOxJ,QAAA,CAASyJ,WAAA,CAAY3H,OAAA,CAAOpM,KAAA,EAAO,IAAI,CAAC;QAC7D,OAAa;UACL4T,GAAA,GAAMtJ,QAAA,CAASoJ,SAAA,CAAUtH,OAAA,CAAOpM,KAAA,GAAQ,GAAG,IAAI,IAAI8T,MAAA,CAAOxJ,QAAA,CAASoJ,SAAA,CAAUtH,OAAA,CAAOpM,KAAA,EAAO,IAAI,KAAK,EAAE;QACvG;QAEDoM,OAAA,CAAOpM,KAAA,IAASiB,UAAA;QAEhB,OAAO2S,GAAA;MACR;MAED,SAASI,aAAa1J,QAAA,EAAU8B,OAAA,EAAQ;QACtC,IAAIkC,KAAA,GAAQhE,QAAA,CAAS2J,UAAA,CAAW7H,OAAA,CAAOpM,KAAA,EAAO,IAAI;QAElDoM,OAAA,CAAOpM,KAAA,IAASkB,YAAA;QAEhB,OAAOoN,KAAA;MACR;MAED,SAAS4F,cAAc5J,QAAA,EAAU8B,OAAA,EAAQ;QACvC,OAAO+B,SAAA,CAAUC,WAAA,CAAY4F,YAAA,CAAa1J,QAAA,EAAU8B,OAAM,CAAC;MAC5D;MAGD,SAASc,cAAciH,MAAA,EAAQ;QAC7B,IAAIC,QAAA,IAAYD,MAAA,GAAS,UAAW;UAClCE,QAAA,GAAWF,MAAA,GAAS;QAEtB,QACGA,MAAA,IAAU,KAAK,KAAK,MACpBC,QAAA,GACGA,QAAA,KAAa,KACXC,QAAA,GACEC,GAAA,GACAC,QAAA,GACF3S,IAAA,CAAKC,GAAA,CAAI,GAAGuS,QAAA,GAAW,EAAE,KAAK,IAAIC,QAAA,GAAW,QAC/C,kBAAkBA,QAAA,GAAW;MAEpC;MAED,SAASzE,YAAYtF,QAAA,EAAU8B,OAAA,EAAQ;QACrC,IAAIoI,MAAA,GAASlK,QAAA,CAAS0C,SAAA,CAAUZ,OAAA,CAAOpM,KAAA,EAAO,IAAI;QAElDoM,OAAA,CAAOpM,KAAA,IAASoB,UAAA;QAEhB,OAAOoT,MAAA;MACR;MAED,SAASC,aAAarO,OAAA,EAAQgG,OAAA,EAAQ;QACpC,OAAOc,aAAA,CAAc0C,WAAA,CAAYxJ,OAAA,EAAQgG,OAAM,CAAC;MACjD;MAED,SAASsI,YAAYpK,QAAA,EAAUlE,OAAA,EAAQgG,OAAA,EAAQ5C,IAAA,EAAM;QACnD,IAAImL,WAAA,GAAcvI,OAAA,CAAOpM,KAAA;QACzB,IAAIuP,QAAA,GAAW,EAAE;QAEjB,OAAOnD,OAAA,CAAOpM,KAAA,GAAQ2U,WAAA,GAAcnL,IAAA,GAAO,GAAG;UAC5C,IAAIwI,IAAA,GAAOC,yBAAA,CAA0B7L,OAAA,EAAQgG,OAAM;UACnD,IAAIiG,SAAA,GAAYgB,UAAA,CAAW/I,QAAA,EAAU8B,OAAM;UAC3C,IAAIkG,OAAA,GAAUxC,UAAA,CAAWxF,QAAA,EAAU8B,OAAM;UACzCA,OAAA,CAAOpM,KAAA,IAAS;UAChB,IAAI4U,SAAA,GAAYvB,UAAA,CAAW/I,QAAA,EAAU8B,OAAM;UAC3C,IAAIyI,SAAA,GAAYxB,UAAA,CAAW/I,QAAA,EAAU8B,OAAM;UAE3CmD,QAAA,CAASzF,IAAA,CAAK;YACZkI,IAAA,EAAAA,IAAA;YACAK,SAAA,EAAAA,SAAA;YACAC,OAAA,EAAAA,OAAA;YACAsC,SAAA,EAAAA,SAAA;YACAC,SAAA,EAAAA;UACV,CAAS;QACF;QAEDzI,OAAA,CAAOpM,KAAA,IAAS;QAEhB,OAAOuP,QAAA;MACR;MAED,SAASuF,oBAAoBxK,QAAA,EAAU8B,OAAA,EAAQ;QAC7C,IAAI2I,IAAA,GAAOf,YAAA,CAAa1J,QAAA,EAAU8B,OAAM;QACxC,IAAI4I,IAAA,GAAOhB,YAAA,CAAa1J,QAAA,EAAU8B,OAAM;QACxC,IAAI6I,MAAA,GAASjB,YAAA,CAAa1J,QAAA,EAAU8B,OAAM;QAC1C,IAAI8I,MAAA,GAASlB,YAAA,CAAa1J,QAAA,EAAU8B,OAAM;QAC1C,IAAI+I,KAAA,GAAQnB,YAAA,CAAa1J,QAAA,EAAU8B,OAAM;QACzC,IAAIgJ,KAAA,GAAQpB,YAAA,CAAa1J,QAAA,EAAU8B,OAAM;QACzC,IAAIiJ,MAAA,GAASrB,YAAA,CAAa1J,QAAA,EAAU8B,OAAM;QAC1C,IAAIkJ,MAAA,GAAStB,YAAA,CAAa1J,QAAA,EAAU8B,OAAM;QAE1C,OAAO;UACL2I,IAAA,EAAAA,IAAA;UACAC,IAAA,EAAAA,IAAA;UACAC,MAAA,EAAAA,MAAA;UACAC,MAAA,EAAAA,MAAA;UACAC,KAAA,EAAAA,KAAA;UACAC,KAAA,EAAAA,KAAA;UACAC,MAAA,EAAAA,MAAA;UACAC,MAAA,EAAAA;QACD;MACF;MAED,SAASC,iBAAiBjL,QAAA,EAAU8B,OAAA,EAAQ;QAC1C,IAAIoJ,gBAAA,GAAmB,CACrB,kBACA,mBACA,oBACA,mBACA,mBACA,qBACA,mBACA,oBACA,oBACA,mBACD;QAED,IAAI3D,WAAA,GAAc/B,UAAA,CAAWxF,QAAA,EAAU8B,OAAM;QAE7C,OAAOoJ,gBAAA,CAAiB3D,WAAW;MACpC;MAED,SAAS4D,WAAWnL,QAAA,EAAU8B,OAAA,EAAQ;QACpC,IAAIsJ,IAAA,GAAOlN,WAAA,CAAY8B,QAAA,EAAU8B,OAAM;QACvC,IAAIuJ,IAAA,GAAOnN,WAAA,CAAY8B,QAAA,EAAU8B,OAAM;QACvC,IAAIwJ,IAAA,GAAOpN,WAAA,CAAY8B,QAAA,EAAU8B,OAAM;QACvC,IAAIyJ,IAAA,GAAOrN,WAAA,CAAY8B,QAAA,EAAU8B,OAAM;QAEvC,OAAO;UAAEsJ,IAAA,EAAAA,IAAA;UAAYC,IAAA,EAAAA,IAAA;UAAYC,IAAA,EAAAA,IAAA;UAAYC,IAAA,EAAAA;QAAY;MAC1D;MAED,SAASC,eAAexL,QAAA,EAAU8B,OAAA,EAAQ;QACxC,IAAI2J,UAAA,GAAa,CAAC,cAAc;QAEhC,IAAIC,SAAA,GAAYlG,UAAA,CAAWxF,QAAA,EAAU8B,OAAM;QAE3C,OAAO2J,UAAA,CAAWC,SAAS;MAC5B;MAED,SAASC,SAAS3L,QAAA,EAAU8B,OAAA,EAAQ;QAClC,IAAIW,CAAA,GAAIiH,YAAA,CAAa1J,QAAA,EAAU8B,OAAM;QACrC,IAAIU,CAAA,GAAIkH,YAAA,CAAa1J,QAAA,EAAU8B,OAAM;QAErC,OAAO,CAACW,CAAA,EAAGD,CAAC;MACb;MAED,SAASoJ,SAAS5L,QAAA,EAAU8B,OAAA,EAAQ;QAClC,IAAIW,CAAA,GAAIiH,YAAA,CAAa1J,QAAA,EAAU8B,OAAM;QACrC,IAAIU,CAAA,GAAIkH,YAAA,CAAa1J,QAAA,EAAU8B,OAAM;QACrC,IAAI+J,CAAA,GAAInC,YAAA,CAAa1J,QAAA,EAAU8B,OAAM;QAErC,OAAO,CAACW,CAAA,EAAGD,CAAA,EAAGqJ,CAAC;MAChB;MAED,SAASC,WAAW9L,QAAA,EAAUlE,OAAA,EAAQgG,OAAA,EAAQxM,IAAA,EAAM4J,IAAA,EAAM;QACxD,IAAI5J,IAAA,KAAS,YAAYA,IAAA,KAAS,kBAAkBA,IAAA,KAAS,cAAc;UACzE,OAAOuT,sBAAA,CAAuB/M,OAAA,EAAQgG,OAAA,EAAQ5C,IAAI;QAC1D,WAAiB5J,IAAA,KAAS,UAAU;UAC5B,OAAO8U,WAAA,CAAYpK,QAAA,EAAUlE,OAAA,EAAQgG,OAAA,EAAQ5C,IAAI;QACzD,WAAiB5J,IAAA,KAAS,kBAAkB;UACpC,OAAOkV,mBAAA,CAAoBxK,QAAA,EAAU8B,OAAM;QACnD,WAAiBxM,IAAA,KAAS,eAAe;UACjC,OAAO2V,gBAAA,CAAiBjL,QAAA,EAAU8B,OAAM;QAChD,WAAiBxM,IAAA,KAAS,SAAS;UAC3B,OAAO6V,UAAA,CAAWnL,QAAA,EAAU8B,OAAM;QAC1C,WAAiBxM,IAAA,KAAS,aAAa;UAC/B,OAAOkW,cAAA,CAAexL,QAAA,EAAU8B,OAAM;QAC9C,WAAiBxM,IAAA,KAAS,SAAS;UAC3B,OAAOoU,YAAA,CAAa1J,QAAA,EAAU8B,OAAM;QAC5C,WAAiBxM,IAAA,KAAS,OAAO;UACzB,OAAOqW,QAAA,CAAS3L,QAAA,EAAU8B,OAAM;QACxC,WAAiBxM,IAAA,KAAS,OAAO;UACzB,OAAOsW,QAAA,CAAS5L,QAAA,EAAU8B,OAAM;QACxC,WAAiBxM,IAAA,KAAS,OAAO;UACzB,OAAOyT,UAAA,CAAW/I,QAAA,EAAU8B,OAAM;QAC1C,WAAiBxM,IAAA,KAAS,YAAY;UAC9B,OAAOwT,aAAA,CAAc9I,QAAA,EAAU8B,OAAM;QAC7C,WAAiBxM,IAAA,KAAS,YAAY;UAC9B,OAAO0T,aAAA,CAAchJ,QAAA,EAAU8B,OAAM;QAC7C,WAAiBxM,IAAA,KAAS,WAAW;UAC7BwM,OAAA,CAAOpM,KAAA,IAASwJ,IAAA;UAChB,OAAO;QACf,OAAa;UACL4C,OAAA,CAAOpM,KAAA,IAASwJ,IAAA;UAChB,OAAO;QACR;MACF;MAED,SAAS6M,YAAY/L,QAAA,EAAUlE,OAAA,EAAQgG,OAAA,EAAQ;QAC7C,IAAMkK,UAAA,GAAY,CAAE;QAEpB,IAAIhM,QAAA,CAASoJ,SAAA,CAAU,GAAG,IAAI,KAAK,UAAU;UAE3C,MAAM;QACP;QAED4C,UAAA,CAAUtF,OAAA,GAAU1G,QAAA,CAASP,QAAA,CAAS,CAAC;QAEvC,IAAMwM,IAAA,GAAOjM,QAAA,CAASP,QAAA,CAAS,CAAC;QAEhCuM,UAAA,CAAUC,IAAA,GAAO;UACfC,UAAA,EAAY,CAAC,EAAED,IAAA,GAAO;UACtBE,QAAA,EAAU,CAAC,EAAEF,IAAA,GAAO;UACpBG,UAAA,EAAY,CAAC,EAAEH,IAAA,GAAO;UACtBI,SAAA,EAAW,CAAC,EAAEJ,IAAA,GAAO;QACtB;QAIDnK,OAAA,CAAOpM,KAAA,GAAQ;QAEf,IAAI4W,WAAA,GAAc;QAElB,OAAOA,WAAA,EAAa;UAClB,IAAIC,aAAA,GAAgB5E,yBAAA,CAA0B7L,OAAA,EAAQgG,OAAM;UAE5D,IAAIyK,aAAA,IAAiB,GAAG;YACtBD,WAAA,GAAc;UACxB,OAAe;YACL,IAAIE,aAAA,GAAgB7E,yBAAA,CAA0B7L,OAAA,EAAQgG,OAAM;YAC5D,IAAI2K,aAAA,GAAgBvO,WAAA,CAAY8B,QAAA,EAAU8B,OAAM;YAChD,IAAI4K,cAAA,GAAiBZ,UAAA,CAAW9L,QAAA,EAAUlE,OAAA,EAAQgG,OAAA,EAAQ0K,aAAA,EAAeC,aAAa;YAEtF,IAAIC,cAAA,KAAmB,QAAW;cAChCC,OAAA,CAAQC,IAAA,4DAAAC,MAAA,CAAiEL,aAAA,OAAkB;YACvG,OAAiB;cACLR,UAAA,CAAUO,aAAa,IAAIG,cAAA;YAC5B;UACF;QACF;QAED,KAAKT,IAAA,GAAO,CAAC,MAAS,GAAG;UAEvBU,OAAA,CAAQG,KAAA,CAAM,cAAcd,UAAS;UACrC,MAAM;QACP;QAED,OAAOA,UAAA;MACR;MAED,SAASe,aAAaf,UAAA,EAAWhM,QAAA,EAAUvH,WAAA,EAAYqJ,OAAA,EAAQkL,UAAA,EAAY;QACzE,IAAMC,WAAA,GAAAC,eAAA;UACJhO,IAAA,EAAM;UACNuF,MAAA,EAAQzE,QAAA;UACRqE,KAAA,EAAO5L,WAAA;UACP6L,MAAA,EAAQxC,OAAA;UACR7B,KAAA,EAAO+L,UAAA,CAAUmB,UAAA,CAAW7B,IAAA,GAAOU,UAAA,CAAUmB,UAAA,CAAW/B,IAAA,GAAO;UAC/DjL,MAAA,EAAQ6L,UAAA,CAAUmB,UAAA,CAAW5B,IAAA,GAAOS,UAAA,CAAUmB,UAAA,CAAW9B,IAAA,GAAO;UAChEpG,QAAA,EAAU+G,UAAA,CAAU/G,QAAA,CAASvG,MAAA;UAC7B0O,YAAA,EAAc;UACdhI,KAAA,EAAO;UACPiI,SAAA,EAAW;UACX/X,IAAA,EAAM0W,UAAA,CAAU/G,QAAA,CAAS,CAAC,EAAE8C,SAAA;UAC5BuF,UAAA,EAAY;UACZC,MAAA,EAAQ;UACRC,MAAA,EAAQ;QAAA,GACP7Y,aAAA,GAAgB,eAAe,UAAU,EAAG,KAC9C;QAED,QAAQqX,UAAA,CAAUzE,WAAA;UAChB,KAAK;YACH0F,WAAA,CAAW7H,KAAA,GAAQ;YACnB6H,WAAA,CAAWK,UAAA,GAAanJ,aAAA;YACxB;UAEF,KAAK;YACH8I,WAAA,CAAW7H,KAAA,GAAQ;YACnB6H,WAAA,CAAWK,UAAA,GAAa/I,aAAA;YACxB;UAEF,KAAK;YACH0I,WAAA,CAAW7H,KAAA,GAAQ;YACnB6H,WAAA,CAAWK,UAAA,GAAazI,aAAA;YACxB;UAEF,KAAK;YACHoI,WAAA,CAAW7H,KAAA,GAAQ;YACnB6H,WAAA,CAAWK,UAAA,GAAazI,aAAA;YACxB;UAEF,KAAK;YACHoI,WAAA,CAAW7H,KAAA,GAAQ;YACnB6H,WAAA,CAAWK,UAAA,GAAavI,aAAA;YACxB;UAEF,KAAK;YACHkI,WAAA,CAAW7H,KAAA,GAAQ;YACnB6H,WAAA,CAAWK,UAAA,GAAatH,aAAA;YACxB;UAEF,KAAK;YACHiH,WAAA,CAAW7H,KAAA,GAAQ;YACnB6H,WAAA,CAAWK,UAAA,GAAa9G,aAAA;YACxB;UAEF,KAAK;YACHyG,WAAA,CAAW7H,KAAA,GAAQ;YACnB6H,WAAA,CAAWK,UAAA,GAAa9G,aAAA;YACxB;UAEF;YACE,MAAM,sBAAsBwF,UAAA,CAAUzE,WAAA,GAAc;QACvD;QAED0F,WAAA,CAAWjI,iBAAA,GAAoBiI,WAAA,CAAW7H,KAAA;QAE1C,IAAI6H,WAAA,CAAW3X,IAAA,IAAQ,GAAG;UAExB,QAAQ0X,UAAA;YACN,KAAKS,SAAA;cACHR,WAAA,CAAWM,MAAA,GAASpD,YAAA;cACpB8C,WAAA,CAAWI,SAAA,GAAYvW,UAAA;cACvB;YAEF,KAAKvB,aAAA;cACH0X,WAAA,CAAWM,MAAA,GAASjI,WAAA;cACpB2H,WAAA,CAAWI,SAAA,GAAYvW,UAAA;cACvB;UACH;QACT,WAAiBmW,WAAA,CAAW3X,IAAA,IAAQ,GAAG;UAE/B,QAAQ0X,UAAA;YACN,KAAKS,SAAA;cACHR,WAAA,CAAWM,MAAA,GAAS7D,YAAA;cACpBuD,WAAA,CAAWI,SAAA,GAAYzW,YAAA;cACvB;YAEF,KAAKrB,aAAA;cACH0X,WAAA,CAAWM,MAAA,GAAS3D,aAAA;cACpBqD,WAAA,CAAWI,SAAA,GAAYzW,YAAA;UAC1B;QACT,OAAa;UACL,MAAM,4CAA4CqW,WAAA,CAAW3X,IAAA,GAAO,UAAU0W,UAAA,CAAUzE,WAAA,GAAc;QACvG;QAED0F,WAAA,CAAWS,UAAA,IAAc1B,UAAA,CAAUmB,UAAA,CAAW5B,IAAA,GAAO,KAAK0B,WAAA,CAAWjI,iBAAA;QAErE,SAASpN,CAAA,GAAI,GAAGA,CAAA,GAAIqV,WAAA,CAAWS,UAAA,EAAY9V,CAAA,IAAK+O,UAAA,CAAW3G,QAAA,EAAU8B,OAAM;QAK3EmL,WAAA,CAAWU,cAAA,GAAiBV,WAAA,CAAWhI,QAAA,IAAY,IAAI,IAAIgI,WAAA,CAAWhI,QAAA;QACtE,IAAM/F,IAAA,GAAO+N,WAAA,CAAWhN,KAAA,GAAQgN,WAAA,CAAW9M,MAAA,GAAS8M,WAAA,CAAWU,cAAA;QAE/D,QAAQX,UAAA;UACN,KAAKS,SAAA;YACHR,WAAA,CAAWW,SAAA,GAAY,IAAI1M,YAAA,CAAahC,IAAI;YAG5C,IAAI+N,WAAA,CAAWhI,QAAA,GAAWgI,WAAA,CAAWU,cAAA,EAAgBV,WAAA,CAAWW,SAAA,CAAUpM,IAAA,CAAK,GAAG,GAAGtC,IAAI;YAEzF;UAEF,KAAK3J,aAAA;YACH0X,WAAA,CAAWW,SAAA,GAAY,IAAIzM,WAAA,CAAYjC,IAAI;YAE3C,IAAI+N,WAAA,CAAWhI,QAAA,GAAWgI,WAAA,CAAWU,cAAA,EAAgBV,WAAA,CAAWW,SAAA,CAAUpM,IAAA,CAAK,OAAQ,GAAGtC,IAAI;YAE9F;UAEF;YACEyN,OAAA,CAAQG,KAAA,CAAM,uCAAuCE,UAAU;YAC/D;QACH;QAEDC,WAAA,CAAWG,YAAA,GAAeH,WAAA,CAAWhN,KAAA,GAAQgN,WAAA,CAAWI,SAAA,GAAYJ,WAAA,CAAWhI,QAAA;QAE/E,IAAIgI,WAAA,CAAWU,cAAA,IAAkB,GAAGV,WAAA,CAAWO,MAAA,GAASK,UAAA,MACnDZ,WAAA,CAAWO,MAAA,GAASM,SAAA;QAEzB,IAAInZ,aAAA,EAAesY,WAAA,CAAWc,UAAA,GAAa,mBACtCd,WAAA,CAAWe,QAAA,GAAW;QAE3B,OAAOf,WAAA;MACR;MAID,IAAMgB,cAAA,GAAiB,IAAI5O,QAAA,CAASzJ,MAAM;MAC1C,IAAMsY,UAAA,GAAa,IAAI1T,UAAA,CAAW5E,MAAM;MACxC,IAAM0O,MAAA,GAAS;QAAE5O,KAAA,EAAO;MAAG;MAG3B,IAAM4R,SAAA,GAAYyE,WAAA,CAAYkC,cAAA,EAAgBrY,MAAA,EAAQ0O,MAAM;MAG5D,IAAM6J,UAAA,GAAapB,YAAA,CAAazF,SAAA,EAAW2G,cAAA,EAAgBC,UAAA,EAAY5J,MAAA,EAAQ,KAAKhP,IAAI;MAExF,IAAM8Y,SAAA,GAAY;QAAE1Y,KAAA,EAAO;MAAG;MAC9B,IAAM2Y,cAAA,GAAiB;QAAEC,CAAA,EAAG;QAAGC,CAAA,EAAG;QAAGC,CAAA,EAAG;QAAGC,CAAA,EAAG;QAAGC,CAAA,EAAG;MAAG;MAEvD,SACMC,gBAAA,GAAmB,GACvBA,gBAAA,GAAmBR,UAAA,CAAWhO,MAAA,GAASgO,UAAA,CAAWnJ,iBAAA,EAClD2J,gBAAA,IACA;QACA,IAAMC,IAAA,GAAO1Q,WAAA,CAAY+P,cAAA,EAAgB3J,MAAM;QAC/C6J,UAAA,CAAWjP,IAAA,GAAOhB,WAAA,CAAY+P,cAAA,EAAgB3J,MAAM;QACpD6J,UAAA,CAAW/I,KAAA,GACTwJ,IAAA,GAAOT,UAAA,CAAWnJ,iBAAA,GAAoBmJ,UAAA,CAAWhO,MAAA,GAC7CgO,UAAA,CAAWhO,MAAA,GAASyO,IAAA,GACpBT,UAAA,CAAWnJ,iBAAA;QAEjB,IAAM6J,YAAA,GAAeV,UAAA,CAAWjP,IAAA,GAAOiP,UAAA,CAAW/I,KAAA,GAAQ+I,UAAA,CAAWf,YAAA;QACrE,IAAM3I,MAAA,GAASoK,YAAA,GAAeV,UAAA,CAAWb,UAAA,CAAWa,UAAU,IAAIhK,aAAA,CAAcgK,UAAU;QAE1F7J,MAAA,CAAO5O,KAAA,IAASyY,UAAA,CAAWjP,IAAA;QAE3B,SAAS4P,MAAA,GAAS,GAAGA,MAAA,GAASX,UAAA,CAAWnJ,iBAAA,EAAmB8J,MAAA,IAAU;UACpE,IAAMC,MAAA,GAASD,MAAA,GAASH,gBAAA,GAAmBR,UAAA,CAAWnJ,iBAAA;UACtD,IAAI+J,MAAA,IAAUZ,UAAA,CAAWhO,MAAA,EAAQ;UAEjC,SAAS6O,SAAA,GAAY,GAAGA,SAAA,GAAYb,UAAA,CAAWlJ,QAAA,EAAU+J,SAAA,IAAa;YACpE,IAAMC,IAAA,GAAOZ,cAAA,CAAe/G,SAAA,CAAUrC,QAAA,CAAS+J,SAAS,EAAEtH,IAAI;YAE9D,SAASjF,CAAA,GAAI,GAAGA,CAAA,GAAI0L,UAAA,CAAWlO,KAAA,EAAOwC,CAAA,IAAK;cACzC2L,SAAA,CAAU1Y,KAAA,IACPoZ,MAAA,IAAUX,UAAA,CAAWlJ,QAAA,GAAWkJ,UAAA,CAAWlO,KAAA,IAAS+O,SAAA,GAAYb,UAAA,CAAWlO,KAAA,GAAQwC,CAAA,IACpF0L,UAAA,CAAWd,SAAA;cACb,IAAM6B,QAAA,IACHf,UAAA,CAAWhO,MAAA,GAAS,IAAI4O,MAAA,KAAWZ,UAAA,CAAWlO,KAAA,GAAQkO,UAAA,CAAWR,cAAA,IAClElL,CAAA,GAAI0L,UAAA,CAAWR,cAAA,GACfsB,IAAA;cACFd,UAAA,CAAWP,SAAA,CAAUsB,QAAQ,IAAIf,UAAA,CAAWZ,MAAA,CAAO9I,MAAA,EAAQ2J,SAAS;YACrE;UACF;QACF;MACF;MAED,OAAAvY,IAAA;QACEsZ,MAAA,EAAQ7H,SAAA;QACRrH,KAAA,EAAOkO,UAAA,CAAWlO,KAAA;QAClBE,MAAA,EAAQgO,UAAA,CAAWhO,MAAA;QACnB9B,IAAA,EAAM8P,UAAA,CAAWP,SAAA;QACjBJ,MAAA,EAAQW,UAAA,CAAWX;MAAA,GAAAN,eAAA,CAAArX,IAAA,EAClBlB,aAAA,GAAgB,eAAe,UAAU,EAAGwZ,UAAA,CAAWxZ,aAAA,GAAgB,eAAe,UAAU,IAAAuY,eAAA,CAAArX,IAAA,UAC3F,KAAKP,IAAA,GAAAO,IAAA;IAEd;EAAA;IAAAJ,GAAA;IAAAC,KAAA,EAED,SAAA0Z,YAAY1Z,KAAA,EAAO;MACjB,KAAKJ,IAAA,GAAOI,KAAA;MACZ,OAAO;IACR;EAAA;IAAAD,GAAA;IAAAC,KAAA,EAED,SAAA2Z,KAAKC,GAAA,EAAKC,MAAA,EAAQC,UAAA,EAAYC,OAAA,EAAS;MACrC,SAASC,eAAeC,OAAA,EAASC,OAAA,EAAS;QACxC,IAAIjb,aAAA,EAAegb,OAAA,CAAQ5B,UAAA,GAAa6B,OAAA,CAAQ7B,UAAA,MAC3C4B,OAAA,CAAQ3B,QAAA,GAAW4B,OAAA,CAAQ5B,QAAA;QAChC2B,OAAA,CAAQE,SAAA,GAAYC,YAAA;QACpBH,OAAA,CAAQI,SAAA,GAAYD,YAAA;QACpBH,OAAA,CAAQK,eAAA,GAAkB;QAC1BL,OAAA,CAAQM,KAAA,GAAQ;QAEhB,IAAIV,MAAA,EAAQA,MAAA,CAAOI,OAAA,EAASC,OAAO;MACpC;MAED,OAAAM,IAAA,CAAAC,eAAA,CAAAtb,SAAA,CAAA0U,SAAA,iBAAAlU,IAAA,OAAkBia,GAAA,EAAKI,cAAA,EAAgBF,UAAA,EAAYC,OAAO;IAC3D;EAAA;EAAA,OAAA5a,SAAA;AAAA,EAtwDqBub,iBAAA"},"metadata":{},"sourceType":"module","externalDependencies":[]}