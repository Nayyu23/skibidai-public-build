{"ast":null,"code":"import _toConsumableArray from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _objectSpread from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _regeneratorRuntime from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _classCallCheck from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _asyncToGenerator from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = function __defNormalProp(obj, key, value) {\n  return key in obj ? __defProp(obj, key, {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: value\n  }) : obj[key] = value;\n};\nvar __publicField = function __publicField(obj, key, value) {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nimport { PropertyBinding, InterpolateLinear, Color, Vector3, CompressedTexture, Texture, MathUtils, RGBAFormat, DoubleSide, BufferAttribute, InterpolateDiscrete, Matrix4, Scene, PlaneGeometry, ShaderMaterial, Uniform, Mesh, PerspectiveCamera, WebGLRenderer, NearestFilter, NearestMipmapNearestFilter, NearestMipmapLinearFilter, LinearFilter, LinearMipmapNearestFilter, LinearMipmapLinearFilter, ClampToEdgeWrapping, RepeatWrapping, MirroredRepeatWrapping } from \"three\";\nimport { version } from \"../_polyfill/constants.js\";\nfunction readAsDataURL(_x) {\n  return _readAsDataURL.apply(this, arguments);\n}\nfunction _readAsDataURL() {\n  _readAsDataURL = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(blob) {\n    var buffer, data;\n    return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n      while (1) switch (_context2.prev = _context2.next) {\n        case 0:\n          _context2.next = 2;\n          return blob.arrayBuffer();\n        case 2:\n          buffer = _context2.sent;\n          data = btoa(String.fromCharCode.apply(String, _toConsumableArray(new Uint8Array(buffer))));\n          return _context2.abrupt(\"return\", \"data:\".concat(blob.type || \"\", \";base64,\").concat(data));\n        case 5:\n        case \"end\":\n          return _context2.stop();\n      }\n    }, _callee2);\n  }));\n  return _readAsDataURL.apply(this, arguments);\n}\nvar _renderer;\nvar fullscreenQuadGeometry;\nvar fullscreenQuadMaterial;\nvar fullscreenQuad;\nfunction decompress(texture) {\n  var maxTextureSize = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Infinity;\n  var renderer = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n  if (!fullscreenQuadGeometry) fullscreenQuadGeometry = new PlaneGeometry(2, 2, 1, 1);\n  if (!fullscreenQuadMaterial) fullscreenQuadMaterial = new ShaderMaterial({\n    uniforms: {\n      blitTexture: new Uniform(texture)\n    },\n    vertexShader: /* glsl */\"\\n        varying vec2 vUv;\\n        void main(){\\n            vUv = uv;\\n            gl_Position = vec4(position.xy * 1.0,0.,.999999);\\n        }\\n      \",\n    fragmentShader: /* glsl */\"\\n          uniform sampler2D blitTexture; \\n          varying vec2 vUv;\\n\\n          void main(){ \\n              gl_FragColor = vec4(vUv.xy, 0, 1);\\n              \\n              #ifdef IS_SRGB\\n              gl_FragColor = LinearTosRGB( texture2D( blitTexture, vUv) );\\n              #else\\n              gl_FragColor = texture2D( blitTexture, vUv);\\n              #endif\\n          }\\n      \"\n  });\n  fullscreenQuadMaterial.uniforms.blitTexture.value = texture;\n  fullscreenQuadMaterial.defines.IS_SRGB = \"colorSpace\" in texture ? texture.colorSpace === \"srgb\" : texture.encoding === 3001;\n  fullscreenQuadMaterial.needsUpdate = true;\n  if (!fullscreenQuad) {\n    fullscreenQuad = new Mesh(fullscreenQuadGeometry, fullscreenQuadMaterial);\n    fullscreenQuad.frustrumCulled = false;\n  }\n  var _camera = new PerspectiveCamera();\n  var _scene = new Scene();\n  _scene.add(fullscreenQuad);\n  if (!renderer) {\n    renderer = _renderer = new WebGLRenderer({\n      antialias: false\n    });\n  }\n  renderer.setSize(Math.min(texture.image.width, maxTextureSize), Math.min(texture.image.height, maxTextureSize));\n  renderer.clear();\n  renderer.render(_scene, _camera);\n  var readableTexture = new Texture(renderer.domElement);\n  readableTexture.minFilter = texture.minFilter;\n  readableTexture.magFilter = texture.magFilter;\n  readableTexture.wrapS = texture.wrapS;\n  readableTexture.wrapT = texture.wrapT;\n  readableTexture.name = texture.name;\n  if (_renderer) {\n    _renderer.dispose();\n    _renderer = null;\n  }\n  return readableTexture;\n}\nvar KHR_mesh_quantization_ExtraAttrTypes = {\n  POSITION: [\"byte\", \"byte normalized\", \"unsigned byte\", \"unsigned byte normalized\", \"short\", \"short normalized\", \"unsigned short\", \"unsigned short normalized\"],\n  NORMAL: [\"byte normalized\", \"short normalized\"],\n  TANGENT: [\"byte normalized\", \"short normalized\"],\n  TEXCOORD: [\"byte\", \"byte normalized\", \"unsigned byte\", \"short\", \"short normalized\", \"unsigned short\"]\n};\nvar GLTFExporter = /*#__PURE__*/function () {\n  function GLTFExporter() {\n    _classCallCheck(this, GLTFExporter);\n    this.pluginCallbacks = [];\n    this.register(function (writer) {\n      return new GLTFLightExtension(writer);\n    });\n    this.register(function (writer) {\n      return new GLTFMaterialsUnlitExtension(writer);\n    });\n    this.register(function (writer) {\n      return new GLTFMaterialsTransmissionExtension(writer);\n    });\n    this.register(function (writer) {\n      return new GLTFMaterialsVolumeExtension(writer);\n    });\n    this.register(function (writer) {\n      return new GLTFMaterialsIorExtension(writer);\n    });\n    this.register(function (writer) {\n      return new GLTFMaterialsSpecularExtension(writer);\n    });\n    this.register(function (writer) {\n      return new GLTFMaterialsClearcoatExtension(writer);\n    });\n    this.register(function (writer) {\n      return new GLTFMaterialsIridescenceExtension(writer);\n    });\n    this.register(function (writer) {\n      return new GLTFMaterialsSheenExtension(writer);\n    });\n    this.register(function (writer) {\n      return new GLTFMaterialsAnisotropyExtension(writer);\n    });\n    this.register(function (writer) {\n      return new GLTFMaterialsEmissiveStrengthExtension(writer);\n    });\n  }\n  _createClass(GLTFExporter, [{\n    key: \"register\",\n    value: function register(callback) {\n      if (this.pluginCallbacks.indexOf(callback) === -1) {\n        this.pluginCallbacks.push(callback);\n      }\n      return this;\n    }\n  }, {\n    key: \"unregister\",\n    value: function unregister(callback) {\n      if (this.pluginCallbacks.indexOf(callback) !== -1) {\n        this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(callback), 1);\n      }\n      return this;\n    }\n    /**\n     * Parse scenes and generate GLTF output\n     * @param  {Scene or [THREE.Scenes]} input   Scene or Array of THREE.Scenes\n     * @param  {Function} onDone  Callback on completed\n     * @param  {Function} onError  Callback on errors\n     * @param  {Object} options options\n     */\n  }, {\n    key: \"parse\",\n    value: function parse(input, onDone, onError, options) {\n      var writer = new GLTFWriter();\n      var plugins = [];\n      for (var i = 0, il = this.pluginCallbacks.length; i < il; i++) {\n        plugins.push(this.pluginCallbacks[i](writer));\n      }\n      writer.setPlugins(plugins);\n      writer.write(input, onDone, options).catch(onError);\n    }\n  }, {\n    key: \"parseAsync\",\n    value: function parseAsync(input, options) {\n      var scope = this;\n      return new Promise(function (resolve, reject) {\n        scope.parse(input, resolve, reject, options);\n      });\n    }\n  }]);\n  return GLTFExporter;\n}();\n/**\n * Static utility functions\n */\n__publicField(GLTFExporter, \"Utils\", {\n  insertKeyframe: function insertKeyframe(track, time) {\n    var tolerance = 1e-3;\n    var valueSize = track.getValueSize();\n    var times = new track.TimeBufferType(track.times.length + 1);\n    var values = new track.ValueBufferType(track.values.length + valueSize);\n    var interpolant = track.createInterpolant(new track.ValueBufferType(valueSize));\n    var index;\n    if (track.times.length === 0) {\n      times[0] = time;\n      for (var i = 0; i < valueSize; i++) {\n        values[i] = 0;\n      }\n      index = 0;\n    } else if (time < track.times[0]) {\n      if (Math.abs(track.times[0] - time) < tolerance) return 0;\n      times[0] = time;\n      times.set(track.times, 1);\n      values.set(interpolant.evaluate(time), 0);\n      values.set(track.values, valueSize);\n      index = 0;\n    } else if (time > track.times[track.times.length - 1]) {\n      if (Math.abs(track.times[track.times.length - 1] - time) < tolerance) {\n        return track.times.length - 1;\n      }\n      times[times.length - 1] = time;\n      times.set(track.times, 0);\n      values.set(track.values, 0);\n      values.set(interpolant.evaluate(time), track.values.length);\n      index = times.length - 1;\n    } else {\n      for (var _i = 0; _i < track.times.length; _i++) {\n        if (Math.abs(track.times[_i] - time) < tolerance) return _i;\n        if (track.times[_i] < time && track.times[_i + 1] > time) {\n          times.set(track.times.slice(0, _i + 1), 0);\n          times[_i + 1] = time;\n          times.set(track.times.slice(_i + 1), _i + 2);\n          values.set(track.values.slice(0, (_i + 1) * valueSize), 0);\n          values.set(interpolant.evaluate(time), (_i + 1) * valueSize);\n          values.set(track.values.slice((_i + 1) * valueSize), (_i + 2) * valueSize);\n          index = _i + 1;\n          break;\n        }\n      }\n    }\n    track.times = times;\n    track.values = values;\n    return index;\n  },\n  mergeMorphTargetTracks: function mergeMorphTargetTracks(clip, root) {\n    var tracks = [];\n    var mergedTracks = {};\n    var sourceTracks = clip.tracks;\n    for (var i = 0; i < sourceTracks.length; ++i) {\n      var sourceTrack = sourceTracks[i];\n      var sourceTrackBinding = PropertyBinding.parseTrackName(sourceTrack.name);\n      var sourceTrackNode = PropertyBinding.findNode(root, sourceTrackBinding.nodeName);\n      if (sourceTrackBinding.propertyName !== \"morphTargetInfluences\" || sourceTrackBinding.propertyIndex === void 0) {\n        tracks.push(sourceTrack);\n        continue;\n      }\n      if (sourceTrack.createInterpolant !== sourceTrack.InterpolantFactoryMethodDiscrete && sourceTrack.createInterpolant !== sourceTrack.InterpolantFactoryMethodLinear) {\n        if (sourceTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline) {\n          throw new Error(\"THREE.GLTFExporter: Cannot merge tracks with glTF CUBICSPLINE interpolation.\");\n        }\n        console.warn(\"THREE.GLTFExporter: Morph target interpolation mode not yet supported. Using LINEAR instead.\");\n        sourceTrack = sourceTrack.clone();\n        sourceTrack.setInterpolation(InterpolateLinear);\n      }\n      var targetCount = sourceTrackNode.morphTargetInfluences.length;\n      var targetIndex = sourceTrackNode.morphTargetDictionary[sourceTrackBinding.propertyIndex];\n      if (targetIndex === void 0) {\n        throw new Error(\"THREE.GLTFExporter: Morph target name not found: \" + sourceTrackBinding.propertyIndex);\n      }\n      var mergedTrack = void 0;\n      if (mergedTracks[sourceTrackNode.uuid] === void 0) {\n        mergedTrack = sourceTrack.clone();\n        var values = new mergedTrack.ValueBufferType(targetCount * mergedTrack.times.length);\n        for (var j = 0; j < mergedTrack.times.length; j++) {\n          values[j * targetCount + targetIndex] = mergedTrack.values[j];\n        }\n        mergedTrack.name = (sourceTrackBinding.nodeName || \"\") + \".morphTargetInfluences\";\n        mergedTrack.values = values;\n        mergedTracks[sourceTrackNode.uuid] = mergedTrack;\n        tracks.push(mergedTrack);\n        continue;\n      }\n      var sourceInterpolant = sourceTrack.createInterpolant(new sourceTrack.ValueBufferType(1));\n      mergedTrack = mergedTracks[sourceTrackNode.uuid];\n      for (var _j = 0; _j < mergedTrack.times.length; _j++) {\n        mergedTrack.values[_j * targetCount + targetIndex] = sourceInterpolant.evaluate(mergedTrack.times[_j]);\n      }\n      for (var _j2 = 0; _j2 < sourceTrack.times.length; _j2++) {\n        var keyframeIndex = this.insertKeyframe(mergedTrack, sourceTrack.times[_j2]);\n        mergedTrack.values[keyframeIndex * targetCount + targetIndex] = sourceTrack.values[_j2];\n      }\n    }\n    clip.tracks = tracks;\n    return clip;\n  }\n});\nvar WEBGL_CONSTANTS = {\n  POINTS: 0,\n  LINES: 1,\n  LINE_LOOP: 2,\n  LINE_STRIP: 3,\n  TRIANGLES: 4,\n  TRIANGLE_STRIP: 5,\n  TRIANGLE_FAN: 6,\n  BYTE: 5120,\n  UNSIGNED_BYTE: 5121,\n  SHORT: 5122,\n  UNSIGNED_SHORT: 5123,\n  INT: 5124,\n  UNSIGNED_INT: 5125,\n  FLOAT: 5126,\n  ARRAY_BUFFER: 34962,\n  ELEMENT_ARRAY_BUFFER: 34963,\n  NEAREST: 9728,\n  LINEAR: 9729,\n  NEAREST_MIPMAP_NEAREST: 9984,\n  LINEAR_MIPMAP_NEAREST: 9985,\n  NEAREST_MIPMAP_LINEAR: 9986,\n  LINEAR_MIPMAP_LINEAR: 9987,\n  CLAMP_TO_EDGE: 33071,\n  MIRRORED_REPEAT: 33648,\n  REPEAT: 10497\n};\nvar KHR_MESH_QUANTIZATION = \"KHR_mesh_quantization\";\nvar THREE_TO_WEBGL = {};\nTHREE_TO_WEBGL[NearestFilter] = WEBGL_CONSTANTS.NEAREST;\nTHREE_TO_WEBGL[NearestMipmapNearestFilter] = WEBGL_CONSTANTS.NEAREST_MIPMAP_NEAREST;\nTHREE_TO_WEBGL[NearestMipmapLinearFilter] = WEBGL_CONSTANTS.NEAREST_MIPMAP_LINEAR;\nTHREE_TO_WEBGL[LinearFilter] = WEBGL_CONSTANTS.LINEAR;\nTHREE_TO_WEBGL[LinearMipmapNearestFilter] = WEBGL_CONSTANTS.LINEAR_MIPMAP_NEAREST;\nTHREE_TO_WEBGL[LinearMipmapLinearFilter] = WEBGL_CONSTANTS.LINEAR_MIPMAP_LINEAR;\nTHREE_TO_WEBGL[ClampToEdgeWrapping] = WEBGL_CONSTANTS.CLAMP_TO_EDGE;\nTHREE_TO_WEBGL[RepeatWrapping] = WEBGL_CONSTANTS.REPEAT;\nTHREE_TO_WEBGL[MirroredRepeatWrapping] = WEBGL_CONSTANTS.MIRRORED_REPEAT;\nvar PATH_PROPERTIES = {\n  scale: \"scale\",\n  position: \"translation\",\n  quaternion: \"rotation\",\n  morphTargetInfluences: \"weights\"\n};\nvar DEFAULT_SPECULAR_COLOR = new Color();\nvar GLB_HEADER_BYTES = 12;\nvar GLB_HEADER_MAGIC = 1179937895;\nvar GLB_VERSION = 2;\nvar GLB_CHUNK_PREFIX_BYTES = 8;\nvar GLB_CHUNK_TYPE_JSON = 1313821514;\nvar GLB_CHUNK_TYPE_BIN = 5130562;\nfunction equalArray(array1, array2) {\n  return array1.length === array2.length && array1.every(function (element, index) {\n    return element === array2[index];\n  });\n}\nfunction stringToArrayBuffer(text) {\n  return new TextEncoder().encode(text).buffer;\n}\nfunction isIdentityMatrix(matrix) {\n  return equalArray(matrix.elements, [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);\n}\nfunction getMinMax(attribute, start, count) {\n  var output = {\n    min: new Array(attribute.itemSize).fill(Number.POSITIVE_INFINITY),\n    max: new Array(attribute.itemSize).fill(Number.NEGATIVE_INFINITY)\n  };\n  for (var i = start; i < start + count; i++) {\n    for (var a = 0; a < attribute.itemSize; a++) {\n      var value = void 0;\n      if (attribute.itemSize > 4) {\n        value = attribute.array[i * attribute.itemSize + a];\n      } else {\n        if (a === 0) value = attribute.getX(i);else if (a === 1) value = attribute.getY(i);else if (a === 2) value = attribute.getZ(i);else if (a === 3) value = attribute.getW(i);\n        if (attribute.normalized === true) {\n          value = MathUtils.normalize(value, attribute.array);\n        }\n      }\n      output.min[a] = Math.min(output.min[a], value);\n      output.max[a] = Math.max(output.max[a], value);\n    }\n  }\n  return output;\n}\nfunction getPaddedBufferSize(bufferSize) {\n  return Math.ceil(bufferSize / 4) * 4;\n}\nfunction getPaddedArrayBuffer(arrayBuffer) {\n  var paddingByte = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  var paddedLength = getPaddedBufferSize(arrayBuffer.byteLength);\n  if (paddedLength !== arrayBuffer.byteLength) {\n    var array = new Uint8Array(paddedLength);\n    array.set(new Uint8Array(arrayBuffer));\n    if (paddingByte !== 0) {\n      for (var i = arrayBuffer.byteLength; i < paddedLength; i++) {\n        array[i] = paddingByte;\n      }\n    }\n    return array.buffer;\n  }\n  return arrayBuffer;\n}\nfunction getCanvas() {\n  if (typeof document === \"undefined\" && typeof OffscreenCanvas !== \"undefined\") {\n    return new OffscreenCanvas(1, 1);\n  }\n  return document.createElement(\"canvas\");\n}\nfunction getToBlobPromise(canvas, mimeType) {\n  if (canvas.toBlob !== void 0) {\n    return new Promise(function (resolve) {\n      return canvas.toBlob(resolve, mimeType);\n    });\n  }\n  var quality;\n  if (mimeType === \"image/jpeg\") {\n    quality = 0.92;\n  } else if (mimeType === \"image/webp\") {\n    quality = 0.8;\n  }\n  return canvas.convertToBlob({\n    type: mimeType,\n    quality: quality\n  });\n}\nvar GLTFWriter = /*#__PURE__*/function () {\n  function GLTFWriter() {\n    _classCallCheck(this, GLTFWriter);\n    this.plugins = [];\n    this.options = {};\n    this.pending = [];\n    this.buffers = [];\n    this.byteOffset = 0;\n    this.buffers = [];\n    this.nodeMap = /* @__PURE__ */new Map();\n    this.skins = [];\n    this.extensionsUsed = {};\n    this.extensionsRequired = {};\n    this.uids = /* @__PURE__ */new Map();\n    this.uid = 0;\n    this.json = {\n      asset: {\n        version: \"2.0\",\n        generator: \"THREE.GLTFExporter\"\n      }\n    };\n    this.cache = {\n      meshes: /* @__PURE__ */new Map(),\n      attributes: /* @__PURE__ */new Map(),\n      attributesNormalized: /* @__PURE__ */new Map(),\n      materials: /* @__PURE__ */new Map(),\n      textures: /* @__PURE__ */new Map(),\n      images: /* @__PURE__ */new Map()\n    };\n  }\n  _createClass(GLTFWriter, [{\n    key: \"setPlugins\",\n    value: function setPlugins(plugins) {\n      this.plugins = plugins;\n    }\n    /**\n     * Parse scenes and generate GLTF output\n     * @param  {Scene or [THREE.Scenes]} input   Scene or Array of THREE.Scenes\n     * @param  {Function} onDone  Callback on completed\n     * @param  {Object} options options\n     */\n  }, {\n    key: \"write\",\n    value: function () {\n      var _write = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(input, onDone) {\n        var options,\n          writer,\n          buffers,\n          json,\n          extensionsUsed,\n          extensionsRequired,\n          blob,\n          extensionsUsedList,\n          extensionsRequiredList,\n          _args = arguments;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              options = _args.length > 2 && _args[2] !== undefined ? _args[2] : {};\n              this.options = Object.assign({\n                // default options\n                binary: false,\n                trs: false,\n                onlyVisible: true,\n                maxTextureSize: Infinity,\n                animations: [],\n                includeCustomExtensions: false\n              }, options);\n              if (this.options.animations.length > 0) {\n                this.options.trs = true;\n              }\n              this.processInput(input);\n              _context.next = 6;\n              return Promise.all(this.pending);\n            case 6:\n              writer = this;\n              buffers = writer.buffers;\n              json = writer.json;\n              options = writer.options;\n              extensionsUsed = writer.extensionsUsed;\n              extensionsRequired = writer.extensionsRequired;\n              blob = new Blob(buffers, {\n                type: \"application/octet-stream\"\n              });\n              extensionsUsedList = Object.keys(extensionsUsed);\n              extensionsRequiredList = Object.keys(extensionsRequired);\n              if (extensionsUsedList.length > 0) json.extensionsUsed = extensionsUsedList;\n              if (extensionsRequiredList.length > 0) json.extensionsRequired = extensionsRequiredList;\n              if (json.buffers && json.buffers.length > 0) json.buffers[0].byteLength = blob.size;\n              if (options.binary === true) {\n                blob.arrayBuffer().then(function (result) {\n                  var binaryChunk = getPaddedArrayBuffer(result);\n                  var binaryChunkPrefix = new DataView(new ArrayBuffer(GLB_CHUNK_PREFIX_BYTES));\n                  binaryChunkPrefix.setUint32(0, binaryChunk.byteLength, true);\n                  binaryChunkPrefix.setUint32(4, GLB_CHUNK_TYPE_BIN, true);\n                  var jsonChunk = getPaddedArrayBuffer(stringToArrayBuffer(JSON.stringify(json)), 32);\n                  var jsonChunkPrefix = new DataView(new ArrayBuffer(GLB_CHUNK_PREFIX_BYTES));\n                  jsonChunkPrefix.setUint32(0, jsonChunk.byteLength, true);\n                  jsonChunkPrefix.setUint32(4, GLB_CHUNK_TYPE_JSON, true);\n                  var header = new ArrayBuffer(GLB_HEADER_BYTES);\n                  var headerView = new DataView(header);\n                  headerView.setUint32(0, GLB_HEADER_MAGIC, true);\n                  headerView.setUint32(4, GLB_VERSION, true);\n                  var totalByteLength = GLB_HEADER_BYTES + jsonChunkPrefix.byteLength + jsonChunk.byteLength + binaryChunkPrefix.byteLength + binaryChunk.byteLength;\n                  headerView.setUint32(8, totalByteLength, true);\n                  var glbBlob = new Blob([header, jsonChunkPrefix, jsonChunk, binaryChunkPrefix, binaryChunk], {\n                    type: \"application/octet-stream\"\n                  });\n                  glbBlob.arrayBuffer().then(onDone);\n                });\n              } else {\n                if (json.buffers && json.buffers.length > 0) {\n                  readAsDataURL(blob).then(function (uri) {\n                    json.buffers[0].uri = uri;\n                    onDone(json);\n                  });\n                } else {\n                  onDone(json);\n                }\n              }\n            case 19:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee, this);\n      }));\n      function write(_x2, _x3) {\n        return _write.apply(this, arguments);\n      }\n      return write;\n    }()\n    /**\n     * Serializes a userData.\n     *\n     * @param {THREE.Object3D|THREE.Material} object\n     * @param {Object} objectDef\n     */\n  }, {\n    key: \"serializeUserData\",\n    value: function serializeUserData(object, objectDef) {\n      if (Object.keys(object.userData).length === 0) return;\n      var options = this.options;\n      var extensionsUsed = this.extensionsUsed;\n      try {\n        var json = JSON.parse(JSON.stringify(object.userData));\n        if (options.includeCustomExtensions && json.gltfExtensions) {\n          if (objectDef.extensions === void 0) objectDef.extensions = {};\n          for (var extensionName in json.gltfExtensions) {\n            objectDef.extensions[extensionName] = json.gltfExtensions[extensionName];\n            extensionsUsed[extensionName] = true;\n          }\n          delete json.gltfExtensions;\n        }\n        if (Object.keys(json).length > 0) objectDef.extras = json;\n      } catch (error) {\n        console.warn(\"THREE.GLTFExporter: userData of '\" + object.name + \"' won't be serialized because of JSON.stringify error - \" + error.message);\n      }\n    }\n    /**\n     * Returns ids for buffer attributes.\n     * @param  {Object} object\n     * @return {Integer}\n     */\n  }, {\n    key: \"getUID\",\n    value: function getUID(attribute) {\n      var isRelativeCopy = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      if (this.uids.has(attribute) === false) {\n        var uids2 = /* @__PURE__ */new Map();\n        uids2.set(true, this.uid++);\n        uids2.set(false, this.uid++);\n        this.uids.set(attribute, uids2);\n      }\n      var uids = this.uids.get(attribute);\n      return uids.get(isRelativeCopy);\n    }\n    /**\n     * Checks if normal attribute values are normalized.\n     *\n     * @param {BufferAttribute} normal\n     * @returns {Boolean}\n     */\n  }, {\n    key: \"isNormalizedNormalAttribute\",\n    value: function isNormalizedNormalAttribute(normal) {\n      var cache = this.cache;\n      if (cache.attributesNormalized.has(normal)) return false;\n      var v = new Vector3();\n      for (var i = 0, il = normal.count; i < il; i++) {\n        if (Math.abs(v.fromBufferAttribute(normal, i).length() - 1) > 5e-4) return false;\n      }\n      return true;\n    }\n    /**\n     * Creates normalized normal buffer attribute.\n     *\n     * @param {BufferAttribute} normal\n     * @returns {BufferAttribute}\n     *\n     */\n  }, {\n    key: \"createNormalizedNormalAttribute\",\n    value: function createNormalizedNormalAttribute(normal) {\n      var cache = this.cache;\n      if (cache.attributesNormalized.has(normal)) return cache.attributesNormalized.get(normal);\n      var attribute = normal.clone();\n      var v = new Vector3();\n      for (var i = 0, il = attribute.count; i < il; i++) {\n        v.fromBufferAttribute(attribute, i);\n        if (v.x === 0 && v.y === 0 && v.z === 0) {\n          v.setX(1);\n        } else {\n          v.normalize();\n        }\n        attribute.setXYZ(i, v.x, v.y, v.z);\n      }\n      cache.attributesNormalized.set(normal, attribute);\n      return attribute;\n    }\n    /**\n     * Applies a texture transform, if present, to the map definition. Requires\n     * the KHR_texture_transform extension.\n     *\n     * @param {Object} mapDef\n     * @param {THREE.Texture} texture\n     */\n  }, {\n    key: \"applyTextureTransform\",\n    value: function applyTextureTransform(mapDef, texture) {\n      var didTransform = false;\n      var transformDef = {};\n      if (texture.offset.x !== 0 || texture.offset.y !== 0) {\n        transformDef.offset = texture.offset.toArray();\n        didTransform = true;\n      }\n      if (texture.rotation !== 0) {\n        transformDef.rotation = texture.rotation;\n        didTransform = true;\n      }\n      if (texture.repeat.x !== 1 || texture.repeat.y !== 1) {\n        transformDef.scale = texture.repeat.toArray();\n        didTransform = true;\n      }\n      if (didTransform) {\n        mapDef.extensions = mapDef.extensions || {};\n        mapDef.extensions[\"KHR_texture_transform\"] = transformDef;\n        this.extensionsUsed[\"KHR_texture_transform\"] = true;\n      }\n    }\n  }, {\n    key: \"buildMetalRoughTexture\",\n    value: function buildMetalRoughTexture(metalnessMap, roughnessMap) {\n      if (metalnessMap === roughnessMap) return metalnessMap;\n      function getEncodingConversion(map) {\n        if (\"colorSpace\" in map ? map.colorSpace === \"srgb\" : map.encoding === 3001) {\n          return function SRGBToLinear(c) {\n            return c < 0.04045 ? c * 0.0773993808 : Math.pow(c * 0.9478672986 + 0.0521327014, 2.4);\n          };\n        }\n        return function LinearToLinear(c) {\n          return c;\n        };\n      }\n      console.warn(\"THREE.GLTFExporter: Merged metalnessMap and roughnessMap textures.\");\n      if (metalnessMap instanceof CompressedTexture) {\n        metalnessMap = decompress(metalnessMap);\n      }\n      if (roughnessMap instanceof CompressedTexture) {\n        roughnessMap = decompress(roughnessMap);\n      }\n      var metalness = metalnessMap ? metalnessMap.image : null;\n      var roughness = roughnessMap ? roughnessMap.image : null;\n      var width = Math.max(metalness ? metalness.width : 0, roughness ? roughness.width : 0);\n      var height = Math.max(metalness ? metalness.height : 0, roughness ? roughness.height : 0);\n      var canvas = getCanvas();\n      canvas.width = width;\n      canvas.height = height;\n      var context = canvas.getContext(\"2d\");\n      context.fillStyle = \"#00ffff\";\n      context.fillRect(0, 0, width, height);\n      var composite = context.getImageData(0, 0, width, height);\n      if (metalness) {\n        context.drawImage(metalness, 0, 0, width, height);\n        var convert = getEncodingConversion(metalnessMap);\n        var data = context.getImageData(0, 0, width, height).data;\n        for (var i = 2; i < data.length; i += 4) {\n          composite.data[i] = convert(data[i] / 256) * 256;\n        }\n      }\n      if (roughness) {\n        context.drawImage(roughness, 0, 0, width, height);\n        var _convert = getEncodingConversion(roughnessMap);\n        var _data = context.getImageData(0, 0, width, height).data;\n        for (var _i2 = 1; _i2 < _data.length; _i2 += 4) {\n          composite.data[_i2] = _convert(_data[_i2] / 256) * 256;\n        }\n      }\n      context.putImageData(composite, 0, 0);\n      var reference = metalnessMap || roughnessMap;\n      var texture = reference.clone();\n      texture.source = new Texture(canvas).source;\n      if (\"colorSpace\" in texture) texture.colorSpace = \"\";else texture.encoding = 3e3;\n      texture.channel = (metalnessMap || roughnessMap).channel;\n      if (metalnessMap && roughnessMap && metalnessMap.channel !== roughnessMap.channel) {\n        console.warn(\"THREE.GLTFExporter: UV channels for metalnessMap and roughnessMap textures must match.\");\n      }\n      return texture;\n    }\n    /**\n     * Process a buffer to append to the default one.\n     * @param  {ArrayBuffer} buffer\n     * @return {Integer}\n     */\n  }, {\n    key: \"processBuffer\",\n    value: function processBuffer(buffer) {\n      var json = this.json;\n      var buffers = this.buffers;\n      if (!json.buffers) json.buffers = [{\n        byteLength: 0\n      }];\n      buffers.push(buffer);\n      return 0;\n    }\n    /**\n     * Process and generate a BufferView\n     * @param  {BufferAttribute} attribute\n     * @param  {number} componentType\n     * @param  {number} start\n     * @param  {number} count\n     * @param  {number} target (Optional) Target usage of the BufferView\n     * @return {Object}\n     */\n  }, {\n    key: \"processBufferView\",\n    value: function processBufferView(attribute, componentType, start, count, target) {\n      var json = this.json;\n      if (!json.bufferViews) json.bufferViews = [];\n      var componentSize;\n      switch (componentType) {\n        case WEBGL_CONSTANTS.BYTE:\n        case WEBGL_CONSTANTS.UNSIGNED_BYTE:\n          componentSize = 1;\n          break;\n        case WEBGL_CONSTANTS.SHORT:\n        case WEBGL_CONSTANTS.UNSIGNED_SHORT:\n          componentSize = 2;\n          break;\n        default:\n          componentSize = 4;\n      }\n      var byteLength = getPaddedBufferSize(count * attribute.itemSize * componentSize);\n      var dataView = new DataView(new ArrayBuffer(byteLength));\n      var offset = 0;\n      for (var i = start; i < start + count; i++) {\n        for (var a = 0; a < attribute.itemSize; a++) {\n          var value = void 0;\n          if (attribute.itemSize > 4) {\n            value = attribute.array[i * attribute.itemSize + a];\n          } else {\n            if (a === 0) value = attribute.getX(i);else if (a === 1) value = attribute.getY(i);else if (a === 2) value = attribute.getZ(i);else if (a === 3) value = attribute.getW(i);\n            if (attribute.normalized === true) {\n              value = MathUtils.normalize(value, attribute.array);\n            }\n          }\n          if (componentType === WEBGL_CONSTANTS.FLOAT) {\n            dataView.setFloat32(offset, value, true);\n          } else if (componentType === WEBGL_CONSTANTS.INT) {\n            dataView.setInt32(offset, value, true);\n          } else if (componentType === WEBGL_CONSTANTS.UNSIGNED_INT) {\n            dataView.setUint32(offset, value, true);\n          } else if (componentType === WEBGL_CONSTANTS.SHORT) {\n            dataView.setInt16(offset, value, true);\n          } else if (componentType === WEBGL_CONSTANTS.UNSIGNED_SHORT) {\n            dataView.setUint16(offset, value, true);\n          } else if (componentType === WEBGL_CONSTANTS.BYTE) {\n            dataView.setInt8(offset, value);\n          } else if (componentType === WEBGL_CONSTANTS.UNSIGNED_BYTE) {\n            dataView.setUint8(offset, value);\n          }\n          offset += componentSize;\n        }\n      }\n      var bufferViewDef = {\n        buffer: this.processBuffer(dataView.buffer),\n        byteOffset: this.byteOffset,\n        byteLength: byteLength\n      };\n      if (target !== void 0) bufferViewDef.target = target;\n      if (target === WEBGL_CONSTANTS.ARRAY_BUFFER) {\n        bufferViewDef.byteStride = attribute.itemSize * componentSize;\n      }\n      this.byteOffset += byteLength;\n      json.bufferViews.push(bufferViewDef);\n      var output = {\n        id: json.bufferViews.length - 1,\n        byteLength: 0\n      };\n      return output;\n    }\n    /**\n     * Process and generate a BufferView from an image Blob.\n     * @param {Blob} blob\n     * @return {Promise<Integer>}\n     */\n  }, {\n    key: \"processBufferViewImage\",\n    value: function processBufferViewImage(blob) {\n      var writer = this;\n      var json = writer.json;\n      if (!json.bufferViews) json.bufferViews = [];\n      return blob.arrayBuffer().then(function (result) {\n        var buffer = getPaddedArrayBuffer(result);\n        var bufferViewDef = {\n          buffer: writer.processBuffer(buffer),\n          byteOffset: writer.byteOffset,\n          byteLength: buffer.byteLength\n        };\n        writer.byteOffset += buffer.byteLength;\n        return json.bufferViews.push(bufferViewDef) - 1;\n      });\n    }\n    /**\n     * Process attribute to generate an accessor\n     * @param  {BufferAttribute} attribute Attribute to process\n     * @param  {THREE.BufferGeometry} geometry (Optional) Geometry used for truncated draw range\n     * @param  {Integer} start (Optional)\n     * @param  {Integer} count (Optional)\n     * @return {Integer|null} Index of the processed accessor on the \"accessors\" array\n     */\n  }, {\n    key: \"processAccessor\",\n    value: function processAccessor(attribute, geometry, start, count) {\n      var json = this.json;\n      var types = {\n        1: \"SCALAR\",\n        2: \"VEC2\",\n        3: \"VEC3\",\n        4: \"VEC4\",\n        9: \"MAT3\",\n        16: \"MAT4\"\n      };\n      var componentType;\n      if (attribute.array.constructor === Float32Array) {\n        componentType = WEBGL_CONSTANTS.FLOAT;\n      } else if (attribute.array.constructor === Int32Array) {\n        componentType = WEBGL_CONSTANTS.INT;\n      } else if (attribute.array.constructor === Uint32Array) {\n        componentType = WEBGL_CONSTANTS.UNSIGNED_INT;\n      } else if (attribute.array.constructor === Int16Array) {\n        componentType = WEBGL_CONSTANTS.SHORT;\n      } else if (attribute.array.constructor === Uint16Array) {\n        componentType = WEBGL_CONSTANTS.UNSIGNED_SHORT;\n      } else if (attribute.array.constructor === Int8Array) {\n        componentType = WEBGL_CONSTANTS.BYTE;\n      } else if (attribute.array.constructor === Uint8Array) {\n        componentType = WEBGL_CONSTANTS.UNSIGNED_BYTE;\n      } else {\n        throw new Error(\"THREE.GLTFExporter: Unsupported bufferAttribute component type: \" + attribute.array.constructor.name);\n      }\n      if (start === void 0) start = 0;\n      if (count === void 0) count = attribute.count;\n      if (count === 0) return null;\n      var minMax = getMinMax(attribute, start, count);\n      var bufferViewTarget;\n      if (geometry !== void 0) {\n        bufferViewTarget = attribute === geometry.index ? WEBGL_CONSTANTS.ELEMENT_ARRAY_BUFFER : WEBGL_CONSTANTS.ARRAY_BUFFER;\n      }\n      var bufferView = this.processBufferView(attribute, componentType, start, count, bufferViewTarget);\n      var accessorDef = {\n        bufferView: bufferView.id,\n        byteOffset: bufferView.byteOffset,\n        componentType: componentType,\n        count: count,\n        max: minMax.max,\n        min: minMax.min,\n        type: types[attribute.itemSize]\n      };\n      if (attribute.normalized === true) accessorDef.normalized = true;\n      if (!json.accessors) json.accessors = [];\n      return json.accessors.push(accessorDef) - 1;\n    }\n    /**\n     * Process image\n     * @param  {Image} image to process\n     * @param  {Integer} format of the image (RGBAFormat)\n     * @param  {Boolean} flipY before writing out the image\n     * @param  {String} mimeType export format\n     * @return {Integer}     Index of the processed texture in the \"images\" array\n     */\n  }, {\n    key: \"processImage\",\n    value: function processImage(image, format, flipY) {\n      var mimeType = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : \"image/png\";\n      if (image !== null) {\n        var writer = this;\n        var cache = writer.cache;\n        var json = writer.json;\n        var options = writer.options;\n        var pending = writer.pending;\n        if (!cache.images.has(image)) cache.images.set(image, {});\n        var cachedImages = cache.images.get(image);\n        var key = mimeType + \":flipY/\" + flipY.toString();\n        if (cachedImages[key] !== void 0) return cachedImages[key];\n        if (!json.images) json.images = [];\n        var imageDef = {\n          mimeType: mimeType\n        };\n        var canvas = getCanvas();\n        canvas.width = Math.min(image.width, options.maxTextureSize);\n        canvas.height = Math.min(image.height, options.maxTextureSize);\n        var ctx = canvas.getContext(\"2d\");\n        if (flipY === true) {\n          ctx.translate(0, canvas.height);\n          ctx.scale(1, -1);\n        }\n        if (image.data !== void 0) {\n          if (format !== RGBAFormat) {\n            console.error(\"GLTFExporter: Only RGBAFormat is supported.\", format);\n          }\n          if (image.width > options.maxTextureSize || image.height > options.maxTextureSize) {\n            console.warn(\"GLTFExporter: Image size is bigger than maxTextureSize\", image);\n          }\n          var data = new Uint8ClampedArray(image.height * image.width * 4);\n          for (var i = 0; i < data.length; i += 4) {\n            data[i + 0] = image.data[i + 0];\n            data[i + 1] = image.data[i + 1];\n            data[i + 2] = image.data[i + 2];\n            data[i + 3] = image.data[i + 3];\n          }\n          ctx.putImageData(new ImageData(data, image.width, image.height), 0, 0);\n        } else {\n          ctx.drawImage(image, 0, 0, canvas.width, canvas.height);\n        }\n        if (options.binary === true) {\n          pending.push(getToBlobPromise(canvas, mimeType).then(function (blob) {\n            return writer.processBufferViewImage(blob);\n          }).then(function (bufferViewIndex) {\n            imageDef.bufferView = bufferViewIndex;\n          }));\n        } else {\n          if (canvas.toDataURL !== void 0) {\n            imageDef.uri = canvas.toDataURL(mimeType);\n          } else {\n            pending.push(getToBlobPromise(canvas, mimeType).then(readAsDataURL).then(function (uri) {\n              imageDef.uri = uri;\n            }));\n          }\n        }\n        var index = json.images.push(imageDef) - 1;\n        cachedImages[key] = index;\n        return index;\n      } else {\n        throw new Error(\"THREE.GLTFExporter: No valid image data found. Unable to process texture.\");\n      }\n    }\n    /**\n     * Process sampler\n     * @param  {Texture} map Texture to process\n     * @return {Integer}     Index of the processed texture in the \"samplers\" array\n     */\n  }, {\n    key: \"processSampler\",\n    value: function processSampler(map) {\n      var json = this.json;\n      if (!json.samplers) json.samplers = [];\n      var samplerDef = {\n        magFilter: THREE_TO_WEBGL[map.magFilter],\n        minFilter: THREE_TO_WEBGL[map.minFilter],\n        wrapS: THREE_TO_WEBGL[map.wrapS],\n        wrapT: THREE_TO_WEBGL[map.wrapT]\n      };\n      return json.samplers.push(samplerDef) - 1;\n    }\n    /**\n     * Process texture\n     * @param  {Texture} map Map to process\n     * @return {Integer} Index of the processed texture in the \"textures\" array\n     */\n  }, {\n    key: \"processTexture\",\n    value: function processTexture(map) {\n      var writer = this;\n      var options = writer.options;\n      var cache = this.cache;\n      var json = this.json;\n      if (cache.textures.has(map)) return cache.textures.get(map);\n      if (!json.textures) json.textures = [];\n      if (map instanceof CompressedTexture) {\n        map = decompress(map, options.maxTextureSize);\n      }\n      var mimeType = map.userData.mimeType;\n      if (mimeType === \"image/webp\") mimeType = \"image/png\";\n      var textureDef = {\n        sampler: this.processSampler(map),\n        source: this.processImage(map.image, map.format, map.flipY, mimeType)\n      };\n      if (map.name) textureDef.name = map.name;\n      this._invokeAll(function (ext) {\n        ext.writeTexture && ext.writeTexture(map, textureDef);\n      });\n      var index = json.textures.push(textureDef) - 1;\n      cache.textures.set(map, index);\n      return index;\n    }\n    /**\n     * Process material\n     * @param  {THREE.Material} material Material to process\n     * @return {Integer|null} Index of the processed material in the \"materials\" array\n     */\n  }, {\n    key: \"processMaterial\",\n    value: function processMaterial(material) {\n      var cache = this.cache;\n      var json = this.json;\n      if (cache.materials.has(material)) return cache.materials.get(material);\n      if (material.isShaderMaterial) {\n        console.warn(\"GLTFExporter: THREE.ShaderMaterial not supported.\");\n        return null;\n      }\n      if (!json.materials) json.materials = [];\n      var materialDef = {\n        pbrMetallicRoughness: {}\n      };\n      if (material.isMeshStandardMaterial !== true && material.isMeshBasicMaterial !== true) {\n        console.warn(\"GLTFExporter: Use MeshStandardMaterial or MeshBasicMaterial for best results.\");\n      }\n      var color = material.color.toArray().concat([material.opacity]);\n      if (!equalArray(color, [1, 1, 1, 1])) {\n        materialDef.pbrMetallicRoughness.baseColorFactor = color;\n      }\n      if (material.isMeshStandardMaterial) {\n        materialDef.pbrMetallicRoughness.metallicFactor = material.metalness;\n        materialDef.pbrMetallicRoughness.roughnessFactor = material.roughness;\n      } else {\n        materialDef.pbrMetallicRoughness.metallicFactor = 0.5;\n        materialDef.pbrMetallicRoughness.roughnessFactor = 0.5;\n      }\n      if (material.metalnessMap || material.roughnessMap) {\n        var metalRoughTexture = this.buildMetalRoughTexture(material.metalnessMap, material.roughnessMap);\n        var metalRoughMapDef = {\n          index: this.processTexture(metalRoughTexture),\n          channel: metalRoughTexture.channel\n        };\n        this.applyTextureTransform(metalRoughMapDef, metalRoughTexture);\n        materialDef.pbrMetallicRoughness.metallicRoughnessTexture = metalRoughMapDef;\n      }\n      if (material.map) {\n        var baseColorMapDef = {\n          index: this.processTexture(material.map),\n          texCoord: material.map.channel\n        };\n        this.applyTextureTransform(baseColorMapDef, material.map);\n        materialDef.pbrMetallicRoughness.baseColorTexture = baseColorMapDef;\n      }\n      if (material.emissive) {\n        var emissive = material.emissive;\n        var maxEmissiveComponent = Math.max(emissive.r, emissive.g, emissive.b);\n        if (maxEmissiveComponent > 0) {\n          materialDef.emissiveFactor = material.emissive.toArray();\n        }\n        if (material.emissiveMap) {\n          var emissiveMapDef = {\n            index: this.processTexture(material.emissiveMap),\n            texCoord: material.emissiveMap.channel\n          };\n          this.applyTextureTransform(emissiveMapDef, material.emissiveMap);\n          materialDef.emissiveTexture = emissiveMapDef;\n        }\n      }\n      if (material.normalMap) {\n        var normalMapDef = {\n          index: this.processTexture(material.normalMap),\n          texCoord: material.normalMap.channel\n        };\n        if (material.normalScale && material.normalScale.x !== 1) {\n          normalMapDef.scale = material.normalScale.x;\n        }\n        this.applyTextureTransform(normalMapDef, material.normalMap);\n        materialDef.normalTexture = normalMapDef;\n      }\n      if (material.aoMap) {\n        var occlusionMapDef = {\n          index: this.processTexture(material.aoMap),\n          texCoord: material.aoMap.channel\n        };\n        if (material.aoMapIntensity !== 1) {\n          occlusionMapDef.strength = material.aoMapIntensity;\n        }\n        this.applyTextureTransform(occlusionMapDef, material.aoMap);\n        materialDef.occlusionTexture = occlusionMapDef;\n      }\n      if (material.transparent) {\n        materialDef.alphaMode = \"BLEND\";\n      } else {\n        if (material.alphaTest > 0) {\n          materialDef.alphaMode = \"MASK\";\n          materialDef.alphaCutoff = material.alphaTest;\n        }\n      }\n      if (material.side === DoubleSide) materialDef.doubleSided = true;\n      if (material.name !== \"\") materialDef.name = material.name;\n      this.serializeUserData(material, materialDef);\n      this._invokeAll(function (ext) {\n        ext.writeMaterial && ext.writeMaterial(material, materialDef);\n      });\n      var index = json.materials.push(materialDef) - 1;\n      cache.materials.set(material, index);\n      return index;\n    }\n    /**\n     * Process mesh\n     * @param  {THREE.Mesh} mesh Mesh to process\n     * @return {Integer|null} Index of the processed mesh in the \"meshes\" array\n     */\n  }, {\n    key: \"processMesh\",\n    value: function processMesh(mesh) {\n      var cache = this.cache;\n      var json = this.json;\n      var meshCacheKeyParts = [mesh.geometry.uuid];\n      if (Array.isArray(mesh.material)) {\n        for (var i = 0, l = mesh.material.length; i < l; i++) {\n          meshCacheKeyParts.push(mesh.material[i].uuid);\n        }\n      } else {\n        meshCacheKeyParts.push(mesh.material.uuid);\n      }\n      var meshCacheKey = meshCacheKeyParts.join(\":\");\n      if (cache.meshes.has(meshCacheKey)) return cache.meshes.get(meshCacheKey);\n      var geometry = mesh.geometry;\n      var mode;\n      if (mesh.isLineSegments) {\n        mode = WEBGL_CONSTANTS.LINES;\n      } else if (mesh.isLineLoop) {\n        mode = WEBGL_CONSTANTS.LINE_LOOP;\n      } else if (mesh.isLine) {\n        mode = WEBGL_CONSTANTS.LINE_STRIP;\n      } else if (mesh.isPoints) {\n        mode = WEBGL_CONSTANTS.POINTS;\n      } else {\n        mode = mesh.material.wireframe ? WEBGL_CONSTANTS.LINES : WEBGL_CONSTANTS.TRIANGLES;\n      }\n      var meshDef = {};\n      var attributes = {};\n      var primitives = [];\n      var targets = [];\n      var nameConversion = _objectSpread(_objectSpread({}, version >= 152 ? {\n        uv: \"TEXCOORD_0\",\n        uv1: \"TEXCOORD_1\",\n        uv2: \"TEXCOORD_2\",\n        uv3: \"TEXCOORD_3\"\n      } : {\n        uv: \"TEXCOORD_0\",\n        uv2: \"TEXCOORD_1\"\n      }), {}, {\n        color: \"COLOR_0\",\n        skinWeight: \"WEIGHTS_0\",\n        skinIndex: \"JOINTS_0\"\n      });\n      var originalNormal = geometry.getAttribute(\"normal\");\n      if (originalNormal !== void 0 && !this.isNormalizedNormalAttribute(originalNormal)) {\n        console.warn(\"THREE.GLTFExporter: Creating normalized normal attribute from the non-normalized one.\");\n        geometry.setAttribute(\"normal\", this.createNormalizedNormalAttribute(originalNormal));\n      }\n      var modifiedAttribute = null;\n      for (var attributeName in geometry.attributes) {\n        if (attributeName.slice(0, 5) === \"morph\") continue;\n        var attribute = geometry.attributes[attributeName];\n        attributeName = nameConversion[attributeName] || attributeName.toUpperCase();\n        var validVertexAttributes = /^(POSITION|NORMAL|TANGENT|TEXCOORD_\\d+|COLOR_\\d+|JOINTS_\\d+|WEIGHTS_\\d+)$/;\n        if (!validVertexAttributes.test(attributeName)) attributeName = \"_\" + attributeName;\n        if (cache.attributes.has(this.getUID(attribute))) {\n          attributes[attributeName] = cache.attributes.get(this.getUID(attribute));\n          continue;\n        }\n        modifiedAttribute = null;\n        var array = attribute.array;\n        if (attributeName === \"JOINTS_0\" && !(array instanceof Uint16Array) && !(array instanceof Uint8Array)) {\n          console.warn('GLTFExporter: Attribute \"skinIndex\" converted to type UNSIGNED_SHORT.');\n          modifiedAttribute = new BufferAttribute(new Uint16Array(array), attribute.itemSize, attribute.normalized);\n        }\n        var accessor = this.processAccessor(modifiedAttribute || attribute, geometry);\n        if (accessor !== null) {\n          if (!attributeName.startsWith(\"_\")) {\n            this.detectMeshQuantization(attributeName, attribute);\n          }\n          attributes[attributeName] = accessor;\n          cache.attributes.set(this.getUID(attribute), accessor);\n        }\n      }\n      if (originalNormal !== void 0) geometry.setAttribute(\"normal\", originalNormal);\n      if (Object.keys(attributes).length === 0) return null;\n      if (mesh.morphTargetInfluences !== void 0 && mesh.morphTargetInfluences.length > 0) {\n        var weights = [];\n        var targetNames = [];\n        var reverseDictionary = {};\n        if (mesh.morphTargetDictionary !== void 0) {\n          for (var key in mesh.morphTargetDictionary) {\n            reverseDictionary[mesh.morphTargetDictionary[key]] = key;\n          }\n        }\n        for (var _i3 = 0; _i3 < mesh.morphTargetInfluences.length; ++_i3) {\n          var target = {};\n          var warned = false;\n          for (var _attributeName in geometry.morphAttributes) {\n            if (_attributeName !== \"position\" && _attributeName !== \"normal\") {\n              if (!warned) {\n                console.warn(\"GLTFExporter: Only POSITION and NORMAL morph are supported.\");\n                warned = true;\n              }\n              continue;\n            }\n            var _attribute = geometry.morphAttributes[_attributeName][_i3];\n            var gltfAttributeName = _attributeName.toUpperCase();\n            var baseAttribute = geometry.attributes[_attributeName];\n            if (cache.attributes.has(this.getUID(_attribute, true))) {\n              target[gltfAttributeName] = cache.attributes.get(this.getUID(_attribute, true));\n              continue;\n            }\n            var relativeAttribute = _attribute.clone();\n            if (!geometry.morphTargetsRelative) {\n              for (var j = 0, jl = _attribute.count; j < jl; j++) {\n                for (var a = 0; a < _attribute.itemSize; a++) {\n                  if (a === 0) relativeAttribute.setX(j, _attribute.getX(j) - baseAttribute.getX(j));\n                  if (a === 1) relativeAttribute.setY(j, _attribute.getY(j) - baseAttribute.getY(j));\n                  if (a === 2) relativeAttribute.setZ(j, _attribute.getZ(j) - baseAttribute.getZ(j));\n                  if (a === 3) relativeAttribute.setW(j, _attribute.getW(j) - baseAttribute.getW(j));\n                }\n              }\n            }\n            target[gltfAttributeName] = this.processAccessor(relativeAttribute, geometry);\n            cache.attributes.set(this.getUID(baseAttribute, true), target[gltfAttributeName]);\n          }\n          targets.push(target);\n          weights.push(mesh.morphTargetInfluences[_i3]);\n          if (mesh.morphTargetDictionary !== void 0) targetNames.push(reverseDictionary[_i3]);\n        }\n        meshDef.weights = weights;\n        if (targetNames.length > 0) {\n          meshDef.extras = {};\n          meshDef.extras.targetNames = targetNames;\n        }\n      }\n      var isMultiMaterial = Array.isArray(mesh.material);\n      if (isMultiMaterial && geometry.groups.length === 0) return null;\n      var materials = isMultiMaterial ? mesh.material : [mesh.material];\n      var groups = isMultiMaterial ? geometry.groups : [{\n        materialIndex: 0,\n        start: void 0,\n        count: void 0\n      }];\n      for (var _i4 = 0, il = groups.length; _i4 < il; _i4++) {\n        var primitive = {\n          mode: mode,\n          attributes: attributes\n        };\n        this.serializeUserData(geometry, primitive);\n        if (targets.length > 0) primitive.targets = targets;\n        if (geometry.index !== null) {\n          var cacheKey = this.getUID(geometry.index);\n          if (groups[_i4].start !== void 0 || groups[_i4].count !== void 0) {\n            cacheKey += \":\" + groups[_i4].start + \":\" + groups[_i4].count;\n          }\n          if (cache.attributes.has(cacheKey)) {\n            primitive.indices = cache.attributes.get(cacheKey);\n          } else {\n            primitive.indices = this.processAccessor(geometry.index, geometry, groups[_i4].start, groups[_i4].count);\n            cache.attributes.set(cacheKey, primitive.indices);\n          }\n          if (primitive.indices === null) delete primitive.indices;\n        }\n        var material = this.processMaterial(materials[groups[_i4].materialIndex]);\n        if (material !== null) primitive.material = material;\n        primitives.push(primitive);\n      }\n      meshDef.primitives = primitives;\n      if (!json.meshes) json.meshes = [];\n      this._invokeAll(function (ext) {\n        ext.writeMesh && ext.writeMesh(mesh, meshDef);\n      });\n      var index = json.meshes.push(meshDef) - 1;\n      cache.meshes.set(meshCacheKey, index);\n      return index;\n    }\n    /**\n     * If a vertex attribute with a\n     * [non-standard data type](https://registry.khronos.org/glTF/specs/2.0/glTF-2.0.html#meshes-overview)\n     * is used, it is checked whether it is a valid data type according to the\n     * [KHR_mesh_quantization](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_mesh_quantization/README.md)\n     * extension.\n     * In this case the extension is automatically added to the list of used extensions.\n     *\n     * @param {string} attributeName\n     * @param {THREE.BufferAttribute} attribute\n     */\n  }, {\n    key: \"detectMeshQuantization\",\n    value: function detectMeshQuantization(attributeName, attribute) {\n      if (this.extensionsUsed[KHR_MESH_QUANTIZATION]) return;\n      var attrType = void 0;\n      switch (attribute.array.constructor) {\n        case Int8Array:\n          attrType = \"byte\";\n          break;\n        case Uint8Array:\n          attrType = \"unsigned byte\";\n          break;\n        case Int16Array:\n          attrType = \"short\";\n          break;\n        case Uint16Array:\n          attrType = \"unsigned short\";\n          break;\n        default:\n          return;\n      }\n      if (attribute.normalized) attrType += \" normalized\";\n      var attrNamePrefix = attributeName.split(\"_\", 1)[0];\n      if (KHR_mesh_quantization_ExtraAttrTypes[attrNamePrefix] && KHR_mesh_quantization_ExtraAttrTypes[attrNamePrefix].includes(attrType)) {\n        this.extensionsUsed[KHR_MESH_QUANTIZATION] = true;\n        this.extensionsRequired[KHR_MESH_QUANTIZATION] = true;\n      }\n    }\n    /**\n     * Process camera\n     * @param  {THREE.Camera} camera Camera to process\n     * @return {Integer}      Index of the processed mesh in the \"camera\" array\n     */\n  }, {\n    key: \"processCamera\",\n    value: function processCamera(camera) {\n      var json = this.json;\n      if (!json.cameras) json.cameras = [];\n      var isOrtho = camera.isOrthographicCamera;\n      var cameraDef = {\n        type: isOrtho ? \"orthographic\" : \"perspective\"\n      };\n      if (isOrtho) {\n        cameraDef.orthographic = {\n          xmag: camera.right * 2,\n          ymag: camera.top * 2,\n          zfar: camera.far <= 0 ? 1e-3 : camera.far,\n          znear: camera.near < 0 ? 0 : camera.near\n        };\n      } else {\n        cameraDef.perspective = {\n          aspectRatio: camera.aspect,\n          yfov: MathUtils.degToRad(camera.fov),\n          zfar: camera.far <= 0 ? 1e-3 : camera.far,\n          znear: camera.near < 0 ? 0 : camera.near\n        };\n      }\n      if (camera.name !== \"\") cameraDef.name = camera.type;\n      return json.cameras.push(cameraDef) - 1;\n    }\n    /**\n     * Creates glTF animation entry from AnimationClip object.\n     *\n     * Status:\n     * - Only properties listed in PATH_PROPERTIES may be animated.\n     *\n     * @param {THREE.AnimationClip} clip\n     * @param {THREE.Object3D} root\n     * @return {number|null}\n     */\n  }, {\n    key: \"processAnimation\",\n    value: function processAnimation(clip, root) {\n      var json = this.json;\n      var nodeMap = this.nodeMap;\n      if (!json.animations) json.animations = [];\n      clip = GLTFExporter.Utils.mergeMorphTargetTracks(clip.clone(), root);\n      var tracks = clip.tracks;\n      var channels = [];\n      var samplers = [];\n      for (var i = 0; i < tracks.length; ++i) {\n        var track = tracks[i];\n        var trackBinding = PropertyBinding.parseTrackName(track.name);\n        var trackNode = PropertyBinding.findNode(root, trackBinding.nodeName);\n        var trackProperty = PATH_PROPERTIES[trackBinding.propertyName];\n        if (trackBinding.objectName === \"bones\") {\n          if (trackNode.isSkinnedMesh === true) {\n            trackNode = trackNode.skeleton.getBoneByName(trackBinding.objectIndex);\n          } else {\n            trackNode = void 0;\n          }\n        }\n        if (!trackNode || !trackProperty) {\n          console.warn('THREE.GLTFExporter: Could not export animation track \"%s\".', track.name);\n          return null;\n        }\n        var inputItemSize = 1;\n        var outputItemSize = track.values.length / track.times.length;\n        if (trackProperty === PATH_PROPERTIES.morphTargetInfluences) {\n          outputItemSize /= trackNode.morphTargetInfluences.length;\n        }\n        var interpolation = void 0;\n        if (track.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline === true) {\n          interpolation = \"CUBICSPLINE\";\n          outputItemSize /= 3;\n        } else if (track.getInterpolation() === InterpolateDiscrete) {\n          interpolation = \"STEP\";\n        } else {\n          interpolation = \"LINEAR\";\n        }\n        samplers.push({\n          input: this.processAccessor(new BufferAttribute(track.times, inputItemSize)),\n          output: this.processAccessor(new BufferAttribute(track.values, outputItemSize)),\n          interpolation: interpolation\n        });\n        channels.push({\n          sampler: samplers.length - 1,\n          target: {\n            node: nodeMap.get(trackNode),\n            path: trackProperty\n          }\n        });\n      }\n      json.animations.push({\n        name: clip.name || \"clip_\" + json.animations.length,\n        samplers: samplers,\n        channels: channels\n      });\n      return json.animations.length - 1;\n    }\n    /**\n     * @param {THREE.Object3D} object\n     * @return {number|null}\n     */\n  }, {\n    key: \"processSkin\",\n    value: function processSkin(object) {\n      var json = this.json;\n      var nodeMap = this.nodeMap;\n      var node = json.nodes[nodeMap.get(object)];\n      var skeleton = object.skeleton;\n      if (skeleton === void 0) return null;\n      var rootJoint = object.skeleton.bones[0];\n      if (rootJoint === void 0) return null;\n      var joints = [];\n      var inverseBindMatrices = new Float32Array(skeleton.bones.length * 16);\n      var temporaryBoneInverse = new Matrix4();\n      for (var i = 0; i < skeleton.bones.length; ++i) {\n        joints.push(nodeMap.get(skeleton.bones[i]));\n        temporaryBoneInverse.copy(skeleton.boneInverses[i]);\n        temporaryBoneInverse.multiply(object.bindMatrix).toArray(inverseBindMatrices, i * 16);\n      }\n      if (json.skins === void 0) json.skins = [];\n      json.skins.push({\n        inverseBindMatrices: this.processAccessor(new BufferAttribute(inverseBindMatrices, 16)),\n        joints: joints,\n        skeleton: nodeMap.get(rootJoint)\n      });\n      var skinIndex = node.skin = json.skins.length - 1;\n      return skinIndex;\n    }\n    /**\n     * Process Object3D node\n     * @param  {THREE.Object3D} node Object3D to processNode\n     * @return {Integer} Index of the node in the nodes list\n     */\n  }, {\n    key: \"processNode\",\n    value: function processNode(object) {\n      var json = this.json;\n      var options = this.options;\n      var nodeMap = this.nodeMap;\n      if (!json.nodes) json.nodes = [];\n      var nodeDef = {};\n      if (options.trs) {\n        var rotation = object.quaternion.toArray();\n        var position = object.position.toArray();\n        var scale = object.scale.toArray();\n        if (!equalArray(rotation, [0, 0, 0, 1])) {\n          nodeDef.rotation = rotation;\n        }\n        if (!equalArray(position, [0, 0, 0])) {\n          nodeDef.translation = position;\n        }\n        if (!equalArray(scale, [1, 1, 1])) {\n          nodeDef.scale = scale;\n        }\n      } else {\n        if (object.matrixAutoUpdate) {\n          object.updateMatrix();\n        }\n        if (isIdentityMatrix(object.matrix) === false) {\n          nodeDef.matrix = object.matrix.elements;\n        }\n      }\n      if (object.name !== \"\") nodeDef.name = String(object.name);\n      this.serializeUserData(object, nodeDef);\n      if (object.isMesh || object.isLine || object.isPoints) {\n        var meshIndex = this.processMesh(object);\n        if (meshIndex !== null) nodeDef.mesh = meshIndex;\n      } else if (object.isCamera) {\n        nodeDef.camera = this.processCamera(object);\n      }\n      if (object.isSkinnedMesh) this.skins.push(object);\n      if (object.children.length > 0) {\n        var children = [];\n        for (var i = 0, l = object.children.length; i < l; i++) {\n          var child = object.children[i];\n          if (child.visible || options.onlyVisible === false) {\n            var nodeIndex2 = this.processNode(child);\n            if (nodeIndex2 !== null) children.push(nodeIndex2);\n          }\n        }\n        if (children.length > 0) nodeDef.children = children;\n      }\n      this._invokeAll(function (ext) {\n        ext.writeNode && ext.writeNode(object, nodeDef);\n      });\n      var nodeIndex = json.nodes.push(nodeDef) - 1;\n      nodeMap.set(object, nodeIndex);\n      return nodeIndex;\n    }\n    /**\n     * Process Scene\n     * @param  {Scene} node Scene to process\n     */\n  }, {\n    key: \"processScene\",\n    value: function processScene(scene) {\n      var json = this.json;\n      var options = this.options;\n      if (!json.scenes) {\n        json.scenes = [];\n        json.scene = 0;\n      }\n      var sceneDef = {};\n      if (scene.name !== \"\") sceneDef.name = scene.name;\n      json.scenes.push(sceneDef);\n      var nodes = [];\n      for (var i = 0, l = scene.children.length; i < l; i++) {\n        var child = scene.children[i];\n        if (child.visible || options.onlyVisible === false) {\n          var nodeIndex = this.processNode(child);\n          if (nodeIndex !== null) nodes.push(nodeIndex);\n        }\n      }\n      if (nodes.length > 0) sceneDef.nodes = nodes;\n      this.serializeUserData(scene, sceneDef);\n    }\n    /**\n     * Creates a Scene to hold a list of objects and parse it\n     * @param  {Array} objects List of objects to process\n     */\n  }, {\n    key: \"processObjects\",\n    value: function processObjects(objects) {\n      var scene = new Scene();\n      scene.name = \"AuxScene\";\n      for (var i = 0; i < objects.length; i++) {\n        scene.children.push(objects[i]);\n      }\n      this.processScene(scene);\n    }\n    /**\n     * @param {THREE.Object3D|Array<THREE.Object3D>} input\n     */\n  }, {\n    key: \"processInput\",\n    value: function processInput(input) {\n      var options = this.options;\n      input = input instanceof Array ? input : [input];\n      this._invokeAll(function (ext) {\n        ext.beforeParse && ext.beforeParse(input);\n      });\n      var objectsWithoutScene = [];\n      for (var i = 0; i < input.length; i++) {\n        if (input[i] instanceof Scene) {\n          this.processScene(input[i]);\n        } else {\n          objectsWithoutScene.push(input[i]);\n        }\n      }\n      if (objectsWithoutScene.length > 0) this.processObjects(objectsWithoutScene);\n      for (var _i5 = 0; _i5 < this.skins.length; ++_i5) {\n        this.processSkin(this.skins[_i5]);\n      }\n      for (var _i6 = 0; _i6 < options.animations.length; ++_i6) {\n        this.processAnimation(options.animations[_i6], input[0]);\n      }\n      this._invokeAll(function (ext) {\n        ext.afterParse && ext.afterParse(input);\n      });\n    }\n  }, {\n    key: \"_invokeAll\",\n    value: function _invokeAll(func) {\n      for (var i = 0, il = this.plugins.length; i < il; i++) {\n        func(this.plugins[i]);\n      }\n    }\n  }]);\n  return GLTFWriter;\n}();\nvar GLTFLightExtension = /*#__PURE__*/function () {\n  function GLTFLightExtension(writer) {\n    _classCallCheck(this, GLTFLightExtension);\n    this.writer = writer;\n    this.name = \"KHR_lights_punctual\";\n  }\n  _createClass(GLTFLightExtension, [{\n    key: \"writeNode\",\n    value: function writeNode(light, nodeDef) {\n      if (!light.isLight) return;\n      if (!light.isDirectionalLight && !light.isPointLight && !light.isSpotLight) {\n        console.warn(\"THREE.GLTFExporter: Only directional, point, and spot lights are supported.\", light);\n        return;\n      }\n      var writer = this.writer;\n      var json = writer.json;\n      var extensionsUsed = writer.extensionsUsed;\n      var lightDef = {};\n      if (light.name) lightDef.name = light.name;\n      lightDef.color = light.color.toArray();\n      lightDef.intensity = light.intensity;\n      if (light.isDirectionalLight) {\n        lightDef.type = \"directional\";\n      } else if (light.isPointLight) {\n        lightDef.type = \"point\";\n        if (light.distance > 0) lightDef.range = light.distance;\n      } else if (light.isSpotLight) {\n        lightDef.type = \"spot\";\n        if (light.distance > 0) lightDef.range = light.distance;\n        lightDef.spot = {};\n        lightDef.spot.innerConeAngle = (light.penumbra - 1) * light.angle * -1;\n        lightDef.spot.outerConeAngle = light.angle;\n      }\n      if (light.decay !== void 0 && light.decay !== 2) {\n        console.warn(\"THREE.GLTFExporter: Light decay may be lost. glTF is physically-based, and expects light.decay=2.\");\n      }\n      if (light.target && (light.target.parent !== light || light.target.position.x !== 0 || light.target.position.y !== 0 || light.target.position.z !== -1)) {\n        console.warn(\"THREE.GLTFExporter: Light direction may be lost. For best results, make light.target a child of the light with position 0,0,-1.\");\n      }\n      if (!extensionsUsed[this.name]) {\n        json.extensions = json.extensions || {};\n        json.extensions[this.name] = {\n          lights: []\n        };\n        extensionsUsed[this.name] = true;\n      }\n      var lights = json.extensions[this.name].lights;\n      lights.push(lightDef);\n      nodeDef.extensions = nodeDef.extensions || {};\n      nodeDef.extensions[this.name] = {\n        light: lights.length - 1\n      };\n    }\n  }]);\n  return GLTFLightExtension;\n}();\nvar GLTFMaterialsUnlitExtension = /*#__PURE__*/function () {\n  function GLTFMaterialsUnlitExtension(writer) {\n    _classCallCheck(this, GLTFMaterialsUnlitExtension);\n    this.writer = writer;\n    this.name = \"KHR_materials_unlit\";\n  }\n  _createClass(GLTFMaterialsUnlitExtension, [{\n    key: \"writeMaterial\",\n    value: function writeMaterial(material, materialDef) {\n      if (!material.isMeshBasicMaterial) return;\n      var writer = this.writer;\n      var extensionsUsed = writer.extensionsUsed;\n      materialDef.extensions = materialDef.extensions || {};\n      materialDef.extensions[this.name] = {};\n      extensionsUsed[this.name] = true;\n      materialDef.pbrMetallicRoughness.metallicFactor = 0;\n      materialDef.pbrMetallicRoughness.roughnessFactor = 0.9;\n    }\n  }]);\n  return GLTFMaterialsUnlitExtension;\n}();\nvar GLTFMaterialsClearcoatExtension = /*#__PURE__*/function () {\n  function GLTFMaterialsClearcoatExtension(writer) {\n    _classCallCheck(this, GLTFMaterialsClearcoatExtension);\n    this.writer = writer;\n    this.name = \"KHR_materials_clearcoat\";\n  }\n  _createClass(GLTFMaterialsClearcoatExtension, [{\n    key: \"writeMaterial\",\n    value: function writeMaterial(material, materialDef) {\n      if (!material.isMeshPhysicalMaterial || material.clearcoat === 0) return;\n      var writer = this.writer;\n      var extensionsUsed = writer.extensionsUsed;\n      var extensionDef = {};\n      extensionDef.clearcoatFactor = material.clearcoat;\n      if (material.clearcoatMap) {\n        var clearcoatMapDef = {\n          index: writer.processTexture(material.clearcoatMap),\n          texCoord: material.clearcoatMap.channel\n        };\n        writer.applyTextureTransform(clearcoatMapDef, material.clearcoatMap);\n        extensionDef.clearcoatTexture = clearcoatMapDef;\n      }\n      extensionDef.clearcoatRoughnessFactor = material.clearcoatRoughness;\n      if (material.clearcoatRoughnessMap) {\n        var clearcoatRoughnessMapDef = {\n          index: writer.processTexture(material.clearcoatRoughnessMap),\n          texCoord: material.clearcoatRoughnessMap.channel\n        };\n        writer.applyTextureTransform(clearcoatRoughnessMapDef, material.clearcoatRoughnessMap);\n        extensionDef.clearcoatRoughnessTexture = clearcoatRoughnessMapDef;\n      }\n      if (material.clearcoatNormalMap) {\n        var clearcoatNormalMapDef = {\n          index: writer.processTexture(material.clearcoatNormalMap),\n          texCoord: material.clearcoatNormalMap.channel\n        };\n        writer.applyTextureTransform(clearcoatNormalMapDef, material.clearcoatNormalMap);\n        extensionDef.clearcoatNormalTexture = clearcoatNormalMapDef;\n      }\n      materialDef.extensions = materialDef.extensions || {};\n      materialDef.extensions[this.name] = extensionDef;\n      extensionsUsed[this.name] = true;\n    }\n  }]);\n  return GLTFMaterialsClearcoatExtension;\n}();\nvar GLTFMaterialsIridescenceExtension = /*#__PURE__*/function () {\n  function GLTFMaterialsIridescenceExtension(writer) {\n    _classCallCheck(this, GLTFMaterialsIridescenceExtension);\n    this.writer = writer;\n    this.name = \"KHR_materials_iridescence\";\n  }\n  _createClass(GLTFMaterialsIridescenceExtension, [{\n    key: \"writeMaterial\",\n    value: function writeMaterial(material, materialDef) {\n      if (!material.isMeshPhysicalMaterial || material.iridescence === 0) return;\n      var writer = this.writer;\n      var extensionsUsed = writer.extensionsUsed;\n      var extensionDef = {};\n      extensionDef.iridescenceFactor = material.iridescence;\n      if (material.iridescenceMap) {\n        var iridescenceMapDef = {\n          index: writer.processTexture(material.iridescenceMap),\n          texCoord: material.iridescenceMap.channel\n        };\n        writer.applyTextureTransform(iridescenceMapDef, material.iridescenceMap);\n        extensionDef.iridescenceTexture = iridescenceMapDef;\n      }\n      extensionDef.iridescenceIor = material.iridescenceIOR;\n      extensionDef.iridescenceThicknessMinimum = material.iridescenceThicknessRange[0];\n      extensionDef.iridescenceThicknessMaximum = material.iridescenceThicknessRange[1];\n      if (material.iridescenceThicknessMap) {\n        var iridescenceThicknessMapDef = {\n          index: writer.processTexture(material.iridescenceThicknessMap),\n          texCoord: material.iridescenceThicknessMap.channel\n        };\n        writer.applyTextureTransform(iridescenceThicknessMapDef, material.iridescenceThicknessMap);\n        extensionDef.iridescenceThicknessTexture = iridescenceThicknessMapDef;\n      }\n      materialDef.extensions = materialDef.extensions || {};\n      materialDef.extensions[this.name] = extensionDef;\n      extensionsUsed[this.name] = true;\n    }\n  }]);\n  return GLTFMaterialsIridescenceExtension;\n}();\nvar GLTFMaterialsTransmissionExtension = /*#__PURE__*/function () {\n  function GLTFMaterialsTransmissionExtension(writer) {\n    _classCallCheck(this, GLTFMaterialsTransmissionExtension);\n    this.writer = writer;\n    this.name = \"KHR_materials_transmission\";\n  }\n  _createClass(GLTFMaterialsTransmissionExtension, [{\n    key: \"writeMaterial\",\n    value: function writeMaterial(material, materialDef) {\n      if (!material.isMeshPhysicalMaterial || material.transmission === 0) return;\n      var writer = this.writer;\n      var extensionsUsed = writer.extensionsUsed;\n      var extensionDef = {};\n      extensionDef.transmissionFactor = material.transmission;\n      if (material.transmissionMap) {\n        var transmissionMapDef = {\n          index: writer.processTexture(material.transmissionMap),\n          texCoord: material.transmissionMap.channel\n        };\n        writer.applyTextureTransform(transmissionMapDef, material.transmissionMap);\n        extensionDef.transmissionTexture = transmissionMapDef;\n      }\n      materialDef.extensions = materialDef.extensions || {};\n      materialDef.extensions[this.name] = extensionDef;\n      extensionsUsed[this.name] = true;\n    }\n  }]);\n  return GLTFMaterialsTransmissionExtension;\n}();\nvar GLTFMaterialsVolumeExtension = /*#__PURE__*/function () {\n  function GLTFMaterialsVolumeExtension(writer) {\n    _classCallCheck(this, GLTFMaterialsVolumeExtension);\n    this.writer = writer;\n    this.name = \"KHR_materials_volume\";\n  }\n  _createClass(GLTFMaterialsVolumeExtension, [{\n    key: \"writeMaterial\",\n    value: function writeMaterial(material, materialDef) {\n      if (!material.isMeshPhysicalMaterial || material.transmission === 0) return;\n      var writer = this.writer;\n      var extensionsUsed = writer.extensionsUsed;\n      var extensionDef = {};\n      extensionDef.thicknessFactor = material.thickness;\n      if (material.thicknessMap) {\n        var thicknessMapDef = {\n          index: writer.processTexture(material.thicknessMap),\n          texCoord: material.thicknessMap.channel\n        };\n        writer.applyTextureTransform(thicknessMapDef, material.thicknessMap);\n        extensionDef.thicknessTexture = thicknessMapDef;\n      }\n      extensionDef.attenuationDistance = material.attenuationDistance;\n      extensionDef.attenuationColor = material.attenuationColor.toArray();\n      materialDef.extensions = materialDef.extensions || {};\n      materialDef.extensions[this.name] = extensionDef;\n      extensionsUsed[this.name] = true;\n    }\n  }]);\n  return GLTFMaterialsVolumeExtension;\n}();\nvar GLTFMaterialsIorExtension = /*#__PURE__*/function () {\n  function GLTFMaterialsIorExtension(writer) {\n    _classCallCheck(this, GLTFMaterialsIorExtension);\n    this.writer = writer;\n    this.name = \"KHR_materials_ior\";\n  }\n  _createClass(GLTFMaterialsIorExtension, [{\n    key: \"writeMaterial\",\n    value: function writeMaterial(material, materialDef) {\n      if (!material.isMeshPhysicalMaterial || material.ior === 1.5) return;\n      var writer = this.writer;\n      var extensionsUsed = writer.extensionsUsed;\n      var extensionDef = {};\n      extensionDef.ior = material.ior;\n      materialDef.extensions = materialDef.extensions || {};\n      materialDef.extensions[this.name] = extensionDef;\n      extensionsUsed[this.name] = true;\n    }\n  }]);\n  return GLTFMaterialsIorExtension;\n}();\nvar GLTFMaterialsSpecularExtension = /*#__PURE__*/function () {\n  function GLTFMaterialsSpecularExtension(writer) {\n    _classCallCheck(this, GLTFMaterialsSpecularExtension);\n    this.writer = writer;\n    this.name = \"KHR_materials_specular\";\n  }\n  _createClass(GLTFMaterialsSpecularExtension, [{\n    key: \"writeMaterial\",\n    value: function writeMaterial(material, materialDef) {\n      if (!material.isMeshPhysicalMaterial || material.specularIntensity === 1 && material.specularColor.equals(DEFAULT_SPECULAR_COLOR) && !material.specularIntensityMap && !material.specularColorTexture) return;\n      var writer = this.writer;\n      var extensionsUsed = writer.extensionsUsed;\n      var extensionDef = {};\n      if (material.specularIntensityMap) {\n        var specularIntensityMapDef = {\n          index: writer.processTexture(material.specularIntensityMap),\n          texCoord: material.specularIntensityMap.channel\n        };\n        writer.applyTextureTransform(specularIntensityMapDef, material.specularIntensityMap);\n        extensionDef.specularTexture = specularIntensityMapDef;\n      }\n      if (material.specularColorMap) {\n        var specularColorMapDef = {\n          index: writer.processTexture(material.specularColorMap),\n          texCoord: material.specularColorMap.channel\n        };\n        writer.applyTextureTransform(specularColorMapDef, material.specularColorMap);\n        extensionDef.specularColorTexture = specularColorMapDef;\n      }\n      extensionDef.specularFactor = material.specularIntensity;\n      extensionDef.specularColorFactor = material.specularColor.toArray();\n      materialDef.extensions = materialDef.extensions || {};\n      materialDef.extensions[this.name] = extensionDef;\n      extensionsUsed[this.name] = true;\n    }\n  }]);\n  return GLTFMaterialsSpecularExtension;\n}();\nvar GLTFMaterialsSheenExtension = /*#__PURE__*/function () {\n  function GLTFMaterialsSheenExtension(writer) {\n    _classCallCheck(this, GLTFMaterialsSheenExtension);\n    this.writer = writer;\n    this.name = \"KHR_materials_sheen\";\n  }\n  _createClass(GLTFMaterialsSheenExtension, [{\n    key: \"writeMaterial\",\n    value: function writeMaterial(material, materialDef) {\n      if (!material.isMeshPhysicalMaterial || material.sheen == 0) return;\n      var writer = this.writer;\n      var extensionsUsed = writer.extensionsUsed;\n      var extensionDef = {};\n      if (material.sheenRoughnessMap) {\n        var sheenRoughnessMapDef = {\n          index: writer.processTexture(material.sheenRoughnessMap),\n          texCoord: material.sheenRoughnessMap.channel\n        };\n        writer.applyTextureTransform(sheenRoughnessMapDef, material.sheenRoughnessMap);\n        extensionDef.sheenRoughnessTexture = sheenRoughnessMapDef;\n      }\n      if (material.sheenColorMap) {\n        var sheenColorMapDef = {\n          index: writer.processTexture(material.sheenColorMap),\n          texCoord: material.sheenColorMap.channel\n        };\n        writer.applyTextureTransform(sheenColorMapDef, material.sheenColorMap);\n        extensionDef.sheenColorTexture = sheenColorMapDef;\n      }\n      extensionDef.sheenRoughnessFactor = material.sheenRoughness;\n      extensionDef.sheenColorFactor = material.sheenColor.toArray();\n      materialDef.extensions = materialDef.extensions || {};\n      materialDef.extensions[this.name] = extensionDef;\n      extensionsUsed[this.name] = true;\n    }\n  }]);\n  return GLTFMaterialsSheenExtension;\n}();\nvar GLTFMaterialsAnisotropyExtension = /*#__PURE__*/function () {\n  function GLTFMaterialsAnisotropyExtension(writer) {\n    _classCallCheck(this, GLTFMaterialsAnisotropyExtension);\n    this.writer = writer;\n    this.name = \"KHR_materials_anisotropy\";\n  }\n  _createClass(GLTFMaterialsAnisotropyExtension, [{\n    key: \"writeMaterial\",\n    value: function writeMaterial(material, materialDef) {\n      if (!material.isMeshPhysicalMaterial || material.anisotropy == 0) return;\n      var writer = this.writer;\n      var extensionsUsed = writer.extensionsUsed;\n      var extensionDef = {};\n      if (material.anisotropyMap) {\n        var anisotropyMapDef = {\n          index: writer.processTexture(material.anisotropyMap)\n        };\n        writer.applyTextureTransform(anisotropyMapDef, material.anisotropyMap);\n        extensionDef.anisotropyTexture = anisotropyMapDef;\n      }\n      extensionDef.anisotropyStrength = material.anisotropy;\n      extensionDef.anisotropyRotation = material.anisotropyRotation;\n      materialDef.extensions = materialDef.extensions || {};\n      materialDef.extensions[this.name] = extensionDef;\n      extensionsUsed[this.name] = true;\n    }\n  }]);\n  return GLTFMaterialsAnisotropyExtension;\n}();\nvar GLTFMaterialsEmissiveStrengthExtension = /*#__PURE__*/function () {\n  function GLTFMaterialsEmissiveStrengthExtension(writer) {\n    _classCallCheck(this, GLTFMaterialsEmissiveStrengthExtension);\n    this.writer = writer;\n    this.name = \"KHR_materials_emissive_strength\";\n  }\n  _createClass(GLTFMaterialsEmissiveStrengthExtension, [{\n    key: \"writeMaterial\",\n    value: function writeMaterial(material, materialDef) {\n      if (!material.isMeshStandardMaterial || material.emissiveIntensity === 1) return;\n      var writer = this.writer;\n      var extensionsUsed = writer.extensionsUsed;\n      var extensionDef = {};\n      extensionDef.emissiveStrength = material.emissiveIntensity;\n      materialDef.extensions = materialDef.extensions || {};\n      materialDef.extensions[this.name] = extensionDef;\n      extensionsUsed[this.name] = true;\n    }\n  }]);\n  return GLTFMaterialsEmissiveStrengthExtension;\n}();\nexport { GLTFExporter };","map":{"version":3,"names":["readAsDataURL","_x","_readAsDataURL","apply","arguments","_asyncToGenerator","_regeneratorRuntime","mark","_callee2","blob","buffer","data","wrap","_callee2$","_context2","prev","next","arrayBuffer","sent","btoa","String","fromCharCode","_toConsumableArray","Uint8Array","abrupt","concat","type","stop","_renderer","fullscreenQuadGeometry","fullscreenQuadMaterial","fullscreenQuad","decompress","texture","maxTextureSize","length","undefined","Infinity","renderer","PlaneGeometry","ShaderMaterial","uniforms","blitTexture","Uniform","vertexShader","fragmentShader","value","defines","IS_SRGB","colorSpace","encoding","needsUpdate","Mesh","frustrumCulled","_camera","PerspectiveCamera","_scene","Scene","add","WebGLRenderer","antialias","setSize","Math","min","image","width","height","clear","render","readableTexture","Texture","domElement","minFilter","magFilter","wrapS","wrapT","name","dispose","KHR_mesh_quantization_ExtraAttrTypes","POSITION","NORMAL","TANGENT","TEXCOORD","GLTFExporter","_classCallCheck","pluginCallbacks","register","writer","GLTFLightExtension","GLTFMaterialsUnlitExtension","GLTFMaterialsTransmissionExtension","GLTFMaterialsVolumeExtension","GLTFMaterialsIorExtension","GLTFMaterialsSpecularExtension","GLTFMaterialsClearcoatExtension","GLTFMaterialsIridescenceExtension","GLTFMaterialsSheenExtension","GLTFMaterialsAnisotropyExtension","GLTFMaterialsEmissiveStrengthExtension","_createClass","key","callback","indexOf","push","unregister","splice","parse","input","onDone","onError","options","GLTFWriter","plugins","i","il","setPlugins","write","catch","parseAsync","scope","Promise","resolve","reject","__publicField","insertKeyframe","track","time","tolerance","valueSize","getValueSize","times","TimeBufferType","values","ValueBufferType","interpolant","createInterpolant","index","abs","set","evaluate","slice","mergeMorphTargetTracks","clip","root","tracks","mergedTracks","sourceTracks","sourceTrack","sourceTrackBinding","PropertyBinding","parseTrackName","sourceTrackNode","findNode","nodeName","propertyName","propertyIndex","InterpolantFactoryMethodDiscrete","InterpolantFactoryMethodLinear","isInterpolantFactoryMethodGLTFCubicSpline","Error","console","warn","clone","setInterpolation","InterpolateLinear","targetCount","morphTargetInfluences","targetIndex","morphTargetDictionary","mergedTrack","uuid","j","sourceInterpolant","keyframeIndex","WEBGL_CONSTANTS","POINTS","LINES","LINE_LOOP","LINE_STRIP","TRIANGLES","TRIANGLE_STRIP","TRIANGLE_FAN","BYTE","UNSIGNED_BYTE","SHORT","UNSIGNED_SHORT","INT","UNSIGNED_INT","FLOAT","ARRAY_BUFFER","ELEMENT_ARRAY_BUFFER","NEAREST","LINEAR","NEAREST_MIPMAP_NEAREST","LINEAR_MIPMAP_NEAREST","NEAREST_MIPMAP_LINEAR","LINEAR_MIPMAP_LINEAR","CLAMP_TO_EDGE","MIRRORED_REPEAT","REPEAT","KHR_MESH_QUANTIZATION","THREE_TO_WEBGL","NearestFilter","NearestMipmapNearestFilter","NearestMipmapLinearFilter","LinearFilter","LinearMipmapNearestFilter","LinearMipmapLinearFilter","ClampToEdgeWrapping","RepeatWrapping","MirroredRepeatWrapping","PATH_PROPERTIES","scale","position","quaternion","DEFAULT_SPECULAR_COLOR","Color","GLB_HEADER_BYTES","GLB_HEADER_MAGIC","GLB_VERSION","GLB_CHUNK_PREFIX_BYTES","GLB_CHUNK_TYPE_JSON","GLB_CHUNK_TYPE_BIN","equalArray","array1","array2","every","element","stringToArrayBuffer","text","TextEncoder","encode","isIdentityMatrix","matrix","elements","getMinMax","attribute","start","count","output","Array","itemSize","fill","Number","POSITIVE_INFINITY","max","NEGATIVE_INFINITY","a","array","getX","getY","getZ","getW","normalized","MathUtils","normalize","getPaddedBufferSize","bufferSize","ceil","getPaddedArrayBuffer","paddingByte","paddedLength","byteLength","getCanvas","document","OffscreenCanvas","createElement","getToBlobPromise","canvas","mimeType","toBlob","quality","convertToBlob","pending","buffers","byteOffset","nodeMap","Map","skins","extensionsUsed","extensionsRequired","uids","uid","json","asset","version","generator","cache","meshes","attributes","attributesNormalized","materials","textures","images","_write","_callee","extensionsUsedList","extensionsRequiredList","_args","_callee$","_context","Object","assign","binary","trs","onlyVisible","animations","includeCustomExtensions","processInput","all","Blob","keys","size","then","result","binaryChunk","binaryChunkPrefix","DataView","ArrayBuffer","setUint32","jsonChunk","JSON","stringify","jsonChunkPrefix","header","headerView","totalByteLength","glbBlob","uri","_x2","_x3","serializeUserData","object","objectDef","userData","gltfExtensions","extensions","extensionName","extras","error","message","getUID","isRelativeCopy","has","uids2","get","isNormalizedNormalAttribute","normal","v","Vector3","fromBufferAttribute","createNormalizedNormalAttribute","x","y","z","setX","setXYZ","applyTextureTransform","mapDef","didTransform","transformDef","offset","toArray","rotation","repeat","buildMetalRoughTexture","metalnessMap","roughnessMap","getEncodingConversion","map","SRGBToLinear","c","pow","LinearToLinear","CompressedTexture","metalness","roughness","context","getContext","fillStyle","fillRect","composite","getImageData","drawImage","convert","putImageData","reference","source","channel","processBuffer","processBufferView","componentType","target","bufferViews","componentSize","dataView","setFloat32","setInt32","setInt16","setUint16","setInt8","setUint8","bufferViewDef","byteStride","id","processBufferViewImage","processAccessor","geometry","types","constructor","Float32Array","Int32Array","Uint32Array","Int16Array","Uint16Array","Int8Array","minMax","bufferViewTarget","bufferView","accessorDef","accessors","processImage","format","flipY","cachedImages","toString","imageDef","ctx","translate","RGBAFormat","Uint8ClampedArray","ImageData","bufferViewIndex","toDataURL","processSampler","samplers","samplerDef","processTexture","textureDef","sampler","_invokeAll","ext","writeTexture","processMaterial","material","isShaderMaterial","materialDef","pbrMetallicRoughness","isMeshStandardMaterial","isMeshBasicMaterial","color","opacity","baseColorFactor","metallicFactor","roughnessFactor","metalRoughTexture","metalRoughMapDef","metallicRoughnessTexture","baseColorMapDef","texCoord","baseColorTexture","emissive","maxEmissiveComponent","r","g","b","emissiveFactor","emissiveMap","emissiveMapDef","emissiveTexture","normalMap","normalMapDef","normalScale","normalTexture","aoMap","occlusionMapDef","aoMapIntensity","strength","occlusionTexture","transparent","alphaMode","alphaTest","alphaCutoff","side","DoubleSide","doubleSided","writeMaterial","processMesh","mesh","meshCacheKeyParts","isArray","l","meshCacheKey","join","mode","isLineSegments","isLineLoop","isLine","isPoints","wireframe","meshDef","primitives","targets","nameConversion","_objectSpread","uv","uv1","uv2","uv3","skinWeight","skinIndex","originalNormal","getAttribute","setAttribute","modifiedAttribute","attributeName","toUpperCase","validVertexAttributes","test","BufferAttribute","accessor","startsWith","detectMeshQuantization","weights","targetNames","reverseDictionary","warned","morphAttributes","gltfAttributeName","baseAttribute","relativeAttribute","morphTargetsRelative","jl","setY","setZ","setW","isMultiMaterial","groups","materialIndex","primitive","cacheKey","indices","writeMesh","attrType","attrNamePrefix","split","includes","processCamera","camera","cameras","isOrtho","isOrthographicCamera","cameraDef","orthographic","xmag","right","ymag","top","zfar","far","znear","near","perspective","aspectRatio","aspect","yfov","degToRad","fov","processAnimation","Utils","channels","trackBinding","trackNode","trackProperty","objectName","isSkinnedMesh","skeleton","getBoneByName","objectIndex","inputItemSize","outputItemSize","interpolation","getInterpolation","InterpolateDiscrete","node","path","processSkin","nodes","rootJoint","bones","joints","inverseBindMatrices","temporaryBoneInverse","Matrix4","copy","boneInverses","multiply","bindMatrix","skin","processNode","nodeDef","translation","matrixAutoUpdate","updateMatrix","isMesh","meshIndex","isCamera","children","child","visible","nodeIndex2","writeNode","nodeIndex","processScene","scene","scenes","sceneDef","processObjects","objects","beforeParse","objectsWithoutScene","afterParse","func","light","isLight","isDirectionalLight","isPointLight","isSpotLight","lightDef","intensity","distance","range","spot","innerConeAngle","penumbra","angle","outerConeAngle","decay","parent","lights","isMeshPhysicalMaterial","clearcoat","extensionDef","clearcoatFactor","clearcoatMap","clearcoatMapDef","clearcoatTexture","clearcoatRoughnessFactor","clearcoatRoughness","clearcoatRoughnessMap","clearcoatRoughnessMapDef","clearcoatRoughnessTexture","clearcoatNormalMap","clearcoatNormalMapDef","clearcoatNormalTexture","iridescence","iridescenceFactor","iridescenceMap","iridescenceMapDef","iridescenceTexture","iridescenceIor","iridescenceIOR","iridescenceThicknessMinimum","iridescenceThicknessRange","iridescenceThicknessMaximum","iridescenceThicknessMap","iridescenceThicknessMapDef","iridescenceThicknessTexture","transmission","transmissionFactor","transmissionMap","transmissionMapDef","transmissionTexture","thicknessFactor","thickness","thicknessMap","thicknessMapDef","thicknessTexture","attenuationDistance","attenuationColor","ior","specularIntensity","specularColor","equals","specularIntensityMap","specularColorTexture","specularIntensityMapDef","specularTexture","specularColorMap","specularColorMapDef","specularFactor","specularColorFactor","sheen","sheenRoughnessMap","sheenRoughnessMapDef","sheenRoughnessTexture","sheenColorMap","sheenColorMapDef","sheenColorTexture","sheenRoughnessFactor","sheenRoughness","sheenColorFactor","sheenColor","anisotropy","anisotropyMap","anisotropyMapDef","anisotropyTexture","anisotropyStrength","anisotropyRotation","emissiveIntensity","emissiveStrength"],"sources":["C:\\Users\\Nayyu\\Desktop\\skibidai-public-build\\node_modules\\src\\exporters\\GLTFExporter.js"],"sourcesContent":["import {\n  REVISION,\n  BufferAttribute,\n  ClampToEdgeWrapping,\n  Color,\n  DoubleSide,\n  InterpolateDiscrete,\n  InterpolateLinear,\n  LinearFilter,\n  LinearMipmapLinearFilter,\n  LinearMipmapNearestFilter,\n  MathUtils,\n  Matrix4,\n  MirroredRepeatWrapping,\n  NearestFilter,\n  NearestMipmapLinearFilter,\n  NearestMipmapNearestFilter,\n  PropertyBinding,\n  RGBAFormat,\n  RepeatWrapping,\n  Scene,\n  Texture,\n  CompressedTexture,\n  Vector3,\n  PlaneGeometry,\n  ShaderMaterial,\n  Uniform,\n  Mesh,\n  PerspectiveCamera,\n  WebGLRenderer,\n} from 'three'\nimport { version } from '../_polyfill/constants'\n\nasync function readAsDataURL(blob) {\n  const buffer = await blob.arrayBuffer()\n  const data = btoa(String.fromCharCode(...new Uint8Array(buffer)))\n  return `data:${blob.type || ''};base64,${data}`\n}\n\nlet _renderer\nlet fullscreenQuadGeometry\nlet fullscreenQuadMaterial\nlet fullscreenQuad\n\nfunction decompress(texture, maxTextureSize = Infinity, renderer = null) {\n  if (!fullscreenQuadGeometry) fullscreenQuadGeometry = new PlaneGeometry(2, 2, 1, 1)\n  if (!fullscreenQuadMaterial)\n    fullscreenQuadMaterial = new ShaderMaterial({\n      uniforms: { blitTexture: new Uniform(texture) },\n      vertexShader: /* glsl */ `\n        varying vec2 vUv;\n        void main(){\n            vUv = uv;\n            gl_Position = vec4(position.xy * 1.0,0.,.999999);\n        }\n      `,\n      fragmentShader: /* glsl */ `\n          uniform sampler2D blitTexture; \n          varying vec2 vUv;\n\n          void main(){ \n              gl_FragColor = vec4(vUv.xy, 0, 1);\n              \n              #ifdef IS_SRGB\n              gl_FragColor = LinearTosRGB( texture2D( blitTexture, vUv) );\n              #else\n              gl_FragColor = texture2D( blitTexture, vUv);\n              #endif\n          }\n      `,\n    })\n\n  fullscreenQuadMaterial.uniforms.blitTexture.value = texture\n  fullscreenQuadMaterial.defines.IS_SRGB =\n    'colorSpace' in texture ? texture.colorSpace === 'srgb' : texture.encoding === 3001\n  fullscreenQuadMaterial.needsUpdate = true\n\n  if (!fullscreenQuad) {\n    fullscreenQuad = new Mesh(fullscreenQuadGeometry, fullscreenQuadMaterial)\n    fullscreenQuad.frustrumCulled = false\n  }\n\n  const _camera = new PerspectiveCamera()\n  const _scene = new Scene()\n  _scene.add(fullscreenQuad)\n\n  if (!renderer) {\n    renderer = _renderer = new WebGLRenderer({ antialias: false })\n  }\n\n  renderer.setSize(Math.min(texture.image.width, maxTextureSize), Math.min(texture.image.height, maxTextureSize))\n  renderer.clear()\n  renderer.render(_scene, _camera)\n\n  const readableTexture = new Texture(renderer.domElement)\n\n  readableTexture.minFilter = texture.minFilter\n  readableTexture.magFilter = texture.magFilter\n  readableTexture.wrapS = texture.wrapS\n  readableTexture.wrapT = texture.wrapT\n  readableTexture.name = texture.name\n\n  if (_renderer) {\n    _renderer.dispose()\n    _renderer = null\n  }\n\n  return readableTexture\n}\n\n/**\n * The KHR_mesh_quantization extension allows these extra attribute component types\n *\n * @see https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_mesh_quantization/README.md#extending-mesh-attributes\n */\nconst KHR_mesh_quantization_ExtraAttrTypes = {\n  POSITION: [\n    'byte',\n    'byte normalized',\n    'unsigned byte',\n    'unsigned byte normalized',\n    'short',\n    'short normalized',\n    'unsigned short',\n    'unsigned short normalized',\n  ],\n  NORMAL: ['byte normalized', 'short normalized'],\n  TANGENT: ['byte normalized', 'short normalized'],\n  TEXCOORD: ['byte', 'byte normalized', 'unsigned byte', 'short', 'short normalized', 'unsigned short'],\n}\n\nclass GLTFExporter {\n  /**\n   * Static utility functions\n   */\n  static Utils = {\n    insertKeyframe: function (track, time) {\n      const tolerance = 0.001 // 1ms\n      const valueSize = track.getValueSize()\n\n      const times = new track.TimeBufferType(track.times.length + 1)\n      const values = new track.ValueBufferType(track.values.length + valueSize)\n      const interpolant = track.createInterpolant(new track.ValueBufferType(valueSize))\n\n      let index\n\n      if (track.times.length === 0) {\n        times[0] = time\n\n        for (let i = 0; i < valueSize; i++) {\n          values[i] = 0\n        }\n\n        index = 0\n      } else if (time < track.times[0]) {\n        if (Math.abs(track.times[0] - time) < tolerance) return 0\n\n        times[0] = time\n        times.set(track.times, 1)\n\n        values.set(interpolant.evaluate(time), 0)\n        values.set(track.values, valueSize)\n\n        index = 0\n      } else if (time > track.times[track.times.length - 1]) {\n        if (Math.abs(track.times[track.times.length - 1] - time) < tolerance) {\n          return track.times.length - 1\n        }\n\n        times[times.length - 1] = time\n        times.set(track.times, 0)\n\n        values.set(track.values, 0)\n        values.set(interpolant.evaluate(time), track.values.length)\n\n        index = times.length - 1\n      } else {\n        for (let i = 0; i < track.times.length; i++) {\n          if (Math.abs(track.times[i] - time) < tolerance) return i\n\n          if (track.times[i] < time && track.times[i + 1] > time) {\n            times.set(track.times.slice(0, i + 1), 0)\n            times[i + 1] = time\n            times.set(track.times.slice(i + 1), i + 2)\n\n            values.set(track.values.slice(0, (i + 1) * valueSize), 0)\n            values.set(interpolant.evaluate(time), (i + 1) * valueSize)\n            values.set(track.values.slice((i + 1) * valueSize), (i + 2) * valueSize)\n\n            index = i + 1\n\n            break\n          }\n        }\n      }\n\n      track.times = times\n      track.values = values\n\n      return index\n    },\n\n    mergeMorphTargetTracks: function (clip, root) {\n      const tracks = []\n      const mergedTracks = {}\n      const sourceTracks = clip.tracks\n\n      for (let i = 0; i < sourceTracks.length; ++i) {\n        let sourceTrack = sourceTracks[i]\n        const sourceTrackBinding = PropertyBinding.parseTrackName(sourceTrack.name)\n        const sourceTrackNode = PropertyBinding.findNode(root, sourceTrackBinding.nodeName)\n\n        if (\n          sourceTrackBinding.propertyName !== 'morphTargetInfluences' ||\n          sourceTrackBinding.propertyIndex === undefined\n        ) {\n          // Tracks that don't affect morph targets, or that affect all morph targets together, can be left as-is.\n          tracks.push(sourceTrack)\n          continue\n        }\n\n        if (\n          sourceTrack.createInterpolant !== sourceTrack.InterpolantFactoryMethodDiscrete &&\n          sourceTrack.createInterpolant !== sourceTrack.InterpolantFactoryMethodLinear\n        ) {\n          if (sourceTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline) {\n            // This should never happen, because glTF morph target animations\n            // affect all targets already.\n            throw new Error('THREE.GLTFExporter: Cannot merge tracks with glTF CUBICSPLINE interpolation.')\n          }\n\n          console.warn('THREE.GLTFExporter: Morph target interpolation mode not yet supported. Using LINEAR instead.')\n\n          sourceTrack = sourceTrack.clone()\n          sourceTrack.setInterpolation(InterpolateLinear)\n        }\n\n        const targetCount = sourceTrackNode.morphTargetInfluences.length\n        const targetIndex = sourceTrackNode.morphTargetDictionary[sourceTrackBinding.propertyIndex]\n\n        if (targetIndex === undefined) {\n          throw new Error('THREE.GLTFExporter: Morph target name not found: ' + sourceTrackBinding.propertyIndex)\n        }\n\n        let mergedTrack\n\n        // If this is the first time we've seen this object, create a new\n        // track to store merged keyframe data for each morph target.\n        if (mergedTracks[sourceTrackNode.uuid] === undefined) {\n          mergedTrack = sourceTrack.clone()\n\n          const values = new mergedTrack.ValueBufferType(targetCount * mergedTrack.times.length)\n\n          for (let j = 0; j < mergedTrack.times.length; j++) {\n            values[j * targetCount + targetIndex] = mergedTrack.values[j]\n          }\n\n          // We need to take into consideration the intended target node\n          // of our original un-merged morphTarget animation.\n          mergedTrack.name = (sourceTrackBinding.nodeName || '') + '.morphTargetInfluences'\n          mergedTrack.values = values\n\n          mergedTracks[sourceTrackNode.uuid] = mergedTrack\n          tracks.push(mergedTrack)\n\n          continue\n        }\n\n        const sourceInterpolant = sourceTrack.createInterpolant(new sourceTrack.ValueBufferType(1))\n\n        mergedTrack = mergedTracks[sourceTrackNode.uuid]\n\n        // For every existing keyframe of the merged track, write a (possibly\n        // interpolated) value from the source track.\n        for (let j = 0; j < mergedTrack.times.length; j++) {\n          mergedTrack.values[j * targetCount + targetIndex] = sourceInterpolant.evaluate(mergedTrack.times[j])\n        }\n\n        // For every existing keyframe of the source track, write a (possibly\n        // new) keyframe to the merged track. Values from the previous loop may\n        // be written again, but keyframes are de-duplicated.\n        for (let j = 0; j < sourceTrack.times.length; j++) {\n          const keyframeIndex = this.insertKeyframe(mergedTrack, sourceTrack.times[j])\n          mergedTrack.values[keyframeIndex * targetCount + targetIndex] = sourceTrack.values[j]\n        }\n      }\n\n      clip.tracks = tracks\n\n      return clip\n    },\n  }\n\n  constructor() {\n    this.pluginCallbacks = []\n\n    this.register(function (writer) {\n      return new GLTFLightExtension(writer)\n    })\n\n    this.register(function (writer) {\n      return new GLTFMaterialsUnlitExtension(writer)\n    })\n\n    this.register(function (writer) {\n      return new GLTFMaterialsTransmissionExtension(writer)\n    })\n\n    this.register(function (writer) {\n      return new GLTFMaterialsVolumeExtension(writer)\n    })\n\n    this.register(function (writer) {\n      return new GLTFMaterialsIorExtension(writer)\n    })\n\n    this.register(function (writer) {\n      return new GLTFMaterialsSpecularExtension(writer)\n    })\n\n    this.register(function (writer) {\n      return new GLTFMaterialsClearcoatExtension(writer)\n    })\n\n    this.register(function (writer) {\n      return new GLTFMaterialsIridescenceExtension(writer)\n    })\n\n    this.register(function (writer) {\n      return new GLTFMaterialsSheenExtension(writer)\n    })\n\n    this.register(function (writer) {\n      return new GLTFMaterialsAnisotropyExtension(writer)\n    })\n\n    this.register(function (writer) {\n      return new GLTFMaterialsEmissiveStrengthExtension(writer)\n    })\n  }\n\n  register(callback) {\n    if (this.pluginCallbacks.indexOf(callback) === -1) {\n      this.pluginCallbacks.push(callback)\n    }\n\n    return this\n  }\n\n  unregister(callback) {\n    if (this.pluginCallbacks.indexOf(callback) !== -1) {\n      this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(callback), 1)\n    }\n\n    return this\n  }\n\n  /**\n   * Parse scenes and generate GLTF output\n   * @param  {Scene or [THREE.Scenes]} input   Scene or Array of THREE.Scenes\n   * @param  {Function} onDone  Callback on completed\n   * @param  {Function} onError  Callback on errors\n   * @param  {Object} options options\n   */\n  parse(input, onDone, onError, options) {\n    const writer = new GLTFWriter()\n    const plugins = []\n\n    for (let i = 0, il = this.pluginCallbacks.length; i < il; i++) {\n      plugins.push(this.pluginCallbacks[i](writer))\n    }\n\n    writer.setPlugins(plugins)\n    writer.write(input, onDone, options).catch(onError)\n  }\n\n  parseAsync(input, options) {\n    const scope = this\n\n    return new Promise(function (resolve, reject) {\n      scope.parse(input, resolve, reject, options)\n    })\n  }\n}\n\n//------------------------------------------------------------------------------\n// Constants\n//------------------------------------------------------------------------------\n\nconst WEBGL_CONSTANTS = {\n  POINTS: 0x0000,\n  LINES: 0x0001,\n  LINE_LOOP: 0x0002,\n  LINE_STRIP: 0x0003,\n  TRIANGLES: 0x0004,\n  TRIANGLE_STRIP: 0x0005,\n  TRIANGLE_FAN: 0x0006,\n\n  BYTE: 0x1400,\n  UNSIGNED_BYTE: 0x1401,\n  SHORT: 0x1402,\n  UNSIGNED_SHORT: 0x1403,\n  INT: 0x1404,\n  UNSIGNED_INT: 0x1405,\n  FLOAT: 0x1406,\n\n  ARRAY_BUFFER: 0x8892,\n  ELEMENT_ARRAY_BUFFER: 0x8893,\n\n  NEAREST: 0x2600,\n  LINEAR: 0x2601,\n  NEAREST_MIPMAP_NEAREST: 0x2700,\n  LINEAR_MIPMAP_NEAREST: 0x2701,\n  NEAREST_MIPMAP_LINEAR: 0x2702,\n  LINEAR_MIPMAP_LINEAR: 0x2703,\n\n  CLAMP_TO_EDGE: 33071,\n  MIRRORED_REPEAT: 33648,\n  REPEAT: 10497,\n}\n\nconst KHR_MESH_QUANTIZATION = 'KHR_mesh_quantization'\n\nconst THREE_TO_WEBGL = {}\n\nTHREE_TO_WEBGL[NearestFilter] = WEBGL_CONSTANTS.NEAREST\nTHREE_TO_WEBGL[NearestMipmapNearestFilter] = WEBGL_CONSTANTS.NEAREST_MIPMAP_NEAREST\nTHREE_TO_WEBGL[NearestMipmapLinearFilter] = WEBGL_CONSTANTS.NEAREST_MIPMAP_LINEAR\nTHREE_TO_WEBGL[LinearFilter] = WEBGL_CONSTANTS.LINEAR\nTHREE_TO_WEBGL[LinearMipmapNearestFilter] = WEBGL_CONSTANTS.LINEAR_MIPMAP_NEAREST\nTHREE_TO_WEBGL[LinearMipmapLinearFilter] = WEBGL_CONSTANTS.LINEAR_MIPMAP_LINEAR\n\nTHREE_TO_WEBGL[ClampToEdgeWrapping] = WEBGL_CONSTANTS.CLAMP_TO_EDGE\nTHREE_TO_WEBGL[RepeatWrapping] = WEBGL_CONSTANTS.REPEAT\nTHREE_TO_WEBGL[MirroredRepeatWrapping] = WEBGL_CONSTANTS.MIRRORED_REPEAT\n\nconst PATH_PROPERTIES = {\n  scale: 'scale',\n  position: 'translation',\n  quaternion: 'rotation',\n  morphTargetInfluences: 'weights',\n}\n\nconst DEFAULT_SPECULAR_COLOR = new Color()\n\n// GLB constants\n// https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#glb-file-format-specification\n\nconst GLB_HEADER_BYTES = 12\nconst GLB_HEADER_MAGIC = 0x46546c67\nconst GLB_VERSION = 2\n\nconst GLB_CHUNK_PREFIX_BYTES = 8\nconst GLB_CHUNK_TYPE_JSON = 0x4e4f534a\nconst GLB_CHUNK_TYPE_BIN = 0x004e4942\n\n//------------------------------------------------------------------------------\n// Utility functions\n//------------------------------------------------------------------------------\n\n/**\n * Compare two arrays\n * @param  {Array} array1 Array 1 to compare\n * @param  {Array} array2 Array 2 to compare\n * @return {Boolean}        Returns true if both arrays are equal\n */\nfunction equalArray(array1, array2) {\n  return (\n    array1.length === array2.length &&\n    array1.every(function (element, index) {\n      return element === array2[index]\n    })\n  )\n}\n\n/**\n * Converts a string to an ArrayBuffer.\n * @param  {string} text\n * @return {ArrayBuffer}\n */\nfunction stringToArrayBuffer(text) {\n  return new TextEncoder().encode(text).buffer\n}\n\n/**\n * Is identity matrix\n *\n * @param {Matrix4} matrix\n * @returns {Boolean} Returns true, if parameter is identity matrix\n */\nfunction isIdentityMatrix(matrix) {\n  return equalArray(matrix.elements, [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1])\n}\n\n/**\n * Get the min and max vectors from the given attribute\n * @param  {BufferAttribute} attribute Attribute to find the min/max in range from start to start + count\n * @param  {Integer} start\n * @param  {Integer} count\n * @return {Object} Object containing the `min` and `max` values (As an array of attribute.itemSize components)\n */\nfunction getMinMax(attribute, start, count) {\n  const output = {\n    min: new Array(attribute.itemSize).fill(Number.POSITIVE_INFINITY),\n    max: new Array(attribute.itemSize).fill(Number.NEGATIVE_INFINITY),\n  }\n\n  for (let i = start; i < start + count; i++) {\n    for (let a = 0; a < attribute.itemSize; a++) {\n      let value\n\n      if (attribute.itemSize > 4) {\n        // no support for interleaved data for itemSize > 4\n\n        value = attribute.array[i * attribute.itemSize + a]\n      } else {\n        if (a === 0) value = attribute.getX(i)\n        else if (a === 1) value = attribute.getY(i)\n        else if (a === 2) value = attribute.getZ(i)\n        else if (a === 3) value = attribute.getW(i)\n\n        if (attribute.normalized === true) {\n          value = MathUtils.normalize(value, attribute.array)\n        }\n      }\n\n      output.min[a] = Math.min(output.min[a], value)\n      output.max[a] = Math.max(output.max[a], value)\n    }\n  }\n\n  return output\n}\n\n/**\n * Get the required size + padding for a buffer, rounded to the next 4-byte boundary.\n * https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#data-alignment\n *\n * @param {Integer} bufferSize The size the original buffer.\n * @returns {Integer} new buffer size with required padding.\n *\n */\nfunction getPaddedBufferSize(bufferSize) {\n  return Math.ceil(bufferSize / 4) * 4\n}\n\n/**\n * Returns a buffer aligned to 4-byte boundary.\n *\n * @param {ArrayBuffer} arrayBuffer Buffer to pad\n * @param {Integer} paddingByte (Optional)\n * @returns {ArrayBuffer} The same buffer if it's already aligned to 4-byte boundary or a new buffer\n */\nfunction getPaddedArrayBuffer(arrayBuffer, paddingByte = 0) {\n  const paddedLength = getPaddedBufferSize(arrayBuffer.byteLength)\n\n  if (paddedLength !== arrayBuffer.byteLength) {\n    const array = new Uint8Array(paddedLength)\n    array.set(new Uint8Array(arrayBuffer))\n\n    if (paddingByte !== 0) {\n      for (let i = arrayBuffer.byteLength; i < paddedLength; i++) {\n        array[i] = paddingByte\n      }\n    }\n\n    return array.buffer\n  }\n\n  return arrayBuffer\n}\n\nfunction getCanvas() {\n  if (typeof document === 'undefined' && typeof OffscreenCanvas !== 'undefined') {\n    return new OffscreenCanvas(1, 1)\n  }\n\n  return document.createElement('canvas')\n}\n\nfunction getToBlobPromise(canvas, mimeType) {\n  if (canvas.toBlob !== undefined) {\n    return new Promise((resolve) => canvas.toBlob(resolve, mimeType))\n  }\n\n  let quality\n\n  // Blink's implementation of convertToBlob seems to default to a quality level of 100%\n  // Use the Blink default quality levels of toBlob instead so that file sizes are comparable.\n  if (mimeType === 'image/jpeg') {\n    quality = 0.92\n  } else if (mimeType === 'image/webp') {\n    quality = 0.8\n  }\n\n  return canvas.convertToBlob({\n    type: mimeType,\n    quality: quality,\n  })\n}\n\n/**\n * Writer\n */\nclass GLTFWriter {\n  constructor() {\n    this.plugins = []\n\n    this.options = {}\n    this.pending = []\n    this.buffers = []\n\n    this.byteOffset = 0\n    this.buffers = []\n    this.nodeMap = new Map()\n    this.skins = []\n\n    this.extensionsUsed = {}\n    this.extensionsRequired = {}\n\n    this.uids = new Map()\n    this.uid = 0\n\n    this.json = {\n      asset: {\n        version: '2.0',\n        generator: 'THREE.GLTFExporter',\n      },\n    }\n\n    this.cache = {\n      meshes: new Map(),\n      attributes: new Map(),\n      attributesNormalized: new Map(),\n      materials: new Map(),\n      textures: new Map(),\n      images: new Map(),\n    }\n  }\n\n  setPlugins(plugins) {\n    this.plugins = plugins\n  }\n\n  /**\n   * Parse scenes and generate GLTF output\n   * @param  {Scene or [THREE.Scenes]} input   Scene or Array of THREE.Scenes\n   * @param  {Function} onDone  Callback on completed\n   * @param  {Object} options options\n   */\n  async write(input, onDone, options = {}) {\n    this.options = Object.assign(\n      {\n        // default options\n        binary: false,\n        trs: false,\n        onlyVisible: true,\n        maxTextureSize: Infinity,\n        animations: [],\n        includeCustomExtensions: false,\n      },\n      options,\n    )\n\n    if (this.options.animations.length > 0) {\n      // Only TRS properties, and not matrices, may be targeted by animation.\n      this.options.trs = true\n    }\n\n    this.processInput(input)\n\n    await Promise.all(this.pending)\n\n    const writer = this\n    const buffers = writer.buffers\n    const json = writer.json\n    options = writer.options\n\n    const extensionsUsed = writer.extensionsUsed\n    const extensionsRequired = writer.extensionsRequired\n\n    // Merge buffers.\n    const blob = new Blob(buffers, { type: 'application/octet-stream' })\n\n    // Declare extensions.\n    const extensionsUsedList = Object.keys(extensionsUsed)\n    const extensionsRequiredList = Object.keys(extensionsRequired)\n\n    if (extensionsUsedList.length > 0) json.extensionsUsed = extensionsUsedList\n    if (extensionsRequiredList.length > 0) json.extensionsRequired = extensionsRequiredList\n\n    // Update bytelength of the single buffer.\n    if (json.buffers && json.buffers.length > 0) json.buffers[0].byteLength = blob.size\n\n    if (options.binary === true) {\n      // https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#glb-file-format-specification\n\n      blob.arrayBuffer().then((result) => {\n        // Binary chunk.\n        const binaryChunk = getPaddedArrayBuffer(result)\n        const binaryChunkPrefix = new DataView(new ArrayBuffer(GLB_CHUNK_PREFIX_BYTES))\n        binaryChunkPrefix.setUint32(0, binaryChunk.byteLength, true)\n        binaryChunkPrefix.setUint32(4, GLB_CHUNK_TYPE_BIN, true)\n\n        // JSON chunk.\n        const jsonChunk = getPaddedArrayBuffer(stringToArrayBuffer(JSON.stringify(json)), 0x20)\n        const jsonChunkPrefix = new DataView(new ArrayBuffer(GLB_CHUNK_PREFIX_BYTES))\n        jsonChunkPrefix.setUint32(0, jsonChunk.byteLength, true)\n        jsonChunkPrefix.setUint32(4, GLB_CHUNK_TYPE_JSON, true)\n\n        // GLB header.\n        const header = new ArrayBuffer(GLB_HEADER_BYTES)\n        const headerView = new DataView(header)\n        headerView.setUint32(0, GLB_HEADER_MAGIC, true)\n        headerView.setUint32(4, GLB_VERSION, true)\n        const totalByteLength =\n          GLB_HEADER_BYTES +\n          jsonChunkPrefix.byteLength +\n          jsonChunk.byteLength +\n          binaryChunkPrefix.byteLength +\n          binaryChunk.byteLength\n        headerView.setUint32(8, totalByteLength, true)\n\n        const glbBlob = new Blob([header, jsonChunkPrefix, jsonChunk, binaryChunkPrefix, binaryChunk], {\n          type: 'application/octet-stream',\n        })\n\n        glbBlob.arrayBuffer().then(onDone)\n      })\n    } else {\n      if (json.buffers && json.buffers.length > 0) {\n        readAsDataURL(blob).then((uri) => {\n          json.buffers[0].uri = uri\n          onDone(json)\n        })\n      } else {\n        onDone(json)\n      }\n    }\n  }\n\n  /**\n   * Serializes a userData.\n   *\n   * @param {THREE.Object3D|THREE.Material} object\n   * @param {Object} objectDef\n   */\n  serializeUserData(object, objectDef) {\n    if (Object.keys(object.userData).length === 0) return\n\n    const options = this.options\n    const extensionsUsed = this.extensionsUsed\n\n    try {\n      const json = JSON.parse(JSON.stringify(object.userData))\n\n      if (options.includeCustomExtensions && json.gltfExtensions) {\n        if (objectDef.extensions === undefined) objectDef.extensions = {}\n\n        for (const extensionName in json.gltfExtensions) {\n          objectDef.extensions[extensionName] = json.gltfExtensions[extensionName]\n          extensionsUsed[extensionName] = true\n        }\n\n        delete json.gltfExtensions\n      }\n\n      if (Object.keys(json).length > 0) objectDef.extras = json\n    } catch (error) {\n      console.warn(\n        \"THREE.GLTFExporter: userData of '\" +\n          object.name +\n          \"' \" +\n          \"won't be serialized because of JSON.stringify error - \" +\n          error.message,\n      )\n    }\n  }\n\n  /**\n   * Returns ids for buffer attributes.\n   * @param  {Object} object\n   * @return {Integer}\n   */\n  getUID(attribute, isRelativeCopy = false) {\n    if (this.uids.has(attribute) === false) {\n      const uids = new Map()\n\n      uids.set(true, this.uid++)\n      uids.set(false, this.uid++)\n\n      this.uids.set(attribute, uids)\n    }\n\n    const uids = this.uids.get(attribute)\n\n    return uids.get(isRelativeCopy)\n  }\n\n  /**\n   * Checks if normal attribute values are normalized.\n   *\n   * @param {BufferAttribute} normal\n   * @returns {Boolean}\n   */\n  isNormalizedNormalAttribute(normal) {\n    const cache = this.cache\n\n    if (cache.attributesNormalized.has(normal)) return false\n\n    const v = new Vector3()\n\n    for (let i = 0, il = normal.count; i < il; i++) {\n      // 0.0005 is from glTF-validator\n      if (Math.abs(v.fromBufferAttribute(normal, i).length() - 1.0) > 0.0005) return false\n    }\n\n    return true\n  }\n\n  /**\n   * Creates normalized normal buffer attribute.\n   *\n   * @param {BufferAttribute} normal\n   * @returns {BufferAttribute}\n   *\n   */\n  createNormalizedNormalAttribute(normal) {\n    const cache = this.cache\n\n    if (cache.attributesNormalized.has(normal)) return cache.attributesNormalized.get(normal)\n\n    const attribute = normal.clone()\n    const v = new Vector3()\n\n    for (let i = 0, il = attribute.count; i < il; i++) {\n      v.fromBufferAttribute(attribute, i)\n\n      if (v.x === 0 && v.y === 0 && v.z === 0) {\n        // if values can't be normalized set (1, 0, 0)\n        v.setX(1.0)\n      } else {\n        v.normalize()\n      }\n\n      attribute.setXYZ(i, v.x, v.y, v.z)\n    }\n\n    cache.attributesNormalized.set(normal, attribute)\n\n    return attribute\n  }\n\n  /**\n   * Applies a texture transform, if present, to the map definition. Requires\n   * the KHR_texture_transform extension.\n   *\n   * @param {Object} mapDef\n   * @param {THREE.Texture} texture\n   */\n  applyTextureTransform(mapDef, texture) {\n    let didTransform = false\n    const transformDef = {}\n\n    if (texture.offset.x !== 0 || texture.offset.y !== 0) {\n      transformDef.offset = texture.offset.toArray()\n      didTransform = true\n    }\n\n    if (texture.rotation !== 0) {\n      transformDef.rotation = texture.rotation\n      didTransform = true\n    }\n\n    if (texture.repeat.x !== 1 || texture.repeat.y !== 1) {\n      transformDef.scale = texture.repeat.toArray()\n      didTransform = true\n    }\n\n    if (didTransform) {\n      mapDef.extensions = mapDef.extensions || {}\n      mapDef.extensions['KHR_texture_transform'] = transformDef\n      this.extensionsUsed['KHR_texture_transform'] = true\n    }\n  }\n\n  buildMetalRoughTexture(metalnessMap, roughnessMap) {\n    if (metalnessMap === roughnessMap) return metalnessMap\n\n    function getEncodingConversion(map) {\n      if ('colorSpace' in map ? map.colorSpace === 'srgb' : map.encoding === 3001) {\n        return function SRGBToLinear(c) {\n          return c < 0.04045 ? c * 0.0773993808 : Math.pow(c * 0.9478672986 + 0.0521327014, 2.4)\n        }\n      }\n\n      return function LinearToLinear(c) {\n        return c\n      }\n    }\n\n    console.warn('THREE.GLTFExporter: Merged metalnessMap and roughnessMap textures.')\n\n    if (metalnessMap instanceof CompressedTexture) {\n      metalnessMap = decompress(metalnessMap)\n    }\n\n    if (roughnessMap instanceof CompressedTexture) {\n      roughnessMap = decompress(roughnessMap)\n    }\n\n    const metalness = metalnessMap ? metalnessMap.image : null\n    const roughness = roughnessMap ? roughnessMap.image : null\n\n    const width = Math.max(metalness ? metalness.width : 0, roughness ? roughness.width : 0)\n    const height = Math.max(metalness ? metalness.height : 0, roughness ? roughness.height : 0)\n\n    const canvas = getCanvas()\n    canvas.width = width\n    canvas.height = height\n\n    const context = canvas.getContext('2d')\n    context.fillStyle = '#00ffff'\n    context.fillRect(0, 0, width, height)\n\n    const composite = context.getImageData(0, 0, width, height)\n\n    if (metalness) {\n      context.drawImage(metalness, 0, 0, width, height)\n\n      const convert = getEncodingConversion(metalnessMap)\n      const data = context.getImageData(0, 0, width, height).data\n\n      for (let i = 2; i < data.length; i += 4) {\n        composite.data[i] = convert(data[i] / 256) * 256\n      }\n    }\n\n    if (roughness) {\n      context.drawImage(roughness, 0, 0, width, height)\n\n      const convert = getEncodingConversion(roughnessMap)\n      const data = context.getImageData(0, 0, width, height).data\n\n      for (let i = 1; i < data.length; i += 4) {\n        composite.data[i] = convert(data[i] / 256) * 256\n      }\n    }\n\n    context.putImageData(composite, 0, 0)\n\n    //\n\n    const reference = metalnessMap || roughnessMap\n\n    const texture = reference.clone()\n\n    // TODO Use new Source() instead?\n    texture.source = new Texture(canvas).source\n    if ('colorSpace' in texture) texture.colorSpace = ''\n    else texture.encoding = 3000\n    texture.channel = (metalnessMap || roughnessMap).channel\n\n    if (metalnessMap && roughnessMap && metalnessMap.channel !== roughnessMap.channel) {\n      console.warn('THREE.GLTFExporter: UV channels for metalnessMap and roughnessMap textures must match.')\n    }\n\n    return texture\n  }\n\n  /**\n   * Process a buffer to append to the default one.\n   * @param  {ArrayBuffer} buffer\n   * @return {Integer}\n   */\n  processBuffer(buffer) {\n    const json = this.json\n    const buffers = this.buffers\n\n    if (!json.buffers) json.buffers = [{ byteLength: 0 }]\n\n    // All buffers are merged before export.\n    buffers.push(buffer)\n\n    return 0\n  }\n\n  /**\n   * Process and generate a BufferView\n   * @param  {BufferAttribute} attribute\n   * @param  {number} componentType\n   * @param  {number} start\n   * @param  {number} count\n   * @param  {number} target (Optional) Target usage of the BufferView\n   * @return {Object}\n   */\n  processBufferView(attribute, componentType, start, count, target) {\n    const json = this.json\n\n    if (!json.bufferViews) json.bufferViews = []\n\n    // Create a new dataview and dump the attribute's array into it\n\n    let componentSize\n\n    switch (componentType) {\n      case WEBGL_CONSTANTS.BYTE:\n      case WEBGL_CONSTANTS.UNSIGNED_BYTE:\n        componentSize = 1\n\n        break\n\n      case WEBGL_CONSTANTS.SHORT:\n      case WEBGL_CONSTANTS.UNSIGNED_SHORT:\n        componentSize = 2\n\n        break\n\n      default:\n        componentSize = 4\n    }\n\n    const byteLength = getPaddedBufferSize(count * attribute.itemSize * componentSize)\n    const dataView = new DataView(new ArrayBuffer(byteLength))\n    let offset = 0\n\n    for (let i = start; i < start + count; i++) {\n      for (let a = 0; a < attribute.itemSize; a++) {\n        let value\n\n        if (attribute.itemSize > 4) {\n          // no support for interleaved data for itemSize > 4\n\n          value = attribute.array[i * attribute.itemSize + a]\n        } else {\n          if (a === 0) value = attribute.getX(i)\n          else if (a === 1) value = attribute.getY(i)\n          else if (a === 2) value = attribute.getZ(i)\n          else if (a === 3) value = attribute.getW(i)\n\n          if (attribute.normalized === true) {\n            value = MathUtils.normalize(value, attribute.array)\n          }\n        }\n\n        if (componentType === WEBGL_CONSTANTS.FLOAT) {\n          dataView.setFloat32(offset, value, true)\n        } else if (componentType === WEBGL_CONSTANTS.INT) {\n          dataView.setInt32(offset, value, true)\n        } else if (componentType === WEBGL_CONSTANTS.UNSIGNED_INT) {\n          dataView.setUint32(offset, value, true)\n        } else if (componentType === WEBGL_CONSTANTS.SHORT) {\n          dataView.setInt16(offset, value, true)\n        } else if (componentType === WEBGL_CONSTANTS.UNSIGNED_SHORT) {\n          dataView.setUint16(offset, value, true)\n        } else if (componentType === WEBGL_CONSTANTS.BYTE) {\n          dataView.setInt8(offset, value)\n        } else if (componentType === WEBGL_CONSTANTS.UNSIGNED_BYTE) {\n          dataView.setUint8(offset, value)\n        }\n\n        offset += componentSize\n      }\n    }\n\n    const bufferViewDef = {\n      buffer: this.processBuffer(dataView.buffer),\n      byteOffset: this.byteOffset,\n      byteLength: byteLength,\n    }\n\n    if (target !== undefined) bufferViewDef.target = target\n\n    if (target === WEBGL_CONSTANTS.ARRAY_BUFFER) {\n      // Only define byteStride for vertex attributes.\n      bufferViewDef.byteStride = attribute.itemSize * componentSize\n    }\n\n    this.byteOffset += byteLength\n\n    json.bufferViews.push(bufferViewDef)\n\n    // @TODO Merge bufferViews where possible.\n    const output = {\n      id: json.bufferViews.length - 1,\n      byteLength: 0,\n    }\n\n    return output\n  }\n\n  /**\n   * Process and generate a BufferView from an image Blob.\n   * @param {Blob} blob\n   * @return {Promise<Integer>}\n   */\n  processBufferViewImage(blob) {\n    const writer = this\n    const json = writer.json\n\n    if (!json.bufferViews) json.bufferViews = []\n\n    return blob.arrayBuffer().then((result) => {\n      const buffer = getPaddedArrayBuffer(result)\n\n      const bufferViewDef = {\n        buffer: writer.processBuffer(buffer),\n        byteOffset: writer.byteOffset,\n        byteLength: buffer.byteLength,\n      }\n\n      writer.byteOffset += buffer.byteLength\n      return json.bufferViews.push(bufferViewDef) - 1\n    })\n  }\n\n  /**\n   * Process attribute to generate an accessor\n   * @param  {BufferAttribute} attribute Attribute to process\n   * @param  {THREE.BufferGeometry} geometry (Optional) Geometry used for truncated draw range\n   * @param  {Integer} start (Optional)\n   * @param  {Integer} count (Optional)\n   * @return {Integer|null} Index of the processed accessor on the \"accessors\" array\n   */\n  processAccessor(attribute, geometry, start, count) {\n    const json = this.json\n\n    const types = {\n      1: 'SCALAR',\n      2: 'VEC2',\n      3: 'VEC3',\n      4: 'VEC4',\n      9: 'MAT3',\n      16: 'MAT4',\n    }\n\n    let componentType\n\n    // Detect the component type of the attribute array\n    if (attribute.array.constructor === Float32Array) {\n      componentType = WEBGL_CONSTANTS.FLOAT\n    } else if (attribute.array.constructor === Int32Array) {\n      componentType = WEBGL_CONSTANTS.INT\n    } else if (attribute.array.constructor === Uint32Array) {\n      componentType = WEBGL_CONSTANTS.UNSIGNED_INT\n    } else if (attribute.array.constructor === Int16Array) {\n      componentType = WEBGL_CONSTANTS.SHORT\n    } else if (attribute.array.constructor === Uint16Array) {\n      componentType = WEBGL_CONSTANTS.UNSIGNED_SHORT\n    } else if (attribute.array.constructor === Int8Array) {\n      componentType = WEBGL_CONSTANTS.BYTE\n    } else if (attribute.array.constructor === Uint8Array) {\n      componentType = WEBGL_CONSTANTS.UNSIGNED_BYTE\n    } else {\n      throw new Error(\n        'THREE.GLTFExporter: Unsupported bufferAttribute component type: ' + attribute.array.constructor.name,\n      )\n    }\n\n    if (start === undefined) start = 0\n    if (count === undefined) count = attribute.count\n\n    // Skip creating an accessor if the attribute doesn't have data to export\n    if (count === 0) return null\n\n    const minMax = getMinMax(attribute, start, count)\n    let bufferViewTarget\n\n    // If geometry isn't provided, don't infer the target usage of the bufferView. For\n    // animation samplers, target must not be set.\n    if (geometry !== undefined) {\n      bufferViewTarget =\n        attribute === geometry.index ? WEBGL_CONSTANTS.ELEMENT_ARRAY_BUFFER : WEBGL_CONSTANTS.ARRAY_BUFFER\n    }\n\n    const bufferView = this.processBufferView(attribute, componentType, start, count, bufferViewTarget)\n\n    const accessorDef = {\n      bufferView: bufferView.id,\n      byteOffset: bufferView.byteOffset,\n      componentType: componentType,\n      count: count,\n      max: minMax.max,\n      min: minMax.min,\n      type: types[attribute.itemSize],\n    }\n\n    if (attribute.normalized === true) accessorDef.normalized = true\n    if (!json.accessors) json.accessors = []\n\n    return json.accessors.push(accessorDef) - 1\n  }\n\n  /**\n   * Process image\n   * @param  {Image} image to process\n   * @param  {Integer} format of the image (RGBAFormat)\n   * @param  {Boolean} flipY before writing out the image\n   * @param  {String} mimeType export format\n   * @return {Integer}     Index of the processed texture in the \"images\" array\n   */\n  processImage(image, format, flipY, mimeType = 'image/png') {\n    if (image !== null) {\n      const writer = this\n      const cache = writer.cache\n      const json = writer.json\n      const options = writer.options\n      const pending = writer.pending\n\n      if (!cache.images.has(image)) cache.images.set(image, {})\n\n      const cachedImages = cache.images.get(image)\n\n      const key = mimeType + ':flipY/' + flipY.toString()\n\n      if (cachedImages[key] !== undefined) return cachedImages[key]\n\n      if (!json.images) json.images = []\n\n      const imageDef = { mimeType: mimeType }\n\n      const canvas = getCanvas()\n\n      canvas.width = Math.min(image.width, options.maxTextureSize)\n      canvas.height = Math.min(image.height, options.maxTextureSize)\n\n      const ctx = canvas.getContext('2d')\n\n      if (flipY === true) {\n        ctx.translate(0, canvas.height)\n        ctx.scale(1, -1)\n      }\n\n      if (image.data !== undefined) {\n        // THREE.DataTexture\n\n        if (format !== RGBAFormat) {\n          console.error('GLTFExporter: Only RGBAFormat is supported.', format)\n        }\n\n        if (image.width > options.maxTextureSize || image.height > options.maxTextureSize) {\n          console.warn('GLTFExporter: Image size is bigger than maxTextureSize', image)\n        }\n\n        const data = new Uint8ClampedArray(image.height * image.width * 4)\n\n        for (let i = 0; i < data.length; i += 4) {\n          data[i + 0] = image.data[i + 0]\n          data[i + 1] = image.data[i + 1]\n          data[i + 2] = image.data[i + 2]\n          data[i + 3] = image.data[i + 3]\n        }\n\n        ctx.putImageData(new ImageData(data, image.width, image.height), 0, 0)\n      } else {\n        ctx.drawImage(image, 0, 0, canvas.width, canvas.height)\n      }\n\n      if (options.binary === true) {\n        pending.push(\n          getToBlobPromise(canvas, mimeType)\n            .then((blob) => writer.processBufferViewImage(blob))\n            .then((bufferViewIndex) => {\n              imageDef.bufferView = bufferViewIndex\n            }),\n        )\n      } else {\n        if (canvas.toDataURL !== undefined) {\n          imageDef.uri = canvas.toDataURL(mimeType)\n        } else {\n          pending.push(\n            getToBlobPromise(canvas, mimeType)\n              .then(readAsDataURL)\n              .then((uri) => {\n                imageDef.uri = uri\n              }),\n          )\n        }\n      }\n\n      const index = json.images.push(imageDef) - 1\n      cachedImages[key] = index\n      return index\n    } else {\n      throw new Error('THREE.GLTFExporter: No valid image data found. Unable to process texture.')\n    }\n  }\n\n  /**\n   * Process sampler\n   * @param  {Texture} map Texture to process\n   * @return {Integer}     Index of the processed texture in the \"samplers\" array\n   */\n  processSampler(map) {\n    const json = this.json\n\n    if (!json.samplers) json.samplers = []\n\n    const samplerDef = {\n      magFilter: THREE_TO_WEBGL[map.magFilter],\n      minFilter: THREE_TO_WEBGL[map.minFilter],\n      wrapS: THREE_TO_WEBGL[map.wrapS],\n      wrapT: THREE_TO_WEBGL[map.wrapT],\n    }\n\n    return json.samplers.push(samplerDef) - 1\n  }\n\n  /**\n   * Process texture\n   * @param  {Texture} map Map to process\n   * @return {Integer} Index of the processed texture in the \"textures\" array\n   */\n  processTexture(map) {\n    const writer = this\n    const options = writer.options\n    const cache = this.cache\n    const json = this.json\n\n    if (cache.textures.has(map)) return cache.textures.get(map)\n\n    if (!json.textures) json.textures = []\n\n    // make non-readable textures (e.g. CompressedTexture) readable by blitting them into a new texture\n    if (map instanceof CompressedTexture) {\n      map = decompress(map, options.maxTextureSize)\n    }\n\n    let mimeType = map.userData.mimeType\n\n    if (mimeType === 'image/webp') mimeType = 'image/png'\n\n    const textureDef = {\n      sampler: this.processSampler(map),\n      source: this.processImage(map.image, map.format, map.flipY, mimeType),\n    }\n\n    if (map.name) textureDef.name = map.name\n\n    this._invokeAll(function (ext) {\n      ext.writeTexture && ext.writeTexture(map, textureDef)\n    })\n\n    const index = json.textures.push(textureDef) - 1\n    cache.textures.set(map, index)\n    return index\n  }\n\n  /**\n   * Process material\n   * @param  {THREE.Material} material Material to process\n   * @return {Integer|null} Index of the processed material in the \"materials\" array\n   */\n  processMaterial(material) {\n    const cache = this.cache\n    const json = this.json\n\n    if (cache.materials.has(material)) return cache.materials.get(material)\n\n    if (material.isShaderMaterial) {\n      console.warn('GLTFExporter: THREE.ShaderMaterial not supported.')\n      return null\n    }\n\n    if (!json.materials) json.materials = []\n\n    // @QUESTION Should we avoid including any attribute that has the default value?\n    const materialDef = { pbrMetallicRoughness: {} }\n\n    if (material.isMeshStandardMaterial !== true && material.isMeshBasicMaterial !== true) {\n      console.warn('GLTFExporter: Use MeshStandardMaterial or MeshBasicMaterial for best results.')\n    }\n\n    // pbrMetallicRoughness.baseColorFactor\n    const color = material.color.toArray().concat([material.opacity])\n\n    if (!equalArray(color, [1, 1, 1, 1])) {\n      materialDef.pbrMetallicRoughness.baseColorFactor = color\n    }\n\n    if (material.isMeshStandardMaterial) {\n      materialDef.pbrMetallicRoughness.metallicFactor = material.metalness\n      materialDef.pbrMetallicRoughness.roughnessFactor = material.roughness\n    } else {\n      materialDef.pbrMetallicRoughness.metallicFactor = 0.5\n      materialDef.pbrMetallicRoughness.roughnessFactor = 0.5\n    }\n\n    // pbrMetallicRoughness.metallicRoughnessTexture\n    if (material.metalnessMap || material.roughnessMap) {\n      const metalRoughTexture = this.buildMetalRoughTexture(material.metalnessMap, material.roughnessMap)\n\n      const metalRoughMapDef = {\n        index: this.processTexture(metalRoughTexture),\n        channel: metalRoughTexture.channel,\n      }\n      this.applyTextureTransform(metalRoughMapDef, metalRoughTexture)\n      materialDef.pbrMetallicRoughness.metallicRoughnessTexture = metalRoughMapDef\n    }\n\n    // pbrMetallicRoughness.baseColorTexture\n    if (material.map) {\n      const baseColorMapDef = {\n        index: this.processTexture(material.map),\n        texCoord: material.map.channel,\n      }\n      this.applyTextureTransform(baseColorMapDef, material.map)\n      materialDef.pbrMetallicRoughness.baseColorTexture = baseColorMapDef\n    }\n\n    if (material.emissive) {\n      const emissive = material.emissive\n      const maxEmissiveComponent = Math.max(emissive.r, emissive.g, emissive.b)\n\n      if (maxEmissiveComponent > 0) {\n        materialDef.emissiveFactor = material.emissive.toArray()\n      }\n\n      // emissiveTexture\n      if (material.emissiveMap) {\n        const emissiveMapDef = {\n          index: this.processTexture(material.emissiveMap),\n          texCoord: material.emissiveMap.channel,\n        }\n        this.applyTextureTransform(emissiveMapDef, material.emissiveMap)\n        materialDef.emissiveTexture = emissiveMapDef\n      }\n    }\n\n    // normalTexture\n    if (material.normalMap) {\n      const normalMapDef = {\n        index: this.processTexture(material.normalMap),\n        texCoord: material.normalMap.channel,\n      }\n\n      if (material.normalScale && material.normalScale.x !== 1) {\n        // glTF normal scale is univariate. Ignore `y`, which may be flipped.\n        // Context: https://github.com/mrdoob/three.js/issues/11438#issuecomment-507003995\n        normalMapDef.scale = material.normalScale.x\n      }\n\n      this.applyTextureTransform(normalMapDef, material.normalMap)\n      materialDef.normalTexture = normalMapDef\n    }\n\n    // occlusionTexture\n    if (material.aoMap) {\n      const occlusionMapDef = {\n        index: this.processTexture(material.aoMap),\n        texCoord: material.aoMap.channel,\n      }\n\n      if (material.aoMapIntensity !== 1.0) {\n        occlusionMapDef.strength = material.aoMapIntensity\n      }\n\n      this.applyTextureTransform(occlusionMapDef, material.aoMap)\n      materialDef.occlusionTexture = occlusionMapDef\n    }\n\n    // alphaMode\n    if (material.transparent) {\n      materialDef.alphaMode = 'BLEND'\n    } else {\n      if (material.alphaTest > 0.0) {\n        materialDef.alphaMode = 'MASK'\n        materialDef.alphaCutoff = material.alphaTest\n      }\n    }\n\n    // doubleSided\n    if (material.side === DoubleSide) materialDef.doubleSided = true\n    if (material.name !== '') materialDef.name = material.name\n\n    this.serializeUserData(material, materialDef)\n\n    this._invokeAll(function (ext) {\n      ext.writeMaterial && ext.writeMaterial(material, materialDef)\n    })\n\n    const index = json.materials.push(materialDef) - 1\n    cache.materials.set(material, index)\n    return index\n  }\n\n  /**\n   * Process mesh\n   * @param  {THREE.Mesh} mesh Mesh to process\n   * @return {Integer|null} Index of the processed mesh in the \"meshes\" array\n   */\n  processMesh(mesh) {\n    const cache = this.cache\n    const json = this.json\n\n    const meshCacheKeyParts = [mesh.geometry.uuid]\n\n    if (Array.isArray(mesh.material)) {\n      for (let i = 0, l = mesh.material.length; i < l; i++) {\n        meshCacheKeyParts.push(mesh.material[i].uuid)\n      }\n    } else {\n      meshCacheKeyParts.push(mesh.material.uuid)\n    }\n\n    const meshCacheKey = meshCacheKeyParts.join(':')\n\n    if (cache.meshes.has(meshCacheKey)) return cache.meshes.get(meshCacheKey)\n\n    const geometry = mesh.geometry\n\n    let mode\n\n    // Use the correct mode\n    if (mesh.isLineSegments) {\n      mode = WEBGL_CONSTANTS.LINES\n    } else if (mesh.isLineLoop) {\n      mode = WEBGL_CONSTANTS.LINE_LOOP\n    } else if (mesh.isLine) {\n      mode = WEBGL_CONSTANTS.LINE_STRIP\n    } else if (mesh.isPoints) {\n      mode = WEBGL_CONSTANTS.POINTS\n    } else {\n      mode = mesh.material.wireframe ? WEBGL_CONSTANTS.LINES : WEBGL_CONSTANTS.TRIANGLES\n    }\n\n    const meshDef = {}\n    const attributes = {}\n    const primitives = []\n    const targets = []\n\n    // Conversion between attributes names in threejs and gltf spec\n    const nameConversion = {\n      ...(version >= 152\n        ? {\n            uv: 'TEXCOORD_0',\n            uv1: 'TEXCOORD_1',\n            uv2: 'TEXCOORD_2',\n            uv3: 'TEXCOORD_3',\n          }\n        : {\n            uv: 'TEXCOORD_0',\n            uv2: 'TEXCOORD_1',\n          }),\n      color: 'COLOR_0',\n      skinWeight: 'WEIGHTS_0',\n      skinIndex: 'JOINTS_0',\n    }\n\n    const originalNormal = geometry.getAttribute('normal')\n\n    if (originalNormal !== undefined && !this.isNormalizedNormalAttribute(originalNormal)) {\n      console.warn('THREE.GLTFExporter: Creating normalized normal attribute from the non-normalized one.')\n\n      geometry.setAttribute('normal', this.createNormalizedNormalAttribute(originalNormal))\n    }\n\n    // @QUESTION Detect if .vertexColors = true?\n    // For every attribute create an accessor\n    let modifiedAttribute = null\n\n    for (let attributeName in geometry.attributes) {\n      // Ignore morph target attributes, which are exported later.\n      if (attributeName.slice(0, 5) === 'morph') continue\n\n      const attribute = geometry.attributes[attributeName]\n      attributeName = nameConversion[attributeName] || attributeName.toUpperCase()\n\n      // Prefix all geometry attributes except the ones specifically\n      // listed in the spec; non-spec attributes are considered custom.\n      const validVertexAttributes = /^(POSITION|NORMAL|TANGENT|TEXCOORD_\\d+|COLOR_\\d+|JOINTS_\\d+|WEIGHTS_\\d+)$/\n\n      if (!validVertexAttributes.test(attributeName)) attributeName = '_' + attributeName\n\n      if (cache.attributes.has(this.getUID(attribute))) {\n        attributes[attributeName] = cache.attributes.get(this.getUID(attribute))\n        continue\n      }\n\n      // JOINTS_0 must be UNSIGNED_BYTE or UNSIGNED_SHORT.\n      modifiedAttribute = null\n      const array = attribute.array\n\n      if (attributeName === 'JOINTS_0' && !(array instanceof Uint16Array) && !(array instanceof Uint8Array)) {\n        console.warn('GLTFExporter: Attribute \"skinIndex\" converted to type UNSIGNED_SHORT.')\n        modifiedAttribute = new BufferAttribute(new Uint16Array(array), attribute.itemSize, attribute.normalized)\n      }\n\n      const accessor = this.processAccessor(modifiedAttribute || attribute, geometry)\n\n      if (accessor !== null) {\n        if (!attributeName.startsWith('_')) {\n          this.detectMeshQuantization(attributeName, attribute)\n        }\n\n        attributes[attributeName] = accessor\n        cache.attributes.set(this.getUID(attribute), accessor)\n      }\n    }\n\n    if (originalNormal !== undefined) geometry.setAttribute('normal', originalNormal)\n\n    // Skip if no exportable attributes found\n    if (Object.keys(attributes).length === 0) return null\n\n    // Morph targets\n    if (mesh.morphTargetInfluences !== undefined && mesh.morphTargetInfluences.length > 0) {\n      const weights = []\n      const targetNames = []\n      const reverseDictionary = {}\n\n      if (mesh.morphTargetDictionary !== undefined) {\n        for (const key in mesh.morphTargetDictionary) {\n          reverseDictionary[mesh.morphTargetDictionary[key]] = key\n        }\n      }\n\n      for (let i = 0; i < mesh.morphTargetInfluences.length; ++i) {\n        const target = {}\n        let warned = false\n\n        for (const attributeName in geometry.morphAttributes) {\n          // glTF 2.0 morph supports only POSITION/NORMAL/TANGENT.\n          // Three.js doesn't support TANGENT yet.\n\n          if (attributeName !== 'position' && attributeName !== 'normal') {\n            if (!warned) {\n              console.warn('GLTFExporter: Only POSITION and NORMAL morph are supported.')\n              warned = true\n            }\n\n            continue\n          }\n\n          const attribute = geometry.morphAttributes[attributeName][i]\n          const gltfAttributeName = attributeName.toUpperCase()\n\n          // Three.js morph attribute has absolute values while the one of glTF has relative values.\n          //\n          // glTF 2.0 Specification:\n          // https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#morph-targets\n\n          const baseAttribute = geometry.attributes[attributeName]\n\n          if (cache.attributes.has(this.getUID(attribute, true))) {\n            target[gltfAttributeName] = cache.attributes.get(this.getUID(attribute, true))\n            continue\n          }\n\n          // Clones attribute not to override\n          const relativeAttribute = attribute.clone()\n\n          if (!geometry.morphTargetsRelative) {\n            for (let j = 0, jl = attribute.count; j < jl; j++) {\n              for (let a = 0; a < attribute.itemSize; a++) {\n                if (a === 0) relativeAttribute.setX(j, attribute.getX(j) - baseAttribute.getX(j))\n                if (a === 1) relativeAttribute.setY(j, attribute.getY(j) - baseAttribute.getY(j))\n                if (a === 2) relativeAttribute.setZ(j, attribute.getZ(j) - baseAttribute.getZ(j))\n                if (a === 3) relativeAttribute.setW(j, attribute.getW(j) - baseAttribute.getW(j))\n              }\n            }\n          }\n\n          target[gltfAttributeName] = this.processAccessor(relativeAttribute, geometry)\n          cache.attributes.set(this.getUID(baseAttribute, true), target[gltfAttributeName])\n        }\n\n        targets.push(target)\n\n        weights.push(mesh.morphTargetInfluences[i])\n\n        if (mesh.morphTargetDictionary !== undefined) targetNames.push(reverseDictionary[i])\n      }\n\n      meshDef.weights = weights\n\n      if (targetNames.length > 0) {\n        meshDef.extras = {}\n        meshDef.extras.targetNames = targetNames\n      }\n    }\n\n    const isMultiMaterial = Array.isArray(mesh.material)\n\n    if (isMultiMaterial && geometry.groups.length === 0) return null\n\n    const materials = isMultiMaterial ? mesh.material : [mesh.material]\n    const groups = isMultiMaterial ? geometry.groups : [{ materialIndex: 0, start: undefined, count: undefined }]\n\n    for (let i = 0, il = groups.length; i < il; i++) {\n      const primitive = {\n        mode: mode,\n        attributes: attributes,\n      }\n\n      this.serializeUserData(geometry, primitive)\n\n      if (targets.length > 0) primitive.targets = targets\n\n      if (geometry.index !== null) {\n        let cacheKey = this.getUID(geometry.index)\n\n        if (groups[i].start !== undefined || groups[i].count !== undefined) {\n          cacheKey += ':' + groups[i].start + ':' + groups[i].count\n        }\n\n        if (cache.attributes.has(cacheKey)) {\n          primitive.indices = cache.attributes.get(cacheKey)\n        } else {\n          primitive.indices = this.processAccessor(geometry.index, geometry, groups[i].start, groups[i].count)\n          cache.attributes.set(cacheKey, primitive.indices)\n        }\n\n        if (primitive.indices === null) delete primitive.indices\n      }\n\n      const material = this.processMaterial(materials[groups[i].materialIndex])\n\n      if (material !== null) primitive.material = material\n\n      primitives.push(primitive)\n    }\n\n    meshDef.primitives = primitives\n\n    if (!json.meshes) json.meshes = []\n\n    this._invokeAll(function (ext) {\n      ext.writeMesh && ext.writeMesh(mesh, meshDef)\n    })\n\n    const index = json.meshes.push(meshDef) - 1\n    cache.meshes.set(meshCacheKey, index)\n    return index\n  }\n\n  /**\n   * If a vertex attribute with a\n   * [non-standard data type](https://registry.khronos.org/glTF/specs/2.0/glTF-2.0.html#meshes-overview)\n   * is used, it is checked whether it is a valid data type according to the\n   * [KHR_mesh_quantization](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_mesh_quantization/README.md)\n   * extension.\n   * In this case the extension is automatically added to the list of used extensions.\n   *\n   * @param {string} attributeName\n   * @param {THREE.BufferAttribute} attribute\n   */\n  detectMeshQuantization(attributeName, attribute) {\n    if (this.extensionsUsed[KHR_MESH_QUANTIZATION]) return\n\n    let attrType = undefined\n\n    switch (attribute.array.constructor) {\n      case Int8Array:\n        attrType = 'byte'\n\n        break\n\n      case Uint8Array:\n        attrType = 'unsigned byte'\n\n        break\n\n      case Int16Array:\n        attrType = 'short'\n\n        break\n\n      case Uint16Array:\n        attrType = 'unsigned short'\n\n        break\n\n      default:\n        return\n    }\n\n    if (attribute.normalized) attrType += ' normalized'\n\n    const attrNamePrefix = attributeName.split('_', 1)[0]\n\n    if (\n      KHR_mesh_quantization_ExtraAttrTypes[attrNamePrefix] &&\n      KHR_mesh_quantization_ExtraAttrTypes[attrNamePrefix].includes(attrType)\n    ) {\n      this.extensionsUsed[KHR_MESH_QUANTIZATION] = true\n      this.extensionsRequired[KHR_MESH_QUANTIZATION] = true\n    }\n  }\n\n  /**\n   * Process camera\n   * @param  {THREE.Camera} camera Camera to process\n   * @return {Integer}      Index of the processed mesh in the \"camera\" array\n   */\n  processCamera(camera) {\n    const json = this.json\n\n    if (!json.cameras) json.cameras = []\n\n    const isOrtho = camera.isOrthographicCamera\n\n    const cameraDef = {\n      type: isOrtho ? 'orthographic' : 'perspective',\n    }\n\n    if (isOrtho) {\n      cameraDef.orthographic = {\n        xmag: camera.right * 2,\n        ymag: camera.top * 2,\n        zfar: camera.far <= 0 ? 0.001 : camera.far,\n        znear: camera.near < 0 ? 0 : camera.near,\n      }\n    } else {\n      cameraDef.perspective = {\n        aspectRatio: camera.aspect,\n        yfov: MathUtils.degToRad(camera.fov),\n        zfar: camera.far <= 0 ? 0.001 : camera.far,\n        znear: camera.near < 0 ? 0 : camera.near,\n      }\n    }\n\n    // Question: Is saving \"type\" as name intentional?\n    if (camera.name !== '') cameraDef.name = camera.type\n\n    return json.cameras.push(cameraDef) - 1\n  }\n\n  /**\n   * Creates glTF animation entry from AnimationClip object.\n   *\n   * Status:\n   * - Only properties listed in PATH_PROPERTIES may be animated.\n   *\n   * @param {THREE.AnimationClip} clip\n   * @param {THREE.Object3D} root\n   * @return {number|null}\n   */\n  processAnimation(clip, root) {\n    const json = this.json\n    const nodeMap = this.nodeMap\n\n    if (!json.animations) json.animations = []\n\n    clip = GLTFExporter.Utils.mergeMorphTargetTracks(clip.clone(), root)\n\n    const tracks = clip.tracks\n    const channels = []\n    const samplers = []\n\n    for (let i = 0; i < tracks.length; ++i) {\n      const track = tracks[i]\n      const trackBinding = PropertyBinding.parseTrackName(track.name)\n      let trackNode = PropertyBinding.findNode(root, trackBinding.nodeName)\n      const trackProperty = PATH_PROPERTIES[trackBinding.propertyName]\n\n      if (trackBinding.objectName === 'bones') {\n        if (trackNode.isSkinnedMesh === true) {\n          trackNode = trackNode.skeleton.getBoneByName(trackBinding.objectIndex)\n        } else {\n          trackNode = undefined\n        }\n      }\n\n      if (!trackNode || !trackProperty) {\n        console.warn('THREE.GLTFExporter: Could not export animation track \"%s\".', track.name)\n        return null\n      }\n\n      const inputItemSize = 1\n      let outputItemSize = track.values.length / track.times.length\n\n      if (trackProperty === PATH_PROPERTIES.morphTargetInfluences) {\n        outputItemSize /= trackNode.morphTargetInfluences.length\n      }\n\n      let interpolation\n\n      // @TODO export CubicInterpolant(InterpolateSmooth) as CUBICSPLINE\n\n      // Detecting glTF cubic spline interpolant by checking factory method's special property\n      // GLTFCubicSplineInterpolant is a custom interpolant and track doesn't return\n      // valid value from .getInterpolation().\n      if (track.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline === true) {\n        interpolation = 'CUBICSPLINE'\n\n        // itemSize of CUBICSPLINE keyframe is 9\n        // (VEC3 * 3: inTangent, splineVertex, and outTangent)\n        // but needs to be stored as VEC3 so dividing by 3 here.\n        outputItemSize /= 3\n      } else if (track.getInterpolation() === InterpolateDiscrete) {\n        interpolation = 'STEP'\n      } else {\n        interpolation = 'LINEAR'\n      }\n\n      samplers.push({\n        input: this.processAccessor(new BufferAttribute(track.times, inputItemSize)),\n        output: this.processAccessor(new BufferAttribute(track.values, outputItemSize)),\n        interpolation: interpolation,\n      })\n\n      channels.push({\n        sampler: samplers.length - 1,\n        target: {\n          node: nodeMap.get(trackNode),\n          path: trackProperty,\n        },\n      })\n    }\n\n    json.animations.push({\n      name: clip.name || 'clip_' + json.animations.length,\n      samplers: samplers,\n      channels: channels,\n    })\n\n    return json.animations.length - 1\n  }\n\n  /**\n   * @param {THREE.Object3D} object\n   * @return {number|null}\n   */\n  processSkin(object) {\n    const json = this.json\n    const nodeMap = this.nodeMap\n\n    const node = json.nodes[nodeMap.get(object)]\n\n    const skeleton = object.skeleton\n\n    if (skeleton === undefined) return null\n\n    const rootJoint = object.skeleton.bones[0]\n\n    if (rootJoint === undefined) return null\n\n    const joints = []\n    const inverseBindMatrices = new Float32Array(skeleton.bones.length * 16)\n    const temporaryBoneInverse = new Matrix4()\n\n    for (let i = 0; i < skeleton.bones.length; ++i) {\n      joints.push(nodeMap.get(skeleton.bones[i]))\n      temporaryBoneInverse.copy(skeleton.boneInverses[i])\n      temporaryBoneInverse.multiply(object.bindMatrix).toArray(inverseBindMatrices, i * 16)\n    }\n\n    if (json.skins === undefined) json.skins = []\n\n    json.skins.push({\n      inverseBindMatrices: this.processAccessor(new BufferAttribute(inverseBindMatrices, 16)),\n      joints: joints,\n      skeleton: nodeMap.get(rootJoint),\n    })\n\n    const skinIndex = (node.skin = json.skins.length - 1)\n\n    return skinIndex\n  }\n\n  /**\n   * Process Object3D node\n   * @param  {THREE.Object3D} node Object3D to processNode\n   * @return {Integer} Index of the node in the nodes list\n   */\n  processNode(object) {\n    const json = this.json\n    const options = this.options\n    const nodeMap = this.nodeMap\n\n    if (!json.nodes) json.nodes = []\n\n    const nodeDef = {}\n\n    if (options.trs) {\n      const rotation = object.quaternion.toArray()\n      const position = object.position.toArray()\n      const scale = object.scale.toArray()\n\n      if (!equalArray(rotation, [0, 0, 0, 1])) {\n        nodeDef.rotation = rotation\n      }\n\n      if (!equalArray(position, [0, 0, 0])) {\n        nodeDef.translation = position\n      }\n\n      if (!equalArray(scale, [1, 1, 1])) {\n        nodeDef.scale = scale\n      }\n    } else {\n      if (object.matrixAutoUpdate) {\n        object.updateMatrix()\n      }\n\n      if (isIdentityMatrix(object.matrix) === false) {\n        nodeDef.matrix = object.matrix.elements\n      }\n    }\n\n    // We don't export empty strings name because it represents no-name in Three.js.\n    if (object.name !== '') nodeDef.name = String(object.name)\n\n    this.serializeUserData(object, nodeDef)\n\n    if (object.isMesh || object.isLine || object.isPoints) {\n      const meshIndex = this.processMesh(object)\n\n      if (meshIndex !== null) nodeDef.mesh = meshIndex\n    } else if (object.isCamera) {\n      nodeDef.camera = this.processCamera(object)\n    }\n\n    if (object.isSkinnedMesh) this.skins.push(object)\n\n    if (object.children.length > 0) {\n      const children = []\n\n      for (let i = 0, l = object.children.length; i < l; i++) {\n        const child = object.children[i]\n\n        if (child.visible || options.onlyVisible === false) {\n          const nodeIndex = this.processNode(child)\n\n          if (nodeIndex !== null) children.push(nodeIndex)\n        }\n      }\n\n      if (children.length > 0) nodeDef.children = children\n    }\n\n    this._invokeAll(function (ext) {\n      ext.writeNode && ext.writeNode(object, nodeDef)\n    })\n\n    const nodeIndex = json.nodes.push(nodeDef) - 1\n    nodeMap.set(object, nodeIndex)\n    return nodeIndex\n  }\n\n  /**\n   * Process Scene\n   * @param  {Scene} node Scene to process\n   */\n  processScene(scene) {\n    const json = this.json\n    const options = this.options\n\n    if (!json.scenes) {\n      json.scenes = []\n      json.scene = 0\n    }\n\n    const sceneDef = {}\n\n    if (scene.name !== '') sceneDef.name = scene.name\n\n    json.scenes.push(sceneDef)\n\n    const nodes = []\n\n    for (let i = 0, l = scene.children.length; i < l; i++) {\n      const child = scene.children[i]\n\n      if (child.visible || options.onlyVisible === false) {\n        const nodeIndex = this.processNode(child)\n\n        if (nodeIndex !== null) nodes.push(nodeIndex)\n      }\n    }\n\n    if (nodes.length > 0) sceneDef.nodes = nodes\n\n    this.serializeUserData(scene, sceneDef)\n  }\n\n  /**\n   * Creates a Scene to hold a list of objects and parse it\n   * @param  {Array} objects List of objects to process\n   */\n  processObjects(objects) {\n    const scene = new Scene()\n    scene.name = 'AuxScene'\n\n    for (let i = 0; i < objects.length; i++) {\n      // We push directly to children instead of calling `add` to prevent\n      // modify the .parent and break its original scene and hierarchy\n      scene.children.push(objects[i])\n    }\n\n    this.processScene(scene)\n  }\n\n  /**\n   * @param {THREE.Object3D|Array<THREE.Object3D>} input\n   */\n  processInput(input) {\n    const options = this.options\n\n    input = input instanceof Array ? input : [input]\n\n    this._invokeAll(function (ext) {\n      ext.beforeParse && ext.beforeParse(input)\n    })\n\n    const objectsWithoutScene = []\n\n    for (let i = 0; i < input.length; i++) {\n      if (input[i] instanceof Scene) {\n        this.processScene(input[i])\n      } else {\n        objectsWithoutScene.push(input[i])\n      }\n    }\n\n    if (objectsWithoutScene.length > 0) this.processObjects(objectsWithoutScene)\n\n    for (let i = 0; i < this.skins.length; ++i) {\n      this.processSkin(this.skins[i])\n    }\n\n    for (let i = 0; i < options.animations.length; ++i) {\n      this.processAnimation(options.animations[i], input[0])\n    }\n\n    this._invokeAll(function (ext) {\n      ext.afterParse && ext.afterParse(input)\n    })\n  }\n\n  _invokeAll(func) {\n    for (let i = 0, il = this.plugins.length; i < il; i++) {\n      func(this.plugins[i])\n    }\n  }\n}\n\n/**\n * Punctual Lights Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_lights_punctual\n */\nclass GLTFLightExtension {\n  constructor(writer) {\n    this.writer = writer\n    this.name = 'KHR_lights_punctual'\n  }\n\n  writeNode(light, nodeDef) {\n    if (!light.isLight) return\n\n    if (!light.isDirectionalLight && !light.isPointLight && !light.isSpotLight) {\n      console.warn('THREE.GLTFExporter: Only directional, point, and spot lights are supported.', light)\n      return\n    }\n\n    const writer = this.writer\n    const json = writer.json\n    const extensionsUsed = writer.extensionsUsed\n\n    const lightDef = {}\n\n    if (light.name) lightDef.name = light.name\n\n    lightDef.color = light.color.toArray()\n\n    lightDef.intensity = light.intensity\n\n    if (light.isDirectionalLight) {\n      lightDef.type = 'directional'\n    } else if (light.isPointLight) {\n      lightDef.type = 'point'\n\n      if (light.distance > 0) lightDef.range = light.distance\n    } else if (light.isSpotLight) {\n      lightDef.type = 'spot'\n\n      if (light.distance > 0) lightDef.range = light.distance\n\n      lightDef.spot = {}\n      lightDef.spot.innerConeAngle = (light.penumbra - 1.0) * light.angle * -1.0\n      lightDef.spot.outerConeAngle = light.angle\n    }\n\n    if (light.decay !== undefined && light.decay !== 2) {\n      console.warn(\n        'THREE.GLTFExporter: Light decay may be lost. glTF is physically-based, ' + 'and expects light.decay=2.',\n      )\n    }\n\n    if (\n      light.target &&\n      (light.target.parent !== light ||\n        light.target.position.x !== 0 ||\n        light.target.position.y !== 0 ||\n        light.target.position.z !== -1)\n    ) {\n      console.warn(\n        'THREE.GLTFExporter: Light direction may be lost. For best results, ' +\n          'make light.target a child of the light with position 0,0,-1.',\n      )\n    }\n\n    if (!extensionsUsed[this.name]) {\n      json.extensions = json.extensions || {}\n      json.extensions[this.name] = { lights: [] }\n      extensionsUsed[this.name] = true\n    }\n\n    const lights = json.extensions[this.name].lights\n    lights.push(lightDef)\n\n    nodeDef.extensions = nodeDef.extensions || {}\n    nodeDef.extensions[this.name] = { light: lights.length - 1 }\n  }\n}\n\n/**\n * Unlit Materials Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_unlit\n */\nclass GLTFMaterialsUnlitExtension {\n  constructor(writer) {\n    this.writer = writer\n    this.name = 'KHR_materials_unlit'\n  }\n\n  writeMaterial(material, materialDef) {\n    if (!material.isMeshBasicMaterial) return\n\n    const writer = this.writer\n    const extensionsUsed = writer.extensionsUsed\n\n    materialDef.extensions = materialDef.extensions || {}\n    materialDef.extensions[this.name] = {}\n\n    extensionsUsed[this.name] = true\n\n    materialDef.pbrMetallicRoughness.metallicFactor = 0.0\n    materialDef.pbrMetallicRoughness.roughnessFactor = 0.9\n  }\n}\n\n/**\n * Clearcoat Materials Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_clearcoat\n */\nclass GLTFMaterialsClearcoatExtension {\n  constructor(writer) {\n    this.writer = writer\n    this.name = 'KHR_materials_clearcoat'\n  }\n\n  writeMaterial(material, materialDef) {\n    if (!material.isMeshPhysicalMaterial || material.clearcoat === 0) return\n\n    const writer = this.writer\n    const extensionsUsed = writer.extensionsUsed\n\n    const extensionDef = {}\n\n    extensionDef.clearcoatFactor = material.clearcoat\n\n    if (material.clearcoatMap) {\n      const clearcoatMapDef = {\n        index: writer.processTexture(material.clearcoatMap),\n        texCoord: material.clearcoatMap.channel,\n      }\n      writer.applyTextureTransform(clearcoatMapDef, material.clearcoatMap)\n      extensionDef.clearcoatTexture = clearcoatMapDef\n    }\n\n    extensionDef.clearcoatRoughnessFactor = material.clearcoatRoughness\n\n    if (material.clearcoatRoughnessMap) {\n      const clearcoatRoughnessMapDef = {\n        index: writer.processTexture(material.clearcoatRoughnessMap),\n        texCoord: material.clearcoatRoughnessMap.channel,\n      }\n      writer.applyTextureTransform(clearcoatRoughnessMapDef, material.clearcoatRoughnessMap)\n      extensionDef.clearcoatRoughnessTexture = clearcoatRoughnessMapDef\n    }\n\n    if (material.clearcoatNormalMap) {\n      const clearcoatNormalMapDef = {\n        index: writer.processTexture(material.clearcoatNormalMap),\n        texCoord: material.clearcoatNormalMap.channel,\n      }\n      writer.applyTextureTransform(clearcoatNormalMapDef, material.clearcoatNormalMap)\n      extensionDef.clearcoatNormalTexture = clearcoatNormalMapDef\n    }\n\n    materialDef.extensions = materialDef.extensions || {}\n    materialDef.extensions[this.name] = extensionDef\n\n    extensionsUsed[this.name] = true\n  }\n}\n\n/**\n * Iridescence Materials Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_iridescence\n */\nclass GLTFMaterialsIridescenceExtension {\n  constructor(writer) {\n    this.writer = writer\n    this.name = 'KHR_materials_iridescence'\n  }\n\n  writeMaterial(material, materialDef) {\n    if (!material.isMeshPhysicalMaterial || material.iridescence === 0) return\n\n    const writer = this.writer\n    const extensionsUsed = writer.extensionsUsed\n\n    const extensionDef = {}\n\n    extensionDef.iridescenceFactor = material.iridescence\n\n    if (material.iridescenceMap) {\n      const iridescenceMapDef = {\n        index: writer.processTexture(material.iridescenceMap),\n        texCoord: material.iridescenceMap.channel,\n      }\n      writer.applyTextureTransform(iridescenceMapDef, material.iridescenceMap)\n      extensionDef.iridescenceTexture = iridescenceMapDef\n    }\n\n    extensionDef.iridescenceIor = material.iridescenceIOR\n    extensionDef.iridescenceThicknessMinimum = material.iridescenceThicknessRange[0]\n    extensionDef.iridescenceThicknessMaximum = material.iridescenceThicknessRange[1]\n\n    if (material.iridescenceThicknessMap) {\n      const iridescenceThicknessMapDef = {\n        index: writer.processTexture(material.iridescenceThicknessMap),\n        texCoord: material.iridescenceThicknessMap.channel,\n      }\n      writer.applyTextureTransform(iridescenceThicknessMapDef, material.iridescenceThicknessMap)\n      extensionDef.iridescenceThicknessTexture = iridescenceThicknessMapDef\n    }\n\n    materialDef.extensions = materialDef.extensions || {}\n    materialDef.extensions[this.name] = extensionDef\n\n    extensionsUsed[this.name] = true\n  }\n}\n\n/**\n * Transmission Materials Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_transmission\n */\nclass GLTFMaterialsTransmissionExtension {\n  constructor(writer) {\n    this.writer = writer\n    this.name = 'KHR_materials_transmission'\n  }\n\n  writeMaterial(material, materialDef) {\n    if (!material.isMeshPhysicalMaterial || material.transmission === 0) return\n\n    const writer = this.writer\n    const extensionsUsed = writer.extensionsUsed\n\n    const extensionDef = {}\n\n    extensionDef.transmissionFactor = material.transmission\n\n    if (material.transmissionMap) {\n      const transmissionMapDef = {\n        index: writer.processTexture(material.transmissionMap),\n        texCoord: material.transmissionMap.channel,\n      }\n      writer.applyTextureTransform(transmissionMapDef, material.transmissionMap)\n      extensionDef.transmissionTexture = transmissionMapDef\n    }\n\n    materialDef.extensions = materialDef.extensions || {}\n    materialDef.extensions[this.name] = extensionDef\n\n    extensionsUsed[this.name] = true\n  }\n}\n\n/**\n * Materials Volume Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_volume\n */\nclass GLTFMaterialsVolumeExtension {\n  constructor(writer) {\n    this.writer = writer\n    this.name = 'KHR_materials_volume'\n  }\n\n  writeMaterial(material, materialDef) {\n    if (!material.isMeshPhysicalMaterial || material.transmission === 0) return\n\n    const writer = this.writer\n    const extensionsUsed = writer.extensionsUsed\n\n    const extensionDef = {}\n\n    extensionDef.thicknessFactor = material.thickness\n\n    if (material.thicknessMap) {\n      const thicknessMapDef = {\n        index: writer.processTexture(material.thicknessMap),\n        texCoord: material.thicknessMap.channel,\n      }\n      writer.applyTextureTransform(thicknessMapDef, material.thicknessMap)\n      extensionDef.thicknessTexture = thicknessMapDef\n    }\n\n    extensionDef.attenuationDistance = material.attenuationDistance\n    extensionDef.attenuationColor = material.attenuationColor.toArray()\n\n    materialDef.extensions = materialDef.extensions || {}\n    materialDef.extensions[this.name] = extensionDef\n\n    extensionsUsed[this.name] = true\n  }\n}\n\n/**\n * Materials ior Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_ior\n */\nclass GLTFMaterialsIorExtension {\n  constructor(writer) {\n    this.writer = writer\n    this.name = 'KHR_materials_ior'\n  }\n\n  writeMaterial(material, materialDef) {\n    if (!material.isMeshPhysicalMaterial || material.ior === 1.5) return\n\n    const writer = this.writer\n    const extensionsUsed = writer.extensionsUsed\n\n    const extensionDef = {}\n\n    extensionDef.ior = material.ior\n\n    materialDef.extensions = materialDef.extensions || {}\n    materialDef.extensions[this.name] = extensionDef\n\n    extensionsUsed[this.name] = true\n  }\n}\n\n/**\n * Materials specular Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_specular\n */\nclass GLTFMaterialsSpecularExtension {\n  constructor(writer) {\n    this.writer = writer\n    this.name = 'KHR_materials_specular'\n  }\n\n  writeMaterial(material, materialDef) {\n    if (\n      !material.isMeshPhysicalMaterial ||\n      (material.specularIntensity === 1.0 &&\n        material.specularColor.equals(DEFAULT_SPECULAR_COLOR) &&\n        !material.specularIntensityMap &&\n        !material.specularColorTexture)\n    )\n      return\n\n    const writer = this.writer\n    const extensionsUsed = writer.extensionsUsed\n\n    const extensionDef = {}\n\n    if (material.specularIntensityMap) {\n      const specularIntensityMapDef = {\n        index: writer.processTexture(material.specularIntensityMap),\n        texCoord: material.specularIntensityMap.channel,\n      }\n      writer.applyTextureTransform(specularIntensityMapDef, material.specularIntensityMap)\n      extensionDef.specularTexture = specularIntensityMapDef\n    }\n\n    if (material.specularColorMap) {\n      const specularColorMapDef = {\n        index: writer.processTexture(material.specularColorMap),\n        texCoord: material.specularColorMap.channel,\n      }\n      writer.applyTextureTransform(specularColorMapDef, material.specularColorMap)\n      extensionDef.specularColorTexture = specularColorMapDef\n    }\n\n    extensionDef.specularFactor = material.specularIntensity\n    extensionDef.specularColorFactor = material.specularColor.toArray()\n\n    materialDef.extensions = materialDef.extensions || {}\n    materialDef.extensions[this.name] = extensionDef\n\n    extensionsUsed[this.name] = true\n  }\n}\n\n/**\n * Sheen Materials Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_sheen\n */\nclass GLTFMaterialsSheenExtension {\n  constructor(writer) {\n    this.writer = writer\n    this.name = 'KHR_materials_sheen'\n  }\n\n  writeMaterial(material, materialDef) {\n    if (!material.isMeshPhysicalMaterial || material.sheen == 0.0) return\n\n    const writer = this.writer\n    const extensionsUsed = writer.extensionsUsed\n\n    const extensionDef = {}\n\n    if (material.sheenRoughnessMap) {\n      const sheenRoughnessMapDef = {\n        index: writer.processTexture(material.sheenRoughnessMap),\n        texCoord: material.sheenRoughnessMap.channel,\n      }\n      writer.applyTextureTransform(sheenRoughnessMapDef, material.sheenRoughnessMap)\n      extensionDef.sheenRoughnessTexture = sheenRoughnessMapDef\n    }\n\n    if (material.sheenColorMap) {\n      const sheenColorMapDef = {\n        index: writer.processTexture(material.sheenColorMap),\n        texCoord: material.sheenColorMap.channel,\n      }\n      writer.applyTextureTransform(sheenColorMapDef, material.sheenColorMap)\n      extensionDef.sheenColorTexture = sheenColorMapDef\n    }\n\n    extensionDef.sheenRoughnessFactor = material.sheenRoughness\n    extensionDef.sheenColorFactor = material.sheenColor.toArray()\n\n    materialDef.extensions = materialDef.extensions || {}\n    materialDef.extensions[this.name] = extensionDef\n\n    extensionsUsed[this.name] = true\n  }\n}\n\n/**\n * Anisotropy Materials Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_anisotropy\n */\nclass GLTFMaterialsAnisotropyExtension {\n  constructor(writer) {\n    this.writer = writer\n    this.name = 'KHR_materials_anisotropy'\n  }\n\n  writeMaterial(material, materialDef) {\n    if (!material.isMeshPhysicalMaterial || material.anisotropy == 0.0) return\n\n    const writer = this.writer\n    const extensionsUsed = writer.extensionsUsed\n\n    const extensionDef = {}\n\n    if (material.anisotropyMap) {\n      const anisotropyMapDef = { index: writer.processTexture(material.anisotropyMap) }\n      writer.applyTextureTransform(anisotropyMapDef, material.anisotropyMap)\n      extensionDef.anisotropyTexture = anisotropyMapDef\n    }\n\n    extensionDef.anisotropyStrength = material.anisotropy\n    extensionDef.anisotropyRotation = material.anisotropyRotation\n\n    materialDef.extensions = materialDef.extensions || {}\n    materialDef.extensions[this.name] = extensionDef\n\n    extensionsUsed[this.name] = true\n  }\n}\n\n/**\n * Materials Emissive Strength Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/blob/5768b3ce0ef32bc39cdf1bef10b948586635ead3/extensions/2.0/Khronos/KHR_materials_emissive_strength/README.md\n */\nclass GLTFMaterialsEmissiveStrengthExtension {\n  constructor(writer) {\n    this.writer = writer\n    this.name = 'KHR_materials_emissive_strength'\n  }\n\n  writeMaterial(material, materialDef) {\n    if (!material.isMeshStandardMaterial || material.emissiveIntensity === 1.0) return\n\n    const writer = this.writer\n    const extensionsUsed = writer.extensionsUsed\n\n    const extensionDef = {}\n\n    extensionDef.emissiveStrength = material.emissiveIntensity\n\n    materialDef.extensions = materialDef.extensions || {}\n    materialDef.extensions[this.name] = extensionDef\n\n    extensionsUsed[this.name] = true\n  }\n}\n\nexport { GLTFExporter }\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}