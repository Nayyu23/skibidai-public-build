{"ast":null,"code":"import _assertThisInitialized from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js\";\nimport _classCallCheck from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _inherits from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport { Loader, LoaderUtils, FileLoader, Vector3, Vector2, TextureLoader, Scene, Object3D, Group, SphereGeometry, MeshBasicMaterial, BackSide, Mesh, PointsMaterial, Points, LineBasicMaterial, LineSegments, FrontSide, DoubleSide, MeshPhongMaterial, Color, DataTexture, BufferGeometry, Float32BufferAttribute, BoxGeometry, ConeGeometry, CylinderGeometry, Quaternion, ShapeUtils, BufferAttribute, RepeatWrapping, ClampToEdgeWrapping } from \"three\";\nimport { createToken, Lexer, CstParser } from \"../libs/chevrotain.js\";\nvar VRMLLoader = /*#__PURE__*/function (_Loader) {\n  _inherits(VRMLLoader, _Loader);\n  var _super = _createSuper(VRMLLoader);\n  function VRMLLoader(manager) {\n    _classCallCheck(this, VRMLLoader);\n    return _super.call(this, manager);\n  }\n  _createClass(VRMLLoader, [{\n    key: \"load\",\n    value: function load(url, onLoad, onProgress, onError) {\n      var scope = this;\n      var path = scope.path === \"\" ? LoaderUtils.extractUrlBase(url) : scope.path;\n      var loader = new FileLoader(scope.manager);\n      loader.setPath(scope.path);\n      loader.setRequestHeader(scope.requestHeader);\n      loader.setWithCredentials(scope.withCredentials);\n      loader.load(url, function (text) {\n        try {\n          onLoad(scope.parse(text, path));\n        } catch (e) {\n          if (onError) {\n            onError(e);\n          } else {\n            console.error(e);\n          }\n          scope.manager.itemError(url);\n        }\n      }, onProgress, onError);\n    }\n  }, {\n    key: \"parse\",\n    value: function parse(data, path) {\n      var nodeMap = {};\n      function generateVRMLTree(data2) {\n        var tokenData = createTokens();\n        var lexer = new VRMLLexer(tokenData.tokens);\n        var parser = new VRMLParser(tokenData.tokenVocabulary);\n        var visitor = createVisitor(parser.getBaseCstVisitorConstructor());\n        var lexingResult = lexer.lex(data2);\n        parser.input = lexingResult.tokens;\n        var cstOutput = parser.vrml();\n        if (parser.errors.length > 0) {\n          console.error(parser.errors);\n          throw Error(\"THREE.VRMLLoader: Parsing errors detected.\");\n        }\n        var ast = visitor.visit(cstOutput);\n        return ast;\n      }\n      function createTokens() {\n        var RouteIdentifier = createToken({\n          name: \"RouteIdentifier\",\n          pattern: /[^\\x30-\\x39\\0-\\x20\\x22\\x27\\x23\\x2b\\x2c\\x2d\\x2e\\x5b\\x5d\\x5c\\x7b\\x7d][^\\0-\\x20\\x22\\x27\\x23\\x2b\\x2c\\x2d\\x2e\\x5b\\x5d\\x5c\\x7b\\x7d]*[\\.][^\\x30-\\x39\\0-\\x20\\x22\\x27\\x23\\x2b\\x2c\\x2d\\x2e\\x5b\\x5d\\x5c\\x7b\\x7d][^\\0-\\x20\\x22\\x27\\x23\\x2b\\x2c\\x2d\\x2e\\x5b\\x5d\\x5c\\x7b\\x7d]*/\n        });\n        var Identifier = createToken({\n          name: \"Identifier\",\n          pattern: /[^\\x30-\\x39\\0-\\x20\\x22\\x27\\x23\\x2b\\x2c\\x2d\\x2e\\x5b\\x5d\\x5c\\x7b\\x7d][^\\0-\\x20\\x22\\x27\\x23\\x2b\\x2c\\x2d\\x2e\\x5b\\x5d\\x5c\\x7b\\x7d]*/,\n          longer_alt: RouteIdentifier\n        });\n        var nodeTypes = [\"Anchor\", \"Billboard\", \"Collision\", \"Group\", \"Transform\",\n        // grouping nodes\n        \"Inline\", \"LOD\", \"Switch\",\n        // special groups\n        \"AudioClip\", \"DirectionalLight\", \"PointLight\", \"Script\", \"Shape\", \"Sound\", \"SpotLight\", \"WorldInfo\",\n        // common nodes\n        \"CylinderSensor\", \"PlaneSensor\", \"ProximitySensor\", \"SphereSensor\", \"TimeSensor\", \"TouchSensor\", \"VisibilitySensor\",\n        // sensors\n        \"Box\", \"Cone\", \"Cylinder\", \"ElevationGrid\", \"Extrusion\", \"IndexedFaceSet\", \"IndexedLineSet\", \"PointSet\", \"Sphere\",\n        // geometries\n        \"Color\", \"Coordinate\", \"Normal\", \"TextureCoordinate\",\n        // geometric properties\n        \"Appearance\", \"FontStyle\", \"ImageTexture\", \"Material\", \"MovieTexture\", \"PixelTexture\", \"TextureTransform\",\n        // appearance\n        \"ColorInterpolator\", \"CoordinateInterpolator\", \"NormalInterpolator\", \"OrientationInterpolator\", \"PositionInterpolator\", \"ScalarInterpolator\",\n        // interpolators\n        \"Background\", \"Fog\", \"NavigationInfo\", \"Viewpoint\",\n        // bindable nodes\n        \"Text\"\n        // Text must be placed at the end of the regex so there are no matches for TextureTransform and TextureCoordinate\n        ];\n\n        var Version = createToken({\n          name: \"Version\",\n          pattern: /#VRML.*/,\n          longer_alt: Identifier\n        });\n        var NodeName = createToken({\n          name: \"NodeName\",\n          pattern: new RegExp(nodeTypes.join(\"|\")),\n          longer_alt: Identifier\n        });\n        var DEF = createToken({\n          name: \"DEF\",\n          pattern: /DEF/,\n          longer_alt: Identifier\n        });\n        var USE = createToken({\n          name: \"USE\",\n          pattern: /USE/,\n          longer_alt: Identifier\n        });\n        var ROUTE = createToken({\n          name: \"ROUTE\",\n          pattern: /ROUTE/,\n          longer_alt: Identifier\n        });\n        var TO = createToken({\n          name: \"TO\",\n          pattern: /TO/,\n          longer_alt: Identifier\n        });\n        var StringLiteral = createToken({\n          name: \"StringLiteral\",\n          pattern: /\"(?:[^\\\\\"\\n\\r]|\\\\[bfnrtv\"\\\\/]|\\\\u[0-9a-fA-F][0-9a-fA-F][0-9a-fA-F][0-9a-fA-F])*\"/\n        });\n        var HexLiteral = createToken({\n          name: \"HexLiteral\",\n          pattern: /0[xX][0-9a-fA-F]+/\n        });\n        var NumberLiteral = createToken({\n          name: \"NumberLiteral\",\n          pattern: /[-+]?[0-9]*\\.?[0-9]+([eE][-+]?[0-9]+)?/\n        });\n        var TrueLiteral = createToken({\n          name: \"TrueLiteral\",\n          pattern: /TRUE/\n        });\n        var FalseLiteral = createToken({\n          name: \"FalseLiteral\",\n          pattern: /FALSE/\n        });\n        var NullLiteral = createToken({\n          name: \"NullLiteral\",\n          pattern: /NULL/\n        });\n        var LSquare = createToken({\n          name: \"LSquare\",\n          pattern: /\\[/\n        });\n        var RSquare = createToken({\n          name: \"RSquare\",\n          pattern: /]/\n        });\n        var LCurly = createToken({\n          name: \"LCurly\",\n          pattern: /{/\n        });\n        var RCurly = createToken({\n          name: \"RCurly\",\n          pattern: /}/\n        });\n        var Comment = createToken({\n          name: \"Comment\",\n          pattern: /#.*/,\n          group: Lexer.SKIPPED\n        });\n        var WhiteSpace = createToken({\n          name: \"WhiteSpace\",\n          pattern: /[ ,\\s]/,\n          group: Lexer.SKIPPED\n        });\n        var tokens = [WhiteSpace,\n        // keywords appear before the Identifier\n        NodeName, DEF, USE, ROUTE, TO, TrueLiteral, FalseLiteral, NullLiteral,\n        // the Identifier must appear after the keywords because all keywords are valid identifiers\n        Version, Identifier, RouteIdentifier, StringLiteral, HexLiteral, NumberLiteral, LSquare, RSquare, LCurly, RCurly, Comment];\n        var tokenVocabulary = {};\n        for (var i = 0, l = tokens.length; i < l; i++) {\n          var token = tokens[i];\n          tokenVocabulary[token.name] = token;\n        }\n        return {\n          tokens: tokens,\n          tokenVocabulary: tokenVocabulary\n        };\n      }\n      function createVisitor(BaseVRMLVisitor) {\n        function VRMLToASTVisitor() {\n          BaseVRMLVisitor.call(this);\n          this.validateVisitor();\n        }\n        VRMLToASTVisitor.prototype = Object.assign(Object.create(BaseVRMLVisitor.prototype), {\n          constructor: VRMLToASTVisitor,\n          vrml: function vrml(ctx) {\n            var data2 = {\n              version: this.visit(ctx.version),\n              nodes: [],\n              routes: []\n            };\n            for (var i = 0, l = ctx.node.length; i < l; i++) {\n              var node = ctx.node[i];\n              data2.nodes.push(this.visit(node));\n            }\n            if (ctx.route) {\n              for (var _i = 0, _l = ctx.route.length; _i < _l; _i++) {\n                var route = ctx.route[_i];\n                data2.routes.push(this.visit(route));\n              }\n            }\n            return data2;\n          },\n          version: function version(ctx) {\n            return ctx.Version[0].image;\n          },\n          node: function node(ctx) {\n            var data2 = {\n              name: ctx.NodeName[0].image,\n              fields: []\n            };\n            if (ctx.field) {\n              for (var i = 0, l = ctx.field.length; i < l; i++) {\n                var field = ctx.field[i];\n                data2.fields.push(this.visit(field));\n              }\n            }\n            if (ctx.def) {\n              data2.DEF = this.visit(ctx.def[0]);\n            }\n            return data2;\n          },\n          field: function field(ctx) {\n            var data2 = {\n              name: ctx.Identifier[0].image,\n              type: null,\n              values: null\n            };\n            var result;\n            if (ctx.singleFieldValue) {\n              result = this.visit(ctx.singleFieldValue[0]);\n            }\n            if (ctx.multiFieldValue) {\n              result = this.visit(ctx.multiFieldValue[0]);\n            }\n            data2.type = result.type;\n            data2.values = result.values;\n            return data2;\n          },\n          def: function def(ctx) {\n            return (ctx.Identifier || ctx.NodeName)[0].image;\n          },\n          use: function use(ctx) {\n            return {\n              USE: (ctx.Identifier || ctx.NodeName)[0].image\n            };\n          },\n          singleFieldValue: function singleFieldValue(ctx) {\n            return processField(this, ctx);\n          },\n          multiFieldValue: function multiFieldValue(ctx) {\n            return processField(this, ctx);\n          },\n          route: function route(ctx) {\n            var data2 = {\n              FROM: ctx.RouteIdentifier[0].image,\n              TO: ctx.RouteIdentifier[1].image\n            };\n            return data2;\n          }\n        });\n        function processField(scope, ctx) {\n          var field = {\n            type: null,\n            values: []\n          };\n          if (ctx.node) {\n            field.type = \"node\";\n            for (var i = 0, l = ctx.node.length; i < l; i++) {\n              var node = ctx.node[i];\n              field.values.push(scope.visit(node));\n            }\n          }\n          if (ctx.use) {\n            field.type = \"use\";\n            for (var _i2 = 0, _l2 = ctx.use.length; _i2 < _l2; _i2++) {\n              var use = ctx.use[_i2];\n              field.values.push(scope.visit(use));\n            }\n          }\n          if (ctx.StringLiteral) {\n            field.type = \"string\";\n            for (var _i3 = 0, _l3 = ctx.StringLiteral.length; _i3 < _l3; _i3++) {\n              var stringLiteral = ctx.StringLiteral[_i3];\n              field.values.push(stringLiteral.image.replace(/'|\"/g, \"\"));\n            }\n          }\n          if (ctx.NumberLiteral) {\n            field.type = \"number\";\n            for (var _i4 = 0, _l4 = ctx.NumberLiteral.length; _i4 < _l4; _i4++) {\n              var numberLiteral = ctx.NumberLiteral[_i4];\n              field.values.push(parseFloat(numberLiteral.image));\n            }\n          }\n          if (ctx.HexLiteral) {\n            field.type = \"hex\";\n            for (var _i5 = 0, _l5 = ctx.HexLiteral.length; _i5 < _l5; _i5++) {\n              var hexLiteral = ctx.HexLiteral[_i5];\n              field.values.push(hexLiteral.image);\n            }\n          }\n          if (ctx.TrueLiteral) {\n            field.type = \"boolean\";\n            for (var _i6 = 0, _l6 = ctx.TrueLiteral.length; _i6 < _l6; _i6++) {\n              var trueLiteral = ctx.TrueLiteral[_i6];\n              if (trueLiteral.image === \"TRUE\") field.values.push(true);\n            }\n          }\n          if (ctx.FalseLiteral) {\n            field.type = \"boolean\";\n            for (var _i7 = 0, _l7 = ctx.FalseLiteral.length; _i7 < _l7; _i7++) {\n              var falseLiteral = ctx.FalseLiteral[_i7];\n              if (falseLiteral.image === \"FALSE\") field.values.push(false);\n            }\n          }\n          if (ctx.NullLiteral) {\n            field.type = \"null\";\n            ctx.NullLiteral.forEach(function () {\n              field.values.push(null);\n            });\n          }\n          return field;\n        }\n        return new VRMLToASTVisitor();\n      }\n      function parseTree(tree2) {\n        var nodes = tree2.nodes;\n        var scene2 = new Scene();\n        for (var i = 0, l = nodes.length; i < l; i++) {\n          var node = nodes[i];\n          buildNodeMap(node);\n        }\n        for (var _i8 = 0, _l8 = nodes.length; _i8 < _l8; _i8++) {\n          var _node = nodes[_i8];\n          var object = getNode(_node);\n          if (object instanceof Object3D) scene2.add(object);\n          if (_node.name === \"WorldInfo\") scene2.userData.worldInfo = object;\n        }\n        return scene2;\n      }\n      function buildNodeMap(node) {\n        if (node.DEF) {\n          nodeMap[node.DEF] = node;\n        }\n        var fields = node.fields;\n        for (var i = 0, l = fields.length; i < l; i++) {\n          var field = fields[i];\n          if (field.type === \"node\") {\n            var fieldValues = field.values;\n            for (var j = 0, jl = fieldValues.length; j < jl; j++) {\n              buildNodeMap(fieldValues[j]);\n            }\n          }\n        }\n      }\n      function getNode(node) {\n        if (node.USE) {\n          return resolveUSE(node.USE);\n        }\n        if (node.build !== void 0) return node.build;\n        node.build = buildNode(node);\n        return node.build;\n      }\n      function buildNode(node) {\n        var nodeName = node.name;\n        var build;\n        switch (nodeName) {\n          case \"Group\":\n          case \"Transform\":\n          case \"Collision\":\n            build = buildGroupingNode(node);\n            break;\n          case \"Background\":\n            build = buildBackgroundNode(node);\n            break;\n          case \"Shape\":\n            build = buildShapeNode(node);\n            break;\n          case \"Appearance\":\n            build = buildAppearanceNode(node);\n            break;\n          case \"Material\":\n            build = buildMaterialNode(node);\n            break;\n          case \"ImageTexture\":\n            build = buildImageTextureNode(node);\n            break;\n          case \"PixelTexture\":\n            build = buildPixelTextureNode(node);\n            break;\n          case \"TextureTransform\":\n            build = buildTextureTransformNode(node);\n            break;\n          case \"IndexedFaceSet\":\n            build = buildIndexedFaceSetNode(node);\n            break;\n          case \"IndexedLineSet\":\n            build = buildIndexedLineSetNode(node);\n            break;\n          case \"PointSet\":\n            build = buildPointSetNode(node);\n            break;\n          case \"Box\":\n            build = buildBoxNode(node);\n            break;\n          case \"Cone\":\n            build = buildConeNode(node);\n            break;\n          case \"Cylinder\":\n            build = buildCylinderNode(node);\n            break;\n          case \"Sphere\":\n            build = buildSphereNode(node);\n            break;\n          case \"ElevationGrid\":\n            build = buildElevationGridNode(node);\n            break;\n          case \"Extrusion\":\n            build = buildExtrusionNode(node);\n            break;\n          case \"Color\":\n          case \"Coordinate\":\n          case \"Normal\":\n          case \"TextureCoordinate\":\n            build = buildGeometricNode(node);\n            break;\n          case \"WorldInfo\":\n            build = buildWorldInfoNode(node);\n            break;\n          case \"Anchor\":\n          case \"Billboard\":\n          case \"Inline\":\n          case \"LOD\":\n          case \"Switch\":\n          case \"AudioClip\":\n          case \"DirectionalLight\":\n          case \"PointLight\":\n          case \"Script\":\n          case \"Sound\":\n          case \"SpotLight\":\n          case \"CylinderSensor\":\n          case \"PlaneSensor\":\n          case \"ProximitySensor\":\n          case \"SphereSensor\":\n          case \"TimeSensor\":\n          case \"TouchSensor\":\n          case \"VisibilitySensor\":\n          case \"Text\":\n          case \"FontStyle\":\n          case \"MovieTexture\":\n          case \"ColorInterpolator\":\n          case \"CoordinateInterpolator\":\n          case \"NormalInterpolator\":\n          case \"OrientationInterpolator\":\n          case \"PositionInterpolator\":\n          case \"ScalarInterpolator\":\n          case \"Fog\":\n          case \"NavigationInfo\":\n          case \"Viewpoint\":\n            break;\n          default:\n            console.warn(\"THREE.VRMLLoader: Unknown node:\", nodeName);\n            break;\n        }\n        if (build !== void 0 && node.DEF !== void 0 && build.hasOwnProperty(\"name\") === true) {\n          build.name = node.DEF;\n        }\n        return build;\n      }\n      function buildGroupingNode(node) {\n        var object = new Group();\n        var fields = node.fields;\n        for (var i = 0, l = fields.length; i < l; i++) {\n          var field = fields[i];\n          var fieldName = field.name;\n          var fieldValues = field.values;\n          switch (fieldName) {\n            case \"bboxCenter\":\n              break;\n            case \"bboxSize\":\n              break;\n            case \"center\":\n              break;\n            case \"children\":\n              parseFieldChildren(fieldValues, object);\n              break;\n            case \"collide\":\n              break;\n            case \"rotation\":\n              var axis = new Vector3(fieldValues[0], fieldValues[1], fieldValues[2]).normalize();\n              var angle = fieldValues[3];\n              object.quaternion.setFromAxisAngle(axis, angle);\n              break;\n            case \"scale\":\n              object.scale.set(fieldValues[0], fieldValues[1], fieldValues[2]);\n              break;\n            case \"scaleOrientation\":\n              break;\n            case \"translation\":\n              object.position.set(fieldValues[0], fieldValues[1], fieldValues[2]);\n              break;\n            case \"proxy\":\n              break;\n            default:\n              console.warn(\"THREE.VRMLLoader: Unknown field:\", fieldName);\n              break;\n          }\n        }\n        return object;\n      }\n      function buildBackgroundNode(node) {\n        var group = new Group();\n        var groundAngle, groundColor;\n        var skyAngle, skyColor;\n        var fields = node.fields;\n        for (var i = 0, l = fields.length; i < l; i++) {\n          var field = fields[i];\n          var fieldName = field.name;\n          var fieldValues = field.values;\n          switch (fieldName) {\n            case \"groundAngle\":\n              groundAngle = fieldValues;\n              break;\n            case \"groundColor\":\n              groundColor = fieldValues;\n              break;\n            case \"backUrl\":\n              break;\n            case \"bottomUrl\":\n              break;\n            case \"frontUrl\":\n              break;\n            case \"leftUrl\":\n              break;\n            case \"rightUrl\":\n              break;\n            case \"topUrl\":\n              break;\n            case \"skyAngle\":\n              skyAngle = fieldValues;\n              break;\n            case \"skyColor\":\n              skyColor = fieldValues;\n              break;\n            default:\n              console.warn(\"THREE.VRMLLoader: Unknown field:\", fieldName);\n              break;\n          }\n        }\n        var radius = 1e4;\n        if (skyColor) {\n          var skyGeometry = new SphereGeometry(radius, 32, 16);\n          var skyMaterial = new MeshBasicMaterial({\n            fog: false,\n            side: BackSide,\n            depthWrite: false,\n            depthTest: false\n          });\n          if (skyColor.length > 3) {\n            paintFaces(skyGeometry, radius, skyAngle, toColorArray(skyColor), true);\n            skyMaterial.vertexColors = true;\n          } else {\n            skyMaterial.color.setRGB(skyColor[0], skyColor[1], skyColor[2]);\n          }\n          var sky = new Mesh(skyGeometry, skyMaterial);\n          group.add(sky);\n        }\n        if (groundColor) {\n          if (groundColor.length > 0) {\n            var groundGeometry = new SphereGeometry(radius, 32, 16, 0, 2 * Math.PI, 0.5 * Math.PI, 1.5 * Math.PI);\n            var groundMaterial = new MeshBasicMaterial({\n              fog: false,\n              side: BackSide,\n              vertexColors: true,\n              depthWrite: false,\n              depthTest: false\n            });\n            paintFaces(groundGeometry, radius, groundAngle, toColorArray(groundColor), false);\n            var ground = new Mesh(groundGeometry, groundMaterial);\n            group.add(ground);\n          }\n        }\n        group.renderOrder = -Infinity;\n        return group;\n      }\n      function buildShapeNode(node) {\n        var fields = node.fields;\n        var material = new MeshBasicMaterial({\n          color: 0\n        });\n        var geometry;\n        for (var i = 0, l = fields.length; i < l; i++) {\n          var field = fields[i];\n          var fieldName = field.name;\n          var fieldValues = field.values;\n          switch (fieldName) {\n            case \"appearance\":\n              if (fieldValues[0] !== null) {\n                material = getNode(fieldValues[0]);\n              }\n              break;\n            case \"geometry\":\n              if (fieldValues[0] !== null) {\n                geometry = getNode(fieldValues[0]);\n              }\n              break;\n            default:\n              console.warn(\"THREE.VRMLLoader: Unknown field:\", fieldName);\n              break;\n          }\n        }\n        var object;\n        if (geometry && geometry.attributes.position) {\n          var type = geometry._type;\n          if (type === \"points\") {\n            var pointsMaterial = new PointsMaterial({\n              color: 16777215\n            });\n            if (geometry.attributes.color !== void 0) {\n              pointsMaterial.vertexColors = true;\n            } else {\n              if (material.isMeshPhongMaterial) {\n                pointsMaterial.color.copy(material.emissive);\n              }\n            }\n            object = new Points(geometry, pointsMaterial);\n          } else if (type === \"line\") {\n            var lineMaterial = new LineBasicMaterial({\n              color: 16777215\n            });\n            if (geometry.attributes.color !== void 0) {\n              lineMaterial.vertexColors = true;\n            } else {\n              if (material.isMeshPhongMaterial) {\n                lineMaterial.color.copy(material.emissive);\n              }\n            }\n            object = new LineSegments(geometry, lineMaterial);\n          } else {\n            if (geometry._solid !== void 0) {\n              material.side = geometry._solid ? FrontSide : DoubleSide;\n            }\n            if (geometry.attributes.color !== void 0) {\n              material.vertexColors = true;\n            }\n            object = new Mesh(geometry, material);\n          }\n        } else {\n          object = new Object3D();\n          object.visible = false;\n        }\n        return object;\n      }\n      function buildAppearanceNode(node) {\n        var material = new MeshPhongMaterial();\n        var transformData;\n        var fields = node.fields;\n        for (var i = 0, l = fields.length; i < l; i++) {\n          var field = fields[i];\n          var fieldName = field.name;\n          var fieldValues = field.values;\n          switch (fieldName) {\n            case \"material\":\n              if (fieldValues[0] !== null) {\n                var materialData = getNode(fieldValues[0]);\n                if (materialData.diffuseColor) material.color.copy(materialData.diffuseColor);\n                if (materialData.emissiveColor) material.emissive.copy(materialData.emissiveColor);\n                if (materialData.shininess) material.shininess = materialData.shininess;\n                if (materialData.specularColor) material.specular.copy(materialData.specularColor);\n                if (materialData.transparency) material.opacity = 1 - materialData.transparency;\n                if (materialData.transparency > 0) material.transparent = true;\n              } else {\n                material = new MeshBasicMaterial({\n                  color: 0\n                });\n              }\n              break;\n            case \"texture\":\n              var textureNode = fieldValues[0];\n              if (textureNode !== null) {\n                if (textureNode.name === \"ImageTexture\" || textureNode.name === \"PixelTexture\") {\n                  material.map = getNode(textureNode);\n                }\n              }\n              break;\n            case \"textureTransform\":\n              if (fieldValues[0] !== null) {\n                transformData = getNode(fieldValues[0]);\n              }\n              break;\n            default:\n              console.warn(\"THREE.VRMLLoader: Unknown field:\", fieldName);\n              break;\n          }\n        }\n        if (material.map) {\n          if (material.map.__type) {\n            switch (material.map.__type) {\n              case TEXTURE_TYPE.INTENSITY_ALPHA:\n                material.opacity = 1;\n                break;\n              case TEXTURE_TYPE.RGB:\n                material.color.set(16777215);\n                break;\n              case TEXTURE_TYPE.RGBA:\n                material.color.set(16777215);\n                material.opacity = 1;\n                break;\n            }\n            delete material.map.__type;\n          }\n          if (transformData) {\n            material.map.center.copy(transformData.center);\n            material.map.rotation = transformData.rotation;\n            material.map.repeat.copy(transformData.scale);\n            material.map.offset.copy(transformData.translation);\n          }\n        }\n        return material;\n      }\n      function buildMaterialNode(node) {\n        var materialData = {};\n        var fields = node.fields;\n        for (var i = 0, l = fields.length; i < l; i++) {\n          var field = fields[i];\n          var fieldName = field.name;\n          var fieldValues = field.values;\n          switch (fieldName) {\n            case \"ambientIntensity\":\n              break;\n            case \"diffuseColor\":\n              materialData.diffuseColor = new Color(fieldValues[0], fieldValues[1], fieldValues[2]);\n              break;\n            case \"emissiveColor\":\n              materialData.emissiveColor = new Color(fieldValues[0], fieldValues[1], fieldValues[2]);\n              break;\n            case \"shininess\":\n              materialData.shininess = fieldValues[0];\n              break;\n            case \"specularColor\":\n              materialData.emissiveColor = new Color(fieldValues[0], fieldValues[1], fieldValues[2]);\n              break;\n            case \"transparency\":\n              materialData.transparency = fieldValues[0];\n              break;\n            default:\n              console.warn(\"THREE.VRMLLoader: Unknown field:\", fieldName);\n              break;\n          }\n        }\n        return materialData;\n      }\n      function parseHexColor(hex, textureType, color) {\n        var value;\n        switch (textureType) {\n          case TEXTURE_TYPE.INTENSITY:\n            value = parseInt(hex);\n            color.r = value;\n            color.g = value;\n            color.b = value;\n            color.a = 1;\n            break;\n          case TEXTURE_TYPE.INTENSITY_ALPHA:\n            value = parseInt(\"0x\" + hex.substring(2, 4));\n            color.r = value;\n            color.g = value;\n            color.b = value;\n            color.a = parseInt(\"0x\" + hex.substring(4, 6));\n            break;\n          case TEXTURE_TYPE.RGB:\n            color.r = parseInt(\"0x\" + hex.substring(2, 4));\n            color.g = parseInt(\"0x\" + hex.substring(4, 6));\n            color.b = parseInt(\"0x\" + hex.substring(6, 8));\n            color.a = 1;\n            break;\n          case TEXTURE_TYPE.RGBA:\n            color.r = parseInt(\"0x\" + hex.substring(2, 4));\n            color.g = parseInt(\"0x\" + hex.substring(4, 6));\n            color.b = parseInt(\"0x\" + hex.substring(6, 8));\n            color.a = parseInt(\"0x\" + hex.substring(8, 10));\n            break;\n        }\n      }\n      function getTextureType(num_components) {\n        var type;\n        switch (num_components) {\n          case 1:\n            type = TEXTURE_TYPE.INTENSITY;\n            break;\n          case 2:\n            type = TEXTURE_TYPE.INTENSITY_ALPHA;\n            break;\n          case 3:\n            type = TEXTURE_TYPE.RGB;\n            break;\n          case 4:\n            type = TEXTURE_TYPE.RGBA;\n            break;\n        }\n        return type;\n      }\n      function buildPixelTextureNode(node) {\n        var texture;\n        var wrapS = RepeatWrapping;\n        var wrapT = RepeatWrapping;\n        var fields = node.fields;\n        for (var i = 0, l = fields.length; i < l; i++) {\n          var field = fields[i];\n          var fieldName = field.name;\n          var fieldValues = field.values;\n          switch (fieldName) {\n            case \"image\":\n              var width = fieldValues[0];\n              var height = fieldValues[1];\n              var num_components = fieldValues[2];\n              var textureType = getTextureType(num_components);\n              var data2 = new Uint8Array(4 * width * height);\n              var color = {\n                r: 0,\n                g: 0,\n                b: 0,\n                a: 0\n              };\n              for (var j = 3, k = 0, jl = fieldValues.length; j < jl; j++, k++) {\n                parseHexColor(fieldValues[j], textureType, color);\n                var stride = k * 4;\n                data2[stride + 0] = color.r;\n                data2[stride + 1] = color.g;\n                data2[stride + 2] = color.b;\n                data2[stride + 3] = color.a;\n              }\n              texture = new DataTexture(data2, width, height);\n              texture.needsUpdate = true;\n              texture.__type = textureType;\n              break;\n            case \"repeatS\":\n              if (fieldValues[0] === false) wrapS = ClampToEdgeWrapping;\n              break;\n            case \"repeatT\":\n              if (fieldValues[0] === false) wrapT = ClampToEdgeWrapping;\n              break;\n            default:\n              console.warn(\"THREE.VRMLLoader: Unknown field:\", fieldName);\n              break;\n          }\n        }\n        if (texture) {\n          texture.wrapS = wrapS;\n          texture.wrapT = wrapT;\n        }\n        return texture;\n      }\n      function buildImageTextureNode(node) {\n        var texture;\n        var wrapS = RepeatWrapping;\n        var wrapT = RepeatWrapping;\n        var fields = node.fields;\n        for (var i = 0, l = fields.length; i < l; i++) {\n          var field = fields[i];\n          var fieldName = field.name;\n          var fieldValues = field.values;\n          switch (fieldName) {\n            case \"url\":\n              var url = fieldValues[0];\n              if (url) texture = textureLoader.load(url);\n              break;\n            case \"repeatS\":\n              if (fieldValues[0] === false) wrapS = ClampToEdgeWrapping;\n              break;\n            case \"repeatT\":\n              if (fieldValues[0] === false) wrapT = ClampToEdgeWrapping;\n              break;\n            default:\n              console.warn(\"THREE.VRMLLoader: Unknown field:\", fieldName);\n              break;\n          }\n        }\n        if (texture) {\n          texture.wrapS = wrapS;\n          texture.wrapT = wrapT;\n        }\n        return texture;\n      }\n      function buildTextureTransformNode(node) {\n        var transformData = {\n          center: new Vector2(),\n          rotation: new Vector2(),\n          scale: new Vector2(),\n          translation: new Vector2()\n        };\n        var fields = node.fields;\n        for (var i = 0, l = fields.length; i < l; i++) {\n          var field = fields[i];\n          var fieldName = field.name;\n          var fieldValues = field.values;\n          switch (fieldName) {\n            case \"center\":\n              transformData.center.set(fieldValues[0], fieldValues[1]);\n              break;\n            case \"rotation\":\n              transformData.rotation = fieldValues[0];\n              break;\n            case \"scale\":\n              transformData.scale.set(fieldValues[0], fieldValues[1]);\n              break;\n            case \"translation\":\n              transformData.translation.set(fieldValues[0], fieldValues[1]);\n              break;\n            default:\n              console.warn(\"THREE.VRMLLoader: Unknown field:\", fieldName);\n              break;\n          }\n        }\n        return transformData;\n      }\n      function buildGeometricNode(node) {\n        return node.fields[0].values;\n      }\n      function buildWorldInfoNode(node) {\n        var worldInfo = {};\n        var fields = node.fields;\n        for (var i = 0, l = fields.length; i < l; i++) {\n          var field = fields[i];\n          var fieldName = field.name;\n          var fieldValues = field.values;\n          switch (fieldName) {\n            case \"title\":\n              worldInfo.title = fieldValues[0];\n              break;\n            case \"info\":\n              worldInfo.info = fieldValues;\n              break;\n            default:\n              console.warn(\"THREE.VRMLLoader: Unknown field:\", fieldName);\n              break;\n          }\n        }\n        return worldInfo;\n      }\n      function buildIndexedFaceSetNode(node) {\n        var color, coord, normal, texCoord;\n        var ccw = true,\n          solid = true,\n          creaseAngle = 0;\n        var colorIndex, coordIndex, normalIndex, texCoordIndex;\n        var colorPerVertex = true,\n          normalPerVertex = true;\n        var fields = node.fields;\n        for (var i = 0, l = fields.length; i < l; i++) {\n          var field = fields[i];\n          var fieldName = field.name;\n          var fieldValues = field.values;\n          switch (fieldName) {\n            case \"color\":\n              var colorNode = fieldValues[0];\n              if (colorNode !== null) {\n                color = getNode(colorNode);\n              }\n              break;\n            case \"coord\":\n              var coordNode = fieldValues[0];\n              if (coordNode !== null) {\n                coord = getNode(coordNode);\n              }\n              break;\n            case \"normal\":\n              var normalNode = fieldValues[0];\n              if (normalNode !== null) {\n                normal = getNode(normalNode);\n              }\n              break;\n            case \"texCoord\":\n              var texCoordNode = fieldValues[0];\n              if (texCoordNode !== null) {\n                texCoord = getNode(texCoordNode);\n              }\n              break;\n            case \"ccw\":\n              ccw = fieldValues[0];\n              break;\n            case \"colorIndex\":\n              colorIndex = fieldValues;\n              break;\n            case \"colorPerVertex\":\n              colorPerVertex = fieldValues[0];\n              break;\n            case \"convex\":\n              break;\n            case \"coordIndex\":\n              coordIndex = fieldValues;\n              break;\n            case \"creaseAngle\":\n              creaseAngle = fieldValues[0];\n              break;\n            case \"normalIndex\":\n              normalIndex = fieldValues;\n              break;\n            case \"normalPerVertex\":\n              normalPerVertex = fieldValues[0];\n              break;\n            case \"solid\":\n              solid = fieldValues[0];\n              break;\n            case \"texCoordIndex\":\n              texCoordIndex = fieldValues;\n              break;\n            default:\n              console.warn(\"THREE.VRMLLoader: Unknown field:\", fieldName);\n              break;\n          }\n        }\n        if (coordIndex === void 0) {\n          console.warn(\"THREE.VRMLLoader: Missing coordIndex.\");\n          return new BufferGeometry();\n        }\n        var triangulatedCoordIndex = triangulateFaceIndex(coordIndex, ccw);\n        var colorAttribute;\n        var normalAttribute;\n        var uvAttribute;\n        if (color) {\n          if (colorPerVertex === true) {\n            if (colorIndex && colorIndex.length > 0) {\n              var triangulatedColorIndex = triangulateFaceIndex(colorIndex, ccw);\n              colorAttribute = computeAttributeFromIndexedData(triangulatedCoordIndex, triangulatedColorIndex, color, 3);\n            } else {\n              colorAttribute = toNonIndexedAttribute(triangulatedCoordIndex, new Float32BufferAttribute(color, 3));\n            }\n          } else {\n            if (colorIndex && colorIndex.length > 0) {\n              var flattenFaceColors = flattenData(color, colorIndex);\n              var triangulatedFaceColors = triangulateFaceData(flattenFaceColors, coordIndex);\n              colorAttribute = computeAttributeFromFaceData(triangulatedCoordIndex, triangulatedFaceColors);\n            } else {\n              var _triangulatedFaceColors = triangulateFaceData(color, coordIndex);\n              colorAttribute = computeAttributeFromFaceData(triangulatedCoordIndex, _triangulatedFaceColors);\n            }\n          }\n        }\n        if (normal) {\n          if (normalPerVertex === true) {\n            if (normalIndex && normalIndex.length > 0) {\n              var triangulatedNormalIndex = triangulateFaceIndex(normalIndex, ccw);\n              normalAttribute = computeAttributeFromIndexedData(triangulatedCoordIndex, triangulatedNormalIndex, normal, 3);\n            } else {\n              normalAttribute = toNonIndexedAttribute(triangulatedCoordIndex, new Float32BufferAttribute(normal, 3));\n            }\n          } else {\n            if (normalIndex && normalIndex.length > 0) {\n              var flattenFaceNormals = flattenData(normal, normalIndex);\n              var triangulatedFaceNormals = triangulateFaceData(flattenFaceNormals, coordIndex);\n              normalAttribute = computeAttributeFromFaceData(triangulatedCoordIndex, triangulatedFaceNormals);\n            } else {\n              var _triangulatedFaceNormals = triangulateFaceData(normal, coordIndex);\n              normalAttribute = computeAttributeFromFaceData(triangulatedCoordIndex, _triangulatedFaceNormals);\n            }\n          }\n        } else {\n          normalAttribute = computeNormalAttribute(triangulatedCoordIndex, coord, creaseAngle);\n        }\n        if (texCoord) {\n          if (texCoordIndex && texCoordIndex.length > 0) {\n            var triangulatedTexCoordIndex = triangulateFaceIndex(texCoordIndex, ccw);\n            uvAttribute = computeAttributeFromIndexedData(triangulatedCoordIndex, triangulatedTexCoordIndex, texCoord, 2);\n          } else {\n            uvAttribute = toNonIndexedAttribute(triangulatedCoordIndex, new Float32BufferAttribute(texCoord, 2));\n          }\n        }\n        var geometry = new BufferGeometry();\n        var positionAttribute = toNonIndexedAttribute(triangulatedCoordIndex, new Float32BufferAttribute(coord, 3));\n        geometry.setAttribute(\"position\", positionAttribute);\n        geometry.setAttribute(\"normal\", normalAttribute);\n        if (colorAttribute) geometry.setAttribute(\"color\", colorAttribute);\n        if (uvAttribute) geometry.setAttribute(\"uv\", uvAttribute);\n        geometry._solid = solid;\n        geometry._type = \"mesh\";\n        return geometry;\n      }\n      function buildIndexedLineSetNode(node) {\n        var color, coord;\n        var colorIndex, coordIndex;\n        var colorPerVertex = true;\n        var fields = node.fields;\n        for (var i = 0, l = fields.length; i < l; i++) {\n          var field = fields[i];\n          var fieldName = field.name;\n          var fieldValues = field.values;\n          switch (fieldName) {\n            case \"color\":\n              var colorNode = fieldValues[0];\n              if (colorNode !== null) {\n                color = getNode(colorNode);\n              }\n              break;\n            case \"coord\":\n              var coordNode = fieldValues[0];\n              if (coordNode !== null) {\n                coord = getNode(coordNode);\n              }\n              break;\n            case \"colorIndex\":\n              colorIndex = fieldValues;\n              break;\n            case \"colorPerVertex\":\n              colorPerVertex = fieldValues[0];\n              break;\n            case \"coordIndex\":\n              coordIndex = fieldValues;\n              break;\n            default:\n              console.warn(\"THREE.VRMLLoader: Unknown field:\", fieldName);\n              break;\n          }\n        }\n        var colorAttribute;\n        var expandedLineIndex = expandLineIndex(coordIndex);\n        if (color) {\n          if (colorPerVertex === true) {\n            if (colorIndex.length > 0) {\n              var expandedColorIndex = expandLineIndex(colorIndex);\n              colorAttribute = computeAttributeFromIndexedData(expandedLineIndex, expandedColorIndex, color, 3);\n            } else {\n              colorAttribute = toNonIndexedAttribute(expandedLineIndex, new Float32BufferAttribute(color, 3));\n            }\n          } else {\n            if (colorIndex.length > 0) {\n              var flattenLineColors = flattenData(color, colorIndex);\n              var expandedLineColors = expandLineData(flattenLineColors, coordIndex);\n              colorAttribute = computeAttributeFromLineData(expandedLineIndex, expandedLineColors);\n            } else {\n              var _expandedLineColors = expandLineData(color, coordIndex);\n              colorAttribute = computeAttributeFromLineData(expandedLineIndex, _expandedLineColors);\n            }\n          }\n        }\n        var geometry = new BufferGeometry();\n        var positionAttribute = toNonIndexedAttribute(expandedLineIndex, new Float32BufferAttribute(coord, 3));\n        geometry.setAttribute(\"position\", positionAttribute);\n        if (colorAttribute) geometry.setAttribute(\"color\", colorAttribute);\n        geometry._type = \"line\";\n        return geometry;\n      }\n      function buildPointSetNode(node) {\n        var color, coord;\n        var fields = node.fields;\n        for (var i = 0, l = fields.length; i < l; i++) {\n          var field = fields[i];\n          var fieldName = field.name;\n          var fieldValues = field.values;\n          switch (fieldName) {\n            case \"color\":\n              var colorNode = fieldValues[0];\n              if (colorNode !== null) {\n                color = getNode(colorNode);\n              }\n              break;\n            case \"coord\":\n              var coordNode = fieldValues[0];\n              if (coordNode !== null) {\n                coord = getNode(coordNode);\n              }\n              break;\n            default:\n              console.warn(\"THREE.VRMLLoader: Unknown field:\", fieldName);\n              break;\n          }\n        }\n        var geometry = new BufferGeometry();\n        geometry.setAttribute(\"position\", new Float32BufferAttribute(coord, 3));\n        if (color) geometry.setAttribute(\"color\", new Float32BufferAttribute(color, 3));\n        geometry._type = \"points\";\n        return geometry;\n      }\n      function buildBoxNode(node) {\n        var size = new Vector3(2, 2, 2);\n        var fields = node.fields;\n        for (var i = 0, l = fields.length; i < l; i++) {\n          var field = fields[i];\n          var fieldName = field.name;\n          var fieldValues = field.values;\n          switch (fieldName) {\n            case \"size\":\n              size.x = fieldValues[0];\n              size.y = fieldValues[1];\n              size.z = fieldValues[2];\n              break;\n            default:\n              console.warn(\"THREE.VRMLLoader: Unknown field:\", fieldName);\n              break;\n          }\n        }\n        var geometry = new BoxGeometry(size.x, size.y, size.z);\n        return geometry;\n      }\n      function buildConeNode(node) {\n        var radius = 1,\n          height = 2,\n          openEnded = false;\n        var fields = node.fields;\n        for (var i = 0, l = fields.length; i < l; i++) {\n          var field = fields[i];\n          var fieldName = field.name;\n          var fieldValues = field.values;\n          switch (fieldName) {\n            case \"bottom\":\n              openEnded = !fieldValues[0];\n              break;\n            case \"bottomRadius\":\n              radius = fieldValues[0];\n              break;\n            case \"height\":\n              height = fieldValues[0];\n              break;\n            case \"side\":\n              break;\n            default:\n              console.warn(\"THREE.VRMLLoader: Unknown field:\", fieldName);\n              break;\n          }\n        }\n        var geometry = new ConeGeometry(radius, height, 16, 1, openEnded);\n        return geometry;\n      }\n      function buildCylinderNode(node) {\n        var radius = 1,\n          height = 2;\n        var fields = node.fields;\n        for (var i = 0, l = fields.length; i < l; i++) {\n          var field = fields[i];\n          var fieldName = field.name;\n          var fieldValues = field.values;\n          switch (fieldName) {\n            case \"bottom\":\n              break;\n            case \"radius\":\n              radius = fieldValues[0];\n              break;\n            case \"height\":\n              height = fieldValues[0];\n              break;\n            case \"side\":\n              break;\n            case \"top\":\n              break;\n            default:\n              console.warn(\"THREE.VRMLLoader: Unknown field:\", fieldName);\n              break;\n          }\n        }\n        var geometry = new CylinderGeometry(radius, radius, height, 16, 1);\n        return geometry;\n      }\n      function buildSphereNode(node) {\n        var radius = 1;\n        var fields = node.fields;\n        for (var i = 0, l = fields.length; i < l; i++) {\n          var field = fields[i];\n          var fieldName = field.name;\n          var fieldValues = field.values;\n          switch (fieldName) {\n            case \"radius\":\n              radius = fieldValues[0];\n              break;\n            default:\n              console.warn(\"THREE.VRMLLoader: Unknown field:\", fieldName);\n              break;\n          }\n        }\n        var geometry = new SphereGeometry(radius, 16, 16);\n        return geometry;\n      }\n      function buildElevationGridNode(node) {\n        var color;\n        var normal;\n        var texCoord;\n        var height;\n        var colorPerVertex = true;\n        var normalPerVertex = true;\n        var solid = true;\n        var ccw = true;\n        var creaseAngle = 0;\n        var xDimension = 2;\n        var zDimension = 2;\n        var xSpacing = 1;\n        var zSpacing = 1;\n        var fields = node.fields;\n        for (var i = 0, l = fields.length; i < l; i++) {\n          var field = fields[i];\n          var fieldName = field.name;\n          var fieldValues = field.values;\n          switch (fieldName) {\n            case \"color\":\n              var colorNode = fieldValues[0];\n              if (colorNode !== null) {\n                color = getNode(colorNode);\n              }\n              break;\n            case \"normal\":\n              var normalNode = fieldValues[0];\n              if (normalNode !== null) {\n                normal = getNode(normalNode);\n              }\n              break;\n            case \"texCoord\":\n              var texCoordNode = fieldValues[0];\n              if (texCoordNode !== null) {\n                texCoord = getNode(texCoordNode);\n              }\n              break;\n            case \"height\":\n              height = fieldValues;\n              break;\n            case \"ccw\":\n              ccw = fieldValues[0];\n              break;\n            case \"colorPerVertex\":\n              colorPerVertex = fieldValues[0];\n              break;\n            case \"creaseAngle\":\n              creaseAngle = fieldValues[0];\n              break;\n            case \"normalPerVertex\":\n              normalPerVertex = fieldValues[0];\n              break;\n            case \"solid\":\n              solid = fieldValues[0];\n              break;\n            case \"xDimension\":\n              xDimension = fieldValues[0];\n              break;\n            case \"xSpacing\":\n              xSpacing = fieldValues[0];\n              break;\n            case \"zDimension\":\n              zDimension = fieldValues[0];\n              break;\n            case \"zSpacing\":\n              zSpacing = fieldValues[0];\n              break;\n            default:\n              console.warn(\"THREE.VRMLLoader: Unknown field:\", fieldName);\n              break;\n          }\n        }\n        var vertices = [];\n        var normals = [];\n        var colors = [];\n        var uvs = [];\n        for (var _i9 = 0; _i9 < zDimension; _i9++) {\n          for (var j = 0; j < xDimension; j++) {\n            var index = _i9 * xDimension + j;\n            var x = xSpacing * _i9;\n            var y = height[index];\n            var z = zSpacing * j;\n            vertices.push(x, y, z);\n            if (color && colorPerVertex === true) {\n              var r = color[index * 3 + 0];\n              var g = color[index * 3 + 1];\n              var b = color[index * 3 + 2];\n              colors.push(r, g, b);\n            }\n            if (normal && normalPerVertex === true) {\n              var xn = normal[index * 3 + 0];\n              var yn = normal[index * 3 + 1];\n              var zn = normal[index * 3 + 2];\n              normals.push(xn, yn, zn);\n            }\n            if (texCoord) {\n              var s = texCoord[index * 2 + 0];\n              var t = texCoord[index * 2 + 1];\n              uvs.push(s, t);\n            } else {\n              uvs.push(_i9 / (xDimension - 1), j / (zDimension - 1));\n            }\n          }\n        }\n        var indices = [];\n        for (var _i10 = 0; _i10 < xDimension - 1; _i10++) {\n          for (var _j = 0; _j < zDimension - 1; _j++) {\n            var a = _i10 + _j * xDimension;\n            var _b = _i10 + (_j + 1) * xDimension;\n            var c = _i10 + 1 + (_j + 1) * xDimension;\n            var d = _i10 + 1 + _j * xDimension;\n            if (ccw === true) {\n              indices.push(a, c, _b);\n              indices.push(c, a, d);\n            } else {\n              indices.push(a, _b, c);\n              indices.push(c, d, a);\n            }\n          }\n        }\n        var positionAttribute = toNonIndexedAttribute(indices, new Float32BufferAttribute(vertices, 3));\n        var uvAttribute = toNonIndexedAttribute(indices, new Float32BufferAttribute(uvs, 2));\n        var colorAttribute;\n        var normalAttribute;\n        if (color) {\n          if (colorPerVertex === false) {\n            for (var _i11 = 0; _i11 < xDimension - 1; _i11++) {\n              for (var _j2 = 0; _j2 < zDimension - 1; _j2++) {\n                var _index = _i11 + _j2 * (xDimension - 1);\n                var _r = color[_index * 3 + 0];\n                var _g = color[_index * 3 + 1];\n                var _b2 = color[_index * 3 + 2];\n                colors.push(_r, _g, _b2);\n                colors.push(_r, _g, _b2);\n                colors.push(_r, _g, _b2);\n                colors.push(_r, _g, _b2);\n                colors.push(_r, _g, _b2);\n                colors.push(_r, _g, _b2);\n              }\n            }\n            colorAttribute = new Float32BufferAttribute(colors, 3);\n          } else {\n            colorAttribute = toNonIndexedAttribute(indices, new Float32BufferAttribute(colors, 3));\n          }\n        }\n        if (normal) {\n          if (normalPerVertex === false) {\n            for (var _i12 = 0; _i12 < xDimension - 1; _i12++) {\n              for (var _j3 = 0; _j3 < zDimension - 1; _j3++) {\n                var _index2 = _i12 + _j3 * (xDimension - 1);\n                var _xn = normal[_index2 * 3 + 0];\n                var _yn = normal[_index2 * 3 + 1];\n                var _zn = normal[_index2 * 3 + 2];\n                normals.push(_xn, _yn, _zn);\n                normals.push(_xn, _yn, _zn);\n                normals.push(_xn, _yn, _zn);\n                normals.push(_xn, _yn, _zn);\n                normals.push(_xn, _yn, _zn);\n                normals.push(_xn, _yn, _zn);\n              }\n            }\n            normalAttribute = new Float32BufferAttribute(normals, 3);\n          } else {\n            normalAttribute = toNonIndexedAttribute(indices, new Float32BufferAttribute(normals, 3));\n          }\n        } else {\n          normalAttribute = computeNormalAttribute(indices, vertices, creaseAngle);\n        }\n        var geometry = new BufferGeometry();\n        geometry.setAttribute(\"position\", positionAttribute);\n        geometry.setAttribute(\"normal\", normalAttribute);\n        geometry.setAttribute(\"uv\", uvAttribute);\n        if (colorAttribute) geometry.setAttribute(\"color\", colorAttribute);\n        geometry._solid = solid;\n        geometry._type = \"mesh\";\n        return geometry;\n      }\n      function buildExtrusionNode(node) {\n        var crossSection = [1, 1, 1, -1, -1, -1, -1, 1, 1, 1];\n        var spine = [0, 0, 0, 0, 1, 0];\n        var scale;\n        var orientation;\n        var beginCap = true;\n        var ccw = true;\n        var creaseAngle = 0;\n        var endCap = true;\n        var solid = true;\n        var fields = node.fields;\n        for (var i = 0, l = fields.length; i < l; i++) {\n          var field = fields[i];\n          var fieldName = field.name;\n          var fieldValues = field.values;\n          switch (fieldName) {\n            case \"beginCap\":\n              beginCap = fieldValues[0];\n              break;\n            case \"ccw\":\n              ccw = fieldValues[0];\n              break;\n            case \"convex\":\n              break;\n            case \"creaseAngle\":\n              creaseAngle = fieldValues[0];\n              break;\n            case \"crossSection\":\n              crossSection = fieldValues;\n              break;\n            case \"endCap\":\n              endCap = fieldValues[0];\n              break;\n            case \"orientation\":\n              orientation = fieldValues;\n              break;\n            case \"scale\":\n              scale = fieldValues;\n              break;\n            case \"solid\":\n              solid = fieldValues[0];\n              break;\n            case \"spine\":\n              spine = fieldValues;\n              break;\n            default:\n              console.warn(\"THREE.VRMLLoader: Unknown field:\", fieldName);\n              break;\n          }\n        }\n        var crossSectionClosed = crossSection[0] === crossSection[crossSection.length - 2] && crossSection[1] === crossSection[crossSection.length - 1];\n        var vertices = [];\n        var spineVector = new Vector3();\n        var scaling = new Vector3();\n        var axis = new Vector3();\n        var vertex = new Vector3();\n        var quaternion = new Quaternion();\n        for (var _i13 = 0, j = 0, o = 0, il = spine.length; _i13 < il; _i13 += 3, j += 2, o += 4) {\n          spineVector.fromArray(spine, _i13);\n          scaling.x = scale ? scale[j + 0] : 1;\n          scaling.y = 1;\n          scaling.z = scale ? scale[j + 1] : 1;\n          axis.x = orientation ? orientation[o + 0] : 0;\n          axis.y = orientation ? orientation[o + 1] : 0;\n          axis.z = orientation ? orientation[o + 2] : 1;\n          var angle = orientation ? orientation[o + 3] : 0;\n          for (var k = 0, kl = crossSection.length; k < kl; k += 2) {\n            vertex.x = crossSection[k + 0];\n            vertex.y = 0;\n            vertex.z = crossSection[k + 1];\n            vertex.multiply(scaling);\n            quaternion.setFromAxisAngle(axis, angle);\n            vertex.applyQuaternion(quaternion);\n            vertex.add(spineVector);\n            vertices.push(vertex.x, vertex.y, vertex.z);\n          }\n        }\n        var indices = [];\n        var spineCount = spine.length / 3;\n        var crossSectionCount = crossSection.length / 2;\n        for (var _i14 = 0; _i14 < spineCount - 1; _i14++) {\n          for (var _j4 = 0; _j4 < crossSectionCount - 1; _j4++) {\n            var a = _j4 + _i14 * crossSectionCount;\n            var b = _j4 + 1 + _i14 * crossSectionCount;\n            var c = _j4 + (_i14 + 1) * crossSectionCount;\n            var d = _j4 + 1 + (_i14 + 1) * crossSectionCount;\n            if (_j4 === crossSectionCount - 2 && crossSectionClosed === true) {\n              b = _i14 * crossSectionCount;\n              d = (_i14 + 1) * crossSectionCount;\n            }\n            if (ccw === true) {\n              indices.push(a, b, c);\n              indices.push(c, b, d);\n            } else {\n              indices.push(a, c, b);\n              indices.push(c, d, b);\n            }\n          }\n        }\n        if (beginCap === true || endCap === true) {\n          var contour = [];\n          for (var _i15 = 0, _l9 = crossSection.length; _i15 < _l9; _i15 += 2) {\n            contour.push(new Vector2(crossSection[_i15], crossSection[_i15 + 1]));\n          }\n          var faces = ShapeUtils.triangulateShape(contour, []);\n          var capIndices = [];\n          for (var _i16 = 0, _l10 = faces.length; _i16 < _l10; _i16++) {\n            var face = faces[_i16];\n            capIndices.push(face[0], face[1], face[2]);\n          }\n          if (beginCap === true) {\n            for (var _i17 = 0, _l11 = capIndices.length; _i17 < _l11; _i17 += 3) {\n              if (ccw === true) {\n                indices.push(capIndices[_i17 + 0], capIndices[_i17 + 1], capIndices[_i17 + 2]);\n              } else {\n                indices.push(capIndices[_i17 + 0], capIndices[_i17 + 2], capIndices[_i17 + 1]);\n              }\n            }\n          }\n          if (endCap === true) {\n            var indexOffset = crossSectionCount * (spineCount - 1);\n            for (var _i18 = 0, _l12 = capIndices.length; _i18 < _l12; _i18 += 3) {\n              if (ccw === true) {\n                indices.push(indexOffset + capIndices[_i18 + 0], indexOffset + capIndices[_i18 + 2], indexOffset + capIndices[_i18 + 1]);\n              } else {\n                indices.push(indexOffset + capIndices[_i18 + 0], indexOffset + capIndices[_i18 + 1], indexOffset + capIndices[_i18 + 2]);\n              }\n            }\n          }\n        }\n        var positionAttribute = toNonIndexedAttribute(indices, new Float32BufferAttribute(vertices, 3));\n        var normalAttribute = computeNormalAttribute(indices, vertices, creaseAngle);\n        var geometry = new BufferGeometry();\n        geometry.setAttribute(\"position\", positionAttribute);\n        geometry.setAttribute(\"normal\", normalAttribute);\n        geometry._solid = solid;\n        geometry._type = \"mesh\";\n        return geometry;\n      }\n      function resolveUSE(identifier) {\n        var node = nodeMap[identifier];\n        var build = getNode(node);\n        return build.isObject3D || build.isMaterial ? build.clone() : build;\n      }\n      function parseFieldChildren(children, owner) {\n        for (var i = 0, l = children.length; i < l; i++) {\n          var object = getNode(children[i]);\n          if (object instanceof Object3D) owner.add(object);\n        }\n      }\n      function triangulateFaceIndex(index, ccw) {\n        var indices = [];\n        var start = 0;\n        for (var i = 0, l = index.length; i < l; i++) {\n          var i1 = index[start];\n          var i2 = index[i + (ccw ? 1 : 2)];\n          var i3 = index[i + (ccw ? 2 : 1)];\n          indices.push(i1, i2, i3);\n          if (index[i + 3] === -1 || i + 3 >= l) {\n            i += 3;\n            start = i + 1;\n          }\n        }\n        return indices;\n      }\n      function triangulateFaceData(data2, index) {\n        var triangulatedData = [];\n        var start = 0;\n        for (var i = 0, l = index.length; i < l; i++) {\n          var stride = start * 3;\n          var x = data2[stride];\n          var y = data2[stride + 1];\n          var z = data2[stride + 2];\n          triangulatedData.push(x, y, z);\n          if (index[i + 3] === -1 || i + 3 >= l) {\n            i += 3;\n            start++;\n          }\n        }\n        return triangulatedData;\n      }\n      function flattenData(data2, index) {\n        var flattenData2 = [];\n        for (var i = 0, l = index.length; i < l; i++) {\n          var i1 = index[i];\n          var stride = i1 * 3;\n          var x = data2[stride];\n          var y = data2[stride + 1];\n          var z = data2[stride + 2];\n          flattenData2.push(x, y, z);\n        }\n        return flattenData2;\n      }\n      function expandLineIndex(index) {\n        var indices = [];\n        for (var i = 0, l = index.length; i < l; i++) {\n          var i1 = index[i];\n          var i2 = index[i + 1];\n          indices.push(i1, i2);\n          if (index[i + 2] === -1 || i + 2 >= l) {\n            i += 2;\n          }\n        }\n        return indices;\n      }\n      function expandLineData(data2, index) {\n        var triangulatedData = [];\n        var start = 0;\n        for (var i = 0, l = index.length; i < l; i++) {\n          var stride = start * 3;\n          var x = data2[stride];\n          var y = data2[stride + 1];\n          var z = data2[stride + 2];\n          triangulatedData.push(x, y, z);\n          if (index[i + 2] === -1 || i + 2 >= l) {\n            i += 2;\n            start++;\n          }\n        }\n        return triangulatedData;\n      }\n      var vA = new Vector3();\n      var vB = new Vector3();\n      var vC = new Vector3();\n      var uvA = new Vector2();\n      var uvB = new Vector2();\n      var uvC = new Vector2();\n      function computeAttributeFromIndexedData(coordIndex, index, data2, itemSize) {\n        var array = [];\n        for (var i = 0, l = coordIndex.length; i < l; i += 3) {\n          var a = index[i];\n          var b = index[i + 1];\n          var c = index[i + 2];\n          if (itemSize === 2) {\n            uvA.fromArray(data2, a * itemSize);\n            uvB.fromArray(data2, b * itemSize);\n            uvC.fromArray(data2, c * itemSize);\n            array.push(uvA.x, uvA.y);\n            array.push(uvB.x, uvB.y);\n            array.push(uvC.x, uvC.y);\n          } else {\n            vA.fromArray(data2, a * itemSize);\n            vB.fromArray(data2, b * itemSize);\n            vC.fromArray(data2, c * itemSize);\n            array.push(vA.x, vA.y, vA.z);\n            array.push(vB.x, vB.y, vB.z);\n            array.push(vC.x, vC.y, vC.z);\n          }\n        }\n        return new Float32BufferAttribute(array, itemSize);\n      }\n      function computeAttributeFromFaceData(index, faceData) {\n        var array = [];\n        for (var i = 0, j = 0, l = index.length; i < l; i += 3, j++) {\n          vA.fromArray(faceData, j * 3);\n          array.push(vA.x, vA.y, vA.z);\n          array.push(vA.x, vA.y, vA.z);\n          array.push(vA.x, vA.y, vA.z);\n        }\n        return new Float32BufferAttribute(array, 3);\n      }\n      function computeAttributeFromLineData(index, lineData) {\n        var array = [];\n        for (var i = 0, j = 0, l = index.length; i < l; i += 2, j++) {\n          vA.fromArray(lineData, j * 3);\n          array.push(vA.x, vA.y, vA.z);\n          array.push(vA.x, vA.y, vA.z);\n        }\n        return new Float32BufferAttribute(array, 3);\n      }\n      function toNonIndexedAttribute(indices, attribute) {\n        var array = attribute.array;\n        var itemSize = attribute.itemSize;\n        var array2 = new array.constructor(indices.length * itemSize);\n        var index = 0,\n          index2 = 0;\n        for (var i = 0, l = indices.length; i < l; i++) {\n          index = indices[i] * itemSize;\n          for (var j = 0; j < itemSize; j++) {\n            array2[index2++] = array[index++];\n          }\n        }\n        return new Float32BufferAttribute(array2, itemSize);\n      }\n      var ab = new Vector3();\n      var cb = new Vector3();\n      function computeNormalAttribute(index, coord, creaseAngle) {\n        var faces = [];\n        var vertexNormals = {};\n        for (var i = 0, l = index.length; i < l; i += 3) {\n          var a = index[i];\n          var b = index[i + 1];\n          var c = index[i + 2];\n          var face = new Face(a, b, c);\n          vA.fromArray(coord, a * 3);\n          vB.fromArray(coord, b * 3);\n          vC.fromArray(coord, c * 3);\n          cb.subVectors(vC, vB);\n          ab.subVectors(vA, vB);\n          cb.cross(ab);\n          cb.normalize();\n          face.normal.copy(cb);\n          if (vertexNormals[a] === void 0) vertexNormals[a] = [];\n          if (vertexNormals[b] === void 0) vertexNormals[b] = [];\n          if (vertexNormals[c] === void 0) vertexNormals[c] = [];\n          vertexNormals[a].push(face.normal);\n          vertexNormals[b].push(face.normal);\n          vertexNormals[c].push(face.normal);\n          faces.push(face);\n        }\n        var normals = [];\n        for (var _i19 = 0, _l13 = faces.length; _i19 < _l13; _i19++) {\n          var _face = faces[_i19];\n          var nA = weightedNormal(vertexNormals[_face.a], _face.normal, creaseAngle);\n          var nB = weightedNormal(vertexNormals[_face.b], _face.normal, creaseAngle);\n          var nC = weightedNormal(vertexNormals[_face.c], _face.normal, creaseAngle);\n          vA.fromArray(coord, _face.a * 3);\n          vB.fromArray(coord, _face.b * 3);\n          vC.fromArray(coord, _face.c * 3);\n          normals.push(nA.x, nA.y, nA.z);\n          normals.push(nB.x, nB.y, nB.z);\n          normals.push(nC.x, nC.y, nC.z);\n        }\n        return new Float32BufferAttribute(normals, 3);\n      }\n      function weightedNormal(normals, vector, creaseAngle) {\n        var normal = new Vector3();\n        if (creaseAngle === 0) {\n          normal.copy(vector);\n        } else {\n          for (var i = 0, l = normals.length; i < l; i++) {\n            if (normals[i].angleTo(vector) < creaseAngle) {\n              normal.add(normals[i]);\n            }\n          }\n        }\n        return normal.normalize();\n      }\n      function toColorArray(colors) {\n        var array = [];\n        for (var i = 0, l = colors.length; i < l; i += 3) {\n          array.push(new Color(colors[i], colors[i + 1], colors[i + 2]));\n        }\n        return array;\n      }\n      function paintFaces(geometry, radius, angles, colors, topDown) {\n        var thresholds = [];\n        var startAngle = topDown === true ? 0 : Math.PI;\n        for (var i = 0, l = colors.length; i < l; i++) {\n          var angle = i === 0 ? 0 : angles[i - 1];\n          angle = topDown === true ? angle : startAngle - angle;\n          var point = new Vector3();\n          point.setFromSphericalCoords(radius, angle, 0);\n          thresholds.push(point);\n        }\n        var indices = geometry.index;\n        var positionAttribute = geometry.attributes.position;\n        var colorAttribute = new BufferAttribute(new Float32Array(geometry.attributes.position.count * 3), 3);\n        var position = new Vector3();\n        var color = new Color();\n        for (var _i20 = 0; _i20 < indices.count; _i20++) {\n          var index = indices.getX(_i20);\n          position.fromBufferAttribute(positionAttribute, index);\n          var thresholdIndexA = void 0,\n            thresholdIndexB = void 0;\n          var t = 1;\n          for (var j = 1; j < thresholds.length; j++) {\n            thresholdIndexA = j - 1;\n            thresholdIndexB = j;\n            var thresholdA = thresholds[thresholdIndexA];\n            var thresholdB = thresholds[thresholdIndexB];\n            if (topDown === true) {\n              if (position.y <= thresholdA.y && position.y > thresholdB.y) {\n                t = Math.abs(thresholdA.y - position.y) / Math.abs(thresholdA.y - thresholdB.y);\n                break;\n              }\n            } else {\n              if (position.y >= thresholdA.y && position.y < thresholdB.y) {\n                t = Math.abs(thresholdA.y - position.y) / Math.abs(thresholdA.y - thresholdB.y);\n                break;\n              }\n            }\n          }\n          var colorA = colors[thresholdIndexA];\n          var colorB = colors[thresholdIndexB];\n          color.copy(colorA).lerp(colorB, t);\n          colorAttribute.setXYZ(index, color.r, color.g, color.b);\n        }\n        geometry.setAttribute(\"color\", colorAttribute);\n      }\n      var textureLoader = new TextureLoader(this.manager);\n      textureLoader.setPath(this.resourcePath || path).setCrossOrigin(this.crossOrigin);\n      if (data.indexOf(\"#VRML V2.0\") === -1) {\n        throw Error(\"THREE.VRMLLexer: Version of VRML asset not supported.\");\n      }\n      var tree = generateVRMLTree(data);\n      var scene = parseTree(tree);\n      return scene;\n    }\n  }]);\n  return VRMLLoader;\n}(Loader);\nvar VRMLLexer = /*#__PURE__*/function () {\n  function VRMLLexer(tokens) {\n    _classCallCheck(this, VRMLLexer);\n    this.lexer = new Lexer(tokens);\n  }\n  _createClass(VRMLLexer, [{\n    key: \"lex\",\n    value: function lex(inputText) {\n      var lexingResult = this.lexer.tokenize(inputText);\n      if (lexingResult.errors.length > 0) {\n        console.error(lexingResult.errors);\n        throw Error(\"THREE.VRMLLexer: Lexing errors detected.\");\n      }\n      return lexingResult;\n    }\n  }]);\n  return VRMLLexer;\n}();\nvar VRMLParser = /*#__PURE__*/function (_CstParser) {\n  _inherits(VRMLParser, _CstParser);\n  var _super2 = _createSuper(VRMLParser);\n  function VRMLParser(tokenVocabulary) {\n    var _this;\n    _classCallCheck(this, VRMLParser);\n    _this = _super2.call(this, tokenVocabulary);\n    var $ = _assertThisInitialized(_this);\n    var Version = tokenVocabulary[\"Version\"];\n    var LCurly = tokenVocabulary[\"LCurly\"];\n    var RCurly = tokenVocabulary[\"RCurly\"];\n    var LSquare = tokenVocabulary[\"LSquare\"];\n    var RSquare = tokenVocabulary[\"RSquare\"];\n    var Identifier = tokenVocabulary[\"Identifier\"];\n    var RouteIdentifier = tokenVocabulary[\"RouteIdentifier\"];\n    var StringLiteral = tokenVocabulary[\"StringLiteral\"];\n    var HexLiteral = tokenVocabulary[\"HexLiteral\"];\n    var NumberLiteral = tokenVocabulary[\"NumberLiteral\"];\n    var TrueLiteral = tokenVocabulary[\"TrueLiteral\"];\n    var FalseLiteral = tokenVocabulary[\"FalseLiteral\"];\n    var NullLiteral = tokenVocabulary[\"NullLiteral\"];\n    var DEF = tokenVocabulary[\"DEF\"];\n    var USE = tokenVocabulary[\"USE\"];\n    var ROUTE = tokenVocabulary[\"ROUTE\"];\n    var TO = tokenVocabulary[\"TO\"];\n    var NodeName = tokenVocabulary[\"NodeName\"];\n    $.RULE(\"vrml\", function () {\n      $.SUBRULE($.version);\n      $.AT_LEAST_ONE(function () {\n        $.SUBRULE($.node);\n      });\n      $.MANY(function () {\n        $.SUBRULE($.route);\n      });\n    });\n    $.RULE(\"version\", function () {\n      $.CONSUME(Version);\n    });\n    $.RULE(\"node\", function () {\n      $.OPTION(function () {\n        $.SUBRULE($.def);\n      });\n      $.CONSUME(NodeName);\n      $.CONSUME(LCurly);\n      $.MANY(function () {\n        $.SUBRULE($.field);\n      });\n      $.CONSUME(RCurly);\n    });\n    $.RULE(\"field\", function () {\n      $.CONSUME(Identifier);\n      $.OR2([{\n        ALT: function ALT() {\n          $.SUBRULE($.singleFieldValue);\n        }\n      }, {\n        ALT: function ALT() {\n          $.SUBRULE($.multiFieldValue);\n        }\n      }]);\n    });\n    $.RULE(\"def\", function () {\n      $.CONSUME(DEF);\n      $.OR([{\n        ALT: function ALT() {\n          $.CONSUME(Identifier);\n        }\n      }, {\n        ALT: function ALT() {\n          $.CONSUME(NodeName);\n        }\n      }]);\n    });\n    $.RULE(\"use\", function () {\n      $.CONSUME(USE);\n      $.OR([{\n        ALT: function ALT() {\n          $.CONSUME(Identifier);\n        }\n      }, {\n        ALT: function ALT() {\n          $.CONSUME(NodeName);\n        }\n      }]);\n    });\n    $.RULE(\"singleFieldValue\", function () {\n      $.AT_LEAST_ONE(function () {\n        $.OR([{\n          ALT: function ALT() {\n            $.SUBRULE($.node);\n          }\n        }, {\n          ALT: function ALT() {\n            $.SUBRULE($.use);\n          }\n        }, {\n          ALT: function ALT() {\n            $.CONSUME(StringLiteral);\n          }\n        }, {\n          ALT: function ALT() {\n            $.CONSUME(HexLiteral);\n          }\n        }, {\n          ALT: function ALT() {\n            $.CONSUME(NumberLiteral);\n          }\n        }, {\n          ALT: function ALT() {\n            $.CONSUME(TrueLiteral);\n          }\n        }, {\n          ALT: function ALT() {\n            $.CONSUME(FalseLiteral);\n          }\n        }, {\n          ALT: function ALT() {\n            $.CONSUME(NullLiteral);\n          }\n        }]);\n      });\n    });\n    $.RULE(\"multiFieldValue\", function () {\n      $.CONSUME(LSquare);\n      $.MANY(function () {\n        $.OR([{\n          ALT: function ALT() {\n            $.SUBRULE($.node);\n          }\n        }, {\n          ALT: function ALT() {\n            $.SUBRULE($.use);\n          }\n        }, {\n          ALT: function ALT() {\n            $.CONSUME(StringLiteral);\n          }\n        }, {\n          ALT: function ALT() {\n            $.CONSUME(HexLiteral);\n          }\n        }, {\n          ALT: function ALT() {\n            $.CONSUME(NumberLiteral);\n          }\n        }, {\n          ALT: function ALT() {\n            $.CONSUME(NullLiteral);\n          }\n        }]);\n      });\n      $.CONSUME(RSquare);\n    });\n    $.RULE(\"route\", function () {\n      $.CONSUME(ROUTE);\n      $.CONSUME(RouteIdentifier);\n      $.CONSUME(TO);\n      $.CONSUME2(RouteIdentifier);\n    });\n    _this.performSelfAnalysis();\n    return _this;\n  }\n  return _createClass(VRMLParser);\n}(CstParser);\nvar Face = /*#__PURE__*/_createClass(function Face(a, b, c) {\n  _classCallCheck(this, Face);\n  this.a = a;\n  this.b = b;\n  this.c = c;\n  this.normal = new Vector3();\n});\nvar TEXTURE_TYPE = {\n  INTENSITY: 1,\n  INTENSITY_ALPHA: 2,\n  RGB: 3,\n  RGBA: 4\n};\nexport { VRMLLoader };","map":{"version":3,"names":["VRMLLoader","_Loader","_inherits","_super","_createSuper","manager","_classCallCheck","call","_createClass","key","value","load","url","onLoad","onProgress","onError","scope","path","LoaderUtils","extractUrlBase","loader","FileLoader","setPath","setRequestHeader","requestHeader","setWithCredentials","withCredentials","text","parse","e","console","error","itemError","data","nodeMap","generateVRMLTree","data2","tokenData","createTokens","lexer","VRMLLexer","tokens","parser","VRMLParser","tokenVocabulary","visitor","createVisitor","getBaseCstVisitorConstructor","lexingResult","lex","input","cstOutput","vrml","errors","length","Error","ast","visit","RouteIdentifier","createToken","name","pattern","Identifier","longer_alt","nodeTypes","Version","NodeName","RegExp","join","DEF","USE","ROUTE","TO","StringLiteral","HexLiteral","NumberLiteral","TrueLiteral","FalseLiteral","NullLiteral","LSquare","RSquare","LCurly","RCurly","Comment","group","Lexer","SKIPPED","WhiteSpace","i","l","token","BaseVRMLVisitor","VRMLToASTVisitor","validateVisitor","prototype","Object","assign","create","constructor","ctx","version","nodes","routes","node","push","route","image","fields","field","def","type","values","result","singleFieldValue","multiFieldValue","use","processField","FROM","stringLiteral","replace","numberLiteral","parseFloat","hexLiteral","trueLiteral","falseLiteral","forEach","parseTree","tree2","scene2","Scene","buildNodeMap","object","getNode","Object3D","add","userData","worldInfo","fieldValues","j","jl","resolveUSE","build","buildNode","nodeName","buildGroupingNode","buildBackgroundNode","buildShapeNode","buildAppearanceNode","buildMaterialNode","buildImageTextureNode","buildPixelTextureNode","buildTextureTransformNode","buildIndexedFaceSetNode","buildIndexedLineSetNode","buildPointSetNode","buildBoxNode","buildConeNode","buildCylinderNode","buildSphereNode","buildElevationGridNode","buildExtrusionNode","buildGeometricNode","buildWorldInfoNode","warn","hasOwnProperty","Group","fieldName","parseFieldChildren","axis","Vector3","normalize","angle","quaternion","setFromAxisAngle","scale","set","position","groundAngle","groundColor","skyAngle","skyColor","radius","skyGeometry","SphereGeometry","skyMaterial","MeshBasicMaterial","fog","side","BackSide","depthWrite","depthTest","paintFaces","toColorArray","vertexColors","color","setRGB","sky","Mesh","groundGeometry","Math","PI","groundMaterial","ground","renderOrder","Infinity","material","geometry","attributes","_type","pointsMaterial","PointsMaterial","isMeshPhongMaterial","copy","emissive","Points","lineMaterial","LineBasicMaterial","LineSegments","_solid","FrontSide","DoubleSide","visible","MeshPhongMaterial","transformData","materialData","diffuseColor","emissiveColor","shininess","specularColor","specular","transparency","opacity","transparent","textureNode","map","__type","TEXTURE_TYPE","INTENSITY_ALPHA","RGB","RGBA","center","rotation","repeat","offset","translation","Color","parseHexColor","hex","textureType","INTENSITY","parseInt","r","g","b","a","substring","getTextureType","num_components","texture","wrapS","RepeatWrapping","wrapT","width","height","Uint8Array","k","stride","DataTexture","needsUpdate","ClampToEdgeWrapping","textureLoader","Vector2","title","info","coord","normal","texCoord","ccw","solid","creaseAngle","colorIndex","coordIndex","normalIndex","texCoordIndex","colorPerVertex","normalPerVertex","colorNode","coordNode","normalNode","texCoordNode","BufferGeometry","triangulatedCoordIndex","triangulateFaceIndex","colorAttribute","normalAttribute","uvAttribute","triangulatedColorIndex","computeAttributeFromIndexedData","toNonIndexedAttribute","Float32BufferAttribute","flattenFaceColors","flattenData","triangulatedFaceColors","triangulateFaceData","computeAttributeFromFaceData","triangulatedNormalIndex","flattenFaceNormals","triangulatedFaceNormals","computeNormalAttribute","triangulatedTexCoordIndex","positionAttribute","setAttribute","expandedLineIndex","expandLineIndex","expandedColorIndex","flattenLineColors","expandedLineColors","expandLineData","computeAttributeFromLineData","size","x","y","z","BoxGeometry","openEnded","ConeGeometry","CylinderGeometry","xDimension","zDimension","xSpacing","zSpacing","vertices","normals","colors","uvs","index","xn","yn","zn","s","t","indices","c","d","crossSection","spine","orientation","beginCap","endCap","crossSectionClosed","spineVector","scaling","vertex","Quaternion","o","il","fromArray","kl","multiply","applyQuaternion","spineCount","crossSectionCount","contour","faces","ShapeUtils","triangulateShape","capIndices","face","indexOffset","identifier","isObject3D","isMaterial","clone","children","owner","start","i1","i2","i3","triangulatedData","flattenData2","vA","vB","vC","uvA","uvB","uvC","itemSize","array","faceData","lineData","attribute","array2","index2","ab","cb","vertexNormals","Face","subVectors","cross","nA","weightedNormal","nB","nC","vector","angleTo","angles","topDown","thresholds","startAngle","point","setFromSphericalCoords","BufferAttribute","Float32Array","count","getX","fromBufferAttribute","thresholdIndexA","thresholdIndexB","thresholdA","thresholdB","abs","colorA","colorB","lerp","setXYZ","TextureLoader","resourcePath","setCrossOrigin","crossOrigin","indexOf","tree","scene","Loader","inputText","tokenize","_CstParser","_super2","_this","$","_assertThisInitialized","RULE","SUBRULE","AT_LEAST_ONE","MANY","CONSUME","OPTION","OR2","ALT","OR","CONSUME2","performSelfAnalysis","CstParser"],"sources":["C:\\Users\\Nayyu\\Desktop\\skibidai-public-build\\node_modules\\src\\loaders\\VRMLLoader.js"],"sourcesContent":["import {\n  BackSide,\n  BoxGeometry,\n  BufferAttribute,\n  BufferGeometry,\n  ClampToEdgeWrapping,\n  Color,\n  ConeGeometry,\n  CylinderGeometry,\n  DataTexture,\n  DoubleSide,\n  FileLoader,\n  Float32BufferAttribute,\n  FrontSide,\n  Group,\n  LineBasicMaterial,\n  LineSegments,\n  Loader,\n  LoaderUtils,\n  Mesh,\n  MeshBasicMaterial,\n  MeshPhongMaterial,\n  Object3D,\n  Points,\n  PointsMaterial,\n  Quaternion,\n  RepeatWrapping,\n  Scene,\n  ShapeUtils,\n  SphereGeometry,\n  TextureLoader,\n  Vector2,\n  Vector3,\n} from 'three'\nimport { Lexer, CstParser, createToken } from '../libs/chevrotain'\n\nclass VRMLLoader extends Loader {\n  constructor(manager) {\n    super(manager)\n  }\n\n  load(url, onLoad, onProgress, onError) {\n    const scope = this\n\n    const path = scope.path === '' ? LoaderUtils.extractUrlBase(url) : scope.path\n\n    const loader = new FileLoader(scope.manager)\n    loader.setPath(scope.path)\n    loader.setRequestHeader(scope.requestHeader)\n    loader.setWithCredentials(scope.withCredentials)\n    loader.load(\n      url,\n      function (text) {\n        try {\n          onLoad(scope.parse(text, path))\n        } catch (e) {\n          if (onError) {\n            onError(e)\n          } else {\n            console.error(e)\n          }\n\n          scope.manager.itemError(url)\n        }\n      },\n      onProgress,\n      onError,\n    )\n  }\n\n  parse(data, path) {\n    const nodeMap = {}\n\n    function generateVRMLTree(data) {\n      // create lexer, parser and visitor\n\n      const tokenData = createTokens()\n\n      const lexer = new VRMLLexer(tokenData.tokens)\n      const parser = new VRMLParser(tokenData.tokenVocabulary)\n      const visitor = createVisitor(parser.getBaseCstVisitorConstructor())\n\n      // lexing\n\n      const lexingResult = lexer.lex(data)\n      parser.input = lexingResult.tokens\n\n      // parsing\n\n      const cstOutput = parser.vrml()\n\n      if (parser.errors.length > 0) {\n        console.error(parser.errors)\n\n        throw Error('THREE.VRMLLoader: Parsing errors detected.')\n      }\n\n      // actions\n\n      const ast = visitor.visit(cstOutput)\n\n      return ast\n    }\n\n    function createTokens() {\n      // from http://gun.teipir.gr/VRML-amgem/spec/part1/concepts.html#SyntaxBasics\n\n      const RouteIdentifier = createToken({\n        name: 'RouteIdentifier',\n        pattern: /[^\\x30-\\x39\\0-\\x20\\x22\\x27\\x23\\x2b\\x2c\\x2d\\x2e\\x5b\\x5d\\x5c\\x7b\\x7d][^\\0-\\x20\\x22\\x27\\x23\\x2b\\x2c\\x2d\\x2e\\x5b\\x5d\\x5c\\x7b\\x7d]*[\\.][^\\x30-\\x39\\0-\\x20\\x22\\x27\\x23\\x2b\\x2c\\x2d\\x2e\\x5b\\x5d\\x5c\\x7b\\x7d][^\\0-\\x20\\x22\\x27\\x23\\x2b\\x2c\\x2d\\x2e\\x5b\\x5d\\x5c\\x7b\\x7d]*/,\n      })\n      const Identifier = createToken({\n        name: 'Identifier',\n        pattern: /[^\\x30-\\x39\\0-\\x20\\x22\\x27\\x23\\x2b\\x2c\\x2d\\x2e\\x5b\\x5d\\x5c\\x7b\\x7d][^\\0-\\x20\\x22\\x27\\x23\\x2b\\x2c\\x2d\\x2e\\x5b\\x5d\\x5c\\x7b\\x7d]*/,\n        longer_alt: RouteIdentifier,\n      })\n\n      // from http://gun.teipir.gr/VRML-amgem/spec/part1/nodesRef.html\n\n      const nodeTypes = [\n        'Anchor',\n        'Billboard',\n        'Collision',\n        'Group',\n        'Transform', // grouping nodes\n        'Inline',\n        'LOD',\n        'Switch', // special groups\n        'AudioClip',\n        'DirectionalLight',\n        'PointLight',\n        'Script',\n        'Shape',\n        'Sound',\n        'SpotLight',\n        'WorldInfo', // common nodes\n        'CylinderSensor',\n        'PlaneSensor',\n        'ProximitySensor',\n        'SphereSensor',\n        'TimeSensor',\n        'TouchSensor',\n        'VisibilitySensor', // sensors\n        'Box',\n        'Cone',\n        'Cylinder',\n        'ElevationGrid',\n        'Extrusion',\n        'IndexedFaceSet',\n        'IndexedLineSet',\n        'PointSet',\n        'Sphere', // geometries\n        'Color',\n        'Coordinate',\n        'Normal',\n        'TextureCoordinate', // geometric properties\n        'Appearance',\n        'FontStyle',\n        'ImageTexture',\n        'Material',\n        'MovieTexture',\n        'PixelTexture',\n        'TextureTransform', // appearance\n        'ColorInterpolator',\n        'CoordinateInterpolator',\n        'NormalInterpolator',\n        'OrientationInterpolator',\n        'PositionInterpolator',\n        'ScalarInterpolator', // interpolators\n        'Background',\n        'Fog',\n        'NavigationInfo',\n        'Viewpoint', // bindable nodes\n        'Text', // Text must be placed at the end of the regex so there are no matches for TextureTransform and TextureCoordinate\n      ]\n\n      //\n\n      const Version = createToken({\n        name: 'Version',\n        pattern: /#VRML.*/,\n        longer_alt: Identifier,\n      })\n\n      const NodeName = createToken({\n        name: 'NodeName',\n        pattern: new RegExp(nodeTypes.join('|')),\n        longer_alt: Identifier,\n      })\n\n      const DEF = createToken({\n        name: 'DEF',\n        pattern: /DEF/,\n        longer_alt: Identifier,\n      })\n\n      const USE = createToken({\n        name: 'USE',\n        pattern: /USE/,\n        longer_alt: Identifier,\n      })\n\n      const ROUTE = createToken({\n        name: 'ROUTE',\n        pattern: /ROUTE/,\n        longer_alt: Identifier,\n      })\n\n      const TO = createToken({\n        name: 'TO',\n        pattern: /TO/,\n        longer_alt: Identifier,\n      })\n\n      //\n\n      const StringLiteral = createToken({\n        name: 'StringLiteral',\n        pattern: /\"(?:[^\\\\\"\\n\\r]|\\\\[bfnrtv\"\\\\/]|\\\\u[0-9a-fA-F][0-9a-fA-F][0-9a-fA-F][0-9a-fA-F])*\"/,\n      })\n      const HexLiteral = createToken({ name: 'HexLiteral', pattern: /0[xX][0-9a-fA-F]+/ })\n      const NumberLiteral = createToken({ name: 'NumberLiteral', pattern: /[-+]?[0-9]*\\.?[0-9]+([eE][-+]?[0-9]+)?/ })\n      const TrueLiteral = createToken({ name: 'TrueLiteral', pattern: /TRUE/ })\n      const FalseLiteral = createToken({ name: 'FalseLiteral', pattern: /FALSE/ })\n      const NullLiteral = createToken({ name: 'NullLiteral', pattern: /NULL/ })\n      const LSquare = createToken({ name: 'LSquare', pattern: /\\[/ })\n      const RSquare = createToken({ name: 'RSquare', pattern: /]/ })\n      const LCurly = createToken({ name: 'LCurly', pattern: /{/ })\n      const RCurly = createToken({ name: 'RCurly', pattern: /}/ })\n      const Comment = createToken({\n        name: 'Comment',\n        pattern: /#.*/,\n        group: Lexer.SKIPPED,\n      })\n\n      // commas, blanks, tabs, newlines and carriage returns are whitespace characters wherever they appear outside of string fields\n\n      const WhiteSpace = createToken({\n        name: 'WhiteSpace',\n        pattern: /[ ,\\s]/,\n        group: Lexer.SKIPPED,\n      })\n\n      const tokens = [\n        WhiteSpace,\n        // keywords appear before the Identifier\n        NodeName,\n        DEF,\n        USE,\n        ROUTE,\n        TO,\n        TrueLiteral,\n        FalseLiteral,\n        NullLiteral,\n        // the Identifier must appear after the keywords because all keywords are valid identifiers\n        Version,\n        Identifier,\n        RouteIdentifier,\n        StringLiteral,\n        HexLiteral,\n        NumberLiteral,\n        LSquare,\n        RSquare,\n        LCurly,\n        RCurly,\n        Comment,\n      ]\n\n      const tokenVocabulary = {}\n\n      for (let i = 0, l = tokens.length; i < l; i++) {\n        const token = tokens[i]\n\n        tokenVocabulary[token.name] = token\n      }\n\n      return { tokens: tokens, tokenVocabulary: tokenVocabulary }\n    }\n\n    function createVisitor(BaseVRMLVisitor) {\n      // the visitor is created dynmaically based on the given base class\n\n      function VRMLToASTVisitor() {\n        BaseVRMLVisitor.call(this)\n\n        this.validateVisitor()\n      }\n\n      VRMLToASTVisitor.prototype = Object.assign(Object.create(BaseVRMLVisitor.prototype), {\n        constructor: VRMLToASTVisitor,\n\n        vrml: function (ctx) {\n          const data = {\n            version: this.visit(ctx.version),\n            nodes: [],\n            routes: [],\n          }\n\n          for (let i = 0, l = ctx.node.length; i < l; i++) {\n            const node = ctx.node[i]\n\n            data.nodes.push(this.visit(node))\n          }\n\n          if (ctx.route) {\n            for (let i = 0, l = ctx.route.length; i < l; i++) {\n              const route = ctx.route[i]\n\n              data.routes.push(this.visit(route))\n            }\n          }\n\n          return data\n        },\n\n        version: function (ctx) {\n          return ctx.Version[0].image\n        },\n\n        node: function (ctx) {\n          const data = {\n            name: ctx.NodeName[0].image,\n            fields: [],\n          }\n\n          if (ctx.field) {\n            for (let i = 0, l = ctx.field.length; i < l; i++) {\n              const field = ctx.field[i]\n\n              data.fields.push(this.visit(field))\n            }\n          }\n\n          // DEF\n\n          if (ctx.def) {\n            data.DEF = this.visit(ctx.def[0])\n          }\n\n          return data\n        },\n\n        field: function (ctx) {\n          const data = {\n            name: ctx.Identifier[0].image,\n            type: null,\n            values: null,\n          }\n\n          let result\n\n          // SFValue\n\n          if (ctx.singleFieldValue) {\n            result = this.visit(ctx.singleFieldValue[0])\n          }\n\n          // MFValue\n\n          if (ctx.multiFieldValue) {\n            result = this.visit(ctx.multiFieldValue[0])\n          }\n\n          data.type = result.type\n          data.values = result.values\n\n          return data\n        },\n\n        def: function (ctx) {\n          return (ctx.Identifier || ctx.NodeName)[0].image\n        },\n\n        use: function (ctx) {\n          return { USE: (ctx.Identifier || ctx.NodeName)[0].image }\n        },\n\n        singleFieldValue: function (ctx) {\n          return processField(this, ctx)\n        },\n\n        multiFieldValue: function (ctx) {\n          return processField(this, ctx)\n        },\n\n        route: function (ctx) {\n          const data = {\n            FROM: ctx.RouteIdentifier[0].image,\n            TO: ctx.RouteIdentifier[1].image,\n          }\n\n          return data\n        },\n      })\n\n      function processField(scope, ctx) {\n        const field = {\n          type: null,\n          values: [],\n        }\n\n        if (ctx.node) {\n          field.type = 'node'\n\n          for (let i = 0, l = ctx.node.length; i < l; i++) {\n            const node = ctx.node[i]\n\n            field.values.push(scope.visit(node))\n          }\n        }\n\n        if (ctx.use) {\n          field.type = 'use'\n\n          for (let i = 0, l = ctx.use.length; i < l; i++) {\n            const use = ctx.use[i]\n\n            field.values.push(scope.visit(use))\n          }\n        }\n\n        if (ctx.StringLiteral) {\n          field.type = 'string'\n\n          for (let i = 0, l = ctx.StringLiteral.length; i < l; i++) {\n            const stringLiteral = ctx.StringLiteral[i]\n\n            field.values.push(stringLiteral.image.replace(/'|\"/g, ''))\n          }\n        }\n\n        if (ctx.NumberLiteral) {\n          field.type = 'number'\n\n          for (let i = 0, l = ctx.NumberLiteral.length; i < l; i++) {\n            const numberLiteral = ctx.NumberLiteral[i]\n\n            field.values.push(parseFloat(numberLiteral.image))\n          }\n        }\n\n        if (ctx.HexLiteral) {\n          field.type = 'hex'\n\n          for (let i = 0, l = ctx.HexLiteral.length; i < l; i++) {\n            const hexLiteral = ctx.HexLiteral[i]\n\n            field.values.push(hexLiteral.image)\n          }\n        }\n\n        if (ctx.TrueLiteral) {\n          field.type = 'boolean'\n\n          for (let i = 0, l = ctx.TrueLiteral.length; i < l; i++) {\n            const trueLiteral = ctx.TrueLiteral[i]\n\n            if (trueLiteral.image === 'TRUE') field.values.push(true)\n          }\n        }\n\n        if (ctx.FalseLiteral) {\n          field.type = 'boolean'\n\n          for (let i = 0, l = ctx.FalseLiteral.length; i < l; i++) {\n            const falseLiteral = ctx.FalseLiteral[i]\n\n            if (falseLiteral.image === 'FALSE') field.values.push(false)\n          }\n        }\n\n        if (ctx.NullLiteral) {\n          field.type = 'null'\n\n          ctx.NullLiteral.forEach(function () {\n            field.values.push(null)\n          })\n        }\n\n        return field\n      }\n\n      return new VRMLToASTVisitor()\n    }\n\n    function parseTree(tree) {\n      // console.log( JSON.stringify( tree, null, 2 ) );\n\n      const nodes = tree.nodes\n      const scene = new Scene()\n\n      // first iteration: build nodemap based on DEF statements\n\n      for (let i = 0, l = nodes.length; i < l; i++) {\n        const node = nodes[i]\n\n        buildNodeMap(node)\n      }\n\n      // second iteration: build nodes\n\n      for (let i = 0, l = nodes.length; i < l; i++) {\n        const node = nodes[i]\n        const object = getNode(node)\n\n        if (object instanceof Object3D) scene.add(object)\n\n        if (node.name === 'WorldInfo') scene.userData.worldInfo = object\n      }\n\n      return scene\n    }\n\n    function buildNodeMap(node) {\n      if (node.DEF) {\n        nodeMap[node.DEF] = node\n      }\n\n      const fields = node.fields\n\n      for (let i = 0, l = fields.length; i < l; i++) {\n        const field = fields[i]\n\n        if (field.type === 'node') {\n          const fieldValues = field.values\n\n          for (let j = 0, jl = fieldValues.length; j < jl; j++) {\n            buildNodeMap(fieldValues[j])\n          }\n        }\n      }\n    }\n\n    function getNode(node) {\n      // handle case where a node refers to a different one\n\n      if (node.USE) {\n        return resolveUSE(node.USE)\n      }\n\n      if (node.build !== undefined) return node.build\n\n      node.build = buildNode(node)\n\n      return node.build\n    }\n\n    // node builder\n\n    function buildNode(node) {\n      const nodeName = node.name\n      let build\n\n      switch (nodeName) {\n        case 'Group':\n        case 'Transform':\n        case 'Collision':\n          build = buildGroupingNode(node)\n          break\n\n        case 'Background':\n          build = buildBackgroundNode(node)\n          break\n\n        case 'Shape':\n          build = buildShapeNode(node)\n          break\n\n        case 'Appearance':\n          build = buildAppearanceNode(node)\n          break\n\n        case 'Material':\n          build = buildMaterialNode(node)\n          break\n\n        case 'ImageTexture':\n          build = buildImageTextureNode(node)\n          break\n\n        case 'PixelTexture':\n          build = buildPixelTextureNode(node)\n          break\n\n        case 'TextureTransform':\n          build = buildTextureTransformNode(node)\n          break\n\n        case 'IndexedFaceSet':\n          build = buildIndexedFaceSetNode(node)\n          break\n\n        case 'IndexedLineSet':\n          build = buildIndexedLineSetNode(node)\n          break\n\n        case 'PointSet':\n          build = buildPointSetNode(node)\n          break\n\n        case 'Box':\n          build = buildBoxNode(node)\n          break\n\n        case 'Cone':\n          build = buildConeNode(node)\n          break\n\n        case 'Cylinder':\n          build = buildCylinderNode(node)\n          break\n\n        case 'Sphere':\n          build = buildSphereNode(node)\n          break\n\n        case 'ElevationGrid':\n          build = buildElevationGridNode(node)\n          break\n\n        case 'Extrusion':\n          build = buildExtrusionNode(node)\n          break\n\n        case 'Color':\n        case 'Coordinate':\n        case 'Normal':\n        case 'TextureCoordinate':\n          build = buildGeometricNode(node)\n          break\n\n        case 'WorldInfo':\n          build = buildWorldInfoNode(node)\n          break\n\n        case 'Anchor':\n        case 'Billboard':\n\n        case 'Inline':\n        case 'LOD':\n        case 'Switch':\n\n        case 'AudioClip':\n        case 'DirectionalLight':\n        case 'PointLight':\n        case 'Script':\n        case 'Sound':\n        case 'SpotLight':\n\n        case 'CylinderSensor':\n        case 'PlaneSensor':\n        case 'ProximitySensor':\n        case 'SphereSensor':\n        case 'TimeSensor':\n        case 'TouchSensor':\n        case 'VisibilitySensor':\n\n        case 'Text':\n\n        case 'FontStyle':\n        case 'MovieTexture':\n\n        case 'ColorInterpolator':\n        case 'CoordinateInterpolator':\n        case 'NormalInterpolator':\n        case 'OrientationInterpolator':\n        case 'PositionInterpolator':\n        case 'ScalarInterpolator':\n\n        case 'Fog':\n        case 'NavigationInfo':\n        case 'Viewpoint':\n          // node not supported yet\n          break\n\n        default:\n          console.warn('THREE.VRMLLoader: Unknown node:', nodeName)\n          break\n      }\n\n      if (build !== undefined && node.DEF !== undefined && build.hasOwnProperty('name') === true) {\n        build.name = node.DEF\n      }\n\n      return build\n    }\n\n    function buildGroupingNode(node) {\n      const object = new Group()\n\n      //\n\n      const fields = node.fields\n\n      for (let i = 0, l = fields.length; i < l; i++) {\n        const field = fields[i]\n        const fieldName = field.name\n        const fieldValues = field.values\n\n        switch (fieldName) {\n          case 'bboxCenter':\n            // field not supported\n            break\n\n          case 'bboxSize':\n            // field not supported\n            break\n\n          case 'center':\n            // field not supported\n            break\n\n          case 'children':\n            parseFieldChildren(fieldValues, object)\n            break\n\n          case 'collide':\n            // field not supported\n            break\n\n          case 'rotation':\n            const axis = new Vector3(fieldValues[0], fieldValues[1], fieldValues[2]).normalize()\n            const angle = fieldValues[3]\n            object.quaternion.setFromAxisAngle(axis, angle)\n            break\n\n          case 'scale':\n            object.scale.set(fieldValues[0], fieldValues[1], fieldValues[2])\n            break\n\n          case 'scaleOrientation':\n            // field not supported\n            break\n\n          case 'translation':\n            object.position.set(fieldValues[0], fieldValues[1], fieldValues[2])\n            break\n\n          case 'proxy':\n            // field not supported\n            break\n\n          default:\n            console.warn('THREE.VRMLLoader: Unknown field:', fieldName)\n            break\n        }\n      }\n\n      return object\n    }\n\n    function buildBackgroundNode(node) {\n      const group = new Group()\n\n      let groundAngle, groundColor\n      let skyAngle, skyColor\n\n      const fields = node.fields\n\n      for (let i = 0, l = fields.length; i < l; i++) {\n        const field = fields[i]\n        const fieldName = field.name\n        const fieldValues = field.values\n\n        switch (fieldName) {\n          case 'groundAngle':\n            groundAngle = fieldValues\n            break\n\n          case 'groundColor':\n            groundColor = fieldValues\n            break\n\n          case 'backUrl':\n            // field not supported\n            break\n\n          case 'bottomUrl':\n            // field not supported\n            break\n\n          case 'frontUrl':\n            // field not supported\n            break\n\n          case 'leftUrl':\n            // field not supported\n            break\n\n          case 'rightUrl':\n            // field not supported\n            break\n\n          case 'topUrl':\n            // field not supported\n            break\n\n          case 'skyAngle':\n            skyAngle = fieldValues\n            break\n\n          case 'skyColor':\n            skyColor = fieldValues\n            break\n\n          default:\n            console.warn('THREE.VRMLLoader: Unknown field:', fieldName)\n            break\n        }\n      }\n\n      const radius = 10000\n\n      // sky\n\n      if (skyColor) {\n        const skyGeometry = new SphereGeometry(radius, 32, 16)\n        const skyMaterial = new MeshBasicMaterial({ fog: false, side: BackSide, depthWrite: false, depthTest: false })\n\n        if (skyColor.length > 3) {\n          paintFaces(skyGeometry, radius, skyAngle, toColorArray(skyColor), true)\n          skyMaterial.vertexColors = true\n        } else {\n          skyMaterial.color.setRGB(skyColor[0], skyColor[1], skyColor[2])\n        }\n\n        const sky = new Mesh(skyGeometry, skyMaterial)\n        group.add(sky)\n      }\n\n      // ground\n\n      if (groundColor) {\n        if (groundColor.length > 0) {\n          const groundGeometry = new SphereGeometry(radius, 32, 16, 0, 2 * Math.PI, 0.5 * Math.PI, 1.5 * Math.PI)\n          const groundMaterial = new MeshBasicMaterial({\n            fog: false,\n            side: BackSide,\n            vertexColors: true,\n            depthWrite: false,\n            depthTest: false,\n          })\n\n          paintFaces(groundGeometry, radius, groundAngle, toColorArray(groundColor), false)\n\n          const ground = new Mesh(groundGeometry, groundMaterial)\n          group.add(ground)\n        }\n      }\n\n      // render background group first\n\n      group.renderOrder = -Infinity\n\n      return group\n    }\n\n    function buildShapeNode(node) {\n      const fields = node.fields\n\n      // if the appearance field is NULL or unspecified, lighting is off and the unlit object color is (0, 0, 0)\n\n      let material = new MeshBasicMaterial({ color: 0x000000 })\n      let geometry\n\n      for (let i = 0, l = fields.length; i < l; i++) {\n        const field = fields[i]\n        const fieldName = field.name\n        const fieldValues = field.values\n\n        switch (fieldName) {\n          case 'appearance':\n            if (fieldValues[0] !== null) {\n              material = getNode(fieldValues[0])\n            }\n\n            break\n\n          case 'geometry':\n            if (fieldValues[0] !== null) {\n              geometry = getNode(fieldValues[0])\n            }\n\n            break\n\n          default:\n            console.warn('THREE.VRMLLoader: Unknown field:', fieldName)\n            break\n        }\n      }\n\n      // build 3D object\n\n      let object\n\n      if (geometry && geometry.attributes.position) {\n        const type = geometry._type\n\n        if (type === 'points') {\n          // points\n\n          const pointsMaterial = new PointsMaterial({ color: 0xffffff })\n\n          if (geometry.attributes.color !== undefined) {\n            pointsMaterial.vertexColors = true\n          } else {\n            // if the color field is NULL and there is a material defined for the appearance affecting this PointSet, then use the emissiveColor of the material to draw the points\n\n            if (material.isMeshPhongMaterial) {\n              pointsMaterial.color.copy(material.emissive)\n            }\n          }\n\n          object = new Points(geometry, pointsMaterial)\n        } else if (type === 'line') {\n          // lines\n\n          const lineMaterial = new LineBasicMaterial({ color: 0xffffff })\n\n          if (geometry.attributes.color !== undefined) {\n            lineMaterial.vertexColors = true\n          } else {\n            // if the color field is NULL and there is a material defined for the appearance affecting this IndexedLineSet, then use the emissiveColor of the material to draw the lines\n\n            if (material.isMeshPhongMaterial) {\n              lineMaterial.color.copy(material.emissive)\n            }\n          }\n\n          object = new LineSegments(geometry, lineMaterial)\n        } else {\n          // consider meshes\n\n          // check \"solid\" hint (it's placed in the geometry but affects the material)\n\n          if (geometry._solid !== undefined) {\n            material.side = geometry._solid ? FrontSide : DoubleSide\n          }\n\n          // check for vertex colors\n\n          if (geometry.attributes.color !== undefined) {\n            material.vertexColors = true\n          }\n\n          object = new Mesh(geometry, material)\n        }\n      } else {\n        object = new Object3D()\n\n        // if the geometry field is NULL or no vertices are defined the object is not drawn\n\n        object.visible = false\n      }\n\n      return object\n    }\n\n    function buildAppearanceNode(node) {\n      let material = new MeshPhongMaterial()\n      let transformData\n\n      const fields = node.fields\n\n      for (let i = 0, l = fields.length; i < l; i++) {\n        const field = fields[i]\n        const fieldName = field.name\n        const fieldValues = field.values\n\n        switch (fieldName) {\n          case 'material':\n            if (fieldValues[0] !== null) {\n              const materialData = getNode(fieldValues[0])\n\n              if (materialData.diffuseColor) material.color.copy(materialData.diffuseColor)\n              if (materialData.emissiveColor) material.emissive.copy(materialData.emissiveColor)\n              if (materialData.shininess) material.shininess = materialData.shininess\n              if (materialData.specularColor) material.specular.copy(materialData.specularColor)\n              if (materialData.transparency) material.opacity = 1 - materialData.transparency\n              if (materialData.transparency > 0) material.transparent = true\n            } else {\n              // if the material field is NULL or unspecified, lighting is off and the unlit object color is (0, 0, 0)\n\n              material = new MeshBasicMaterial({ color: 0x000000 })\n            }\n\n            break\n\n          case 'texture':\n            const textureNode = fieldValues[0]\n            if (textureNode !== null) {\n              if (textureNode.name === 'ImageTexture' || textureNode.name === 'PixelTexture') {\n                material.map = getNode(textureNode)\n              } else {\n                // MovieTexture not supported yet\n              }\n            }\n\n            break\n\n          case 'textureTransform':\n            if (fieldValues[0] !== null) {\n              transformData = getNode(fieldValues[0])\n            }\n\n            break\n\n          default:\n            console.warn('THREE.VRMLLoader: Unknown field:', fieldName)\n            break\n        }\n      }\n\n      // only apply texture transform data if a texture was defined\n\n      if (material.map) {\n        // respect VRML lighting model\n\n        if (material.map.__type) {\n          switch (material.map.__type) {\n            case TEXTURE_TYPE.INTENSITY_ALPHA:\n              material.opacity = 1 // ignore transparency\n              break\n\n            case TEXTURE_TYPE.RGB:\n              material.color.set(0xffffff) // ignore material color\n              break\n\n            case TEXTURE_TYPE.RGBA:\n              material.color.set(0xffffff) // ignore material color\n              material.opacity = 1 // ignore transparency\n              break\n\n            default:\n          }\n\n          delete material.map.__type\n        }\n\n        // apply texture transform\n\n        if (transformData) {\n          material.map.center.copy(transformData.center)\n          material.map.rotation = transformData.rotation\n          material.map.repeat.copy(transformData.scale)\n          material.map.offset.copy(transformData.translation)\n        }\n      }\n\n      return material\n    }\n\n    function buildMaterialNode(node) {\n      const materialData = {}\n\n      const fields = node.fields\n\n      for (let i = 0, l = fields.length; i < l; i++) {\n        const field = fields[i]\n        const fieldName = field.name\n        const fieldValues = field.values\n\n        switch (fieldName) {\n          case 'ambientIntensity':\n            // field not supported\n            break\n\n          case 'diffuseColor':\n            materialData.diffuseColor = new Color(fieldValues[0], fieldValues[1], fieldValues[2])\n            break\n\n          case 'emissiveColor':\n            materialData.emissiveColor = new Color(fieldValues[0], fieldValues[1], fieldValues[2])\n            break\n\n          case 'shininess':\n            materialData.shininess = fieldValues[0]\n            break\n\n          case 'specularColor':\n            materialData.emissiveColor = new Color(fieldValues[0], fieldValues[1], fieldValues[2])\n            break\n\n          case 'transparency':\n            materialData.transparency = fieldValues[0]\n            break\n\n          default:\n            console.warn('THREE.VRMLLoader: Unknown field:', fieldName)\n            break\n        }\n      }\n\n      return materialData\n    }\n\n    function parseHexColor(hex, textureType, color) {\n      let value\n\n      switch (textureType) {\n        case TEXTURE_TYPE.INTENSITY:\n          // Intensity texture: A one-component image specifies one-byte hexadecimal or integer values representing the intensity of the image\n          value = parseInt(hex)\n          color.r = value\n          color.g = value\n          color.b = value\n          color.a = 1\n          break\n\n        case TEXTURE_TYPE.INTENSITY_ALPHA:\n          // Intensity+Alpha texture: A two-component image specifies the intensity in the first (high) byte and the alpha opacity in the second (low) byte.\n          value = parseInt('0x' + hex.substring(2, 4))\n          color.r = value\n          color.g = value\n          color.b = value\n          color.a = parseInt('0x' + hex.substring(4, 6))\n          break\n\n        case TEXTURE_TYPE.RGB:\n          // RGB texture: Pixels in a three-component image specify the red component in the first (high) byte, followed by the green and blue components\n          color.r = parseInt('0x' + hex.substring(2, 4))\n          color.g = parseInt('0x' + hex.substring(4, 6))\n          color.b = parseInt('0x' + hex.substring(6, 8))\n          color.a = 1\n          break\n\n        case TEXTURE_TYPE.RGBA:\n          // RGBA texture: Four-component images specify the alpha opacity byte after red/green/blue\n          color.r = parseInt('0x' + hex.substring(2, 4))\n          color.g = parseInt('0x' + hex.substring(4, 6))\n          color.b = parseInt('0x' + hex.substring(6, 8))\n          color.a = parseInt('0x' + hex.substring(8, 10))\n          break\n\n        default:\n      }\n    }\n\n    function getTextureType(num_components) {\n      let type\n\n      switch (num_components) {\n        case 1:\n          type = TEXTURE_TYPE.INTENSITY\n          break\n\n        case 2:\n          type = TEXTURE_TYPE.INTENSITY_ALPHA\n          break\n\n        case 3:\n          type = TEXTURE_TYPE.RGB\n          break\n\n        case 4:\n          type = TEXTURE_TYPE.RGBA\n          break\n\n        default:\n      }\n\n      return type\n    }\n\n    function buildPixelTextureNode(node) {\n      let texture\n      let wrapS = RepeatWrapping\n      let wrapT = RepeatWrapping\n\n      const fields = node.fields\n\n      for (let i = 0, l = fields.length; i < l; i++) {\n        const field = fields[i]\n        const fieldName = field.name\n        const fieldValues = field.values\n\n        switch (fieldName) {\n          case 'image':\n            const width = fieldValues[0]\n            const height = fieldValues[1]\n            const num_components = fieldValues[2]\n\n            const textureType = getTextureType(num_components)\n\n            const data = new Uint8Array(4 * width * height)\n\n            const color = { r: 0, g: 0, b: 0, a: 0 }\n\n            for (let j = 3, k = 0, jl = fieldValues.length; j < jl; j++, k++) {\n              parseHexColor(fieldValues[j], textureType, color)\n\n              const stride = k * 4\n\n              data[stride + 0] = color.r\n              data[stride + 1] = color.g\n              data[stride + 2] = color.b\n              data[stride + 3] = color.a\n            }\n\n            texture = new DataTexture(data, width, height)\n            texture.needsUpdate = true\n            texture.__type = textureType // needed for material modifications\n            break\n\n          case 'repeatS':\n            if (fieldValues[0] === false) wrapS = ClampToEdgeWrapping\n            break\n\n          case 'repeatT':\n            if (fieldValues[0] === false) wrapT = ClampToEdgeWrapping\n            break\n\n          default:\n            console.warn('THREE.VRMLLoader: Unknown field:', fieldName)\n            break\n        }\n      }\n\n      if (texture) {\n        texture.wrapS = wrapS\n        texture.wrapT = wrapT\n      }\n\n      return texture\n    }\n\n    function buildImageTextureNode(node) {\n      let texture\n      let wrapS = RepeatWrapping\n      let wrapT = RepeatWrapping\n\n      const fields = node.fields\n\n      for (let i = 0, l = fields.length; i < l; i++) {\n        const field = fields[i]\n        const fieldName = field.name\n        const fieldValues = field.values\n\n        switch (fieldName) {\n          case 'url':\n            const url = fieldValues[0]\n            if (url) texture = textureLoader.load(url)\n            break\n\n          case 'repeatS':\n            if (fieldValues[0] === false) wrapS = ClampToEdgeWrapping\n            break\n\n          case 'repeatT':\n            if (fieldValues[0] === false) wrapT = ClampToEdgeWrapping\n            break\n\n          default:\n            console.warn('THREE.VRMLLoader: Unknown field:', fieldName)\n            break\n        }\n      }\n\n      if (texture) {\n        texture.wrapS = wrapS\n        texture.wrapT = wrapT\n      }\n\n      return texture\n    }\n\n    function buildTextureTransformNode(node) {\n      const transformData = {\n        center: new Vector2(),\n        rotation: new Vector2(),\n        scale: new Vector2(),\n        translation: new Vector2(),\n      }\n\n      const fields = node.fields\n\n      for (let i = 0, l = fields.length; i < l; i++) {\n        const field = fields[i]\n        const fieldName = field.name\n        const fieldValues = field.values\n\n        switch (fieldName) {\n          case 'center':\n            transformData.center.set(fieldValues[0], fieldValues[1])\n            break\n\n          case 'rotation':\n            transformData.rotation = fieldValues[0]\n            break\n\n          case 'scale':\n            transformData.scale.set(fieldValues[0], fieldValues[1])\n            break\n\n          case 'translation':\n            transformData.translation.set(fieldValues[0], fieldValues[1])\n            break\n\n          default:\n            console.warn('THREE.VRMLLoader: Unknown field:', fieldName)\n            break\n        }\n      }\n\n      return transformData\n    }\n\n    function buildGeometricNode(node) {\n      return node.fields[0].values\n    }\n\n    function buildWorldInfoNode(node) {\n      const worldInfo = {}\n\n      const fields = node.fields\n\n      for (let i = 0, l = fields.length; i < l; i++) {\n        const field = fields[i]\n        const fieldName = field.name\n        const fieldValues = field.values\n\n        switch (fieldName) {\n          case 'title':\n            worldInfo.title = fieldValues[0]\n            break\n\n          case 'info':\n            worldInfo.info = fieldValues\n            break\n\n          default:\n            console.warn('THREE.VRMLLoader: Unknown field:', fieldName)\n            break\n        }\n      }\n\n      return worldInfo\n    }\n\n    function buildIndexedFaceSetNode(node) {\n      let color, coord, normal, texCoord\n      let ccw = true,\n        solid = true,\n        creaseAngle = 0\n      let colorIndex, coordIndex, normalIndex, texCoordIndex\n      let colorPerVertex = true,\n        normalPerVertex = true\n\n      const fields = node.fields\n\n      for (let i = 0, l = fields.length; i < l; i++) {\n        const field = fields[i]\n        const fieldName = field.name\n        const fieldValues = field.values\n\n        switch (fieldName) {\n          case 'color':\n            const colorNode = fieldValues[0]\n\n            if (colorNode !== null) {\n              color = getNode(colorNode)\n            }\n\n            break\n\n          case 'coord':\n            const coordNode = fieldValues[0]\n\n            if (coordNode !== null) {\n              coord = getNode(coordNode)\n            }\n\n            break\n\n          case 'normal':\n            const normalNode = fieldValues[0]\n\n            if (normalNode !== null) {\n              normal = getNode(normalNode)\n            }\n\n            break\n\n          case 'texCoord':\n            const texCoordNode = fieldValues[0]\n\n            if (texCoordNode !== null) {\n              texCoord = getNode(texCoordNode)\n            }\n\n            break\n\n          case 'ccw':\n            ccw = fieldValues[0]\n            break\n\n          case 'colorIndex':\n            colorIndex = fieldValues\n            break\n\n          case 'colorPerVertex':\n            colorPerVertex = fieldValues[0]\n            break\n\n          case 'convex':\n            // field not supported\n            break\n\n          case 'coordIndex':\n            coordIndex = fieldValues\n            break\n\n          case 'creaseAngle':\n            creaseAngle = fieldValues[0]\n            break\n\n          case 'normalIndex':\n            normalIndex = fieldValues\n            break\n\n          case 'normalPerVertex':\n            normalPerVertex = fieldValues[0]\n            break\n\n          case 'solid':\n            solid = fieldValues[0]\n            break\n\n          case 'texCoordIndex':\n            texCoordIndex = fieldValues\n            break\n\n          default:\n            console.warn('THREE.VRMLLoader: Unknown field:', fieldName)\n            break\n        }\n      }\n\n      if (coordIndex === undefined) {\n        console.warn('THREE.VRMLLoader: Missing coordIndex.')\n\n        return new BufferGeometry() // handle VRML files with incomplete geometry definition\n      }\n\n      const triangulatedCoordIndex = triangulateFaceIndex(coordIndex, ccw)\n\n      let colorAttribute\n      let normalAttribute\n      let uvAttribute\n\n      if (color) {\n        if (colorPerVertex === true) {\n          if (colorIndex && colorIndex.length > 0) {\n            // if the colorIndex field is not empty, then it is used to choose colors for each vertex of the IndexedFaceSet.\n\n            const triangulatedColorIndex = triangulateFaceIndex(colorIndex, ccw)\n            colorAttribute = computeAttributeFromIndexedData(triangulatedCoordIndex, triangulatedColorIndex, color, 3)\n          } else {\n            // if the colorIndex field is empty, then the coordIndex field is used to choose colors from the Color node\n\n            colorAttribute = toNonIndexedAttribute(triangulatedCoordIndex, new Float32BufferAttribute(color, 3))\n          }\n        } else {\n          if (colorIndex && colorIndex.length > 0) {\n            // if the colorIndex field is not empty, then they are used to choose one color for each face of the IndexedFaceSet\n\n            const flattenFaceColors = flattenData(color, colorIndex)\n            const triangulatedFaceColors = triangulateFaceData(flattenFaceColors, coordIndex)\n            colorAttribute = computeAttributeFromFaceData(triangulatedCoordIndex, triangulatedFaceColors)\n          } else {\n            // if the colorIndex field is empty, then the color are applied to each face of the IndexedFaceSet in order\n\n            const triangulatedFaceColors = triangulateFaceData(color, coordIndex)\n            colorAttribute = computeAttributeFromFaceData(triangulatedCoordIndex, triangulatedFaceColors)\n          }\n        }\n      }\n\n      if (normal) {\n        if (normalPerVertex === true) {\n          // consider vertex normals\n\n          if (normalIndex && normalIndex.length > 0) {\n            // if the normalIndex field is not empty, then it is used to choose normals for each vertex of the IndexedFaceSet.\n\n            const triangulatedNormalIndex = triangulateFaceIndex(normalIndex, ccw)\n            normalAttribute = computeAttributeFromIndexedData(\n              triangulatedCoordIndex,\n              triangulatedNormalIndex,\n              normal,\n              3,\n            )\n          } else {\n            // if the normalIndex field is empty, then the coordIndex field is used to choose normals from the Normal node\n\n            normalAttribute = toNonIndexedAttribute(triangulatedCoordIndex, new Float32BufferAttribute(normal, 3))\n          }\n        } else {\n          // consider face normals\n\n          if (normalIndex && normalIndex.length > 0) {\n            // if the normalIndex field is not empty, then they are used to choose one normal for each face of the IndexedFaceSet\n\n            const flattenFaceNormals = flattenData(normal, normalIndex)\n            const triangulatedFaceNormals = triangulateFaceData(flattenFaceNormals, coordIndex)\n            normalAttribute = computeAttributeFromFaceData(triangulatedCoordIndex, triangulatedFaceNormals)\n          } else {\n            // if the normalIndex field is empty, then the normals are applied to each face of the IndexedFaceSet in order\n\n            const triangulatedFaceNormals = triangulateFaceData(normal, coordIndex)\n            normalAttribute = computeAttributeFromFaceData(triangulatedCoordIndex, triangulatedFaceNormals)\n          }\n        }\n      } else {\n        // if the normal field is NULL, then the loader should automatically generate normals, using creaseAngle to determine if and how normals are smoothed across shared vertices\n\n        normalAttribute = computeNormalAttribute(triangulatedCoordIndex, coord, creaseAngle)\n      }\n\n      if (texCoord) {\n        // texture coordinates are always defined on vertex level\n\n        if (texCoordIndex && texCoordIndex.length > 0) {\n          // if the texCoordIndex field is not empty, then it is used to choose texture coordinates for each vertex of the IndexedFaceSet.\n\n          const triangulatedTexCoordIndex = triangulateFaceIndex(texCoordIndex, ccw)\n          uvAttribute = computeAttributeFromIndexedData(triangulatedCoordIndex, triangulatedTexCoordIndex, texCoord, 2)\n        } else {\n          // if the texCoordIndex field is empty, then the coordIndex array is used to choose texture coordinates from the TextureCoordinate node\n\n          uvAttribute = toNonIndexedAttribute(triangulatedCoordIndex, new Float32BufferAttribute(texCoord, 2))\n        }\n      }\n\n      const geometry = new BufferGeometry()\n      const positionAttribute = toNonIndexedAttribute(triangulatedCoordIndex, new Float32BufferAttribute(coord, 3))\n\n      geometry.setAttribute('position', positionAttribute)\n      geometry.setAttribute('normal', normalAttribute)\n\n      // optional attributes\n\n      if (colorAttribute) geometry.setAttribute('color', colorAttribute)\n      if (uvAttribute) geometry.setAttribute('uv', uvAttribute)\n\n      // \"solid\" influences the material so let's store it for later use\n\n      geometry._solid = solid\n      geometry._type = 'mesh'\n\n      return geometry\n    }\n\n    function buildIndexedLineSetNode(node) {\n      let color, coord\n      let colorIndex, coordIndex\n      let colorPerVertex = true\n\n      const fields = node.fields\n\n      for (let i = 0, l = fields.length; i < l; i++) {\n        const field = fields[i]\n        const fieldName = field.name\n        const fieldValues = field.values\n\n        switch (fieldName) {\n          case 'color':\n            const colorNode = fieldValues[0]\n\n            if (colorNode !== null) {\n              color = getNode(colorNode)\n            }\n\n            break\n\n          case 'coord':\n            const coordNode = fieldValues[0]\n\n            if (coordNode !== null) {\n              coord = getNode(coordNode)\n            }\n\n            break\n\n          case 'colorIndex':\n            colorIndex = fieldValues\n            break\n\n          case 'colorPerVertex':\n            colorPerVertex = fieldValues[0]\n            break\n\n          case 'coordIndex':\n            coordIndex = fieldValues\n            break\n\n          default:\n            console.warn('THREE.VRMLLoader: Unknown field:', fieldName)\n            break\n        }\n      }\n\n      // build lines\n\n      let colorAttribute\n\n      const expandedLineIndex = expandLineIndex(coordIndex) // create an index for three.js's linesegment primitive\n\n      if (color) {\n        if (colorPerVertex === true) {\n          if (colorIndex.length > 0) {\n            // if the colorIndex field is not empty, then one color is used for each polyline of the IndexedLineSet.\n\n            const expandedColorIndex = expandLineIndex(colorIndex) // compute colors for each line segment (rendering primitve)\n            colorAttribute = computeAttributeFromIndexedData(expandedLineIndex, expandedColorIndex, color, 3) // compute data on vertex level\n          } else {\n            // if the colorIndex field is empty, then the colors are applied to each polyline of the IndexedLineSet in order.\n\n            colorAttribute = toNonIndexedAttribute(expandedLineIndex, new Float32BufferAttribute(color, 3))\n          }\n        } else {\n          if (colorIndex.length > 0) {\n            // if the colorIndex field is not empty, then colors are applied to each vertex of the IndexedLineSet\n\n            const flattenLineColors = flattenData(color, colorIndex) // compute colors for each VRML primitve\n            const expandedLineColors = expandLineData(flattenLineColors, coordIndex) // compute colors for each line segment (rendering primitve)\n            colorAttribute = computeAttributeFromLineData(expandedLineIndex, expandedLineColors) // compute data on vertex level\n          } else {\n            // if the colorIndex field is empty, then the coordIndex field is used to choose colors from the Color node\n\n            const expandedLineColors = expandLineData(color, coordIndex) // compute colors for each line segment (rendering primitve)\n            colorAttribute = computeAttributeFromLineData(expandedLineIndex, expandedLineColors) // compute data on vertex level\n          }\n        }\n      }\n\n      //\n\n      const geometry = new BufferGeometry()\n\n      const positionAttribute = toNonIndexedAttribute(expandedLineIndex, new Float32BufferAttribute(coord, 3))\n      geometry.setAttribute('position', positionAttribute)\n\n      if (colorAttribute) geometry.setAttribute('color', colorAttribute)\n\n      geometry._type = 'line'\n\n      return geometry\n    }\n\n    function buildPointSetNode(node) {\n      let color, coord\n\n      const fields = node.fields\n\n      for (let i = 0, l = fields.length; i < l; i++) {\n        const field = fields[i]\n        const fieldName = field.name\n        const fieldValues = field.values\n\n        switch (fieldName) {\n          case 'color':\n            const colorNode = fieldValues[0]\n\n            if (colorNode !== null) {\n              color = getNode(colorNode)\n            }\n\n            break\n\n          case 'coord':\n            const coordNode = fieldValues[0]\n\n            if (coordNode !== null) {\n              coord = getNode(coordNode)\n            }\n\n            break\n\n          default:\n            console.warn('THREE.VRMLLoader: Unknown field:', fieldName)\n            break\n        }\n      }\n\n      const geometry = new BufferGeometry()\n\n      geometry.setAttribute('position', new Float32BufferAttribute(coord, 3))\n      if (color) geometry.setAttribute('color', new Float32BufferAttribute(color, 3))\n\n      geometry._type = 'points'\n\n      return geometry\n    }\n\n    function buildBoxNode(node) {\n      const size = new Vector3(2, 2, 2)\n\n      const fields = node.fields\n\n      for (let i = 0, l = fields.length; i < l; i++) {\n        const field = fields[i]\n        const fieldName = field.name\n        const fieldValues = field.values\n\n        switch (fieldName) {\n          case 'size':\n            size.x = fieldValues[0]\n            size.y = fieldValues[1]\n            size.z = fieldValues[2]\n            break\n\n          default:\n            console.warn('THREE.VRMLLoader: Unknown field:', fieldName)\n            break\n        }\n      }\n\n      const geometry = new BoxGeometry(size.x, size.y, size.z)\n\n      return geometry\n    }\n\n    function buildConeNode(node) {\n      let radius = 1,\n        height = 2,\n        openEnded = false\n\n      const fields = node.fields\n\n      for (let i = 0, l = fields.length; i < l; i++) {\n        const field = fields[i]\n        const fieldName = field.name\n        const fieldValues = field.values\n\n        switch (fieldName) {\n          case 'bottom':\n            openEnded = !fieldValues[0]\n            break\n\n          case 'bottomRadius':\n            radius = fieldValues[0]\n            break\n\n          case 'height':\n            height = fieldValues[0]\n            break\n\n          case 'side':\n            // field not supported\n            break\n\n          default:\n            console.warn('THREE.VRMLLoader: Unknown field:', fieldName)\n            break\n        }\n      }\n\n      const geometry = new ConeGeometry(radius, height, 16, 1, openEnded)\n\n      return geometry\n    }\n\n    function buildCylinderNode(node) {\n      let radius = 1,\n        height = 2\n\n      const fields = node.fields\n\n      for (let i = 0, l = fields.length; i < l; i++) {\n        const field = fields[i]\n        const fieldName = field.name\n        const fieldValues = field.values\n\n        switch (fieldName) {\n          case 'bottom':\n            // field not supported\n            break\n\n          case 'radius':\n            radius = fieldValues[0]\n            break\n\n          case 'height':\n            height = fieldValues[0]\n            break\n\n          case 'side':\n            // field not supported\n            break\n\n          case 'top':\n            // field not supported\n            break\n\n          default:\n            console.warn('THREE.VRMLLoader: Unknown field:', fieldName)\n            break\n        }\n      }\n\n      const geometry = new CylinderGeometry(radius, radius, height, 16, 1)\n\n      return geometry\n    }\n\n    function buildSphereNode(node) {\n      let radius = 1\n\n      const fields = node.fields\n\n      for (let i = 0, l = fields.length; i < l; i++) {\n        const field = fields[i]\n        const fieldName = field.name\n        const fieldValues = field.values\n\n        switch (fieldName) {\n          case 'radius':\n            radius = fieldValues[0]\n            break\n\n          default:\n            console.warn('THREE.VRMLLoader: Unknown field:', fieldName)\n            break\n        }\n      }\n\n      const geometry = new SphereGeometry(radius, 16, 16)\n\n      return geometry\n    }\n\n    function buildElevationGridNode(node) {\n      let color\n      let normal\n      let texCoord\n      let height\n\n      let colorPerVertex = true\n      let normalPerVertex = true\n      let solid = true\n      let ccw = true\n      let creaseAngle = 0\n      let xDimension = 2\n      let zDimension = 2\n      let xSpacing = 1\n      let zSpacing = 1\n\n      const fields = node.fields\n\n      for (let i = 0, l = fields.length; i < l; i++) {\n        const field = fields[i]\n        const fieldName = field.name\n        const fieldValues = field.values\n\n        switch (fieldName) {\n          case 'color':\n            const colorNode = fieldValues[0]\n\n            if (colorNode !== null) {\n              color = getNode(colorNode)\n            }\n\n            break\n\n          case 'normal':\n            const normalNode = fieldValues[0]\n\n            if (normalNode !== null) {\n              normal = getNode(normalNode)\n            }\n\n            break\n\n          case 'texCoord':\n            const texCoordNode = fieldValues[0]\n\n            if (texCoordNode !== null) {\n              texCoord = getNode(texCoordNode)\n            }\n\n            break\n\n          case 'height':\n            height = fieldValues\n            break\n\n          case 'ccw':\n            ccw = fieldValues[0]\n            break\n\n          case 'colorPerVertex':\n            colorPerVertex = fieldValues[0]\n            break\n\n          case 'creaseAngle':\n            creaseAngle = fieldValues[0]\n            break\n\n          case 'normalPerVertex':\n            normalPerVertex = fieldValues[0]\n            break\n\n          case 'solid':\n            solid = fieldValues[0]\n            break\n\n          case 'xDimension':\n            xDimension = fieldValues[0]\n            break\n\n          case 'xSpacing':\n            xSpacing = fieldValues[0]\n            break\n\n          case 'zDimension':\n            zDimension = fieldValues[0]\n            break\n\n          case 'zSpacing':\n            zSpacing = fieldValues[0]\n            break\n\n          default:\n            console.warn('THREE.VRMLLoader: Unknown field:', fieldName)\n            break\n        }\n      }\n\n      // vertex data\n\n      const vertices = []\n      const normals = []\n      const colors = []\n      const uvs = []\n\n      for (let i = 0; i < zDimension; i++) {\n        for (let j = 0; j < xDimension; j++) {\n          // compute a row major index\n\n          const index = i * xDimension + j\n\n          // vertices\n\n          const x = xSpacing * i\n          const y = height[index]\n          const z = zSpacing * j\n\n          vertices.push(x, y, z)\n\n          // colors\n\n          if (color && colorPerVertex === true) {\n            const r = color[index * 3 + 0]\n            const g = color[index * 3 + 1]\n            const b = color[index * 3 + 2]\n\n            colors.push(r, g, b)\n          }\n\n          // normals\n\n          if (normal && normalPerVertex === true) {\n            const xn = normal[index * 3 + 0]\n            const yn = normal[index * 3 + 1]\n            const zn = normal[index * 3 + 2]\n\n            normals.push(xn, yn, zn)\n          }\n\n          // uvs\n\n          if (texCoord) {\n            const s = texCoord[index * 2 + 0]\n            const t = texCoord[index * 2 + 1]\n\n            uvs.push(s, t)\n          } else {\n            uvs.push(i / (xDimension - 1), j / (zDimension - 1))\n          }\n        }\n      }\n\n      // indices\n\n      const indices = []\n\n      for (let i = 0; i < xDimension - 1; i++) {\n        for (let j = 0; j < zDimension - 1; j++) {\n          // from https://tecfa.unige.ch/guides/vrml/vrml97/spec/part1/nodesRef.html#ElevationGrid\n\n          const a = i + j * xDimension\n          const b = i + (j + 1) * xDimension\n          const c = i + 1 + (j + 1) * xDimension\n          const d = i + 1 + j * xDimension\n\n          // faces\n\n          if (ccw === true) {\n            indices.push(a, c, b)\n            indices.push(c, a, d)\n          } else {\n            indices.push(a, b, c)\n            indices.push(c, d, a)\n          }\n        }\n      }\n\n      //\n\n      const positionAttribute = toNonIndexedAttribute(indices, new Float32BufferAttribute(vertices, 3))\n      const uvAttribute = toNonIndexedAttribute(indices, new Float32BufferAttribute(uvs, 2))\n      let colorAttribute\n      let normalAttribute\n\n      // color attribute\n\n      if (color) {\n        if (colorPerVertex === false) {\n          for (let i = 0; i < xDimension - 1; i++) {\n            for (let j = 0; j < zDimension - 1; j++) {\n              const index = i + j * (xDimension - 1)\n\n              const r = color[index * 3 + 0]\n              const g = color[index * 3 + 1]\n              const b = color[index * 3 + 2]\n\n              // one color per quad\n\n              colors.push(r, g, b)\n              colors.push(r, g, b)\n              colors.push(r, g, b)\n              colors.push(r, g, b)\n              colors.push(r, g, b)\n              colors.push(r, g, b)\n            }\n          }\n\n          colorAttribute = new Float32BufferAttribute(colors, 3)\n        } else {\n          colorAttribute = toNonIndexedAttribute(indices, new Float32BufferAttribute(colors, 3))\n        }\n      }\n\n      // normal attribute\n\n      if (normal) {\n        if (normalPerVertex === false) {\n          for (let i = 0; i < xDimension - 1; i++) {\n            for (let j = 0; j < zDimension - 1; j++) {\n              const index = i + j * (xDimension - 1)\n\n              const xn = normal[index * 3 + 0]\n              const yn = normal[index * 3 + 1]\n              const zn = normal[index * 3 + 2]\n\n              // one normal per quad\n\n              normals.push(xn, yn, zn)\n              normals.push(xn, yn, zn)\n              normals.push(xn, yn, zn)\n              normals.push(xn, yn, zn)\n              normals.push(xn, yn, zn)\n              normals.push(xn, yn, zn)\n            }\n          }\n\n          normalAttribute = new Float32BufferAttribute(normals, 3)\n        } else {\n          normalAttribute = toNonIndexedAttribute(indices, new Float32BufferAttribute(normals, 3))\n        }\n      } else {\n        normalAttribute = computeNormalAttribute(indices, vertices, creaseAngle)\n      }\n\n      // build geometry\n\n      const geometry = new BufferGeometry()\n      geometry.setAttribute('position', positionAttribute)\n      geometry.setAttribute('normal', normalAttribute)\n      geometry.setAttribute('uv', uvAttribute)\n\n      if (colorAttribute) geometry.setAttribute('color', colorAttribute)\n\n      // \"solid\" influences the material so let's store it for later use\n\n      geometry._solid = solid\n      geometry._type = 'mesh'\n\n      return geometry\n    }\n\n    function buildExtrusionNode(node) {\n      let crossSection = [1, 1, 1, -1, -1, -1, -1, 1, 1, 1]\n      let spine = [0, 0, 0, 0, 1, 0]\n      let scale\n      let orientation\n\n      let beginCap = true\n      let ccw = true\n      let creaseAngle = 0\n      let endCap = true\n      let solid = true\n\n      const fields = node.fields\n\n      for (let i = 0, l = fields.length; i < l; i++) {\n        const field = fields[i]\n        const fieldName = field.name\n        const fieldValues = field.values\n\n        switch (fieldName) {\n          case 'beginCap':\n            beginCap = fieldValues[0]\n            break\n\n          case 'ccw':\n            ccw = fieldValues[0]\n            break\n\n          case 'convex':\n            // field not supported\n            break\n\n          case 'creaseAngle':\n            creaseAngle = fieldValues[0]\n            break\n\n          case 'crossSection':\n            crossSection = fieldValues\n            break\n\n          case 'endCap':\n            endCap = fieldValues[0]\n            break\n\n          case 'orientation':\n            orientation = fieldValues\n            break\n\n          case 'scale':\n            scale = fieldValues\n            break\n\n          case 'solid':\n            solid = fieldValues[0]\n            break\n\n          case 'spine':\n            spine = fieldValues // only extrusion along the Y-axis are supported so far\n            break\n\n          default:\n            console.warn('THREE.VRMLLoader: Unknown field:', fieldName)\n            break\n        }\n      }\n\n      const crossSectionClosed =\n        crossSection[0] === crossSection[crossSection.length - 2] &&\n        crossSection[1] === crossSection[crossSection.length - 1]\n\n      // vertices\n\n      const vertices = []\n      const spineVector = new Vector3()\n      const scaling = new Vector3()\n\n      const axis = new Vector3()\n      const vertex = new Vector3()\n      const quaternion = new Quaternion()\n\n      for (let i = 0, j = 0, o = 0, il = spine.length; i < il; i += 3, j += 2, o += 4) {\n        spineVector.fromArray(spine, i)\n\n        scaling.x = scale ? scale[j + 0] : 1\n        scaling.y = 1\n        scaling.z = scale ? scale[j + 1] : 1\n\n        axis.x = orientation ? orientation[o + 0] : 0\n        axis.y = orientation ? orientation[o + 1] : 0\n        axis.z = orientation ? orientation[o + 2] : 1\n        const angle = orientation ? orientation[o + 3] : 0\n\n        for (let k = 0, kl = crossSection.length; k < kl; k += 2) {\n          vertex.x = crossSection[k + 0]\n          vertex.y = 0\n          vertex.z = crossSection[k + 1]\n\n          // scale\n\n          vertex.multiply(scaling)\n\n          // rotate\n\n          quaternion.setFromAxisAngle(axis, angle)\n          vertex.applyQuaternion(quaternion)\n\n          // translate\n\n          vertex.add(spineVector)\n\n          vertices.push(vertex.x, vertex.y, vertex.z)\n        }\n      }\n\n      // indices\n\n      const indices = []\n\n      const spineCount = spine.length / 3\n      const crossSectionCount = crossSection.length / 2\n\n      for (let i = 0; i < spineCount - 1; i++) {\n        for (let j = 0; j < crossSectionCount - 1; j++) {\n          const a = j + i * crossSectionCount\n          let b = j + 1 + i * crossSectionCount\n          const c = j + (i + 1) * crossSectionCount\n          let d = j + 1 + (i + 1) * crossSectionCount\n\n          if (j === crossSectionCount - 2 && crossSectionClosed === true) {\n            b = i * crossSectionCount\n            d = (i + 1) * crossSectionCount\n          }\n\n          if (ccw === true) {\n            indices.push(a, b, c)\n            indices.push(c, b, d)\n          } else {\n            indices.push(a, c, b)\n            indices.push(c, d, b)\n          }\n        }\n      }\n\n      // triangulate cap\n\n      if (beginCap === true || endCap === true) {\n        const contour = []\n\n        for (let i = 0, l = crossSection.length; i < l; i += 2) {\n          contour.push(new Vector2(crossSection[i], crossSection[i + 1]))\n        }\n\n        const faces = ShapeUtils.triangulateShape(contour, [])\n        const capIndices = []\n\n        for (let i = 0, l = faces.length; i < l; i++) {\n          const face = faces[i]\n\n          capIndices.push(face[0], face[1], face[2])\n        }\n\n        // begin cap\n\n        if (beginCap === true) {\n          for (let i = 0, l = capIndices.length; i < l; i += 3) {\n            if (ccw === true) {\n              indices.push(capIndices[i + 0], capIndices[i + 1], capIndices[i + 2])\n            } else {\n              indices.push(capIndices[i + 0], capIndices[i + 2], capIndices[i + 1])\n            }\n          }\n        }\n\n        // end cap\n\n        if (endCap === true) {\n          const indexOffset = crossSectionCount * (spineCount - 1) // references to the first vertex of the last cross section\n\n          for (let i = 0, l = capIndices.length; i < l; i += 3) {\n            if (ccw === true) {\n              indices.push(\n                indexOffset + capIndices[i + 0],\n                indexOffset + capIndices[i + 2],\n                indexOffset + capIndices[i + 1],\n              )\n            } else {\n              indices.push(\n                indexOffset + capIndices[i + 0],\n                indexOffset + capIndices[i + 1],\n                indexOffset + capIndices[i + 2],\n              )\n            }\n          }\n        }\n      }\n\n      const positionAttribute = toNonIndexedAttribute(indices, new Float32BufferAttribute(vertices, 3))\n      const normalAttribute = computeNormalAttribute(indices, vertices, creaseAngle)\n\n      const geometry = new BufferGeometry()\n      geometry.setAttribute('position', positionAttribute)\n      geometry.setAttribute('normal', normalAttribute)\n      // no uvs yet\n\n      // \"solid\" influences the material so let's store it for later use\n\n      geometry._solid = solid\n      geometry._type = 'mesh'\n\n      return geometry\n    }\n\n    // helper functions\n\n    function resolveUSE(identifier) {\n      const node = nodeMap[identifier]\n      const build = getNode(node)\n\n      // because the same 3D objects can have different transformations, it's necessary to clone them.\n      // materials can be influenced by the geometry (e.g. vertex normals). cloning is necessary to avoid\n      // any side effects\n\n      return build.isObject3D || build.isMaterial ? build.clone() : build\n    }\n\n    function parseFieldChildren(children, owner) {\n      for (let i = 0, l = children.length; i < l; i++) {\n        const object = getNode(children[i])\n\n        if (object instanceof Object3D) owner.add(object)\n      }\n    }\n\n    function triangulateFaceIndex(index, ccw) {\n      const indices = []\n\n      // since face defintions can have more than three vertices, it's necessary to\n      // perform a simple triangulation\n\n      let start = 0\n\n      for (let i = 0, l = index.length; i < l; i++) {\n        const i1 = index[start]\n        const i2 = index[i + (ccw ? 1 : 2)]\n        const i3 = index[i + (ccw ? 2 : 1)]\n\n        indices.push(i1, i2, i3)\n\n        // an index of -1 indicates that the current face has ended and the next one begins\n\n        if (index[i + 3] === -1 || i + 3 >= l) {\n          i += 3\n          start = i + 1\n        }\n      }\n\n      return indices\n    }\n\n    function triangulateFaceData(data, index) {\n      const triangulatedData = []\n\n      let start = 0\n\n      for (let i = 0, l = index.length; i < l; i++) {\n        const stride = start * 3\n\n        const x = data[stride]\n        const y = data[stride + 1]\n        const z = data[stride + 2]\n\n        triangulatedData.push(x, y, z)\n\n        // an index of -1 indicates that the current face has ended and the next one begins\n\n        if (index[i + 3] === -1 || i + 3 >= l) {\n          i += 3\n          start++\n        }\n      }\n\n      return triangulatedData\n    }\n\n    function flattenData(data, index) {\n      const flattenData = []\n\n      for (let i = 0, l = index.length; i < l; i++) {\n        const i1 = index[i]\n\n        const stride = i1 * 3\n\n        const x = data[stride]\n        const y = data[stride + 1]\n        const z = data[stride + 2]\n\n        flattenData.push(x, y, z)\n      }\n\n      return flattenData\n    }\n\n    function expandLineIndex(index) {\n      const indices = []\n\n      for (let i = 0, l = index.length; i < l; i++) {\n        const i1 = index[i]\n        const i2 = index[i + 1]\n\n        indices.push(i1, i2)\n\n        // an index of -1 indicates that the current line has ended and the next one begins\n\n        if (index[i + 2] === -1 || i + 2 >= l) {\n          i += 2\n        }\n      }\n\n      return indices\n    }\n\n    function expandLineData(data, index) {\n      const triangulatedData = []\n\n      let start = 0\n\n      for (let i = 0, l = index.length; i < l; i++) {\n        const stride = start * 3\n\n        const x = data[stride]\n        const y = data[stride + 1]\n        const z = data[stride + 2]\n\n        triangulatedData.push(x, y, z)\n\n        // an index of -1 indicates that the current line has ended and the next one begins\n\n        if (index[i + 2] === -1 || i + 2 >= l) {\n          i += 2\n          start++\n        }\n      }\n\n      return triangulatedData\n    }\n\n    const vA = new Vector3()\n    const vB = new Vector3()\n    const vC = new Vector3()\n\n    const uvA = new Vector2()\n    const uvB = new Vector2()\n    const uvC = new Vector2()\n\n    function computeAttributeFromIndexedData(coordIndex, index, data, itemSize) {\n      const array = []\n\n      // we use the coordIndex.length as delimiter since normalIndex must contain at least as many indices\n\n      for (let i = 0, l = coordIndex.length; i < l; i += 3) {\n        const a = index[i]\n        const b = index[i + 1]\n        const c = index[i + 2]\n\n        if (itemSize === 2) {\n          uvA.fromArray(data, a * itemSize)\n          uvB.fromArray(data, b * itemSize)\n          uvC.fromArray(data, c * itemSize)\n\n          array.push(uvA.x, uvA.y)\n          array.push(uvB.x, uvB.y)\n          array.push(uvC.x, uvC.y)\n        } else {\n          vA.fromArray(data, a * itemSize)\n          vB.fromArray(data, b * itemSize)\n          vC.fromArray(data, c * itemSize)\n\n          array.push(vA.x, vA.y, vA.z)\n          array.push(vB.x, vB.y, vB.z)\n          array.push(vC.x, vC.y, vC.z)\n        }\n      }\n\n      return new Float32BufferAttribute(array, itemSize)\n    }\n\n    function computeAttributeFromFaceData(index, faceData) {\n      const array = []\n\n      for (let i = 0, j = 0, l = index.length; i < l; i += 3, j++) {\n        vA.fromArray(faceData, j * 3)\n\n        array.push(vA.x, vA.y, vA.z)\n        array.push(vA.x, vA.y, vA.z)\n        array.push(vA.x, vA.y, vA.z)\n      }\n\n      return new Float32BufferAttribute(array, 3)\n    }\n\n    function computeAttributeFromLineData(index, lineData) {\n      const array = []\n\n      for (let i = 0, j = 0, l = index.length; i < l; i += 2, j++) {\n        vA.fromArray(lineData, j * 3)\n\n        array.push(vA.x, vA.y, vA.z)\n        array.push(vA.x, vA.y, vA.z)\n      }\n\n      return new Float32BufferAttribute(array, 3)\n    }\n\n    function toNonIndexedAttribute(indices, attribute) {\n      const array = attribute.array\n      const itemSize = attribute.itemSize\n\n      const array2 = new array.constructor(indices.length * itemSize)\n\n      let index = 0,\n        index2 = 0\n\n      for (let i = 0, l = indices.length; i < l; i++) {\n        index = indices[i] * itemSize\n\n        for (let j = 0; j < itemSize; j++) {\n          array2[index2++] = array[index++]\n        }\n      }\n\n      return new Float32BufferAttribute(array2, itemSize)\n    }\n\n    const ab = new Vector3()\n    const cb = new Vector3()\n\n    function computeNormalAttribute(index, coord, creaseAngle) {\n      const faces = []\n      const vertexNormals = {}\n\n      // prepare face and raw vertex normals\n\n      for (let i = 0, l = index.length; i < l; i += 3) {\n        const a = index[i]\n        const b = index[i + 1]\n        const c = index[i + 2]\n\n        const face = new Face(a, b, c)\n\n        vA.fromArray(coord, a * 3)\n        vB.fromArray(coord, b * 3)\n        vC.fromArray(coord, c * 3)\n\n        cb.subVectors(vC, vB)\n        ab.subVectors(vA, vB)\n        cb.cross(ab)\n\n        cb.normalize()\n\n        face.normal.copy(cb)\n\n        if (vertexNormals[a] === undefined) vertexNormals[a] = []\n        if (vertexNormals[b] === undefined) vertexNormals[b] = []\n        if (vertexNormals[c] === undefined) vertexNormals[c] = []\n\n        vertexNormals[a].push(face.normal)\n        vertexNormals[b].push(face.normal)\n        vertexNormals[c].push(face.normal)\n\n        faces.push(face)\n      }\n\n      // compute vertex normals and build final geometry\n\n      const normals = []\n\n      for (let i = 0, l = faces.length; i < l; i++) {\n        const face = faces[i]\n\n        const nA = weightedNormal(vertexNormals[face.a], face.normal, creaseAngle)\n        const nB = weightedNormal(vertexNormals[face.b], face.normal, creaseAngle)\n        const nC = weightedNormal(vertexNormals[face.c], face.normal, creaseAngle)\n\n        vA.fromArray(coord, face.a * 3)\n        vB.fromArray(coord, face.b * 3)\n        vC.fromArray(coord, face.c * 3)\n\n        normals.push(nA.x, nA.y, nA.z)\n        normals.push(nB.x, nB.y, nB.z)\n        normals.push(nC.x, nC.y, nC.z)\n      }\n\n      return new Float32BufferAttribute(normals, 3)\n    }\n\n    function weightedNormal(normals, vector, creaseAngle) {\n      const normal = new Vector3()\n\n      if (creaseAngle === 0) {\n        normal.copy(vector)\n      } else {\n        for (let i = 0, l = normals.length; i < l; i++) {\n          if (normals[i].angleTo(vector) < creaseAngle) {\n            normal.add(normals[i])\n          }\n        }\n      }\n\n      return normal.normalize()\n    }\n\n    function toColorArray(colors) {\n      const array = []\n\n      for (let i = 0, l = colors.length; i < l; i += 3) {\n        array.push(new Color(colors[i], colors[i + 1], colors[i + 2]))\n      }\n\n      return array\n    }\n\n    /**\n     * Vertically paints the faces interpolating between the\n     * specified colors at the specified angels. This is used for the Background\n     * node, but could be applied to other nodes with multiple faces as well.\n     *\n     * When used with the Background node, default is directionIsDown is true if\n     * interpolating the skyColor down from the Zenith. When interpolationg up from\n     * the Nadir i.e. interpolating the groundColor, the directionIsDown is false.\n     *\n     * The first angle is never specified, it is the Zenith (0 rad). Angles are specified\n     * in radians. The geometry is thought a sphere, but could be anything. The color interpolation\n     * is linear along the Y axis in any case.\n     *\n     * You must specify one more color than you have angles at the beginning of the colors array.\n     * This is the color of the Zenith (the top of the shape).\n     *\n     * @param {BufferGeometry} geometry\n     * @param {number} radius\n     * @param {array} angles\n     * @param {array} colors\n     * @param {boolean} topDown - Whether to work top down or bottom up.\n     */\n    function paintFaces(geometry, radius, angles, colors, topDown) {\n      // compute threshold values\n\n      const thresholds = []\n      const startAngle = topDown === true ? 0 : Math.PI\n\n      for (let i = 0, l = colors.length; i < l; i++) {\n        let angle = i === 0 ? 0 : angles[i - 1]\n        angle = topDown === true ? angle : startAngle - angle\n\n        const point = new Vector3()\n        point.setFromSphericalCoords(radius, angle, 0)\n\n        thresholds.push(point)\n      }\n\n      // generate vertex colors\n\n      const indices = geometry.index\n      const positionAttribute = geometry.attributes.position\n      const colorAttribute = new BufferAttribute(new Float32Array(geometry.attributes.position.count * 3), 3)\n\n      const position = new Vector3()\n      const color = new Color()\n\n      for (let i = 0; i < indices.count; i++) {\n        const index = indices.getX(i)\n        position.fromBufferAttribute(positionAttribute, index)\n\n        let thresholdIndexA, thresholdIndexB\n        let t = 1\n\n        for (let j = 1; j < thresholds.length; j++) {\n          thresholdIndexA = j - 1\n          thresholdIndexB = j\n\n          const thresholdA = thresholds[thresholdIndexA]\n          const thresholdB = thresholds[thresholdIndexB]\n\n          if (topDown === true) {\n            // interpolation for sky color\n\n            if (position.y <= thresholdA.y && position.y > thresholdB.y) {\n              t = Math.abs(thresholdA.y - position.y) / Math.abs(thresholdA.y - thresholdB.y)\n\n              break\n            }\n          } else {\n            // interpolation for ground color\n\n            if (position.y >= thresholdA.y && position.y < thresholdB.y) {\n              t = Math.abs(thresholdA.y - position.y) / Math.abs(thresholdA.y - thresholdB.y)\n\n              break\n            }\n          }\n        }\n\n        const colorA = colors[thresholdIndexA]\n        const colorB = colors[thresholdIndexB]\n\n        color.copy(colorA).lerp(colorB, t)\n\n        colorAttribute.setXYZ(index, color.r, color.g, color.b)\n      }\n\n      geometry.setAttribute('color', colorAttribute)\n    }\n\n    //\n\n    const textureLoader = new TextureLoader(this.manager)\n    textureLoader.setPath(this.resourcePath || path).setCrossOrigin(this.crossOrigin)\n\n    // check version (only 2.0 is supported)\n\n    if (data.indexOf('#VRML V2.0') === -1) {\n      throw Error('THREE.VRMLLexer: Version of VRML asset not supported.')\n    }\n\n    // create JSON representing the tree structure of the VRML asset\n\n    const tree = generateVRMLTree(data)\n\n    // parse the tree structure to a three.js scene\n\n    const scene = parseTree(tree)\n\n    return scene\n  }\n}\n\nclass VRMLLexer {\n  constructor(tokens) {\n    this.lexer = new Lexer(tokens)\n  }\n\n  lex(inputText) {\n    const lexingResult = this.lexer.tokenize(inputText)\n\n    if (lexingResult.errors.length > 0) {\n      console.error(lexingResult.errors)\n\n      throw Error('THREE.VRMLLexer: Lexing errors detected.')\n    }\n\n    return lexingResult\n  }\n}\n\nclass VRMLParser extends CstParser {\n  constructor(tokenVocabulary) {\n    super(tokenVocabulary)\n\n    const $ = this\n\n    const Version = tokenVocabulary['Version']\n    const LCurly = tokenVocabulary['LCurly']\n    const RCurly = tokenVocabulary['RCurly']\n    const LSquare = tokenVocabulary['LSquare']\n    const RSquare = tokenVocabulary['RSquare']\n    const Identifier = tokenVocabulary['Identifier']\n    const RouteIdentifier = tokenVocabulary['RouteIdentifier']\n    const StringLiteral = tokenVocabulary['StringLiteral']\n    const HexLiteral = tokenVocabulary['HexLiteral']\n    const NumberLiteral = tokenVocabulary['NumberLiteral']\n    const TrueLiteral = tokenVocabulary['TrueLiteral']\n    const FalseLiteral = tokenVocabulary['FalseLiteral']\n    const NullLiteral = tokenVocabulary['NullLiteral']\n    const DEF = tokenVocabulary['DEF']\n    const USE = tokenVocabulary['USE']\n    const ROUTE = tokenVocabulary['ROUTE']\n    const TO = tokenVocabulary['TO']\n    const NodeName = tokenVocabulary['NodeName']\n\n    $.RULE('vrml', function () {\n      $.SUBRULE($.version)\n      $.AT_LEAST_ONE(function () {\n        $.SUBRULE($.node)\n      })\n      $.MANY(function () {\n        $.SUBRULE($.route)\n      })\n    })\n\n    $.RULE('version', function () {\n      $.CONSUME(Version)\n    })\n\n    $.RULE('node', function () {\n      $.OPTION(function () {\n        $.SUBRULE($.def)\n      })\n\n      $.CONSUME(NodeName)\n      $.CONSUME(LCurly)\n      $.MANY(function () {\n        $.SUBRULE($.field)\n      })\n      $.CONSUME(RCurly)\n    })\n\n    $.RULE('field', function () {\n      $.CONSUME(Identifier)\n\n      $.OR2([\n        {\n          ALT: function () {\n            $.SUBRULE($.singleFieldValue)\n          },\n        },\n        {\n          ALT: function () {\n            $.SUBRULE($.multiFieldValue)\n          },\n        },\n      ])\n    })\n\n    $.RULE('def', function () {\n      $.CONSUME(DEF)\n      $.OR([\n        {\n          ALT: function () {\n            $.CONSUME(Identifier)\n          },\n        },\n        {\n          ALT: function () {\n            $.CONSUME(NodeName)\n          },\n        },\n      ])\n    })\n\n    $.RULE('use', function () {\n      $.CONSUME(USE)\n      $.OR([\n        {\n          ALT: function () {\n            $.CONSUME(Identifier)\n          },\n        },\n        {\n          ALT: function () {\n            $.CONSUME(NodeName)\n          },\n        },\n      ])\n    })\n\n    $.RULE('singleFieldValue', function () {\n      $.AT_LEAST_ONE(function () {\n        $.OR([\n          {\n            ALT: function () {\n              $.SUBRULE($.node)\n            },\n          },\n          {\n            ALT: function () {\n              $.SUBRULE($.use)\n            },\n          },\n          {\n            ALT: function () {\n              $.CONSUME(StringLiteral)\n            },\n          },\n          {\n            ALT: function () {\n              $.CONSUME(HexLiteral)\n            },\n          },\n          {\n            ALT: function () {\n              $.CONSUME(NumberLiteral)\n            },\n          },\n          {\n            ALT: function () {\n              $.CONSUME(TrueLiteral)\n            },\n          },\n          {\n            ALT: function () {\n              $.CONSUME(FalseLiteral)\n            },\n          },\n          {\n            ALT: function () {\n              $.CONSUME(NullLiteral)\n            },\n          },\n        ])\n      })\n    })\n\n    $.RULE('multiFieldValue', function () {\n      $.CONSUME(LSquare)\n      $.MANY(function () {\n        $.OR([\n          {\n            ALT: function () {\n              $.SUBRULE($.node)\n            },\n          },\n          {\n            ALT: function () {\n              $.SUBRULE($.use)\n            },\n          },\n          {\n            ALT: function () {\n              $.CONSUME(StringLiteral)\n            },\n          },\n          {\n            ALT: function () {\n              $.CONSUME(HexLiteral)\n            },\n          },\n          {\n            ALT: function () {\n              $.CONSUME(NumberLiteral)\n            },\n          },\n          {\n            ALT: function () {\n              $.CONSUME(NullLiteral)\n            },\n          },\n        ])\n      })\n      $.CONSUME(RSquare)\n    })\n\n    $.RULE('route', function () {\n      $.CONSUME(ROUTE)\n      $.CONSUME(RouteIdentifier)\n      $.CONSUME(TO)\n      $.CONSUME2(RouteIdentifier)\n    })\n\n    this.performSelfAnalysis()\n  }\n}\n\nclass Face {\n  constructor(a, b, c) {\n    this.a = a\n    this.b = b\n    this.c = c\n    this.normal = new Vector3()\n  }\n}\n\nconst TEXTURE_TYPE = {\n  INTENSITY: 1,\n  INTENSITY_ALPHA: 2,\n  RGB: 3,\n  RGBA: 4,\n}\n\nexport { VRMLLoader }\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}