{"ast":null,"code":"import _classCallCheck from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _assertThisInitialized from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js\";\nimport _get from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/get.js\";\nimport _getPrototypeOf from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js\";\nimport _inherits from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport * as THREE from \"three\";\nvar PINCH_MAX = 0.05;\nvar PINCH_THRESHOLD = 0.02;\nvar PINCH_MIN = 0.01;\nvar POINTER_ADVANCE_MAX = 0.02;\nvar POINTER_OPACITY_MAX = 1;\nvar POINTER_OPACITY_MIN = 0.4;\nvar POINTER_FRONT_RADIUS = 2e-3;\nvar POINTER_REAR_RADIUS = 0.01;\nvar POINTER_REAR_RADIUS_MIN = 3e-3;\nvar POINTER_LENGTH = 0.035;\nvar POINTER_SEGMENTS = 16;\nvar POINTER_RINGS = 12;\nvar POINTER_HEMISPHERE_ANGLE = 110;\nvar YAXIS = new THREE.Vector3(0, 1, 0);\nvar ZAXIS = new THREE.Vector3(0, 0, 1);\nvar CURSOR_RADIUS = 0.02;\nvar CURSOR_MAX_DISTANCE = 1.5;\nvar OculusHandPointerModel = /*#__PURE__*/function (_THREE$Object3D) {\n  _inherits(OculusHandPointerModel, _THREE$Object3D);\n  var _super = _createSuper(OculusHandPointerModel);\n  function OculusHandPointerModel(hand, controller) {\n    var _this;\n    _classCallCheck(this, OculusHandPointerModel);\n    _this = _super.call(this);\n    _this.hand = hand;\n    _this.controller = controller;\n    _this.motionController = null;\n    _this.envMap = null;\n    _this.mesh = null;\n    _this.pointerGeometry = null;\n    _this.pointerMesh = null;\n    _this.pointerObject = null;\n    _this.pinched = false;\n    _this.attached = false;\n    _this.cursorObject = null;\n    _this.raycaster = null;\n    _this._onConnected = _this._onConnected.bind(_assertThisInitialized(_this));\n    _this._onDisconnected = _this._onDisconnected.bind(_assertThisInitialized(_this));\n    _this.hand.addEventListener(\"connected\", _this._onConnected);\n    _this.hand.addEventListener(\"disconnected\", _this._onDisconnected);\n    return _this;\n  }\n  _createClass(OculusHandPointerModel, [{\n    key: \"_onConnected\",\n    value: function _onConnected(event) {\n      var xrInputSource = event.data;\n      if (xrInputSource.hand) {\n        this.visible = true;\n        this.xrInputSource = xrInputSource;\n        this.createPointer();\n      }\n    }\n  }, {\n    key: \"_onDisconnected\",\n    value: function _onDisconnected() {\n      var _a, _b;\n      this.visible = false;\n      this.xrInputSource = null;\n      (_a = this.pointerGeometry) == null ? void 0 : _a.dispose();\n      (_b = this.pointerMesh) == null ? void 0 : _b.material.dispose();\n      this.clear();\n    }\n  }, {\n    key: \"_drawVerticesRing\",\n    value: function _drawVerticesRing(vertices, baseVector, ringIndex) {\n      var segmentVector = baseVector.clone();\n      for (var i = 0; i < POINTER_SEGMENTS; i++) {\n        segmentVector.applyAxisAngle(ZAXIS, Math.PI * 2 / POINTER_SEGMENTS);\n        var vid = ringIndex * POINTER_SEGMENTS + i;\n        vertices[3 * vid] = segmentVector.x;\n        vertices[3 * vid + 1] = segmentVector.y;\n        vertices[3 * vid + 2] = segmentVector.z;\n      }\n    }\n  }, {\n    key: \"_updatePointerVertices\",\n    value: function _updatePointerVertices(rearRadius) {\n      var vertices = this.pointerGeometry.attributes.position.array;\n      var frontFaceBase = new THREE.Vector3(POINTER_FRONT_RADIUS, 0, -1 * (POINTER_LENGTH - rearRadius));\n      this._drawVerticesRing(vertices, frontFaceBase, 0);\n      var rearBase = new THREE.Vector3(Math.sin(Math.PI * POINTER_HEMISPHERE_ANGLE / 180) * rearRadius, Math.cos(Math.PI * POINTER_HEMISPHERE_ANGLE / 180) * rearRadius, 0);\n      for (var i = 0; i < POINTER_RINGS; i++) {\n        this._drawVerticesRing(vertices, rearBase, i + 1);\n        rearBase.applyAxisAngle(YAXIS, Math.PI * POINTER_HEMISPHERE_ANGLE / 180 / (POINTER_RINGS * -2));\n      }\n      var frontCenterIndex = POINTER_SEGMENTS * (1 + POINTER_RINGS);\n      var rearCenterIndex = POINTER_SEGMENTS * (1 + POINTER_RINGS) + 1;\n      var frontCenter = new THREE.Vector3(0, 0, -1 * (POINTER_LENGTH - rearRadius));\n      vertices[frontCenterIndex * 3] = frontCenter.x;\n      vertices[frontCenterIndex * 3 + 1] = frontCenter.y;\n      vertices[frontCenterIndex * 3 + 2] = frontCenter.z;\n      var rearCenter = new THREE.Vector3(0, 0, rearRadius);\n      vertices[rearCenterIndex * 3] = rearCenter.x;\n      vertices[rearCenterIndex * 3 + 1] = rearCenter.y;\n      vertices[rearCenterIndex * 3 + 2] = rearCenter.z;\n      this.pointerGeometry.setAttribute(\"position\", new THREE.Float32BufferAttribute(vertices, 3));\n    }\n  }, {\n    key: \"createPointer\",\n    value: function createPointer() {\n      var i, j;\n      var vertices = new Array(((POINTER_RINGS + 1) * POINTER_SEGMENTS + 2) * 3).fill(0);\n      var indices = [];\n      this.pointerGeometry = new THREE.BufferGeometry();\n      this.pointerGeometry.setAttribute(\"position\", new THREE.Float32BufferAttribute(vertices, 3));\n      this._updatePointerVertices(POINTER_REAR_RADIUS);\n      for (i = 0; i < POINTER_RINGS; i++) {\n        for (j = 0; j < POINTER_SEGMENTS - 1; j++) {\n          indices.push(i * POINTER_SEGMENTS + j, i * POINTER_SEGMENTS + j + 1, (i + 1) * POINTER_SEGMENTS + j);\n          indices.push(i * POINTER_SEGMENTS + j + 1, (i + 1) * POINTER_SEGMENTS + j + 1, (i + 1) * POINTER_SEGMENTS + j);\n        }\n        indices.push((i + 1) * POINTER_SEGMENTS - 1, i * POINTER_SEGMENTS, (i + 2) * POINTER_SEGMENTS - 1);\n        indices.push(i * POINTER_SEGMENTS, (i + 1) * POINTER_SEGMENTS, (i + 2) * POINTER_SEGMENTS - 1);\n      }\n      var frontCenterIndex = POINTER_SEGMENTS * (1 + POINTER_RINGS);\n      var rearCenterIndex = POINTER_SEGMENTS * (1 + POINTER_RINGS) + 1;\n      for (i = 0; i < POINTER_SEGMENTS - 1; i++) {\n        indices.push(frontCenterIndex, i + 1, i);\n        indices.push(rearCenterIndex, i + POINTER_SEGMENTS * POINTER_RINGS, i + POINTER_SEGMENTS * POINTER_RINGS + 1);\n      }\n      indices.push(frontCenterIndex, 0, POINTER_SEGMENTS - 1);\n      indices.push(rearCenterIndex, POINTER_SEGMENTS * (POINTER_RINGS + 1) - 1, POINTER_SEGMENTS * POINTER_RINGS);\n      var material = new THREE.MeshBasicMaterial();\n      material.transparent = true;\n      material.opacity = POINTER_OPACITY_MIN;\n      this.pointerGeometry.setIndex(indices);\n      this.pointerMesh = new THREE.Mesh(this.pointerGeometry, material);\n      this.pointerMesh.position.set(0, 0, -1 * POINTER_REAR_RADIUS);\n      this.pointerObject = new THREE.Object3D();\n      this.pointerObject.add(this.pointerMesh);\n      this.raycaster = new THREE.Raycaster();\n      var cursorGeometry = new THREE.SphereGeometry(CURSOR_RADIUS, 10, 10);\n      var cursorMaterial = new THREE.MeshBasicMaterial();\n      cursorMaterial.transparent = true;\n      cursorMaterial.opacity = POINTER_OPACITY_MIN;\n      this.cursorObject = new THREE.Mesh(cursorGeometry, cursorMaterial);\n      this.pointerObject.add(this.cursorObject);\n      this.add(this.pointerObject);\n    }\n  }, {\n    key: \"_updateRaycaster\",\n    value: function _updateRaycaster() {\n      if (this.raycaster) {\n        var pointerMatrix = this.pointerObject.matrixWorld;\n        var tempMatrix = new THREE.Matrix4();\n        tempMatrix.identity().extractRotation(pointerMatrix);\n        this.raycaster.ray.origin.setFromMatrixPosition(pointerMatrix);\n        this.raycaster.ray.direction.set(0, 0, -1).applyMatrix4(tempMatrix);\n      }\n    }\n  }, {\n    key: \"_updatePointer\",\n    value: function _updatePointer() {\n      this.pointerObject.visible = this.controller.visible;\n      var indexTip = this.hand.joints[\"index-finger-tip\"];\n      var thumbTip = this.hand.joints[\"thumb-tip\"];\n      var distance = indexTip.position.distanceTo(thumbTip.position);\n      var position = indexTip.position.clone().add(thumbTip.position).multiplyScalar(0.5);\n      this.pointerObject.position.copy(position);\n      this.pointerObject.quaternion.copy(this.controller.quaternion);\n      this.pinched = distance <= PINCH_THRESHOLD;\n      var pinchScale = (distance - PINCH_MIN) / (PINCH_MAX - PINCH_MIN);\n      var focusScale = (distance - PINCH_MIN) / (PINCH_THRESHOLD - PINCH_MIN);\n      if (pinchScale > 1) {\n        this._updatePointerVertices(POINTER_REAR_RADIUS);\n        this.pointerMesh.position.set(0, 0, -1 * POINTER_REAR_RADIUS);\n        this.pointerMesh.material.opacity = POINTER_OPACITY_MIN;\n      } else if (pinchScale > 0) {\n        var rearRadius = (POINTER_REAR_RADIUS - POINTER_REAR_RADIUS_MIN) * pinchScale + POINTER_REAR_RADIUS_MIN;\n        this._updatePointerVertices(rearRadius);\n        if (focusScale < 1) {\n          this.pointerMesh.position.set(0, 0, -1 * rearRadius - (1 - focusScale) * POINTER_ADVANCE_MAX);\n          this.pointerMesh.material.opacity = POINTER_OPACITY_MIN + (1 - focusScale) * (POINTER_OPACITY_MAX - POINTER_OPACITY_MIN);\n        } else {\n          this.pointerMesh.position.set(0, 0, -1 * rearRadius);\n          this.pointerMesh.material.opacity = POINTER_OPACITY_MIN;\n        }\n      } else {\n        this._updatePointerVertices(POINTER_REAR_RADIUS_MIN);\n        this.pointerMesh.position.set(0, 0, -1 * POINTER_REAR_RADIUS_MIN - POINTER_ADVANCE_MAX);\n        this.pointerMesh.material.opacity = POINTER_OPACITY_MAX;\n      }\n      this.cursorObject.material.opacity = this.pointerMesh.material.opacity;\n    }\n  }, {\n    key: \"updateMatrixWorld\",\n    value: function updateMatrixWorld(force) {\n      _get(_getPrototypeOf(OculusHandPointerModel.prototype), \"updateMatrixWorld\", this).call(this, force);\n      if (this.pointerGeometry) {\n        this._updatePointer();\n        this._updateRaycaster();\n      }\n    }\n  }, {\n    key: \"isPinched\",\n    value: function isPinched() {\n      return this.pinched;\n    }\n  }, {\n    key: \"setAttached\",\n    value: function setAttached(attached) {\n      this.attached = attached;\n    }\n  }, {\n    key: \"isAttached\",\n    value: function isAttached() {\n      return this.attached;\n    }\n  }, {\n    key: \"intersectObject\",\n    value: function intersectObject(object) {\n      var recursive = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      if (this.raycaster) {\n        return this.raycaster.intersectObject(object, recursive);\n      }\n    }\n  }, {\n    key: \"intersectObjects\",\n    value: function intersectObjects(objects) {\n      var recursive = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      if (this.raycaster) {\n        return this.raycaster.intersectObjects(objects, recursive);\n      }\n    }\n  }, {\n    key: \"checkIntersections\",\n    value: function checkIntersections(objects) {\n      var recursive = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      if (this.raycaster && !this.attached) {\n        var intersections = this.raycaster.intersectObjects(objects, recursive);\n        var direction = new THREE.Vector3(0, 0, -1);\n        if (intersections.length > 0) {\n          var intersection = intersections[0];\n          var distance = intersection.distance;\n          this.cursorObject.position.copy(direction.multiplyScalar(distance));\n        } else {\n          this.cursorObject.position.copy(direction.multiplyScalar(CURSOR_MAX_DISTANCE));\n        }\n      }\n    }\n  }, {\n    key: \"setCursor\",\n    value: function setCursor(distance) {\n      var direction = new THREE.Vector3(0, 0, -1);\n      if (this.raycaster && !this.attached) {\n        this.cursorObject.position.copy(direction.multiplyScalar(distance));\n      }\n    }\n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      this._onDisconnected();\n      this.hand.removeEventListener(\"connected\", this._onConnected);\n      this.hand.removeEventListener(\"disconnected\", this._onDisconnected);\n    }\n  }]);\n  return OculusHandPointerModel;\n}(THREE.Object3D);\nexport { OculusHandPointerModel };","map":{"version":3,"names":["PINCH_MAX","PINCH_THRESHOLD","PINCH_MIN","POINTER_ADVANCE_MAX","POINTER_OPACITY_MAX","POINTER_OPACITY_MIN","POINTER_FRONT_RADIUS","POINTER_REAR_RADIUS","POINTER_REAR_RADIUS_MIN","POINTER_LENGTH","POINTER_SEGMENTS","POINTER_RINGS","POINTER_HEMISPHERE_ANGLE","YAXIS","THREE","Vector3","ZAXIS","CURSOR_RADIUS","CURSOR_MAX_DISTANCE","OculusHandPointerModel","_THREE$Object3D","_inherits","_super","_createSuper","hand","controller","_this","_classCallCheck","call","motionController","envMap","mesh","pointerGeometry","pointerMesh","pointerObject","pinched","attached","cursorObject","raycaster","_onConnected","bind","_assertThisInitialized","_onDisconnected","addEventListener","_createClass","key","value","event","xrInputSource","data","visible","createPointer","_a","dispose","_b","material","clear","_drawVerticesRing","vertices","baseVector","ringIndex","segmentVector","clone","i","applyAxisAngle","Math","PI","vid","x","y","z","_updatePointerVertices","rearRadius","attributes","position","array","frontFaceBase","rearBase","sin","cos","frontCenterIndex","rearCenterIndex","frontCenter","rearCenter","setAttribute","Float32BufferAttribute","j","Array","fill","indices","BufferGeometry","push","MeshBasicMaterial","transparent","opacity","setIndex","Mesh","set","Object3D","add","Raycaster","cursorGeometry","SphereGeometry","cursorMaterial","_updateRaycaster","pointerMatrix","matrixWorld","tempMatrix","Matrix4","identity","extractRotation","ray","origin","setFromMatrixPosition","direction","applyMatrix4","_updatePointer","indexTip","joints","thumbTip","distance","distanceTo","multiplyScalar","copy","quaternion","pinchScale","focusScale","updateMatrixWorld","force","_get","_getPrototypeOf","prototype","isPinched","setAttached","isAttached","intersectObject","object","recursive","arguments","length","undefined","intersectObjects","objects","checkIntersections","intersections","intersection","setCursor","removeEventListener"],"sources":["C:\\Users\\Nayyu\\Desktop\\skibidai-public-build\\node_modules\\src\\webxr\\OculusHandPointerModel.js"],"sourcesContent":["import * as THREE from 'three'\n\nconst PINCH_MAX = 0.05\nconst PINCH_THRESHOLD = 0.02\nconst PINCH_MIN = 0.01\nconst POINTER_ADVANCE_MAX = 0.02\nconst POINTER_OPACITY_MAX = 1\nconst POINTER_OPACITY_MIN = 0.4\nconst POINTER_FRONT_RADIUS = 0.002\nconst POINTER_REAR_RADIUS = 0.01\nconst POINTER_REAR_RADIUS_MIN = 0.003\nconst POINTER_LENGTH = 0.035\nconst POINTER_SEGMENTS = 16\nconst POINTER_RINGS = 12\nconst POINTER_HEMISPHERE_ANGLE = 110\nconst YAXIS = new THREE.Vector3(0, 1, 0)\nconst ZAXIS = new THREE.Vector3(0, 0, 1)\n\nconst CURSOR_RADIUS = 0.02\nconst CURSOR_MAX_DISTANCE = 1.5\n\nclass OculusHandPointerModel extends THREE.Object3D {\n  constructor(hand, controller) {\n    super()\n\n    this.hand = hand\n    this.controller = controller\n\n    // Unused\n    this.motionController = null\n    this.envMap = null\n    this.mesh = null\n\n    this.pointerGeometry = null\n    this.pointerMesh = null\n    this.pointerObject = null\n\n    this.pinched = false\n    this.attached = false\n\n    this.cursorObject = null\n\n    this.raycaster = null\n\n    this._onConnected = this._onConnected.bind(this)\n    this._onDisconnected = this._onDisconnected.bind(this)\n    this.hand.addEventListener('connected', this._onConnected)\n    this.hand.addEventListener('disconnected', this._onDisconnected)\n  }\n\n  _onConnected(event) {\n    const xrInputSource = event.data\n    if (xrInputSource.hand) {\n      this.visible = true\n      this.xrInputSource = xrInputSource\n\n      this.createPointer()\n    }\n  }\n\n  _onDisconnected() {\n    this.visible = false\n    this.xrInputSource = null\n\n    this.pointerGeometry?.dispose()\n    this.pointerMesh?.material.dispose()\n\n    this.clear()\n  }\n\n  _drawVerticesRing(vertices, baseVector, ringIndex) {\n    const segmentVector = baseVector.clone()\n    for (var i = 0; i < POINTER_SEGMENTS; i++) {\n      segmentVector.applyAxisAngle(ZAXIS, (Math.PI * 2) / POINTER_SEGMENTS)\n      const vid = ringIndex * POINTER_SEGMENTS + i\n      vertices[3 * vid] = segmentVector.x\n      vertices[3 * vid + 1] = segmentVector.y\n      vertices[3 * vid + 2] = segmentVector.z\n    }\n  }\n\n  _updatePointerVertices(rearRadius) {\n    const vertices = this.pointerGeometry.attributes.position.array\n    // first ring for front face\n    const frontFaceBase = new THREE.Vector3(POINTER_FRONT_RADIUS, 0, -1 * (POINTER_LENGTH - rearRadius))\n    this._drawVerticesRing(vertices, frontFaceBase, 0)\n\n    // rings for rear hemisphere\n    const rearBase = new THREE.Vector3(\n      Math.sin((Math.PI * POINTER_HEMISPHERE_ANGLE) / 180) * rearRadius,\n      Math.cos((Math.PI * POINTER_HEMISPHERE_ANGLE) / 180) * rearRadius,\n      0,\n    )\n    for (var i = 0; i < POINTER_RINGS; i++) {\n      this._drawVerticesRing(vertices, rearBase, i + 1)\n      rearBase.applyAxisAngle(YAXIS, (Math.PI * POINTER_HEMISPHERE_ANGLE) / 180 / (POINTER_RINGS * -2))\n    }\n\n    // front and rear face center vertices\n    const frontCenterIndex = POINTER_SEGMENTS * (1 + POINTER_RINGS)\n    const rearCenterIndex = POINTER_SEGMENTS * (1 + POINTER_RINGS) + 1\n    const frontCenter = new THREE.Vector3(0, 0, -1 * (POINTER_LENGTH - rearRadius))\n    vertices[frontCenterIndex * 3] = frontCenter.x\n    vertices[frontCenterIndex * 3 + 1] = frontCenter.y\n    vertices[frontCenterIndex * 3 + 2] = frontCenter.z\n    const rearCenter = new THREE.Vector3(0, 0, rearRadius)\n    vertices[rearCenterIndex * 3] = rearCenter.x\n    vertices[rearCenterIndex * 3 + 1] = rearCenter.y\n    vertices[rearCenterIndex * 3 + 2] = rearCenter.z\n\n    this.pointerGeometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3))\n    // verticesNeedUpdate = true;\n  }\n\n  createPointer() {\n    var i, j\n    const vertices = new Array(((POINTER_RINGS + 1) * POINTER_SEGMENTS + 2) * 3).fill(0)\n    // const vertices = [];\n    const indices = []\n    this.pointerGeometry = new THREE.BufferGeometry()\n\n    this.pointerGeometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3))\n\n    this._updatePointerVertices(POINTER_REAR_RADIUS)\n\n    // construct faces to connect rings\n    for (i = 0; i < POINTER_RINGS; i++) {\n      for (j = 0; j < POINTER_SEGMENTS - 1; j++) {\n        indices.push(i * POINTER_SEGMENTS + j, i * POINTER_SEGMENTS + j + 1, (i + 1) * POINTER_SEGMENTS + j)\n        indices.push(i * POINTER_SEGMENTS + j + 1, (i + 1) * POINTER_SEGMENTS + j + 1, (i + 1) * POINTER_SEGMENTS + j)\n      }\n\n      indices.push((i + 1) * POINTER_SEGMENTS - 1, i * POINTER_SEGMENTS, (i + 2) * POINTER_SEGMENTS - 1)\n      indices.push(i * POINTER_SEGMENTS, (i + 1) * POINTER_SEGMENTS, (i + 2) * POINTER_SEGMENTS - 1)\n    }\n\n    // construct front and rear face\n    const frontCenterIndex = POINTER_SEGMENTS * (1 + POINTER_RINGS)\n    const rearCenterIndex = POINTER_SEGMENTS * (1 + POINTER_RINGS) + 1\n\n    for (i = 0; i < POINTER_SEGMENTS - 1; i++) {\n      indices.push(frontCenterIndex, i + 1, i)\n      indices.push(rearCenterIndex, i + POINTER_SEGMENTS * POINTER_RINGS, i + POINTER_SEGMENTS * POINTER_RINGS + 1)\n    }\n\n    indices.push(frontCenterIndex, 0, POINTER_SEGMENTS - 1)\n    indices.push(rearCenterIndex, POINTER_SEGMENTS * (POINTER_RINGS + 1) - 1, POINTER_SEGMENTS * POINTER_RINGS)\n\n    const material = new THREE.MeshBasicMaterial()\n    material.transparent = true\n    material.opacity = POINTER_OPACITY_MIN\n\n    this.pointerGeometry.setIndex(indices)\n\n    this.pointerMesh = new THREE.Mesh(this.pointerGeometry, material)\n\n    this.pointerMesh.position.set(0, 0, -1 * POINTER_REAR_RADIUS)\n    this.pointerObject = new THREE.Object3D()\n    this.pointerObject.add(this.pointerMesh)\n\n    this.raycaster = new THREE.Raycaster()\n\n    // create cursor\n    const cursorGeometry = new THREE.SphereGeometry(CURSOR_RADIUS, 10, 10)\n    const cursorMaterial = new THREE.MeshBasicMaterial()\n    cursorMaterial.transparent = true\n    cursorMaterial.opacity = POINTER_OPACITY_MIN\n\n    this.cursorObject = new THREE.Mesh(cursorGeometry, cursorMaterial)\n    this.pointerObject.add(this.cursorObject)\n\n    this.add(this.pointerObject)\n  }\n\n  _updateRaycaster() {\n    if (this.raycaster) {\n      const pointerMatrix = this.pointerObject.matrixWorld\n      const tempMatrix = new THREE.Matrix4()\n      tempMatrix.identity().extractRotation(pointerMatrix)\n      this.raycaster.ray.origin.setFromMatrixPosition(pointerMatrix)\n      this.raycaster.ray.direction.set(0, 0, -1).applyMatrix4(tempMatrix)\n    }\n  }\n\n  _updatePointer() {\n    this.pointerObject.visible = this.controller.visible\n    const indexTip = this.hand.joints['index-finger-tip']\n    const thumbTip = this.hand.joints['thumb-tip']\n    const distance = indexTip.position.distanceTo(thumbTip.position)\n    const position = indexTip.position.clone().add(thumbTip.position).multiplyScalar(0.5)\n    this.pointerObject.position.copy(position)\n    this.pointerObject.quaternion.copy(this.controller.quaternion)\n\n    this.pinched = distance <= PINCH_THRESHOLD\n\n    const pinchScale = (distance - PINCH_MIN) / (PINCH_MAX - PINCH_MIN)\n    const focusScale = (distance - PINCH_MIN) / (PINCH_THRESHOLD - PINCH_MIN)\n    if (pinchScale > 1) {\n      this._updatePointerVertices(POINTER_REAR_RADIUS)\n      this.pointerMesh.position.set(0, 0, -1 * POINTER_REAR_RADIUS)\n      this.pointerMesh.material.opacity = POINTER_OPACITY_MIN\n    } else if (pinchScale > 0) {\n      const rearRadius = (POINTER_REAR_RADIUS - POINTER_REAR_RADIUS_MIN) * pinchScale + POINTER_REAR_RADIUS_MIN\n      this._updatePointerVertices(rearRadius)\n      if (focusScale < 1) {\n        this.pointerMesh.position.set(0, 0, -1 * rearRadius - (1 - focusScale) * POINTER_ADVANCE_MAX)\n        this.pointerMesh.material.opacity =\n          POINTER_OPACITY_MIN + (1 - focusScale) * (POINTER_OPACITY_MAX - POINTER_OPACITY_MIN)\n      } else {\n        this.pointerMesh.position.set(0, 0, -1 * rearRadius)\n        this.pointerMesh.material.opacity = POINTER_OPACITY_MIN\n      }\n    } else {\n      this._updatePointerVertices(POINTER_REAR_RADIUS_MIN)\n      this.pointerMesh.position.set(0, 0, -1 * POINTER_REAR_RADIUS_MIN - POINTER_ADVANCE_MAX)\n      this.pointerMesh.material.opacity = POINTER_OPACITY_MAX\n    }\n\n    this.cursorObject.material.opacity = this.pointerMesh.material.opacity\n  }\n\n  updateMatrixWorld(force) {\n    super.updateMatrixWorld(force)\n    if (this.pointerGeometry) {\n      this._updatePointer()\n      this._updateRaycaster()\n    }\n  }\n\n  isPinched() {\n    return this.pinched\n  }\n\n  setAttached(attached) {\n    this.attached = attached\n  }\n\n  isAttached() {\n    return this.attached\n  }\n\n  intersectObject(object, recursive = true) {\n    if (this.raycaster) {\n      return this.raycaster.intersectObject(object, recursive)\n    }\n  }\n\n  intersectObjects(objects, recursive = true) {\n    if (this.raycaster) {\n      return this.raycaster.intersectObjects(objects, recursive)\n    }\n  }\n\n  checkIntersections(objects, recursive = false) {\n    if (this.raycaster && !this.attached) {\n      const intersections = this.raycaster.intersectObjects(objects, recursive)\n      const direction = new THREE.Vector3(0, 0, -1)\n      if (intersections.length > 0) {\n        const intersection = intersections[0]\n        const distance = intersection.distance\n        this.cursorObject.position.copy(direction.multiplyScalar(distance))\n      } else {\n        this.cursorObject.position.copy(direction.multiplyScalar(CURSOR_MAX_DISTANCE))\n      }\n    }\n  }\n\n  setCursor(distance) {\n    const direction = new THREE.Vector3(0, 0, -1)\n    if (this.raycaster && !this.attached) {\n      this.cursorObject.position.copy(direction.multiplyScalar(distance))\n    }\n  }\n\n  dispose() {\n    this._onDisconnected()\n    this.hand.removeEventListener('connected', this._onConnected)\n    this.hand.removeEventListener('disconnected', this._onDisconnected)\n  }\n}\n\nexport { OculusHandPointerModel }\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}