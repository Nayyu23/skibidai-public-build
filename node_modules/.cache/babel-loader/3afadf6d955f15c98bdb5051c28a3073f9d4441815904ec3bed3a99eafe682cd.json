{"ast":null,"code":"import _toConsumableArray from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _classCallCheck from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport { BufferAttribute, BufferGeometry, Vector3, Vector4, Matrix4, Matrix3 } from 'three';\nvar _positionVector = /*@__PURE__*/new Vector3();\nvar _normalVector = /*@__PURE__*/new Vector3();\nvar _tangentVector = /*@__PURE__*/new Vector3();\nvar _tangentVector4 = /*@__PURE__*/new Vector4();\nvar _morphVector = /*@__PURE__*/new Vector3();\nvar _temp = /*@__PURE__*/new Vector3();\nvar _skinIndex = /*@__PURE__*/new Vector4();\nvar _skinWeight = /*@__PURE__*/new Vector4();\nvar _matrix = /*@__PURE__*/new Matrix4();\nvar _boneMatrix = /*@__PURE__*/new Matrix4();\n\n// Confirms that the two provided attributes are compatible\nfunction validateAttributes(attr1, attr2) {\n  if (!attr1 && !attr2) {\n    return;\n  }\n  var sameCount = attr1.count === attr2.count;\n  var sameNormalized = attr1.normalized === attr2.normalized;\n  var sameType = attr1.array.constructor === attr2.array.constructor;\n  var sameItemSize = attr1.itemSize === attr2.itemSize;\n  if (!sameCount || !sameNormalized || !sameType || !sameItemSize) {\n    throw new Error();\n  }\n}\n\n// Clones the given attribute with a new compatible buffer attribute but no data\nfunction createAttributeClone(attr) {\n  var countOverride = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  var cons = attr.array.constructor;\n  var normalized = attr.normalized;\n  var itemSize = attr.itemSize;\n  var count = countOverride === null ? attr.count : countOverride;\n  return new BufferAttribute(new cons(itemSize * count), itemSize, normalized);\n}\n\n// target offset is the number of elements in the target buffer stride to skip before copying the\n// attributes contents in to.\nfunction copyAttributeContents(attr, target) {\n  var targetOffset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  if (attr.isInterleavedBufferAttribute) {\n    var itemSize = attr.itemSize;\n    for (var i = 0, l = attr.count; i < l; i++) {\n      var io = i + targetOffset;\n      target.setX(io, attr.getX(i));\n      if (itemSize >= 2) target.setY(io, attr.getY(i));\n      if (itemSize >= 3) target.setZ(io, attr.getZ(i));\n      if (itemSize >= 4) target.setW(io, attr.getW(i));\n    }\n  } else {\n    var array = target.array;\n    var cons = array.constructor;\n    var byteOffset = array.BYTES_PER_ELEMENT * attr.itemSize * targetOffset;\n    var temp = new cons(array.buffer, byteOffset, attr.array.length);\n    temp.set(attr.array);\n  }\n}\n\n// Adds the \"matrix\" multiplied by \"scale\" to \"target\"\nfunction addScaledMatrix(target, matrix, scale) {\n  var targetArray = target.elements;\n  var matrixArray = matrix.elements;\n  for (var i = 0, l = matrixArray.length; i < l; i++) {\n    targetArray[i] += matrixArray[i] * scale;\n  }\n}\n\n// A version of \"SkinnedMesh.boneTransform\" for normals\nfunction boneNormalTransform(mesh, index, target) {\n  var skeleton = mesh.skeleton;\n  var geometry = mesh.geometry;\n  var bones = skeleton.bones;\n  var boneInverses = skeleton.boneInverses;\n  _skinIndex.fromBufferAttribute(geometry.attributes.skinIndex, index);\n  _skinWeight.fromBufferAttribute(geometry.attributes.skinWeight, index);\n  _matrix.elements.fill(0);\n  for (var i = 0; i < 4; i++) {\n    var weight = _skinWeight.getComponent(i);\n    if (weight !== 0) {\n      var boneIndex = _skinIndex.getComponent(i);\n      _boneMatrix.multiplyMatrices(bones[boneIndex].matrixWorld, boneInverses[boneIndex]);\n      addScaledMatrix(_matrix, _boneMatrix, weight);\n    }\n  }\n  _matrix.multiply(mesh.bindMatrix).premultiply(mesh.bindMatrixInverse);\n  target.transformDirection(_matrix);\n  return target;\n}\n\n// Applies the morph target data to the target vector\nfunction applyMorphTarget(morphData, morphInfluences, morphTargetsRelative, i, target) {\n  _morphVector.set(0, 0, 0);\n  for (var j = 0, jl = morphData.length; j < jl; j++) {\n    var influence = morphInfluences[j];\n    var morphAttribute = morphData[j];\n    if (influence === 0) continue;\n    _temp.fromBufferAttribute(morphAttribute, i);\n    if (morphTargetsRelative) {\n      _morphVector.addScaledVector(_temp, influence);\n    } else {\n      _morphVector.addScaledVector(_temp.sub(target), influence);\n    }\n  }\n  target.add(_morphVector);\n}\n\n// Modified version of BufferGeometryUtils.mergeBufferGeometries that ignores morph targets and updates a attributes in place\nfunction mergeBufferGeometries(geometries) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n    useGroups: false,\n    updateIndex: false,\n    skipAttributes: []\n  };\n  var targetGeometry = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new BufferGeometry();\n  var isIndexed = geometries[0].index !== null;\n  var _options$useGroups = options.useGroups,\n    useGroups = _options$useGroups === void 0 ? false : _options$useGroups,\n    _options$updateIndex = options.updateIndex,\n    updateIndex = _options$updateIndex === void 0 ? false : _options$updateIndex,\n    _options$skipAttribut = options.skipAttributes,\n    skipAttributes = _options$skipAttribut === void 0 ? [] : _options$skipAttribut;\n  var attributesUsed = new Set(Object.keys(geometries[0].attributes));\n  var attributes = {};\n  var offset = 0;\n  targetGeometry.clearGroups();\n  for (var i = 0; i < geometries.length; ++i) {\n    var geometry = geometries[i];\n    var attributesCount = 0;\n\n    // ensure that all geometries are indexed, or none\n    if (isIndexed !== (geometry.index !== null)) {\n      throw new Error('StaticGeometryGenerator: All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them.');\n    }\n\n    // gather attributes, exit early if they're different\n    for (var name in geometry.attributes) {\n      if (!attributesUsed.has(name)) {\n        throw new Error('StaticGeometryGenerator: All geometries must have compatible attributes; make sure \"' + name + '\" attribute exists among all geometries, or in none of them.');\n      }\n      if (attributes[name] === undefined) {\n        attributes[name] = [];\n      }\n      attributes[name].push(geometry.attributes[name]);\n      attributesCount++;\n    }\n\n    // ensure geometries have the same number of attributes\n    if (attributesCount !== attributesUsed.size) {\n      throw new Error('StaticGeometryGenerator: Make sure all geometries have the same number of attributes.');\n    }\n    if (useGroups) {\n      var count = void 0;\n      if (isIndexed) {\n        count = geometry.index.count;\n      } else if (geometry.attributes.position !== undefined) {\n        count = geometry.attributes.position.count;\n      } else {\n        throw new Error('StaticGeometryGenerator: The geometry must have either an index or a position attribute');\n      }\n      targetGeometry.addGroup(offset, count, i);\n      offset += count;\n    }\n  }\n\n  // merge indices\n  if (isIndexed) {\n    var forceUpdateIndex = false;\n    if (!targetGeometry.index) {\n      var indexCount = 0;\n      for (var _i = 0; _i < geometries.length; ++_i) {\n        indexCount += geometries[_i].index.count;\n      }\n      targetGeometry.setIndex(new BufferAttribute(new Uint32Array(indexCount), 1, false));\n      forceUpdateIndex = true;\n    }\n    if (updateIndex || forceUpdateIndex) {\n      var targetIndex = targetGeometry.index;\n      var targetOffset = 0;\n      var indexOffset = 0;\n      for (var _i2 = 0; _i2 < geometries.length; ++_i2) {\n        var _geometry = geometries[_i2];\n        var index = _geometry.index;\n        if (skipAttributes[_i2] !== true) {\n          for (var j = 0; j < index.count; ++j) {\n            targetIndex.setX(targetOffset, index.getX(j) + indexOffset);\n            targetOffset++;\n          }\n        }\n        indexOffset += _geometry.attributes.position.count;\n      }\n    }\n  }\n\n  // merge attributes\n  for (var _name in attributes) {\n    var attrList = attributes[_name];\n    if (!(_name in targetGeometry.attributes)) {\n      var _count = 0;\n      for (var key in attrList) {\n        _count += attrList[key].count;\n      }\n      targetGeometry.setAttribute(_name, createAttributeClone(attributes[_name][0], _count));\n    }\n    var targetAttribute = targetGeometry.attributes[_name];\n    var _offset = 0;\n    for (var _i3 = 0, l = attrList.length; _i3 < l; _i3++) {\n      var attr = attrList[_i3];\n      if (skipAttributes[_i3] !== true) {\n        copyAttributeContents(attr, targetAttribute, _offset);\n      }\n      _offset += attr.count;\n    }\n  }\n  return targetGeometry;\n}\nfunction checkTypedArrayEquality(a, b) {\n  if (a === null || b === null) {\n    return a === b;\n  }\n  if (a.length !== b.length) {\n    return false;\n  }\n  for (var i = 0, l = a.length; i < l; i++) {\n    if (a[i] !== b[i]) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction invertGeometry(geometry) {\n  var index = geometry.index,\n    attributes = geometry.attributes;\n  if (index) {\n    for (var i = 0, l = index.count; i < l; i += 3) {\n      var v0 = index.getX(i);\n      var v2 = index.getX(i + 2);\n      index.setX(i, v2);\n      index.setX(i + 2, v0);\n    }\n  } else {\n    for (var key in attributes) {\n      var attr = attributes[key];\n      var itemSize = attr.itemSize;\n      for (var _i4 = 0, _l = attr.count; _i4 < _l; _i4 += 3) {\n        for (var j = 0; j < itemSize; j++) {\n          var _v = attr.getComponent(_i4, j);\n          var _v2 = attr.getComponent(_i4 + 2, j);\n          attr.setComponent(_i4, j, _v2);\n          attr.setComponent(_i4 + 2, j, _v);\n        }\n      }\n    }\n  }\n  return geometry;\n}\n\n// Checks whether the geometry changed between this and last evaluation\nvar GeometryDiff = /*#__PURE__*/function () {\n  function GeometryDiff(mesh) {\n    _classCallCheck(this, GeometryDiff);\n    this.matrixWorld = new Matrix4();\n    this.geometryHash = null;\n    this.boneMatrices = null;\n    this.primitiveCount = -1;\n    this.mesh = mesh;\n    this.update();\n  }\n  _createClass(GeometryDiff, [{\n    key: \"update\",\n    value: function update() {\n      var mesh = this.mesh;\n      var geometry = mesh.geometry;\n      var skeleton = mesh.skeleton;\n      var primitiveCount = (geometry.index ? geometry.index.count : geometry.attributes.position.count) / 3;\n      this.matrixWorld.copy(mesh.matrixWorld);\n      this.geometryHash = geometry.attributes.position.version;\n      this.primitiveCount = primitiveCount;\n      if (skeleton) {\n        // ensure the bone matrix array is updated to the appropriate length\n        if (!skeleton.boneTexture) {\n          skeleton.computeBoneTexture();\n        }\n        skeleton.update();\n\n        // copy data if possible otherwise clone it\n        var boneMatrices = skeleton.boneMatrices;\n        if (!this.boneMatrices || this.boneMatrices.length !== boneMatrices.length) {\n          this.boneMatrices = boneMatrices.slice();\n        } else {\n          this.boneMatrices.set(boneMatrices);\n        }\n      } else {\n        this.boneMatrices = null;\n      }\n    }\n  }, {\n    key: \"didChange\",\n    value: function didChange() {\n      var mesh = this.mesh;\n      var geometry = mesh.geometry;\n      var primitiveCount = (geometry.index ? geometry.index.count : geometry.attributes.position.count) / 3;\n      var identical = this.matrixWorld.equals(mesh.matrixWorld) && this.geometryHash === geometry.attributes.position.version && checkTypedArrayEquality(mesh.skeleton && mesh.skeleton.boneMatrices || null, this.boneMatrices) && this.primitiveCount === primitiveCount;\n      return !identical;\n    }\n  }]);\n  return GeometryDiff;\n}();\nexport var StaticGeometryGenerator = /*#__PURE__*/function () {\n  function StaticGeometryGenerator(meshes) {\n    _classCallCheck(this, StaticGeometryGenerator);\n    if (!Array.isArray(meshes)) {\n      meshes = [meshes];\n    }\n    var finalMeshes = [];\n    meshes.forEach(function (object) {\n      object.traverseVisible(function (c) {\n        if (c.isMesh) {\n          finalMeshes.push(c);\n        }\n      });\n    });\n    this.meshes = finalMeshes;\n    this.useGroups = true;\n    this.applyWorldTransforms = true;\n    this.attributes = ['position', 'normal', 'color', 'tangent', 'uv', 'uv2'];\n    this._intermediateGeometry = new Array(finalMeshes.length).fill().map(function () {\n      return new BufferGeometry();\n    });\n    this._diffMap = new WeakMap();\n  }\n  _createClass(StaticGeometryGenerator, [{\n    key: \"getMaterials\",\n    value: function getMaterials() {\n      var materials = [];\n      this.meshes.forEach(function (mesh) {\n        if (Array.isArray(mesh.material)) {\n          materials.push.apply(materials, _toConsumableArray(mesh.material));\n        } else {\n          materials.push(mesh.material);\n        }\n      });\n      return materials;\n    }\n  }, {\n    key: \"generate\",\n    value: function generate() {\n      var targetGeometry = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new BufferGeometry();\n      // track which attributes have been updated and which to skip to avoid unnecessary attribute copies\n      var skipAttributes = [];\n      var meshes = this.meshes,\n        useGroups = this.useGroups,\n        _intermediateGeometry = this._intermediateGeometry,\n        _diffMap = this._diffMap;\n      for (var i = 0, l = meshes.length; i < l; i++) {\n        var mesh = meshes[i];\n        var geom = _intermediateGeometry[i];\n        var diff = _diffMap.get(mesh);\n        if (!diff || diff.didChange(mesh)) {\n          this._convertToStaticGeometry(mesh, geom);\n          skipAttributes.push(false);\n          if (!diff) {\n            _diffMap.set(mesh, new GeometryDiff(mesh));\n          } else {\n            diff.update();\n          }\n        } else {\n          skipAttributes.push(true);\n        }\n      }\n      if (_intermediateGeometry.length === 0) {\n        // if there are no geometries then just create a fake empty geometry to provide\n        targetGeometry.setIndex(null);\n\n        // remove all geometry\n        var attrs = targetGeometry.attributes;\n        for (var key in attrs) {\n          targetGeometry.deleteAttribute(key);\n        }\n\n        // create dummy attributes\n        for (var _key in this.attributes) {\n          targetGeometry.setAttribute(this.attributes[_key], new BufferAttribute(new Float32Array(0), 4, false));\n        }\n      } else {\n        mergeBufferGeometries(_intermediateGeometry, {\n          useGroups: useGroups,\n          skipAttributes: skipAttributes\n        }, targetGeometry);\n      }\n      for (var _key2 in targetGeometry.attributes) {\n        targetGeometry.attributes[_key2].needsUpdate = true;\n      }\n      return targetGeometry;\n    }\n  }, {\n    key: \"_convertToStaticGeometry\",\n    value: function _convertToStaticGeometry(mesh) {\n      var targetGeometry = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new BufferGeometry();\n      var geometry = mesh.geometry;\n      var applyWorldTransforms = this.applyWorldTransforms;\n      var includeNormal = this.attributes.includes('normal');\n      var includeTangent = this.attributes.includes('tangent');\n      var attributes = geometry.attributes;\n      var targetAttributes = targetGeometry.attributes;\n\n      // initialize the attributes if they don't exist\n      if (!targetGeometry.index && geometry.index) {\n        targetGeometry.index = geometry.index.clone();\n      }\n      if (!targetAttributes.position) {\n        targetGeometry.setAttribute('position', createAttributeClone(attributes.position));\n      }\n      if (includeNormal && !targetAttributes.normal && attributes.normal) {\n        targetGeometry.setAttribute('normal', createAttributeClone(attributes.normal));\n      }\n      if (includeTangent && !targetAttributes.tangent && attributes.tangent) {\n        targetGeometry.setAttribute('tangent', createAttributeClone(attributes.tangent));\n      }\n\n      // ensure the attributes are consistent\n      validateAttributes(geometry.index, targetGeometry.index);\n      validateAttributes(attributes.position, targetAttributes.position);\n      if (includeNormal) {\n        validateAttributes(attributes.normal, targetAttributes.normal);\n      }\n      if (includeTangent) {\n        validateAttributes(attributes.tangent, targetAttributes.tangent);\n      }\n\n      // generate transformed vertex attribute data\n      var position = attributes.position;\n      var normal = includeNormal ? attributes.normal : null;\n      var tangent = includeTangent ? attributes.tangent : null;\n      var morphPosition = geometry.morphAttributes.position;\n      var morphNormal = geometry.morphAttributes.normal;\n      var morphTangent = geometry.morphAttributes.tangent;\n      var morphTargetsRelative = geometry.morphTargetsRelative;\n      var morphInfluences = mesh.morphTargetInfluences;\n      var normalMatrix = new Matrix3();\n      normalMatrix.getNormalMatrix(mesh.matrixWorld);\n\n      // copy the index\n      if (geometry.index) {\n        targetGeometry.index.array.set(geometry.index.array);\n      }\n\n      // copy and apply other attributes\n      for (var i = 0, l = attributes.position.count; i < l; i++) {\n        _positionVector.fromBufferAttribute(position, i);\n        if (normal) {\n          _normalVector.fromBufferAttribute(normal, i);\n        }\n        if (tangent) {\n          _tangentVector4.fromBufferAttribute(tangent, i);\n          _tangentVector.fromBufferAttribute(tangent, i);\n        }\n\n        // apply morph target transform\n        if (morphInfluences) {\n          if (morphPosition) {\n            applyMorphTarget(morphPosition, morphInfluences, morphTargetsRelative, i, _positionVector);\n          }\n          if (morphNormal) {\n            applyMorphTarget(morphNormal, morphInfluences, morphTargetsRelative, i, _normalVector);\n          }\n          if (morphTangent) {\n            applyMorphTarget(morphTangent, morphInfluences, morphTargetsRelative, i, _tangentVector);\n          }\n        }\n\n        // apply bone transform\n        if (mesh.isSkinnedMesh) {\n          mesh.applyBoneTransform(i, _positionVector);\n          if (normal) {\n            boneNormalTransform(mesh, i, _normalVector);\n          }\n          if (tangent) {\n            boneNormalTransform(mesh, i, _tangentVector);\n          }\n        }\n\n        // update the vectors of the attributes\n        if (applyWorldTransforms) {\n          _positionVector.applyMatrix4(mesh.matrixWorld);\n        }\n        targetAttributes.position.setXYZ(i, _positionVector.x, _positionVector.y, _positionVector.z);\n        if (normal) {\n          if (applyWorldTransforms) {\n            _normalVector.applyNormalMatrix(normalMatrix);\n          }\n          targetAttributes.normal.setXYZ(i, _normalVector.x, _normalVector.y, _normalVector.z);\n        }\n        if (tangent) {\n          if (applyWorldTransforms) {\n            _tangentVector.transformDirection(mesh.matrixWorld);\n          }\n          targetAttributes.tangent.setXYZW(i, _tangentVector.x, _tangentVector.y, _tangentVector.z, _tangentVector4.w);\n        }\n      }\n\n      // copy other attributes over\n      for (var _i5 in this.attributes) {\n        var key = this.attributes[_i5];\n        if (key === 'position' || key === 'tangent' || key === 'normal' || !(key in attributes)) {\n          continue;\n        }\n        if (!targetAttributes[key]) {\n          targetGeometry.setAttribute(key, createAttributeClone(attributes[key]));\n        }\n        validateAttributes(attributes[key], targetAttributes[key]);\n        copyAttributeContents(attributes[key], targetAttributes[key]);\n      }\n      if (mesh.matrixWorld.determinant() < 0) {\n        invertGeometry(targetGeometry);\n      }\n      return targetGeometry;\n    }\n  }]);\n  return StaticGeometryGenerator;\n}();","map":{"version":3,"names":["BufferAttribute","BufferGeometry","Vector3","Vector4","Matrix4","Matrix3","_positionVector","_normalVector","_tangentVector","_tangentVector4","_morphVector","_temp","_skinIndex","_skinWeight","_matrix","_boneMatrix","validateAttributes","attr1","attr2","sameCount","count","sameNormalized","normalized","sameType","array","constructor","sameItemSize","itemSize","Error","createAttributeClone","attr","countOverride","arguments","length","undefined","cons","copyAttributeContents","target","targetOffset","isInterleavedBufferAttribute","i","l","io","setX","getX","setY","getY","setZ","getZ","setW","getW","byteOffset","BYTES_PER_ELEMENT","temp","buffer","set","addScaledMatrix","matrix","scale","targetArray","elements","matrixArray","boneNormalTransform","mesh","index","skeleton","geometry","bones","boneInverses","fromBufferAttribute","attributes","skinIndex","skinWeight","fill","weight","getComponent","boneIndex","multiplyMatrices","matrixWorld","multiply","bindMatrix","premultiply","bindMatrixInverse","transformDirection","applyMorphTarget","morphData","morphInfluences","morphTargetsRelative","j","jl","influence","morphAttribute","addScaledVector","sub","add","mergeBufferGeometries","geometries","options","useGroups","updateIndex","skipAttributes","targetGeometry","isIndexed","_options$useGroups","_options$updateIndex","_options$skipAttribut","attributesUsed","Set","Object","keys","offset","clearGroups","attributesCount","name","has","push","size","position","addGroup","forceUpdateIndex","indexCount","setIndex","Uint32Array","targetIndex","indexOffset","attrList","key","setAttribute","targetAttribute","checkTypedArrayEquality","a","b","invertGeometry","v0","v2","setComponent","GeometryDiff","_classCallCheck","geometryHash","boneMatrices","primitiveCount","update","_createClass","value","copy","version","boneTexture","computeBoneTexture","slice","didChange","identical","equals","StaticGeometryGenerator","meshes","Array","isArray","finalMeshes","forEach","object","traverseVisible","c","isMesh","applyWorldTransforms","_intermediateGeometry","map","_diffMap","WeakMap","getMaterials","materials","material","apply","_toConsumableArray","generate","geom","diff","get","_convertToStaticGeometry","attrs","deleteAttribute","Float32Array","needsUpdate","includeNormal","includes","includeTangent","targetAttributes","clone","normal","tangent","morphPosition","morphAttributes","morphNormal","morphTangent","morphTargetInfluences","normalMatrix","getNormalMatrix","isSkinnedMesh","applyBoneTransform","applyMatrix4","setXYZ","x","y","z","applyNormalMatrix","setXYZW","w","determinant"],"sources":["C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/three-mesh-bvh/src/utils/StaticGeometryGenerator.js"],"sourcesContent":["import { BufferAttribute, BufferGeometry, Vector3, Vector4, Matrix4, Matrix3 } from 'three';\n\nconst _positionVector = /*@__PURE__*/ new Vector3();\nconst _normalVector = /*@__PURE__*/ new Vector3();\nconst _tangentVector = /*@__PURE__*/ new Vector3();\nconst _tangentVector4 = /*@__PURE__*/ new Vector4();\n\nconst _morphVector = /*@__PURE__*/ new Vector3();\nconst _temp = /*@__PURE__*/ new Vector3();\n\nconst _skinIndex = /*@__PURE__*/ new Vector4();\nconst _skinWeight = /*@__PURE__*/ new Vector4();\nconst _matrix = /*@__PURE__*/ new Matrix4();\nconst _boneMatrix = /*@__PURE__*/ new Matrix4();\n\n// Confirms that the two provided attributes are compatible\nfunction validateAttributes( attr1, attr2 ) {\n\n\tif ( ! attr1 && ! attr2 ) {\n\n\t\treturn;\n\n\t}\n\n\tconst sameCount = attr1.count === attr2.count;\n\tconst sameNormalized = attr1.normalized === attr2.normalized;\n\tconst sameType = attr1.array.constructor === attr2.array.constructor;\n\tconst sameItemSize = attr1.itemSize === attr2.itemSize;\n\n\tif ( ! sameCount || ! sameNormalized || ! sameType || ! sameItemSize ) {\n\n\t\tthrow new Error();\n\n\t}\n\n}\n\n// Clones the given attribute with a new compatible buffer attribute but no data\nfunction createAttributeClone( attr, countOverride = null ) {\n\n\tconst cons = attr.array.constructor;\n\tconst normalized = attr.normalized;\n\tconst itemSize = attr.itemSize;\n\tconst count = countOverride === null ? attr.count : countOverride;\n\n\treturn new BufferAttribute( new cons( itemSize * count ), itemSize, normalized );\n\n}\n\n// target offset is the number of elements in the target buffer stride to skip before copying the\n// attributes contents in to.\nfunction copyAttributeContents( attr, target, targetOffset = 0 ) {\n\n\tif ( attr.isInterleavedBufferAttribute ) {\n\n\t\tconst itemSize = attr.itemSize;\n\t\tfor ( let i = 0, l = attr.count; i < l; i ++ ) {\n\n\t\t\tconst io = i + targetOffset;\n\t\t\ttarget.setX( io, attr.getX( i ) );\n\t\t\tif ( itemSize >= 2 ) target.setY( io, attr.getY( i ) );\n\t\t\tif ( itemSize >= 3 ) target.setZ( io, attr.getZ( i ) );\n\t\t\tif ( itemSize >= 4 ) target.setW( io, attr.getW( i ) );\n\n\t\t}\n\n\t} else {\n\n\t\tconst array = target.array;\n\t\tconst cons = array.constructor;\n\t\tconst byteOffset = array.BYTES_PER_ELEMENT * attr.itemSize * targetOffset;\n\t\tconst temp = new cons( array.buffer, byteOffset, attr.array.length );\n\t\ttemp.set( attr.array );\n\n\t}\n\n}\n\n// Adds the \"matrix\" multiplied by \"scale\" to \"target\"\nfunction addScaledMatrix( target, matrix, scale ) {\n\n\tconst targetArray = target.elements;\n\tconst matrixArray = matrix.elements;\n\tfor ( let i = 0, l = matrixArray.length; i < l; i ++ ) {\n\n\t\ttargetArray[ i ] += matrixArray[ i ] * scale;\n\n\t}\n\n}\n\n// A version of \"SkinnedMesh.boneTransform\" for normals\nfunction boneNormalTransform( mesh, index, target ) {\n\n\tconst skeleton = mesh.skeleton;\n\tconst geometry = mesh.geometry;\n\tconst bones = skeleton.bones;\n\tconst boneInverses = skeleton.boneInverses;\n\n\t_skinIndex.fromBufferAttribute( geometry.attributes.skinIndex, index );\n\t_skinWeight.fromBufferAttribute( geometry.attributes.skinWeight, index );\n\n\t_matrix.elements.fill( 0 );\n\n\tfor ( let i = 0; i < 4; i ++ ) {\n\n\t\tconst weight = _skinWeight.getComponent( i );\n\n\t\tif ( weight !== 0 ) {\n\n\t\t\tconst boneIndex = _skinIndex.getComponent( i );\n\t\t\t_boneMatrix.multiplyMatrices( bones[ boneIndex ].matrixWorld, boneInverses[ boneIndex ] );\n\n\t\t\taddScaledMatrix( _matrix, _boneMatrix, weight );\n\n\t\t}\n\n\t}\n\n\t_matrix.multiply( mesh.bindMatrix ).premultiply( mesh.bindMatrixInverse );\n\ttarget.transformDirection( _matrix );\n\n\treturn target;\n\n}\n\n// Applies the morph target data to the target vector\nfunction applyMorphTarget( morphData, morphInfluences, morphTargetsRelative, i, target ) {\n\n\t_morphVector.set( 0, 0, 0 );\n\tfor ( let j = 0, jl = morphData.length; j < jl; j ++ ) {\n\n\t\tconst influence = morphInfluences[ j ];\n\t\tconst morphAttribute = morphData[ j ];\n\n\t\tif ( influence === 0 ) continue;\n\n\t\t_temp.fromBufferAttribute( morphAttribute, i );\n\n\t\tif ( morphTargetsRelative ) {\n\n\t\t\t_morphVector.addScaledVector( _temp, influence );\n\n\t\t} else {\n\n\t\t\t_morphVector.addScaledVector( _temp.sub( target ), influence );\n\n\t\t}\n\n\t}\n\n\ttarget.add( _morphVector );\n\n}\n\n// Modified version of BufferGeometryUtils.mergeBufferGeometries that ignores morph targets and updates a attributes in place\nfunction mergeBufferGeometries( geometries, options = { useGroups: false, updateIndex: false, skipAttributes: [] }, targetGeometry = new BufferGeometry() ) {\n\n\tconst isIndexed = geometries[ 0 ].index !== null;\n\tconst { useGroups = false, updateIndex = false, skipAttributes = [] } = options;\n\n\tconst attributesUsed = new Set( Object.keys( geometries[ 0 ].attributes ) );\n\tconst attributes = {};\n\n\tlet offset = 0;\n\n\ttargetGeometry.clearGroups();\n\tfor ( let i = 0; i < geometries.length; ++ i ) {\n\n\t\tconst geometry = geometries[ i ];\n\t\tlet attributesCount = 0;\n\n\t\t// ensure that all geometries are indexed, or none\n\t\tif ( isIndexed !== ( geometry.index !== null ) ) {\n\n\t\t\tthrow new Error( 'StaticGeometryGenerator: All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them.' );\n\n\t\t}\n\n\t\t// gather attributes, exit early if they're different\n\t\tfor ( const name in geometry.attributes ) {\n\n\t\t\tif ( ! attributesUsed.has( name ) ) {\n\n\t\t\t\tthrow new Error( 'StaticGeometryGenerator: All geometries must have compatible attributes; make sure \"' + name + '\" attribute exists among all geometries, or in none of them.' );\n\n\t\t\t}\n\n\t\t\tif ( attributes[ name ] === undefined ) {\n\n\t\t\t\tattributes[ name ] = [];\n\n\t\t\t}\n\n\t\t\tattributes[ name ].push( geometry.attributes[ name ] );\n\t\t\tattributesCount ++;\n\n\t\t}\n\n\t\t// ensure geometries have the same number of attributes\n\t\tif ( attributesCount !== attributesUsed.size ) {\n\n\t\t\tthrow new Error( 'StaticGeometryGenerator: Make sure all geometries have the same number of attributes.' );\n\n\t\t}\n\n\t\tif ( useGroups ) {\n\n\t\t\tlet count;\n\t\t\tif ( isIndexed ) {\n\n\t\t\t\tcount = geometry.index.count;\n\n\t\t\t} else if ( geometry.attributes.position !== undefined ) {\n\n\t\t\t\tcount = geometry.attributes.position.count;\n\n\t\t\t} else {\n\n\t\t\t\tthrow new Error( 'StaticGeometryGenerator: The geometry must have either an index or a position attribute' );\n\n\t\t\t}\n\n\t\t\ttargetGeometry.addGroup( offset, count, i );\n\t\t\toffset += count;\n\n\t\t}\n\n\t}\n\n\t// merge indices\n\tif ( isIndexed ) {\n\n\t\tlet forceUpdateIndex = false;\n\t\tif ( ! targetGeometry.index ) {\n\n\t\t\tlet indexCount = 0;\n\t\t\tfor ( let i = 0; i < geometries.length; ++ i ) {\n\n\t\t\t\tindexCount += geometries[ i ].index.count;\n\n\t\t\t}\n\n\t\t\ttargetGeometry.setIndex( new BufferAttribute( new Uint32Array( indexCount ), 1, false ) );\n\t\t\tforceUpdateIndex = true;\n\n\t\t}\n\n\t\tif ( updateIndex || forceUpdateIndex ) {\n\n\t\t\tconst targetIndex = targetGeometry.index;\n\t\t\tlet targetOffset = 0;\n\t\t\tlet indexOffset = 0;\n\t\t\tfor ( let i = 0; i < geometries.length; ++ i ) {\n\n\t\t\t\tconst geometry = geometries[ i ];\n\t\t\t\tconst index = geometry.index;\n\t\t\t\tif ( skipAttributes[ i ] !== true ) {\n\n\t\t\t\t\tfor ( let j = 0; j < index.count; ++ j ) {\n\n\t\t\t\t\t\ttargetIndex.setX( targetOffset, index.getX( j ) + indexOffset );\n\t\t\t\t\t\ttargetOffset ++;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tindexOffset += geometry.attributes.position.count;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t// merge attributes\n\tfor ( const name in attributes ) {\n\n\t\tconst attrList = attributes[ name ];\n\t\tif ( ! ( name in targetGeometry.attributes ) ) {\n\n\t\t\tlet count = 0;\n\t\t\tfor ( const key in attrList ) {\n\n\t\t\t\tcount += attrList[ key ].count;\n\n\t\t\t}\n\n\t\t\ttargetGeometry.setAttribute( name, createAttributeClone( attributes[ name ][ 0 ], count ) );\n\n\t\t}\n\n\t\tconst targetAttribute = targetGeometry.attributes[ name ];\n\t\tlet offset = 0;\n\t\tfor ( let i = 0, l = attrList.length; i < l; i ++ ) {\n\n\t\t\tconst attr = attrList[ i ];\n\t\t\tif ( skipAttributes[ i ] !== true ) {\n\n\t\t\t\tcopyAttributeContents( attr, targetAttribute, offset );\n\n\t\t\t}\n\n\t\t\toffset += attr.count;\n\n\t\t}\n\n\t}\n\n\treturn targetGeometry;\n\n}\n\nfunction checkTypedArrayEquality( a, b ) {\n\n\tif ( a === null || b === null ) {\n\n\t\treturn a === b;\n\n\t}\n\n\tif ( a.length !== b.length ) {\n\n\t\treturn false;\n\n\t}\n\n\tfor ( let i = 0, l = a.length; i < l; i ++ ) {\n\n\t\tif ( a[ i ] !== b[ i ] ) {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t}\n\n\treturn true;\n\n}\n\nfunction invertGeometry( geometry ) {\n\n\tconst { index, attributes } = geometry;\n\tif ( index ) {\n\n\t\tfor ( let i = 0, l = index.count; i < l; i += 3 ) {\n\n\t\t\tconst v0 = index.getX( i );\n\t\t\tconst v2 = index.getX( i + 2 );\n\t\t\tindex.setX( i, v2 );\n\t\t\tindex.setX( i + 2, v0 );\n\n\t\t}\n\n\t} else {\n\n\t\tfor ( const key in attributes ) {\n\n\t\t\tconst attr = attributes[ key ];\n\t\t\tconst itemSize = attr.itemSize;\n\t\t\tfor ( let i = 0, l = attr.count; i < l; i += 3 ) {\n\n\t\t\t\tfor ( let j = 0; j < itemSize; j ++ ) {\n\n\t\t\t\t\tconst v0 = attr.getComponent( i, j );\n\t\t\t\t\tconst v2 = attr.getComponent( i + 2, j );\n\t\t\t\t\tattr.setComponent( i, j, v2 );\n\t\t\t\t\tattr.setComponent( i + 2, j, v0 );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\treturn geometry;\n\n\n}\n\n// Checks whether the geometry changed between this and last evaluation\nclass GeometryDiff {\n\n\tconstructor( mesh ) {\n\n\t\tthis.matrixWorld = new Matrix4();\n\t\tthis.geometryHash = null;\n\t\tthis.boneMatrices = null;\n\t\tthis.primitiveCount = - 1;\n\t\tthis.mesh = mesh;\n\n\t\tthis.update();\n\n\t}\n\n\tupdate() {\n\n\t\tconst mesh = this.mesh;\n\t\tconst geometry = mesh.geometry;\n\t\tconst skeleton = mesh.skeleton;\n\t\tconst primitiveCount = ( geometry.index ? geometry.index.count : geometry.attributes.position.count ) / 3;\n\t\tthis.matrixWorld.copy( mesh.matrixWorld );\n\t\tthis.geometryHash = geometry.attributes.position.version;\n\t\tthis.primitiveCount = primitiveCount;\n\n\t\tif ( skeleton ) {\n\n\t\t\t// ensure the bone matrix array is updated to the appropriate length\n\t\t\tif ( ! skeleton.boneTexture ) {\n\n\t\t\t\tskeleton.computeBoneTexture();\n\n\t\t\t}\n\n\t\t\tskeleton.update();\n\n\t\t\t// copy data if possible otherwise clone it\n\t\t\tconst boneMatrices = skeleton.boneMatrices;\n\t\t\tif ( ! this.boneMatrices || this.boneMatrices.length !== boneMatrices.length ) {\n\n\t\t\t\tthis.boneMatrices = boneMatrices.slice();\n\n\t\t\t} else {\n\n\t\t\t\tthis.boneMatrices.set( boneMatrices );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tthis.boneMatrices = null;\n\n\t\t}\n\n\t}\n\n\tdidChange() {\n\n\t\tconst mesh = this.mesh;\n\t\tconst geometry = mesh.geometry;\n\t\tconst primitiveCount = ( geometry.index ? geometry.index.count : geometry.attributes.position.count ) / 3;\n\t\tconst identical =\n\t\t\tthis.matrixWorld.equals( mesh.matrixWorld ) &&\n\t\t\tthis.geometryHash === geometry.attributes.position.version &&\n\t\t\tcheckTypedArrayEquality( mesh.skeleton && mesh.skeleton.boneMatrices || null, this.boneMatrices ) &&\n\t\t\tthis.primitiveCount === primitiveCount;\n\n\t\treturn ! identical;\n\n\t}\n\n}\n\nexport class StaticGeometryGenerator {\n\n\tconstructor( meshes ) {\n\n\t\tif ( ! Array.isArray( meshes ) ) {\n\n\t\t\tmeshes = [ meshes ];\n\n\t\t}\n\n\t\tconst finalMeshes = [];\n\t\tmeshes.forEach( object => {\n\n\t\t\tobject.traverseVisible( c => {\n\n\t\t\t\tif ( c.isMesh ) {\n\n\t\t\t\t\tfinalMeshes.push( c );\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t} );\n\n\t\tthis.meshes = finalMeshes;\n\t\tthis.useGroups = true;\n\t\tthis.applyWorldTransforms = true;\n\t\tthis.attributes = [ 'position', 'normal', 'color', 'tangent', 'uv', 'uv2' ];\n\t\tthis._intermediateGeometry = new Array( finalMeshes.length ).fill().map( () => new BufferGeometry() );\n\t\tthis._diffMap = new WeakMap();\n\n\t}\n\n\tgetMaterials() {\n\n\t\tconst materials = [];\n\t\tthis.meshes.forEach( mesh => {\n\n\t\t\tif ( Array.isArray( mesh.material ) ) {\n\n\t\t\t\tmaterials.push( ...mesh.material );\n\n\t\t\t} else {\n\n\t\t\t\tmaterials.push( mesh.material );\n\n\t\t\t}\n\n\t\t} );\n\t\treturn materials;\n\n\t}\n\n\tgenerate( targetGeometry = new BufferGeometry() ) {\n\n\t\t// track which attributes have been updated and which to skip to avoid unnecessary attribute copies\n\t\tlet skipAttributes = [];\n\t\tconst { meshes, useGroups, _intermediateGeometry, _diffMap } = this;\n\t\tfor ( let i = 0, l = meshes.length; i < l; i ++ ) {\n\n\t\t\tconst mesh = meshes[ i ];\n\t\t\tconst geom = _intermediateGeometry[ i ];\n\t\t\tconst diff = _diffMap.get( mesh );\n\t\t\tif ( ! diff || diff.didChange( mesh ) ) {\n\n\t\t\t\tthis._convertToStaticGeometry( mesh, geom );\n\t\t\t\tskipAttributes.push( false );\n\n\t\t\t\tif ( ! diff ) {\n\n\t\t\t\t\t_diffMap.set( mesh, new GeometryDiff( mesh ) );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tdiff.update();\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tskipAttributes.push( true );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( _intermediateGeometry.length === 0 ) {\n\n\t\t\t// if there are no geometries then just create a fake empty geometry to provide\n\t\t\ttargetGeometry.setIndex( null );\n\n\t\t\t// remove all geometry\n\t\t\tconst attrs = targetGeometry.attributes;\n\t\t\tfor ( const key in attrs ) {\n\n\t\t\t\ttargetGeometry.deleteAttribute( key );\n\n\t\t\t}\n\n\t\t\t// create dummy attributes\n\t\t\tfor ( const key in this.attributes ) {\n\n\t\t\t\ttargetGeometry.setAttribute( this.attributes[ key ], new BufferAttribute( new Float32Array( 0 ), 4, false ) );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tmergeBufferGeometries( _intermediateGeometry, { useGroups, skipAttributes }, targetGeometry );\n\n\t\t}\n\n\t\tfor ( const key in targetGeometry.attributes ) {\n\n\t\t\ttargetGeometry.attributes[ key ].needsUpdate = true;\n\n\t\t}\n\n\t\treturn targetGeometry;\n\n\t}\n\n\t_convertToStaticGeometry( mesh, targetGeometry = new BufferGeometry() ) {\n\n\t\tconst geometry = mesh.geometry;\n\t\tconst applyWorldTransforms = this.applyWorldTransforms;\n\t\tconst includeNormal = this.attributes.includes( 'normal' );\n\t\tconst includeTangent = this.attributes.includes( 'tangent' );\n\t\tconst attributes = geometry.attributes;\n\t\tconst targetAttributes = targetGeometry.attributes;\n\n\t\t// initialize the attributes if they don't exist\n\t\tif ( ! targetGeometry.index && geometry.index ) {\n\n\t\t\ttargetGeometry.index = geometry.index.clone();\n\n\t\t}\n\n\t\tif ( ! targetAttributes.position ) {\n\n\t\t\ttargetGeometry.setAttribute( 'position', createAttributeClone( attributes.position ) );\n\n\t\t}\n\n\t\tif ( includeNormal && ! targetAttributes.normal && attributes.normal ) {\n\n\t\t\ttargetGeometry.setAttribute( 'normal', createAttributeClone( attributes.normal ) );\n\n\t\t}\n\n\t\tif ( includeTangent && ! targetAttributes.tangent && attributes.tangent ) {\n\n\t\t\ttargetGeometry.setAttribute( 'tangent', createAttributeClone( attributes.tangent ) );\n\n\t\t}\n\n\t\t// ensure the attributes are consistent\n\t\tvalidateAttributes( geometry.index, targetGeometry.index );\n\t\tvalidateAttributes( attributes.position, targetAttributes.position );\n\n\t\tif ( includeNormal ) {\n\n\t\t\tvalidateAttributes( attributes.normal, targetAttributes.normal );\n\n\t\t}\n\n\t\tif ( includeTangent ) {\n\n\t\t\tvalidateAttributes( attributes.tangent, targetAttributes.tangent );\n\n\t\t}\n\n\t\t// generate transformed vertex attribute data\n\t\tconst position = attributes.position;\n\t\tconst normal = includeNormal ? attributes.normal : null;\n\t\tconst tangent = includeTangent ? attributes.tangent : null;\n\t\tconst morphPosition = geometry.morphAttributes.position;\n\t\tconst morphNormal = geometry.morphAttributes.normal;\n\t\tconst morphTangent = geometry.morphAttributes.tangent;\n\t\tconst morphTargetsRelative = geometry.morphTargetsRelative;\n\t\tconst morphInfluences = mesh.morphTargetInfluences;\n\t\tconst normalMatrix = new Matrix3();\n\t\tnormalMatrix.getNormalMatrix( mesh.matrixWorld );\n\n\t\t// copy the index\n\t\tif ( geometry.index ) {\n\n\t\t\ttargetGeometry.index.array.set( geometry.index.array );\n\n\t\t}\n\n\t\t// copy and apply other attributes\n\t\tfor ( let i = 0, l = attributes.position.count; i < l; i ++ ) {\n\n\t\t\t_positionVector.fromBufferAttribute( position, i );\n\t\t\tif ( normal ) {\n\n\t\t\t\t_normalVector.fromBufferAttribute( normal, i );\n\n\t\t\t}\n\n\t\t\tif ( tangent ) {\n\n\t\t\t\t_tangentVector4.fromBufferAttribute( tangent, i );\n\t\t\t\t_tangentVector.fromBufferAttribute( tangent, i );\n\n\t\t\t}\n\n\t\t\t// apply morph target transform\n\t\t\tif ( morphInfluences ) {\n\n\t\t\t\tif ( morphPosition ) {\n\n\t\t\t\t\tapplyMorphTarget( morphPosition, morphInfluences, morphTargetsRelative, i, _positionVector );\n\n\t\t\t\t}\n\n\t\t\t\tif ( morphNormal ) {\n\n\t\t\t\t\tapplyMorphTarget( morphNormal, morphInfluences, morphTargetsRelative, i, _normalVector );\n\n\t\t\t\t}\n\n\t\t\t\tif ( morphTangent ) {\n\n\t\t\t\t\tapplyMorphTarget( morphTangent, morphInfluences, morphTargetsRelative, i, _tangentVector );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// apply bone transform\n\t\t\tif ( mesh.isSkinnedMesh ) {\n\n\t\t\t\tmesh.applyBoneTransform( i, _positionVector );\n\t\t\t\tif ( normal ) {\n\n\t\t\t\t\tboneNormalTransform( mesh, i, _normalVector );\n\n\t\t\t\t}\n\n\t\t\t\tif ( tangent ) {\n\n\t\t\t\t\tboneNormalTransform( mesh, i, _tangentVector );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// update the vectors of the attributes\n\t\t\tif ( applyWorldTransforms ) {\n\n\t\t\t\t_positionVector.applyMatrix4( mesh.matrixWorld );\n\n\t\t\t}\n\n\t\t\ttargetAttributes.position.setXYZ( i, _positionVector.x, _positionVector.y, _positionVector.z );\n\n\t\t\tif ( normal ) {\n\n\t\t\t\tif ( applyWorldTransforms ) {\n\n\t\t\t\t\t_normalVector.applyNormalMatrix( normalMatrix );\n\n\t\t\t\t}\n\n\t\t\t\ttargetAttributes.normal.setXYZ( i, _normalVector.x, _normalVector.y, _normalVector.z );\n\n\t\t\t}\n\n\t\t\tif ( tangent ) {\n\n\t\t\t\tif ( applyWorldTransforms ) {\n\n\t\t\t\t\t_tangentVector.transformDirection( mesh.matrixWorld );\n\n\t\t\t\t}\n\n\t\t\t\ttargetAttributes.tangent.setXYZW( i, _tangentVector.x, _tangentVector.y, _tangentVector.z, _tangentVector4.w );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// copy other attributes over\n\t\tfor ( const i in this.attributes ) {\n\n\t\t\tconst key = this.attributes[ i ];\n\t\t\tif ( key === 'position' || key === 'tangent' || key === 'normal' || ! ( key in attributes ) ) {\n\n\t\t\t\tcontinue;\n\n\t\t\t}\n\n\t\t\tif ( ! targetAttributes[ key ] ) {\n\n\t\t\t\ttargetGeometry.setAttribute( key, createAttributeClone( attributes[ key ] ) );\n\n\t\t\t}\n\n\t\t\tvalidateAttributes( attributes[ key ], targetAttributes[ key ] );\n\t\t\tcopyAttributeContents( attributes[ key ], targetAttributes[ key ] );\n\n\t\t}\n\n\t\tif ( mesh.matrixWorld.determinant() < 0 ) {\n\n\t\t\tinvertGeometry( targetGeometry );\n\n\t\t}\n\n\t\treturn targetGeometry;\n\n\t}\n\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}