{"ast":null,"code":"import _classCallCheck from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _inherits from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport { Loader, LoaderUtils, FileLoader, TextureLoader, Vector3, Quaternion, Matrix4, Skeleton, BufferGeometry, MeshLambertMaterial, BufferAttribute, Mesh, SkinnedMesh, Object3D, MeshPhongMaterial, Bone, Color } from \"three\";\nvar AssimpLoader = /*#__PURE__*/function (_Loader) {\n  _inherits(AssimpLoader, _Loader);\n  var _super = _createSuper(AssimpLoader);\n  function AssimpLoader() {\n    _classCallCheck(this, AssimpLoader);\n    return _super.apply(this, arguments);\n  }\n  _createClass(AssimpLoader, [{\n    key: \"load\",\n    value: function load(url, onLoad, onProgress, onError) {\n      var scope = this;\n      var path = scope.path === \"\" ? LoaderUtils.extractUrlBase(url) : scope.path;\n      var loader = new FileLoader(scope.manager);\n      loader.setPath(scope.path);\n      loader.setResponseType(\"arraybuffer\");\n      loader.setRequestHeader(scope.requestHeader);\n      loader.setWithCredentials(scope.withCredentials);\n      loader.load(url, function (buffer) {\n        try {\n          onLoad(scope.parse(buffer, path));\n        } catch (e) {\n          if (onError) {\n            onError(e);\n          } else {\n            console.error(e);\n          }\n          scope.manager.itemError(url);\n        }\n      }, onProgress, onError);\n    }\n  }, {\n    key: \"parse\",\n    value: function parse(buffer, path) {\n      var textureLoader = new TextureLoader(this.manager);\n      textureLoader.setPath(this.resourcePath || path).setCrossOrigin(this.crossOrigin);\n      var Virtulous = {};\n      Virtulous.KeyFrame = /*#__PURE__*/function () {\n        function _class(time, matrix) {\n          _classCallCheck(this, _class);\n          this.time = time;\n          this.matrix = matrix.clone();\n          this.position = new Vector3();\n          this.quaternion = new Quaternion();\n          this.scale = new Vector3(1, 1, 1);\n          this.matrix.decompose(this.position, this.quaternion, this.scale);\n          this.clone = function () {\n            var n = new Virtulous.KeyFrame(this.time, this.matrix);\n            return n;\n          };\n          this.lerp = function (nextKey, time2) {\n            time2 -= this.time;\n            var dist = nextKey.time - this.time;\n            var l = time2 / dist;\n            var l2 = 1 - l;\n            var keypos = this.position;\n            var keyrot = this.quaternion;\n            var key2pos = nextKey.position;\n            var key2rot = nextKey.quaternion;\n            Virtulous.KeyFrame.tempAniPos.x = keypos.x * l2 + key2pos.x * l;\n            Virtulous.KeyFrame.tempAniPos.y = keypos.y * l2 + key2pos.y * l;\n            Virtulous.KeyFrame.tempAniPos.z = keypos.z * l2 + key2pos.z * l;\n            Virtulous.KeyFrame.tempAniQuat.set(keyrot.x, keyrot.y, keyrot.z, keyrot.w);\n            Virtulous.KeyFrame.tempAniQuat.slerp(key2rot, l);\n            return Virtulous.KeyFrame.tempAniMatrix.compose(Virtulous.KeyFrame.tempAniPos, Virtulous.KeyFrame.tempAniQuat, Virtulous.KeyFrame.tempAniScale);\n          };\n        }\n        return _createClass(_class);\n      }();\n      Virtulous.KeyFrame.tempAniPos = new Vector3();\n      Virtulous.KeyFrame.tempAniQuat = new Quaternion();\n      Virtulous.KeyFrame.tempAniScale = new Vector3(1, 1, 1);\n      Virtulous.KeyFrame.tempAniMatrix = new Matrix4();\n      Virtulous.KeyFrameTrack = function () {\n        this.keys = [];\n        this.target = null;\n        this.time = 0;\n        this.length = 0;\n        this._accelTable = {};\n        this.fps = 20;\n        this.addKey = function (key) {\n          this.keys.push(key);\n        };\n        this.init = function () {\n          this.sortKeys();\n          if (this.keys.length > 0) this.length = this.keys[this.keys.length - 1].time;else this.length = 0;\n          if (!this.fps) return;\n          for (var j = 0; j < this.length * this.fps; j++) {\n            for (var i = 0; i < this.keys.length; i++) {\n              if (this.keys[i].time == j) {\n                this._accelTable[j] = i;\n                break;\n              } else if (this.keys[i].time < j / this.fps && this.keys[i + 1] && this.keys[i + 1].time >= j / this.fps) {\n                this._accelTable[j] = i;\n                break;\n              }\n            }\n          }\n        };\n        this.parseFromThree = function (data) {\n          var fps = data.fps;\n          this.target = data.node;\n          var track = data.hierarchy[0].keys;\n          for (var i = 0; i < track.length; i++) {\n            this.addKey(new Virtulous.KeyFrame(i / fps || track[i].time, track[i].targets[0].data));\n          }\n          this.init();\n        };\n        this.parseFromCollada = function (data) {\n          var track = data.keys;\n          var fps = this.fps;\n          for (var i = 0; i < track.length; i++) {\n            this.addKey(new Virtulous.KeyFrame(i / fps || track[i].time, track[i].matrix));\n          }\n          this.init();\n        };\n        this.sortKeys = function () {\n          this.keys.sort(this.keySortFunc);\n        };\n        this.keySortFunc = function (a, b) {\n          return a.time - b.time;\n        };\n        this.clone = function () {\n          var t = new Virtulous.KeyFrameTrack();\n          t.target = this.target;\n          t.time = this.time;\n          t.length = this.length;\n          for (var i = 0; i < this.keys.length; i++) {\n            t.addKey(this.keys[i].clone());\n          }\n          t.init();\n          return t;\n        };\n        this.reTarget = function (root, compareitor) {\n          if (!compareitor) compareitor = Virtulous.TrackTargetNodeNameCompare;\n          this.target = compareitor(root, this.target);\n        };\n        this.keySearchAccel = function (time) {\n          time *= this.fps;\n          time = Math.floor(time);\n          return this._accelTable[time] || 0;\n        };\n        this.setTime = function (time) {\n          time = Math.abs(time);\n          if (this.length) time = time % this.length + 0.05;\n          var key0 = null;\n          var key1 = null;\n          for (var i = this.keySearchAccel(time); i < this.keys.length; i++) {\n            if (this.keys[i].time == time) {\n              key0 = this.keys[i];\n              key1 = this.keys[i];\n              break;\n            } else if (this.keys[i].time < time && this.keys[i + 1] && this.keys[i + 1].time > time) {\n              key0 = this.keys[i];\n              key1 = this.keys[i + 1];\n              break;\n            } else if (this.keys[i].time < time && i == this.keys.length - 1) {\n              key0 = this.keys[i];\n              key1 = this.keys[0].clone();\n              key1.time += this.length + 0.05;\n              break;\n            }\n          }\n          if (key0 && key1 && key0 !== key1) {\n            this.target.matrixAutoUpdate = false;\n            this.target.matrix.copy(key0.lerp(key1, time));\n            this.target.matrixWorldNeedsUpdate = true;\n            return;\n          }\n          if (key0 && key1 && key0 == key1) {\n            this.target.matrixAutoUpdate = false;\n            this.target.matrix.copy(key0.matrix);\n            this.target.matrixWorldNeedsUpdate = true;\n            return;\n          }\n        };\n      };\n      Virtulous.TrackTargetNodeNameCompare = function (root, target) {\n        function find(node, name) {\n          if (node.name == name) return node;\n          for (var i = 0; i < node.children.length; i++) {\n            var r = find(node.children[i], name);\n            if (r) return r;\n          }\n          return null;\n        }\n        return find(root, target.name);\n      };\n      Virtulous.Animation = function () {\n        this.tracks = [];\n        this.length = 0;\n        this.addTrack = function (track) {\n          this.tracks.push(track);\n          this.length = Math.max(track.length, this.length);\n        };\n        this.setTime = function (time) {\n          this.time = time;\n          for (var i = 0; i < this.tracks.length; i++) this.tracks[i].setTime(time);\n        };\n        this.clone = function (target, compareitor) {\n          if (!compareitor) compareitor = Virtulous.TrackTargetNodeNameCompare;\n          var n = new Virtulous.Animation();\n          n.target = target;\n          for (var i = 0; i < this.tracks.length; i++) {\n            var track = this.tracks[i].clone();\n            track.reTarget(target, compareitor);\n            n.addTrack(track);\n          }\n          return n;\n        };\n      };\n      var ASSBIN_CHUNK_AICAMERA = 4660;\n      var ASSBIN_CHUNK_AILIGHT = 4661;\n      var ASSBIN_CHUNK_AITEXTURE = 4662;\n      var ASSBIN_CHUNK_AIMESH = 4663;\n      var ASSBIN_CHUNK_AINODEANIM = 4664;\n      var ASSBIN_CHUNK_AISCENE = 4665;\n      var ASSBIN_CHUNK_AIBONE = 4666;\n      var ASSBIN_CHUNK_AIANIMATION = 4667;\n      var ASSBIN_CHUNK_AINODE = 4668;\n      var ASSBIN_CHUNK_AIMATERIAL = 4669;\n      var ASSBIN_CHUNK_AIMATERIALPROPERTY = 4670;\n      var ASSBIN_MESH_HAS_POSITIONS = 1;\n      var ASSBIN_MESH_HAS_NORMALS = 2;\n      var ASSBIN_MESH_HAS_TANGENTS_AND_BITANGENTS = 4;\n      var ASSBIN_MESH_HAS_TEXCOORD_BASE = 256;\n      var ASSBIN_MESH_HAS_COLOR_BASE = 65536;\n      var AI_MAX_NUMBER_OF_COLOR_SETS = 1;\n      var AI_MAX_NUMBER_OF_TEXTURECOORDS = 4;\n      //! A directional light source has a well-defined direction\n      //! but is infinitely far away. That's quite a good\n      //! approximation for sun light.\n      var aiLightSource_DIRECTIONAL = 1;\n      //! A point light source has a well-defined position\n      //! in space but no direction - it emits light in all\n      //! directions. A normal bulb is a point light.\n      //! A spot light source emits light in a specific\n      //! angle. It has a position and a direction it is pointing to.\n      //! A good example for a spot light is a light spot in\n      //! sport arenas.\n      var aiLightSource_SPOT = 3;\n      //! The generic light level of the world, including the bounces\n      //! of all other lightsources.\n      //! Typically, there's at most one ambient light in a scene.\n      //! This light type doesn't have a valid position, direction, or\n      //! other properties, just a color.\n      var aiTextureType_DIFFUSE = 1;\n      var aiTextureType_NORMALS = 6;\n      var aiTextureType_OPACITY = 8;\n      var aiTextureType_LIGHTMAP = 10;\n      var BONESPERVERT = 4;\n      function ASSBIN_MESH_HAS_TEXCOORD(n) {\n        return ASSBIN_MESH_HAS_TEXCOORD_BASE << n;\n      }\n      function ASSBIN_MESH_HAS_COLOR(n) {\n        return ASSBIN_MESH_HAS_COLOR_BASE << n;\n      }\n      function markBones(scene) {\n        for (var i in scene.mMeshes) {\n          var mesh = scene.mMeshes[i];\n          for (var k in mesh.mBones) {\n            var boneNode = scene.findNode(mesh.mBones[k].mName);\n            if (boneNode) boneNode.isBone = true;\n          }\n        }\n      }\n      function cloneTreeToBones(root, scene) {\n        var rootBone = new Bone();\n        rootBone.matrix.copy(root.matrix);\n        rootBone.matrixWorld.copy(root.matrixWorld);\n        rootBone.position.copy(root.position);\n        rootBone.quaternion.copy(root.quaternion);\n        rootBone.scale.copy(root.scale);\n        scene.nodeCount++;\n        rootBone.name = \"bone_\" + root.name + scene.nodeCount.toString();\n        if (!scene.nodeToBoneMap[root.name]) scene.nodeToBoneMap[root.name] = [];\n        scene.nodeToBoneMap[root.name].push(rootBone);\n        for (var i in root.children) {\n          var child = cloneTreeToBones(root.children[i], scene);\n          rootBone.add(child);\n        }\n        return rootBone;\n      }\n      function sortWeights(indexes, weights) {\n        var pairs = [];\n        for (var i = 0; i < indexes.length; i++) {\n          pairs.push({\n            i: indexes[i],\n            w: weights[i]\n          });\n        }\n        pairs.sort(function (a, b) {\n          return b.w - a.w;\n        });\n        while (pairs.length < 4) {\n          pairs.push({\n            i: 0,\n            w: 0\n          });\n        }\n        if (pairs.length > 4) pairs.length = 4;\n        var sum = 0;\n        for (var _i = 0; _i < 4; _i++) {\n          sum += pairs[_i].w * pairs[_i].w;\n        }\n        sum = Math.sqrt(sum);\n        for (var _i2 = 0; _i2 < 4; _i2++) {\n          pairs[_i2].w = pairs[_i2].w / sum;\n          indexes[_i2] = pairs[_i2].i;\n          weights[_i2] = pairs[_i2].w;\n        }\n      }\n      function findMatchingBone(root, name) {\n        if (root.name.indexOf(\"bone_\" + name) == 0) return root;\n        for (var i in root.children) {\n          var ret = findMatchingBone(root.children[i], name);\n          if (ret) return ret;\n        }\n        return void 0;\n      }\n      var aiMesh = /*#__PURE__*/_createClass(function aiMesh() {\n        _classCallCheck(this, aiMesh);\n        this.mPrimitiveTypes = 0;\n        this.mNumVertices = 0;\n        this.mNumFaces = 0;\n        this.mNumBones = 0;\n        this.mMaterialIndex = 0;\n        this.mVertices = [];\n        this.mNormals = [];\n        this.mTangents = [];\n        this.mBitangents = [];\n        this.mColors = [[]];\n        this.mTextureCoords = [[]];\n        this.mFaces = [];\n        this.mBones = [];\n        this.hookupSkeletons = function (scene) {\n          if (this.mBones.length == 0) return;\n          var allBones = [];\n          var offsetMatrix = [];\n          var skeletonRoot = scene.findNode(this.mBones[0].mName);\n          while (skeletonRoot.mParent && skeletonRoot.mParent.isBone) {\n            skeletonRoot = skeletonRoot.mParent;\n          }\n          var threeSkeletonRoot = skeletonRoot.toTHREE(scene);\n          var threeSkeletonRootBone = cloneTreeToBones(threeSkeletonRoot, scene);\n          this.threeNode.add(threeSkeletonRootBone);\n          for (var i = 0; i < this.mBones.length; i++) {\n            var bone = findMatchingBone(threeSkeletonRootBone, this.mBones[i].mName);\n            if (bone) {\n              var tbone = bone;\n              allBones.push(tbone);\n              offsetMatrix.push(this.mBones[i].mOffsetMatrix.toTHREE());\n            } else {\n              var skeletonRoot = scene.findNode(this.mBones[i].mName);\n              if (!skeletonRoot) return;\n              var threeSkeletonRoot = skeletonRoot.toTHREE(scene);\n              var threeSkeletonRootBone = cloneTreeToBones(threeSkeletonRoot, scene);\n              this.threeNode.add(threeSkeletonRootBone);\n              var bone = findMatchingBone(threeSkeletonRootBone, this.mBones[i].mName);\n              var tbone = bone;\n              allBones.push(tbone);\n              offsetMatrix.push(this.mBones[i].mOffsetMatrix.toTHREE());\n            }\n          }\n          var skeleton = new Skeleton(allBones, offsetMatrix);\n          this.threeNode.bind(skeleton, new Matrix4());\n          this.threeNode.material.skinning = true;\n        };\n        this.toTHREE = function (scene) {\n          if (this.threeNode) return this.threeNode;\n          var geometry = new BufferGeometry();\n          var mat;\n          if (scene.mMaterials[this.mMaterialIndex]) mat = scene.mMaterials[this.mMaterialIndex].toTHREE(scene);else mat = new MeshLambertMaterial();\n          geometry.setIndex(new BufferAttribute(new Uint32Array(this.mIndexArray), 1));\n          geometry.setAttribute(\"position\", new BufferAttribute(this.mVertexBuffer, 3));\n          if (this.mNormalBuffer && this.mNormalBuffer.length > 0) {\n            geometry.setAttribute(\"normal\", new BufferAttribute(this.mNormalBuffer, 3));\n          }\n          if (this.mColorBuffer && this.mColorBuffer.length > 0) {\n            geometry.setAttribute(\"color\", new BufferAttribute(this.mColorBuffer, 4));\n          }\n          if (this.mTexCoordsBuffers[0] && this.mTexCoordsBuffers[0].length > 0) {\n            geometry.setAttribute(\"uv\", new BufferAttribute(new Float32Array(this.mTexCoordsBuffers[0]), 2));\n          }\n          if (this.mTexCoordsBuffers[1] && this.mTexCoordsBuffers[1].length > 0) {\n            geometry.setAttribute(\"uv1\", new BufferAttribute(new Float32Array(this.mTexCoordsBuffers[1]), 2));\n          }\n          if (this.mTangentBuffer && this.mTangentBuffer.length > 0) {\n            geometry.setAttribute(\"tangents\", new BufferAttribute(this.mTangentBuffer, 3));\n          }\n          if (this.mBitangentBuffer && this.mBitangentBuffer.length > 0) {\n            geometry.setAttribute(\"bitangents\", new BufferAttribute(this.mBitangentBuffer, 3));\n          }\n          if (this.mBones.length > 0) {\n            var weights = [];\n            var bones = [];\n            for (var i = 0; i < this.mBones.length; i++) {\n              for (var j = 0; j < this.mBones[i].mWeights.length; j++) {\n                var weight = this.mBones[i].mWeights[j];\n                if (weight) {\n                  if (!weights[weight.mVertexId]) weights[weight.mVertexId] = [];\n                  if (!bones[weight.mVertexId]) bones[weight.mVertexId] = [];\n                  weights[weight.mVertexId].push(weight.mWeight);\n                  bones[weight.mVertexId].push(parseInt(i));\n                }\n              }\n            }\n            for (var _i3 in bones) {\n              sortWeights(bones[_i3], weights[_i3]);\n            }\n            var _weights = [];\n            var _bones = [];\n            for (var _i4 = 0; _i4 < weights.length; _i4++) {\n              for (var _j = 0; _j < 4; _j++) {\n                if (weights[_i4] && bones[_i4]) {\n                  _weights.push(weights[_i4][_j]);\n                  _bones.push(bones[_i4][_j]);\n                } else {\n                  _weights.push(0);\n                  _bones.push(0);\n                }\n              }\n            }\n            geometry.setAttribute(\"skinWeight\", new BufferAttribute(new Float32Array(_weights), BONESPERVERT));\n            geometry.setAttribute(\"skinIndex\", new BufferAttribute(new Float32Array(_bones), BONESPERVERT));\n          }\n          var mesh;\n          if (this.mBones.length == 0) mesh = new Mesh(geometry, mat);\n          if (this.mBones.length > 0) {\n            mesh = new SkinnedMesh(geometry, mat);\n            mesh.normalizeSkinWeights();\n          }\n          this.threeNode = mesh;\n          return mesh;\n        };\n      });\n      var aiFace = /*#__PURE__*/_createClass(function aiFace() {\n        _classCallCheck(this, aiFace);\n        this.mNumIndices = 0;\n        this.mIndices = [];\n      });\n      var aiVector3D = /*#__PURE__*/_createClass(function aiVector3D() {\n        _classCallCheck(this, aiVector3D);\n        this.x = 0;\n        this.y = 0;\n        this.z = 0;\n        this.toTHREE = function () {\n          return new Vector3(this.x, this.y, this.z);\n        };\n      });\n      var aiColor3D = /*#__PURE__*/_createClass(function aiColor3D() {\n        _classCallCheck(this, aiColor3D);\n        this.r = 0;\n        this.g = 0;\n        this.b = 0;\n        this.a = 0;\n        this.toTHREE = function () {\n          return new Color(this.r, this.g, this.b);\n        };\n      });\n      var aiQuaternion = /*#__PURE__*/_createClass(function aiQuaternion() {\n        _classCallCheck(this, aiQuaternion);\n        this.x = 0;\n        this.y = 0;\n        this.z = 0;\n        this.w = 0;\n        this.toTHREE = function () {\n          return new Quaternion(this.x, this.y, this.z, this.w);\n        };\n      });\n      var aiVertexWeight = /*#__PURE__*/_createClass(function aiVertexWeight() {\n        _classCallCheck(this, aiVertexWeight);\n        this.mVertexId = 0;\n        this.mWeight = 0;\n      });\n      var aiString = /*#__PURE__*/_createClass(function aiString() {\n        _classCallCheck(this, aiString);\n        this.data = [];\n        this.toString = function () {\n          var str = \"\";\n          this.data.forEach(function (i) {\n            str += String.fromCharCode(i);\n          });\n          return str.replace(/[^\\x20-\\x7E]+/g, \"\");\n        };\n      });\n      var aiVectorKey = /*#__PURE__*/_createClass(function aiVectorKey() {\n        _classCallCheck(this, aiVectorKey);\n        this.mTime = 0;\n        this.mValue = null;\n      });\n      var aiQuatKey = /*#__PURE__*/_createClass(function aiQuatKey() {\n        _classCallCheck(this, aiQuatKey);\n        this.mTime = 0;\n        this.mValue = null;\n      });\n      var aiNode = /*#__PURE__*/_createClass(function aiNode() {\n        _classCallCheck(this, aiNode);\n        this.mName = \"\";\n        this.mTransformation = [];\n        this.mNumChildren = 0;\n        this.mNumMeshes = 0;\n        this.mMeshes = [];\n        this.mChildren = [];\n        this.toTHREE = function (scene) {\n          if (this.threeNode) return this.threeNode;\n          var o = new Object3D();\n          o.name = this.mName;\n          o.matrix = this.mTransformation.toTHREE();\n          for (var i = 0; i < this.mChildren.length; i++) {\n            o.add(this.mChildren[i].toTHREE(scene));\n          }\n          for (var _i5 = 0; _i5 < this.mMeshes.length; _i5++) {\n            o.add(scene.mMeshes[this.mMeshes[_i5]].toTHREE(scene));\n          }\n          this.threeNode = o;\n          o.matrix.decompose(o.position, o.quaternion, o.scale);\n          return o;\n        };\n      });\n      var aiBone = /*#__PURE__*/_createClass(function aiBone() {\n        _classCallCheck(this, aiBone);\n        this.mName = \"\";\n        this.mNumWeights = 0;\n        this.mOffsetMatrix = 0;\n      });\n      var aiMaterialProperty = /*#__PURE__*/_createClass(function aiMaterialProperty() {\n        _classCallCheck(this, aiMaterialProperty);\n        this.mKey = \"\";\n        this.mSemantic = 0;\n        this.mIndex = 0;\n        this.mData = [];\n        this.mDataLength = 0;\n        this.mType = 0;\n        this.dataAsColor = function () {\n          var array = new Uint8Array(this.mData).buffer;\n          var reader = new DataView(array);\n          var r = reader.getFloat32(0, true);\n          var g = reader.getFloat32(4, true);\n          var b = reader.getFloat32(8, true);\n          return new Color(r, g, b);\n        };\n        this.dataAsFloat = function () {\n          var array = new Uint8Array(this.mData).buffer;\n          var reader = new DataView(array);\n          var r = reader.getFloat32(0, true);\n          return r;\n        };\n        this.dataAsBool = function () {\n          var array = new Uint8Array(this.mData).buffer;\n          var reader = new DataView(array);\n          var r = reader.getFloat32(0, true);\n          return !!r;\n        };\n        this.dataAsString = function () {\n          var s = new aiString();\n          s.data = this.mData;\n          return s.toString();\n        };\n        this.dataAsMap = function () {\n          var s = new aiString();\n          s.data = this.mData;\n          var path2 = s.toString();\n          path2 = path2.replace(/\\\\/g, \"/\");\n          if (path2.indexOf(\"/\") != -1) {\n            path2 = path2.substr(path2.lastIndexOf(\"/\") + 1);\n          }\n          return textureLoader.load(path2);\n        };\n      });\n      var namePropMapping = {\n        \"?mat.name\": \"name\",\n        \"$mat.shadingm\": \"shading\",\n        \"$mat.twosided\": \"twoSided\",\n        \"$mat.wireframe\": \"wireframe\",\n        \"$clr.ambient\": \"ambient\",\n        \"$clr.diffuse\": \"color\",\n        \"$clr.specular\": \"specular\",\n        \"$clr.emissive\": \"emissive\",\n        \"$clr.transparent\": \"transparent\",\n        \"$clr.reflective\": \"reflect\",\n        \"$mat.shininess\": \"shininess\",\n        \"$mat.reflectivity\": \"reflectivity\",\n        \"$mat.refracti\": \"refraction\",\n        \"$tex.file\": \"map\"\n      };\n      var nameTypeMapping = {\n        \"?mat.name\": \"string\",\n        \"$mat.shadingm\": \"bool\",\n        \"$mat.twosided\": \"bool\",\n        \"$mat.wireframe\": \"bool\",\n        \"$clr.ambient\": \"color\",\n        \"$clr.diffuse\": \"color\",\n        \"$clr.specular\": \"color\",\n        \"$clr.emissive\": \"color\",\n        \"$clr.transparent\": \"color\",\n        \"$clr.reflective\": \"color\",\n        \"$mat.shininess\": \"float\",\n        \"$mat.reflectivity\": \"float\",\n        \"$mat.refracti\": \"float\",\n        \"$tex.file\": \"map\"\n      };\n      var aiMaterial = /*#__PURE__*/_createClass(function aiMaterial() {\n        _classCallCheck(this, aiMaterial);\n        this.mNumAllocated = 0;\n        this.mNumProperties = 0;\n        this.mProperties = [];\n        this.toTHREE = function () {\n          var mat = new MeshPhongMaterial();\n          for (var i = 0; i < this.mProperties.length; i++) {\n            if (nameTypeMapping[this.mProperties[i].mKey] == \"float\") {\n              mat[namePropMapping[this.mProperties[i].mKey]] = this.mProperties[i].dataAsFloat();\n            }\n            if (nameTypeMapping[this.mProperties[i].mKey] == \"color\") {\n              mat[namePropMapping[this.mProperties[i].mKey]] = this.mProperties[i].dataAsColor();\n            }\n            if (nameTypeMapping[this.mProperties[i].mKey] == \"bool\") {\n              mat[namePropMapping[this.mProperties[i].mKey]] = this.mProperties[i].dataAsBool();\n            }\n            if (nameTypeMapping[this.mProperties[i].mKey] == \"string\") {\n              mat[namePropMapping[this.mProperties[i].mKey]] = this.mProperties[i].dataAsString();\n            }\n            if (nameTypeMapping[this.mProperties[i].mKey] == \"map\") {\n              var prop = this.mProperties[i];\n              if (prop.mSemantic == aiTextureType_DIFFUSE) mat.map = this.mProperties[i].dataAsMap();\n              if (prop.mSemantic == aiTextureType_NORMALS) mat.normalMap = this.mProperties[i].dataAsMap();\n              if (prop.mSemantic == aiTextureType_LIGHTMAP) mat.lightMap = this.mProperties[i].dataAsMap();\n              if (prop.mSemantic == aiTextureType_OPACITY) mat.alphaMap = this.mProperties[i].dataAsMap();\n            }\n          }\n          mat.ambient.r = 0.53;\n          mat.ambient.g = 0.53;\n          mat.ambient.b = 0.53;\n          mat.color.r = 1;\n          mat.color.g = 1;\n          mat.color.b = 1;\n          return mat;\n        };\n      });\n      function veclerp(v1, v2, l) {\n        var v = new Vector3();\n        var lm1 = 1 - l;\n        v.x = v1.x * l + v2.x * lm1;\n        v.y = v1.y * l + v2.y * lm1;\n        v.z = v1.z * l + v2.z * lm1;\n        return v;\n      }\n      function quatlerp(q1, q2, l) {\n        return q1.clone().slerp(q2, 1 - l);\n      }\n      function sampleTrack(keys, time, lne, lerp) {\n        if (keys.length == 1) return keys[0].mValue.toTHREE();\n        var dist = Infinity;\n        var key = null;\n        var nextKey = null;\n        for (var i = 0; i < keys.length; i++) {\n          var timeDist = Math.abs(keys[i].mTime - time);\n          if (timeDist < dist && keys[i].mTime <= time) {\n            dist = timeDist;\n            key = keys[i];\n            nextKey = keys[i + 1];\n          }\n        }\n        if (!key) {\n          return null;\n        } else if (nextKey) {\n          var dT = nextKey.mTime - key.mTime;\n          var T = key.mTime - time;\n          var l = T / dT;\n          return lerp(key.mValue.toTHREE(), nextKey.mValue.toTHREE(), l);\n        } else {\n          nextKey = keys[0].clone();\n          nextKey.mTime += lne;\n          var dT = nextKey.mTime - key.mTime;\n          var T = key.mTime - time;\n          var l = T / dT;\n          return lerp(key.mValue.toTHREE(), nextKey.mValue.toTHREE(), l);\n        }\n      }\n      var aiNodeAnim = /*#__PURE__*/_createClass(function aiNodeAnim() {\n        _classCallCheck(this, aiNodeAnim);\n        this.mNodeName = \"\";\n        this.mNumPositionKeys = 0;\n        this.mNumRotationKeys = 0;\n        this.mNumScalingKeys = 0;\n        this.mPositionKeys = [];\n        this.mRotationKeys = [];\n        this.mScalingKeys = [];\n        this.mPreState = \"\";\n        this.mPostState = \"\";\n        this.init = function (tps) {\n          if (!tps) tps = 1;\n          function t(t2) {\n            t2.mTime /= tps;\n          }\n          this.mPositionKeys.forEach(t);\n          this.mRotationKeys.forEach(t);\n          this.mScalingKeys.forEach(t);\n        };\n        this.sortKeys = function () {\n          function comp(a, b) {\n            return a.mTime - b.mTime;\n          }\n          this.mPositionKeys.sort(comp);\n          this.mRotationKeys.sort(comp);\n          this.mScalingKeys.sort(comp);\n        };\n        this.getLength = function () {\n          return Math.max(Math.max.apply(null, this.mPositionKeys.map(function (a) {\n            return a.mTime;\n          })), Math.max.apply(null, this.mRotationKeys.map(function (a) {\n            return a.mTime;\n          })), Math.max.apply(null, this.mScalingKeys.map(function (a) {\n            return a.mTime;\n          })));\n        };\n        this.toTHREE = function (o) {\n          this.sortKeys();\n          var length = this.getLength();\n          var track = new Virtulous.KeyFrameTrack();\n          for (var i = 0; i < length; i += 0.05) {\n            var matrix = new Matrix4();\n            var time = i;\n            var pos = sampleTrack(this.mPositionKeys, time, length, veclerp);\n            var scale = sampleTrack(this.mScalingKeys, time, length, veclerp);\n            var rotation = sampleTrack(this.mRotationKeys, time, length, quatlerp);\n            matrix.compose(pos, rotation, scale);\n            var key = new Virtulous.KeyFrame(time, matrix);\n            track.addKey(key);\n          }\n          track.target = o.findNode(this.mNodeName).toTHREE();\n          var tracks = [track];\n          if (o.nodeToBoneMap[this.mNodeName]) {\n            for (var _i6 = 0; _i6 < o.nodeToBoneMap[this.mNodeName].length; _i6++) {\n              var t2 = track.clone();\n              t2.target = o.nodeToBoneMap[this.mNodeName][_i6];\n              tracks.push(t2);\n            }\n          }\n          return tracks;\n        };\n      });\n      var aiAnimation = /*#__PURE__*/_createClass(function aiAnimation() {\n        _classCallCheck(this, aiAnimation);\n        this.mName = \"\";\n        this.mDuration = 0;\n        this.mTicksPerSecond = 0;\n        this.mNumChannels = 0;\n        this.mChannels = [];\n        this.toTHREE = function (root) {\n          var animationHandle = new Virtulous.Animation();\n          for (var i in this.mChannels) {\n            this.mChannels[i].init(this.mTicksPerSecond);\n            var tracks = this.mChannels[i].toTHREE(root);\n            for (var j in tracks) {\n              tracks[j].init();\n              animationHandle.addTrack(tracks[j]);\n            }\n          }\n          animationHandle.length = Math.max.apply(null, animationHandle.tracks.map(function (e) {\n            return e.length;\n          }));\n          return animationHandle;\n        };\n      });\n      var aiTexture = /*#__PURE__*/_createClass(function aiTexture() {\n        _classCallCheck(this, aiTexture);\n        this.mWidth = 0;\n        this.mHeight = 0;\n        this.texAchFormatHint = [];\n        this.pcData = [];\n      });\n      var aiLight = /*#__PURE__*/_createClass(function aiLight() {\n        _classCallCheck(this, aiLight);\n        this.mName = \"\";\n        this.mType = 0;\n        this.mAttenuationConstant = 0;\n        this.mAttenuationLinear = 0;\n        this.mAttenuationQuadratic = 0;\n        this.mAngleInnerCone = 0;\n        this.mAngleOuterCone = 0;\n        this.mColorDiffuse = null;\n        this.mColorSpecular = null;\n        this.mColorAmbient = null;\n      });\n      var aiCamera = /*#__PURE__*/_createClass(function aiCamera() {\n        _classCallCheck(this, aiCamera);\n        this.mName = \"\";\n        this.mPosition = null;\n        this.mLookAt = null;\n        this.mUp = null;\n        this.mHorizontalFOV = 0;\n        this.mClipPlaneNear = 0;\n        this.mClipPlaneFar = 0;\n        this.mAspect = 0;\n      });\n      var aiScene = /*#__PURE__*/_createClass(function aiScene() {\n        _classCallCheck(this, aiScene);\n        this.versionMajor = 0;\n        this.versionMinor = 0;\n        this.versionRevision = 0;\n        this.compileFlags = 0;\n        this.mFlags = 0;\n        this.mNumMeshes = 0;\n        this.mNumMaterials = 0;\n        this.mNumAnimations = 0;\n        this.mNumTextures = 0;\n        this.mNumLights = 0;\n        this.mNumCameras = 0;\n        this.mRootNode = null;\n        this.mMeshes = [];\n        this.mMaterials = [];\n        this.mAnimations = [];\n        this.mLights = [];\n        this.mCameras = [];\n        this.nodeToBoneMap = {};\n        this.findNode = function (name, root) {\n          if (!root) {\n            root = this.mRootNode;\n          }\n          if (root.mName == name) {\n            return root;\n          }\n          for (var i = 0; i < root.mChildren.length; i++) {\n            var ret = this.findNode(name, root.mChildren[i]);\n            if (ret) return ret;\n          }\n          return null;\n        };\n        this.toTHREE = function () {\n          this.nodeCount = 0;\n          markBones(this);\n          var o = this.mRootNode.toTHREE(this);\n          for (var i in this.mMeshes) this.mMeshes[i].hookupSkeletons(this);\n          if (this.mAnimations.length > 0) {\n            var a = this.mAnimations[0].toTHREE(this);\n          }\n          return {\n            object: o,\n            animation: a\n          };\n        };\n      });\n      var aiMatrix4 = /*#__PURE__*/_createClass(function aiMatrix4() {\n        _classCallCheck(this, aiMatrix4);\n        this.elements = [[], [], [], []];\n        this.toTHREE = function () {\n          var m = new Matrix4();\n          for (var i = 0; i < 4; ++i) {\n            for (var i2 = 0; i2 < 4; ++i2) {\n              m.elements[i * 4 + i2] = this.elements[i2][i];\n            }\n          }\n          return m;\n        };\n      });\n      var littleEndian = true;\n      function readFloat(dataview) {\n        var val = dataview.getFloat32(dataview.readOffset, littleEndian);\n        dataview.readOffset += 4;\n        return val;\n      }\n      function Read_double(dataview) {\n        var val = dataview.getFloat64(dataview.readOffset, littleEndian);\n        dataview.readOffset += 8;\n        return val;\n      }\n      function Read_uint8_t(dataview) {\n        var val = dataview.getUint8(dataview.readOffset);\n        dataview.readOffset += 1;\n        return val;\n      }\n      function Read_uint16_t(dataview) {\n        var val = dataview.getUint16(dataview.readOffset, littleEndian);\n        dataview.readOffset += 2;\n        return val;\n      }\n      function Read_unsigned_int(dataview) {\n        var val = dataview.getUint32(dataview.readOffset, littleEndian);\n        dataview.readOffset += 4;\n        return val;\n      }\n      function Read_uint32_t(dataview) {\n        var val = dataview.getUint32(dataview.readOffset, littleEndian);\n        dataview.readOffset += 4;\n        return val;\n      }\n      function Read_aiVector3D(stream) {\n        var v = new aiVector3D();\n        v.x = readFloat(stream);\n        v.y = readFloat(stream);\n        v.z = readFloat(stream);\n        return v;\n      }\n      function Read_aiColor3D(stream) {\n        var c = new aiColor3D();\n        c.r = readFloat(stream);\n        c.g = readFloat(stream);\n        c.b = readFloat(stream);\n        return c;\n      }\n      function Read_aiQuaternion(stream) {\n        var v = new aiQuaternion();\n        v.w = readFloat(stream);\n        v.x = readFloat(stream);\n        v.y = readFloat(stream);\n        v.z = readFloat(stream);\n        return v;\n      }\n      function Read_aiString(stream) {\n        var s = new aiString();\n        var stringlengthbytes = Read_unsigned_int(stream);\n        stream.ReadBytes(s.data, 1, stringlengthbytes);\n        return s.toString();\n      }\n      function Read_aiVertexWeight(stream) {\n        var w = new aiVertexWeight();\n        w.mVertexId = Read_unsigned_int(stream);\n        w.mWeight = readFloat(stream);\n        return w;\n      }\n      function Read_aiMatrix4x4(stream) {\n        var m = new aiMatrix4();\n        for (var i = 0; i < 4; ++i) {\n          for (var i2 = 0; i2 < 4; ++i2) {\n            m.elements[i][i2] = readFloat(stream);\n          }\n        }\n        return m;\n      }\n      function Read_aiVectorKey(stream) {\n        var v = new aiVectorKey();\n        v.mTime = Read_double(stream);\n        v.mValue = Read_aiVector3D(stream);\n        return v;\n      }\n      function Read_aiQuatKey(stream) {\n        var v = new aiQuatKey();\n        v.mTime = Read_double(stream);\n        v.mValue = Read_aiQuaternion(stream);\n        return v;\n      }\n      function ReadArray_aiVertexWeight(stream, data, size) {\n        for (var i = 0; i < size; i++) data[i] = Read_aiVertexWeight(stream);\n      }\n      function ReadArray_aiVectorKey(stream, data, size) {\n        for (var i = 0; i < size; i++) data[i] = Read_aiVectorKey(stream);\n      }\n      function ReadArray_aiQuatKey(stream, data, size) {\n        for (var i = 0; i < size; i++) data[i] = Read_aiQuatKey(stream);\n      }\n      function ReadBounds(stream, T, n) {\n        return stream.Seek(sizeof(T) * n, aiOrigin_CUR);\n      }\n      function ai_assert(bool) {\n        if (!bool) throw \"asset failed\";\n      }\n      function ReadBinaryNode(stream, parent, depth) {\n        var chunkID = Read_uint32_t(stream);\n        ai_assert(chunkID == ASSBIN_CHUNK_AINODE);\n        Read_uint32_t(stream);\n        var node = new aiNode();\n        node.mParent = parent;\n        node.mDepth = depth;\n        node.mName = Read_aiString(stream);\n        node.mTransformation = Read_aiMatrix4x4(stream);\n        node.mNumChildren = Read_unsigned_int(stream);\n        node.mNumMeshes = Read_unsigned_int(stream);\n        if (node.mNumMeshes) {\n          node.mMeshes = [];\n          for (var i = 0; i < node.mNumMeshes; ++i) {\n            node.mMeshes[i] = Read_unsigned_int(stream);\n          }\n        }\n        if (node.mNumChildren) {\n          node.mChildren = [];\n          for (var _i7 = 0; _i7 < node.mNumChildren; ++_i7) {\n            var node2 = ReadBinaryNode(stream, node, depth++);\n            node.mChildren[_i7] = node2;\n          }\n        }\n        return node;\n      }\n      function ReadBinaryBone(stream, b) {\n        var chunkID = Read_uint32_t(stream);\n        ai_assert(chunkID == ASSBIN_CHUNK_AIBONE);\n        Read_uint32_t(stream);\n        b.mName = Read_aiString(stream);\n        b.mNumWeights = Read_unsigned_int(stream);\n        b.mOffsetMatrix = Read_aiMatrix4x4(stream);\n        if (shortened) {\n          ReadBounds(stream, b.mWeights, b.mNumWeights);\n        } else {\n          b.mWeights = [];\n          ReadArray_aiVertexWeight(stream, b.mWeights, b.mNumWeights);\n        }\n        return b;\n      }\n      function ReadBinaryMesh(stream, mesh) {\n        var chunkID = Read_uint32_t(stream);\n        ai_assert(chunkID == ASSBIN_CHUNK_AIMESH);\n        Read_uint32_t(stream);\n        mesh.mPrimitiveTypes = Read_unsigned_int(stream);\n        mesh.mNumVertices = Read_unsigned_int(stream);\n        mesh.mNumFaces = Read_unsigned_int(stream);\n        mesh.mNumBones = Read_unsigned_int(stream);\n        mesh.mMaterialIndex = Read_unsigned_int(stream);\n        mesh.mNumUVComponents = [];\n        var c = Read_unsigned_int(stream);\n        if (c & ASSBIN_MESH_HAS_POSITIONS) {\n          if (shortened) {\n            ReadBounds(stream, mesh.mVertices, mesh.mNumVertices);\n          } else {\n            mesh.mVertices = [];\n            mesh.mVertexBuffer = stream.subArray32(stream.readOffset, stream.readOffset + mesh.mNumVertices * 3 * 4);\n            stream.Seek(mesh.mNumVertices * 3 * 4, aiOrigin_CUR);\n          }\n        }\n        if (c & ASSBIN_MESH_HAS_NORMALS) {\n          if (shortened) {\n            ReadBounds(stream, mesh.mNormals, mesh.mNumVertices);\n          } else {\n            mesh.mNormals = [];\n            mesh.mNormalBuffer = stream.subArray32(stream.readOffset, stream.readOffset + mesh.mNumVertices * 3 * 4);\n            stream.Seek(mesh.mNumVertices * 3 * 4, aiOrigin_CUR);\n          }\n        }\n        if (c & ASSBIN_MESH_HAS_TANGENTS_AND_BITANGENTS) {\n          if (shortened) {\n            ReadBounds(stream, mesh.mTangents, mesh.mNumVertices);\n            ReadBounds(stream, mesh.mBitangents, mesh.mNumVertices);\n          } else {\n            mesh.mTangents = [];\n            mesh.mTangentBuffer = stream.subArray32(stream.readOffset, stream.readOffset + mesh.mNumVertices * 3 * 4);\n            stream.Seek(mesh.mNumVertices * 3 * 4, aiOrigin_CUR);\n            mesh.mBitangents = [];\n            mesh.mBitangentBuffer = stream.subArray32(stream.readOffset, stream.readOffset + mesh.mNumVertices * 3 * 4);\n            stream.Seek(mesh.mNumVertices * 3 * 4, aiOrigin_CUR);\n          }\n        }\n        for (var n = 0; n < AI_MAX_NUMBER_OF_COLOR_SETS; ++n) {\n          if (!(c & ASSBIN_MESH_HAS_COLOR(n))) break;\n          if (shortened) {\n            ReadBounds(stream, mesh.mColors[n], mesh.mNumVertices);\n          } else {\n            mesh.mColors[n] = [];\n            mesh.mColorBuffer = stream.subArray32(stream.readOffset, stream.readOffset + mesh.mNumVertices * 4 * 4);\n            stream.Seek(mesh.mNumVertices * 4 * 4, aiOrigin_CUR);\n          }\n        }\n        mesh.mTexCoordsBuffers = [];\n        for (var _n = 0; _n < AI_MAX_NUMBER_OF_TEXTURECOORDS; ++_n) {\n          if (!(c & ASSBIN_MESH_HAS_TEXCOORD(_n))) break;\n          mesh.mNumUVComponents[_n] = Read_unsigned_int(stream);\n          if (shortened) {\n            ReadBounds(stream, mesh.mTextureCoords[_n], mesh.mNumVertices);\n          } else {\n            mesh.mTextureCoords[_n] = [];\n            mesh.mTexCoordsBuffers[_n] = [];\n            for (var uv = 0; uv < mesh.mNumVertices; uv++) {\n              mesh.mTexCoordsBuffers[_n].push(readFloat(stream));\n              mesh.mTexCoordsBuffers[_n].push(readFloat(stream));\n              readFloat(stream);\n            }\n          }\n        }\n        if (shortened) {\n          Read_unsigned_int(stream);\n        } else {\n          mesh.mFaces = [];\n          mesh.mIndexArray = [];\n          for (var i = 0; i < mesh.mNumFaces; ++i) {\n            var f = mesh.mFaces[i] = new aiFace();\n            f.mNumIndices = Read_uint16_t(stream);\n            f.mIndices = [];\n            for (var a = 0; a < f.mNumIndices; ++a) {\n              if (mesh.mNumVertices < 1 << 16) {\n                f.mIndices[a] = Read_uint16_t(stream);\n              } else {\n                f.mIndices[a] = Read_unsigned_int(stream);\n              }\n            }\n            if (f.mNumIndices === 3) {\n              mesh.mIndexArray.push(f.mIndices[0]);\n              mesh.mIndexArray.push(f.mIndices[1]);\n              mesh.mIndexArray.push(f.mIndices[2]);\n            } else if (f.mNumIndices === 4) {\n              mesh.mIndexArray.push(f.mIndices[0]);\n              mesh.mIndexArray.push(f.mIndices[1]);\n              mesh.mIndexArray.push(f.mIndices[2]);\n              mesh.mIndexArray.push(f.mIndices[2]);\n              mesh.mIndexArray.push(f.mIndices[3]);\n              mesh.mIndexArray.push(f.mIndices[0]);\n            } else {\n              throw new Error(\"Sorry, can't currently triangulate polys. Use the triangulate preprocessor in Assimp.\");\n            }\n          }\n        }\n        if (mesh.mNumBones) {\n          mesh.mBones = [];\n          for (var _a = 0; _a < mesh.mNumBones; ++_a) {\n            mesh.mBones[_a] = new aiBone();\n            ReadBinaryBone(stream, mesh.mBones[_a]);\n          }\n        }\n      }\n      function ReadBinaryMaterialProperty(stream, prop) {\n        var chunkID = Read_uint32_t(stream);\n        ai_assert(chunkID == ASSBIN_CHUNK_AIMATERIALPROPERTY);\n        Read_uint32_t(stream);\n        prop.mKey = Read_aiString(stream);\n        prop.mSemantic = Read_unsigned_int(stream);\n        prop.mIndex = Read_unsigned_int(stream);\n        prop.mDataLength = Read_unsigned_int(stream);\n        prop.mType = Read_unsigned_int(stream);\n        prop.mData = [];\n        stream.ReadBytes(prop.mData, 1, prop.mDataLength);\n      }\n      function ReadBinaryMaterial(stream, mat) {\n        var chunkID = Read_uint32_t(stream);\n        ai_assert(chunkID == ASSBIN_CHUNK_AIMATERIAL);\n        Read_uint32_t(stream);\n        mat.mNumAllocated = mat.mNumProperties = Read_unsigned_int(stream);\n        if (mat.mNumProperties) {\n          if (mat.mProperties) {\n            delete mat.mProperties;\n          }\n          mat.mProperties = [];\n          for (var i = 0; i < mat.mNumProperties; ++i) {\n            mat.mProperties[i] = new aiMaterialProperty();\n            ReadBinaryMaterialProperty(stream, mat.mProperties[i]);\n          }\n        }\n      }\n      function ReadBinaryNodeAnim(stream, nd) {\n        var chunkID = Read_uint32_t(stream);\n        ai_assert(chunkID == ASSBIN_CHUNK_AINODEANIM);\n        Read_uint32_t(stream);\n        nd.mNodeName = Read_aiString(stream);\n        nd.mNumPositionKeys = Read_unsigned_int(stream);\n        nd.mNumRotationKeys = Read_unsigned_int(stream);\n        nd.mNumScalingKeys = Read_unsigned_int(stream);\n        nd.mPreState = Read_unsigned_int(stream);\n        nd.mPostState = Read_unsigned_int(stream);\n        if (nd.mNumPositionKeys) {\n          if (shortened) {\n            ReadBounds(stream, nd.mPositionKeys, nd.mNumPositionKeys);\n          } else {\n            nd.mPositionKeys = [];\n            ReadArray_aiVectorKey(stream, nd.mPositionKeys, nd.mNumPositionKeys);\n          }\n        }\n        if (nd.mNumRotationKeys) {\n          if (shortened) {\n            ReadBounds(stream, nd.mRotationKeys, nd.mNumRotationKeys);\n          } else {\n            nd.mRotationKeys = [];\n            ReadArray_aiQuatKey(stream, nd.mRotationKeys, nd.mNumRotationKeys);\n          }\n        }\n        if (nd.mNumScalingKeys) {\n          if (shortened) {\n            ReadBounds(stream, nd.mScalingKeys, nd.mNumScalingKeys);\n          } else {\n            nd.mScalingKeys = [];\n            ReadArray_aiVectorKey(stream, nd.mScalingKeys, nd.mNumScalingKeys);\n          }\n        }\n      }\n      function ReadBinaryAnim(stream, anim) {\n        var chunkID = Read_uint32_t(stream);\n        ai_assert(chunkID == ASSBIN_CHUNK_AIANIMATION);\n        Read_uint32_t(stream);\n        anim.mName = Read_aiString(stream);\n        anim.mDuration = Read_double(stream);\n        anim.mTicksPerSecond = Read_double(stream);\n        anim.mNumChannels = Read_unsigned_int(stream);\n        if (anim.mNumChannels) {\n          anim.mChannels = [];\n          for (var a = 0; a < anim.mNumChannels; ++a) {\n            anim.mChannels[a] = new aiNodeAnim();\n            ReadBinaryNodeAnim(stream, anim.mChannels[a]);\n          }\n        }\n      }\n      function ReadBinaryTexture(stream, tex) {\n        var chunkID = Read_uint32_t(stream);\n        ai_assert(chunkID == ASSBIN_CHUNK_AITEXTURE);\n        Read_uint32_t(stream);\n        tex.mWidth = Read_unsigned_int(stream);\n        tex.mHeight = Read_unsigned_int(stream);\n        stream.ReadBytes(tex.achFormatHint, 1, 4);\n        if (!shortened) {\n          if (!tex.mHeight) {\n            tex.pcData = [];\n            stream.ReadBytes(tex.pcData, 1, tex.mWidth);\n          } else {\n            tex.pcData = [];\n            stream.ReadBytes(tex.pcData, 1, tex.mWidth * tex.mHeight * 4);\n          }\n        }\n      }\n      function ReadBinaryLight(stream, l) {\n        var chunkID = Read_uint32_t(stream);\n        ai_assert(chunkID == ASSBIN_CHUNK_AILIGHT);\n        Read_uint32_t(stream);\n        l.mName = Read_aiString(stream);\n        l.mType = Read_unsigned_int(stream);\n        if (l.mType != aiLightSource_DIRECTIONAL) {\n          l.mAttenuationConstant = readFloat(stream);\n          l.mAttenuationLinear = readFloat(stream);\n          l.mAttenuationQuadratic = readFloat(stream);\n        }\n        l.mColorDiffuse = Read_aiColor3D(stream);\n        l.mColorSpecular = Read_aiColor3D(stream);\n        l.mColorAmbient = Read_aiColor3D(stream);\n        if (l.mType == aiLightSource_SPOT) {\n          l.mAngleInnerCone = readFloat(stream);\n          l.mAngleOuterCone = readFloat(stream);\n        }\n      }\n      function ReadBinaryCamera(stream, cam) {\n        var chunkID = Read_uint32_t(stream);\n        ai_assert(chunkID == ASSBIN_CHUNK_AICAMERA);\n        Read_uint32_t(stream);\n        cam.mName = Read_aiString(stream);\n        cam.mPosition = Read_aiVector3D(stream);\n        cam.mLookAt = Read_aiVector3D(stream);\n        cam.mUp = Read_aiVector3D(stream);\n        cam.mHorizontalFOV = readFloat(stream);\n        cam.mClipPlaneNear = readFloat(stream);\n        cam.mClipPlaneFar = readFloat(stream);\n        cam.mAspect = readFloat(stream);\n      }\n      function ReadBinaryScene(stream, scene) {\n        var chunkID = Read_uint32_t(stream);\n        ai_assert(chunkID == ASSBIN_CHUNK_AISCENE);\n        Read_uint32_t(stream);\n        scene.mFlags = Read_unsigned_int(stream);\n        scene.mNumMeshes = Read_unsigned_int(stream);\n        scene.mNumMaterials = Read_unsigned_int(stream);\n        scene.mNumAnimations = Read_unsigned_int(stream);\n        scene.mNumTextures = Read_unsigned_int(stream);\n        scene.mNumLights = Read_unsigned_int(stream);\n        scene.mNumCameras = Read_unsigned_int(stream);\n        scene.mRootNode = new aiNode();\n        scene.mRootNode = ReadBinaryNode(stream, null, 0);\n        if (scene.mNumMeshes) {\n          scene.mMeshes = [];\n          for (var i = 0; i < scene.mNumMeshes; ++i) {\n            scene.mMeshes[i] = new aiMesh();\n            ReadBinaryMesh(stream, scene.mMeshes[i]);\n          }\n        }\n        if (scene.mNumMaterials) {\n          scene.mMaterials = [];\n          for (var _i8 = 0; _i8 < scene.mNumMaterials; ++_i8) {\n            scene.mMaterials[_i8] = new aiMaterial();\n            ReadBinaryMaterial(stream, scene.mMaterials[_i8]);\n          }\n        }\n        if (scene.mNumAnimations) {\n          scene.mAnimations = [];\n          for (var _i9 = 0; _i9 < scene.mNumAnimations; ++_i9) {\n            scene.mAnimations[_i9] = new aiAnimation();\n            ReadBinaryAnim(stream, scene.mAnimations[_i9]);\n          }\n        }\n        if (scene.mNumTextures) {\n          scene.mTextures = [];\n          for (var _i10 = 0; _i10 < scene.mNumTextures; ++_i10) {\n            scene.mTextures[_i10] = new aiTexture();\n            ReadBinaryTexture(stream, scene.mTextures[_i10]);\n          }\n        }\n        if (scene.mNumLights) {\n          scene.mLights = [];\n          for (var _i11 = 0; _i11 < scene.mNumLights; ++_i11) {\n            scene.mLights[_i11] = new aiLight();\n            ReadBinaryLight(stream, scene.mLights[_i11]);\n          }\n        }\n        if (scene.mNumCameras) {\n          scene.mCameras = [];\n          for (var _i12 = 0; _i12 < scene.mNumCameras; ++_i12) {\n            scene.mCameras[_i12] = new aiCamera();\n            ReadBinaryCamera(stream, scene.mCameras[_i12]);\n          }\n        }\n      }\n      var aiOrigin_CUR = 0;\n      var aiOrigin_BEG = 1;\n      function extendStream(stream) {\n        stream.readOffset = 0;\n        stream.Seek = function (off, ori) {\n          if (ori == aiOrigin_CUR) {\n            stream.readOffset += off;\n          }\n          if (ori == aiOrigin_BEG) {\n            stream.readOffset = off;\n          }\n        };\n        stream.ReadBytes = function (buff, size, n) {\n          var bytes = size * n;\n          for (var i = 0; i < bytes; i++) buff[i] = Read_uint8_t(this);\n        };\n        stream.subArray32 = function (start, end) {\n          var buff = this.buffer;\n          var newbuff = buff.slice(start, end);\n          return new Float32Array(newbuff);\n        };\n        stream.subArrayUint16 = function (start, end) {\n          var buff = this.buffer;\n          var newbuff = buff.slice(start, end);\n          return new Uint16Array(newbuff);\n        };\n        stream.subArrayUint8 = function (start, end) {\n          var buff = this.buffer;\n          var newbuff = buff.slice(start, end);\n          return new Uint8Array(newbuff);\n        };\n        stream.subArrayUint32 = function (start, end) {\n          var buff = this.buffer;\n          var newbuff = buff.slice(start, end);\n          return new Uint32Array(newbuff);\n        };\n      }\n      var shortened, compressed;\n      function InternReadFile(pFiledata) {\n        var pScene = new aiScene();\n        var stream = new DataView(pFiledata);\n        extendStream(stream);\n        stream.Seek(44, aiOrigin_CUR);\n        pScene.versionMajor = Read_unsigned_int(stream);\n        pScene.versionMinor = Read_unsigned_int(stream);\n        pScene.versionRevision = Read_unsigned_int(stream);\n        pScene.compileFlags = Read_unsigned_int(stream);\n        shortened = Read_uint16_t(stream) > 0;\n        compressed = Read_uint16_t(stream) > 0;\n        if (shortened) throw \"Shortened binaries are not supported!\";\n        stream.Seek(256, aiOrigin_CUR);\n        stream.Seek(128, aiOrigin_CUR);\n        stream.Seek(64, aiOrigin_CUR);\n        if (compressed) {\n          var uncompressedSize = Read_uint32_t(stream);\n          var compressedSize = stream.FileSize() - stream.Tell();\n          var compressedData = [];\n          stream.Read(compressedData, 1, compressedSize);\n          var uncompressedData = [];\n          uncompress(uncompressedData, uncompressedSize, compressedData, compressedSize);\n          var buff = new ArrayBuffer(uncompressedData);\n          ReadBinaryScene(buff, pScene);\n        } else {\n          ReadBinaryScene(stream, pScene);\n        }\n        return pScene.toTHREE();\n      }\n      return InternReadFile(buffer);\n    }\n  }]);\n  return AssimpLoader;\n}(Loader);\nexport { AssimpLoader };","map":{"version":3,"names":["AssimpLoader","_Loader","_inherits","_super","_createSuper","_classCallCheck","apply","arguments","_createClass","key","value","load","url","onLoad","onProgress","onError","scope","path","LoaderUtils","extractUrlBase","loader","FileLoader","manager","setPath","setResponseType","setRequestHeader","requestHeader","setWithCredentials","withCredentials","buffer","parse","e","console","error","itemError","textureLoader","TextureLoader","resourcePath","setCrossOrigin","crossOrigin","Virtulous","KeyFrame","_class","time","matrix","clone","position","Vector3","quaternion","Quaternion","scale","decompose","n","lerp","nextKey","time2","dist","l","l2","keypos","keyrot","key2pos","key2rot","tempAniPos","x","y","z","tempAniQuat","set","w","slerp","tempAniMatrix","compose","tempAniScale","Matrix4","KeyFrameTrack","keys","target","length","_accelTable","fps","addKey","push","init","sortKeys","j","i","parseFromThree","data","node","track","hierarchy","targets","parseFromCollada","sort","keySortFunc","a","b","t","reTarget","root","compareitor","TrackTargetNodeNameCompare","keySearchAccel","Math","floor","setTime","abs","key0","key1","matrixAutoUpdate","copy","matrixWorldNeedsUpdate","find","name","children","r","Animation","tracks","addTrack","max","ASSBIN_CHUNK_AICAMERA","ASSBIN_CHUNK_AILIGHT","ASSBIN_CHUNK_AITEXTURE","ASSBIN_CHUNK_AIMESH","ASSBIN_CHUNK_AINODEANIM","ASSBIN_CHUNK_AISCENE","ASSBIN_CHUNK_AIBONE","ASSBIN_CHUNK_AIANIMATION","ASSBIN_CHUNK_AINODE","ASSBIN_CHUNK_AIMATERIAL","ASSBIN_CHUNK_AIMATERIALPROPERTY","ASSBIN_MESH_HAS_POSITIONS","ASSBIN_MESH_HAS_NORMALS","ASSBIN_MESH_HAS_TANGENTS_AND_BITANGENTS","ASSBIN_MESH_HAS_TEXCOORD_BASE","ASSBIN_MESH_HAS_COLOR_BASE","AI_MAX_NUMBER_OF_COLOR_SETS","AI_MAX_NUMBER_OF_TEXTURECOORDS","aiLightSource_DIRECTIONAL","aiLightSource_SPOT","aiTextureType_DIFFUSE","aiTextureType_NORMALS","aiTextureType_OPACITY","aiTextureType_LIGHTMAP","BONESPERVERT","ASSBIN_MESH_HAS_TEXCOORD","ASSBIN_MESH_HAS_COLOR","markBones","scene","mMeshes","mesh","k","mBones","boneNode","findNode","mName","isBone","cloneTreeToBones","rootBone","Bone","matrixWorld","nodeCount","toString","nodeToBoneMap","child","add","sortWeights","indexes","weights","pairs","sum","sqrt","findMatchingBone","indexOf","ret","aiMesh","mPrimitiveTypes","mNumVertices","mNumFaces","mNumBones","mMaterialIndex","mVertices","mNormals","mTangents","mBitangents","mColors","mTextureCoords","mFaces","hookupSkeletons","allBones","offsetMatrix","skeletonRoot","mParent","threeSkeletonRoot","toTHREE","threeSkeletonRootBone","threeNode","bone","tbone","mOffsetMatrix","skeleton","Skeleton","bind","material","skinning","geometry","BufferGeometry","mat","mMaterials","MeshLambertMaterial","setIndex","BufferAttribute","Uint32Array","mIndexArray","setAttribute","mVertexBuffer","mNormalBuffer","mColorBuffer","mTexCoordsBuffers","Float32Array","mTangentBuffer","mBitangentBuffer","bones","mWeights","weight","mVertexId","mWeight","parseInt","_weights","_bones","Mesh","SkinnedMesh","normalizeSkinWeights","aiFace","mNumIndices","mIndices","aiVector3D","aiColor3D","g","Color","aiQuaternion","aiVertexWeight","aiString","str","forEach","String","fromCharCode","replace","aiVectorKey","mTime","mValue","aiQuatKey","aiNode","mTransformation","mNumChildren","mNumMeshes","mChildren","o","Object3D","aiBone","mNumWeights","aiMaterialProperty","mKey","mSemantic","mIndex","mData","mDataLength","mType","dataAsColor","array","Uint8Array","reader","DataView","getFloat32","dataAsFloat","dataAsBool","dataAsString","s","dataAsMap","path2","substr","lastIndexOf","namePropMapping","nameTypeMapping","aiMaterial","mNumAllocated","mNumProperties","mProperties","MeshPhongMaterial","prop","map","normalMap","lightMap","alphaMap","ambient","color","veclerp","v1","v2","v","lm1","quatlerp","q1","q2","sampleTrack","lne","Infinity","timeDist","dT","T","aiNodeAnim","mNodeName","mNumPositionKeys","mNumRotationKeys","mNumScalingKeys","mPositionKeys","mRotationKeys","mScalingKeys","mPreState","mPostState","tps","t2","comp","getLength","pos","rotation","aiAnimation","mDuration","mTicksPerSecond","mNumChannels","mChannels","animationHandle","aiTexture","mWidth","mHeight","texAchFormatHint","pcData","aiLight","mAttenuationConstant","mAttenuationLinear","mAttenuationQuadratic","mAngleInnerCone","mAngleOuterCone","mColorDiffuse","mColorSpecular","mColorAmbient","aiCamera","mPosition","mLookAt","mUp","mHorizontalFOV","mClipPlaneNear","mClipPlaneFar","mAspect","aiScene","versionMajor","versionMinor","versionRevision","compileFlags","mFlags","mNumMaterials","mNumAnimations","mNumTextures","mNumLights","mNumCameras","mRootNode","mAnimations","mLights","mCameras","object","animation","aiMatrix4","elements","m","i2","littleEndian","readFloat","dataview","val","readOffset","Read_double","getFloat64","Read_uint8_t","getUint8","Read_uint16_t","getUint16","Read_unsigned_int","getUint32","Read_uint32_t","Read_aiVector3D","stream","Read_aiColor3D","c","Read_aiQuaternion","Read_aiString","stringlengthbytes","ReadBytes","Read_aiVertexWeight","Read_aiMatrix4x4","Read_aiVectorKey","Read_aiQuatKey","ReadArray_aiVertexWeight","size","ReadArray_aiVectorKey","ReadArray_aiQuatKey","ReadBounds","Seek","sizeof","aiOrigin_CUR","ai_assert","bool","ReadBinaryNode","parent","depth","chunkID","mDepth","node2","ReadBinaryBone","shortened","ReadBinaryMesh","mNumUVComponents","subArray32","uv","f","Error","ReadBinaryMaterialProperty","ReadBinaryMaterial","ReadBinaryNodeAnim","nd","ReadBinaryAnim","anim","ReadBinaryTexture","tex","achFormatHint","ReadBinaryLight","ReadBinaryCamera","cam","ReadBinaryScene","mTextures","aiOrigin_BEG","extendStream","off","ori","buff","bytes","start","end","newbuff","slice","subArrayUint16","Uint16Array","subArrayUint8","subArrayUint32","compressed","InternReadFile","pFiledata","pScene","uncompressedSize","compressedSize","FileSize","Tell","compressedData","Read","uncompressedData","uncompress","ArrayBuffer","Loader"],"sources":["C:\\Users\\Nayyu\\Desktop\\skibidai-public-build\\node_modules\\src\\loaders\\AssimpLoader.js"],"sourcesContent":["import {\n  Bone,\n  BufferAttribute,\n  BufferGeometry,\n  Color,\n  FileLoader,\n  Loader,\n  LoaderUtils,\n  Matrix4,\n  Mesh,\n  MeshLambertMaterial,\n  MeshPhongMaterial,\n  Object3D,\n  Quaternion,\n  Skeleton,\n  SkinnedMesh,\n  TextureLoader,\n  Vector3,\n} from 'three'\n\nclass AssimpLoader extends Loader {\n  load(url, onLoad, onProgress, onError) {\n    var scope = this\n\n    var path = scope.path === '' ? LoaderUtils.extractUrlBase(url) : scope.path\n\n    var loader = new FileLoader(scope.manager)\n    loader.setPath(scope.path)\n    loader.setResponseType('arraybuffer')\n    loader.setRequestHeader(scope.requestHeader)\n    loader.setWithCredentials(scope.withCredentials)\n\n    loader.load(\n      url,\n      function (buffer) {\n        try {\n          onLoad(scope.parse(buffer, path))\n        } catch (e) {\n          if (onError) {\n            onError(e)\n          } else {\n            console.error(e)\n          }\n\n          scope.manager.itemError(url)\n        }\n      },\n      onProgress,\n      onError,\n    )\n  }\n\n  parse(buffer, path) {\n    var textureLoader = new TextureLoader(this.manager)\n    textureLoader.setPath(this.resourcePath || path).setCrossOrigin(this.crossOrigin)\n\n    var Virtulous = {}\n\n    Virtulous.KeyFrame = class {\n      constructor(time, matrix) {\n        this.time = time\n        this.matrix = matrix.clone()\n        this.position = new Vector3()\n        this.quaternion = new Quaternion()\n        this.scale = new Vector3(1, 1, 1)\n        this.matrix.decompose(this.position, this.quaternion, this.scale)\n        this.clone = function () {\n          var n = new Virtulous.KeyFrame(this.time, this.matrix)\n          return n\n        }\n\n        this.lerp = function (nextKey, time) {\n          time -= this.time\n          var dist = nextKey.time - this.time\n          var l = time / dist\n          var l2 = 1 - l\n          var keypos = this.position\n          var keyrot = this.quaternion\n          //      var keyscl =  key.parentspaceScl || key.scl;\n          var key2pos = nextKey.position\n          var key2rot = nextKey.quaternion\n          //  var key2scl =  key2.parentspaceScl || key2.scl;\n          Virtulous.KeyFrame.tempAniPos.x = keypos.x * l2 + key2pos.x * l\n          Virtulous.KeyFrame.tempAniPos.y = keypos.y * l2 + key2pos.y * l\n          Virtulous.KeyFrame.tempAniPos.z = keypos.z * l2 + key2pos.z * l\n          //     tempAniScale.x = keyscl[0] * l2 + key2scl[0] * l;\n          //     tempAniScale.y = keyscl[1] * l2 + key2scl[1] * l;\n          //     tempAniScale.z = keyscl[2] * l2 + key2scl[2] * l;\n          Virtulous.KeyFrame.tempAniQuat.set(keyrot.x, keyrot.y, keyrot.z, keyrot.w)\n          Virtulous.KeyFrame.tempAniQuat.slerp(key2rot, l)\n          return Virtulous.KeyFrame.tempAniMatrix.compose(\n            Virtulous.KeyFrame.tempAniPos,\n            Virtulous.KeyFrame.tempAniQuat,\n            Virtulous.KeyFrame.tempAniScale,\n          )\n        }\n      }\n    }\n\n    Virtulous.KeyFrame.tempAniPos = new Vector3()\n    Virtulous.KeyFrame.tempAniQuat = new Quaternion()\n    Virtulous.KeyFrame.tempAniScale = new Vector3(1, 1, 1)\n    Virtulous.KeyFrame.tempAniMatrix = new Matrix4()\n    Virtulous.KeyFrameTrack = function () {\n      this.keys = []\n      this.target = null\n      this.time = 0\n      this.length = 0\n      this._accelTable = {}\n      this.fps = 20\n      this.addKey = function (key) {\n        this.keys.push(key)\n      }\n\n      this.init = function () {\n        this.sortKeys()\n\n        if (this.keys.length > 0) this.length = this.keys[this.keys.length - 1].time\n        else this.length = 0\n\n        if (!this.fps) return\n\n        for (let j = 0; j < this.length * this.fps; j++) {\n          for (let i = 0; i < this.keys.length; i++) {\n            if (this.keys[i].time == j) {\n              this._accelTable[j] = i\n              break\n            } else if (this.keys[i].time < j / this.fps && this.keys[i + 1] && this.keys[i + 1].time >= j / this.fps) {\n              this._accelTable[j] = i\n              break\n            }\n          }\n        }\n      }\n\n      this.parseFromThree = function (data) {\n        var fps = data.fps\n        this.target = data.node\n        var track = data.hierarchy[0].keys\n        for (let i = 0; i < track.length; i++) {\n          this.addKey(new Virtulous.KeyFrame(i / fps || track[i].time, track[i].targets[0].data))\n        }\n\n        this.init()\n      }\n\n      this.parseFromCollada = function (data) {\n        var track = data.keys\n        var fps = this.fps\n\n        for (let i = 0; i < track.length; i++) {\n          this.addKey(new Virtulous.KeyFrame(i / fps || track[i].time, track[i].matrix))\n        }\n\n        this.init()\n      }\n\n      this.sortKeys = function () {\n        this.keys.sort(this.keySortFunc)\n      }\n\n      this.keySortFunc = function (a, b) {\n        return a.time - b.time\n      }\n\n      this.clone = function () {\n        var t = new Virtulous.KeyFrameTrack()\n        t.target = this.target\n        t.time = this.time\n        t.length = this.length\n\n        for (let i = 0; i < this.keys.length; i++) {\n          t.addKey(this.keys[i].clone())\n        }\n\n        t.init()\n        return t\n      }\n\n      this.reTarget = function (root, compareitor) {\n        if (!compareitor) compareitor = Virtulous.TrackTargetNodeNameCompare\n        this.target = compareitor(root, this.target)\n      }\n\n      this.keySearchAccel = function (time) {\n        time *= this.fps\n        time = Math.floor(time)\n        return this._accelTable[time] || 0\n      }\n\n      this.setTime = function (time) {\n        time = Math.abs(time)\n        if (this.length) time = (time % this.length) + 0.05\n        var key0 = null\n        var key1 = null\n\n        for (let i = this.keySearchAccel(time); i < this.keys.length; i++) {\n          if (this.keys[i].time == time) {\n            key0 = this.keys[i]\n            key1 = this.keys[i]\n            break\n          } else if (this.keys[i].time < time && this.keys[i + 1] && this.keys[i + 1].time > time) {\n            key0 = this.keys[i]\n            key1 = this.keys[i + 1]\n            break\n          } else if (this.keys[i].time < time && i == this.keys.length - 1) {\n            key0 = this.keys[i]\n            key1 = this.keys[0].clone()\n            key1.time += this.length + 0.05\n            break\n          }\n        }\n\n        if (key0 && key1 && key0 !== key1) {\n          this.target.matrixAutoUpdate = false\n          this.target.matrix.copy(key0.lerp(key1, time))\n          this.target.matrixWorldNeedsUpdate = true\n          return\n        }\n\n        if (key0 && key1 && key0 == key1) {\n          this.target.matrixAutoUpdate = false\n          this.target.matrix.copy(key0.matrix)\n          this.target.matrixWorldNeedsUpdate = true\n          return\n        }\n      }\n    }\n\n    Virtulous.TrackTargetNodeNameCompare = function (root, target) {\n      function find(node, name) {\n        if (node.name == name) return node\n\n        for (let i = 0; i < node.children.length; i++) {\n          var r = find(node.children[i], name)\n          if (r) return r\n        }\n\n        return null\n      }\n\n      return find(root, target.name)\n    }\n\n    Virtulous.Animation = function () {\n      this.tracks = []\n      this.length = 0\n\n      this.addTrack = function (track) {\n        this.tracks.push(track)\n        this.length = Math.max(track.length, this.length)\n      }\n\n      this.setTime = function (time) {\n        this.time = time\n\n        for (let i = 0; i < this.tracks.length; i++) this.tracks[i].setTime(time)\n      }\n\n      this.clone = function (target, compareitor) {\n        if (!compareitor) compareitor = Virtulous.TrackTargetNodeNameCompare\n        var n = new Virtulous.Animation()\n        n.target = target\n        for (let i = 0; i < this.tracks.length; i++) {\n          var track = this.tracks[i].clone()\n          track.reTarget(target, compareitor)\n          n.addTrack(track)\n        }\n\n        return n\n      }\n    }\n\n    var ASSBIN_CHUNK_AICAMERA = 0x1234\n    var ASSBIN_CHUNK_AILIGHT = 0x1235\n    var ASSBIN_CHUNK_AITEXTURE = 0x1236\n    var ASSBIN_CHUNK_AIMESH = 0x1237\n    var ASSBIN_CHUNK_AINODEANIM = 0x1238\n    var ASSBIN_CHUNK_AISCENE = 0x1239\n    var ASSBIN_CHUNK_AIBONE = 0x123a\n    var ASSBIN_CHUNK_AIANIMATION = 0x123b\n    var ASSBIN_CHUNK_AINODE = 0x123c\n    var ASSBIN_CHUNK_AIMATERIAL = 0x123d\n    var ASSBIN_CHUNK_AIMATERIALPROPERTY = 0x123e\n    var ASSBIN_MESH_HAS_POSITIONS = 0x1\n    var ASSBIN_MESH_HAS_NORMALS = 0x2\n    var ASSBIN_MESH_HAS_TANGENTS_AND_BITANGENTS = 0x4\n    var ASSBIN_MESH_HAS_TEXCOORD_BASE = 0x100\n    var ASSBIN_MESH_HAS_COLOR_BASE = 0x10000\n    var AI_MAX_NUMBER_OF_COLOR_SETS = 1\n    var AI_MAX_NUMBER_OF_TEXTURECOORDS = 4\n    //var aiLightSource_UNDEFINED = 0x0;\n    //! A directional light source has a well-defined direction\n    //! but is infinitely far away. That's quite a good\n    //! approximation for sun light.\n    var aiLightSource_DIRECTIONAL = 0x1\n    //! A point light source has a well-defined position\n    //! in space but no direction - it emits light in all\n    //! directions. A normal bulb is a point light.\n    //var aiLightSource_POINT = 0x2;\n    //! A spot light source emits light in a specific\n    //! angle. It has a position and a direction it is pointing to.\n    //! A good example for a spot light is a light spot in\n    //! sport arenas.\n    var aiLightSource_SPOT = 0x3\n    //! The generic light level of the world, including the bounces\n    //! of all other lightsources.\n    //! Typically, there's at most one ambient light in a scene.\n    //! This light type doesn't have a valid position, direction, or\n    //! other properties, just a color.\n    //var aiLightSource_AMBIENT = 0x4;\n    /** Flat shading. Shading is done on per-face base,\n     *  diffuse only. Also known as 'faceted shading'.\n     */\n    //var aiShadingMode_Flat = 0x1;\n    /** Simple Gouraud shading.\n     */\n    //var aiShadingMode_Gouraud = 0x2;\n    /** Phong-Shading -\n     */\n    //var aiShadingMode_Phong = 0x3;\n    /** Phong-Blinn-Shading\n     */\n    //var aiShadingMode_Blinn = 0x4;\n    /** Toon-Shading per pixel\n     *\n     *  Also known as 'comic' shader.\n     */\n    //var aiShadingMode_Toon = 0x5;\n    /** OrenNayar-Shading per pixel\n     *\n     *  Extension to standard Lambertian shading, taking the\n     *  roughness of the material into account\n     */\n    //var aiShadingMode_OrenNayar = 0x6;\n    /** Minnaert-Shading per pixel\n     *\n     *  Extension to standard Lambertian shading, taking the\n     *  \"darkness\" of the material into account\n     */\n    //var aiShadingMode_Minnaert = 0x7;\n    /** CookTorrance-Shading per pixel\n     *\n     *  Special shader for metallic surfaces.\n     */\n    //var aiShadingMode_CookTorrance = 0x8;\n    /** No shading at all. Constant light influence of 1.0.\n     */\n    //var aiShadingMode_NoShading = 0x9;\n    /** Fresnel shading\n     */\n    //var aiShadingMode_Fresnel = 0xa;\n    //var aiTextureType_NONE = 0x0;\n    /** The texture is combined with the result of the diffuse\n     *  lighting equation.\n     */\n    var aiTextureType_DIFFUSE = 0x1\n    /** The texture is combined with the result of the specular\n     *  lighting equation.\n     */\n    //var aiTextureType_SPECULAR = 0x2;\n    /** The texture is combined with the result of the ambient\n     *  lighting equation.\n     */\n    //var aiTextureType_AMBIENT = 0x3;\n    /** The texture is added to the result of the lighting\n     *  calculation. It isn't influenced by incoming light.\n     */\n    //var aiTextureType_EMISSIVE = 0x4;\n    /** The texture is a height map.\n     *\n     *  By convention, higher gray-scale values stand for\n     *  higher elevations from the base height.\n     */\n    //var aiTextureType_HEIGHT = 0x5;\n    /** The texture is a (tangent space) normal-map.\n     *\n     *  Again, there are several conventions for tangent-space\n     *  normal maps. Assimp does (intentionally) not\n     *  distinguish here.\n     */\n    var aiTextureType_NORMALS = 0x6\n    /** The texture defines the glossiness of the material.\n     *\n     *  The glossiness is in fact the exponent of the specular\n     *  (phong) lighting equation. Usually there is a conversion\n     *  function defined to map the linear color values in the\n     *  texture to a suitable exponent. Have fun.\n     */\n    //var aiTextureType_SHININESS = 0x7;\n    /** The texture defines per-pixel opacity.\n     *\n     *  Usually 'white' means opaque and 'black' means\n     *  'transparency'. Or quite the opposite. Have fun.\n     */\n    var aiTextureType_OPACITY = 0x8\n    /** Displacement texture\n     *\n     *  The exact purpose and format is application-dependent.\n     *  Higher color values stand for higher vertex displacements.\n     */\n    //var aiTextureType_DISPLACEMENT = 0x9;\n    /** Lightmap texture (aka Ambient Occlusion)\n     *\n     *  Both 'Lightmaps' and dedicated 'ambient occlusion maps' are\n     *  covered by this material property. The texture contains a\n     *  scaling value for the final color value of a pixel. Its\n     *  intensity is not affected by incoming light.\n     */\n    var aiTextureType_LIGHTMAP = 0xa\n    /** Reflection texture\n     *\n     * Contains the color of a perfect mirror reflection.\n     * Rarely used, almost never for real-time applications.\n     */\n    //var aiTextureType_REFLECTION = 0xB;\n    /** Unknown texture\n     *\n     *  A texture reference that does not match any of the definitions\n     *  above is considered to be 'unknown'. It is still imported,\n     *  but is excluded from any further postprocessing.\n     */\n    //var aiTextureType_UNKNOWN = 0xC;\n    var BONESPERVERT = 4\n\n    function ASSBIN_MESH_HAS_TEXCOORD(n) {\n      return ASSBIN_MESH_HAS_TEXCOORD_BASE << n\n    }\n\n    function ASSBIN_MESH_HAS_COLOR(n) {\n      return ASSBIN_MESH_HAS_COLOR_BASE << n\n    }\n\n    function markBones(scene) {\n      for (let i in scene.mMeshes) {\n        var mesh = scene.mMeshes[i]\n        for (let k in mesh.mBones) {\n          var boneNode = scene.findNode(mesh.mBones[k].mName)\n          if (boneNode) boneNode.isBone = true\n        }\n      }\n    }\n\n    function cloneTreeToBones(root, scene) {\n      var rootBone = new Bone()\n      rootBone.matrix.copy(root.matrix)\n      rootBone.matrixWorld.copy(root.matrixWorld)\n      rootBone.position.copy(root.position)\n      rootBone.quaternion.copy(root.quaternion)\n      rootBone.scale.copy(root.scale)\n      scene.nodeCount++\n      rootBone.name = 'bone_' + root.name + scene.nodeCount.toString()\n\n      if (!scene.nodeToBoneMap[root.name]) scene.nodeToBoneMap[root.name] = []\n      scene.nodeToBoneMap[root.name].push(rootBone)\n      for (let i in root.children) {\n        var child = cloneTreeToBones(root.children[i], scene)\n        rootBone.add(child)\n      }\n\n      return rootBone\n    }\n\n    function sortWeights(indexes, weights) {\n      var pairs = []\n\n      for (let i = 0; i < indexes.length; i++) {\n        pairs.push({\n          i: indexes[i],\n          w: weights[i],\n        })\n      }\n\n      pairs.sort(function (a, b) {\n        return b.w - a.w\n      })\n\n      while (pairs.length < 4) {\n        pairs.push({\n          i: 0,\n          w: 0,\n        })\n      }\n\n      if (pairs.length > 4) pairs.length = 4\n      var sum = 0\n\n      for (let i = 0; i < 4; i++) {\n        sum += pairs[i].w * pairs[i].w\n      }\n\n      sum = Math.sqrt(sum)\n\n      for (let i = 0; i < 4; i++) {\n        pairs[i].w = pairs[i].w / sum\n        indexes[i] = pairs[i].i\n        weights[i] = pairs[i].w\n      }\n    }\n\n    function findMatchingBone(root, name) {\n      if (root.name.indexOf('bone_' + name) == 0) return root\n\n      for (let i in root.children) {\n        var ret = findMatchingBone(root.children[i], name)\n\n        if (ret) return ret\n      }\n\n      return undefined\n    }\n\n    class aiMesh {\n      constructor() {\n        this.mPrimitiveTypes = 0\n        this.mNumVertices = 0\n        this.mNumFaces = 0\n        this.mNumBones = 0\n        this.mMaterialIndex = 0\n        this.mVertices = []\n        this.mNormals = []\n        this.mTangents = []\n        this.mBitangents = []\n        this.mColors = [[]]\n        this.mTextureCoords = [[]]\n        this.mFaces = []\n        this.mBones = []\n        this.hookupSkeletons = function (scene) {\n          if (this.mBones.length == 0) return\n\n          var allBones = []\n          var offsetMatrix = []\n          var skeletonRoot = scene.findNode(this.mBones[0].mName)\n\n          while (skeletonRoot.mParent && skeletonRoot.mParent.isBone) {\n            skeletonRoot = skeletonRoot.mParent\n          }\n\n          var threeSkeletonRoot = skeletonRoot.toTHREE(scene)\n          var threeSkeletonRootBone = cloneTreeToBones(threeSkeletonRoot, scene)\n          this.threeNode.add(threeSkeletonRootBone)\n\n          for (let i = 0; i < this.mBones.length; i++) {\n            var bone = findMatchingBone(threeSkeletonRootBone, this.mBones[i].mName)\n\n            if (bone) {\n              var tbone = bone\n              allBones.push(tbone)\n              //tbone.matrixAutoUpdate = false;\n              offsetMatrix.push(this.mBones[i].mOffsetMatrix.toTHREE())\n            } else {\n              var skeletonRoot = scene.findNode(this.mBones[i].mName)\n              if (!skeletonRoot) return\n              var threeSkeletonRoot = skeletonRoot.toTHREE(scene)\n              var threeSkeletonRootBone = cloneTreeToBones(threeSkeletonRoot, scene)\n              this.threeNode.add(threeSkeletonRootBone)\n              var bone = findMatchingBone(threeSkeletonRootBone, this.mBones[i].mName)\n              var tbone = bone\n              allBones.push(tbone)\n              //tbone.matrixAutoUpdate = false;\n              offsetMatrix.push(this.mBones[i].mOffsetMatrix.toTHREE())\n            }\n          }\n\n          var skeleton = new Skeleton(allBones, offsetMatrix)\n\n          this.threeNode.bind(skeleton, new Matrix4())\n          this.threeNode.material.skinning = true\n        }\n\n        this.toTHREE = function (scene) {\n          if (this.threeNode) return this.threeNode\n          var geometry = new BufferGeometry()\n          var mat\n          if (scene.mMaterials[this.mMaterialIndex]) mat = scene.mMaterials[this.mMaterialIndex].toTHREE(scene)\n          else mat = new MeshLambertMaterial()\n          geometry.setIndex(new BufferAttribute(new Uint32Array(this.mIndexArray), 1))\n          geometry.setAttribute('position', new BufferAttribute(this.mVertexBuffer, 3))\n          if (this.mNormalBuffer && this.mNormalBuffer.length > 0) {\n            geometry.setAttribute('normal', new BufferAttribute(this.mNormalBuffer, 3))\n          }\n          if (this.mColorBuffer && this.mColorBuffer.length > 0) {\n            geometry.setAttribute('color', new BufferAttribute(this.mColorBuffer, 4))\n          }\n          if (this.mTexCoordsBuffers[0] && this.mTexCoordsBuffers[0].length > 0) {\n            geometry.setAttribute('uv', new BufferAttribute(new Float32Array(this.mTexCoordsBuffers[0]), 2))\n          }\n          if (this.mTexCoordsBuffers[1] && this.mTexCoordsBuffers[1].length > 0) {\n            geometry.setAttribute('uv1', new BufferAttribute(new Float32Array(this.mTexCoordsBuffers[1]), 2))\n          }\n          if (this.mTangentBuffer && this.mTangentBuffer.length > 0) {\n            geometry.setAttribute('tangents', new BufferAttribute(this.mTangentBuffer, 3))\n          }\n          if (this.mBitangentBuffer && this.mBitangentBuffer.length > 0) {\n            geometry.setAttribute('bitangents', new BufferAttribute(this.mBitangentBuffer, 3))\n          }\n          if (this.mBones.length > 0) {\n            var weights = []\n            var bones = []\n\n            for (let i = 0; i < this.mBones.length; i++) {\n              for (let j = 0; j < this.mBones[i].mWeights.length; j++) {\n                var weight = this.mBones[i].mWeights[j]\n                if (weight) {\n                  if (!weights[weight.mVertexId]) weights[weight.mVertexId] = []\n                  if (!bones[weight.mVertexId]) bones[weight.mVertexId] = []\n                  weights[weight.mVertexId].push(weight.mWeight)\n                  bones[weight.mVertexId].push(parseInt(i))\n                }\n              }\n            }\n\n            for (let i in bones) {\n              sortWeights(bones[i], weights[i])\n            }\n\n            var _weights = []\n            var _bones = []\n\n            for (let i = 0; i < weights.length; i++) {\n              for (let j = 0; j < 4; j++) {\n                if (weights[i] && bones[i]) {\n                  _weights.push(weights[i][j])\n                  _bones.push(bones[i][j])\n                } else {\n                  _weights.push(0)\n                  _bones.push(0)\n                }\n              }\n            }\n\n            geometry.setAttribute('skinWeight', new BufferAttribute(new Float32Array(_weights), BONESPERVERT))\n            geometry.setAttribute('skinIndex', new BufferAttribute(new Float32Array(_bones), BONESPERVERT))\n          }\n\n          var mesh\n\n          if (this.mBones.length == 0) mesh = new Mesh(geometry, mat)\n\n          if (this.mBones.length > 0) {\n            mesh = new SkinnedMesh(geometry, mat)\n            mesh.normalizeSkinWeights()\n          }\n\n          this.threeNode = mesh\n          //mesh.matrixAutoUpdate = false;\n          return mesh\n        }\n      }\n    }\n\n    class aiFace {\n      constructor() {\n        this.mNumIndices = 0\n        this.mIndices = []\n      }\n    }\n\n    class aiVector3D {\n      constructor() {\n        this.x = 0\n        this.y = 0\n        this.z = 0\n\n        this.toTHREE = function () {\n          return new Vector3(this.x, this.y, this.z)\n        }\n      }\n    }\n\n    class aiColor3D {\n      constructor() {\n        this.r = 0\n        this.g = 0\n        this.b = 0\n        this.a = 0\n        this.toTHREE = function () {\n          return new Color(this.r, this.g, this.b)\n        }\n      }\n    }\n\n    class aiQuaternion {\n      constructor() {\n        this.x = 0\n        this.y = 0\n        this.z = 0\n        this.w = 0\n        this.toTHREE = function () {\n          return new Quaternion(this.x, this.y, this.z, this.w)\n        }\n      }\n    }\n\n    class aiVertexWeight {\n      constructor() {\n        this.mVertexId = 0\n        this.mWeight = 0\n      }\n    }\n\n    class aiString {\n      constructor() {\n        this.data = []\n        this.toString = function () {\n          var str = ''\n          this.data.forEach(function (i) {\n            str += String.fromCharCode(i)\n          })\n          return str.replace(/[^\\x20-\\x7E]+/g, '')\n        }\n      }\n    }\n\n    class aiVectorKey {\n      constructor() {\n        this.mTime = 0\n        this.mValue = null\n      }\n    }\n\n    class aiQuatKey {\n      constructor() {\n        this.mTime = 0\n        this.mValue = null\n      }\n    }\n\n    class aiNode {\n      constructor() {\n        this.mName = ''\n        this.mTransformation = []\n        this.mNumChildren = 0\n        this.mNumMeshes = 0\n        this.mMeshes = []\n        this.mChildren = []\n        this.toTHREE = function (scene) {\n          if (this.threeNode) return this.threeNode\n          var o = new Object3D()\n          o.name = this.mName\n          o.matrix = this.mTransformation.toTHREE()\n\n          for (let i = 0; i < this.mChildren.length; i++) {\n            o.add(this.mChildren[i].toTHREE(scene))\n          }\n\n          for (let i = 0; i < this.mMeshes.length; i++) {\n            o.add(scene.mMeshes[this.mMeshes[i]].toTHREE(scene))\n          }\n\n          this.threeNode = o\n          //o.matrixAutoUpdate = false;\n          o.matrix.decompose(o.position, o.quaternion, o.scale)\n          return o\n        }\n      }\n    }\n\n    class aiBone {\n      constructor() {\n        this.mName = ''\n        this.mNumWeights = 0\n        this.mOffsetMatrix = 0\n      }\n    }\n\n    class aiMaterialProperty {\n      constructor() {\n        this.mKey = ''\n        this.mSemantic = 0\n        this.mIndex = 0\n        this.mData = []\n        this.mDataLength = 0\n        this.mType = 0\n        this.dataAsColor = function () {\n          var array = new Uint8Array(this.mData).buffer\n          var reader = new DataView(array)\n          var r = reader.getFloat32(0, true)\n          var g = reader.getFloat32(4, true)\n          var b = reader.getFloat32(8, true)\n          //var a = reader.getFloat32(12, true);\n          return new Color(r, g, b)\n        }\n\n        this.dataAsFloat = function () {\n          var array = new Uint8Array(this.mData).buffer\n          var reader = new DataView(array)\n          var r = reader.getFloat32(0, true)\n          return r\n        }\n\n        this.dataAsBool = function () {\n          var array = new Uint8Array(this.mData).buffer\n          var reader = new DataView(array)\n          var r = reader.getFloat32(0, true)\n          return !!r\n        }\n\n        this.dataAsString = function () {\n          var s = new aiString()\n          s.data = this.mData\n          return s.toString()\n        }\n\n        this.dataAsMap = function () {\n          var s = new aiString()\n          s.data = this.mData\n          var path = s.toString()\n          path = path.replace(/\\\\/g, '/')\n\n          if (path.indexOf('/') != -1) {\n            path = path.substr(path.lastIndexOf('/') + 1)\n          }\n\n          return textureLoader.load(path)\n        }\n      }\n    }\n\n    var namePropMapping = {\n      '?mat.name': 'name',\n      '$mat.shadingm': 'shading',\n      '$mat.twosided': 'twoSided',\n      '$mat.wireframe': 'wireframe',\n      '$clr.ambient': 'ambient',\n      '$clr.diffuse': 'color',\n      '$clr.specular': 'specular',\n      '$clr.emissive': 'emissive',\n      '$clr.transparent': 'transparent',\n      '$clr.reflective': 'reflect',\n      '$mat.shininess': 'shininess',\n      '$mat.reflectivity': 'reflectivity',\n      '$mat.refracti': 'refraction',\n      '$tex.file': 'map',\n    }\n\n    var nameTypeMapping = {\n      '?mat.name': 'string',\n      '$mat.shadingm': 'bool',\n      '$mat.twosided': 'bool',\n      '$mat.wireframe': 'bool',\n      '$clr.ambient': 'color',\n      '$clr.diffuse': 'color',\n      '$clr.specular': 'color',\n      '$clr.emissive': 'color',\n      '$clr.transparent': 'color',\n      '$clr.reflective': 'color',\n      '$mat.shininess': 'float',\n      '$mat.reflectivity': 'float',\n      '$mat.refracti': 'float',\n      '$tex.file': 'map',\n    }\n\n    class aiMaterial {\n      constructor() {\n        this.mNumAllocated = 0\n        this.mNumProperties = 0\n        this.mProperties = []\n        this.toTHREE = function () {\n          var mat = new MeshPhongMaterial()\n\n          for (let i = 0; i < this.mProperties.length; i++) {\n            if (nameTypeMapping[this.mProperties[i].mKey] == 'float') {\n              mat[namePropMapping[this.mProperties[i].mKey]] = this.mProperties[i].dataAsFloat()\n            }\n            if (nameTypeMapping[this.mProperties[i].mKey] == 'color') {\n              mat[namePropMapping[this.mProperties[i].mKey]] = this.mProperties[i].dataAsColor()\n            }\n            if (nameTypeMapping[this.mProperties[i].mKey] == 'bool') {\n              mat[namePropMapping[this.mProperties[i].mKey]] = this.mProperties[i].dataAsBool()\n            }\n            if (nameTypeMapping[this.mProperties[i].mKey] == 'string') {\n              mat[namePropMapping[this.mProperties[i].mKey]] = this.mProperties[i].dataAsString()\n            }\n            if (nameTypeMapping[this.mProperties[i].mKey] == 'map') {\n              var prop = this.mProperties[i]\n              if (prop.mSemantic == aiTextureType_DIFFUSE) mat.map = this.mProperties[i].dataAsMap()\n              if (prop.mSemantic == aiTextureType_NORMALS) mat.normalMap = this.mProperties[i].dataAsMap()\n              if (prop.mSemantic == aiTextureType_LIGHTMAP) mat.lightMap = this.mProperties[i].dataAsMap()\n              if (prop.mSemantic == aiTextureType_OPACITY) mat.alphaMap = this.mProperties[i].dataAsMap()\n            }\n          }\n\n          mat.ambient.r = 0.53\n          mat.ambient.g = 0.53\n          mat.ambient.b = 0.53\n          mat.color.r = 1\n          mat.color.g = 1\n          mat.color.b = 1\n          return mat\n        }\n      }\n    }\n\n    function veclerp(v1, v2, l) {\n      var v = new Vector3()\n      var lm1 = 1 - l\n      v.x = v1.x * l + v2.x * lm1\n      v.y = v1.y * l + v2.y * lm1\n      v.z = v1.z * l + v2.z * lm1\n      return v\n    }\n\n    function quatlerp(q1, q2, l) {\n      return q1.clone().slerp(q2, 1 - l)\n    }\n\n    function sampleTrack(keys, time, lne, lerp) {\n      if (keys.length == 1) return keys[0].mValue.toTHREE()\n\n      var dist = Infinity\n      var key = null\n      var nextKey = null\n\n      for (let i = 0; i < keys.length; i++) {\n        var timeDist = Math.abs(keys[i].mTime - time)\n\n        if (timeDist < dist && keys[i].mTime <= time) {\n          dist = timeDist\n          key = keys[i]\n          nextKey = keys[i + 1]\n        }\n      }\n\n      if (!key) {\n        return null\n      } else if (nextKey) {\n        var dT = nextKey.mTime - key.mTime\n        var T = key.mTime - time\n        var l = T / dT\n\n        return lerp(key.mValue.toTHREE(), nextKey.mValue.toTHREE(), l)\n      } else {\n        nextKey = keys[0].clone()\n        nextKey.mTime += lne\n\n        var dT = nextKey.mTime - key.mTime\n        var T = key.mTime - time\n        var l = T / dT\n\n        return lerp(key.mValue.toTHREE(), nextKey.mValue.toTHREE(), l)\n      }\n    }\n\n    class aiNodeAnim {\n      constructor() {\n        this.mNodeName = ''\n        this.mNumPositionKeys = 0\n        this.mNumRotationKeys = 0\n        this.mNumScalingKeys = 0\n        this.mPositionKeys = []\n        this.mRotationKeys = []\n        this.mScalingKeys = []\n        this.mPreState = ''\n        this.mPostState = ''\n        this.init = function (tps) {\n          if (!tps) tps = 1\n\n          function t(t) {\n            t.mTime /= tps\n          }\n\n          this.mPositionKeys.forEach(t)\n          this.mRotationKeys.forEach(t)\n          this.mScalingKeys.forEach(t)\n        }\n\n        this.sortKeys = function () {\n          function comp(a, b) {\n            return a.mTime - b.mTime\n          }\n\n          this.mPositionKeys.sort(comp)\n          this.mRotationKeys.sort(comp)\n          this.mScalingKeys.sort(comp)\n        }\n\n        this.getLength = function () {\n          return Math.max(\n            Math.max.apply(\n              null,\n              this.mPositionKeys.map(function (a) {\n                return a.mTime\n              }),\n            ),\n            Math.max.apply(\n              null,\n              this.mRotationKeys.map(function (a) {\n                return a.mTime\n              }),\n            ),\n            Math.max.apply(\n              null,\n              this.mScalingKeys.map(function (a) {\n                return a.mTime\n              }),\n            ),\n          )\n        }\n\n        this.toTHREE = function (o) {\n          this.sortKeys()\n          var length = this.getLength()\n          var track = new Virtulous.KeyFrameTrack()\n\n          for (let i = 0; i < length; i += 0.05) {\n            var matrix = new Matrix4()\n            var time = i\n            var pos = sampleTrack(this.mPositionKeys, time, length, veclerp)\n            var scale = sampleTrack(this.mScalingKeys, time, length, veclerp)\n            var rotation = sampleTrack(this.mRotationKeys, time, length, quatlerp)\n            matrix.compose(pos, rotation, scale)\n\n            var key = new Virtulous.KeyFrame(time, matrix)\n            track.addKey(key)\n          }\n\n          track.target = o.findNode(this.mNodeName).toTHREE()\n\n          var tracks = [track]\n\n          if (o.nodeToBoneMap[this.mNodeName]) {\n            for (let i = 0; i < o.nodeToBoneMap[this.mNodeName].length; i++) {\n              var t2 = track.clone()\n              t2.target = o.nodeToBoneMap[this.mNodeName][i]\n              tracks.push(t2)\n            }\n          }\n\n          return tracks\n        }\n      }\n    }\n\n    class aiAnimation {\n      constructor() {\n        this.mName = ''\n        this.mDuration = 0\n        this.mTicksPerSecond = 0\n        this.mNumChannels = 0\n        this.mChannels = []\n        this.toTHREE = function (root) {\n          var animationHandle = new Virtulous.Animation()\n\n          for (let i in this.mChannels) {\n            this.mChannels[i].init(this.mTicksPerSecond)\n\n            var tracks = this.mChannels[i].toTHREE(root)\n\n            for (let j in tracks) {\n              tracks[j].init()\n              animationHandle.addTrack(tracks[j])\n            }\n          }\n\n          animationHandle.length = Math.max.apply(\n            null,\n            animationHandle.tracks.map(function (e) {\n              return e.length\n            }),\n          )\n          return animationHandle\n        }\n      }\n    }\n\n    class aiTexture {\n      constructor() {\n        this.mWidth = 0\n        this.mHeight = 0\n        this.texAchFormatHint = []\n        this.pcData = []\n      }\n    }\n\n    class aiLight {\n      constructor() {\n        this.mName = ''\n        this.mType = 0\n        this.mAttenuationConstant = 0\n        this.mAttenuationLinear = 0\n        this.mAttenuationQuadratic = 0\n        this.mAngleInnerCone = 0\n        this.mAngleOuterCone = 0\n        this.mColorDiffuse = null\n        this.mColorSpecular = null\n        this.mColorAmbient = null\n      }\n    }\n\n    class aiCamera {\n      constructor() {\n        this.mName = ''\n        this.mPosition = null\n        this.mLookAt = null\n        this.mUp = null\n        this.mHorizontalFOV = 0\n        this.mClipPlaneNear = 0\n        this.mClipPlaneFar = 0\n        this.mAspect = 0\n      }\n    }\n\n    class aiScene {\n      constructor() {\n        this.versionMajor = 0\n        this.versionMinor = 0\n        this.versionRevision = 0\n        this.compileFlags = 0\n        this.mFlags = 0\n        this.mNumMeshes = 0\n        this.mNumMaterials = 0\n        this.mNumAnimations = 0\n        this.mNumTextures = 0\n        this.mNumLights = 0\n        this.mNumCameras = 0\n        this.mRootNode = null\n        this.mMeshes = []\n        this.mMaterials = []\n        this.mAnimations = []\n        this.mLights = []\n        this.mCameras = []\n        this.nodeToBoneMap = {}\n        this.findNode = function (name, root) {\n          if (!root) {\n            root = this.mRootNode\n          }\n\n          if (root.mName == name) {\n            return root\n          }\n\n          for (let i = 0; i < root.mChildren.length; i++) {\n            var ret = this.findNode(name, root.mChildren[i])\n            if (ret) return ret\n          }\n\n          return null\n        }\n\n        this.toTHREE = function () {\n          this.nodeCount = 0\n\n          markBones(this)\n\n          var o = this.mRootNode.toTHREE(this)\n\n          for (let i in this.mMeshes) this.mMeshes[i].hookupSkeletons(this)\n\n          if (this.mAnimations.length > 0) {\n            var a = this.mAnimations[0].toTHREE(this)\n          }\n\n          return { object: o, animation: a }\n        }\n      }\n    }\n\n    class aiMatrix4 {\n      constructor() {\n        this.elements = [[], [], [], []]\n        this.toTHREE = function () {\n          var m = new Matrix4()\n\n          for (let i = 0; i < 4; ++i) {\n            for (let i2 = 0; i2 < 4; ++i2) {\n              m.elements[i * 4 + i2] = this.elements[i2][i]\n            }\n          }\n\n          return m\n        }\n      }\n    }\n\n    var littleEndian = true\n\n    function readFloat(dataview) {\n      var val = dataview.getFloat32(dataview.readOffset, littleEndian)\n      dataview.readOffset += 4\n      return val\n    }\n\n    function Read_double(dataview) {\n      var val = dataview.getFloat64(dataview.readOffset, littleEndian)\n      dataview.readOffset += 8\n      return val\n    }\n\n    function Read_uint8_t(dataview) {\n      var val = dataview.getUint8(dataview.readOffset)\n      dataview.readOffset += 1\n      return val\n    }\n\n    function Read_uint16_t(dataview) {\n      var val = dataview.getUint16(dataview.readOffset, littleEndian)\n      dataview.readOffset += 2\n      return val\n    }\n\n    function Read_unsigned_int(dataview) {\n      var val = dataview.getUint32(dataview.readOffset, littleEndian)\n      dataview.readOffset += 4\n      return val\n    }\n\n    function Read_uint32_t(dataview) {\n      var val = dataview.getUint32(dataview.readOffset, littleEndian)\n      dataview.readOffset += 4\n      return val\n    }\n\n    function Read_aiVector3D(stream) {\n      var v = new aiVector3D()\n      v.x = readFloat(stream)\n      v.y = readFloat(stream)\n      v.z = readFloat(stream)\n      return v\n    }\n\n    function Read_aiColor3D(stream) {\n      var c = new aiColor3D()\n      c.r = readFloat(stream)\n      c.g = readFloat(stream)\n      c.b = readFloat(stream)\n      return c\n    }\n\n    function Read_aiQuaternion(stream) {\n      var v = new aiQuaternion()\n      v.w = readFloat(stream)\n      v.x = readFloat(stream)\n      v.y = readFloat(stream)\n      v.z = readFloat(stream)\n      return v\n    }\n\n    function Read_aiString(stream) {\n      var s = new aiString()\n      var stringlengthbytes = Read_unsigned_int(stream)\n      stream.ReadBytes(s.data, 1, stringlengthbytes)\n      return s.toString()\n    }\n\n    function Read_aiVertexWeight(stream) {\n      var w = new aiVertexWeight()\n      w.mVertexId = Read_unsigned_int(stream)\n      w.mWeight = readFloat(stream)\n      return w\n    }\n\n    function Read_aiMatrix4x4(stream) {\n      var m = new aiMatrix4()\n\n      for (let i = 0; i < 4; ++i) {\n        for (let i2 = 0; i2 < 4; ++i2) {\n          m.elements[i][i2] = readFloat(stream)\n        }\n      }\n\n      return m\n    }\n\n    function Read_aiVectorKey(stream) {\n      var v = new aiVectorKey()\n      v.mTime = Read_double(stream)\n      v.mValue = Read_aiVector3D(stream)\n      return v\n    }\n\n    function Read_aiQuatKey(stream) {\n      var v = new aiQuatKey()\n      v.mTime = Read_double(stream)\n      v.mValue = Read_aiQuaternion(stream)\n      return v\n    }\n\n    function ReadArray_aiVertexWeight(stream, data, size) {\n      for (let i = 0; i < size; i++) data[i] = Read_aiVertexWeight(stream)\n    }\n\n    function ReadArray_aiVectorKey(stream, data, size) {\n      for (let i = 0; i < size; i++) data[i] = Read_aiVectorKey(stream)\n    }\n\n    function ReadArray_aiQuatKey(stream, data, size) {\n      for (let i = 0; i < size; i++) data[i] = Read_aiQuatKey(stream)\n    }\n\n    function ReadBounds(stream, T /*p*/, n) {\n      // not sure what to do here, the data isn't really useful.\n      return stream.Seek(sizeof(T) * n, aiOrigin_CUR)\n    }\n\n    function ai_assert(bool) {\n      if (!bool) throw 'asset failed'\n    }\n\n    function ReadBinaryNode(stream, parent, depth) {\n      var chunkID = Read_uint32_t(stream)\n      ai_assert(chunkID == ASSBIN_CHUNK_AINODE)\n      /*uint32_t size =*/\n      Read_uint32_t(stream)\n      var node = new aiNode()\n      node.mParent = parent\n      node.mDepth = depth\n      node.mName = Read_aiString(stream)\n      node.mTransformation = Read_aiMatrix4x4(stream)\n      node.mNumChildren = Read_unsigned_int(stream)\n      node.mNumMeshes = Read_unsigned_int(stream)\n\n      if (node.mNumMeshes) {\n        node.mMeshes = []\n\n        for (let i = 0; i < node.mNumMeshes; ++i) {\n          node.mMeshes[i] = Read_unsigned_int(stream)\n        }\n      }\n\n      if (node.mNumChildren) {\n        node.mChildren = []\n\n        for (let i = 0; i < node.mNumChildren; ++i) {\n          var node2 = ReadBinaryNode(stream, node, depth++)\n          node.mChildren[i] = node2\n        }\n      }\n\n      return node\n    }\n\n    // -----------------------------------------------------------------------------------\n\n    function ReadBinaryBone(stream, b) {\n      var chunkID = Read_uint32_t(stream)\n      ai_assert(chunkID == ASSBIN_CHUNK_AIBONE)\n      /*uint32_t size =*/\n      Read_uint32_t(stream)\n      b.mName = Read_aiString(stream)\n      b.mNumWeights = Read_unsigned_int(stream)\n      b.mOffsetMatrix = Read_aiMatrix4x4(stream)\n      // for the moment we write dumb min/max values for the bones, too.\n      // maybe I'll add a better, hash-like solution later\n      if (shortened) {\n        ReadBounds(stream, b.mWeights, b.mNumWeights)\n      } else {\n        // else write as usual\n\n        b.mWeights = []\n        ReadArray_aiVertexWeight(stream, b.mWeights, b.mNumWeights)\n      }\n\n      return b\n    }\n\n    function ReadBinaryMesh(stream, mesh) {\n      var chunkID = Read_uint32_t(stream)\n      ai_assert(chunkID == ASSBIN_CHUNK_AIMESH)\n      /*uint32_t size =*/\n      Read_uint32_t(stream)\n      mesh.mPrimitiveTypes = Read_unsigned_int(stream)\n      mesh.mNumVertices = Read_unsigned_int(stream)\n      mesh.mNumFaces = Read_unsigned_int(stream)\n      mesh.mNumBones = Read_unsigned_int(stream)\n      mesh.mMaterialIndex = Read_unsigned_int(stream)\n      mesh.mNumUVComponents = []\n      // first of all, write bits for all existent vertex components\n      var c = Read_unsigned_int(stream)\n\n      if (c & ASSBIN_MESH_HAS_POSITIONS) {\n        if (shortened) {\n          ReadBounds(stream, mesh.mVertices, mesh.mNumVertices)\n        } else {\n          // else write as usual\n\n          mesh.mVertices = []\n          mesh.mVertexBuffer = stream.subArray32(stream.readOffset, stream.readOffset + mesh.mNumVertices * 3 * 4)\n          stream.Seek(mesh.mNumVertices * 3 * 4, aiOrigin_CUR)\n        }\n      }\n\n      if (c & ASSBIN_MESH_HAS_NORMALS) {\n        if (shortened) {\n          ReadBounds(stream, mesh.mNormals, mesh.mNumVertices)\n        } else {\n          // else write as usual\n\n          mesh.mNormals = []\n          mesh.mNormalBuffer = stream.subArray32(stream.readOffset, stream.readOffset + mesh.mNumVertices * 3 * 4)\n          stream.Seek(mesh.mNumVertices * 3 * 4, aiOrigin_CUR)\n        }\n      }\n\n      if (c & ASSBIN_MESH_HAS_TANGENTS_AND_BITANGENTS) {\n        if (shortened) {\n          ReadBounds(stream, mesh.mTangents, mesh.mNumVertices)\n          ReadBounds(stream, mesh.mBitangents, mesh.mNumVertices)\n        } else {\n          // else write as usual\n\n          mesh.mTangents = []\n          mesh.mTangentBuffer = stream.subArray32(stream.readOffset, stream.readOffset + mesh.mNumVertices * 3 * 4)\n          stream.Seek(mesh.mNumVertices * 3 * 4, aiOrigin_CUR)\n          mesh.mBitangents = []\n          mesh.mBitangentBuffer = stream.subArray32(stream.readOffset, stream.readOffset + mesh.mNumVertices * 3 * 4)\n          stream.Seek(mesh.mNumVertices * 3 * 4, aiOrigin_CUR)\n        }\n      }\n\n      for (let n = 0; n < AI_MAX_NUMBER_OF_COLOR_SETS; ++n) {\n        if (!(c & ASSBIN_MESH_HAS_COLOR(n))) break\n\n        if (shortened) {\n          ReadBounds(stream, mesh.mColors[n], mesh.mNumVertices)\n        } else {\n          // else write as usual\n\n          mesh.mColors[n] = []\n          mesh.mColorBuffer = stream.subArray32(stream.readOffset, stream.readOffset + mesh.mNumVertices * 4 * 4)\n          stream.Seek(mesh.mNumVertices * 4 * 4, aiOrigin_CUR)\n        }\n      }\n\n      mesh.mTexCoordsBuffers = []\n\n      for (let n = 0; n < AI_MAX_NUMBER_OF_TEXTURECOORDS; ++n) {\n        if (!(c & ASSBIN_MESH_HAS_TEXCOORD(n))) break\n\n        // write number of UV components\n        mesh.mNumUVComponents[n] = Read_unsigned_int(stream)\n\n        if (shortened) {\n          ReadBounds(stream, mesh.mTextureCoords[n], mesh.mNumVertices)\n        } else {\n          // else write as usual\n\n          mesh.mTextureCoords[n] = []\n          //note that assbin always writes 3d texcoords\n          mesh.mTexCoordsBuffers[n] = []\n\n          for (let uv = 0; uv < mesh.mNumVertices; uv++) {\n            mesh.mTexCoordsBuffers[n].push(readFloat(stream))\n            mesh.mTexCoordsBuffers[n].push(readFloat(stream))\n            readFloat(stream)\n          }\n        }\n      }\n\n      // write faces. There are no floating-point calculations involved\n      // in these, so we can write a simple hash over the face data\n      // to the dump file. We generate a single 32 Bit hash for 512 faces\n      // using Assimp's standard hashing function.\n      if (shortened) {\n        Read_unsigned_int(stream)\n      } else {\n        // else write as usual\n\n        // if there are less than 2^16 vertices, we can simply use 16 bit integers ...\n        mesh.mFaces = []\n        mesh.mIndexArray = []\n\n        for (let i = 0; i < mesh.mNumFaces; ++i) {\n          var f = (mesh.mFaces[i] = new aiFace())\n          // BOOST_STATIC_ASSERT(AI_MAX_FACE_INDICES <= 0xffff);\n          f.mNumIndices = Read_uint16_t(stream)\n          f.mIndices = []\n\n          for (let a = 0; a < f.mNumIndices; ++a) {\n            if (mesh.mNumVertices < 1 << 16) {\n              f.mIndices[a] = Read_uint16_t(stream)\n            } else {\n              f.mIndices[a] = Read_unsigned_int(stream)\n            }\n          }\n\n          if (f.mNumIndices === 3) {\n            mesh.mIndexArray.push(f.mIndices[0])\n            mesh.mIndexArray.push(f.mIndices[1])\n            mesh.mIndexArray.push(f.mIndices[2])\n          } else if (f.mNumIndices === 4) {\n            mesh.mIndexArray.push(f.mIndices[0])\n            mesh.mIndexArray.push(f.mIndices[1])\n            mesh.mIndexArray.push(f.mIndices[2])\n            mesh.mIndexArray.push(f.mIndices[2])\n            mesh.mIndexArray.push(f.mIndices[3])\n            mesh.mIndexArray.push(f.mIndices[0])\n          } else {\n            throw new Error(\"Sorry, can't currently triangulate polys. Use the triangulate preprocessor in Assimp.\")\n          }\n        }\n      }\n\n      // write bones\n      if (mesh.mNumBones) {\n        mesh.mBones = []\n\n        for (let a = 0; a < mesh.mNumBones; ++a) {\n          mesh.mBones[a] = new aiBone()\n          ReadBinaryBone(stream, mesh.mBones[a])\n        }\n      }\n    }\n\n    function ReadBinaryMaterialProperty(stream, prop) {\n      var chunkID = Read_uint32_t(stream)\n      ai_assert(chunkID == ASSBIN_CHUNK_AIMATERIALPROPERTY)\n      /*uint32_t size =*/\n      Read_uint32_t(stream)\n      prop.mKey = Read_aiString(stream)\n      prop.mSemantic = Read_unsigned_int(stream)\n      prop.mIndex = Read_unsigned_int(stream)\n      prop.mDataLength = Read_unsigned_int(stream)\n      prop.mType = Read_unsigned_int(stream)\n      prop.mData = []\n      stream.ReadBytes(prop.mData, 1, prop.mDataLength)\n    }\n\n    // -----------------------------------------------------------------------------------\n\n    function ReadBinaryMaterial(stream, mat) {\n      var chunkID = Read_uint32_t(stream)\n      ai_assert(chunkID == ASSBIN_CHUNK_AIMATERIAL)\n      /*uint32_t size =*/\n      Read_uint32_t(stream)\n      mat.mNumAllocated = mat.mNumProperties = Read_unsigned_int(stream)\n\n      if (mat.mNumProperties) {\n        if (mat.mProperties) {\n          delete mat.mProperties\n        }\n\n        mat.mProperties = []\n\n        for (let i = 0; i < mat.mNumProperties; ++i) {\n          mat.mProperties[i] = new aiMaterialProperty()\n          ReadBinaryMaterialProperty(stream, mat.mProperties[i])\n        }\n      }\n    }\n\n    function ReadBinaryNodeAnim(stream, nd) {\n      var chunkID = Read_uint32_t(stream)\n      ai_assert(chunkID == ASSBIN_CHUNK_AINODEANIM)\n      /*uint32_t size =*/\n      Read_uint32_t(stream)\n      nd.mNodeName = Read_aiString(stream)\n      nd.mNumPositionKeys = Read_unsigned_int(stream)\n      nd.mNumRotationKeys = Read_unsigned_int(stream)\n      nd.mNumScalingKeys = Read_unsigned_int(stream)\n      nd.mPreState = Read_unsigned_int(stream)\n      nd.mPostState = Read_unsigned_int(stream)\n\n      if (nd.mNumPositionKeys) {\n        if (shortened) {\n          ReadBounds(stream, nd.mPositionKeys, nd.mNumPositionKeys)\n        } else {\n          // else write as usual\n\n          nd.mPositionKeys = []\n          ReadArray_aiVectorKey(stream, nd.mPositionKeys, nd.mNumPositionKeys)\n        }\n      }\n\n      if (nd.mNumRotationKeys) {\n        if (shortened) {\n          ReadBounds(stream, nd.mRotationKeys, nd.mNumRotationKeys)\n        } else {\n          // else write as usual\n\n          nd.mRotationKeys = []\n          ReadArray_aiQuatKey(stream, nd.mRotationKeys, nd.mNumRotationKeys)\n        }\n      }\n\n      if (nd.mNumScalingKeys) {\n        if (shortened) {\n          ReadBounds(stream, nd.mScalingKeys, nd.mNumScalingKeys)\n        } else {\n          // else write as usual\n\n          nd.mScalingKeys = []\n          ReadArray_aiVectorKey(stream, nd.mScalingKeys, nd.mNumScalingKeys)\n        }\n      }\n    }\n\n    function ReadBinaryAnim(stream, anim) {\n      var chunkID = Read_uint32_t(stream)\n      ai_assert(chunkID == ASSBIN_CHUNK_AIANIMATION)\n      /*uint32_t size =*/\n      Read_uint32_t(stream)\n      anim.mName = Read_aiString(stream)\n      anim.mDuration = Read_double(stream)\n      anim.mTicksPerSecond = Read_double(stream)\n      anim.mNumChannels = Read_unsigned_int(stream)\n\n      if (anim.mNumChannels) {\n        anim.mChannels = []\n\n        for (let a = 0; a < anim.mNumChannels; ++a) {\n          anim.mChannels[a] = new aiNodeAnim()\n          ReadBinaryNodeAnim(stream, anim.mChannels[a])\n        }\n      }\n    }\n\n    function ReadBinaryTexture(stream, tex) {\n      var chunkID = Read_uint32_t(stream)\n      ai_assert(chunkID == ASSBIN_CHUNK_AITEXTURE)\n      /*uint32_t size =*/\n      Read_uint32_t(stream)\n      tex.mWidth = Read_unsigned_int(stream)\n      tex.mHeight = Read_unsigned_int(stream)\n      stream.ReadBytes(tex.achFormatHint, 1, 4)\n\n      if (!shortened) {\n        if (!tex.mHeight) {\n          tex.pcData = []\n          stream.ReadBytes(tex.pcData, 1, tex.mWidth)\n        } else {\n          tex.pcData = []\n          stream.ReadBytes(tex.pcData, 1, tex.mWidth * tex.mHeight * 4)\n        }\n      }\n    }\n\n    function ReadBinaryLight(stream, l) {\n      var chunkID = Read_uint32_t(stream)\n      ai_assert(chunkID == ASSBIN_CHUNK_AILIGHT)\n      /*uint32_t size =*/\n      Read_uint32_t(stream)\n      l.mName = Read_aiString(stream)\n      l.mType = Read_unsigned_int(stream)\n\n      if (l.mType != aiLightSource_DIRECTIONAL) {\n        l.mAttenuationConstant = readFloat(stream)\n        l.mAttenuationLinear = readFloat(stream)\n        l.mAttenuationQuadratic = readFloat(stream)\n      }\n\n      l.mColorDiffuse = Read_aiColor3D(stream)\n      l.mColorSpecular = Read_aiColor3D(stream)\n      l.mColorAmbient = Read_aiColor3D(stream)\n\n      if (l.mType == aiLightSource_SPOT) {\n        l.mAngleInnerCone = readFloat(stream)\n        l.mAngleOuterCone = readFloat(stream)\n      }\n    }\n\n    function ReadBinaryCamera(stream, cam) {\n      var chunkID = Read_uint32_t(stream)\n      ai_assert(chunkID == ASSBIN_CHUNK_AICAMERA)\n      /*uint32_t size =*/\n      Read_uint32_t(stream)\n      cam.mName = Read_aiString(stream)\n      cam.mPosition = Read_aiVector3D(stream)\n      cam.mLookAt = Read_aiVector3D(stream)\n      cam.mUp = Read_aiVector3D(stream)\n      cam.mHorizontalFOV = readFloat(stream)\n      cam.mClipPlaneNear = readFloat(stream)\n      cam.mClipPlaneFar = readFloat(stream)\n      cam.mAspect = readFloat(stream)\n    }\n\n    function ReadBinaryScene(stream, scene) {\n      var chunkID = Read_uint32_t(stream)\n      ai_assert(chunkID == ASSBIN_CHUNK_AISCENE)\n      /*uint32_t size =*/\n      Read_uint32_t(stream)\n      scene.mFlags = Read_unsigned_int(stream)\n      scene.mNumMeshes = Read_unsigned_int(stream)\n      scene.mNumMaterials = Read_unsigned_int(stream)\n      scene.mNumAnimations = Read_unsigned_int(stream)\n      scene.mNumTextures = Read_unsigned_int(stream)\n      scene.mNumLights = Read_unsigned_int(stream)\n      scene.mNumCameras = Read_unsigned_int(stream)\n      // Read node graph\n      scene.mRootNode = new aiNode()\n      scene.mRootNode = ReadBinaryNode(stream, null, 0)\n      // Read all meshes\n      if (scene.mNumMeshes) {\n        scene.mMeshes = []\n\n        for (let i = 0; i < scene.mNumMeshes; ++i) {\n          scene.mMeshes[i] = new aiMesh()\n          ReadBinaryMesh(stream, scene.mMeshes[i])\n        }\n      }\n\n      // Read materials\n      if (scene.mNumMaterials) {\n        scene.mMaterials = []\n\n        for (let i = 0; i < scene.mNumMaterials; ++i) {\n          scene.mMaterials[i] = new aiMaterial()\n          ReadBinaryMaterial(stream, scene.mMaterials[i])\n        }\n      }\n\n      // Read all animations\n      if (scene.mNumAnimations) {\n        scene.mAnimations = []\n\n        for (let i = 0; i < scene.mNumAnimations; ++i) {\n          scene.mAnimations[i] = new aiAnimation()\n          ReadBinaryAnim(stream, scene.mAnimations[i])\n        }\n      }\n\n      // Read all textures\n      if (scene.mNumTextures) {\n        scene.mTextures = []\n\n        for (let i = 0; i < scene.mNumTextures; ++i) {\n          scene.mTextures[i] = new aiTexture()\n          ReadBinaryTexture(stream, scene.mTextures[i])\n        }\n      }\n\n      // Read lights\n      if (scene.mNumLights) {\n        scene.mLights = []\n\n        for (let i = 0; i < scene.mNumLights; ++i) {\n          scene.mLights[i] = new aiLight()\n          ReadBinaryLight(stream, scene.mLights[i])\n        }\n      }\n\n      // Read cameras\n      if (scene.mNumCameras) {\n        scene.mCameras = []\n\n        for (let i = 0; i < scene.mNumCameras; ++i) {\n          scene.mCameras[i] = new aiCamera()\n          ReadBinaryCamera(stream, scene.mCameras[i])\n        }\n      }\n    }\n\n    var aiOrigin_CUR = 0\n    var aiOrigin_BEG = 1\n\n    function extendStream(stream) {\n      stream.readOffset = 0\n      stream.Seek = function (off, ori) {\n        if (ori == aiOrigin_CUR) {\n          stream.readOffset += off\n        }\n\n        if (ori == aiOrigin_BEG) {\n          stream.readOffset = off\n        }\n      }\n\n      stream.ReadBytes = function (buff, size, n) {\n        var bytes = size * n\n        for (let i = 0; i < bytes; i++) buff[i] = Read_uint8_t(this)\n      }\n\n      stream.subArray32 = function (start, end) {\n        var buff = this.buffer\n        var newbuff = buff.slice(start, end)\n        return new Float32Array(newbuff)\n      }\n\n      stream.subArrayUint16 = function (start, end) {\n        var buff = this.buffer\n        var newbuff = buff.slice(start, end)\n        return new Uint16Array(newbuff)\n      }\n\n      stream.subArrayUint8 = function (start, end) {\n        var buff = this.buffer\n        var newbuff = buff.slice(start, end)\n        return new Uint8Array(newbuff)\n      }\n\n      stream.subArrayUint32 = function (start, end) {\n        var buff = this.buffer\n        var newbuff = buff.slice(start, end)\n        return new Uint32Array(newbuff)\n      }\n    }\n\n    var shortened, compressed\n\n    function InternReadFile(pFiledata) {\n      var pScene = new aiScene()\n      var stream = new DataView(pFiledata)\n      extendStream(stream)\n      stream.Seek(44, aiOrigin_CUR) // signature\n      /*unsigned int versionMajor =*/\n      pScene.versionMajor = Read_unsigned_int(stream)\n      /*unsigned int versionMinor =*/\n      pScene.versionMinor = Read_unsigned_int(stream)\n      /*unsigned int versionRevision =*/\n      pScene.versionRevision = Read_unsigned_int(stream)\n      /*unsigned int compileFlags =*/\n      pScene.compileFlags = Read_unsigned_int(stream)\n      shortened = Read_uint16_t(stream) > 0\n      compressed = Read_uint16_t(stream) > 0\n      if (shortened) throw 'Shortened binaries are not supported!'\n      stream.Seek(256, aiOrigin_CUR) // original filename\n      stream.Seek(128, aiOrigin_CUR) // options\n      stream.Seek(64, aiOrigin_CUR) // padding\n      if (compressed) {\n        var uncompressedSize = Read_uint32_t(stream)\n        var compressedSize = stream.FileSize() - stream.Tell()\n        var compressedData = []\n        stream.Read(compressedData, 1, compressedSize)\n        var uncompressedData = []\n        uncompress(uncompressedData, uncompressedSize, compressedData, compressedSize)\n        var buff = new ArrayBuffer(uncompressedData)\n        ReadBinaryScene(buff, pScene)\n      } else {\n        ReadBinaryScene(stream, pScene)\n      }\n\n      return pScene.toTHREE()\n    }\n\n    return InternReadFile(buffer)\n  }\n}\n\nexport { AssimpLoader }\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}