{"ast":null,"code":"import _objectSpread from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _slicedToArray from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _objectWithoutProperties from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js\";\nvar _excluded = [\"autoTransform\", \"matrix\", \"axisLock\", \"dragLimits\", \"onHover\", \"onDragStart\", \"onDrag\", \"onDragEnd\", \"children\", \"dragConfig\"];\nimport _extends from '@babel/runtime/helpers/esm/extends';\nimport * as React from 'react';\nimport * as THREE from 'three';\nimport { useThree } from '@react-three/fiber';\nimport { useGesture } from '@use-gesture/react';\nvar initialModelPosition = new THREE.Vector3();\nvar mousePosition2D = new THREE.Vector2();\nvar mousePosition3D = new THREE.Vector3();\nvar dragOffset = new THREE.Vector3();\nvar dragPlaneNormal = new THREE.Vector3();\nvar dragPlane = new THREE.Plane();\nvar DragControls = /*#__PURE__*/React.forwardRef(function (_ref, fRef) {\n  var _ref$autoTransform = _ref.autoTransform,\n    autoTransform = _ref$autoTransform === void 0 ? true : _ref$autoTransform,\n    matrix = _ref.matrix,\n    axisLock = _ref.axisLock,\n    dragLimits = _ref.dragLimits,\n    _onHover = _ref.onHover,\n    _onDragStart = _ref.onDragStart,\n    _onDrag = _ref.onDrag,\n    _onDragEnd = _ref.onDragEnd,\n    children = _ref.children,\n    dragConfig = _ref.dragConfig,\n    props = _objectWithoutProperties(_ref, _excluded);\n  var defaultControls = useThree(function (state) {\n    return state.controls;\n  });\n  var _useThree = useThree(),\n    camera = _useThree.camera,\n    size = _useThree.size,\n    raycaster = _useThree.raycaster,\n    invalidate = _useThree.invalidate;\n  var ref = React.useRef(null);\n  var bind = useGesture({\n    onHover: function onHover(_ref2) {\n      var hovering = _ref2.hovering;\n      return _onHover && _onHover(hovering !== null && hovering !== void 0 ? hovering : false);\n    },\n    onDragStart: function onDragStart(_ref3) {\n      var event = _ref3.event;\n      if (defaultControls) defaultControls.enabled = false;\n      var point = event.point;\n      ref.current.matrix.decompose(initialModelPosition, new THREE.Quaternion(), new THREE.Vector3());\n      mousePosition3D.copy(point);\n      dragOffset.copy(mousePosition3D).sub(initialModelPosition);\n      _onDragStart && _onDragStart(initialModelPosition);\n      invalidate();\n    },\n    onDrag: function onDrag(_ref4) {\n      var _ref4$xy = _slicedToArray(_ref4.xy, 2),\n        dragX = _ref4$xy[0],\n        dragY = _ref4$xy[1],\n        intentional = _ref4.intentional;\n      if (!intentional) return;\n      var normalizedMouseX = (dragX - size.left) / size.width * 2 - 1;\n      var normalizedMouseY = -((dragY - size.top) / size.height) * 2 + 1;\n      mousePosition2D.set(normalizedMouseX, normalizedMouseY);\n      raycaster.setFromCamera(mousePosition2D, camera);\n      if (!axisLock) {\n        camera.getWorldDirection(dragPlaneNormal).negate();\n      } else {\n        switch (axisLock) {\n          case 'x':\n            dragPlaneNormal.set(1, 0, 0);\n            break;\n          case 'y':\n            dragPlaneNormal.set(0, 1, 0);\n            break;\n          case 'z':\n            dragPlaneNormal.set(0, 0, 1);\n            break;\n        }\n      }\n      dragPlane.setFromNormalAndCoplanarPoint(dragPlaneNormal, mousePosition3D);\n      raycaster.ray.intersectPlane(dragPlane, mousePosition3D);\n      var previousLocalMatrix = ref.current.matrix.clone();\n      var previousWorldMatrix = ref.current.matrixWorld.clone();\n      var intendedNewPosition = new THREE.Vector3(mousePosition3D.x - dragOffset.x, mousePosition3D.y - dragOffset.y, mousePosition3D.z - dragOffset.z);\n      if (dragLimits) {\n        intendedNewPosition.x = dragLimits[0] ? Math.max(Math.min(intendedNewPosition.x, dragLimits[0][1]), dragLimits[0][0]) : intendedNewPosition.x;\n        intendedNewPosition.y = dragLimits[1] ? Math.max(Math.min(intendedNewPosition.y, dragLimits[1][1]), dragLimits[1][0]) : intendedNewPosition.y;\n        intendedNewPosition.z = dragLimits[2] ? Math.max(Math.min(intendedNewPosition.z, dragLimits[2][1]), dragLimits[2][0]) : intendedNewPosition.z;\n      }\n      if (autoTransform) {\n        ref.current.matrix.setPosition(intendedNewPosition);\n        var deltaLocalMatrix = ref.current.matrix.clone().multiply(previousLocalMatrix.invert());\n        var deltaWorldMatrix = ref.current.matrix.clone().multiply(previousWorldMatrix.invert());\n        _onDrag && _onDrag(ref.current.matrix, deltaLocalMatrix, ref.current.matrixWorld, deltaWorldMatrix);\n      } else {\n        var tempMatrix = new THREE.Matrix4().copy(ref.current.matrix);\n        tempMatrix.setPosition(intendedNewPosition);\n        var _deltaLocalMatrix = tempMatrix.clone().multiply(previousLocalMatrix.invert());\n        var _deltaWorldMatrix = tempMatrix.clone().multiply(previousWorldMatrix.invert());\n        _onDrag && _onDrag(tempMatrix, _deltaLocalMatrix, ref.current.matrixWorld, _deltaWorldMatrix);\n      }\n      invalidate();\n    },\n    onDragEnd: function onDragEnd() {\n      if (defaultControls) defaultControls.enabled = true;\n      _onDragEnd && _onDragEnd();\n      invalidate();\n    }\n  }, {\n    drag: _objectSpread({\n      filterTaps: true,\n      threshold: 1\n    }, typeof dragConfig === 'object' ? dragConfig : {})\n  });\n  React.useImperativeHandle(fRef, function () {\n    return ref.current;\n  }, []);\n  React.useLayoutEffect(function () {\n    if (!matrix) return;\n\n    // If the matrix is a real matrix4 it means that the user wants to control the gizmo\n    // In that case it should just be set, as a bare prop update would merely copy it\n    ref.current.matrix = matrix;\n  }, [matrix]);\n  return /*#__PURE__*/React.createElement(\"group\", _extends({\n    ref: ref\n  }, bind(), {\n    matrix: matrix,\n    matrixAutoUpdate: false\n  }, props), children);\n});\nexport { DragControls };","map":{"version":3,"names":["_extends","React","THREE","useThree","useGesture","initialModelPosition","Vector3","mousePosition2D","Vector2","mousePosition3D","dragOffset","dragPlaneNormal","dragPlane","Plane","DragControls","forwardRef","_ref","fRef","_ref$autoTransform","autoTransform","matrix","axisLock","dragLimits","onHover","onDragStart","onDrag","onDragEnd","children","dragConfig","props","_objectWithoutProperties","_excluded","defaultControls","state","controls","_useThree","camera","size","raycaster","invalidate","ref","useRef","bind","_ref2","hovering","_ref3","event","enabled","point","current","decompose","Quaternion","copy","sub","_ref4","_ref4$xy","_slicedToArray","xy","dragX","dragY","intentional","normalizedMouseX","left","width","normalizedMouseY","top","height","set","setFromCamera","getWorldDirection","negate","setFromNormalAndCoplanarPoint","ray","intersectPlane","previousLocalMatrix","clone","previousWorldMatrix","matrixWorld","intendedNewPosition","x","y","z","Math","max","min","setPosition","deltaLocalMatrix","multiply","invert","deltaWorldMatrix","tempMatrix","Matrix4","drag","_objectSpread","filterTaps","threshold","useImperativeHandle","useLayoutEffect","createElement","matrixAutoUpdate"],"sources":["C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@react-three/drei/web/DragControls.js"],"sourcesContent":["import _extends from '@babel/runtime/helpers/esm/extends';\nimport * as React from 'react';\nimport * as THREE from 'three';\nimport { useThree } from '@react-three/fiber';\nimport { useGesture } from '@use-gesture/react';\n\nconst initialModelPosition = new THREE.Vector3();\nconst mousePosition2D = new THREE.Vector2();\nconst mousePosition3D = new THREE.Vector3();\nconst dragOffset = new THREE.Vector3();\nconst dragPlaneNormal = new THREE.Vector3();\nconst dragPlane = new THREE.Plane();\nconst DragControls = /*#__PURE__*/React.forwardRef(({\n  autoTransform = true,\n  matrix,\n  axisLock,\n  dragLimits,\n  onHover,\n  onDragStart,\n  onDrag,\n  onDragEnd,\n  children,\n  dragConfig,\n  ...props\n}, fRef) => {\n  const defaultControls = useThree(state => state.controls);\n  const {\n    camera,\n    size,\n    raycaster,\n    invalidate\n  } = useThree();\n  const ref = React.useRef(null);\n  const bind = useGesture({\n    onHover: ({\n      hovering\n    }) => onHover && onHover(hovering !== null && hovering !== void 0 ? hovering : false),\n    onDragStart: ({\n      event\n    }) => {\n      if (defaultControls) defaultControls.enabled = false;\n      const {\n        point\n      } = event;\n      ref.current.matrix.decompose(initialModelPosition, new THREE.Quaternion(), new THREE.Vector3());\n      mousePosition3D.copy(point);\n      dragOffset.copy(mousePosition3D).sub(initialModelPosition);\n      onDragStart && onDragStart(initialModelPosition);\n      invalidate();\n    },\n    onDrag: ({\n      xy: [dragX, dragY],\n      intentional\n    }) => {\n      if (!intentional) return;\n      const normalizedMouseX = (dragX - size.left) / size.width * 2 - 1;\n      const normalizedMouseY = -((dragY - size.top) / size.height) * 2 + 1;\n      mousePosition2D.set(normalizedMouseX, normalizedMouseY);\n      raycaster.setFromCamera(mousePosition2D, camera);\n      if (!axisLock) {\n        camera.getWorldDirection(dragPlaneNormal).negate();\n      } else {\n        switch (axisLock) {\n          case 'x':\n            dragPlaneNormal.set(1, 0, 0);\n            break;\n          case 'y':\n            dragPlaneNormal.set(0, 1, 0);\n            break;\n          case 'z':\n            dragPlaneNormal.set(0, 0, 1);\n            break;\n        }\n      }\n      dragPlane.setFromNormalAndCoplanarPoint(dragPlaneNormal, mousePosition3D);\n      raycaster.ray.intersectPlane(dragPlane, mousePosition3D);\n      const previousLocalMatrix = ref.current.matrix.clone();\n      const previousWorldMatrix = ref.current.matrixWorld.clone();\n      const intendedNewPosition = new THREE.Vector3(mousePosition3D.x - dragOffset.x, mousePosition3D.y - dragOffset.y, mousePosition3D.z - dragOffset.z);\n      if (dragLimits) {\n        intendedNewPosition.x = dragLimits[0] ? Math.max(Math.min(intendedNewPosition.x, dragLimits[0][1]), dragLimits[0][0]) : intendedNewPosition.x;\n        intendedNewPosition.y = dragLimits[1] ? Math.max(Math.min(intendedNewPosition.y, dragLimits[1][1]), dragLimits[1][0]) : intendedNewPosition.y;\n        intendedNewPosition.z = dragLimits[2] ? Math.max(Math.min(intendedNewPosition.z, dragLimits[2][1]), dragLimits[2][0]) : intendedNewPosition.z;\n      }\n      if (autoTransform) {\n        ref.current.matrix.setPosition(intendedNewPosition);\n        const deltaLocalMatrix = ref.current.matrix.clone().multiply(previousLocalMatrix.invert());\n        const deltaWorldMatrix = ref.current.matrix.clone().multiply(previousWorldMatrix.invert());\n        onDrag && onDrag(ref.current.matrix, deltaLocalMatrix, ref.current.matrixWorld, deltaWorldMatrix);\n      } else {\n        const tempMatrix = new THREE.Matrix4().copy(ref.current.matrix);\n        tempMatrix.setPosition(intendedNewPosition);\n        const deltaLocalMatrix = tempMatrix.clone().multiply(previousLocalMatrix.invert());\n        const deltaWorldMatrix = tempMatrix.clone().multiply(previousWorldMatrix.invert());\n        onDrag && onDrag(tempMatrix, deltaLocalMatrix, ref.current.matrixWorld, deltaWorldMatrix);\n      }\n      invalidate();\n    },\n    onDragEnd: () => {\n      if (defaultControls) defaultControls.enabled = true;\n      onDragEnd && onDragEnd();\n      invalidate();\n    }\n  }, {\n    drag: {\n      filterTaps: true,\n      threshold: 1,\n      ...(typeof dragConfig === 'object' ? dragConfig : {})\n    }\n  });\n  React.useImperativeHandle(fRef, () => ref.current, []);\n  React.useLayoutEffect(() => {\n    if (!matrix) return;\n\n    // If the matrix is a real matrix4 it means that the user wants to control the gizmo\n    // In that case it should just be set, as a bare prop update would merely copy it\n    ref.current.matrix = matrix;\n  }, [matrix]);\n  return /*#__PURE__*/React.createElement(\"group\", _extends({\n    ref: ref\n  }, bind(), {\n    matrix: matrix,\n    matrixAutoUpdate: false\n  }, props), children);\n});\n\nexport { DragControls };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}