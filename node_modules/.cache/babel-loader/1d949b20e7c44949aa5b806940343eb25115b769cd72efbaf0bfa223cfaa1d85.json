{"ast":null,"code":"import _createClass from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _classCallCheck from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _inherits from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport * as THREE from 'three';\nimport { version } from '../helpers/constants.js';\nvar SpotLightMaterial = /*#__PURE__*/function (_THREE$ShaderMaterial) {\n  _inherits(SpotLightMaterial, _THREE$ShaderMaterial);\n  var _super = _createSuper(SpotLightMaterial);\n  function SpotLightMaterial() {\n    _classCallCheck(this, SpotLightMaterial);\n    return _super.call(this, {\n      uniforms: {\n        depth: {\n          value: null\n        },\n        opacity: {\n          value: 1\n        },\n        attenuation: {\n          value: 2.5\n        },\n        anglePower: {\n          value: 12\n        },\n        spotPosition: {\n          value: new THREE.Vector3(0, 0, 0)\n        },\n        lightColor: {\n          value: new THREE.Color('white')\n        },\n        cameraNear: {\n          value: 0\n        },\n        cameraFar: {\n          value: 1\n        },\n        resolution: {\n          value: new THREE.Vector2(0, 0)\n        }\n      },\n      transparent: true,\n      depthWrite: false,\n      vertexShader: /* glsl */\"\\n        varying vec3 vNormal;\\n        varying float vViewZ;\\n        varying float vIntensity;\\n        uniform vec3 spotPosition;\\n        uniform float attenuation;\\n\\n        #include <common>\\n        #include <logdepthbuf_pars_vertex>\\n\\n        void main() {\\n          // compute intensity\\n          vNormal = normalize(normalMatrix * normal);\\n          vec4 worldPosition = modelMatrix * vec4(position, 1);\\n          vec4 viewPosition = viewMatrix * worldPosition;\\n          vViewZ = viewPosition.z;\\n\\n          vIntensity = 1.0 - saturate(distance(worldPosition.xyz, spotPosition) / attenuation);\\n\\n          gl_Position = projectionMatrix * viewPosition;\\n\\n          #include <logdepthbuf_vertex>\\n        }\\n      \",\n      fragmentShader: /* glsl */\"\\n        varying vec3 vNormal;\\n        varying float vViewZ;\\n        varying float vIntensity;\\n\\n        uniform vec3 lightColor;\\n        uniform float anglePower;\\n        uniform sampler2D depth;\\n        uniform vec2 resolution;\\n        uniform float cameraNear;\\n        uniform float cameraFar;\\n        uniform float opacity;\\n\\n        #include <packing>\\n        #include <logdepthbuf_pars_fragment>\\n\\n        float readDepth(sampler2D depthSampler, vec2 uv) {\\n          float fragCoordZ = texture(depthSampler, uv).r;\\n\\n          // https://github.com/mrdoob/three.js/issues/23072\\n          #ifdef USE_LOGDEPTHBUF\\n            float viewZ = 1.0 - exp2(fragCoordZ * log(cameraFar + 1.0) / log(2.0));\\n          #else\\n            float viewZ = perspectiveDepthToViewZ(fragCoordZ, cameraNear, cameraFar);\\n          #endif\\n\\n          return viewZ;\\n        }\\n\\n        void main() {\\n          #include <logdepthbuf_fragment>\\n\\n          vec3 normal = vec3(vNormal.x, vNormal.y, abs(vNormal.z));\\n          float angleIntensity = pow(dot(normal, vec3(0, 0, 1)), anglePower);\\n          float intensity = vIntensity * angleIntensity;\\n\\n          // fades when z is close to sampled depth, meaning the cone is intersecting existing geometry\\n          bool isSoft = resolution[0] > 0.0 && resolution[1] > 0.0;\\n          if (isSoft) {\\n            vec2 uv = gl_FragCoord.xy / resolution;\\n            intensity *= smoothstep(0.0, 1.0, vViewZ - readDepth(depth, uv));\\n          }\\n\\n          gl_FragColor = vec4(lightColor, intensity * opacity);\\n\\n          #include <tonemapping_fragment>\\n          #include <\".concat(version >= 154 ? 'colorspace_fragment' : 'encodings_fragment', \">\\n        }\\n      \")\n    });\n  }\n  return _createClass(SpotLightMaterial);\n}(THREE.ShaderMaterial);\nexport { SpotLightMaterial };","map":{"version":3,"names":["THREE","version","SpotLightMaterial","_THREE$ShaderMaterial","_inherits","_super","_createSuper","_classCallCheck","call","uniforms","depth","value","opacity","attenuation","anglePower","spotPosition","Vector3","lightColor","Color","cameraNear","cameraFar","resolution","Vector2","transparent","depthWrite","vertexShader","fragmentShader","concat","_createClass","ShaderMaterial"],"sources":["C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@react-three/drei/materials/SpotLightMaterial.js"],"sourcesContent":["import * as THREE from 'three';\nimport { version } from '../helpers/constants.js';\n\nclass SpotLightMaterial extends THREE.ShaderMaterial {\n  constructor() {\n    super({\n      uniforms: {\n        depth: {\n          value: null\n        },\n        opacity: {\n          value: 1\n        },\n        attenuation: {\n          value: 2.5\n        },\n        anglePower: {\n          value: 12\n        },\n        spotPosition: {\n          value: new THREE.Vector3(0, 0, 0)\n        },\n        lightColor: {\n          value: new THREE.Color('white')\n        },\n        cameraNear: {\n          value: 0\n        },\n        cameraFar: {\n          value: 1\n        },\n        resolution: {\n          value: new THREE.Vector2(0, 0)\n        }\n      },\n      transparent: true,\n      depthWrite: false,\n      vertexShader: /* glsl */`\n        varying vec3 vNormal;\n        varying float vViewZ;\n        varying float vIntensity;\n        uniform vec3 spotPosition;\n        uniform float attenuation;\n\n        #include <common>\n        #include <logdepthbuf_pars_vertex>\n\n        void main() {\n          // compute intensity\n          vNormal = normalize(normalMatrix * normal);\n          vec4 worldPosition = modelMatrix * vec4(position, 1);\n          vec4 viewPosition = viewMatrix * worldPosition;\n          vViewZ = viewPosition.z;\n\n          vIntensity = 1.0 - saturate(distance(worldPosition.xyz, spotPosition) / attenuation);\n\n          gl_Position = projectionMatrix * viewPosition;\n\n          #include <logdepthbuf_vertex>\n        }\n      `,\n      fragmentShader: /* glsl */`\n        varying vec3 vNormal;\n        varying float vViewZ;\n        varying float vIntensity;\n\n        uniform vec3 lightColor;\n        uniform float anglePower;\n        uniform sampler2D depth;\n        uniform vec2 resolution;\n        uniform float cameraNear;\n        uniform float cameraFar;\n        uniform float opacity;\n\n        #include <packing>\n        #include <logdepthbuf_pars_fragment>\n\n        float readDepth(sampler2D depthSampler, vec2 uv) {\n          float fragCoordZ = texture(depthSampler, uv).r;\n\n          // https://github.com/mrdoob/three.js/issues/23072\n          #ifdef USE_LOGDEPTHBUF\n            float viewZ = 1.0 - exp2(fragCoordZ * log(cameraFar + 1.0) / log(2.0));\n          #else\n            float viewZ = perspectiveDepthToViewZ(fragCoordZ, cameraNear, cameraFar);\n          #endif\n\n          return viewZ;\n        }\n\n        void main() {\n          #include <logdepthbuf_fragment>\n\n          vec3 normal = vec3(vNormal.x, vNormal.y, abs(vNormal.z));\n          float angleIntensity = pow(dot(normal, vec3(0, 0, 1)), anglePower);\n          float intensity = vIntensity * angleIntensity;\n\n          // fades when z is close to sampled depth, meaning the cone is intersecting existing geometry\n          bool isSoft = resolution[0] > 0.0 && resolution[1] > 0.0;\n          if (isSoft) {\n            vec2 uv = gl_FragCoord.xy / resolution;\n            intensity *= smoothstep(0.0, 1.0, vViewZ - readDepth(depth, uv));\n          }\n\n          gl_FragColor = vec4(lightColor, intensity * opacity);\n\n          #include <tonemapping_fragment>\n          #include <${version >= 154 ? 'colorspace_fragment' : 'encodings_fragment'}>\n        }\n      `\n    });\n  }\n}\n\nexport { SpotLightMaterial };\n"],"mappings":";;;;AAAA,OAAO,KAAKA,KAAK,MAAM,OAAO;AAC9B,SAASC,OAAO,QAAQ,yBAAyB;AAAC,IAE5CC,iBAAiB,0BAAAC,qBAAA;EAAAC,SAAA,CAAAF,iBAAA,EAAAC,qBAAA;EAAA,IAAAE,MAAA,GAAAC,YAAA,CAAAJ,iBAAA;EACrB,SAAAA,kBAAA,EAAc;IAAAK,eAAA,OAAAL,iBAAA;IAAA,OAAAG,MAAA,CAAAG,IAAA,OACN;MACJC,QAAQ,EAAE;QACRC,KAAK,EAAE;UACLC,KAAK,EAAE;QACT,CAAC;QACDC,OAAO,EAAE;UACPD,KAAK,EAAE;QACT,CAAC;QACDE,WAAW,EAAE;UACXF,KAAK,EAAE;QACT,CAAC;QACDG,UAAU,EAAE;UACVH,KAAK,EAAE;QACT,CAAC;QACDI,YAAY,EAAE;UACZJ,KAAK,EAAE,IAAIX,KAAK,CAACgB,OAAO,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC;QAClC,CAAC;QACDC,UAAU,EAAE;UACVN,KAAK,EAAE,IAAIX,KAAK,CAACkB,KAAK,CAAC,OAAO;QAChC,CAAC;QACDC,UAAU,EAAE;UACVR,KAAK,EAAE;QACT,CAAC;QACDS,SAAS,EAAE;UACTT,KAAK,EAAE;QACT,CAAC;QACDU,UAAU,EAAE;UACVV,KAAK,EAAE,IAAIX,KAAK,CAACsB,OAAO,CAAC,CAAC,EAAE,CAAC;QAC/B;MACF,CAAC;MACDC,WAAW,EAAE,IAAI;MACjBC,UAAU,EAAE,KAAK;MACjBC,YAAY,EAAE,2uBAuBb;MACDC,cAAc,EAAE,8mDAAAC,MAAA,CA8CA1B,OAAO,IAAI,GAAG,GAAG,qBAAqB,GAAG,oBAAoB;IAG/E,CAAC;EACH;EAAC,OAAA2B,YAAA,CAAA1B,iBAAA;AAAA,EA5G6BF,KAAK,CAAC6B,cAAc;AA+GpD,SAAS3B,iBAAiB"},"metadata":{},"sourceType":"module","externalDependencies":[]}