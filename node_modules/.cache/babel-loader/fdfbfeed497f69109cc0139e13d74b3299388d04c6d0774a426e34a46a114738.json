{"ast":null,"code":"import _createClass from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _classCallCheck from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _assertThisInitialized from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js\";\nimport _inherits from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = function __defNormalProp(obj, key, value) {\n  return key in obj ? __defProp(obj, key, {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: value\n  }) : obj[key] = value;\n};\nvar __publicField = function __publicField(obj, key, value) {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nimport { Mesh, Matrix4, Vector2, Color, Vector3, PerspectiveCamera, DepthTexture, UnsignedShortType, NearestFilter, WebGLRenderTarget, ShaderMaterial, UniformsUtils, Plane, HalfFloatType } from \"three\";\nvar _ReflectorForSSRPass = /*#__PURE__*/function (_Mesh) {\n  _inherits(_ReflectorForSSRPass, _Mesh);\n  var _super = _createSuper(_ReflectorForSSRPass);\n  function _ReflectorForSSRPass(geometry) {\n    var _this;\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    _classCallCheck(this, _ReflectorForSSRPass);\n    _this = _super.call(this, geometry);\n    _this.isReflectorForSSRPass = true;\n    _this.type = \"ReflectorForSSRPass\";\n    var scope = _assertThisInitialized(_this);\n    var color = options.color !== void 0 ? new Color(options.color) : new Color(8355711);\n    var textureWidth = options.textureWidth || 512;\n    var textureHeight = options.textureHeight || 512;\n    var clipBias = options.clipBias || 0;\n    var shader = options.shader || _ReflectorForSSRPass.ReflectorShader;\n    var useDepthTexture = options.useDepthTexture === true;\n    var yAxis = new Vector3(0, 1, 0);\n    var vecTemp0 = new Vector3();\n    var vecTemp1 = new Vector3();\n    scope.needsUpdate = false;\n    scope.maxDistance = _ReflectorForSSRPass.ReflectorShader.uniforms.maxDistance.value;\n    scope.opacity = _ReflectorForSSRPass.ReflectorShader.uniforms.opacity.value;\n    scope.color = color;\n    scope.resolution = options.resolution || new Vector2(window.innerWidth, window.innerHeight);\n    scope._distanceAttenuation = _ReflectorForSSRPass.ReflectorShader.defines.DISTANCE_ATTENUATION;\n    Object.defineProperty(scope, \"distanceAttenuation\", {\n      get: function get() {\n        return scope._distanceAttenuation;\n      },\n      set: function set(val) {\n        if (scope._distanceAttenuation === val) return;\n        scope._distanceAttenuation = val;\n        scope.material.defines.DISTANCE_ATTENUATION = val;\n        scope.material.needsUpdate = true;\n      }\n    });\n    scope._fresnel = _ReflectorForSSRPass.ReflectorShader.defines.FRESNEL;\n    Object.defineProperty(scope, \"fresnel\", {\n      get: function get() {\n        return scope._fresnel;\n      },\n      set: function set(val) {\n        if (scope._fresnel === val) return;\n        scope._fresnel = val;\n        scope.material.defines.FRESNEL = val;\n        scope.material.needsUpdate = true;\n      }\n    });\n    var normal = new Vector3();\n    var reflectorWorldPosition = new Vector3();\n    var cameraWorldPosition = new Vector3();\n    var rotationMatrix = new Matrix4();\n    var lookAtPosition = new Vector3(0, 0, -1);\n    var view = new Vector3();\n    var target = new Vector3();\n    var textureMatrix = new Matrix4();\n    var virtualCamera = new PerspectiveCamera();\n    var depthTexture;\n    if (useDepthTexture) {\n      depthTexture = new DepthTexture();\n      depthTexture.type = UnsignedShortType;\n      depthTexture.minFilter = NearestFilter;\n      depthTexture.magFilter = NearestFilter;\n    }\n    var parameters = {\n      depthTexture: useDepthTexture ? depthTexture : null,\n      type: HalfFloatType\n    };\n    var renderTarget = new WebGLRenderTarget(textureWidth, textureHeight, parameters);\n    var material = new ShaderMaterial({\n      transparent: useDepthTexture,\n      defines: Object.assign({}, _ReflectorForSSRPass.ReflectorShader.defines, {\n        useDepthTexture: useDepthTexture\n      }),\n      uniforms: UniformsUtils.clone(shader.uniforms),\n      fragmentShader: shader.fragmentShader,\n      vertexShader: shader.vertexShader\n    });\n    material.uniforms[\"tDiffuse\"].value = renderTarget.texture;\n    material.uniforms[\"color\"].value = scope.color;\n    material.uniforms[\"textureMatrix\"].value = textureMatrix;\n    if (useDepthTexture) {\n      material.uniforms[\"tDepth\"].value = renderTarget.depthTexture;\n    }\n    _this.material = material;\n    var globalPlane = new Plane(new Vector3(0, 1, 0), clipBias);\n    var globalPlanes = [globalPlane];\n    _this.doRender = function (renderer, scene, camera) {\n      material.uniforms[\"maxDistance\"].value = scope.maxDistance;\n      material.uniforms[\"color\"].value = scope.color;\n      material.uniforms[\"opacity\"].value = scope.opacity;\n      vecTemp0.copy(camera.position).normalize();\n      vecTemp1.copy(vecTemp0).reflect(yAxis);\n      material.uniforms[\"fresnelCoe\"].value = (vecTemp0.dot(vecTemp1) + 1) / 2;\n      reflectorWorldPosition.setFromMatrixPosition(scope.matrixWorld);\n      cameraWorldPosition.setFromMatrixPosition(camera.matrixWorld);\n      rotationMatrix.extractRotation(scope.matrixWorld);\n      normal.set(0, 0, 1);\n      normal.applyMatrix4(rotationMatrix);\n      view.subVectors(reflectorWorldPosition, cameraWorldPosition);\n      if (view.dot(normal) > 0) return;\n      view.reflect(normal).negate();\n      view.add(reflectorWorldPosition);\n      rotationMatrix.extractRotation(camera.matrixWorld);\n      lookAtPosition.set(0, 0, -1);\n      lookAtPosition.applyMatrix4(rotationMatrix);\n      lookAtPosition.add(cameraWorldPosition);\n      target.subVectors(reflectorWorldPosition, lookAtPosition);\n      target.reflect(normal).negate();\n      target.add(reflectorWorldPosition);\n      virtualCamera.position.copy(view);\n      virtualCamera.up.set(0, 1, 0);\n      virtualCamera.up.applyMatrix4(rotationMatrix);\n      virtualCamera.up.reflect(normal);\n      virtualCamera.lookAt(target);\n      virtualCamera.far = camera.far;\n      virtualCamera.updateMatrixWorld();\n      virtualCamera.projectionMatrix.copy(camera.projectionMatrix);\n      material.uniforms[\"virtualCameraNear\"].value = camera.near;\n      material.uniforms[\"virtualCameraFar\"].value = camera.far;\n      material.uniforms[\"virtualCameraMatrixWorld\"].value = virtualCamera.matrixWorld;\n      material.uniforms[\"virtualCameraProjectionMatrix\"].value = camera.projectionMatrix;\n      material.uniforms[\"virtualCameraProjectionMatrixInverse\"].value = camera.projectionMatrixInverse;\n      material.uniforms[\"resolution\"].value = scope.resolution;\n      textureMatrix.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1);\n      textureMatrix.multiply(virtualCamera.projectionMatrix);\n      textureMatrix.multiply(virtualCamera.matrixWorldInverse);\n      textureMatrix.multiply(scope.matrixWorld);\n      var currentRenderTarget = renderer.getRenderTarget();\n      var currentXrEnabled = renderer.xr.enabled;\n      var currentShadowAutoUpdate = renderer.shadowMap.autoUpdate;\n      var currentClippingPlanes = renderer.clippingPlanes;\n      renderer.xr.enabled = false;\n      renderer.shadowMap.autoUpdate = false;\n      renderer.clippingPlanes = globalPlanes;\n      renderer.setRenderTarget(renderTarget);\n      renderer.state.buffers.depth.setMask(true);\n      if (renderer.autoClear === false) renderer.clear();\n      renderer.render(scene, virtualCamera);\n      renderer.xr.enabled = currentXrEnabled;\n      renderer.shadowMap.autoUpdate = currentShadowAutoUpdate;\n      renderer.clippingPlanes = currentClippingPlanes;\n      renderer.setRenderTarget(currentRenderTarget);\n      var viewport = camera.viewport;\n      if (viewport !== void 0) {\n        renderer.state.viewport(viewport);\n      }\n    };\n    _this.getRenderTarget = function () {\n      return renderTarget;\n    };\n    return _this;\n  }\n  return _createClass(_ReflectorForSSRPass);\n}(Mesh);\nvar ReflectorForSSRPass = _ReflectorForSSRPass;\n__publicField(ReflectorForSSRPass, \"ReflectorShader\", {\n  defines: {\n    DISTANCE_ATTENUATION: true,\n    FRESNEL: true\n  },\n  uniforms: {\n    color: {\n      value: null\n    },\n    tDiffuse: {\n      value: null\n    },\n    tDepth: {\n      value: null\n    },\n    textureMatrix: {\n      value: new Matrix4()\n    },\n    maxDistance: {\n      value: 180\n    },\n    opacity: {\n      value: 0.5\n    },\n    fresnelCoe: {\n      value: null\n    },\n    virtualCameraNear: {\n      value: null\n    },\n    virtualCameraFar: {\n      value: null\n    },\n    virtualCameraProjectionMatrix: {\n      value: new Matrix4()\n    },\n    virtualCameraMatrixWorld: {\n      value: new Matrix4()\n    },\n    virtualCameraProjectionMatrixInverse: {\n      value: new Matrix4()\n    },\n    resolution: {\n      value: new Vector2()\n    }\n  },\n  vertexShader: /* glsl */\"\\n\\t\\tuniform mat4 textureMatrix;\\n\\t\\tvarying vec4 vUv;\\n\\n\\t\\tvoid main() {\\n\\n\\t\\t\\tvUv = textureMatrix * vec4( position, 1.0 );\\n\\n\\t\\t\\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n\\n\\t\\t}\",\n  fragmentShader: /* glsl */\"\\n\\t\\tuniform vec3 color;\\n\\t\\tuniform sampler2D tDiffuse;\\n\\t\\tuniform sampler2D tDepth;\\n\\t\\tuniform float maxDistance;\\n\\t\\tuniform float opacity;\\n\\t\\tuniform float fresnelCoe;\\n\\t\\tuniform float virtualCameraNear;\\n\\t\\tuniform float virtualCameraFar;\\n\\t\\tuniform mat4 virtualCameraProjectionMatrix;\\n\\t\\tuniform mat4 virtualCameraProjectionMatrixInverse;\\n\\t\\tuniform mat4 virtualCameraMatrixWorld;\\n\\t\\tuniform vec2 resolution;\\n\\t\\tvarying vec4 vUv;\\n\\t\\t#include <packing>\\n\\t\\tfloat blendOverlay( float base, float blend ) {\\n\\t\\t\\treturn( base < 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );\\n\\t\\t}\\n\\t\\tvec3 blendOverlay( vec3 base, vec3 blend ) {\\n\\t\\t\\treturn vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ), blendOverlay( base.b, blend.b ) );\\n\\t\\t}\\n\\t\\tfloat getDepth( const in vec2 uv ) {\\n\\t\\t\\treturn texture2D( tDepth, uv ).x;\\n\\t\\t}\\n\\t\\tfloat getViewZ( const in float depth ) {\\n\\t\\t\\treturn perspectiveDepthToViewZ( depth, virtualCameraNear, virtualCameraFar );\\n\\t\\t}\\n\\t\\tvec3 getViewPosition( const in vec2 uv, const in float depth/*clip space*/, const in float clipW ) {\\n\\t\\t\\tvec4 clipPosition = vec4( ( vec3( uv, depth ) - 0.5 ) * 2.0, 1.0 );//ndc\\n\\t\\t\\tclipPosition *= clipW; //clip\\n\\t\\t\\treturn ( virtualCameraProjectionMatrixInverse * clipPosition ).xyz;//view\\n\\t\\t}\\n\\t\\tvoid main() {\\n\\t\\t\\tvec4 base = texture2DProj( tDiffuse, vUv );\\n\\t\\t\\t#ifdef useDepthTexture\\n\\t\\t\\t\\tvec2 uv=(gl_FragCoord.xy-.5)/resolution.xy;\\n\\t\\t\\t\\tuv.x=1.-uv.x;\\n\\t\\t\\t\\tfloat depth = texture2DProj( tDepth, vUv ).r;\\n\\t\\t\\t\\tfloat viewZ = getViewZ( depth );\\n\\t\\t\\t\\tfloat clipW = virtualCameraProjectionMatrix[2][3] * viewZ+virtualCameraProjectionMatrix[3][3];\\n\\t\\t\\t\\tvec3 viewPosition=getViewPosition( uv, depth, clipW );\\n\\t\\t\\t\\tvec3 worldPosition=(virtualCameraMatrixWorld*vec4(viewPosition,1)).xyz;\\n\\t\\t\\t\\tif(worldPosition.y>maxDistance) discard;\\n\\t\\t\\t\\tfloat op=opacity;\\n\\t\\t\\t\\t#ifdef DISTANCE_ATTENUATION\\n\\t\\t\\t\\t\\tfloat ratio=1.-(worldPosition.y/maxDistance);\\n\\t\\t\\t\\t\\tfloat attenuation=ratio*ratio;\\n\\t\\t\\t\\t\\top=opacity*attenuation;\\n\\t\\t\\t\\t#endif\\n\\t\\t\\t\\t#ifdef FRESNEL\\n\\t\\t\\t\\t\\top*=fresnelCoe;\\n\\t\\t\\t\\t#endif\\n\\t\\t\\t\\tgl_FragColor = vec4( blendOverlay( base.rgb, color ), op );\\n\\t\\t\\t#else\\n\\t\\t\\t\\tgl_FragColor = vec4( blendOverlay( base.rgb, color ), 1.0 );\\n\\t\\t\\t#endif\\n\\t\\t}\\n\\t\"\n});\nexport { ReflectorForSSRPass };","map":{"version":3,"names":["_ReflectorForSSRPass","_Mesh","_inherits","_super","_createSuper","geometry","_this","options","arguments","length","undefined","_classCallCheck","call","isReflectorForSSRPass","type","scope","_assertThisInitialized","color","Color","textureWidth","textureHeight","clipBias","shader","ReflectorShader","useDepthTexture","yAxis","Vector3","vecTemp0","vecTemp1","needsUpdate","maxDistance","uniforms","value","opacity","resolution","Vector2","window","innerWidth","innerHeight","_distanceAttenuation","defines","DISTANCE_ATTENUATION","Object","defineProperty","get","set","val","material","_fresnel","FRESNEL","normal","reflectorWorldPosition","cameraWorldPosition","rotationMatrix","Matrix4","lookAtPosition","view","target","textureMatrix","virtualCamera","PerspectiveCamera","depthTexture","DepthTexture","UnsignedShortType","minFilter","NearestFilter","magFilter","parameters","HalfFloatType","renderTarget","WebGLRenderTarget","ShaderMaterial","transparent","assign","UniformsUtils","clone","fragmentShader","vertexShader","texture","globalPlane","Plane","globalPlanes","doRender","renderer","scene","camera","copy","position","normalize","reflect","dot","setFromMatrixPosition","matrixWorld","extractRotation","applyMatrix4","subVectors","negate","add","up","lookAt","far","updateMatrixWorld","projectionMatrix","near","projectionMatrixInverse","multiply","matrixWorldInverse","currentRenderTarget","getRenderTarget","currentXrEnabled","xr","enabled","currentShadowAutoUpdate","shadowMap","autoUpdate","currentClippingPlanes","clippingPlanes","setRenderTarget","state","buffers","depth","setMask","autoClear","clear","render","viewport","_createClass","Mesh","ReflectorForSSRPass","__publicField","tDiffuse","tDepth","fresnelCoe","virtualCameraNear","virtualCameraFar","virtualCameraProjectionMatrix","virtualCameraMatrixWorld","virtualCameraProjectionMatrixInverse"],"sources":["C:\\Users\\Nayyu\\Desktop\\skibidai-public-build\\node_modules\\src\\objects\\ReflectorForSSRPass.js"],"sourcesContent":["import {\n  Color,\n  Matrix4,\n  Mesh,\n  PerspectiveCamera,\n  ShaderMaterial,\n  UniformsUtils,\n  Vector2,\n  Vector3,\n  WebGLRenderTarget,\n  DepthTexture,\n  UnsignedShortType,\n  NearestFilter,\n  Plane,\n  HalfFloatType,\n} from 'three'\n\nclass ReflectorForSSRPass extends Mesh {\n  static ReflectorShader = {\n    defines: {\n      DISTANCE_ATTENUATION: true,\n      FRESNEL: true,\n    },\n\n    uniforms: {\n      color: { value: null },\n      tDiffuse: { value: null },\n      tDepth: { value: null },\n      textureMatrix: { value: new Matrix4() },\n      maxDistance: { value: 180 },\n      opacity: { value: 0.5 },\n      fresnelCoe: { value: null },\n      virtualCameraNear: { value: null },\n      virtualCameraFar: { value: null },\n      virtualCameraProjectionMatrix: { value: new Matrix4() },\n      virtualCameraMatrixWorld: { value: new Matrix4() },\n      virtualCameraProjectionMatrixInverse: { value: new Matrix4() },\n      resolution: { value: new Vector2() },\n    },\n\n    vertexShader: /* glsl */ `\n\t\tuniform mat4 textureMatrix;\n\t\tvarying vec4 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvUv = textureMatrix * vec4( position, 1.0 );\n\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t}`,\n\n    fragmentShader: /* glsl */ `\n\t\tuniform vec3 color;\n\t\tuniform sampler2D tDiffuse;\n\t\tuniform sampler2D tDepth;\n\t\tuniform float maxDistance;\n\t\tuniform float opacity;\n\t\tuniform float fresnelCoe;\n\t\tuniform float virtualCameraNear;\n\t\tuniform float virtualCameraFar;\n\t\tuniform mat4 virtualCameraProjectionMatrix;\n\t\tuniform mat4 virtualCameraProjectionMatrixInverse;\n\t\tuniform mat4 virtualCameraMatrixWorld;\n\t\tuniform vec2 resolution;\n\t\tvarying vec4 vUv;\n\t\t#include <packing>\n\t\tfloat blendOverlay( float base, float blend ) {\n\t\t\treturn( base < 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );\n\t\t}\n\t\tvec3 blendOverlay( vec3 base, vec3 blend ) {\n\t\t\treturn vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ), blendOverlay( base.b, blend.b ) );\n\t\t}\n\t\tfloat getDepth( const in vec2 uv ) {\n\t\t\treturn texture2D( tDepth, uv ).x;\n\t\t}\n\t\tfloat getViewZ( const in float depth ) {\n\t\t\treturn perspectiveDepthToViewZ( depth, virtualCameraNear, virtualCameraFar );\n\t\t}\n\t\tvec3 getViewPosition( const in vec2 uv, const in float depth/*clip space*/, const in float clipW ) {\n\t\t\tvec4 clipPosition = vec4( ( vec3( uv, depth ) - 0.5 ) * 2.0, 1.0 );//ndc\n\t\t\tclipPosition *= clipW; //clip\n\t\t\treturn ( virtualCameraProjectionMatrixInverse * clipPosition ).xyz;//view\n\t\t}\n\t\tvoid main() {\n\t\t\tvec4 base = texture2DProj( tDiffuse, vUv );\n\t\t\t#ifdef useDepthTexture\n\t\t\t\tvec2 uv=(gl_FragCoord.xy-.5)/resolution.xy;\n\t\t\t\tuv.x=1.-uv.x;\n\t\t\t\tfloat depth = texture2DProj( tDepth, vUv ).r;\n\t\t\t\tfloat viewZ = getViewZ( depth );\n\t\t\t\tfloat clipW = virtualCameraProjectionMatrix[2][3] * viewZ+virtualCameraProjectionMatrix[3][3];\n\t\t\t\tvec3 viewPosition=getViewPosition( uv, depth, clipW );\n\t\t\t\tvec3 worldPosition=(virtualCameraMatrixWorld*vec4(viewPosition,1)).xyz;\n\t\t\t\tif(worldPosition.y>maxDistance) discard;\n\t\t\t\tfloat op=opacity;\n\t\t\t\t#ifdef DISTANCE_ATTENUATION\n\t\t\t\t\tfloat ratio=1.-(worldPosition.y/maxDistance);\n\t\t\t\t\tfloat attenuation=ratio*ratio;\n\t\t\t\t\top=opacity*attenuation;\n\t\t\t\t#endif\n\t\t\t\t#ifdef FRESNEL\n\t\t\t\t\top*=fresnelCoe;\n\t\t\t\t#endif\n\t\t\t\tgl_FragColor = vec4( blendOverlay( base.rgb, color ), op );\n\t\t\t#else\n\t\t\t\tgl_FragColor = vec4( blendOverlay( base.rgb, color ), 1.0 );\n\t\t\t#endif\n\t\t}\n\t`,\n  }\n\n  constructor(geometry, options = {}) {\n    super(geometry)\n\n    this.isReflectorForSSRPass = true\n\n    this.type = 'ReflectorForSSRPass'\n\n    const scope = this\n\n    const color = options.color !== undefined ? new Color(options.color) : new Color(0x7f7f7f)\n    const textureWidth = options.textureWidth || 512\n    const textureHeight = options.textureHeight || 512\n    const clipBias = options.clipBias || 0\n    const shader = options.shader || ReflectorForSSRPass.ReflectorShader\n    const useDepthTexture = options.useDepthTexture === true\n    const yAxis = new Vector3(0, 1, 0)\n    const vecTemp0 = new Vector3()\n    const vecTemp1 = new Vector3()\n\n    //\n\n    scope.needsUpdate = false\n    scope.maxDistance = ReflectorForSSRPass.ReflectorShader.uniforms.maxDistance.value\n    scope.opacity = ReflectorForSSRPass.ReflectorShader.uniforms.opacity.value\n    scope.color = color\n    scope.resolution = options.resolution || new Vector2(window.innerWidth, window.innerHeight)\n\n    scope._distanceAttenuation = ReflectorForSSRPass.ReflectorShader.defines.DISTANCE_ATTENUATION\n    Object.defineProperty(scope, 'distanceAttenuation', {\n      get() {\n        return scope._distanceAttenuation\n      },\n      set(val) {\n        if (scope._distanceAttenuation === val) return\n        scope._distanceAttenuation = val\n        scope.material.defines.DISTANCE_ATTENUATION = val\n        scope.material.needsUpdate = true\n      },\n    })\n\n    scope._fresnel = ReflectorForSSRPass.ReflectorShader.defines.FRESNEL\n    Object.defineProperty(scope, 'fresnel', {\n      get() {\n        return scope._fresnel\n      },\n      set(val) {\n        if (scope._fresnel === val) return\n        scope._fresnel = val\n        scope.material.defines.FRESNEL = val\n        scope.material.needsUpdate = true\n      },\n    })\n\n    const normal = new Vector3()\n    const reflectorWorldPosition = new Vector3()\n    const cameraWorldPosition = new Vector3()\n    const rotationMatrix = new Matrix4()\n    const lookAtPosition = new Vector3(0, 0, -1)\n\n    const view = new Vector3()\n    const target = new Vector3()\n\n    const textureMatrix = new Matrix4()\n    const virtualCamera = new PerspectiveCamera()\n\n    let depthTexture\n\n    if (useDepthTexture) {\n      depthTexture = new DepthTexture()\n      depthTexture.type = UnsignedShortType\n      depthTexture.minFilter = NearestFilter\n      depthTexture.magFilter = NearestFilter\n    }\n\n    const parameters = {\n      depthTexture: useDepthTexture ? depthTexture : null,\n      type: HalfFloatType,\n    }\n\n    const renderTarget = new WebGLRenderTarget(textureWidth, textureHeight, parameters)\n\n    const material = new ShaderMaterial({\n      transparent: useDepthTexture,\n      defines: Object.assign({}, ReflectorForSSRPass.ReflectorShader.defines, {\n        useDepthTexture,\n      }),\n      uniforms: UniformsUtils.clone(shader.uniforms),\n      fragmentShader: shader.fragmentShader,\n      vertexShader: shader.vertexShader,\n    })\n\n    material.uniforms['tDiffuse'].value = renderTarget.texture\n    material.uniforms['color'].value = scope.color\n    material.uniforms['textureMatrix'].value = textureMatrix\n    if (useDepthTexture) {\n      material.uniforms['tDepth'].value = renderTarget.depthTexture\n    }\n\n    this.material = material\n\n    const globalPlane = new Plane(new Vector3(0, 1, 0), clipBias)\n    const globalPlanes = [globalPlane]\n\n    this.doRender = function (renderer, scene, camera) {\n      material.uniforms['maxDistance'].value = scope.maxDistance\n      material.uniforms['color'].value = scope.color\n      material.uniforms['opacity'].value = scope.opacity\n\n      vecTemp0.copy(camera.position).normalize()\n      vecTemp1.copy(vecTemp0).reflect(yAxis)\n      material.uniforms['fresnelCoe'].value = (vecTemp0.dot(vecTemp1) + 1) / 2 // TODO: Also need to use glsl viewPosition and viewNormal per pixel.\n\n      reflectorWorldPosition.setFromMatrixPosition(scope.matrixWorld)\n      cameraWorldPosition.setFromMatrixPosition(camera.matrixWorld)\n\n      rotationMatrix.extractRotation(scope.matrixWorld)\n\n      normal.set(0, 0, 1)\n      normal.applyMatrix4(rotationMatrix)\n\n      view.subVectors(reflectorWorldPosition, cameraWorldPosition)\n\n      // Avoid rendering when reflector is facing away\n\n      if (view.dot(normal) > 0) return\n\n      view.reflect(normal).negate()\n      view.add(reflectorWorldPosition)\n\n      rotationMatrix.extractRotation(camera.matrixWorld)\n\n      lookAtPosition.set(0, 0, -1)\n      lookAtPosition.applyMatrix4(rotationMatrix)\n      lookAtPosition.add(cameraWorldPosition)\n\n      target.subVectors(reflectorWorldPosition, lookAtPosition)\n      target.reflect(normal).negate()\n      target.add(reflectorWorldPosition)\n\n      virtualCamera.position.copy(view)\n      virtualCamera.up.set(0, 1, 0)\n      virtualCamera.up.applyMatrix4(rotationMatrix)\n      virtualCamera.up.reflect(normal)\n      virtualCamera.lookAt(target)\n\n      virtualCamera.far = camera.far // Used in WebGLBackground\n\n      virtualCamera.updateMatrixWorld()\n      virtualCamera.projectionMatrix.copy(camera.projectionMatrix)\n\n      material.uniforms['virtualCameraNear'].value = camera.near\n      material.uniforms['virtualCameraFar'].value = camera.far\n      material.uniforms['virtualCameraMatrixWorld'].value = virtualCamera.matrixWorld\n      material.uniforms['virtualCameraProjectionMatrix'].value = camera.projectionMatrix\n      material.uniforms['virtualCameraProjectionMatrixInverse'].value = camera.projectionMatrixInverse\n      material.uniforms['resolution'].value = scope.resolution\n\n      // Update the texture matrix\n      textureMatrix.set(0.5, 0.0, 0.0, 0.5, 0.0, 0.5, 0.0, 0.5, 0.0, 0.0, 0.5, 0.5, 0.0, 0.0, 0.0, 1.0)\n      textureMatrix.multiply(virtualCamera.projectionMatrix)\n      textureMatrix.multiply(virtualCamera.matrixWorldInverse)\n      textureMatrix.multiply(scope.matrixWorld)\n\n      // scope.visible = false;\n\n      const currentRenderTarget = renderer.getRenderTarget()\n\n      const currentXrEnabled = renderer.xr.enabled\n      const currentShadowAutoUpdate = renderer.shadowMap.autoUpdate\n      const currentClippingPlanes = renderer.clippingPlanes\n\n      renderer.xr.enabled = false // Avoid camera modification\n      renderer.shadowMap.autoUpdate = false // Avoid re-computing shadows\n      renderer.clippingPlanes = globalPlanes\n\n      renderer.setRenderTarget(renderTarget)\n\n      renderer.state.buffers.depth.setMask(true) // make sure the depth buffer is writable so it can be properly cleared, see #18897\n\n      if (renderer.autoClear === false) renderer.clear()\n      renderer.render(scene, virtualCamera)\n\n      renderer.xr.enabled = currentXrEnabled\n      renderer.shadowMap.autoUpdate = currentShadowAutoUpdate\n      renderer.clippingPlanes = currentClippingPlanes\n\n      renderer.setRenderTarget(currentRenderTarget)\n\n      // Restore viewport\n\n      const viewport = camera.viewport\n\n      if (viewport !== undefined) {\n        renderer.state.viewport(viewport)\n      }\n\n      // scope.visible = true;\n    }\n\n    this.getRenderTarget = function () {\n      return renderTarget\n    }\n  }\n}\n\nexport { ReflectorForSSRPass }\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}