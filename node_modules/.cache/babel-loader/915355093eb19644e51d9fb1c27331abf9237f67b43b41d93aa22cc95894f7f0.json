{"ast":null,"code":"import _classCallCheck from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _get from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/get.js\";\nimport _getPrototypeOf from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js\";\nimport _inherits from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport { Object3D, MeshBasicMaterial, MathUtils, Mesh } from \"three\";\nimport { LightningStrike } from \"../geometries/LightningStrike.js\";\nvar LightningStorm = /*#__PURE__*/function (_Object3D) {\n  _inherits(LightningStorm, _Object3D);\n  var _super = _createSuper(LightningStorm);\n  function LightningStorm() {\n    var _this;\n    var stormParams = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    _classCallCheck(this, LightningStorm);\n    _this = _super.call(this);\n    _this.isLightningStorm = true;\n    _this.stormParams = stormParams;\n    stormParams.size = stormParams.size !== void 0 ? stormParams.size : 1e3;\n    stormParams.minHeight = stormParams.minHeight !== void 0 ? stormParams.minHeight : 80;\n    stormParams.maxHeight = stormParams.maxHeight !== void 0 ? stormParams.maxHeight : 100;\n    stormParams.maxSlope = stormParams.maxSlope !== void 0 ? stormParams.maxSlope : 1.1;\n    stormParams.maxLightnings = stormParams.maxLightnings !== void 0 ? stormParams.maxLightnings : 3;\n    stormParams.lightningMinPeriod = stormParams.lightningMinPeriod !== void 0 ? stormParams.lightningMinPeriod : 3;\n    stormParams.lightningMaxPeriod = stormParams.lightningMaxPeriod !== void 0 ? stormParams.lightningMaxPeriod : 7;\n    stormParams.lightningMinDuration = stormParams.lightningMinDuration !== void 0 ? stormParams.lightningMinDuration : 1;\n    stormParams.lightningMaxDuration = stormParams.lightningMaxDuration !== void 0 ? stormParams.lightningMaxDuration : 2.5;\n    _this.lightningParameters = LightningStrike.copyParameters(stormParams.lightningParameters, stormParams.lightningParameters);\n    _this.lightningParameters.isEternal = false;\n    _this.lightningMaterial = stormParams.lightningMaterial !== void 0 ? stormParams.lightningMaterial : new MeshBasicMaterial({\n      color: 11599871\n    });\n    if (stormParams.onRayPosition !== void 0) {\n      _this.onRayPosition = stormParams.onRayPosition;\n    } else {\n      _this.onRayPosition = function (source, dest) {\n        dest.set((Math.random() - 0.5) * stormParams.size, 0, (Math.random() - 0.5) * stormParams.size);\n        var height = MathUtils.lerp(stormParams.minHeight, stormParams.maxHeight, Math.random());\n        source.set(stormParams.maxSlope * (2 * Math.random() - 1), 1, stormParams.maxSlope * (2 * Math.random() - 1)).multiplyScalar(height).add(dest);\n      };\n    }\n    _this.onLightningDown = stormParams.onLightningDown;\n    _this.inited = false;\n    _this.nextLightningTime = 0;\n    _this.lightningsMeshes = [];\n    _this.deadLightningsMeshes = [];\n    for (var i = 0; i < _this.stormParams.maxLightnings; i++) {\n      var lightning = new LightningStrike(LightningStrike.copyParameters({}, _this.lightningParameters));\n      var mesh = new Mesh(lightning, _this.lightningMaterial);\n      _this.deadLightningsMeshes.push(mesh);\n    }\n    return _this;\n  }\n  _createClass(LightningStorm, [{\n    key: \"update\",\n    value: function update(time) {\n      if (!this.inited) {\n        this.nextLightningTime = this.getNextLightningTime(time) * Math.random();\n        this.inited = true;\n      }\n      if (time >= this.nextLightningTime) {\n        var lightningMesh = this.deadLightningsMeshes.pop();\n        if (lightningMesh) {\n          var lightningParams1 = LightningStrike.copyParameters(lightningMesh.geometry.rayParameters, this.lightningParameters);\n          lightningParams1.birthTime = time;\n          lightningParams1.deathTime = time + MathUtils.lerp(this.stormParams.lightningMinDuration, this.stormParams.lightningMaxDuration, Math.random());\n          this.onRayPosition(lightningParams1.sourceOffset, lightningParams1.destOffset);\n          lightningParams1.noiseSeed = Math.random();\n          this.add(lightningMesh);\n          this.lightningsMeshes.push(lightningMesh);\n        }\n        this.nextLightningTime = this.getNextLightningTime(time);\n      }\n      var i = 0,\n        il = this.lightningsMeshes.length;\n      while (i < il) {\n        var mesh = this.lightningsMeshes[i];\n        var lightning = mesh.geometry;\n        var prevState = lightning.state;\n        lightning.update(time);\n        if (prevState === LightningStrike.RAY_PROPAGATING && lightning.state > prevState) {\n          if (this.onLightningDown) {\n            this.onLightningDown(lightning);\n          }\n        }\n        if (lightning.state === LightningStrike.RAY_EXTINGUISHED) {\n          this.lightningsMeshes.splice(this.lightningsMeshes.indexOf(mesh), 1);\n          this.deadLightningsMeshes.push(mesh);\n          this.remove(mesh);\n          il--;\n        } else {\n          i++;\n        }\n      }\n    }\n  }, {\n    key: \"getNextLightningTime\",\n    value: function getNextLightningTime(currentTime) {\n      return currentTime + MathUtils.lerp(this.stormParams.lightningMinPeriod, this.stormParams.lightningMaxPeriod, Math.random()) / (this.stormParams.maxLightnings + 1);\n    }\n  }, {\n    key: \"copy\",\n    value: function copy(source, recursive) {\n      _get(_getPrototypeOf(LightningStorm.prototype), \"copy\", this).call(this, source, recursive);\n      this.stormParams.size = source.stormParams.size;\n      this.stormParams.minHeight = source.stormParams.minHeight;\n      this.stormParams.maxHeight = source.stormParams.maxHeight;\n      this.stormParams.maxSlope = source.stormParams.maxSlope;\n      this.stormParams.maxLightnings = source.stormParams.maxLightnings;\n      this.stormParams.lightningMinPeriod = source.stormParams.lightningMinPeriod;\n      this.stormParams.lightningMaxPeriod = source.stormParams.lightningMaxPeriod;\n      this.stormParams.lightningMinDuration = source.stormParams.lightningMinDuration;\n      this.stormParams.lightningMaxDuration = source.stormParams.lightningMaxDuration;\n      this.lightningParameters = LightningStrike.copyParameters({}, source.lightningParameters);\n      this.lightningMaterial = source.stormParams.lightningMaterial;\n      this.onLightningDown = source.onLightningDown;\n      return this;\n    }\n  }, {\n    key: \"clone\",\n    value: function clone() {\n      return new this.constructor(this.stormParams).copy(this);\n    }\n  }]);\n  return LightningStorm;\n}(Object3D);\nexport { LightningStorm };","map":{"version":3,"names":["LightningStorm","_Object3D","_inherits","_super","_createSuper","_this","stormParams","arguments","length","undefined","_classCallCheck","call","isLightningStorm","size","minHeight","maxHeight","maxSlope","maxLightnings","lightningMinPeriod","lightningMaxPeriod","lightningMinDuration","lightningMaxDuration","lightningParameters","LightningStrike","copyParameters","isEternal","lightningMaterial","MeshBasicMaterial","color","onRayPosition","source","dest","set","Math","random","height","MathUtils","lerp","multiplyScalar","add","onLightningDown","inited","nextLightningTime","lightningsMeshes","deadLightningsMeshes","i","lightning","mesh","Mesh","push","_createClass","key","value","update","time","getNextLightningTime","lightningMesh","pop","lightningParams1","geometry","rayParameters","birthTime","deathTime","sourceOffset","destOffset","noiseSeed","il","prevState","state","RAY_PROPAGATING","RAY_EXTINGUISHED","splice","indexOf","remove","currentTime","copy","recursive","_get","_getPrototypeOf","prototype","clone","constructor","Object3D"],"sources":["C:\\Users\\Nayyu\\Desktop\\skibidai-public-build\\node_modules\\src\\objects\\LightningStorm.js"],"sourcesContent":["import { MathUtils, Mesh, MeshBasicMaterial, Object3D } from 'three'\nimport { LightningStrike } from '../geometries/LightningStrike'\n\n/**\n * @fileoverview Lightning strike object generator\n *\n *\n * Usage\n *\n * const myStorm = new LightningStorm( paramsObject );\n * myStorm.position.set( ... );\n * scene.add( myStorm );\n * ...\n * myStorm.update( currentTime );\n *\n * The \"currentTime\" can only go forwards or be stopped.\n *\n *\n * LightningStorm parameters:\n *\n * @param {double} size Size of the storm. If no 'onRayPosition' parameter is defined, it means the side of the rectangle the storm covers.\n *\n * @param {double} minHeight Minimum height a ray can start at. If no 'onRayPosition' parameter is defined, it means the height above plane y = 0.\n *\n * @param {double} maxHeight Maximum height a ray can start at. If no 'onRayPosition' parameter is defined, it means the height above plane y = 0.\n *\n * @param {double} maxSlope The maximum inclination slope of a ray. If no 'onRayPosition' parameter is defined, it means the slope relative to plane y = 0.\n *\n * @param {integer} maxLightnings Greater than 0. The maximum number of simultaneous rays.\n *\n * @param {double} lightningMinPeriod minimum time between two consecutive rays.\n *\n * @param {double} lightningMaxPeriod maximum time between two consecutive rays.\n *\n * @param {double} lightningMinDuration The minimum time a ray can last.\n *\n * @param {double} lightningMaxDuration The maximum time a ray can last.\n *\n * @param {Object} lightningParameters The parameters for created rays. See LightningStrike (geometry)\n *\n * @param {Material} lightningMaterial The THREE.Material used for the created rays.\n *\n * @param {function} onRayPosition Optional callback with two Vector3 parameters (source, dest). You can set here the start and end points for each created ray, using the standard size, minHeight, etc parameters and other values in your algorithm.\n *\n * @param {function} onLightningDown This optional callback is called with one parameter (lightningStrike) when a ray ends propagating, so it has hit the ground.\n *\n *\n */\n\nclass LightningStorm extends Object3D {\n  constructor(stormParams = {}) {\n    super()\n\n    this.isLightningStorm = true\n\n    // Parameters\n\n    this.stormParams = stormParams\n\n    stormParams.size = stormParams.size !== undefined ? stormParams.size : 1000.0\n    stormParams.minHeight = stormParams.minHeight !== undefined ? stormParams.minHeight : 80.0\n    stormParams.maxHeight = stormParams.maxHeight !== undefined ? stormParams.maxHeight : 100.0\n    stormParams.maxSlope = stormParams.maxSlope !== undefined ? stormParams.maxSlope : 1.1\n\n    stormParams.maxLightnings = stormParams.maxLightnings !== undefined ? stormParams.maxLightnings : 3\n\n    stormParams.lightningMinPeriod = stormParams.lightningMinPeriod !== undefined ? stormParams.lightningMinPeriod : 3.0\n    stormParams.lightningMaxPeriod = stormParams.lightningMaxPeriod !== undefined ? stormParams.lightningMaxPeriod : 7.0\n\n    stormParams.lightningMinDuration =\n      stormParams.lightningMinDuration !== undefined ? stormParams.lightningMinDuration : 1.0\n    stormParams.lightningMaxDuration =\n      stormParams.lightningMaxDuration !== undefined ? stormParams.lightningMaxDuration : 2.5\n\n    this.lightningParameters = LightningStrike.copyParameters(\n      stormParams.lightningParameters,\n      stormParams.lightningParameters,\n    )\n\n    this.lightningParameters.isEternal = false\n\n    this.lightningMaterial =\n      stormParams.lightningMaterial !== undefined\n        ? stormParams.lightningMaterial\n        : new MeshBasicMaterial({ color: 0xb0ffff })\n\n    if (stormParams.onRayPosition !== undefined) {\n      this.onRayPosition = stormParams.onRayPosition\n    } else {\n      this.onRayPosition = function (source, dest) {\n        dest.set((Math.random() - 0.5) * stormParams.size, 0, (Math.random() - 0.5) * stormParams.size)\n\n        const height = MathUtils.lerp(stormParams.minHeight, stormParams.maxHeight, Math.random())\n\n        source\n          .set(stormParams.maxSlope * (2 * Math.random() - 1), 1, stormParams.maxSlope * (2 * Math.random() - 1))\n          .multiplyScalar(height)\n          .add(dest)\n      }\n    }\n\n    this.onLightningDown = stormParams.onLightningDown\n\n    // Internal state\n\n    this.inited = false\n    this.nextLightningTime = 0\n    this.lightningsMeshes = []\n    this.deadLightningsMeshes = []\n\n    for (let i = 0; i < this.stormParams.maxLightnings; i++) {\n      const lightning = new LightningStrike(LightningStrike.copyParameters({}, this.lightningParameters))\n      const mesh = new Mesh(lightning, this.lightningMaterial)\n      this.deadLightningsMeshes.push(mesh)\n    }\n  }\n\n  update(time) {\n    if (!this.inited) {\n      this.nextLightningTime = this.getNextLightningTime(time) * Math.random()\n      this.inited = true\n    }\n\n    if (time >= this.nextLightningTime) {\n      // Lightning creation\n\n      const lightningMesh = this.deadLightningsMeshes.pop()\n\n      if (lightningMesh) {\n        const lightningParams1 = LightningStrike.copyParameters(\n          lightningMesh.geometry.rayParameters,\n          this.lightningParameters,\n        )\n\n        lightningParams1.birthTime = time\n        lightningParams1.deathTime =\n          time +\n          MathUtils.lerp(this.stormParams.lightningMinDuration, this.stormParams.lightningMaxDuration, Math.random())\n\n        this.onRayPosition(lightningParams1.sourceOffset, lightningParams1.destOffset)\n\n        lightningParams1.noiseSeed = Math.random()\n\n        this.add(lightningMesh)\n\n        this.lightningsMeshes.push(lightningMesh)\n      }\n\n      // Schedule next lightning\n      this.nextLightningTime = this.getNextLightningTime(time)\n    }\n\n    let i = 0,\n      il = this.lightningsMeshes.length\n\n    while (i < il) {\n      const mesh = this.lightningsMeshes[i]\n\n      const lightning = mesh.geometry\n\n      const prevState = lightning.state\n\n      lightning.update(time)\n\n      if (prevState === LightningStrike.RAY_PROPAGATING && lightning.state > prevState) {\n        if (this.onLightningDown) {\n          this.onLightningDown(lightning)\n        }\n      }\n\n      if (lightning.state === LightningStrike.RAY_EXTINGUISHED) {\n        // Lightning is to be destroyed\n\n        this.lightningsMeshes.splice(this.lightningsMeshes.indexOf(mesh), 1)\n\n        this.deadLightningsMeshes.push(mesh)\n\n        this.remove(mesh)\n\n        il--\n      } else {\n        i++\n      }\n    }\n  }\n\n  getNextLightningTime(currentTime) {\n    return (\n      currentTime +\n      MathUtils.lerp(this.stormParams.lightningMinPeriod, this.stormParams.lightningMaxPeriod, Math.random()) /\n        (this.stormParams.maxLightnings + 1)\n    )\n  }\n\n  copy(source, recursive) {\n    super.copy(source, recursive)\n\n    this.stormParams.size = source.stormParams.size\n    this.stormParams.minHeight = source.stormParams.minHeight\n    this.stormParams.maxHeight = source.stormParams.maxHeight\n    this.stormParams.maxSlope = source.stormParams.maxSlope\n\n    this.stormParams.maxLightnings = source.stormParams.maxLightnings\n\n    this.stormParams.lightningMinPeriod = source.stormParams.lightningMinPeriod\n    this.stormParams.lightningMaxPeriod = source.stormParams.lightningMaxPeriod\n\n    this.stormParams.lightningMinDuration = source.stormParams.lightningMinDuration\n    this.stormParams.lightningMaxDuration = source.stormParams.lightningMaxDuration\n\n    this.lightningParameters = LightningStrike.copyParameters({}, source.lightningParameters)\n\n    this.lightningMaterial = source.stormParams.lightningMaterial\n\n    this.onLightningDown = source.onLightningDown\n\n    return this\n  }\n\n  clone() {\n    return new this.constructor(this.stormParams).copy(this)\n  }\n}\n\nexport { LightningStorm }\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}