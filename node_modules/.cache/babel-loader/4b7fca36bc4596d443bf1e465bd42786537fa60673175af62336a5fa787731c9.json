{"ast":null,"code":"import _defineProperty from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport _objectSpread from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _classCallCheck from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport { BufferAttribute, Box3, FrontSide } from 'three';\nimport { CENTER, BYTES_PER_NODE, IS_LEAFNODE_FLAG, SKIP_GENERATION } from './Constants.js';\nimport { buildPackedTree } from './build/buildTree.js';\nimport { OrientedBox } from '../math/OrientedBox.js';\nimport { arrayToBox } from '../utils/ArrayBoxUtilities.js';\nimport { ExtendedTrianglePool } from '../utils/ExtendedTrianglePool.js';\nimport { shapecast as _shapecast } from './cast/shapecast.js';\nimport { closestPointToPoint as _closestPointToPoint } from './cast/closestPointToPoint.js';\nimport { iterateOverTriangles } from './utils/iterationUtils.generated.js';\nimport { refit as _refit } from './cast/refit.generated.js';\nimport { raycast as _raycast } from './cast/raycast.generated.js';\nimport { raycastFirst as _raycastFirst } from './cast/raycastFirst.generated.js';\nimport { intersectsGeometry as _intersectsGeometry } from './cast/intersectsGeometry.generated.js';\nimport { closestPointToGeometry as _closestPointToGeometry } from './cast/closestPointToGeometry.generated.js';\nimport { iterateOverTriangles_indirect } from './utils/iterationUtils_indirect.generated.js';\nimport { refit_indirect } from './cast/refit_indirect.generated.js';\nimport { raycast_indirect } from './cast/raycast_indirect.generated.js';\nimport { raycastFirst_indirect } from './cast/raycastFirst_indirect.generated.js';\nimport { intersectsGeometry_indirect } from './cast/intersectsGeometry_indirect.generated.js';\nimport { closestPointToGeometry_indirect } from './cast/closestPointToGeometry_indirect.generated.js';\nimport { isSharedArrayBufferSupported } from '../utils/BufferUtils.js';\nimport { setTriangle } from '../utils/TriangleUtilities.js';\nimport { bvhcast as _bvhcast } from './cast/bvhcast.js';\nvar obb = /* @__PURE__ */new OrientedBox();\nvar tempBox = /* @__PURE__ */new Box3();\nexport var DEFAULT_OPTIONS = {\n  strategy: CENTER,\n  maxDepth: 40,\n  maxLeafTris: 10,\n  useSharedArrayBuffer: false,\n  setBoundingBox: true,\n  onProgress: null,\n  indirect: false,\n  verbose: true\n};\nexport var MeshBVH = /*#__PURE__*/function () {\n  function MeshBVH(geometry) {\n    var _this = this;\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    _classCallCheck(this, MeshBVH);\n    if (!geometry.isBufferGeometry) {\n      throw new Error('MeshBVH: Only BufferGeometries are supported.');\n    } else if (geometry.index && geometry.index.isInterleavedBufferAttribute) {\n      throw new Error('MeshBVH: InterleavedBufferAttribute is not supported for the index attribute.');\n    }\n\n    // default options\n    options = Object.assign(_objectSpread(_objectSpread({}, DEFAULT_OPTIONS), {}, _defineProperty({}, SKIP_GENERATION, false)), options);\n    if (options.useSharedArrayBuffer && !isSharedArrayBufferSupported()) {\n      throw new Error('MeshBVH: SharedArrayBuffer is not available.');\n    }\n\n    // retain references to the geometry so we can use them it without having to\n    // take a geometry reference in every function.\n    this.geometry = geometry;\n    this._roots = null;\n    this._indirectBuffer = null;\n    if (!options[SKIP_GENERATION]) {\n      buildPackedTree(this, options);\n      if (!geometry.boundingBox && options.setBoundingBox) {\n        geometry.boundingBox = this.getBoundingBox(new Box3());\n      }\n    }\n    this.resolveTriangleIndex = options.indirect ? function (i) {\n      return _this._indirectBuffer[i];\n    } : function (i) {\n      return i;\n    };\n  }\n  _createClass(MeshBVH, [{\n    key: \"indirect\",\n    get: function get() {\n      return !!this._indirectBuffer;\n    }\n  }, {\n    key: \"refit\",\n    value: function refit() {\n      var nodeIndices = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n      var refitFunc = this.indirect ? refit_indirect : _refit;\n      return refitFunc(this, nodeIndices);\n    }\n  }, {\n    key: \"traverse\",\n    value: function traverse(callback) {\n      var rootIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      var buffer = this._roots[rootIndex];\n      var uint32Array = new Uint32Array(buffer);\n      var uint16Array = new Uint16Array(buffer);\n      _traverse(0);\n      function _traverse(node32Index) {\n        var depth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n        var node16Index = node32Index * 2;\n        var isLeaf = uint16Array[node16Index + 15] === IS_LEAFNODE_FLAG;\n        if (isLeaf) {\n          var offset = uint32Array[node32Index + 6];\n          var count = uint16Array[node16Index + 14];\n          callback(depth, isLeaf, new Float32Array(buffer, node32Index * 4, 6), offset, count);\n        } else {\n          // TODO: use node functions here\n          var left = node32Index + BYTES_PER_NODE / 4;\n          var right = uint32Array[node32Index + 6];\n          var splitAxis = uint32Array[node32Index + 7];\n          var stopTraversal = callback(depth, isLeaf, new Float32Array(buffer, node32Index * 4, 6), splitAxis);\n          if (!stopTraversal) {\n            _traverse(left, depth + 1);\n            _traverse(right, depth + 1);\n          }\n        }\n      }\n    }\n\n    /* Core Cast Functions */\n  }, {\n    key: \"raycast\",\n    value: function raycast(ray) {\n      var materialOrSide = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : FrontSide;\n      var near = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n      var far = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : Infinity;\n      var roots = this._roots;\n      var geometry = this.geometry;\n      var intersects = [];\n      var isMaterial = materialOrSide.isMaterial;\n      var isArrayMaterial = Array.isArray(materialOrSide);\n      var groups = geometry.groups;\n      var side = isMaterial ? materialOrSide.side : materialOrSide;\n      var raycastFunc = this.indirect ? raycast_indirect : _raycast;\n      for (var i = 0, l = roots.length; i < l; i++) {\n        var materialSide = isArrayMaterial ? materialOrSide[groups[i].materialIndex].side : side;\n        var startCount = intersects.length;\n        raycastFunc(this, i, materialSide, ray, intersects, near, far);\n        if (isArrayMaterial) {\n          var materialIndex = groups[i].materialIndex;\n          for (var j = startCount, jl = intersects.length; j < jl; j++) {\n            intersects[j].face.materialIndex = materialIndex;\n          }\n        }\n      }\n      return intersects;\n    }\n  }, {\n    key: \"raycastFirst\",\n    value: function raycastFirst(ray) {\n      var materialOrSide = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : FrontSide;\n      var near = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n      var far = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : Infinity;\n      var roots = this._roots;\n      var geometry = this.geometry;\n      var isMaterial = materialOrSide.isMaterial;\n      var isArrayMaterial = Array.isArray(materialOrSide);\n      var closestResult = null;\n      var groups = geometry.groups;\n      var side = isMaterial ? materialOrSide.side : materialOrSide;\n      var raycastFirstFunc = this.indirect ? raycastFirst_indirect : _raycastFirst;\n      for (var i = 0, l = roots.length; i < l; i++) {\n        var materialSide = isArrayMaterial ? materialOrSide[groups[i].materialIndex].side : side;\n        var result = raycastFirstFunc(this, i, materialSide, ray, near, far);\n        if (result != null && (closestResult == null || result.distance < closestResult.distance)) {\n          closestResult = result;\n          if (isArrayMaterial) {\n            result.face.materialIndex = groups[i].materialIndex;\n          }\n        }\n      }\n      return closestResult;\n    }\n  }, {\n    key: \"intersectsGeometry\",\n    value: function intersectsGeometry(otherGeometry, geomToMesh) {\n      var result = false;\n      var roots = this._roots;\n      var intersectsGeometryFunc = this.indirect ? intersectsGeometry_indirect : _intersectsGeometry;\n      for (var i = 0, l = roots.length; i < l; i++) {\n        result = intersectsGeometryFunc(this, i, otherGeometry, geomToMesh);\n        if (result) {\n          break;\n        }\n      }\n      return result;\n    }\n  }, {\n    key: \"shapecast\",\n    value: function shapecast(callbacks) {\n      var _this2 = this;\n      var triangle = ExtendedTrianglePool.getPrimitive();\n      var iterateFunc = this.indirect ? iterateOverTriangles_indirect : iterateOverTriangles;\n      var boundsTraverseOrder = callbacks.boundsTraverseOrder,\n        intersectsBounds = callbacks.intersectsBounds,\n        intersectsRange = callbacks.intersectsRange,\n        intersectsTriangle = callbacks.intersectsTriangle;\n\n      // wrap the intersectsRange function\n      if (intersectsRange && intersectsTriangle) {\n        var originalIntersectsRange = intersectsRange;\n        intersectsRange = function intersectsRange(offset, count, contained, depth, nodeIndex) {\n          if (!originalIntersectsRange(offset, count, contained, depth, nodeIndex)) {\n            return iterateFunc(offset, count, _this2, intersectsTriangle, contained, depth, triangle);\n          }\n          return true;\n        };\n      } else if (!intersectsRange) {\n        if (intersectsTriangle) {\n          intersectsRange = function intersectsRange(offset, count, contained, depth) {\n            return iterateFunc(offset, count, _this2, intersectsTriangle, contained, depth, triangle);\n          };\n        } else {\n          intersectsRange = function intersectsRange(offset, count, contained) {\n            return contained;\n          };\n        }\n      }\n\n      // run shapecast\n      var result = false;\n      var byteOffset = 0;\n      var roots = this._roots;\n      for (var i = 0, l = roots.length; i < l; i++) {\n        var root = roots[i];\n        result = _shapecast(this, i, intersectsBounds, intersectsRange, boundsTraverseOrder, byteOffset);\n        if (result) {\n          break;\n        }\n        byteOffset += root.byteLength;\n      }\n      ExtendedTrianglePool.releasePrimitive(triangle);\n      return result;\n    }\n  }, {\n    key: \"bvhcast\",\n    value: function bvhcast(otherBvh, matrixToLocal, callbacks) {\n      var _this3 = this;\n      var intersectsRanges = callbacks.intersectsRanges,\n        intersectsTriangles = callbacks.intersectsTriangles;\n      var triangle1 = ExtendedTrianglePool.getPrimitive();\n      var indexAttr1 = this.geometry.index;\n      var positionAttr1 = this.geometry.attributes.position;\n      var assignTriangle1 = this.indirect ? function (i1) {\n        var ti = _this3.resolveTriangleIndex(i1);\n        setTriangle(triangle1, ti * 3, indexAttr1, positionAttr1);\n      } : function (i1) {\n        setTriangle(triangle1, i1 * 3, indexAttr1, positionAttr1);\n      };\n      var triangle2 = ExtendedTrianglePool.getPrimitive();\n      var indexAttr2 = otherBvh.geometry.index;\n      var positionAttr2 = otherBvh.geometry.attributes.position;\n      var assignTriangle2 = otherBvh.indirect ? function (i2) {\n        var ti2 = otherBvh.resolveTriangleIndex(i2);\n        setTriangle(triangle2, ti2 * 3, indexAttr2, positionAttr2);\n      } : function (i2) {\n        setTriangle(triangle2, i2 * 3, indexAttr2, positionAttr2);\n      };\n\n      // generate triangle callback if needed\n      if (intersectsTriangles) {\n        var iterateOverDoubleTriangles = function iterateOverDoubleTriangles(offset1, count1, offset2, count2, depth1, index1, depth2, index2) {\n          for (var i2 = offset2, l2 = offset2 + count2; i2 < l2; i2++) {\n            assignTriangle2(i2);\n            triangle2.a.applyMatrix4(matrixToLocal);\n            triangle2.b.applyMatrix4(matrixToLocal);\n            triangle2.c.applyMatrix4(matrixToLocal);\n            triangle2.needsUpdate = true;\n            for (var i1 = offset1, l1 = offset1 + count1; i1 < l1; i1++) {\n              assignTriangle1(i1);\n              triangle1.needsUpdate = true;\n              if (intersectsTriangles(triangle1, triangle2, i1, i2, depth1, index1, depth2, index2)) {\n                return true;\n              }\n            }\n          }\n          return false;\n        };\n        if (intersectsRanges) {\n          var originalIntersectsRanges = intersectsRanges;\n          intersectsRanges = function intersectsRanges(offset1, count1, offset2, count2, depth1, index1, depth2, index2) {\n            if (!originalIntersectsRanges(offset1, count1, offset2, count2, depth1, index1, depth2, index2)) {\n              return iterateOverDoubleTriangles(offset1, count1, offset2, count2, depth1, index1, depth2, index2);\n            }\n            return true;\n          };\n        } else {\n          intersectsRanges = iterateOverDoubleTriangles;\n        }\n      }\n      return _bvhcast(this, otherBvh, matrixToLocal, intersectsRanges);\n    }\n\n    /* Derived Cast Functions */\n  }, {\n    key: \"intersectsBox\",\n    value: function intersectsBox(box, boxToMesh) {\n      obb.set(box.min, box.max, boxToMesh);\n      obb.needsUpdate = true;\n      return this.shapecast({\n        intersectsBounds: function intersectsBounds(box) {\n          return obb.intersectsBox(box);\n        },\n        intersectsTriangle: function intersectsTriangle(tri) {\n          return obb.intersectsTriangle(tri);\n        }\n      });\n    }\n  }, {\n    key: \"intersectsSphere\",\n    value: function intersectsSphere(sphere) {\n      return this.shapecast({\n        intersectsBounds: function intersectsBounds(box) {\n          return sphere.intersectsBox(box);\n        },\n        intersectsTriangle: function intersectsTriangle(tri) {\n          return tri.intersectsSphere(sphere);\n        }\n      });\n    }\n  }, {\n    key: \"closestPointToGeometry\",\n    value: function closestPointToGeometry(otherGeometry, geometryToBvh) {\n      var target1 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      var target2 = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n      var minThreshold = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;\n      var maxThreshold = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : Infinity;\n      var closestPointToGeometryFunc = this.indirect ? closestPointToGeometry_indirect : _closestPointToGeometry;\n      return closestPointToGeometryFunc(this, otherGeometry, geometryToBvh, target1, target2, minThreshold, maxThreshold);\n    }\n  }, {\n    key: \"closestPointToPoint\",\n    value: function closestPointToPoint(point) {\n      var target = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var minThreshold = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n      var maxThreshold = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : Infinity;\n      return _closestPointToPoint(this, point, target, minThreshold, maxThreshold);\n    }\n  }, {\n    key: \"getBoundingBox\",\n    value: function getBoundingBox(target) {\n      target.makeEmpty();\n      var roots = this._roots;\n      roots.forEach(function (buffer) {\n        arrayToBox(0, new Float32Array(buffer), tempBox);\n        target.union(tempBox);\n      });\n      return target;\n    }\n  }], [{\n    key: \"serialize\",\n    value: function serialize(bvh) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      options = _objectSpread({\n        cloneBuffers: true\n      }, options);\n      var geometry = bvh.geometry;\n      var rootData = bvh._roots;\n      var indirectBuffer = bvh._indirectBuffer;\n      var indexAttribute = geometry.getIndex();\n      var result;\n      if (options.cloneBuffers) {\n        result = {\n          roots: rootData.map(function (root) {\n            return root.slice();\n          }),\n          index: indexAttribute ? indexAttribute.array.slice() : null,\n          indirectBuffer: indirectBuffer ? indirectBuffer.slice() : null\n        };\n      } else {\n        result = {\n          roots: rootData,\n          index: indexAttribute ? indexAttribute.array : null,\n          indirectBuffer: indirectBuffer\n        };\n      }\n      return result;\n    }\n  }, {\n    key: \"deserialize\",\n    value: function deserialize(data, geometry) {\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      options = _objectSpread({\n        setIndex: true,\n        indirect: Boolean(data.indirectBuffer)\n      }, options);\n      var index = data.index,\n        roots = data.roots,\n        indirectBuffer = data.indirectBuffer;\n      var bvh = new MeshBVH(geometry, _objectSpread(_objectSpread({}, options), {}, _defineProperty({}, SKIP_GENERATION, true)));\n      bvh._roots = roots;\n      bvh._indirectBuffer = indirectBuffer || null;\n      if (options.setIndex) {\n        var indexAttribute = geometry.getIndex();\n        if (indexAttribute === null) {\n          var newIndex = new BufferAttribute(data.index, 1, false);\n          geometry.setIndex(newIndex);\n        } else if (indexAttribute.array !== index) {\n          indexAttribute.array.set(index);\n          indexAttribute.needsUpdate = true;\n        }\n      }\n      return bvh;\n    }\n  }]);\n  return MeshBVH;\n}();","map":{"version":3,"names":["BufferAttribute","Box3","FrontSide","CENTER","BYTES_PER_NODE","IS_LEAFNODE_FLAG","SKIP_GENERATION","buildPackedTree","OrientedBox","arrayToBox","ExtendedTrianglePool","shapecast","closestPointToPoint","iterateOverTriangles","refit","raycast","raycastFirst","intersectsGeometry","closestPointToGeometry","iterateOverTriangles_indirect","refit_indirect","raycast_indirect","raycastFirst_indirect","intersectsGeometry_indirect","closestPointToGeometry_indirect","isSharedArrayBufferSupported","setTriangle","bvhcast","obb","tempBox","DEFAULT_OPTIONS","strategy","maxDepth","maxLeafTris","useSharedArrayBuffer","setBoundingBox","onProgress","indirect","verbose","MeshBVH","geometry","_this","options","arguments","length","undefined","_classCallCheck","isBufferGeometry","Error","index","isInterleavedBufferAttribute","Object","assign","_objectSpread","_defineProperty","_roots","_indirectBuffer","boundingBox","getBoundingBox","resolveTriangleIndex","i","_createClass","key","get","value","nodeIndices","refitFunc","traverse","callback","rootIndex","buffer","uint32Array","Uint32Array","uint16Array","Uint16Array","_traverse","node32Index","depth","node16Index","isLeaf","offset","count","Float32Array","left","right","splitAxis","stopTraversal","ray","materialOrSide","near","far","Infinity","roots","intersects","isMaterial","isArrayMaterial","Array","isArray","groups","side","raycastFunc","l","materialSide","materialIndex","startCount","j","jl","face","closestResult","raycastFirstFunc","result","distance","otherGeometry","geomToMesh","intersectsGeometryFunc","callbacks","_this2","triangle","getPrimitive","iterateFunc","boundsTraverseOrder","intersectsBounds","intersectsRange","intersectsTriangle","originalIntersectsRange","contained","nodeIndex","byteOffset","root","byteLength","releasePrimitive","otherBvh","matrixToLocal","_this3","intersectsRanges","intersectsTriangles","triangle1","indexAttr1","positionAttr1","attributes","position","assignTriangle1","i1","ti","triangle2","indexAttr2","positionAttr2","assignTriangle2","i2","ti2","iterateOverDoubleTriangles","offset1","count1","offset2","count2","depth1","index1","depth2","index2","l2","a","applyMatrix4","b","c","needsUpdate","l1","originalIntersectsRanges","intersectsBox","box","boxToMesh","set","min","max","tri","intersectsSphere","sphere","geometryToBvh","target1","target2","minThreshold","maxThreshold","closestPointToGeometryFunc","point","target","makeEmpty","forEach","union","serialize","bvh","cloneBuffers","rootData","indirectBuffer","indexAttribute","getIndex","map","slice","array","deserialize","data","setIndex","Boolean","newIndex"],"sources":["C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/three-mesh-bvh/src/core/MeshBVH.js"],"sourcesContent":["import { BufferAttribute, Box3, FrontSide } from 'three';\nimport { CENTER, BYTES_PER_NODE, IS_LEAFNODE_FLAG, SKIP_GENERATION } from './Constants.js';\nimport { buildPackedTree } from './build/buildTree.js';\nimport { OrientedBox } from '../math/OrientedBox.js';\nimport { arrayToBox } from '../utils/ArrayBoxUtilities.js';\nimport { ExtendedTrianglePool } from '../utils/ExtendedTrianglePool.js';\nimport { shapecast } from './cast/shapecast.js';\nimport { closestPointToPoint } from './cast/closestPointToPoint.js';\n\nimport { iterateOverTriangles } from './utils/iterationUtils.generated.js';\nimport { refit } from './cast/refit.generated.js';\nimport { raycast } from './cast/raycast.generated.js';\nimport { raycastFirst } from './cast/raycastFirst.generated.js';\nimport { intersectsGeometry } from './cast/intersectsGeometry.generated.js';\nimport { closestPointToGeometry } from './cast/closestPointToGeometry.generated.js';\n\nimport { iterateOverTriangles_indirect } from './utils/iterationUtils_indirect.generated.js';\nimport { refit_indirect } from './cast/refit_indirect.generated.js';\nimport { raycast_indirect } from './cast/raycast_indirect.generated.js';\nimport { raycastFirst_indirect } from './cast/raycastFirst_indirect.generated.js';\nimport { intersectsGeometry_indirect } from './cast/intersectsGeometry_indirect.generated.js';\nimport { closestPointToGeometry_indirect } from './cast/closestPointToGeometry_indirect.generated.js';\nimport { isSharedArrayBufferSupported } from '../utils/BufferUtils.js';\nimport { setTriangle } from '../utils/TriangleUtilities.js';\nimport { bvhcast } from './cast/bvhcast.js';\n\nconst obb = /* @__PURE__ */ new OrientedBox();\nconst tempBox = /* @__PURE__ */ new Box3();\nexport const DEFAULT_OPTIONS = {\n\tstrategy: CENTER,\n\tmaxDepth: 40,\n\tmaxLeafTris: 10,\n\tuseSharedArrayBuffer: false,\n\tsetBoundingBox: true,\n\tonProgress: null,\n\tindirect: false,\n\tverbose: true,\n};\n\nexport class MeshBVH {\n\n\tstatic serialize( bvh, options = {} ) {\n\n\t\toptions = {\n\t\t\tcloneBuffers: true,\n\t\t\t...options,\n\t\t};\n\n\t\tconst geometry = bvh.geometry;\n\t\tconst rootData = bvh._roots;\n\t\tconst indirectBuffer = bvh._indirectBuffer;\n\t\tconst indexAttribute = geometry.getIndex();\n\t\tlet result;\n\t\tif ( options.cloneBuffers ) {\n\n\t\t\tresult = {\n\t\t\t\troots: rootData.map( root => root.slice() ),\n\t\t\t\tindex: indexAttribute ? indexAttribute.array.slice() : null,\n\t\t\t\tindirectBuffer: indirectBuffer ? indirectBuffer.slice() : null,\n\t\t\t};\n\n\t\t} else {\n\n\t\t\tresult = {\n\t\t\t\troots: rootData,\n\t\t\t\tindex: indexAttribute ? indexAttribute.array : null,\n\t\t\t\tindirectBuffer: indirectBuffer,\n\t\t\t};\n\n\t\t}\n\n\t\treturn result;\n\n\t}\n\n\tstatic deserialize( data, geometry, options = {} ) {\n\n\t\toptions = {\n\t\t\tsetIndex: true,\n\t\t\tindirect: Boolean( data.indirectBuffer ),\n\t\t\t...options,\n\t\t};\n\n\t\tconst { index, roots, indirectBuffer } = data;\n\t\tconst bvh = new MeshBVH( geometry, { ...options, [ SKIP_GENERATION ]: true } );\n\t\tbvh._roots = roots;\n\t\tbvh._indirectBuffer = indirectBuffer || null;\n\n\t\tif ( options.setIndex ) {\n\n\t\t\tconst indexAttribute = geometry.getIndex();\n\t\t\tif ( indexAttribute === null ) {\n\n\t\t\t\tconst newIndex = new BufferAttribute( data.index, 1, false );\n\t\t\t\tgeometry.setIndex( newIndex );\n\n\t\t\t} else if ( indexAttribute.array !== index ) {\n\n\t\t\t\tindexAttribute.array.set( index );\n\t\t\t\tindexAttribute.needsUpdate = true;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn bvh;\n\n\t}\n\n\tget indirect() {\n\n\t\treturn ! ! this._indirectBuffer;\n\n\t}\n\n\tconstructor( geometry, options = {} ) {\n\n\t\tif ( ! geometry.isBufferGeometry ) {\n\n\t\t\tthrow new Error( 'MeshBVH: Only BufferGeometries are supported.' );\n\n\t\t} else if ( geometry.index && geometry.index.isInterleavedBufferAttribute ) {\n\n\t\t\tthrow new Error( 'MeshBVH: InterleavedBufferAttribute is not supported for the index attribute.' );\n\n\t\t}\n\n\t\t// default options\n\t\toptions = Object.assign( {\n\n\t\t\t...DEFAULT_OPTIONS,\n\n\t\t\t// undocumented options\n\n\t\t\t// Whether to skip generating the tree. Used for deserialization.\n\t\t\t[ SKIP_GENERATION ]: false,\n\n\t\t}, options );\n\n\t\tif ( options.useSharedArrayBuffer && ! isSharedArrayBufferSupported() ) {\n\n\t\t\tthrow new Error( 'MeshBVH: SharedArrayBuffer is not available.' );\n\n\t\t}\n\n\t\t// retain references to the geometry so we can use them it without having to\n\t\t// take a geometry reference in every function.\n\t\tthis.geometry = geometry;\n\t\tthis._roots = null;\n\t\tthis._indirectBuffer = null;\n\t\tif ( ! options[ SKIP_GENERATION ] ) {\n\n\t\t\tbuildPackedTree( this, options );\n\n\t\t\tif ( ! geometry.boundingBox && options.setBoundingBox ) {\n\n\t\t\t\tgeometry.boundingBox = this.getBoundingBox( new Box3() );\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.resolveTriangleIndex = options.indirect ? i => this._indirectBuffer[ i ] : i => i;\n\n\t}\n\n\trefit( nodeIndices = null ) {\n\n\t\tconst refitFunc = this.indirect ? refit_indirect : refit;\n\t\treturn refitFunc( this, nodeIndices );\n\n\t}\n\n\ttraverse( callback, rootIndex = 0 ) {\n\n\t\tconst buffer = this._roots[ rootIndex ];\n\t\tconst uint32Array = new Uint32Array( buffer );\n\t\tconst uint16Array = new Uint16Array( buffer );\n\t\t_traverse( 0 );\n\n\t\tfunction _traverse( node32Index, depth = 0 ) {\n\n\t\t\tconst node16Index = node32Index * 2;\n\t\t\tconst isLeaf = uint16Array[ node16Index + 15 ] === IS_LEAFNODE_FLAG;\n\t\t\tif ( isLeaf ) {\n\n\t\t\t\tconst offset = uint32Array[ node32Index + 6 ];\n\t\t\t\tconst count = uint16Array[ node16Index + 14 ];\n\t\t\t\tcallback( depth, isLeaf, new Float32Array( buffer, node32Index * 4, 6 ), offset, count );\n\n\t\t\t} else {\n\n\t\t\t\t// TODO: use node functions here\n\t\t\t\tconst left = node32Index + BYTES_PER_NODE / 4;\n\t\t\t\tconst right = uint32Array[ node32Index + 6 ];\n\t\t\t\tconst splitAxis = uint32Array[ node32Index + 7 ];\n\t\t\t\tconst stopTraversal = callback( depth, isLeaf, new Float32Array( buffer, node32Index * 4, 6 ), splitAxis );\n\n\t\t\t\tif ( ! stopTraversal ) {\n\n\t\t\t\t\t_traverse( left, depth + 1 );\n\t\t\t\t\t_traverse( right, depth + 1 );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/* Core Cast Functions */\n\traycast( ray, materialOrSide = FrontSide, near = 0, far = Infinity ) {\n\n\t\tconst roots = this._roots;\n\t\tconst geometry = this.geometry;\n\t\tconst intersects = [];\n\t\tconst isMaterial = materialOrSide.isMaterial;\n\t\tconst isArrayMaterial = Array.isArray( materialOrSide );\n\n\t\tconst groups = geometry.groups;\n\t\tconst side = isMaterial ? materialOrSide.side : materialOrSide;\n\t\tconst raycastFunc = this.indirect ? raycast_indirect : raycast;\n\t\tfor ( let i = 0, l = roots.length; i < l; i ++ ) {\n\n\t\t\tconst materialSide = isArrayMaterial ? materialOrSide[ groups[ i ].materialIndex ].side : side;\n\t\t\tconst startCount = intersects.length;\n\n\t\t\traycastFunc( this, i, materialSide, ray, intersects, near, far );\n\n\t\t\tif ( isArrayMaterial ) {\n\n\t\t\t\tconst materialIndex = groups[ i ].materialIndex;\n\t\t\t\tfor ( let j = startCount, jl = intersects.length; j < jl; j ++ ) {\n\n\t\t\t\t\tintersects[ j ].face.materialIndex = materialIndex;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn intersects;\n\n\t}\n\n\traycastFirst( ray, materialOrSide = FrontSide, near = 0, far = Infinity ) {\n\n\t\tconst roots = this._roots;\n\t\tconst geometry = this.geometry;\n\t\tconst isMaterial = materialOrSide.isMaterial;\n\t\tconst isArrayMaterial = Array.isArray( materialOrSide );\n\n\t\tlet closestResult = null;\n\n\t\tconst groups = geometry.groups;\n\t\tconst side = isMaterial ? materialOrSide.side : materialOrSide;\n\t\tconst raycastFirstFunc = this.indirect ? raycastFirst_indirect : raycastFirst;\n\t\tfor ( let i = 0, l = roots.length; i < l; i ++ ) {\n\n\t\t\tconst materialSide = isArrayMaterial ? materialOrSide[ groups[ i ].materialIndex ].side : side;\n\t\t\tconst result = raycastFirstFunc( this, i, materialSide, ray, near, far );\n\t\t\tif ( result != null && ( closestResult == null || result.distance < closestResult.distance ) ) {\n\n\t\t\t\tclosestResult = result;\n\t\t\t\tif ( isArrayMaterial ) {\n\n\t\t\t\t\tresult.face.materialIndex = groups[ i ].materialIndex;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn closestResult;\n\n\t}\n\n\tintersectsGeometry( otherGeometry, geomToMesh ) {\n\n\t\tlet result = false;\n\t\tconst roots = this._roots;\n\t\tconst intersectsGeometryFunc = this.indirect ? intersectsGeometry_indirect : intersectsGeometry;\n\t\tfor ( let i = 0, l = roots.length; i < l; i ++ ) {\n\n\t\t\tresult = intersectsGeometryFunc( this, i, otherGeometry, geomToMesh );\n\n\t\t\tif ( result ) {\n\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn result;\n\n\t}\n\n\tshapecast( callbacks ) {\n\n\t\tconst triangle = ExtendedTrianglePool.getPrimitive();\n\t\tconst iterateFunc = this.indirect ? iterateOverTriangles_indirect : iterateOverTriangles;\n\t\tlet {\n\t\t\tboundsTraverseOrder,\n\t\t\tintersectsBounds,\n\t\t\tintersectsRange,\n\t\t\tintersectsTriangle,\n\t\t} = callbacks;\n\n\t\t// wrap the intersectsRange function\n\t\tif ( intersectsRange && intersectsTriangle ) {\n\n\t\t\tconst originalIntersectsRange = intersectsRange;\n\t\t\tintersectsRange = ( offset, count, contained, depth, nodeIndex ) => {\n\n\t\t\t\tif ( ! originalIntersectsRange( offset, count, contained, depth, nodeIndex ) ) {\n\n\t\t\t\t\treturn iterateFunc( offset, count, this, intersectsTriangle, contained, depth, triangle );\n\n\t\t\t\t}\n\n\t\t\t\treturn true;\n\n\t\t\t};\n\n\t\t} else if ( ! intersectsRange ) {\n\n\t\t\tif ( intersectsTriangle ) {\n\n\t\t\t\tintersectsRange = ( offset, count, contained, depth ) => {\n\n\t\t\t\t\treturn iterateFunc( offset, count, this, intersectsTriangle, contained, depth, triangle );\n\n\t\t\t\t};\n\n\t\t\t} else {\n\n\t\t\t\tintersectsRange = ( offset, count, contained ) => {\n\n\t\t\t\t\treturn contained;\n\n\t\t\t\t};\n\n\t\t\t}\n\n\t\t}\n\n\t\t// run shapecast\n\t\tlet result = false;\n\t\tlet byteOffset = 0;\n\t\tconst roots = this._roots;\n\t\tfor ( let i = 0, l = roots.length; i < l; i ++ ) {\n\n\t\t\tconst root = roots[ i ];\n\t\t\tresult = shapecast( this, i, intersectsBounds, intersectsRange, boundsTraverseOrder, byteOffset );\n\n\t\t\tif ( result ) {\n\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tbyteOffset += root.byteLength;\n\n\t\t}\n\n\t\tExtendedTrianglePool.releasePrimitive( triangle );\n\n\t\treturn result;\n\n\t}\n\n\tbvhcast( otherBvh, matrixToLocal, callbacks ) {\n\n\t\tlet {\n\t\t\tintersectsRanges,\n\t\t\tintersectsTriangles,\n\t\t} = callbacks;\n\n\t\tconst triangle1 = ExtendedTrianglePool.getPrimitive();\n\t\tconst indexAttr1 = this.geometry.index;\n\t\tconst positionAttr1 = this.geometry.attributes.position;\n\t\tconst assignTriangle1 = this.indirect ?\n\t\t\ti1 => {\n\n\n\t\t\t\tconst ti = this.resolveTriangleIndex( i1 );\n\t\t\t\tsetTriangle( triangle1, ti * 3, indexAttr1, positionAttr1 );\n\n\t\t\t} :\n\t\t\ti1 => {\n\n\t\t\t\tsetTriangle( triangle1, i1 * 3, indexAttr1, positionAttr1 );\n\n\t\t\t};\n\n\t\tconst triangle2 = ExtendedTrianglePool.getPrimitive();\n\t\tconst indexAttr2 = otherBvh.geometry.index;\n\t\tconst positionAttr2 = otherBvh.geometry.attributes.position;\n\t\tconst assignTriangle2 = otherBvh.indirect ?\n\t\t\ti2 => {\n\n\t\t\t\tconst ti2 = otherBvh.resolveTriangleIndex( i2 );\n\t\t\t\tsetTriangle( triangle2, ti2 * 3, indexAttr2, positionAttr2 );\n\n\t\t\t} :\n\t\t\ti2 => {\n\n\t\t\t\tsetTriangle( triangle2, i2 * 3, indexAttr2, positionAttr2 );\n\n\t\t\t};\n\n\t\t// generate triangle callback if needed\n\t\tif ( intersectsTriangles ) {\n\n\t\t\tconst iterateOverDoubleTriangles = ( offset1, count1, offset2, count2, depth1, index1, depth2, index2 ) => {\n\n\t\t\t\tfor ( let i2 = offset2, l2 = offset2 + count2; i2 < l2; i2 ++ ) {\n\n\t\t\t\t\tassignTriangle2( i2 );\n\n\t\t\t\t\ttriangle2.a.applyMatrix4( matrixToLocal );\n\t\t\t\t\ttriangle2.b.applyMatrix4( matrixToLocal );\n\t\t\t\t\ttriangle2.c.applyMatrix4( matrixToLocal );\n\t\t\t\t\ttriangle2.needsUpdate = true;\n\n\t\t\t\t\tfor ( let i1 = offset1, l1 = offset1 + count1; i1 < l1; i1 ++ ) {\n\n\t\t\t\t\t\tassignTriangle1( i1 );\n\n\t\t\t\t\t\ttriangle1.needsUpdate = true;\n\n\t\t\t\t\t\tif ( intersectsTriangles( triangle1, triangle2, i1, i2, depth1, index1, depth2, index2 ) ) {\n\n\t\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn false;\n\n\t\t\t};\n\n\t\t\tif ( intersectsRanges ) {\n\n\t\t\t\tconst originalIntersectsRanges = intersectsRanges;\n\t\t\t\tintersectsRanges = function ( offset1, count1, offset2, count2, depth1, index1, depth2, index2 ) {\n\n\t\t\t\t\tif ( ! originalIntersectsRanges( offset1, count1, offset2, count2, depth1, index1, depth2, index2 ) ) {\n\n\t\t\t\t\t\treturn iterateOverDoubleTriangles( offset1, count1, offset2, count2, depth1, index1, depth2, index2 );\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn true;\n\n\t\t\t\t};\n\n\t\t\t} else {\n\n\t\t\t\tintersectsRanges = iterateOverDoubleTriangles;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn bvhcast( this, otherBvh, matrixToLocal, intersectsRanges );\n\n\t}\n\n\n\t/* Derived Cast Functions */\n\tintersectsBox( box, boxToMesh ) {\n\n\t\tobb.set( box.min, box.max, boxToMesh );\n\t\tobb.needsUpdate = true;\n\n\t\treturn this.shapecast(\n\t\t\t{\n\t\t\t\tintersectsBounds: box => obb.intersectsBox( box ),\n\t\t\t\tintersectsTriangle: tri => obb.intersectsTriangle( tri )\n\t\t\t}\n\t\t);\n\n\t}\n\n\tintersectsSphere( sphere ) {\n\n\t\treturn this.shapecast(\n\t\t\t{\n\t\t\t\tintersectsBounds: box => sphere.intersectsBox( box ),\n\t\t\t\tintersectsTriangle: tri => tri.intersectsSphere( sphere )\n\t\t\t}\n\t\t);\n\n\t}\n\n\tclosestPointToGeometry( otherGeometry, geometryToBvh, target1 = { }, target2 = { }, minThreshold = 0, maxThreshold = Infinity ) {\n\n\t\tconst closestPointToGeometryFunc = this.indirect ? closestPointToGeometry_indirect : closestPointToGeometry;\n\t\treturn closestPointToGeometryFunc(\n\t\t\tthis,\n\t\t\totherGeometry,\n\t\t\tgeometryToBvh,\n\t\t\ttarget1,\n\t\t\ttarget2,\n\t\t\tminThreshold,\n\t\t\tmaxThreshold,\n\t\t);\n\n\t}\n\n\tclosestPointToPoint( point, target = { }, minThreshold = 0, maxThreshold = Infinity ) {\n\n\t\treturn closestPointToPoint(\n\t\t\tthis,\n\t\t\tpoint,\n\t\t\ttarget,\n\t\t\tminThreshold,\n\t\t\tmaxThreshold,\n\t\t);\n\n\t}\n\n\tgetBoundingBox( target ) {\n\n\t\ttarget.makeEmpty();\n\n\t\tconst roots = this._roots;\n\t\troots.forEach( buffer => {\n\n\t\t\tarrayToBox( 0, new Float32Array( buffer ), tempBox );\n\t\t\ttarget.union( tempBox );\n\n\t\t} );\n\n\t\treturn target;\n\n\t}\n\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}