{"ast":null,"code":"import _classCallCheck from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _assertThisInitialized from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js\";\nimport _inherits from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = function __defNormalProp(obj, key, value) {\n  return key in obj ? __defProp(obj, key, {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: value\n  }) : obj[key] = value;\n};\nvar __publicField = function __publicField(obj, key, value) {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nimport { Pass, FullScreenQuad } from \"./Pass.js\";\nimport { Vector2, Color, WebGLRenderTarget, MeshDepthMaterial, DoubleSide, RGBADepthPacking, NoBlending, UniformsUtils, ShaderMaterial, Matrix4, Vector3, AdditiveBlending } from \"three\";\nimport { CopyShader } from \"../shaders/CopyShader.js\";\nvar OutlinePass = /*#__PURE__*/function (_Pass) {\n  _inherits(OutlinePass, _Pass);\n  var _super = _createSuper(OutlinePass);\n  function OutlinePass(resolution, scene, camera, selectedObjects) {\n    var _this;\n    _classCallCheck(this, OutlinePass);\n    _this = _super.call(this);\n    __publicField(_assertThisInitialized(_this), \"renderScene\");\n    __publicField(_assertThisInitialized(_this), \"renderCamera\");\n    __publicField(_assertThisInitialized(_this), \"selectedObjects\");\n    __publicField(_assertThisInitialized(_this), \"visibleEdgeColor\");\n    __publicField(_assertThisInitialized(_this), \"hiddenEdgeColor\");\n    __publicField(_assertThisInitialized(_this), \"edgeGlow\");\n    __publicField(_assertThisInitialized(_this), \"usePatternTexture\");\n    __publicField(_assertThisInitialized(_this), \"edgeThickness\");\n    __publicField(_assertThisInitialized(_this), \"edgeStrength\");\n    __publicField(_assertThisInitialized(_this), \"downSampleRatio\");\n    __publicField(_assertThisInitialized(_this), \"pulsePeriod\");\n    __publicField(_assertThisInitialized(_this), \"resolution\");\n    __publicField(_assertThisInitialized(_this), \"renderTargetMaskBuffer\");\n    __publicField(_assertThisInitialized(_this), \"depthMaterial\");\n    __publicField(_assertThisInitialized(_this), \"prepareMaskMaterial\");\n    __publicField(_assertThisInitialized(_this), \"renderTargetDepthBuffer\");\n    __publicField(_assertThisInitialized(_this), \"renderTargetMaskDownSampleBuffer\");\n    __publicField(_assertThisInitialized(_this), \"renderTargetBlurBuffer1\");\n    __publicField(_assertThisInitialized(_this), \"renderTargetBlurBuffer2\");\n    __publicField(_assertThisInitialized(_this), \"edgeDetectionMaterial\");\n    __publicField(_assertThisInitialized(_this), \"renderTargetEdgeBuffer1\");\n    __publicField(_assertThisInitialized(_this), \"renderTargetEdgeBuffer2\");\n    __publicField(_assertThisInitialized(_this), \"separableBlurMaterial1\");\n    __publicField(_assertThisInitialized(_this), \"separableBlurMaterial2\");\n    __publicField(_assertThisInitialized(_this), \"overlayMaterial\");\n    __publicField(_assertThisInitialized(_this), \"materialCopy\");\n    __publicField(_assertThisInitialized(_this), \"oldClearAlpha\");\n    __publicField(_assertThisInitialized(_this), \"fsQuad\");\n    __publicField(_assertThisInitialized(_this), \"tempPulseColor1\");\n    __publicField(_assertThisInitialized(_this), \"tempPulseColor2\");\n    __publicField(_assertThisInitialized(_this), \"textureMatrix\");\n    __publicField(_assertThisInitialized(_this), \"patternTexture\");\n    __publicField(_assertThisInitialized(_this), \"_visibilityCache\");\n    __publicField(_assertThisInitialized(_this), \"_oldClearColor\");\n    __publicField(_assertThisInitialized(_this), \"copyUniforms\");\n    __publicField(_assertThisInitialized(_this), \"BlurDirectionX\", new Vector2(1, 0));\n    __publicField(_assertThisInitialized(_this), \"BlurDirectionY\", new Vector2(0, 1));\n    _this.renderScene = scene;\n    _this.renderCamera = camera;\n    _this.selectedObjects = selectedObjects !== void 0 ? selectedObjects : [];\n    _this.visibleEdgeColor = new Color(1, 1, 1);\n    _this.hiddenEdgeColor = new Color(0.1, 0.04, 0.02);\n    _this.edgeGlow = 0;\n    _this.usePatternTexture = false;\n    _this.edgeThickness = 1;\n    _this.edgeStrength = 3;\n    _this.downSampleRatio = 2;\n    _this.pulsePeriod = 0;\n    _this._visibilityCache = /* @__PURE__ */new Map();\n    _this.resolution = resolution !== void 0 ? new Vector2(resolution.x, resolution.y) : new Vector2(256, 256);\n    var resx = Math.round(_this.resolution.x / _this.downSampleRatio);\n    var resy = Math.round(_this.resolution.y / _this.downSampleRatio);\n    _this.renderTargetMaskBuffer = new WebGLRenderTarget(_this.resolution.x, _this.resolution.y);\n    _this.renderTargetMaskBuffer.texture.name = \"OutlinePass.mask\";\n    _this.renderTargetMaskBuffer.texture.generateMipmaps = false;\n    _this.depthMaterial = new MeshDepthMaterial();\n    _this.depthMaterial.side = DoubleSide;\n    _this.depthMaterial.depthPacking = RGBADepthPacking;\n    _this.depthMaterial.blending = NoBlending;\n    _this.prepareMaskMaterial = _this.getPrepareMaskMaterial();\n    _this.prepareMaskMaterial.side = DoubleSide;\n    _this.prepareMaskMaterial.fragmentShader = replaceDepthToViewZ(_this.prepareMaskMaterial.fragmentShader, _this.renderCamera);\n    _this.renderTargetDepthBuffer = new WebGLRenderTarget(_this.resolution.x, _this.resolution.y);\n    _this.renderTargetDepthBuffer.texture.name = \"OutlinePass.depth\";\n    _this.renderTargetDepthBuffer.texture.generateMipmaps = false;\n    _this.renderTargetMaskDownSampleBuffer = new WebGLRenderTarget(resx, resy);\n    _this.renderTargetMaskDownSampleBuffer.texture.name = \"OutlinePass.depthDownSample\";\n    _this.renderTargetMaskDownSampleBuffer.texture.generateMipmaps = false;\n    _this.renderTargetBlurBuffer1 = new WebGLRenderTarget(resx, resy);\n    _this.renderTargetBlurBuffer1.texture.name = \"OutlinePass.blur1\";\n    _this.renderTargetBlurBuffer1.texture.generateMipmaps = false;\n    _this.renderTargetBlurBuffer2 = new WebGLRenderTarget(Math.round(resx / 2), Math.round(resy / 2));\n    _this.renderTargetBlurBuffer2.texture.name = \"OutlinePass.blur2\";\n    _this.renderTargetBlurBuffer2.texture.generateMipmaps = false;\n    _this.edgeDetectionMaterial = _this.getEdgeDetectionMaterial();\n    _this.renderTargetEdgeBuffer1 = new WebGLRenderTarget(resx, resy);\n    _this.renderTargetEdgeBuffer1.texture.name = \"OutlinePass.edge1\";\n    _this.renderTargetEdgeBuffer1.texture.generateMipmaps = false;\n    _this.renderTargetEdgeBuffer2 = new WebGLRenderTarget(Math.round(resx / 2), Math.round(resy / 2));\n    _this.renderTargetEdgeBuffer2.texture.name = \"OutlinePass.edge2\";\n    _this.renderTargetEdgeBuffer2.texture.generateMipmaps = false;\n    var MAX_EDGE_THICKNESS = 4;\n    var MAX_EDGE_GLOW = 4;\n    _this.separableBlurMaterial1 = _this.getSeperableBlurMaterial(MAX_EDGE_THICKNESS);\n    _this.separableBlurMaterial1.uniforms[\"texSize\"].value.set(resx, resy);\n    _this.separableBlurMaterial1.uniforms[\"kernelRadius\"].value = 1;\n    _this.separableBlurMaterial2 = _this.getSeperableBlurMaterial(MAX_EDGE_GLOW);\n    _this.separableBlurMaterial2.uniforms[\"texSize\"].value.set(Math.round(resx / 2), Math.round(resy / 2));\n    _this.separableBlurMaterial2.uniforms[\"kernelRadius\"].value = MAX_EDGE_GLOW;\n    _this.overlayMaterial = _this.getOverlayMaterial();\n    if (CopyShader === void 0) console.error(\"THREE.OutlinePass relies on CopyShader\");\n    var copyShader = CopyShader;\n    _this.copyUniforms = UniformsUtils.clone(copyShader.uniforms);\n    _this.copyUniforms[\"opacity\"].value = 1;\n    _this.materialCopy = new ShaderMaterial({\n      uniforms: _this.copyUniforms,\n      vertexShader: copyShader.vertexShader,\n      fragmentShader: copyShader.fragmentShader,\n      blending: NoBlending,\n      depthTest: false,\n      depthWrite: false,\n      transparent: true\n    });\n    _this.enabled = true;\n    _this.needsSwap = false;\n    _this._oldClearColor = new Color();\n    _this.oldClearAlpha = 1;\n    _this.fsQuad = new FullScreenQuad(_this.materialCopy);\n    _this.tempPulseColor1 = new Color();\n    _this.tempPulseColor2 = new Color();\n    _this.textureMatrix = new Matrix4();\n    function replaceDepthToViewZ(string, camera2) {\n      var type = camera2.isPerspectiveCamera ? \"perspective\" : \"orthographic\";\n      return string.replace(/DEPTH_TO_VIEW_Z/g, type + \"DepthToViewZ\");\n    }\n    return _this;\n  }\n  _createClass(OutlinePass, [{\n    key: \"dispose\",\n    value: function dispose() {\n      this.renderTargetMaskBuffer.dispose();\n      this.renderTargetDepthBuffer.dispose();\n      this.renderTargetMaskDownSampleBuffer.dispose();\n      this.renderTargetBlurBuffer1.dispose();\n      this.renderTargetBlurBuffer2.dispose();\n      this.renderTargetEdgeBuffer1.dispose();\n      this.renderTargetEdgeBuffer2.dispose();\n    }\n  }, {\n    key: \"setSize\",\n    value: function setSize(width, height) {\n      this.renderTargetMaskBuffer.setSize(width, height);\n      this.renderTargetDepthBuffer.setSize(width, height);\n      var resx = Math.round(width / this.downSampleRatio);\n      var resy = Math.round(height / this.downSampleRatio);\n      this.renderTargetMaskDownSampleBuffer.setSize(resx, resy);\n      this.renderTargetBlurBuffer1.setSize(resx, resy);\n      this.renderTargetEdgeBuffer1.setSize(resx, resy);\n      this.separableBlurMaterial1.uniforms[\"texSize\"].value.set(resx, resy);\n      resx = Math.round(resx / 2);\n      resy = Math.round(resy / 2);\n      this.renderTargetBlurBuffer2.setSize(resx, resy);\n      this.renderTargetEdgeBuffer2.setSize(resx, resy);\n      this.separableBlurMaterial2.uniforms[\"texSize\"].value.set(resx, resy);\n    }\n  }, {\n    key: \"changeVisibilityOfSelectedObjects\",\n    value: function changeVisibilityOfSelectedObjects(bVisible) {\n      var cache = this._visibilityCache;\n      function gatherSelectedMeshesCallBack(object) {\n        if (object.isMesh) {\n          if (bVisible === true) {\n            object.visible = cache.get(object);\n          } else {\n            cache.set(object, object.visible);\n            object.visible = bVisible;\n          }\n        }\n      }\n      for (var i = 0; i < this.selectedObjects.length; i++) {\n        var selectedObject = this.selectedObjects[i];\n        selectedObject.traverse(gatherSelectedMeshesCallBack);\n      }\n    }\n  }, {\n    key: \"changeVisibilityOfNonSelectedObjects\",\n    value: function changeVisibilityOfNonSelectedObjects(bVisible) {\n      var cache = this._visibilityCache;\n      var selectedMeshes = [];\n      function gatherSelectedMeshesCallBack(object) {\n        if (object.isMesh) selectedMeshes.push(object);\n      }\n      for (var i = 0; i < this.selectedObjects.length; i++) {\n        var selectedObject = this.selectedObjects[i];\n        selectedObject.traverse(gatherSelectedMeshesCallBack);\n      }\n      function VisibilityChangeCallBack(object) {\n        if (object.isMesh || object.isSprite) {\n          var bFound = false;\n          for (var _i = 0; _i < selectedMeshes.length; _i++) {\n            var selectedObjectId = selectedMeshes[_i].id;\n            if (selectedObjectId === object.id) {\n              bFound = true;\n              break;\n            }\n          }\n          if (bFound === false) {\n            var visibility = object.visible;\n            if (bVisible === false || cache.get(object) === true) {\n              object.visible = bVisible;\n            }\n            cache.set(object, visibility);\n          }\n        } else if (object.isPoints || object.isLine) {\n          if (bVisible === true) {\n            object.visible = cache.get(object);\n          } else {\n            cache.set(object, object.visible);\n            object.visible = bVisible;\n          }\n        }\n      }\n      this.renderScene.traverse(VisibilityChangeCallBack);\n    }\n  }, {\n    key: \"updateTextureMatrix\",\n    value: function updateTextureMatrix() {\n      this.textureMatrix.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1);\n      this.textureMatrix.multiply(this.renderCamera.projectionMatrix);\n      this.textureMatrix.multiply(this.renderCamera.matrixWorldInverse);\n    }\n  }, {\n    key: \"render\",\n    value: function render(renderer, writeBuffer, readBuffer, deltaTime, maskActive) {\n      if (this.selectedObjects.length > 0) {\n        renderer.getClearColor(this._oldClearColor);\n        this.oldClearAlpha = renderer.getClearAlpha();\n        var oldAutoClear = renderer.autoClear;\n        renderer.autoClear = false;\n        if (maskActive) renderer.state.buffers.stencil.setTest(false);\n        renderer.setClearColor(16777215, 1);\n        this.changeVisibilityOfSelectedObjects(false);\n        var currentBackground = this.renderScene.background;\n        this.renderScene.background = null;\n        this.renderScene.overrideMaterial = this.depthMaterial;\n        renderer.setRenderTarget(this.renderTargetDepthBuffer);\n        renderer.clear();\n        renderer.render(this.renderScene, this.renderCamera);\n        this.changeVisibilityOfSelectedObjects(true);\n        this._visibilityCache.clear();\n        this.updateTextureMatrix();\n        this.changeVisibilityOfNonSelectedObjects(false);\n        this.renderScene.overrideMaterial = this.prepareMaskMaterial;\n        this.prepareMaskMaterial.uniforms[\"cameraNearFar\"].value.set(this.renderCamera.near, this.renderCamera.far);\n        this.prepareMaskMaterial.uniforms[\"depthTexture\"].value = this.renderTargetDepthBuffer.texture;\n        this.prepareMaskMaterial.uniforms[\"textureMatrix\"].value = this.textureMatrix;\n        renderer.setRenderTarget(this.renderTargetMaskBuffer);\n        renderer.clear();\n        renderer.render(this.renderScene, this.renderCamera);\n        this.renderScene.overrideMaterial = null;\n        this.changeVisibilityOfNonSelectedObjects(true);\n        this._visibilityCache.clear();\n        this.renderScene.background = currentBackground;\n        this.fsQuad.material = this.materialCopy;\n        this.copyUniforms[\"tDiffuse\"].value = this.renderTargetMaskBuffer.texture;\n        renderer.setRenderTarget(this.renderTargetMaskDownSampleBuffer);\n        renderer.clear();\n        this.fsQuad.render(renderer);\n        this.tempPulseColor1.copy(this.visibleEdgeColor);\n        this.tempPulseColor2.copy(this.hiddenEdgeColor);\n        if (this.pulsePeriod > 0) {\n          var scalar = (1 + 0.25) / 2 + Math.cos(performance.now() * 0.01 / this.pulsePeriod) * (1 - 0.25) / 2;\n          this.tempPulseColor1.multiplyScalar(scalar);\n          this.tempPulseColor2.multiplyScalar(scalar);\n        }\n        this.fsQuad.material = this.edgeDetectionMaterial;\n        this.edgeDetectionMaterial.uniforms[\"maskTexture\"].value = this.renderTargetMaskDownSampleBuffer.texture;\n        this.edgeDetectionMaterial.uniforms[\"texSize\"].value.set(this.renderTargetMaskDownSampleBuffer.width, this.renderTargetMaskDownSampleBuffer.height);\n        this.edgeDetectionMaterial.uniforms[\"visibleEdgeColor\"].value = this.tempPulseColor1;\n        this.edgeDetectionMaterial.uniforms[\"hiddenEdgeColor\"].value = this.tempPulseColor2;\n        renderer.setRenderTarget(this.renderTargetEdgeBuffer1);\n        renderer.clear();\n        this.fsQuad.render(renderer);\n        this.fsQuad.material = this.separableBlurMaterial1;\n        this.separableBlurMaterial1.uniforms[\"colorTexture\"].value = this.renderTargetEdgeBuffer1.texture;\n        this.separableBlurMaterial1.uniforms[\"direction\"].value = this.BlurDirectionX;\n        this.separableBlurMaterial1.uniforms[\"kernelRadius\"].value = this.edgeThickness;\n        renderer.setRenderTarget(this.renderTargetBlurBuffer1);\n        renderer.clear();\n        this.fsQuad.render(renderer);\n        this.separableBlurMaterial1.uniforms[\"colorTexture\"].value = this.renderTargetBlurBuffer1.texture;\n        this.separableBlurMaterial1.uniforms[\"direction\"].value = this.BlurDirectionY;\n        renderer.setRenderTarget(this.renderTargetEdgeBuffer1);\n        renderer.clear();\n        this.fsQuad.render(renderer);\n        this.fsQuad.material = this.separableBlurMaterial2;\n        this.separableBlurMaterial2.uniforms[\"colorTexture\"].value = this.renderTargetEdgeBuffer1.texture;\n        this.separableBlurMaterial2.uniforms[\"direction\"].value = this.BlurDirectionX;\n        renderer.setRenderTarget(this.renderTargetBlurBuffer2);\n        renderer.clear();\n        this.fsQuad.render(renderer);\n        this.separableBlurMaterial2.uniforms[\"colorTexture\"].value = this.renderTargetBlurBuffer2.texture;\n        this.separableBlurMaterial2.uniforms[\"direction\"].value = this.BlurDirectionY;\n        renderer.setRenderTarget(this.renderTargetEdgeBuffer2);\n        renderer.clear();\n        this.fsQuad.render(renderer);\n        this.fsQuad.material = this.overlayMaterial;\n        this.overlayMaterial.uniforms[\"maskTexture\"].value = this.renderTargetMaskBuffer.texture;\n        this.overlayMaterial.uniforms[\"edgeTexture1\"].value = this.renderTargetEdgeBuffer1.texture;\n        this.overlayMaterial.uniforms[\"edgeTexture2\"].value = this.renderTargetEdgeBuffer2.texture;\n        this.overlayMaterial.uniforms[\"patternTexture\"].value = this.patternTexture;\n        this.overlayMaterial.uniforms[\"edgeStrength\"].value = this.edgeStrength;\n        this.overlayMaterial.uniforms[\"edgeGlow\"].value = this.edgeGlow;\n        this.overlayMaterial.uniforms[\"usePatternTexture\"].value = this.usePatternTexture;\n        if (maskActive) renderer.state.buffers.stencil.setTest(true);\n        renderer.setRenderTarget(readBuffer);\n        this.fsQuad.render(renderer);\n        renderer.setClearColor(this._oldClearColor, this.oldClearAlpha);\n        renderer.autoClear = oldAutoClear;\n      }\n      if (this.renderToScreen) {\n        this.fsQuad.material = this.materialCopy;\n        this.copyUniforms[\"tDiffuse\"].value = readBuffer.texture;\n        renderer.setRenderTarget(null);\n        this.fsQuad.render(renderer);\n      }\n    }\n  }, {\n    key: \"getPrepareMaskMaterial\",\n    value: function getPrepareMaskMaterial() {\n      return new ShaderMaterial({\n        uniforms: {\n          depthTexture: {\n            value: null\n          },\n          cameraNearFar: {\n            value: new Vector2(0.5, 0.5)\n          },\n          textureMatrix: {\n            value: null\n          }\n        },\n        vertexShader: \"#include <morphtarget_pars_vertex>\\n\\t\\t\\t\\t#include <skinning_pars_vertex>\\n\\t\\t\\t\\tvarying vec4 projTexCoord;\\n\\t\\t\\t\\tvarying vec4 vPosition;\\n\\t\\t\\t\\tuniform mat4 textureMatrix;\\n\\t\\t\\t\\tvoid main() {\\n\\t\\t\\t\\t\\t#include <skinbase_vertex>\\n\\t\\t\\t\\t\\t#include <begin_vertex>\\n\\t\\t\\t\\t\\t#include <morphtarget_vertex>\\n\\t\\t\\t\\t\\t#include <skinning_vertex>\\n\\t\\t\\t\\t\\t#include <project_vertex>\\n\\t\\t\\t\\t\\tvPosition = mvPosition;\\n\\t\\t\\t\\t\\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\\n\\t\\t\\t\\t\\tprojTexCoord = textureMatrix * worldPosition;\\n\\t\\t\\t\\t}\",\n        fragmentShader: \"#include <packing>\\n\\t\\t\\t\\tvarying vec4 vPosition;\\n\\t\\t\\t\\tvarying vec4 projTexCoord;\\n\\t\\t\\t\\tuniform sampler2D depthTexture;\\n\\t\\t\\t\\tuniform vec2 cameraNearFar;\\n\\t\\t\\t\\tvoid main() {\\n\\t\\t\\t\\t\\tfloat depth = unpackRGBAToDepth(texture2DProj( depthTexture, projTexCoord ));\\n\\t\\t\\t\\t\\tfloat viewZ = - DEPTH_TO_VIEW_Z( depth, cameraNearFar.x, cameraNearFar.y );\\n\\t\\t\\t\\t\\tfloat depthTest = (-vPosition.z > viewZ) ? 1.0 : 0.0;\\n\\t\\t\\t\\t\\tgl_FragColor = vec4(0.0, depthTest, 1.0, 1.0);\\n\\t\\t\\t\\t}\"\n      });\n    }\n  }, {\n    key: \"getEdgeDetectionMaterial\",\n    value: function getEdgeDetectionMaterial() {\n      return new ShaderMaterial({\n        uniforms: {\n          maskTexture: {\n            value: null\n          },\n          texSize: {\n            value: new Vector2(0.5, 0.5)\n          },\n          visibleEdgeColor: {\n            value: new Vector3(1, 1, 1)\n          },\n          hiddenEdgeColor: {\n            value: new Vector3(1, 1, 1)\n          }\n        },\n        vertexShader: \"varying vec2 vUv;\\n\\t\\t\\t\\tvoid main() {\\n\\t\\t\\t\\t\\tvUv = uv;\\n\\t\\t\\t\\t\\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n\\t\\t\\t\\t}\",\n        fragmentShader: \"varying vec2 vUv;\\n\\t\\t\\t\\tuniform sampler2D maskTexture;\\n\\t\\t\\t\\tuniform vec2 texSize;\\n\\t\\t\\t\\tuniform vec3 visibleEdgeColor;\\n\\t\\t\\t\\tuniform vec3 hiddenEdgeColor;\\n\\t\\t\\t\\tvoid main() {\\n\\t\\t\\t\\t\\tvec2 invSize = 1.0 / texSize;\\n\\t\\t\\t\\t\\tvec4 uvOffset = vec4(1.0, 0.0, 0.0, 1.0) * vec4(invSize, invSize);\\n\\t\\t\\t\\t\\tvec4 c1 = texture2D( maskTexture, vUv + uvOffset.xy);\\n\\t\\t\\t\\t\\tvec4 c2 = texture2D( maskTexture, vUv - uvOffset.xy);\\n\\t\\t\\t\\t\\tvec4 c3 = texture2D( maskTexture, vUv + uvOffset.yw);\\n\\t\\t\\t\\t\\tvec4 c4 = texture2D( maskTexture, vUv - uvOffset.yw);\\n\\t\\t\\t\\t\\tfloat diff1 = (c1.r - c2.r)*0.5;\\n\\t\\t\\t\\t\\tfloat diff2 = (c3.r - c4.r)*0.5;\\n\\t\\t\\t\\t\\tfloat d = length( vec2(diff1, diff2) );\\n\\t\\t\\t\\t\\tfloat a1 = min(c1.g, c2.g);\\n\\t\\t\\t\\t\\tfloat a2 = min(c3.g, c4.g);\\n\\t\\t\\t\\t\\tfloat visibilityFactor = min(a1, a2);\\n\\t\\t\\t\\t\\tvec3 edgeColor = 1.0 - visibilityFactor > 0.001 ? visibleEdgeColor : hiddenEdgeColor;\\n\\t\\t\\t\\t\\tgl_FragColor = vec4(edgeColor, 1.0) * vec4(d);\\n\\t\\t\\t\\t}\"\n      });\n    }\n  }, {\n    key: \"getSeperableBlurMaterial\",\n    value: function getSeperableBlurMaterial(maxRadius) {\n      return new ShaderMaterial({\n        defines: {\n          MAX_RADIUS: maxRadius\n        },\n        uniforms: {\n          colorTexture: {\n            value: null\n          },\n          texSize: {\n            value: new Vector2(0.5, 0.5)\n          },\n          direction: {\n            value: new Vector2(0.5, 0.5)\n          },\n          kernelRadius: {\n            value: 1\n          }\n        },\n        vertexShader: \"varying vec2 vUv;\\n\\t\\t\\t\\tvoid main() {\\n\\t\\t\\t\\t\\tvUv = uv;\\n\\t\\t\\t\\t\\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n\\t\\t\\t\\t}\",\n        fragmentShader: \"#include <common>\\n\\t\\t\\t\\tvarying vec2 vUv;\\n\\t\\t\\t\\tuniform sampler2D colorTexture;\\n\\t\\t\\t\\tuniform vec2 texSize;\\n\\t\\t\\t\\tuniform vec2 direction;\\n\\t\\t\\t\\tuniform float kernelRadius;\\n\\t\\t\\t\\tfloat gaussianPdf(in float x, in float sigma) {\\n\\t\\t\\t\\t\\treturn 0.39894 * exp( -0.5 * x * x/( sigma * sigma))/sigma;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tvoid main() {\\n\\t\\t\\t\\t\\tvec2 invSize = 1.0 / texSize;\\n\\t\\t\\t\\t\\tfloat weightSum = gaussianPdf(0.0, kernelRadius);\\n\\t\\t\\t\\t\\tvec4 diffuseSum = texture2D( colorTexture, vUv) * weightSum;\\n\\t\\t\\t\\t\\tvec2 delta = direction * invSize * kernelRadius/float(MAX_RADIUS);\\n\\t\\t\\t\\t\\tvec2 uvOffset = delta;\\n\\t\\t\\t\\t\\tfor( int i = 1; i <= MAX_RADIUS; i ++ ) {\\n\\t\\t\\t\\t\\t\\tfloat w = gaussianPdf(uvOffset.x, kernelRadius);\\n\\t\\t\\t\\t\\t\\tvec4 sample1 = texture2D( colorTexture, vUv + uvOffset);\\n\\t\\t\\t\\t\\t\\tvec4 sample2 = texture2D( colorTexture, vUv - uvOffset);\\n\\t\\t\\t\\t\\t\\tdiffuseSum += ((sample1 + sample2) * w);\\n\\t\\t\\t\\t\\t\\tweightSum += (2.0 * w);\\n\\t\\t\\t\\t\\t\\tuvOffset += delta;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tgl_FragColor = diffuseSum/weightSum;\\n\\t\\t\\t\\t}\"\n      });\n    }\n  }, {\n    key: \"getOverlayMaterial\",\n    value: function getOverlayMaterial() {\n      return new ShaderMaterial({\n        uniforms: {\n          maskTexture: {\n            value: null\n          },\n          edgeTexture1: {\n            value: null\n          },\n          edgeTexture2: {\n            value: null\n          },\n          patternTexture: {\n            value: null\n          },\n          edgeStrength: {\n            value: 1\n          },\n          edgeGlow: {\n            value: 1\n          },\n          usePatternTexture: {\n            value: 0\n          }\n        },\n        vertexShader: \"varying vec2 vUv;\\n\\t\\t\\t\\tvoid main() {\\n\\t\\t\\t\\t\\tvUv = uv;\\n\\t\\t\\t\\t\\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n\\t\\t\\t\\t}\",\n        fragmentShader: \"varying vec2 vUv;\\n\\t\\t\\t\\tuniform sampler2D maskTexture;\\n\\t\\t\\t\\tuniform sampler2D edgeTexture1;\\n\\t\\t\\t\\tuniform sampler2D edgeTexture2;\\n\\t\\t\\t\\tuniform sampler2D patternTexture;\\n\\t\\t\\t\\tuniform float edgeStrength;\\n\\t\\t\\t\\tuniform float edgeGlow;\\n\\t\\t\\t\\tuniform bool usePatternTexture;\\n\\t\\t\\t\\tvoid main() {\\n\\t\\t\\t\\t\\tvec4 edgeValue1 = texture2D(edgeTexture1, vUv);\\n\\t\\t\\t\\t\\tvec4 edgeValue2 = texture2D(edgeTexture2, vUv);\\n\\t\\t\\t\\t\\tvec4 maskColor = texture2D(maskTexture, vUv);\\n\\t\\t\\t\\t\\tvec4 patternColor = texture2D(patternTexture, 6.0 * vUv);\\n\\t\\t\\t\\t\\tfloat visibilityFactor = 1.0 - maskColor.g > 0.0 ? 1.0 : 0.5;\\n\\t\\t\\t\\t\\tvec4 edgeValue = edgeValue1 + edgeValue2 * edgeGlow;\\n\\t\\t\\t\\t\\tvec4 finalColor = edgeStrength * maskColor.r * edgeValue;\\n\\t\\t\\t\\t\\tif(usePatternTexture)\\n\\t\\t\\t\\t\\t\\tfinalColor += + visibilityFactor * (1.0 - maskColor.r) * (1.0 - patternColor.r);\\n\\t\\t\\t\\t\\tgl_FragColor = finalColor;\\n\\t\\t\\t\\t}\",\n        blending: AdditiveBlending,\n        depthTest: false,\n        depthWrite: false,\n        transparent: true\n      });\n    }\n  }]);\n  return OutlinePass;\n}(Pass);\nexport { OutlinePass };","map":{"version":3,"names":["OutlinePass","_Pass","_inherits","_super","_createSuper","resolution","scene","camera","selectedObjects","_this","_classCallCheck","call","__publicField","_assertThisInitialized","Vector2","renderScene","renderCamera","visibleEdgeColor","Color","hiddenEdgeColor","edgeGlow","usePatternTexture","edgeThickness","edgeStrength","downSampleRatio","pulsePeriod","_visibilityCache","Map","x","y","resx","Math","round","resy","renderTargetMaskBuffer","WebGLRenderTarget","texture","name","generateMipmaps","depthMaterial","MeshDepthMaterial","side","DoubleSide","depthPacking","RGBADepthPacking","blending","NoBlending","prepareMaskMaterial","getPrepareMaskMaterial","fragmentShader","replaceDepthToViewZ","renderTargetDepthBuffer","renderTargetMaskDownSampleBuffer","renderTargetBlurBuffer1","renderTargetBlurBuffer2","edgeDetectionMaterial","getEdgeDetectionMaterial","renderTargetEdgeBuffer1","renderTargetEdgeBuffer2","MAX_EDGE_THICKNESS","MAX_EDGE_GLOW","separableBlurMaterial1","getSeperableBlurMaterial","uniforms","value","set","separableBlurMaterial2","overlayMaterial","getOverlayMaterial","CopyShader","console","error","copyShader","copyUniforms","UniformsUtils","clone","materialCopy","ShaderMaterial","vertexShader","depthTest","depthWrite","transparent","enabled","needsSwap","_oldClearColor","oldClearAlpha","fsQuad","FullScreenQuad","tempPulseColor1","tempPulseColor2","textureMatrix","Matrix4","string","camera2","type","isPerspectiveCamera","replace","_createClass","key","dispose","setSize","width","height","changeVisibilityOfSelectedObjects","bVisible","cache","gatherSelectedMeshesCallBack","object","isMesh","visible","get","i","length","selectedObject","traverse","changeVisibilityOfNonSelectedObjects","selectedMeshes","push","VisibilityChangeCallBack","isSprite","bFound","selectedObjectId","id","visibility","isPoints","isLine","updateTextureMatrix","multiply","projectionMatrix","matrixWorldInverse","render","renderer","writeBuffer","readBuffer","deltaTime","maskActive","getClearColor","getClearAlpha","oldAutoClear","autoClear","state","buffers","stencil","setTest","setClearColor","currentBackground","background","overrideMaterial","setRenderTarget","clear","near","far","material","copy","scalar","cos","performance","now","multiplyScalar","BlurDirectionX","BlurDirectionY","patternTexture","renderToScreen","depthTexture","cameraNearFar","maskTexture","texSize","Vector3","maxRadius","defines","MAX_RADIUS","colorTexture","direction","kernelRadius","edgeTexture1","edgeTexture2","AdditiveBlending","Pass"],"sources":["C:\\Users\\Nayyu\\Desktop\\skibidai-public-build\\node_modules\\src\\postprocessing\\OutlinePass.ts"],"sourcesContent":["import { Pass, FullScreenQuad } from './Pass'\nimport {\n  AdditiveBlending,\n  Camera,\n  Color,\n  DoubleSide,\n  Line,\n  Matrix4,\n  Mesh,\n  MeshDepthMaterial,\n  NoBlending,\n  Object3D,\n  PerspectiveCamera,\n  Points,\n  RGBADepthPacking,\n  Scene,\n  ShaderMaterial,\n  Sprite,\n  Texture,\n  UniformsUtils,\n  Vector2,\n  Vector3,\n  WebGLRenderer,\n  WebGLRenderTarget,\n} from 'three'\nimport { CopyShader } from '../shaders/CopyShader'\n\nclass OutlinePass extends Pass {\n  public renderScene: Scene\n  public renderCamera: Camera\n  public selectedObjects: Object3D[]\n  public visibleEdgeColor: Color\n  public hiddenEdgeColor: Color\n  public edgeGlow: number\n  public usePatternTexture: boolean\n  public edgeThickness: number\n  public edgeStrength: number\n  public downSampleRatio: number\n  public pulsePeriod: number\n  public resolution: Vector2\n  public renderTargetMaskBuffer: WebGLRenderTarget\n  public depthMaterial: MeshDepthMaterial\n  public prepareMaskMaterial: ShaderMaterial\n  public renderTargetDepthBuffer: WebGLRenderTarget\n  public renderTargetMaskDownSampleBuffer: WebGLRenderTarget\n  public renderTargetBlurBuffer1: WebGLRenderTarget\n  public renderTargetBlurBuffer2: WebGLRenderTarget\n  public edgeDetectionMaterial: ShaderMaterial\n  public renderTargetEdgeBuffer1: WebGLRenderTarget\n  public renderTargetEdgeBuffer2: WebGLRenderTarget\n  public separableBlurMaterial1: ShaderMaterial\n  public separableBlurMaterial2: ShaderMaterial\n  public overlayMaterial: ShaderMaterial\n  public materialCopy: ShaderMaterial\n  public oldClearAlpha: number\n  public fsQuad: FullScreenQuad\n  public tempPulseColor1: Color\n  public tempPulseColor2: Color\n  public textureMatrix: Matrix4\n  public patternTexture?: Texture\n\n  private _visibilityCache: Map<Object3D, boolean>\n  private _oldClearColor: Color\n\n  public copyUniforms\n\n  public BlurDirectionX = new Vector2(1.0, 0.0)\n  public BlurDirectionY = new Vector2(0.0, 1.0)\n\n  constructor(resolution: Vector2, scene: Scene, camera: Camera, selectedObjects?: Object3D[]) {\n    super()\n\n    this.renderScene = scene\n    this.renderCamera = camera\n    this.selectedObjects = selectedObjects !== undefined ? selectedObjects : []\n    this.visibleEdgeColor = new Color(1, 1, 1)\n    this.hiddenEdgeColor = new Color(0.1, 0.04, 0.02)\n    this.edgeGlow = 0.0\n    this.usePatternTexture = false\n    this.edgeThickness = 1.0\n    this.edgeStrength = 3.0\n    this.downSampleRatio = 2\n    this.pulsePeriod = 0\n\n    this._visibilityCache = new Map()\n\n    this.resolution = resolution !== undefined ? new Vector2(resolution.x, resolution.y) : new Vector2(256, 256)\n\n    const resx = Math.round(this.resolution.x / this.downSampleRatio)\n    const resy = Math.round(this.resolution.y / this.downSampleRatio)\n\n    this.renderTargetMaskBuffer = new WebGLRenderTarget(this.resolution.x, this.resolution.y)\n    this.renderTargetMaskBuffer.texture.name = 'OutlinePass.mask'\n    this.renderTargetMaskBuffer.texture.generateMipmaps = false\n\n    this.depthMaterial = new MeshDepthMaterial()\n    this.depthMaterial.side = DoubleSide\n    this.depthMaterial.depthPacking = RGBADepthPacking\n    this.depthMaterial.blending = NoBlending\n\n    this.prepareMaskMaterial = this.getPrepareMaskMaterial()\n    this.prepareMaskMaterial.side = DoubleSide\n    this.prepareMaskMaterial.fragmentShader = replaceDepthToViewZ(\n      this.prepareMaskMaterial.fragmentShader,\n      this.renderCamera as PerspectiveCamera,\n    )\n\n    this.renderTargetDepthBuffer = new WebGLRenderTarget(this.resolution.x, this.resolution.y)\n    this.renderTargetDepthBuffer.texture.name = 'OutlinePass.depth'\n    this.renderTargetDepthBuffer.texture.generateMipmaps = false\n\n    this.renderTargetMaskDownSampleBuffer = new WebGLRenderTarget(resx, resy)\n    this.renderTargetMaskDownSampleBuffer.texture.name = 'OutlinePass.depthDownSample'\n    this.renderTargetMaskDownSampleBuffer.texture.generateMipmaps = false\n\n    this.renderTargetBlurBuffer1 = new WebGLRenderTarget(resx, resy)\n    this.renderTargetBlurBuffer1.texture.name = 'OutlinePass.blur1'\n    this.renderTargetBlurBuffer1.texture.generateMipmaps = false\n    this.renderTargetBlurBuffer2 = new WebGLRenderTarget(Math.round(resx / 2), Math.round(resy / 2))\n    this.renderTargetBlurBuffer2.texture.name = 'OutlinePass.blur2'\n    this.renderTargetBlurBuffer2.texture.generateMipmaps = false\n\n    this.edgeDetectionMaterial = this.getEdgeDetectionMaterial()\n    this.renderTargetEdgeBuffer1 = new WebGLRenderTarget(resx, resy)\n    this.renderTargetEdgeBuffer1.texture.name = 'OutlinePass.edge1'\n    this.renderTargetEdgeBuffer1.texture.generateMipmaps = false\n    this.renderTargetEdgeBuffer2 = new WebGLRenderTarget(Math.round(resx / 2), Math.round(resy / 2))\n    this.renderTargetEdgeBuffer2.texture.name = 'OutlinePass.edge2'\n    this.renderTargetEdgeBuffer2.texture.generateMipmaps = false\n\n    const MAX_EDGE_THICKNESS = 4\n    const MAX_EDGE_GLOW = 4\n\n    this.separableBlurMaterial1 = this.getSeperableBlurMaterial(MAX_EDGE_THICKNESS)\n    this.separableBlurMaterial1.uniforms['texSize'].value.set(resx, resy)\n    this.separableBlurMaterial1.uniforms['kernelRadius'].value = 1\n    this.separableBlurMaterial2 = this.getSeperableBlurMaterial(MAX_EDGE_GLOW)\n    this.separableBlurMaterial2.uniforms['texSize'].value.set(Math.round(resx / 2), Math.round(resy / 2))\n    this.separableBlurMaterial2.uniforms['kernelRadius'].value = MAX_EDGE_GLOW\n\n    // Overlay material\n    this.overlayMaterial = this.getOverlayMaterial()\n\n    // copy material\n    if (CopyShader === undefined) console.error('THREE.OutlinePass relies on CopyShader')\n\n    const copyShader = CopyShader\n\n    this.copyUniforms = UniformsUtils.clone(copyShader.uniforms)\n    this.copyUniforms['opacity'].value = 1.0\n\n    this.materialCopy = new ShaderMaterial({\n      uniforms: this.copyUniforms,\n      vertexShader: copyShader.vertexShader,\n      fragmentShader: copyShader.fragmentShader,\n      blending: NoBlending,\n      depthTest: false,\n      depthWrite: false,\n      transparent: true,\n    })\n\n    this.enabled = true\n    this.needsSwap = false\n\n    this._oldClearColor = new Color()\n    this.oldClearAlpha = 1\n\n    this.fsQuad = new FullScreenQuad(this.materialCopy)\n\n    this.tempPulseColor1 = new Color()\n    this.tempPulseColor2 = new Color()\n    this.textureMatrix = new Matrix4()\n\n    function replaceDepthToViewZ(string: string, camera: PerspectiveCamera): string {\n      const type = camera.isPerspectiveCamera ? 'perspective' : 'orthographic'\n\n      return string.replace(/DEPTH_TO_VIEW_Z/g, type + 'DepthToViewZ')\n    }\n  }\n\n  public dispose(): void {\n    this.renderTargetMaskBuffer.dispose()\n    this.renderTargetDepthBuffer.dispose()\n    this.renderTargetMaskDownSampleBuffer.dispose()\n    this.renderTargetBlurBuffer1.dispose()\n    this.renderTargetBlurBuffer2.dispose()\n    this.renderTargetEdgeBuffer1.dispose()\n    this.renderTargetEdgeBuffer2.dispose()\n  }\n\n  public setSize(width: number, height: number): void {\n    this.renderTargetMaskBuffer.setSize(width, height)\n    this.renderTargetDepthBuffer.setSize(width, height)\n\n    let resx = Math.round(width / this.downSampleRatio)\n    let resy = Math.round(height / this.downSampleRatio)\n    this.renderTargetMaskDownSampleBuffer.setSize(resx, resy)\n    this.renderTargetBlurBuffer1.setSize(resx, resy)\n    this.renderTargetEdgeBuffer1.setSize(resx, resy)\n    this.separableBlurMaterial1.uniforms['texSize'].value.set(resx, resy)\n\n    resx = Math.round(resx / 2)\n    resy = Math.round(resy / 2)\n\n    this.renderTargetBlurBuffer2.setSize(resx, resy)\n    this.renderTargetEdgeBuffer2.setSize(resx, resy)\n\n    this.separableBlurMaterial2.uniforms['texSize'].value.set(resx, resy)\n  }\n\n  public changeVisibilityOfSelectedObjects(bVisible: boolean): void {\n    const cache = this._visibilityCache\n\n    function gatherSelectedMeshesCallBack(object: Object3D): void {\n      if ((object as Mesh).isMesh) {\n        if (bVisible === true) {\n          object.visible = cache.get(object) as boolean\n        } else {\n          cache.set(object, object.visible)\n          object.visible = bVisible\n        }\n      }\n    }\n\n    for (let i = 0; i < this.selectedObjects.length; i++) {\n      const selectedObject = this.selectedObjects[i]\n      selectedObject.traverse(gatherSelectedMeshesCallBack)\n    }\n  }\n\n  public changeVisibilityOfNonSelectedObjects(bVisible: boolean): void {\n    const cache = this._visibilityCache\n    const selectedMeshes: Object3D[] = []\n\n    function gatherSelectedMeshesCallBack(object: Object3D): void {\n      if ((object as Mesh).isMesh) selectedMeshes.push(object)\n    }\n\n    for (let i = 0; i < this.selectedObjects.length; i++) {\n      const selectedObject = this.selectedObjects[i]\n      selectedObject.traverse(gatherSelectedMeshesCallBack)\n    }\n\n    function VisibilityChangeCallBack(object: Object3D): void {\n      if ((object as Mesh).isMesh || (object as Sprite).isSprite) {\n        // only meshes and sprites are supported by OutlinePass\n\n        let bFound = false\n\n        for (let i = 0; i < selectedMeshes.length; i++) {\n          const selectedObjectId = selectedMeshes[i].id\n\n          if (selectedObjectId === object.id) {\n            bFound = true\n            break\n          }\n        }\n\n        if (bFound === false) {\n          const visibility = object.visible\n\n          if (bVisible === false || cache.get(object) === true) {\n            object.visible = bVisible\n          }\n\n          cache.set(object, visibility)\n        }\n      } else if ((object as Points).isPoints || (object as Line).isLine) {\n        // the visibilty of points and lines is always set to false in order to\n        // not affect the outline computation\n\n        if (bVisible === true) {\n          object.visible = cache.get(object) as boolean // restore\n        } else {\n          cache.set(object, object.visible)\n          object.visible = bVisible\n        }\n      }\n    }\n\n    this.renderScene.traverse(VisibilityChangeCallBack)\n  }\n\n  public updateTextureMatrix(): void {\n    this.textureMatrix.set(0.5, 0.0, 0.0, 0.5, 0.0, 0.5, 0.0, 0.5, 0.0, 0.0, 0.5, 0.5, 0.0, 0.0, 0.0, 1.0)\n    this.textureMatrix.multiply(this.renderCamera.projectionMatrix)\n    this.textureMatrix.multiply(this.renderCamera.matrixWorldInverse)\n  }\n\n  public render(\n    renderer: WebGLRenderer,\n    writeBuffer: WebGLRenderTarget,\n    readBuffer: WebGLRenderTarget,\n    deltaTime: number,\n    maskActive: boolean,\n  ): void {\n    if (this.selectedObjects.length > 0) {\n      renderer.getClearColor(this._oldClearColor)\n      this.oldClearAlpha = renderer.getClearAlpha()\n      const oldAutoClear = renderer.autoClear\n\n      renderer.autoClear = false\n\n      if (maskActive) renderer.state.buffers.stencil.setTest(false)\n\n      renderer.setClearColor(0xffffff, 1)\n\n      // Make selected objects invisible\n      this.changeVisibilityOfSelectedObjects(false)\n\n      const currentBackground = this.renderScene.background\n      this.renderScene.background = null\n\n      // 1. Draw Non Selected objects in the depth buffer\n      this.renderScene.overrideMaterial = this.depthMaterial\n      renderer.setRenderTarget(this.renderTargetDepthBuffer)\n      renderer.clear()\n      renderer.render(this.renderScene, this.renderCamera)\n\n      // Make selected objects visible\n      this.changeVisibilityOfSelectedObjects(true)\n      this._visibilityCache.clear()\n\n      // Update Texture Matrix for Depth compare\n      this.updateTextureMatrix()\n\n      // Make non selected objects invisible, and draw only the selected objects, by comparing the depth buffer of non selected objects\n      this.changeVisibilityOfNonSelectedObjects(false)\n      this.renderScene.overrideMaterial = this.prepareMaskMaterial\n      this.prepareMaskMaterial.uniforms['cameraNearFar'].value.set(\n        (this.renderCamera as PerspectiveCamera).near,\n        (this.renderCamera as PerspectiveCamera).far,\n      )\n      this.prepareMaskMaterial.uniforms['depthTexture'].value = this.renderTargetDepthBuffer.texture\n      this.prepareMaskMaterial.uniforms['textureMatrix'].value = this.textureMatrix\n      renderer.setRenderTarget(this.renderTargetMaskBuffer)\n      renderer.clear()\n      renderer.render(this.renderScene, this.renderCamera)\n      this.renderScene.overrideMaterial = null\n      this.changeVisibilityOfNonSelectedObjects(true)\n      this._visibilityCache.clear()\n\n      this.renderScene.background = currentBackground\n\n      // 2. Downsample to Half resolution\n      this.fsQuad.material = this.materialCopy\n      this.copyUniforms['tDiffuse'].value = this.renderTargetMaskBuffer.texture\n      renderer.setRenderTarget(this.renderTargetMaskDownSampleBuffer)\n      renderer.clear()\n      this.fsQuad.render(renderer)\n\n      this.tempPulseColor1.copy(this.visibleEdgeColor)\n      this.tempPulseColor2.copy(this.hiddenEdgeColor)\n\n      if (this.pulsePeriod > 0) {\n        const scalar = (1 + 0.25) / 2 + (Math.cos((performance.now() * 0.01) / this.pulsePeriod) * (1.0 - 0.25)) / 2\n        this.tempPulseColor1.multiplyScalar(scalar)\n        this.tempPulseColor2.multiplyScalar(scalar)\n      }\n\n      // 3. Apply Edge Detection Pass\n      this.fsQuad.material = this.edgeDetectionMaterial\n      this.edgeDetectionMaterial.uniforms['maskTexture'].value = this.renderTargetMaskDownSampleBuffer.texture\n      this.edgeDetectionMaterial.uniforms['texSize'].value.set(\n        this.renderTargetMaskDownSampleBuffer.width,\n        this.renderTargetMaskDownSampleBuffer.height,\n      )\n      this.edgeDetectionMaterial.uniforms['visibleEdgeColor'].value = this.tempPulseColor1\n      this.edgeDetectionMaterial.uniforms['hiddenEdgeColor'].value = this.tempPulseColor2\n      renderer.setRenderTarget(this.renderTargetEdgeBuffer1)\n      renderer.clear()\n      this.fsQuad.render(renderer)\n\n      // 4. Apply Blur on Half res\n      this.fsQuad.material = this.separableBlurMaterial1\n      this.separableBlurMaterial1.uniforms['colorTexture'].value = this.renderTargetEdgeBuffer1.texture\n      this.separableBlurMaterial1.uniforms['direction'].value = this.BlurDirectionX\n      this.separableBlurMaterial1.uniforms['kernelRadius'].value = this.edgeThickness\n      renderer.setRenderTarget(this.renderTargetBlurBuffer1)\n      renderer.clear()\n      this.fsQuad.render(renderer)\n      this.separableBlurMaterial1.uniforms['colorTexture'].value = this.renderTargetBlurBuffer1.texture\n      this.separableBlurMaterial1.uniforms['direction'].value = this.BlurDirectionY\n      renderer.setRenderTarget(this.renderTargetEdgeBuffer1)\n      renderer.clear()\n      this.fsQuad.render(renderer)\n\n      // Apply Blur on quarter res\n      this.fsQuad.material = this.separableBlurMaterial2\n      this.separableBlurMaterial2.uniforms['colorTexture'].value = this.renderTargetEdgeBuffer1.texture\n      this.separableBlurMaterial2.uniforms['direction'].value = this.BlurDirectionX\n      renderer.setRenderTarget(this.renderTargetBlurBuffer2)\n      renderer.clear()\n      this.fsQuad.render(renderer)\n      this.separableBlurMaterial2.uniforms['colorTexture'].value = this.renderTargetBlurBuffer2.texture\n      this.separableBlurMaterial2.uniforms['direction'].value = this.BlurDirectionY\n      renderer.setRenderTarget(this.renderTargetEdgeBuffer2)\n      renderer.clear()\n      this.fsQuad.render(renderer)\n\n      // Blend it additively over the input texture\n      this.fsQuad.material = this.overlayMaterial\n      this.overlayMaterial.uniforms['maskTexture'].value = this.renderTargetMaskBuffer.texture\n      this.overlayMaterial.uniforms['edgeTexture1'].value = this.renderTargetEdgeBuffer1.texture\n      this.overlayMaterial.uniforms['edgeTexture2'].value = this.renderTargetEdgeBuffer2.texture\n      this.overlayMaterial.uniforms['patternTexture'].value = this.patternTexture\n      this.overlayMaterial.uniforms['edgeStrength'].value = this.edgeStrength\n      this.overlayMaterial.uniforms['edgeGlow'].value = this.edgeGlow\n      this.overlayMaterial.uniforms['usePatternTexture'].value = this.usePatternTexture\n\n      if (maskActive) renderer.state.buffers.stencil.setTest(true)\n\n      renderer.setRenderTarget(readBuffer)\n      this.fsQuad.render(renderer)\n\n      renderer.setClearColor(this._oldClearColor, this.oldClearAlpha)\n      renderer.autoClear = oldAutoClear\n    }\n\n    if (this.renderToScreen) {\n      this.fsQuad.material = this.materialCopy\n      this.copyUniforms['tDiffuse'].value = readBuffer.texture\n      renderer.setRenderTarget(null)\n      this.fsQuad.render(renderer)\n    }\n  }\n\n  public getPrepareMaskMaterial(): ShaderMaterial {\n    return new ShaderMaterial({\n      uniforms: {\n        depthTexture: { value: null },\n        cameraNearFar: { value: new Vector2(0.5, 0.5) },\n        textureMatrix: { value: null },\n      },\n\n      vertexShader: `#include <morphtarget_pars_vertex>\n\t\t\t\t#include <skinning_pars_vertex>\n\t\t\t\tvarying vec4 projTexCoord;\n\t\t\t\tvarying vec4 vPosition;\n\t\t\t\tuniform mat4 textureMatrix;\n\t\t\t\tvoid main() {\n\t\t\t\t\t#include <skinbase_vertex>\n\t\t\t\t\t#include <begin_vertex>\n\t\t\t\t\t#include <morphtarget_vertex>\n\t\t\t\t\t#include <skinning_vertex>\n\t\t\t\t\t#include <project_vertex>\n\t\t\t\t\tvPosition = mvPosition;\n\t\t\t\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\n\t\t\t\t\tprojTexCoord = textureMatrix * worldPosition;\n\t\t\t\t}`,\n\n      fragmentShader: `#include <packing>\n\t\t\t\tvarying vec4 vPosition;\n\t\t\t\tvarying vec4 projTexCoord;\n\t\t\t\tuniform sampler2D depthTexture;\n\t\t\t\tuniform vec2 cameraNearFar;\n\t\t\t\tvoid main() {\n\t\t\t\t\tfloat depth = unpackRGBAToDepth(texture2DProj( depthTexture, projTexCoord ));\n\t\t\t\t\tfloat viewZ = - DEPTH_TO_VIEW_Z( depth, cameraNearFar.x, cameraNearFar.y );\n\t\t\t\t\tfloat depthTest = (-vPosition.z > viewZ) ? 1.0 : 0.0;\n\t\t\t\t\tgl_FragColor = vec4(0.0, depthTest, 1.0, 1.0);\n\t\t\t\t}`,\n    })\n  }\n\n  public getEdgeDetectionMaterial(): ShaderMaterial {\n    return new ShaderMaterial({\n      uniforms: {\n        maskTexture: { value: null },\n        texSize: { value: new Vector2(0.5, 0.5) },\n        visibleEdgeColor: { value: new Vector3(1.0, 1.0, 1.0) },\n        hiddenEdgeColor: { value: new Vector3(1.0, 1.0, 1.0) },\n      },\n\n      vertexShader: `varying vec2 vUv;\n\t\t\t\tvoid main() {\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t}`,\n\n      fragmentShader: `varying vec2 vUv;\n\t\t\t\tuniform sampler2D maskTexture;\n\t\t\t\tuniform vec2 texSize;\n\t\t\t\tuniform vec3 visibleEdgeColor;\n\t\t\t\tuniform vec3 hiddenEdgeColor;\n\t\t\t\tvoid main() {\n\t\t\t\t\tvec2 invSize = 1.0 / texSize;\n\t\t\t\t\tvec4 uvOffset = vec4(1.0, 0.0, 0.0, 1.0) * vec4(invSize, invSize);\n\t\t\t\t\tvec4 c1 = texture2D( maskTexture, vUv + uvOffset.xy);\n\t\t\t\t\tvec4 c2 = texture2D( maskTexture, vUv - uvOffset.xy);\n\t\t\t\t\tvec4 c3 = texture2D( maskTexture, vUv + uvOffset.yw);\n\t\t\t\t\tvec4 c4 = texture2D( maskTexture, vUv - uvOffset.yw);\n\t\t\t\t\tfloat diff1 = (c1.r - c2.r)*0.5;\n\t\t\t\t\tfloat diff2 = (c3.r - c4.r)*0.5;\n\t\t\t\t\tfloat d = length( vec2(diff1, diff2) );\n\t\t\t\t\tfloat a1 = min(c1.g, c2.g);\n\t\t\t\t\tfloat a2 = min(c3.g, c4.g);\n\t\t\t\t\tfloat visibilityFactor = min(a1, a2);\n\t\t\t\t\tvec3 edgeColor = 1.0 - visibilityFactor > 0.001 ? visibleEdgeColor : hiddenEdgeColor;\n\t\t\t\t\tgl_FragColor = vec4(edgeColor, 1.0) * vec4(d);\n\t\t\t\t}`,\n    })\n  }\n\n  public getSeperableBlurMaterial(maxRadius: number): ShaderMaterial {\n    return new ShaderMaterial({\n      defines: {\n        MAX_RADIUS: maxRadius,\n      },\n\n      uniforms: {\n        colorTexture: { value: null },\n        texSize: { value: new Vector2(0.5, 0.5) },\n        direction: { value: new Vector2(0.5, 0.5) },\n        kernelRadius: { value: 1.0 },\n      },\n\n      vertexShader: `varying vec2 vUv;\n\t\t\t\tvoid main() {\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t}`,\n\n      fragmentShader: `#include <common>\n\t\t\t\tvarying vec2 vUv;\n\t\t\t\tuniform sampler2D colorTexture;\n\t\t\t\tuniform vec2 texSize;\n\t\t\t\tuniform vec2 direction;\n\t\t\t\tuniform float kernelRadius;\n\t\t\t\tfloat gaussianPdf(in float x, in float sigma) {\n\t\t\t\t\treturn 0.39894 * exp( -0.5 * x * x/( sigma * sigma))/sigma;\n\t\t\t\t}\n\t\t\t\tvoid main() {\n\t\t\t\t\tvec2 invSize = 1.0 / texSize;\n\t\t\t\t\tfloat weightSum = gaussianPdf(0.0, kernelRadius);\n\t\t\t\t\tvec4 diffuseSum = texture2D( colorTexture, vUv) * weightSum;\n\t\t\t\t\tvec2 delta = direction * invSize * kernelRadius/float(MAX_RADIUS);\n\t\t\t\t\tvec2 uvOffset = delta;\n\t\t\t\t\tfor( int i = 1; i <= MAX_RADIUS; i ++ ) {\n\t\t\t\t\t\tfloat w = gaussianPdf(uvOffset.x, kernelRadius);\n\t\t\t\t\t\tvec4 sample1 = texture2D( colorTexture, vUv + uvOffset);\n\t\t\t\t\t\tvec4 sample2 = texture2D( colorTexture, vUv - uvOffset);\n\t\t\t\t\t\tdiffuseSum += ((sample1 + sample2) * w);\n\t\t\t\t\t\tweightSum += (2.0 * w);\n\t\t\t\t\t\tuvOffset += delta;\n\t\t\t\t\t}\n\t\t\t\t\tgl_FragColor = diffuseSum/weightSum;\n\t\t\t\t}`,\n    })\n  }\n\n  public getOverlayMaterial(): ShaderMaterial {\n    return new ShaderMaterial({\n      uniforms: {\n        maskTexture: { value: null },\n        edgeTexture1: { value: null },\n        edgeTexture2: { value: null },\n        patternTexture: { value: null },\n        edgeStrength: { value: 1.0 },\n        edgeGlow: { value: 1.0 },\n        usePatternTexture: { value: 0.0 },\n      },\n\n      vertexShader: `varying vec2 vUv;\n\t\t\t\tvoid main() {\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t}`,\n\n      fragmentShader: `varying vec2 vUv;\n\t\t\t\tuniform sampler2D maskTexture;\n\t\t\t\tuniform sampler2D edgeTexture1;\n\t\t\t\tuniform sampler2D edgeTexture2;\n\t\t\t\tuniform sampler2D patternTexture;\n\t\t\t\tuniform float edgeStrength;\n\t\t\t\tuniform float edgeGlow;\n\t\t\t\tuniform bool usePatternTexture;\n\t\t\t\tvoid main() {\n\t\t\t\t\tvec4 edgeValue1 = texture2D(edgeTexture1, vUv);\n\t\t\t\t\tvec4 edgeValue2 = texture2D(edgeTexture2, vUv);\n\t\t\t\t\tvec4 maskColor = texture2D(maskTexture, vUv);\n\t\t\t\t\tvec4 patternColor = texture2D(patternTexture, 6.0 * vUv);\n\t\t\t\t\tfloat visibilityFactor = 1.0 - maskColor.g > 0.0 ? 1.0 : 0.5;\n\t\t\t\t\tvec4 edgeValue = edgeValue1 + edgeValue2 * edgeGlow;\n\t\t\t\t\tvec4 finalColor = edgeStrength * maskColor.r * edgeValue;\n\t\t\t\t\tif(usePatternTexture)\n\t\t\t\t\t\tfinalColor += + visibilityFactor * (1.0 - maskColor.r) * (1.0 - patternColor.r);\n\t\t\t\t\tgl_FragColor = finalColor;\n\t\t\t\t}`,\n      blending: AdditiveBlending,\n      depthTest: false,\n      depthWrite: false,\n      transparent: true,\n    })\n  }\n}\n\nexport { OutlinePass }\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;IA2BMA,WAAA,0BAAAC,KAAA;EAAAC,SAAA,CAAAF,WAAA,EAAAC,KAAA;EAAA,IAAAE,MAAA,GAAAC,YAAA,CAAAJ,WAAA;EA0CJ,SAAAA,YAAYK,UAAA,EAAqBC,KAAA,EAAcC,MAAA,EAAgBC,eAAA,EAA8B;IAAA,IAAAC,KAAA;IAAAC,eAAA,OAAAV,WAAA;IACrFS,KAAA,GAAAN,MAAA,CAAAQ,IAAA;IA1CDC,aAAA,CAAAC,sBAAA,CAAAJ,KAAA;IACAG,aAAA,CAAAC,sBAAA,CAAAJ,KAAA;IACAG,aAAA,CAAAC,sBAAA,CAAAJ,KAAA;IACAG,aAAA,CAAAC,sBAAA,CAAAJ,KAAA;IACAG,aAAA,CAAAC,sBAAA,CAAAJ,KAAA;IACAG,aAAA,CAAAC,sBAAA,CAAAJ,KAAA;IACAG,aAAA,CAAAC,sBAAA,CAAAJ,KAAA;IACAG,aAAA,CAAAC,sBAAA,CAAAJ,KAAA;IACAG,aAAA,CAAAC,sBAAA,CAAAJ,KAAA;IACAG,aAAA,CAAAC,sBAAA,CAAAJ,KAAA;IACAG,aAAA,CAAAC,sBAAA,CAAAJ,KAAA;IACAG,aAAA,CAAAC,sBAAA,CAAAJ,KAAA;IACAG,aAAA,CAAAC,sBAAA,CAAAJ,KAAA;IACAG,aAAA,CAAAC,sBAAA,CAAAJ,KAAA;IACAG,aAAA,CAAAC,sBAAA,CAAAJ,KAAA;IACAG,aAAA,CAAAC,sBAAA,CAAAJ,KAAA;IACAG,aAAA,CAAAC,sBAAA,CAAAJ,KAAA;IACAG,aAAA,CAAAC,sBAAA,CAAAJ,KAAA;IACAG,aAAA,CAAAC,sBAAA,CAAAJ,KAAA;IACAG,aAAA,CAAAC,sBAAA,CAAAJ,KAAA;IACAG,aAAA,CAAAC,sBAAA,CAAAJ,KAAA;IACAG,aAAA,CAAAC,sBAAA,CAAAJ,KAAA;IACAG,aAAA,CAAAC,sBAAA,CAAAJ,KAAA;IACAG,aAAA,CAAAC,sBAAA,CAAAJ,KAAA;IACAG,aAAA,CAAAC,sBAAA,CAAAJ,KAAA;IACAG,aAAA,CAAAC,sBAAA,CAAAJ,KAAA;IACAG,aAAA,CAAAC,sBAAA,CAAAJ,KAAA;IACAG,aAAA,CAAAC,sBAAA,CAAAJ,KAAA;IACAG,aAAA,CAAAC,sBAAA,CAAAJ,KAAA;IACAG,aAAA,CAAAC,sBAAA,CAAAJ,KAAA;IACAG,aAAA,CAAAC,sBAAA,CAAAJ,KAAA;IACAG,aAAA,CAAAC,sBAAA,CAAAJ,KAAA;IAECG,aAAA,CAAAC,sBAAA,CAAAJ,KAAA;IACAG,aAAA,CAAAC,sBAAA,CAAAJ,KAAA;IAEDG,aAAA,CAAAC,sBAAA,CAAAJ,KAAA;IAEAG,aAAA,CAAAC,sBAAA,CAAAJ,KAAA,qBAAiB,IAAIK,OAAA,CAAQ,GAAK,CAAG;IACrCF,aAAA,CAAAC,sBAAA,CAAAJ,KAAA,qBAAiB,IAAIK,OAAA,CAAQ,GAAK,CAAG;IAK1CL,KAAA,CAAKM,WAAA,GAAcT,KAAA;IACnBG,KAAA,CAAKO,YAAA,GAAeT,MAAA;IACpBE,KAAA,CAAKD,eAAA,GAAkBA,eAAA,KAAoB,SAAYA,eAAA,GAAkB;IACzEC,KAAA,CAAKQ,gBAAA,GAAmB,IAAIC,KAAA,CAAM,GAAG,GAAG,CAAC;IACzCT,KAAA,CAAKU,eAAA,GAAkB,IAAID,KAAA,CAAM,KAAK,MAAM,IAAI;IAChDT,KAAA,CAAKW,QAAA,GAAW;IAChBX,KAAA,CAAKY,iBAAA,GAAoB;IACzBZ,KAAA,CAAKa,aAAA,GAAgB;IACrBb,KAAA,CAAKc,YAAA,GAAe;IACpBd,KAAA,CAAKe,eAAA,GAAkB;IACvBf,KAAA,CAAKgB,WAAA,GAAc;IAEdhB,KAAA,CAAAiB,gBAAA,sBAAuBC,GAAA;IAE5BlB,KAAA,CAAKJ,UAAA,GAAaA,UAAA,KAAe,SAAY,IAAIS,OAAA,CAAQT,UAAA,CAAWuB,CAAA,EAAGvB,UAAA,CAAWwB,CAAC,IAAI,IAAIf,OAAA,CAAQ,KAAK,GAAG;IAE3G,IAAMgB,IAAA,GAAOC,IAAA,CAAKC,KAAA,CAAMvB,KAAA,CAAKJ,UAAA,CAAWuB,CAAA,GAAInB,KAAA,CAAKe,eAAe;IAChE,IAAMS,IAAA,GAAOF,IAAA,CAAKC,KAAA,CAAMvB,KAAA,CAAKJ,UAAA,CAAWwB,CAAA,GAAIpB,KAAA,CAAKe,eAAe;IAE3Df,KAAA,CAAAyB,sBAAA,GAAyB,IAAIC,iBAAA,CAAkB1B,KAAA,CAAKJ,UAAA,CAAWuB,CAAA,EAAGnB,KAAA,CAAKJ,UAAA,CAAWwB,CAAC;IACnFpB,KAAA,CAAAyB,sBAAA,CAAuBE,OAAA,CAAQC,IAAA,GAAO;IACtC5B,KAAA,CAAAyB,sBAAA,CAAuBE,OAAA,CAAQE,eAAA,GAAkB;IAEjD7B,KAAA,CAAA8B,aAAA,GAAgB,IAAIC,iBAAA;IACzB/B,KAAA,CAAK8B,aAAA,CAAcE,IAAA,GAAOC,UAAA;IAC1BjC,KAAA,CAAK8B,aAAA,CAAcI,YAAA,GAAeC,gBAAA;IAClCnC,KAAA,CAAK8B,aAAA,CAAcM,QAAA,GAAWC,UAAA;IAEzBrC,KAAA,CAAAsC,mBAAA,GAAsBtC,KAAA,CAAKuC,sBAAA;IAChCvC,KAAA,CAAKsC,mBAAA,CAAoBN,IAAA,GAAOC,UAAA;IAChCjC,KAAA,CAAKsC,mBAAA,CAAoBE,cAAA,GAAiBC,mBAAA,CACxCzC,KAAA,CAAKsC,mBAAA,CAAoBE,cAAA,EACzBxC,KAAA,CAAKO,YAAA;IAGFP,KAAA,CAAA0C,uBAAA,GAA0B,IAAIhB,iBAAA,CAAkB1B,KAAA,CAAKJ,UAAA,CAAWuB,CAAA,EAAGnB,KAAA,CAAKJ,UAAA,CAAWwB,CAAC;IACpFpB,KAAA,CAAA0C,uBAAA,CAAwBf,OAAA,CAAQC,IAAA,GAAO;IACvC5B,KAAA,CAAA0C,uBAAA,CAAwBf,OAAA,CAAQE,eAAA,GAAkB;IAEvD7B,KAAA,CAAK2C,gCAAA,GAAmC,IAAIjB,iBAAA,CAAkBL,IAAA,EAAMG,IAAI;IACnExB,KAAA,CAAA2C,gCAAA,CAAiChB,OAAA,CAAQC,IAAA,GAAO;IAChD5B,KAAA,CAAA2C,gCAAA,CAAiChB,OAAA,CAAQE,eAAA,GAAkB;IAEhE7B,KAAA,CAAK4C,uBAAA,GAA0B,IAAIlB,iBAAA,CAAkBL,IAAA,EAAMG,IAAI;IAC1DxB,KAAA,CAAA4C,uBAAA,CAAwBjB,OAAA,CAAQC,IAAA,GAAO;IACvC5B,KAAA,CAAA4C,uBAAA,CAAwBjB,OAAA,CAAQE,eAAA,GAAkB;IACvD7B,KAAA,CAAK6C,uBAAA,GAA0B,IAAInB,iBAAA,CAAkBJ,IAAA,CAAKC,KAAA,CAAMF,IAAA,GAAO,CAAC,GAAGC,IAAA,CAAKC,KAAA,CAAMC,IAAA,GAAO,CAAC,CAAC;IAC1FxB,KAAA,CAAA6C,uBAAA,CAAwBlB,OAAA,CAAQC,IAAA,GAAO;IACvC5B,KAAA,CAAA6C,uBAAA,CAAwBlB,OAAA,CAAQE,eAAA,GAAkB;IAElD7B,KAAA,CAAA8C,qBAAA,GAAwB9C,KAAA,CAAK+C,wBAAA;IAClC/C,KAAA,CAAKgD,uBAAA,GAA0B,IAAItB,iBAAA,CAAkBL,IAAA,EAAMG,IAAI;IAC1DxB,KAAA,CAAAgD,uBAAA,CAAwBrB,OAAA,CAAQC,IAAA,GAAO;IACvC5B,KAAA,CAAAgD,uBAAA,CAAwBrB,OAAA,CAAQE,eAAA,GAAkB;IACvD7B,KAAA,CAAKiD,uBAAA,GAA0B,IAAIvB,iBAAA,CAAkBJ,IAAA,CAAKC,KAAA,CAAMF,IAAA,GAAO,CAAC,GAAGC,IAAA,CAAKC,KAAA,CAAMC,IAAA,GAAO,CAAC,CAAC;IAC1FxB,KAAA,CAAAiD,uBAAA,CAAwBtB,OAAA,CAAQC,IAAA,GAAO;IACvC5B,KAAA,CAAAiD,uBAAA,CAAwBtB,OAAA,CAAQE,eAAA,GAAkB;IAEvD,IAAMqB,kBAAA,GAAqB;IAC3B,IAAMC,aAAA,GAAgB;IAEjBnD,KAAA,CAAAoD,sBAAA,GAAyBpD,KAAA,CAAKqD,wBAAA,CAAyBH,kBAAkB;IAC9ElD,KAAA,CAAKoD,sBAAA,CAAuBE,QAAA,CAAS,SAAS,EAAEC,KAAA,CAAMC,GAAA,CAAInC,IAAA,EAAMG,IAAI;IACpExB,KAAA,CAAKoD,sBAAA,CAAuBE,QAAA,CAAS,cAAc,EAAEC,KAAA,GAAQ;IACxDvD,KAAA,CAAAyD,sBAAA,GAAyBzD,KAAA,CAAKqD,wBAAA,CAAyBF,aAAa;IACzEnD,KAAA,CAAKyD,sBAAA,CAAuBH,QAAA,CAAS,SAAS,EAAEC,KAAA,CAAMC,GAAA,CAAIlC,IAAA,CAAKC,KAAA,CAAMF,IAAA,GAAO,CAAC,GAAGC,IAAA,CAAKC,KAAA,CAAMC,IAAA,GAAO,CAAC,CAAC;IACpGxB,KAAA,CAAKyD,sBAAA,CAAuBH,QAAA,CAAS,cAAc,EAAEC,KAAA,GAAQJ,aAAA;IAGxDnD,KAAA,CAAA0D,eAAA,GAAkB1D,KAAA,CAAK2D,kBAAA;IAG5B,IAAIC,UAAA,KAAe,QAAWC,OAAA,CAAQC,KAAA,CAAM,wCAAwC;IAEpF,IAAMC,UAAA,GAAaH,UAAA;IAEnB5D,KAAA,CAAKgE,YAAA,GAAeC,aAAA,CAAcC,KAAA,CAAMH,UAAA,CAAWT,QAAQ;IACtDtD,KAAA,CAAAgE,YAAA,CAAa,SAAS,EAAET,KAAA,GAAQ;IAEhCvD,KAAA,CAAAmE,YAAA,GAAe,IAAIC,cAAA,CAAe;MACrCd,QAAA,EAAUtD,KAAA,CAAKgE,YAAA;MACfK,YAAA,EAAcN,UAAA,CAAWM,YAAA;MACzB7B,cAAA,EAAgBuB,UAAA,CAAWvB,cAAA;MAC3BJ,QAAA,EAAUC,UAAA;MACViC,SAAA,EAAW;MACXC,UAAA,EAAY;MACZC,WAAA,EAAa;IAAA,CACd;IAEDxE,KAAA,CAAKyE,OAAA,GAAU;IACfzE,KAAA,CAAK0E,SAAA,GAAY;IAEZ1E,KAAA,CAAA2E,cAAA,GAAiB,IAAIlE,KAAA;IAC1BT,KAAA,CAAK4E,aAAA,GAAgB;IAErB5E,KAAA,CAAK6E,MAAA,GAAS,IAAIC,cAAA,CAAe9E,KAAA,CAAKmE,YAAY;IAE7CnE,KAAA,CAAA+E,eAAA,GAAkB,IAAItE,KAAA;IACtBT,KAAA,CAAAgF,eAAA,GAAkB,IAAIvE,KAAA;IACtBT,KAAA,CAAAiF,aAAA,GAAgB,IAAIC,OAAA;IAEhB,SAAAzC,oBAAoB0C,MAAA,EAAgBC,OAAA,EAAmC;MACxE,IAAAC,IAAA,GAAOD,OAAA,CAAOE,mBAAA,GAAsB,gBAAgB;MAE1D,OAAOH,MAAA,CAAOI,OAAA,CAAQ,oBAAoBF,IAAA,GAAO,cAAc;IACjE;IAAA,OAAArF,KAAA;EACF;EAAAwF,YAAA,CAAAjG,WAAA;IAAAkG,GAAA;IAAAlC,KAAA,EAEO,SAAAmC,QAAA,EAAgB;MACrB,KAAKjE,sBAAA,CAAuBiE,OAAA;MAC5B,KAAKhD,uBAAA,CAAwBgD,OAAA;MAC7B,KAAK/C,gCAAA,CAAiC+C,OAAA;MACtC,KAAK9C,uBAAA,CAAwB8C,OAAA;MAC7B,KAAK7C,uBAAA,CAAwB6C,OAAA;MAC7B,KAAK1C,uBAAA,CAAwB0C,OAAA;MAC7B,KAAKzC,uBAAA,CAAwByC,OAAA;IAC/B;EAAA;IAAAD,GAAA;IAAAlC,KAAA,EAEO,SAAAoC,QAAQC,KAAA,EAAeC,MAAA,EAAsB;MAC7C,KAAApE,sBAAA,CAAuBkE,OAAA,CAAQC,KAAA,EAAOC,MAAM;MAC5C,KAAAnD,uBAAA,CAAwBiD,OAAA,CAAQC,KAAA,EAAOC,MAAM;MAElD,IAAIxE,IAAA,GAAOC,IAAA,CAAKC,KAAA,CAAMqE,KAAA,GAAQ,KAAK7E,eAAe;MAClD,IAAIS,IAAA,GAAOF,IAAA,CAAKC,KAAA,CAAMsE,MAAA,GAAS,KAAK9E,eAAe;MAC9C,KAAA4B,gCAAA,CAAiCgD,OAAA,CAAQtE,IAAA,EAAMG,IAAI;MACnD,KAAAoB,uBAAA,CAAwB+C,OAAA,CAAQtE,IAAA,EAAMG,IAAI;MAC1C,KAAAwB,uBAAA,CAAwB2C,OAAA,CAAQtE,IAAA,EAAMG,IAAI;MAC/C,KAAK4B,sBAAA,CAAuBE,QAAA,CAAS,SAAS,EAAEC,KAAA,CAAMC,GAAA,CAAInC,IAAA,EAAMG,IAAI;MAE7DH,IAAA,GAAAC,IAAA,CAAKC,KAAA,CAAMF,IAAA,GAAO,CAAC;MACnBG,IAAA,GAAAF,IAAA,CAAKC,KAAA,CAAMC,IAAA,GAAO,CAAC;MAErB,KAAAqB,uBAAA,CAAwB8C,OAAA,CAAQtE,IAAA,EAAMG,IAAI;MAC1C,KAAAyB,uBAAA,CAAwB0C,OAAA,CAAQtE,IAAA,EAAMG,IAAI;MAE/C,KAAKiC,sBAAA,CAAuBH,QAAA,CAAS,SAAS,EAAEC,KAAA,CAAMC,GAAA,CAAInC,IAAA,EAAMG,IAAI;IACtE;EAAA;IAAAiE,GAAA;IAAAlC,KAAA,EAEO,SAAAuC,kCAAkCC,QAAA,EAAyB;MAChE,IAAMC,KAAA,GAAQ,KAAK/E,gBAAA;MAEnB,SAASgF,6BAA6BC,MAAA,EAAwB;QAC5D,IAAKA,MAAA,CAAgBC,MAAA,EAAQ;UAC3B,IAAIJ,QAAA,KAAa,MAAM;YACdG,MAAA,CAAAE,OAAA,GAAUJ,KAAA,CAAMK,GAAA,CAAIH,MAAM;UAAA,OAC5B;YACCF,KAAA,CAAAxC,GAAA,CAAI0C,MAAA,EAAQA,MAAA,CAAOE,OAAO;YAChCF,MAAA,CAAOE,OAAA,GAAUL,QAAA;UACnB;QACF;MACF;MAEA,SAASO,CAAA,GAAI,GAAGA,CAAA,GAAI,KAAKvG,eAAA,CAAgBwG,MAAA,EAAQD,CAAA,IAAK;QAC9C,IAAAE,cAAA,GAAiB,KAAKzG,eAAA,CAAgBuG,CAAC;QAC7CE,cAAA,CAAeC,QAAA,CAASR,4BAA4B;MACtD;IACF;EAAA;IAAAR,GAAA;IAAAlC,KAAA,EAEO,SAAAmD,qCAAqCX,QAAA,EAAyB;MACnE,IAAMC,KAAA,GAAQ,KAAK/E,gBAAA;MACnB,IAAM0F,cAAA,GAA6B;MAEnC,SAASV,6BAA6BC,MAAA,EAAwB;QAC5D,IAAKA,MAAA,CAAgBC,MAAA,EAAQQ,cAAA,CAAeC,IAAA,CAAKV,MAAM;MACzD;MAEA,SAASI,CAAA,GAAI,GAAGA,CAAA,GAAI,KAAKvG,eAAA,CAAgBwG,MAAA,EAAQD,CAAA,IAAK;QAC9C,IAAAE,cAAA,GAAiB,KAAKzG,eAAA,CAAgBuG,CAAC;QAC7CE,cAAA,CAAeC,QAAA,CAASR,4BAA4B;MACtD;MAEA,SAASY,yBAAyBX,MAAA,EAAwB;QACnD,IAAAA,MAAA,CAAgBC,MAAA,IAAWD,MAAA,CAAkBY,QAAA,EAAU;UAG1D,IAAIC,MAAA,GAAS;UAEb,SAAST,EAAA,GAAI,GAAGA,EAAA,GAAIK,cAAA,CAAeJ,MAAA,EAAQD,EAAA,IAAK;YACxC,IAAAU,gBAAA,GAAmBL,cAAA,CAAeL,EAAC,EAAEW,EAAA;YAEvC,IAAAD,gBAAA,KAAqBd,MAAA,CAAOe,EAAA,EAAI;cACzBF,MAAA;cACT;YACF;UACF;UAEA,IAAIA,MAAA,KAAW,OAAO;YACpB,IAAMG,UAAA,GAAahB,MAAA,CAAOE,OAAA;YAE1B,IAAIL,QAAA,KAAa,SAASC,KAAA,CAAMK,GAAA,CAAIH,MAAM,MAAM,MAAM;cACpDA,MAAA,CAAOE,OAAA,GAAUL,QAAA;YACnB;YAEMC,KAAA,CAAAxC,GAAA,CAAI0C,MAAA,EAAQgB,UAAU;UAC9B;QACU,WAAAhB,MAAA,CAAkBiB,QAAA,IAAajB,MAAA,CAAgBkB,MAAA,EAAQ;UAIjE,IAAIrB,QAAA,KAAa,MAAM;YACdG,MAAA,CAAAE,OAAA,GAAUJ,KAAA,CAAMK,GAAA,CAAIH,MAAM;UAAA,OAC5B;YACCF,KAAA,CAAAxC,GAAA,CAAI0C,MAAA,EAAQA,MAAA,CAAOE,OAAO;YAChCF,MAAA,CAAOE,OAAA,GAAUL,QAAA;UACnB;QACF;MACF;MAEK,KAAAzF,WAAA,CAAYmG,QAAA,CAASI,wBAAwB;IACpD;EAAA;IAAApB,GAAA;IAAAlC,KAAA,EAEO,SAAA8D,oBAAA,EAA4B;MACjC,KAAKpC,aAAA,CAAczB,GAAA,CAAI,KAAK,GAAK,GAAK,KAAK,GAAK,KAAK,GAAK,KAAK,GAAK,GAAK,KAAK,KAAK,GAAK,GAAK,GAAK,CAAG;MACrG,KAAKyB,aAAA,CAAcqC,QAAA,CAAS,KAAK/G,YAAA,CAAagH,gBAAgB;MAC9D,KAAKtC,aAAA,CAAcqC,QAAA,CAAS,KAAK/G,YAAA,CAAaiH,kBAAkB;IAClE;EAAA;IAAA/B,GAAA;IAAAlC,KAAA,EAEO,SAAAkE,OACLC,QAAA,EACAC,WAAA,EACAC,UAAA,EACAC,SAAA,EACAC,UAAA,EACM;MACF,SAAK/H,eAAA,CAAgBwG,MAAA,GAAS,GAAG;QAC1BmB,QAAA,CAAAK,aAAA,CAAc,KAAKpD,cAAc;QACrC,KAAAC,aAAA,GAAgB8C,QAAA,CAASM,aAAA;QAC9B,IAAMC,YAAA,GAAeP,QAAA,CAASQ,SAAA;QAE9BR,QAAA,CAASQ,SAAA,GAAY;QAEjB,IAAAJ,UAAA,EAAYJ,QAAA,CAASS,KAAA,CAAMC,OAAA,CAAQC,OAAA,CAAQC,OAAA,CAAQ,KAAK;QAEnDZ,QAAA,CAAAa,aAAA,CAAc,UAAU,CAAC;QAGlC,KAAKzC,iCAAA,CAAkC,KAAK;QAEtC,IAAA0C,iBAAA,GAAoB,KAAKlI,WAAA,CAAYmI,UAAA;QAC3C,KAAKnI,WAAA,CAAYmI,UAAA,GAAa;QAGzB,KAAAnI,WAAA,CAAYoI,gBAAA,GAAmB,KAAK5G,aAAA;QAChC4F,QAAA,CAAAiB,eAAA,CAAgB,KAAKjG,uBAAuB;QACrDgF,QAAA,CAASkB,KAAA,CAAM;QACflB,QAAA,CAASD,MAAA,CAAO,KAAKnH,WAAA,EAAa,KAAKC,YAAY;QAGnD,KAAKuF,iCAAA,CAAkC,IAAI;QAC3C,KAAK7E,gBAAA,CAAiB2H,KAAA;QAGtB,KAAKvB,mBAAA,CAAoB;QAGzB,KAAKX,oCAAA,CAAqC,KAAK;QAC1C,KAAApG,WAAA,CAAYoI,gBAAA,GAAmB,KAAKpG,mBAAA;QACzC,KAAKA,mBAAA,CAAoBgB,QAAA,CAAS,eAAe,EAAEC,KAAA,CAAMC,GAAA,CACtD,KAAKjD,YAAA,CAAmCsI,IAAA,EACxC,KAAKtI,YAAA,CAAmCuI,GAAA;QAE3C,KAAKxG,mBAAA,CAAoBgB,QAAA,CAAS,cAAc,EAAEC,KAAA,GAAQ,KAAKb,uBAAA,CAAwBf,OAAA;QACvF,KAAKW,mBAAA,CAAoBgB,QAAA,CAAS,eAAe,EAAEC,KAAA,GAAQ,KAAK0B,aAAA;QACvDyC,QAAA,CAAAiB,eAAA,CAAgB,KAAKlH,sBAAsB;QACpDiG,QAAA,CAASkB,KAAA,CAAM;QACflB,QAAA,CAASD,MAAA,CAAO,KAAKnH,WAAA,EAAa,KAAKC,YAAY;QACnD,KAAKD,WAAA,CAAYoI,gBAAA,GAAmB;QACpC,KAAKhC,oCAAA,CAAqC,IAAI;QAC9C,KAAKzF,gBAAA,CAAiB2H,KAAA;QAEtB,KAAKtI,WAAA,CAAYmI,UAAA,GAAaD,iBAAA;QAGzB,KAAA3D,MAAA,CAAOkE,QAAA,GAAW,KAAK5E,YAAA;QAC5B,KAAKH,YAAA,CAAa,UAAU,EAAET,KAAA,GAAQ,KAAK9B,sBAAA,CAAuBE,OAAA;QACzD+F,QAAA,CAAAiB,eAAA,CAAgB,KAAKhG,gCAAgC;QAC9D+E,QAAA,CAASkB,KAAA,CAAM;QACV,KAAA/D,MAAA,CAAO4C,MAAA,CAAOC,QAAQ;QAEtB,KAAA3C,eAAA,CAAgBiE,IAAA,CAAK,KAAKxI,gBAAgB;QAC1C,KAAAwE,eAAA,CAAgBgE,IAAA,CAAK,KAAKtI,eAAe;QAE1C,SAAKM,WAAA,GAAc,GAAG;UACxB,IAAMiI,MAAA,IAAU,IAAI,QAAQ,IAAK3H,IAAA,CAAK4H,GAAA,CAAKC,WAAA,CAAYC,GAAA,CAAI,IAAI,OAAQ,KAAKpI,WAAW,KAAK,IAAM,QAAS;UACtG,KAAA+D,eAAA,CAAgBsE,cAAA,CAAeJ,MAAM;UACrC,KAAAjE,eAAA,CAAgBqE,cAAA,CAAeJ,MAAM;QAC5C;QAGK,KAAApE,MAAA,CAAOkE,QAAA,GAAW,KAAKjG,qBAAA;QAC5B,KAAKA,qBAAA,CAAsBQ,QAAA,CAAS,aAAa,EAAEC,KAAA,GAAQ,KAAKZ,gCAAA,CAAiChB,OAAA;QACjG,KAAKmB,qBAAA,CAAsBQ,QAAA,CAAS,SAAS,EAAEC,KAAA,CAAMC,GAAA,CACnD,KAAKb,gCAAA,CAAiCiD,KAAA,EACtC,KAAKjD,gCAAA,CAAiCkD,MAAA;QAExC,KAAK/C,qBAAA,CAAsBQ,QAAA,CAAS,kBAAkB,EAAEC,KAAA,GAAQ,KAAKwB,eAAA;QACrE,KAAKjC,qBAAA,CAAsBQ,QAAA,CAAS,iBAAiB,EAAEC,KAAA,GAAQ,KAAKyB,eAAA;QAC3D0C,QAAA,CAAAiB,eAAA,CAAgB,KAAK3F,uBAAuB;QACrD0E,QAAA,CAASkB,KAAA,CAAM;QACV,KAAA/D,MAAA,CAAO4C,MAAA,CAAOC,QAAQ;QAGtB,KAAA7C,MAAA,CAAOkE,QAAA,GAAW,KAAK3F,sBAAA;QAC5B,KAAKA,sBAAA,CAAuBE,QAAA,CAAS,cAAc,EAAEC,KAAA,GAAQ,KAAKP,uBAAA,CAAwBrB,OAAA;QAC1F,KAAKyB,sBAAA,CAAuBE,QAAA,CAAS,WAAW,EAAEC,KAAA,GAAQ,KAAK+F,cAAA;QAC/D,KAAKlG,sBAAA,CAAuBE,QAAA,CAAS,cAAc,EAAEC,KAAA,GAAQ,KAAK1C,aAAA;QACzD6G,QAAA,CAAAiB,eAAA,CAAgB,KAAK/F,uBAAuB;QACrD8E,QAAA,CAASkB,KAAA,CAAM;QACV,KAAA/D,MAAA,CAAO4C,MAAA,CAAOC,QAAQ;QAC3B,KAAKtE,sBAAA,CAAuBE,QAAA,CAAS,cAAc,EAAEC,KAAA,GAAQ,KAAKX,uBAAA,CAAwBjB,OAAA;QAC1F,KAAKyB,sBAAA,CAAuBE,QAAA,CAAS,WAAW,EAAEC,KAAA,GAAQ,KAAKgG,cAAA;QACtD7B,QAAA,CAAAiB,eAAA,CAAgB,KAAK3F,uBAAuB;QACrD0E,QAAA,CAASkB,KAAA,CAAM;QACV,KAAA/D,MAAA,CAAO4C,MAAA,CAAOC,QAAQ;QAGtB,KAAA7C,MAAA,CAAOkE,QAAA,GAAW,KAAKtF,sBAAA;QAC5B,KAAKA,sBAAA,CAAuBH,QAAA,CAAS,cAAc,EAAEC,KAAA,GAAQ,KAAKP,uBAAA,CAAwBrB,OAAA;QAC1F,KAAK8B,sBAAA,CAAuBH,QAAA,CAAS,WAAW,EAAEC,KAAA,GAAQ,KAAK+F,cAAA;QACtD5B,QAAA,CAAAiB,eAAA,CAAgB,KAAK9F,uBAAuB;QACrD6E,QAAA,CAASkB,KAAA,CAAM;QACV,KAAA/D,MAAA,CAAO4C,MAAA,CAAOC,QAAQ;QAC3B,KAAKjE,sBAAA,CAAuBH,QAAA,CAAS,cAAc,EAAEC,KAAA,GAAQ,KAAKV,uBAAA,CAAwBlB,OAAA;QAC1F,KAAK8B,sBAAA,CAAuBH,QAAA,CAAS,WAAW,EAAEC,KAAA,GAAQ,KAAKgG,cAAA;QACtD7B,QAAA,CAAAiB,eAAA,CAAgB,KAAK1F,uBAAuB;QACrDyE,QAAA,CAASkB,KAAA,CAAM;QACV,KAAA/D,MAAA,CAAO4C,MAAA,CAAOC,QAAQ;QAGtB,KAAA7C,MAAA,CAAOkE,QAAA,GAAW,KAAKrF,eAAA;QAC5B,KAAKA,eAAA,CAAgBJ,QAAA,CAAS,aAAa,EAAEC,KAAA,GAAQ,KAAK9B,sBAAA,CAAuBE,OAAA;QACjF,KAAK+B,eAAA,CAAgBJ,QAAA,CAAS,cAAc,EAAEC,KAAA,GAAQ,KAAKP,uBAAA,CAAwBrB,OAAA;QACnF,KAAK+B,eAAA,CAAgBJ,QAAA,CAAS,cAAc,EAAEC,KAAA,GAAQ,KAAKN,uBAAA,CAAwBtB,OAAA;QACnF,KAAK+B,eAAA,CAAgBJ,QAAA,CAAS,gBAAgB,EAAEC,KAAA,GAAQ,KAAKiG,cAAA;QAC7D,KAAK9F,eAAA,CAAgBJ,QAAA,CAAS,cAAc,EAAEC,KAAA,GAAQ,KAAKzC,YAAA;QAC3D,KAAK4C,eAAA,CAAgBJ,QAAA,CAAS,UAAU,EAAEC,KAAA,GAAQ,KAAK5C,QAAA;QACvD,KAAK+C,eAAA,CAAgBJ,QAAA,CAAS,mBAAmB,EAAEC,KAAA,GAAQ,KAAK3C,iBAAA;QAE5D,IAAAkH,UAAA,EAAYJ,QAAA,CAASS,KAAA,CAAMC,OAAA,CAAQC,OAAA,CAAQC,OAAA,CAAQ,IAAI;QAE3DZ,QAAA,CAASiB,eAAA,CAAgBf,UAAU;QAC9B,KAAA/C,MAAA,CAAO4C,MAAA,CAAOC,QAAQ;QAE3BA,QAAA,CAASa,aAAA,CAAc,KAAK5D,cAAA,EAAgB,KAAKC,aAAa;QAC9D8C,QAAA,CAASQ,SAAA,GAAYD,YAAA;MACvB;MAEA,IAAI,KAAKwB,cAAA,EAAgB;QAClB,KAAA5E,MAAA,CAAOkE,QAAA,GAAW,KAAK5E,YAAA;QAC5B,KAAKH,YAAA,CAAa,UAAU,EAAET,KAAA,GAAQqE,UAAA,CAAWjG,OAAA;QACjD+F,QAAA,CAASiB,eAAA,CAAgB,IAAI;QACxB,KAAA9D,MAAA,CAAO4C,MAAA,CAAOC,QAAQ;MAC7B;IACF;EAAA;IAAAjC,GAAA;IAAAlC,KAAA,EAEO,SAAAhB,uBAAA,EAAyC;MAC9C,OAAO,IAAI6B,cAAA,CAAe;QACxBd,QAAA,EAAU;UACRoG,YAAA,EAAc;YAAEnG,KAAA,EAAO;UAAK;UAC5BoG,aAAA,EAAe;YAAEpG,KAAA,EAAO,IAAIlD,OAAA,CAAQ,KAAK,GAAG;UAAE;UAC9C4E,aAAA,EAAe;YAAE1B,KAAA,EAAO;UAAK;QAC/B;QAEAc,YAAA,4jBAAc;QAgBd7B,cAAA;MAAgB,CAWjB;IACH;EAAA;IAAAiD,GAAA;IAAAlC,KAAA,EAEO,SAAAR,yBAAA,EAA2C;MAChD,OAAO,IAAIqB,cAAA,CAAe;QACxBd,QAAA,EAAU;UACRsG,WAAA,EAAa;YAAErG,KAAA,EAAO;UAAK;UAC3BsG,OAAA,EAAS;YAAEtG,KAAA,EAAO,IAAIlD,OAAA,CAAQ,KAAK,GAAG;UAAE;UACxCG,gBAAA,EAAkB;YAAE+C,KAAA,EAAO,IAAIuG,OAAA,CAAQ,GAAK,GAAK,CAAG;UAAE;UACtDpJ,eAAA,EAAiB;YAAE6C,KAAA,EAAO,IAAIuG,OAAA,CAAQ,GAAK,GAAK,CAAG;UAAE;QACvD;QAEAzF,YAAA,iKAAc;QAMd7B,cAAA;MAAgB,CAqBjB;IACH;EAAA;IAAAiD,GAAA;IAAAlC,KAAA,EAEO,SAAAF,yBAAyB0G,SAAA,EAAmC;MACjE,OAAO,IAAI3F,cAAA,CAAe;QACxB4F,OAAA,EAAS;UACPC,UAAA,EAAYF;QACd;QAEAzG,QAAA,EAAU;UACR4G,YAAA,EAAc;YAAE3G,KAAA,EAAO;UAAK;UAC5BsG,OAAA,EAAS;YAAEtG,KAAA,EAAO,IAAIlD,OAAA,CAAQ,KAAK,GAAG;UAAE;UACxC8J,SAAA,EAAW;YAAE5G,KAAA,EAAO,IAAIlD,OAAA,CAAQ,KAAK,GAAG;UAAE;UAC1C+J,YAAA,EAAc;YAAE7G,KAAA,EAAO;UAAI;QAC7B;QAEAc,YAAA,iKAAc;QAMd7B,cAAA;MAAgB,CAyBjB;IACH;EAAA;IAAAiD,GAAA;IAAAlC,KAAA,EAEO,SAAAI,mBAAA,EAAqC;MAC1C,OAAO,IAAIS,cAAA,CAAe;QACxBd,QAAA,EAAU;UACRsG,WAAA,EAAa;YAAErG,KAAA,EAAO;UAAK;UAC3B8G,YAAA,EAAc;YAAE9G,KAAA,EAAO;UAAK;UAC5B+G,YAAA,EAAc;YAAE/G,KAAA,EAAO;UAAK;UAC5BiG,cAAA,EAAgB;YAAEjG,KAAA,EAAO;UAAK;UAC9BzC,YAAA,EAAc;YAAEyC,KAAA,EAAO;UAAI;UAC3B5C,QAAA,EAAU;YAAE4C,KAAA,EAAO;UAAI;UACvB3C,iBAAA,EAAmB;YAAE2C,KAAA,EAAO;UAAI;QAClC;QAEAc,YAAA,iKAAc;QAMd7B,cAAA,k7BAAgB;QAoBhBJ,QAAA,EAAUmI,gBAAA;QACVjG,SAAA,EAAW;QACXC,UAAA,EAAY;QACZC,WAAA,EAAa;MAAA,CACd;IACH;EAAA;EAAA,OAAAjF,WAAA;AAAA,EAvjBwBiL,IAAA"},"metadata":{},"sourceType":"module","externalDependencies":[]}