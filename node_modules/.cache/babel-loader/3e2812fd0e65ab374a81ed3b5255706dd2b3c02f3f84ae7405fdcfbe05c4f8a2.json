{"ast":null,"code":"import _classCallCheck from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = function __defNormalProp(obj, key, value) {\n  return key in obj ? __defProp(obj, key, {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: value\n  }) : obj[key] = value;\n};\nvar __publicField = function __publicField(obj, key, value) {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nimport { Vector3 } from \"three\";\nvar isMesh = function isMesh(object) {\n  return object.isMesh;\n};\nvar STLExporter = /*#__PURE__*/function () {\n  function STLExporter() {\n    _classCallCheck(this, STLExporter);\n    __publicField(this, \"binary\", false);\n    __publicField(this, \"output\", \"\");\n    __publicField(this, \"offset\", 80);\n    // skip header\n    __publicField(this, \"objects\", []);\n    __publicField(this, \"triangles\", 0);\n    __publicField(this, \"vA\", new Vector3());\n    __publicField(this, \"vB\", new Vector3());\n    __publicField(this, \"vC\", new Vector3());\n    __publicField(this, \"cb\", new Vector3());\n    __publicField(this, \"ab\", new Vector3());\n    __publicField(this, \"normal\", new Vector3());\n  }\n  _createClass(STLExporter, [{\n    key: \"parse\",\n    value: function parse(scene, options) {\n      var _this = this;\n      this.binary = (options == null ? void 0 : options.binary) !== void 0 ? options == null ? void 0 : options.binary : false;\n      scene.traverse(function (object) {\n        if (isMesh(object)) {\n          var geometry = object.geometry;\n          if (!geometry.isBufferGeometry) {\n            throw new Error(\"THREE.STLExporter: Geometry is not of type THREE.BufferGeometry.\");\n          }\n          var index = geometry.index;\n          var positionAttribute = geometry.getAttribute(\"position\") || null;\n          if (!positionAttribute) return;\n          _this.triangles += index !== null ? index.count / 3 : positionAttribute.count / 3;\n          _this.objects.push({\n            object3d: object,\n            geometry: geometry\n          });\n        }\n      });\n      if (this.binary) {\n        var bufferLength = this.triangles * 2 + this.triangles * 3 * 4 * 4 + 80 + 4;\n        var arrayBuffer = new ArrayBuffer(bufferLength);\n        this.output = new DataView(arrayBuffer);\n        this.output.setUint32(this.offset, this.triangles, true);\n        this.offset += 4;\n      } else {\n        this.output = \"\";\n        this.output += \"solid exported\\n\";\n      }\n      for (var i = 0, il = this.objects.length; i < il; i++) {\n        var object = this.objects[i].object3d;\n        var geometry = this.objects[i].geometry;\n        var index = geometry.index;\n        var positionAttribute = geometry.getAttribute(\"position\");\n        if (index !== null) {\n          for (var j = 0; j < index.count; j += 3) {\n            var a = index.getX(j + 0);\n            var b = index.getX(j + 1);\n            var c = index.getX(j + 2);\n            this.writeFace(a, b, c, positionAttribute, object);\n          }\n        } else {\n          for (var _j = 0; _j < positionAttribute.count; _j += 3) {\n            var _a = _j + 0;\n            var _b = _j + 1;\n            var _c = _j + 2;\n            this.writeFace(_a, _b, _c, positionAttribute, object);\n          }\n        }\n      }\n      if (!this.binary) {\n        this.output += \"endsolid exported\\n\";\n      }\n      return this.output;\n    }\n  }, {\n    key: \"writeFace\",\n    value: function writeFace(a, b, c, positionAttribute, object) {\n      this.vA.fromBufferAttribute(positionAttribute, a);\n      this.vB.fromBufferAttribute(positionAttribute, b);\n      this.vC.fromBufferAttribute(positionAttribute, c);\n      if (object.isSkinnedMesh) {\n        var mesh = object;\n        if (\"applyBoneTransform\" in mesh) {\n          mesh.applyBoneTransform(a, this.vA);\n          mesh.applyBoneTransform(b, this.vB);\n          mesh.applyBoneTransform(c, this.vC);\n        } else {\n          mesh.boneTransform(a, this.vA);\n          mesh.boneTransform(b, this.vB);\n          mesh.boneTransform(c, this.vC);\n        }\n      }\n      this.vA.applyMatrix4(object.matrixWorld);\n      this.vB.applyMatrix4(object.matrixWorld);\n      this.vC.applyMatrix4(object.matrixWorld);\n      this.writeNormal(this.vA, this.vB, this.vC);\n      this.writeVertex(this.vA);\n      this.writeVertex(this.vB);\n      this.writeVertex(this.vC);\n      if (this.binary && this.output instanceof DataView) {\n        this.output.setUint16(this.offset, 0, true);\n        this.offset += 2;\n      } else {\n        this.output += \"\t\tendloop\\n\";\n        this.output += \"\tendfacet\\n\";\n      }\n    }\n  }, {\n    key: \"writeNormal\",\n    value: function writeNormal(vA, vB, vC) {\n      this.cb.subVectors(vC, vB);\n      this.ab.subVectors(vA, vB);\n      this.cb.cross(this.ab).normalize();\n      this.normal.copy(this.cb).normalize();\n      if (this.binary && this.output instanceof DataView) {\n        this.output.setFloat32(this.offset, this.normal.x, true);\n        this.offset += 4;\n        this.output.setFloat32(this.offset, this.normal.y, true);\n        this.offset += 4;\n        this.output.setFloat32(this.offset, this.normal.z, true);\n        this.offset += 4;\n      } else {\n        this.output += \"\\tfacet normal \".concat(this.normal.x, \" \").concat(this.normal.y, \" \").concat(this.normal.z, \"\\n\");\n        this.output += \"\t\touter loop\\n\";\n      }\n    }\n  }, {\n    key: \"writeVertex\",\n    value: function writeVertex(vertex) {\n      if (this.binary && this.output instanceof DataView) {\n        this.output.setFloat32(this.offset, vertex.x, true);\n        this.offset += 4;\n        this.output.setFloat32(this.offset, vertex.y, true);\n        this.offset += 4;\n        this.output.setFloat32(this.offset, vertex.z, true);\n        this.offset += 4;\n      } else {\n        this.output += \"\\t\\t\\tvertex \".concat(vertex.x, \" \").concat(vertex.y, \" \").concat(vertex.z, \"\\n\");\n      }\n    }\n  }]);\n  return STLExporter;\n}();\nexport { STLExporter };","map":{"version":3,"names":["isMesh","object","STLExporter","_classCallCheck","__publicField","Vector3","parse","scene","options","_this","binary","traverse","geometry","isBufferGeometry","Error","index","positionAttribute","getAttribute","triangles","count","objects","push","object3d","bufferLength","arrayBuffer","ArrayBuffer","output","DataView","setUint32","offset","i","il","length","j","a","getX","b","c","writeFace","key","value","vA","fromBufferAttribute","vB","vC","isSkinnedMesh","mesh","applyBoneTransform","boneTransform","applyMatrix4","matrixWorld","writeNormal","writeVertex","setUint16","cb","subVectors","ab","cross","normalize","normal","copy","setFloat32","x","y","z","concat","vertex"],"sources":["C:\\Users\\Nayyu\\Desktop\\skibidai-public-build\\node_modules\\src\\exporters\\STLExporter.ts"],"sourcesContent":["import {\n  BufferAttribute,\n  BufferGeometry,\n  InterleavedBufferAttribute,\n  Mesh,\n  Object3D,\n  SkinnedMesh,\n  Vector3,\n} from 'three'\n\nexport interface STLExporterOptionsBinary {\n  binary: true\n}\n\nexport interface STLExporterOptionsString {\n  binary?: false\n}\n\nexport interface STLExporterOptions {\n  binary?: boolean\n}\n\nconst isMesh = (object: unknown): object is Mesh => (object as any).isMesh\n\nexport class STLExporter {\n  private binary = false\n\n  private output: string | DataView = ''\n  private offset: number = 80 // skip header\n\n  private objects: { object3d: Object3D; geometry: BufferGeometry }[] = []\n  private triangles: number = 0\n\n  private vA = new Vector3()\n  private vB = new Vector3()\n  private vC = new Vector3()\n  private cb = new Vector3()\n  private ab = new Vector3()\n  private normal = new Vector3()\n\n  parse(scene: Object3D, options: STLExporterOptionsBinary): DataView\n  parse(scene: Object3D, options?: STLExporterOptionsString): string\n  parse(scene: Object3D, options?: STLExporterOptions): string | DataView {\n    this.binary = options?.binary !== undefined ? options?.binary : false\n\n    scene.traverse((object: Object3D) => {\n      if (isMesh(object)) {\n        const geometry = object.geometry\n\n        if (!geometry.isBufferGeometry) {\n          throw new Error('THREE.STLExporter: Geometry is not of type THREE.BufferGeometry.')\n        }\n\n        const index = geometry.index\n        const positionAttribute = geometry.getAttribute('position') || null\n        if (!positionAttribute) return\n\n        this.triangles += index !== null ? index.count / 3 : positionAttribute.count / 3\n\n        this.objects.push({\n          object3d: object,\n          geometry: geometry,\n        })\n      }\n    })\n\n    if (this.binary) {\n      const bufferLength = this.triangles * 2 + this.triangles * 3 * 4 * 4 + 80 + 4\n      const arrayBuffer = new ArrayBuffer(bufferLength)\n      this.output = new DataView(arrayBuffer)\n      this.output.setUint32(this.offset, this.triangles, true)\n      this.offset += 4\n    } else {\n      this.output = ''\n      this.output += 'solid exported\\n'\n    }\n\n    for (let i = 0, il = this.objects.length; i < il; i++) {\n      const object = this.objects[i].object3d\n      const geometry = this.objects[i].geometry\n\n      const index = geometry.index\n      const positionAttribute = geometry.getAttribute('position')\n\n      if (index !== null) {\n        // indexed geometry\n        for (let j = 0; j < index.count; j += 3) {\n          const a = index.getX(j + 0)\n          const b = index.getX(j + 1)\n          const c = index.getX(j + 2)\n\n          this.writeFace(a, b, c, positionAttribute, object as SkinnedMesh)\n        }\n      } else {\n        // non-indexed geometry\n        for (let j = 0; j < positionAttribute.count; j += 3) {\n          const a = j + 0\n          const b = j + 1\n          const c = j + 2\n\n          this.writeFace(a, b, c, positionAttribute, object as SkinnedMesh)\n        }\n      }\n    }\n\n    if (!this.binary) {\n      this.output += 'endsolid exported\\n'\n    }\n\n    return this.output\n  }\n\n  private writeFace(\n    a: number,\n    b: number,\n    c: number,\n    positionAttribute: BufferAttribute | InterleavedBufferAttribute,\n    object: SkinnedMesh,\n  ): void {\n    this.vA.fromBufferAttribute(positionAttribute, a)\n    this.vB.fromBufferAttribute(positionAttribute, b)\n    this.vC.fromBufferAttribute(positionAttribute, c)\n\n    if (object.isSkinnedMesh) {\n      const mesh = object as Omit<SkinnedMesh, 'boneTransform' | 'applyBoneTransform'> &\n        (\n          | {\n              boneTransform(index: number, vector: Vector3): Vector3\n            }\n          | {\n              applyBoneTransform(index: number, vector: Vector3): Vector3\n            }\n        )\n\n      // r151 https://github.com/mrdoob/three.js/pull/25586\n      if ('applyBoneTransform' in mesh) {\n        mesh.applyBoneTransform(a, this.vA)\n        mesh.applyBoneTransform(b, this.vB)\n        mesh.applyBoneTransform(c, this.vC)\n      } else {\n        mesh.boneTransform(a, this.vA)\n        mesh.boneTransform(b, this.vB)\n        mesh.boneTransform(c, this.vC)\n      }\n    }\n\n    this.vA.applyMatrix4(object.matrixWorld)\n    this.vB.applyMatrix4(object.matrixWorld)\n    this.vC.applyMatrix4(object.matrixWorld)\n\n    this.writeNormal(this.vA, this.vB, this.vC)\n\n    this.writeVertex(this.vA)\n    this.writeVertex(this.vB)\n    this.writeVertex(this.vC)\n\n    if (this.binary && this.output instanceof DataView) {\n      this.output.setUint16(this.offset, 0, true)\n      this.offset += 2\n    } else {\n      this.output += '\\t\\tendloop\\n'\n      this.output += '\\tendfacet\\n'\n    }\n  }\n\n  private writeNormal(vA: Vector3, vB: Vector3, vC: Vector3): void {\n    this.cb.subVectors(vC, vB)\n    this.ab.subVectors(vA, vB)\n    this.cb.cross(this.ab).normalize()\n\n    this.normal.copy(this.cb).normalize()\n\n    if (this.binary && this.output instanceof DataView) {\n      this.output.setFloat32(this.offset, this.normal.x, true)\n      this.offset += 4\n      this.output.setFloat32(this.offset, this.normal.y, true)\n      this.offset += 4\n      this.output.setFloat32(this.offset, this.normal.z, true)\n      this.offset += 4\n    } else {\n      this.output += `\\tfacet normal ${this.normal.x} ${this.normal.y} ${this.normal.z}\\n`\n      this.output += '\\t\\touter loop\\n'\n    }\n  }\n\n  private writeVertex(vertex: Vector3): void {\n    if (this.binary && this.output instanceof DataView) {\n      this.output.setFloat32(this.offset, vertex.x, true)\n      this.offset += 4\n      this.output.setFloat32(this.offset, vertex.y, true)\n      this.offset += 4\n      this.output.setFloat32(this.offset, vertex.z, true)\n      this.offset += 4\n    } else {\n      this.output += `\\t\\t\\tvertex ${vertex.x} ${vertex.y} ${vertex.z}\\n`\n    }\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}