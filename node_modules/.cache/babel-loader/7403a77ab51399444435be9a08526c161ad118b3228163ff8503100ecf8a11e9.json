{"ast":null,"code":"import _classCallCheck from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _inherits from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport { Loader, FileLoader, Skeleton, Vector3, Quaternion, Bone, VectorKeyframeTrack, QuaternionKeyframeTrack, AnimationClip } from \"three\";\nvar BVHLoader = /*#__PURE__*/function (_Loader) {\n  _inherits(BVHLoader, _Loader);\n  var _super = _createSuper(BVHLoader);\n  function BVHLoader(manager) {\n    var _this;\n    _classCallCheck(this, BVHLoader);\n    _this = _super.call(this, manager);\n    _this.animateBonePositions = true;\n    _this.animateBoneRotations = true;\n    return _this;\n  }\n  _createClass(BVHLoader, [{\n    key: \"load\",\n    value: function load(url, onLoad, onProgress, onError) {\n      var scope = this;\n      var loader = new FileLoader(scope.manager);\n      loader.setPath(scope.path);\n      loader.setRequestHeader(scope.requestHeader);\n      loader.setWithCredentials(scope.withCredentials);\n      loader.load(url, function (text) {\n        try {\n          onLoad(scope.parse(text));\n        } catch (e) {\n          if (onError) {\n            onError(e);\n          } else {\n            console.error(e);\n          }\n          scope.manager.itemError(url);\n        }\n      }, onProgress, onError);\n    }\n  }, {\n    key: \"parse\",\n    value: function parse(text) {\n      function readBvh(lines2) {\n        if (nextLine(lines2) !== \"HIERARCHY\") {\n          console.error(\"THREE.BVHLoader: HIERARCHY expected.\");\n        }\n        var list = [];\n        var root = readNode(lines2, nextLine(lines2), list);\n        if (nextLine(lines2) !== \"MOTION\") {\n          console.error(\"THREE.BVHLoader: MOTION expected.\");\n        }\n        var tokens = nextLine(lines2).split(/[\\s]+/);\n        var numFrames = parseInt(tokens[1]);\n        if (isNaN(numFrames)) {\n          console.error(\"THREE.BVHLoader: Failed to read number of frames.\");\n        }\n        tokens = nextLine(lines2).split(/[\\s]+/);\n        var frameTime = parseFloat(tokens[2]);\n        if (isNaN(frameTime)) {\n          console.error(\"THREE.BVHLoader: Failed to read frame time.\");\n        }\n        for (var i = 0; i < numFrames; i++) {\n          tokens = nextLine(lines2).split(/[\\s]+/);\n          readFrameData(tokens, i * frameTime, root);\n        }\n        return list;\n      }\n      function readFrameData(data, frameTime, bone) {\n        if (bone.type === \"ENDSITE\") return;\n        var keyframe = {\n          time: frameTime,\n          position: new Vector3(),\n          rotation: new Quaternion()\n        };\n        bone.frames.push(keyframe);\n        var quat = new Quaternion();\n        var vx = new Vector3(1, 0, 0);\n        var vy = new Vector3(0, 1, 0);\n        var vz = new Vector3(0, 0, 1);\n        for (var i = 0; i < bone.channels.length; i++) {\n          switch (bone.channels[i]) {\n            case \"Xposition\":\n              keyframe.position.x = parseFloat(data.shift().trim());\n              break;\n            case \"Yposition\":\n              keyframe.position.y = parseFloat(data.shift().trim());\n              break;\n            case \"Zposition\":\n              keyframe.position.z = parseFloat(data.shift().trim());\n              break;\n            case \"Xrotation\":\n              quat.setFromAxisAngle(vx, parseFloat(data.shift().trim()) * Math.PI / 180);\n              keyframe.rotation.multiply(quat);\n              break;\n            case \"Yrotation\":\n              quat.setFromAxisAngle(vy, parseFloat(data.shift().trim()) * Math.PI / 180);\n              keyframe.rotation.multiply(quat);\n              break;\n            case \"Zrotation\":\n              quat.setFromAxisAngle(vz, parseFloat(data.shift().trim()) * Math.PI / 180);\n              keyframe.rotation.multiply(quat);\n              break;\n            default:\n              console.warn(\"THREE.BVHLoader: Invalid channel type.\");\n          }\n        }\n        for (var _i = 0; _i < bone.children.length; _i++) {\n          readFrameData(data, frameTime, bone.children[_i]);\n        }\n      }\n      function readNode(lines2, firstline, list) {\n        var node = {\n          name: \"\",\n          type: \"\",\n          frames: []\n        };\n        list.push(node);\n        var tokens = firstline.split(/[\\s]+/);\n        if (tokens[0].toUpperCase() === \"END\" && tokens[1].toUpperCase() === \"SITE\") {\n          node.type = \"ENDSITE\";\n          node.name = \"ENDSITE\";\n        } else {\n          node.name = tokens[1];\n          node.type = tokens[0].toUpperCase();\n        }\n        if (nextLine(lines2) !== \"{\") {\n          console.error(\"THREE.BVHLoader: Expected opening { after type & name\");\n        }\n        tokens = nextLine(lines2).split(/[\\s]+/);\n        if (tokens[0] !== \"OFFSET\") {\n          console.error(\"THREE.BVHLoader: Expected OFFSET but got: \" + tokens[0]);\n        }\n        if (tokens.length !== 4) {\n          console.error(\"THREE.BVHLoader: Invalid number of values for OFFSET.\");\n        }\n        var offset = new Vector3(parseFloat(tokens[1]), parseFloat(tokens[2]), parseFloat(tokens[3]));\n        if (isNaN(offset.x) || isNaN(offset.y) || isNaN(offset.z)) {\n          console.error(\"THREE.BVHLoader: Invalid values of OFFSET.\");\n        }\n        node.offset = offset;\n        if (node.type !== \"ENDSITE\") {\n          tokens = nextLine(lines2).split(/[\\s]+/);\n          if (tokens[0] !== \"CHANNELS\") {\n            console.error(\"THREE.BVHLoader: Expected CHANNELS definition.\");\n          }\n          var numChannels = parseInt(tokens[1]);\n          node.channels = tokens.splice(2, numChannels);\n          node.children = [];\n        }\n        while (true) {\n          var line = nextLine(lines2);\n          if (line === \"}\") {\n            return node;\n          } else {\n            node.children.push(readNode(lines2, line, list));\n          }\n        }\n      }\n      function toTHREEBone(source, list) {\n        var bone = new Bone();\n        list.push(bone);\n        bone.position.add(source.offset);\n        bone.name = source.name;\n        if (source.type !== \"ENDSITE\") {\n          for (var i = 0; i < source.children.length; i++) {\n            bone.add(toTHREEBone(source.children[i], list));\n          }\n        }\n        return bone;\n      }\n      function toTHREEAnimation(bones2) {\n        var tracks = [];\n        for (var i = 0; i < bones2.length; i++) {\n          var bone = bones2[i];\n          if (bone.type === \"ENDSITE\") continue;\n          var times = [];\n          var positions = [];\n          var rotations = [];\n          for (var j = 0; j < bone.frames.length; j++) {\n            var frame = bone.frames[j];\n            times.push(frame.time);\n            positions.push(frame.position.x + bone.offset.x);\n            positions.push(frame.position.y + bone.offset.y);\n            positions.push(frame.position.z + bone.offset.z);\n            rotations.push(frame.rotation.x);\n            rotations.push(frame.rotation.y);\n            rotations.push(frame.rotation.z);\n            rotations.push(frame.rotation.w);\n          }\n          if (scope.animateBonePositions) {\n            tracks.push(new VectorKeyframeTrack(\".bones[\" + bone.name + \"].position\", times, positions));\n          }\n          if (scope.animateBoneRotations) {\n            tracks.push(new QuaternionKeyframeTrack(\".bones[\" + bone.name + \"].quaternion\", times, rotations));\n          }\n        }\n        return new AnimationClip(\"animation\", -1, tracks);\n      }\n      function nextLine(lines2) {\n        var line;\n        while ((line = lines2.shift().trim()).length === 0) {}\n        return line;\n      }\n      var scope = this;\n      var lines = text.split(/[\\r\\n]+/g);\n      var bones = readBvh(lines);\n      var threeBones = [];\n      toTHREEBone(bones[0], threeBones);\n      var threeClip = toTHREEAnimation(bones);\n      return {\n        skeleton: new Skeleton(threeBones),\n        clip: threeClip\n      };\n    }\n  }]);\n  return BVHLoader;\n}(Loader);\nexport { BVHLoader };","map":{"version":3,"names":["BVHLoader","_Loader","_inherits","_super","_createSuper","manager","_this","_classCallCheck","call","animateBonePositions","animateBoneRotations","_createClass","key","value","load","url","onLoad","onProgress","onError","scope","loader","FileLoader","setPath","path","setRequestHeader","requestHeader","setWithCredentials","withCredentials","text","parse","e","console","error","itemError","readBvh","lines2","nextLine","list","root","readNode","tokens","split","numFrames","parseInt","isNaN","frameTime","parseFloat","i","readFrameData","data","bone","type","keyframe","time","position","Vector3","rotation","Quaternion","frames","push","quat","vx","vy","vz","channels","length","x","shift","trim","y","z","setFromAxisAngle","Math","PI","multiply","warn","children","firstline","node","name","toUpperCase","offset","numChannels","splice","line","toTHREEBone","source","Bone","add","toTHREEAnimation","bones2","tracks","times","positions","rotations","j","frame","w","VectorKeyframeTrack","QuaternionKeyframeTrack","AnimationClip","lines","bones","threeBones","threeClip","skeleton","Skeleton","clip","Loader"],"sources":["C:\\Users\\Nayyu\\Desktop\\skibidai-public-build\\node_modules\\src\\loaders\\BVHLoader.js"],"sourcesContent":["import {\n  AnimationClip,\n  Bone,\n  FileLoader,\n  Loader,\n  Quaternion,\n  QuaternionKeyframeTrack,\n  Skeleton,\n  Vector3,\n  VectorKeyframeTrack,\n} from 'three'\n\n/**\n * Description: reads BVH files and outputs a single Skeleton and an AnimationClip\n *\n * Currently only supports bvh files containing a single root.\n *\n */\n\nclass BVHLoader extends Loader {\n  constructor(manager) {\n    super(manager)\n\n    this.animateBonePositions = true\n    this.animateBoneRotations = true\n  }\n\n  load(url, onLoad, onProgress, onError) {\n    const scope = this\n\n    const loader = new FileLoader(scope.manager)\n    loader.setPath(scope.path)\n    loader.setRequestHeader(scope.requestHeader)\n    loader.setWithCredentials(scope.withCredentials)\n    loader.load(\n      url,\n      function (text) {\n        try {\n          onLoad(scope.parse(text))\n        } catch (e) {\n          if (onError) {\n            onError(e)\n          } else {\n            console.error(e)\n          }\n\n          scope.manager.itemError(url)\n        }\n      },\n      onProgress,\n      onError,\n    )\n  }\n\n  parse(text) {\n    /*\n\t\t\treads a string array (lines) from a BVH file\n\t\t\tand outputs a skeleton structure including motion data\n\n\t\t\treturns thee root node:\n\t\t\t{ name: '', channels: [], children: [] }\n\t\t*/\n    function readBvh(lines) {\n      // read model structure\n\n      if (nextLine(lines) !== 'HIERARCHY') {\n        console.error('THREE.BVHLoader: HIERARCHY expected.')\n      }\n\n      const list = [] // collects flat array of all bones\n      const root = readNode(lines, nextLine(lines), list)\n\n      // read motion data\n\n      if (nextLine(lines) !== 'MOTION') {\n        console.error('THREE.BVHLoader: MOTION expected.')\n      }\n\n      // number of frames\n\n      let tokens = nextLine(lines).split(/[\\s]+/)\n      const numFrames = parseInt(tokens[1])\n\n      if (isNaN(numFrames)) {\n        console.error('THREE.BVHLoader: Failed to read number of frames.')\n      }\n\n      // frame time\n\n      tokens = nextLine(lines).split(/[\\s]+/)\n      const frameTime = parseFloat(tokens[2])\n\n      if (isNaN(frameTime)) {\n        console.error('THREE.BVHLoader: Failed to read frame time.')\n      }\n\n      // read frame data line by line\n\n      for (let i = 0; i < numFrames; i++) {\n        tokens = nextLine(lines).split(/[\\s]+/)\n        readFrameData(tokens, i * frameTime, root)\n      }\n\n      return list\n    }\n\n    /*\n\t\t\tRecursively reads data from a single frame into the bone hierarchy.\n\t\t\tThe passed bone hierarchy has to be structured in the same order as the BVH file.\n\t\t\tkeyframe data is stored in bone.frames.\n\n\t\t\t- data: splitted string array (frame values), values are shift()ed so\n\t\t\tthis should be empty after parsing the whole hierarchy.\n\t\t\t- frameTime: playback time for this keyframe.\n\t\t\t- bone: the bone to read frame data from.\n\t\t*/\n    function readFrameData(data, frameTime, bone) {\n      // end sites have no motion data\n\n      if (bone.type === 'ENDSITE') return\n\n      // add keyframe\n\n      const keyframe = {\n        time: frameTime,\n        position: new Vector3(),\n        rotation: new Quaternion(),\n      }\n\n      bone.frames.push(keyframe)\n\n      const quat = new Quaternion()\n\n      const vx = new Vector3(1, 0, 0)\n      const vy = new Vector3(0, 1, 0)\n      const vz = new Vector3(0, 0, 1)\n\n      // parse values for each channel in node\n\n      for (let i = 0; i < bone.channels.length; i++) {\n        switch (bone.channels[i]) {\n          case 'Xposition':\n            keyframe.position.x = parseFloat(data.shift().trim())\n            break\n          case 'Yposition':\n            keyframe.position.y = parseFloat(data.shift().trim())\n            break\n          case 'Zposition':\n            keyframe.position.z = parseFloat(data.shift().trim())\n            break\n          case 'Xrotation':\n            quat.setFromAxisAngle(vx, (parseFloat(data.shift().trim()) * Math.PI) / 180)\n            keyframe.rotation.multiply(quat)\n            break\n          case 'Yrotation':\n            quat.setFromAxisAngle(vy, (parseFloat(data.shift().trim()) * Math.PI) / 180)\n            keyframe.rotation.multiply(quat)\n            break\n          case 'Zrotation':\n            quat.setFromAxisAngle(vz, (parseFloat(data.shift().trim()) * Math.PI) / 180)\n            keyframe.rotation.multiply(quat)\n            break\n          default:\n            console.warn('THREE.BVHLoader: Invalid channel type.')\n        }\n      }\n\n      // parse child nodes\n\n      for (let i = 0; i < bone.children.length; i++) {\n        readFrameData(data, frameTime, bone.children[i])\n      }\n    }\n\n    /*\n\t\t Recursively parses the HIERACHY section of the BVH file\n\n\t\t - lines: all lines of the file. lines are consumed as we go along.\n\t\t - firstline: line containing the node type and name e.g. 'JOINT hip'\n\t\t - list: collects a flat list of nodes\n\n\t\t returns: a BVH node including children\n\t\t*/\n    function readNode(lines, firstline, list) {\n      const node = { name: '', type: '', frames: [] }\n      list.push(node)\n\n      // parse node type and name\n\n      let tokens = firstline.split(/[\\s]+/)\n\n      if (tokens[0].toUpperCase() === 'END' && tokens[1].toUpperCase() === 'SITE') {\n        node.type = 'ENDSITE'\n        node.name = 'ENDSITE' // bvh end sites have no name\n      } else {\n        node.name = tokens[1]\n        node.type = tokens[0].toUpperCase()\n      }\n\n      if (nextLine(lines) !== '{') {\n        console.error('THREE.BVHLoader: Expected opening { after type & name')\n      }\n\n      // parse OFFSET\n\n      tokens = nextLine(lines).split(/[\\s]+/)\n\n      if (tokens[0] !== 'OFFSET') {\n        console.error('THREE.BVHLoader: Expected OFFSET but got: ' + tokens[0])\n      }\n\n      if (tokens.length !== 4) {\n        console.error('THREE.BVHLoader: Invalid number of values for OFFSET.')\n      }\n\n      const offset = new Vector3(parseFloat(tokens[1]), parseFloat(tokens[2]), parseFloat(tokens[3]))\n\n      if (isNaN(offset.x) || isNaN(offset.y) || isNaN(offset.z)) {\n        console.error('THREE.BVHLoader: Invalid values of OFFSET.')\n      }\n\n      node.offset = offset\n\n      // parse CHANNELS definitions\n\n      if (node.type !== 'ENDSITE') {\n        tokens = nextLine(lines).split(/[\\s]+/)\n\n        if (tokens[0] !== 'CHANNELS') {\n          console.error('THREE.BVHLoader: Expected CHANNELS definition.')\n        }\n\n        const numChannels = parseInt(tokens[1])\n        node.channels = tokens.splice(2, numChannels)\n        node.children = []\n      }\n\n      // read children\n\n      while (true) {\n        const line = nextLine(lines)\n\n        if (line === '}') {\n          return node\n        } else {\n          node.children.push(readNode(lines, line, list))\n        }\n      }\n    }\n\n    /*\n\t\t\trecursively converts the internal bvh node structure to a Bone hierarchy\n\n\t\t\tsource: the bvh root node\n\t\t\tlist: pass an empty array, collects a flat list of all converted THREE.Bones\n\n\t\t\treturns the root Bone\n\t\t*/\n    function toTHREEBone(source, list) {\n      const bone = new Bone()\n      list.push(bone)\n\n      bone.position.add(source.offset)\n      bone.name = source.name\n\n      if (source.type !== 'ENDSITE') {\n        for (let i = 0; i < source.children.length; i++) {\n          bone.add(toTHREEBone(source.children[i], list))\n        }\n      }\n\n      return bone\n    }\n\n    /*\n\t\t\tbuilds a AnimationClip from the keyframe data saved in each bone.\n\n\t\t\tbone: bvh root node\n\n\t\t\treturns: a AnimationClip containing position and quaternion tracks\n\t\t*/\n    function toTHREEAnimation(bones) {\n      const tracks = []\n\n      // create a position and quaternion animation track for each node\n\n      for (let i = 0; i < bones.length; i++) {\n        const bone = bones[i]\n\n        if (bone.type === 'ENDSITE') continue\n\n        // track data\n\n        const times = []\n        const positions = []\n        const rotations = []\n\n        for (let j = 0; j < bone.frames.length; j++) {\n          const frame = bone.frames[j]\n\n          times.push(frame.time)\n\n          // the animation system animates the position property,\n          // so we have to add the joint offset to all values\n\n          positions.push(frame.position.x + bone.offset.x)\n          positions.push(frame.position.y + bone.offset.y)\n          positions.push(frame.position.z + bone.offset.z)\n\n          rotations.push(frame.rotation.x)\n          rotations.push(frame.rotation.y)\n          rotations.push(frame.rotation.z)\n          rotations.push(frame.rotation.w)\n        }\n\n        if (scope.animateBonePositions) {\n          tracks.push(new VectorKeyframeTrack('.bones[' + bone.name + '].position', times, positions))\n        }\n\n        if (scope.animateBoneRotations) {\n          tracks.push(new QuaternionKeyframeTrack('.bones[' + bone.name + '].quaternion', times, rotations))\n        }\n      }\n\n      return new AnimationClip('animation', -1, tracks)\n    }\n\n    /*\n\t\t\treturns the next non-empty line in lines\n\t\t*/\n    function nextLine(lines) {\n      let line\n      // skip empty lines\n      while ((line = lines.shift().trim()).length === 0) {}\n\n      return line\n    }\n\n    const scope = this\n\n    const lines = text.split(/[\\r\\n]+/g)\n\n    const bones = readBvh(lines)\n\n    const threeBones = []\n    toTHREEBone(bones[0], threeBones)\n\n    const threeClip = toTHREEAnimation(bones)\n\n    return {\n      skeleton: new Skeleton(threeBones),\n      clip: threeClip,\n    }\n  }\n}\n\nexport { BVHLoader }\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}