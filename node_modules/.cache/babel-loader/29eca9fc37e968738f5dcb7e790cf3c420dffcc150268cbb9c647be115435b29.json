{"ast":null,"code":"import _slicedToArray from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _assertThisInitialized from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js\";\nimport _get from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/get.js\";\nimport _getPrototypeOf from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js\";\nimport _createClass from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _classCallCheck from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _inherits from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport { Mesh, PlaneGeometry, MeshBasicMaterial, CanvasTexture, LinearFilter, Color } from \"three\";\nvar HTMLMesh = /*#__PURE__*/function (_Mesh) {\n  _inherits(HTMLMesh, _Mesh);\n  var _super = _createSuper(HTMLMesh);\n  function HTMLMesh(dom) {\n    var _this;\n    _classCallCheck(this, HTMLMesh);\n    var texture = new HTMLTexture(dom);\n    var geometry = new PlaneGeometry(texture.image.width * 1e-3, texture.image.height * 1e-3);\n    var material = new MeshBasicMaterial({\n      map: texture,\n      toneMapped: false,\n      transparent: true\n    });\n    _this = _super.call(this, geometry, material);\n    function onEvent(event) {\n      material.map.dispatchDOMEvent(event);\n    }\n    _this.addEventListener(\"mousedown\", onEvent);\n    _this.addEventListener(\"mousemove\", onEvent);\n    _this.addEventListener(\"mouseup\", onEvent);\n    _this.addEventListener(\"click\", onEvent);\n    _this.dispose = function () {\n      geometry.dispose();\n      material.dispose();\n      material.map.dispose();\n      canvases.delete(dom);\n      this.removeEventListener(\"mousedown\", onEvent);\n      this.removeEventListener(\"mousemove\", onEvent);\n      this.removeEventListener(\"mouseup\", onEvent);\n      this.removeEventListener(\"click\", onEvent);\n    };\n    return _this;\n  }\n  return _createClass(HTMLMesh);\n}(Mesh);\nvar HTMLTexture = /*#__PURE__*/function (_CanvasTexture) {\n  _inherits(HTMLTexture, _CanvasTexture);\n  var _super2 = _createSuper(HTMLTexture);\n  function HTMLTexture(dom) {\n    var _this2;\n    _classCallCheck(this, HTMLTexture);\n    _this2 = _super2.call(this, html2canvas(dom));\n    _this2.dom = dom;\n    _this2.anisotropy = 16;\n    if (\"colorSpace\" in _assertThisInitialized(_this2)) _this2.colorSpace = \"srgb\";else _this2.encoding = 3001;\n    _this2.minFilter = LinearFilter;\n    _this2.magFilter = LinearFilter;\n    var observer = new MutationObserver(function () {\n      if (!_this2.scheduleUpdate) {\n        _this2.scheduleUpdate = setTimeout(function () {\n          return _this2.update();\n        }, 16);\n      }\n    });\n    var config = {\n      attributes: true,\n      childList: true,\n      subtree: true,\n      characterData: true\n    };\n    observer.observe(dom, config);\n    _this2.observer = observer;\n    return _this2;\n  }\n  _createClass(HTMLTexture, [{\n    key: \"dispatchDOMEvent\",\n    value: function dispatchDOMEvent(event) {\n      if (event.data) {\n        htmlevent(this.dom, event.type, event.data.x, event.data.y);\n      }\n    }\n  }, {\n    key: \"update\",\n    value: function update() {\n      this.image = html2canvas(this.dom);\n      this.needsUpdate = true;\n      this.scheduleUpdate = null;\n    }\n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      if (this.observer) {\n        this.observer.disconnect();\n      }\n      this.scheduleUpdate = clearTimeout(this.scheduleUpdate);\n      _get(_getPrototypeOf(HTMLTexture.prototype), \"dispose\", this).call(this);\n    }\n  }]);\n  return HTMLTexture;\n}(CanvasTexture);\nvar canvases = /* @__PURE__ */new WeakMap();\nfunction html2canvas(element) {\n  var range = document.createRange();\n  var color = new Color();\n  function Clipper(context2) {\n    var clips = [];\n    var isClipping = false;\n    function doClip() {\n      if (isClipping) {\n        isClipping = false;\n        context2.restore();\n      }\n      if (clips.length === 0) return;\n      var minX = -Infinity,\n        minY = -Infinity;\n      var maxX = Infinity,\n        maxY = Infinity;\n      for (var i = 0; i < clips.length; i++) {\n        var clip = clips[i];\n        minX = Math.max(minX, clip.x);\n        minY = Math.max(minY, clip.y);\n        maxX = Math.min(maxX, clip.x + clip.width);\n        maxY = Math.min(maxY, clip.y + clip.height);\n      }\n      context2.save();\n      context2.beginPath();\n      context2.rect(minX, minY, maxX - minX, maxY - minY);\n      context2.clip();\n      isClipping = true;\n    }\n    return {\n      add: function add(clip) {\n        clips.push(clip);\n        doClip();\n      },\n      remove: function remove() {\n        clips.pop();\n        doClip();\n      }\n    };\n  }\n  function drawText(style, x, y, string) {\n    if (string !== \"\") {\n      if (style.textTransform === \"uppercase\") {\n        string = string.toUpperCase();\n      }\n      context.font = style.fontWeight + \" \" + style.fontSize + \" \" + style.fontFamily;\n      context.textBaseline = \"top\";\n      context.fillStyle = style.color;\n      context.fillText(string, x, y + parseFloat(style.fontSize) * 0.1);\n    }\n  }\n  function buildRectPath(x, y, w, h, r) {\n    if (w < 2 * r) r = w / 2;\n    if (h < 2 * r) r = h / 2;\n    context.beginPath();\n    context.moveTo(x + r, y);\n    context.arcTo(x + w, y, x + w, y + h, r);\n    context.arcTo(x + w, y + h, x, y + h, r);\n    context.arcTo(x, y + h, x, y, r);\n    context.arcTo(x, y, x + w, y, r);\n    context.closePath();\n  }\n  function drawBorder(style, which, x, y, width, height) {\n    var borderWidth = style[which + \"Width\"];\n    var borderStyle = style[which + \"Style\"];\n    var borderColor = style[which + \"Color\"];\n    if (borderWidth !== \"0px\" && borderStyle !== \"none\" && borderColor !== \"transparent\" && borderColor !== \"rgba(0, 0, 0, 0)\") {\n      context.strokeStyle = borderColor;\n      context.lineWidth = parseFloat(borderWidth);\n      context.beginPath();\n      context.moveTo(x, y);\n      context.lineTo(x + width, y + height);\n      context.stroke();\n    }\n  }\n  function drawElement(element2, style) {\n    var x = 0,\n      y = 0,\n      width = 0,\n      height = 0;\n    if (element2.nodeType === Node.TEXT_NODE) {\n      range.selectNode(element2);\n      var rect = range.getBoundingClientRect();\n      x = rect.left - offset.left - 0.5;\n      y = rect.top - offset.top - 0.5;\n      width = rect.width;\n      height = rect.height;\n      drawText(style, x, y, element2.nodeValue.trim());\n    } else if (element2.nodeType === Node.COMMENT_NODE) {\n      return;\n    } else if (element2 instanceof HTMLCanvasElement) {\n      if (element2.style.display === \"none\") return;\n      context.save();\n      var dpr = window.devicePixelRatio;\n      context.scale(1 / dpr, 1 / dpr);\n      context.drawImage(element2, 0, 0);\n      context.restore();\n    } else {\n      if (element2.style.display === \"none\") return;\n      var _rect = element2.getBoundingClientRect();\n      x = _rect.left - offset.left - 0.5;\n      y = _rect.top - offset.top - 0.5;\n      width = _rect.width;\n      height = _rect.height;\n      style = window.getComputedStyle(element2);\n      buildRectPath(x, y, width, height, parseFloat(style.borderRadius));\n      var backgroundColor = style.backgroundColor;\n      if (backgroundColor !== \"transparent\" && backgroundColor !== \"rgba(0, 0, 0, 0)\") {\n        context.fillStyle = backgroundColor;\n        context.fill();\n      }\n      var borders = [\"borderTop\", \"borderLeft\", \"borderBottom\", \"borderRight\"];\n      var match = true;\n      var prevBorder = null;\n      for (var _i = 0, _borders = borders; _i < _borders.length; _i++) {\n        var border = _borders[_i];\n        if (prevBorder !== null) {\n          match = style[border + \"Width\"] === style[prevBorder + \"Width\"] && style[border + \"Color\"] === style[prevBorder + \"Color\"] && style[border + \"Style\"] === style[prevBorder + \"Style\"];\n        }\n        if (match === false) break;\n        prevBorder = border;\n      }\n      if (match === true) {\n        var width2 = parseFloat(style.borderTopWidth);\n        if (style.borderTopWidth !== \"0px\" && style.borderTopStyle !== \"none\" && style.borderTopColor !== \"transparent\" && style.borderTopColor !== \"rgba(0, 0, 0, 0)\") {\n          context.strokeStyle = style.borderTopColor;\n          context.lineWidth = width2;\n          context.stroke();\n        }\n      } else {\n        drawBorder(style, \"borderTop\", x, y, width, 0);\n        drawBorder(style, \"borderLeft\", x, y, 0, height);\n        drawBorder(style, \"borderBottom\", x, y + height, width, 0);\n        drawBorder(style, \"borderRight\", x + width, y, 0, height);\n      }\n      if (element2 instanceof HTMLInputElement) {\n        var accentColor = style.accentColor;\n        if (accentColor === void 0 || accentColor === \"auto\") accentColor = style.color;\n        color.set(accentColor);\n        var luminance = Math.sqrt(0.299 * Math.pow(color.r, 2) + 0.587 * Math.pow(color.g, 2) + 0.114 * Math.pow(color.b, 2));\n        var accentTextColor = luminance < 0.5 ? \"white\" : \"#111111\";\n        if (element2.type === \"radio\") {\n          buildRectPath(x, y, width, height, height);\n          context.fillStyle = \"white\";\n          context.strokeStyle = accentColor;\n          context.lineWidth = 1;\n          context.fill();\n          context.stroke();\n          if (element2.checked) {\n            buildRectPath(x + 2, y + 2, width - 4, height - 4, height);\n            context.fillStyle = accentColor;\n            context.strokeStyle = accentTextColor;\n            context.lineWidth = 2;\n            context.fill();\n            context.stroke();\n          }\n        }\n        if (element2.type === \"checkbox\") {\n          buildRectPath(x, y, width, height, 2);\n          context.fillStyle = element2.checked ? accentColor : \"white\";\n          context.strokeStyle = element2.checked ? accentTextColor : accentColor;\n          context.lineWidth = 1;\n          context.stroke();\n          context.fill();\n          if (element2.checked) {\n            var currentTextAlign = context.textAlign;\n            context.textAlign = \"center\";\n            var properties = {\n              color: accentTextColor,\n              fontFamily: style.fontFamily,\n              fontSize: height + \"px\",\n              fontWeight: \"bold\"\n            };\n            drawText(properties, x + width / 2, y, \"✔\");\n            context.textAlign = currentTextAlign;\n          }\n        }\n        if (element2.type === \"range\") {\n          var _map = [\"min\", \"max\", \"value\"].map(function (property) {\n              return parseFloat(element2[property]);\n            }),\n            _map2 = _slicedToArray(_map, 3),\n            min = _map2[0],\n            max = _map2[1],\n            value = _map2[2];\n          var position = (value - min) / (max - min) * (width - height);\n          buildRectPath(x, y + height / 4, width, height / 2, height / 4);\n          context.fillStyle = accentTextColor;\n          context.strokeStyle = accentColor;\n          context.lineWidth = 1;\n          context.fill();\n          context.stroke();\n          buildRectPath(x, y + height / 4, position + height / 2, height / 2, height / 4);\n          context.fillStyle = accentColor;\n          context.fill();\n          buildRectPath(x + position, y, height, height, height / 2);\n          context.fillStyle = accentColor;\n          context.fill();\n        }\n        if (element2.type === \"color\" || element2.type === \"text\" || element2.type === \"number\") {\n          clipper.add({\n            x: x,\n            y: y,\n            width: width,\n            height: height\n          });\n          drawText(style, x + parseInt(style.paddingLeft), y + parseInt(style.paddingTop), element2.value);\n          clipper.remove();\n        }\n      }\n    }\n    var isClipping = style.overflow === \"auto\" || style.overflow === \"hidden\";\n    if (isClipping) clipper.add({\n      x: x,\n      y: y,\n      width: width,\n      height: height\n    });\n    for (var i = 0; i < element2.childNodes.length; i++) {\n      drawElement(element2.childNodes[i], style);\n    }\n    if (isClipping) clipper.remove();\n  }\n  var offset = element.getBoundingClientRect();\n  var canvas = canvases.get(element);\n  if (canvas === void 0) {\n    canvas = document.createElement(\"canvas\");\n    canvas.width = offset.width;\n    canvas.height = offset.height;\n    canvases.set(element, canvas);\n  }\n  var context = canvas.getContext(\"2d\"\n  /*, { alpha: false }*/);\n\n  var clipper = new Clipper(context);\n  drawElement(element);\n  return canvas;\n}\nfunction htmlevent(element, event, x, y) {\n  var mouseEventInit = {\n    clientX: x * element.offsetWidth + element.offsetLeft,\n    clientY: y * element.offsetHeight + element.offsetTop,\n    view: element.ownerDocument.defaultView\n  };\n  window.dispatchEvent(new MouseEvent(event, mouseEventInit));\n  var rect = element.getBoundingClientRect();\n  x = x * rect.width + rect.left;\n  y = y * rect.height + rect.top;\n  function traverse(element2) {\n    if (element2.nodeType !== Node.TEXT_NODE && element2.nodeType !== Node.COMMENT_NODE) {\n      var rect2 = element2.getBoundingClientRect();\n      if (x > rect2.left && x < rect2.right && y > rect2.top && y < rect2.bottom) {\n        element2.dispatchEvent(new MouseEvent(event, mouseEventInit));\n        if (element2 instanceof HTMLInputElement && element2.type === \"range\" && (event === \"mousedown\" || event === \"click\")) {\n          var _map3 = [\"min\", \"max\"].map(function (property) {\n              return parseFloat(element2[property]);\n            }),\n            _map4 = _slicedToArray(_map3, 2),\n            min = _map4[0],\n            max = _map4[1];\n          var width = rect2.width;\n          var offsetX = x - rect2.x;\n          var proportion = offsetX / width;\n          element2.value = min + (max - min) * proportion;\n          element2.dispatchEvent(new InputEvent(\"input\", {\n            bubbles: true\n          }));\n        }\n      }\n      for (var i = 0; i < element2.childNodes.length; i++) {\n        traverse(element2.childNodes[i]);\n      }\n    }\n  }\n  traverse(element);\n}\nexport { HTMLMesh };","map":{"version":3,"names":["HTMLMesh","_Mesh","_inherits","_super","_createSuper","dom","_this","_classCallCheck","texture","HTMLTexture","geometry","PlaneGeometry","image","width","height","material","MeshBasicMaterial","map","toneMapped","transparent","call","onEvent","event","dispatchDOMEvent","addEventListener","dispose","canvases","delete","removeEventListener","_createClass","Mesh","_CanvasTexture","_super2","_this2","html2canvas","anisotropy","_assertThisInitialized","colorSpace","encoding","minFilter","LinearFilter","magFilter","observer","MutationObserver","scheduleUpdate","setTimeout","update","config","attributes","childList","subtree","characterData","observe","key","value","data","htmlevent","type","x","y","needsUpdate","disconnect","clearTimeout","_get","_getPrototypeOf","prototype","CanvasTexture","WeakMap","element","range","document","createRange","color","Color","Clipper","context2","clips","isClipping","doClip","restore","length","minX","Infinity","minY","maxX","maxY","i","clip","Math","max","min","save","beginPath","rect","add","push","remove","pop","drawText","style","string","textTransform","toUpperCase","context","font","fontWeight","fontSize","fontFamily","textBaseline","fillStyle","fillText","parseFloat","buildRectPath","w","h","r","moveTo","arcTo","closePath","drawBorder","which","borderWidth","borderStyle","borderColor","strokeStyle","lineWidth","lineTo","stroke","drawElement","element2","nodeType","Node","TEXT_NODE","selectNode","getBoundingClientRect","left","offset","top","nodeValue","trim","COMMENT_NODE","HTMLCanvasElement","display","dpr","window","devicePixelRatio","scale","drawImage","getComputedStyle","borderRadius","backgroundColor","fill","borders","match","prevBorder","_i","_borders","border","width2","borderTopWidth","borderTopStyle","borderTopColor","HTMLInputElement","accentColor","set","luminance","sqrt","pow","g","b","accentTextColor","checked","currentTextAlign","textAlign","properties","_map","property","_map2","_slicedToArray","position","clipper","parseInt","paddingLeft","paddingTop","overflow","childNodes","canvas","get","createElement","getContext","mouseEventInit","clientX","offsetWidth","offsetLeft","clientY","offsetHeight","offsetTop","view","ownerDocument","defaultView","dispatchEvent","MouseEvent","traverse","rect2","right","bottom","_map3","_map4","offsetX","proportion","InputEvent","bubbles"],"sources":["C:\\Users\\Nayyu\\Desktop\\skibidai-public-build\\node_modules\\src\\interactive\\HTMLMesh.js"],"sourcesContent":["import { CanvasTexture, LinearFilter, Mesh, MeshBasicMaterial, PlaneGeometry, Color } from 'three'\n\nclass HTMLMesh extends Mesh {\n  constructor(dom) {\n    const texture = new HTMLTexture(dom)\n\n    const geometry = new PlaneGeometry(texture.image.width * 0.001, texture.image.height * 0.001)\n    const material = new MeshBasicMaterial({ map: texture, toneMapped: false, transparent: true })\n\n    super(geometry, material)\n\n    function onEvent(event) {\n      material.map.dispatchDOMEvent(event)\n    }\n\n    this.addEventListener('mousedown', onEvent)\n    this.addEventListener('mousemove', onEvent)\n    this.addEventListener('mouseup', onEvent)\n    this.addEventListener('click', onEvent)\n\n    this.dispose = function () {\n      geometry.dispose()\n      material.dispose()\n\n      material.map.dispose()\n\n      canvases.delete(dom)\n\n      this.removeEventListener('mousedown', onEvent)\n      this.removeEventListener('mousemove', onEvent)\n      this.removeEventListener('mouseup', onEvent)\n      this.removeEventListener('click', onEvent)\n    }\n  }\n}\n\nclass HTMLTexture extends CanvasTexture {\n  constructor(dom) {\n    super(html2canvas(dom))\n\n    this.dom = dom\n\n    this.anisotropy = 16\n    if ('colorSpace' in this) this.colorSpace = 'srgb'\n    else this.encoding = 3001 // sRGBEncoding\n    this.minFilter = LinearFilter\n    this.magFilter = LinearFilter\n\n    // Create an observer on the DOM, and run html2canvas update in the next loop\n    const observer = new MutationObserver(() => {\n      if (!this.scheduleUpdate) {\n        // ideally should use xr.requestAnimationFrame, here setTimeout to avoid passing the renderer\n        this.scheduleUpdate = setTimeout(() => this.update(), 16)\n      }\n    })\n\n    const config = { attributes: true, childList: true, subtree: true, characterData: true }\n    observer.observe(dom, config)\n\n    this.observer = observer\n  }\n\n  dispatchDOMEvent(event) {\n    if (event.data) {\n      htmlevent(this.dom, event.type, event.data.x, event.data.y)\n    }\n  }\n\n  update() {\n    this.image = html2canvas(this.dom)\n    this.needsUpdate = true\n\n    this.scheduleUpdate = null\n  }\n\n  dispose() {\n    if (this.observer) {\n      this.observer.disconnect()\n    }\n\n    this.scheduleUpdate = clearTimeout(this.scheduleUpdate)\n\n    super.dispose()\n  }\n}\n\n//\n\nconst canvases = new WeakMap()\n\nfunction html2canvas(element) {\n  const range = document.createRange()\n  const color = new Color()\n\n  function Clipper(context) {\n    const clips = []\n    let isClipping = false\n\n    function doClip() {\n      if (isClipping) {\n        isClipping = false\n        context.restore()\n      }\n\n      if (clips.length === 0) return\n\n      let minX = -Infinity,\n        minY = -Infinity\n      let maxX = Infinity,\n        maxY = Infinity\n\n      for (let i = 0; i < clips.length; i++) {\n        const clip = clips[i]\n\n        minX = Math.max(minX, clip.x)\n        minY = Math.max(minY, clip.y)\n        maxX = Math.min(maxX, clip.x + clip.width)\n        maxY = Math.min(maxY, clip.y + clip.height)\n      }\n\n      context.save()\n      context.beginPath()\n      context.rect(minX, minY, maxX - minX, maxY - minY)\n      context.clip()\n\n      isClipping = true\n    }\n\n    return {\n      add: function (clip) {\n        clips.push(clip)\n        doClip()\n      },\n\n      remove: function () {\n        clips.pop()\n        doClip()\n      },\n    }\n  }\n\n  function drawText(style, x, y, string) {\n    if (string !== '') {\n      if (style.textTransform === 'uppercase') {\n        string = string.toUpperCase()\n      }\n\n      context.font = style.fontWeight + ' ' + style.fontSize + ' ' + style.fontFamily\n      context.textBaseline = 'top'\n      context.fillStyle = style.color\n      context.fillText(string, x, y + parseFloat(style.fontSize) * 0.1)\n    }\n  }\n\n  function buildRectPath(x, y, w, h, r) {\n    if (w < 2 * r) r = w / 2\n    if (h < 2 * r) r = h / 2\n\n    context.beginPath()\n    context.moveTo(x + r, y)\n    context.arcTo(x + w, y, x + w, y + h, r)\n    context.arcTo(x + w, y + h, x, y + h, r)\n    context.arcTo(x, y + h, x, y, r)\n    context.arcTo(x, y, x + w, y, r)\n    context.closePath()\n  }\n\n  function drawBorder(style, which, x, y, width, height) {\n    const borderWidth = style[which + 'Width']\n    const borderStyle = style[which + 'Style']\n    const borderColor = style[which + 'Color']\n\n    if (\n      borderWidth !== '0px' &&\n      borderStyle !== 'none' &&\n      borderColor !== 'transparent' &&\n      borderColor !== 'rgba(0, 0, 0, 0)'\n    ) {\n      context.strokeStyle = borderColor\n      context.lineWidth = parseFloat(borderWidth)\n      context.beginPath()\n      context.moveTo(x, y)\n      context.lineTo(x + width, y + height)\n      context.stroke()\n    }\n  }\n\n  function drawElement(element, style) {\n    let x = 0,\n      y = 0,\n      width = 0,\n      height = 0\n\n    if (element.nodeType === Node.TEXT_NODE) {\n      // text\n\n      range.selectNode(element)\n\n      const rect = range.getBoundingClientRect()\n\n      x = rect.left - offset.left - 0.5\n      y = rect.top - offset.top - 0.5\n      width = rect.width\n      height = rect.height\n\n      drawText(style, x, y, element.nodeValue.trim())\n    } else if (element.nodeType === Node.COMMENT_NODE) {\n      return\n    } else if (element instanceof HTMLCanvasElement) {\n      // Canvas element\n      if (element.style.display === 'none') return\n\n      context.save()\n      const dpr = window.devicePixelRatio\n      context.scale(1 / dpr, 1 / dpr)\n      context.drawImage(element, 0, 0)\n      context.restore()\n    } else {\n      if (element.style.display === 'none') return\n\n      const rect = element.getBoundingClientRect()\n\n      x = rect.left - offset.left - 0.5\n      y = rect.top - offset.top - 0.5\n      width = rect.width\n      height = rect.height\n\n      style = window.getComputedStyle(element)\n\n      // Get the border of the element used for fill and border\n\n      buildRectPath(x, y, width, height, parseFloat(style.borderRadius))\n\n      const backgroundColor = style.backgroundColor\n\n      if (backgroundColor !== 'transparent' && backgroundColor !== 'rgba(0, 0, 0, 0)') {\n        context.fillStyle = backgroundColor\n        context.fill()\n      }\n\n      // If all the borders match then stroke the round rectangle\n\n      const borders = ['borderTop', 'borderLeft', 'borderBottom', 'borderRight']\n\n      let match = true\n      let prevBorder = null\n\n      for (const border of borders) {\n        if (prevBorder !== null) {\n          match =\n            style[border + 'Width'] === style[prevBorder + 'Width'] &&\n            style[border + 'Color'] === style[prevBorder + 'Color'] &&\n            style[border + 'Style'] === style[prevBorder + 'Style']\n        }\n\n        if (match === false) break\n\n        prevBorder = border\n      }\n\n      if (match === true) {\n        // They all match so stroke the rectangle from before allows for border-radius\n\n        const width = parseFloat(style.borderTopWidth)\n\n        if (\n          style.borderTopWidth !== '0px' &&\n          style.borderTopStyle !== 'none' &&\n          style.borderTopColor !== 'transparent' &&\n          style.borderTopColor !== 'rgba(0, 0, 0, 0)'\n        ) {\n          context.strokeStyle = style.borderTopColor\n          context.lineWidth = width\n          context.stroke()\n        }\n      } else {\n        // Otherwise draw individual borders\n\n        drawBorder(style, 'borderTop', x, y, width, 0)\n        drawBorder(style, 'borderLeft', x, y, 0, height)\n        drawBorder(style, 'borderBottom', x, y + height, width, 0)\n        drawBorder(style, 'borderRight', x + width, y, 0, height)\n      }\n\n      if (element instanceof HTMLInputElement) {\n        let accentColor = style.accentColor\n\n        if (accentColor === undefined || accentColor === 'auto') accentColor = style.color\n\n        color.set(accentColor)\n\n        const luminance = Math.sqrt(0.299 * color.r ** 2 + 0.587 * color.g ** 2 + 0.114 * color.b ** 2)\n        const accentTextColor = luminance < 0.5 ? 'white' : '#111111'\n\n        if (element.type === 'radio') {\n          buildRectPath(x, y, width, height, height)\n\n          context.fillStyle = 'white'\n          context.strokeStyle = accentColor\n          context.lineWidth = 1\n          context.fill()\n          context.stroke()\n\n          if (element.checked) {\n            buildRectPath(x + 2, y + 2, width - 4, height - 4, height)\n\n            context.fillStyle = accentColor\n            context.strokeStyle = accentTextColor\n            context.lineWidth = 2\n            context.fill()\n            context.stroke()\n          }\n        }\n\n        if (element.type === 'checkbox') {\n          buildRectPath(x, y, width, height, 2)\n\n          context.fillStyle = element.checked ? accentColor : 'white'\n          context.strokeStyle = element.checked ? accentTextColor : accentColor\n          context.lineWidth = 1\n          context.stroke()\n          context.fill()\n\n          if (element.checked) {\n            const currentTextAlign = context.textAlign\n\n            context.textAlign = 'center'\n\n            const properties = {\n              color: accentTextColor,\n              fontFamily: style.fontFamily,\n              fontSize: height + 'px',\n              fontWeight: 'bold',\n            }\n\n            drawText(properties, x + width / 2, y, '✔')\n\n            context.textAlign = currentTextAlign\n          }\n        }\n\n        if (element.type === 'range') {\n          const [min, max, value] = ['min', 'max', 'value'].map((property) => parseFloat(element[property]))\n          const position = ((value - min) / (max - min)) * (width - height)\n\n          buildRectPath(x, y + height / 4, width, height / 2, height / 4)\n          context.fillStyle = accentTextColor\n          context.strokeStyle = accentColor\n          context.lineWidth = 1\n          context.fill()\n          context.stroke()\n\n          buildRectPath(x, y + height / 4, position + height / 2, height / 2, height / 4)\n          context.fillStyle = accentColor\n          context.fill()\n\n          buildRectPath(x + position, y, height, height, height / 2)\n          context.fillStyle = accentColor\n          context.fill()\n        }\n\n        if (element.type === 'color' || element.type === 'text' || element.type === 'number') {\n          clipper.add({ x: x, y: y, width: width, height: height })\n\n          drawText(style, x + parseInt(style.paddingLeft), y + parseInt(style.paddingTop), element.value)\n\n          clipper.remove()\n        }\n      }\n    }\n\n    /*\n\t\t// debug\n\t\tcontext.strokeStyle = '#' + Math.random().toString( 16 ).slice( - 3 );\n\t\tcontext.strokeRect( x - 0.5, y - 0.5, width + 1, height + 1 );\n\t\t*/\n\n    const isClipping = style.overflow === 'auto' || style.overflow === 'hidden'\n\n    if (isClipping) clipper.add({ x: x, y: y, width: width, height: height })\n\n    for (let i = 0; i < element.childNodes.length; i++) {\n      drawElement(element.childNodes[i], style)\n    }\n\n    if (isClipping) clipper.remove()\n  }\n\n  const offset = element.getBoundingClientRect()\n\n  let canvas = canvases.get(element)\n\n  if (canvas === undefined) {\n    canvas = document.createElement('canvas')\n    canvas.width = offset.width\n    canvas.height = offset.height\n    canvases.set(element, canvas)\n  }\n\n  const context = canvas.getContext('2d' /*, { alpha: false }*/)\n\n  const clipper = new Clipper(context)\n\n  // console.time( 'drawElement' );\n\n  drawElement(element)\n\n  // console.timeEnd( 'drawElement' );\n\n  return canvas\n}\n\nfunction htmlevent(element, event, x, y) {\n  const mouseEventInit = {\n    clientX: x * element.offsetWidth + element.offsetLeft,\n    clientY: y * element.offsetHeight + element.offsetTop,\n    view: element.ownerDocument.defaultView,\n  }\n\n  window.dispatchEvent(new MouseEvent(event, mouseEventInit))\n\n  const rect = element.getBoundingClientRect()\n\n  x = x * rect.width + rect.left\n  y = y * rect.height + rect.top\n\n  function traverse(element) {\n    if (element.nodeType !== Node.TEXT_NODE && element.nodeType !== Node.COMMENT_NODE) {\n      const rect = element.getBoundingClientRect()\n\n      if (x > rect.left && x < rect.right && y > rect.top && y < rect.bottom) {\n        element.dispatchEvent(new MouseEvent(event, mouseEventInit))\n\n        if (\n          element instanceof HTMLInputElement &&\n          element.type === 'range' &&\n          (event === 'mousedown' || event === 'click')\n        ) {\n          const [min, max] = ['min', 'max'].map((property) => parseFloat(element[property]))\n\n          const width = rect.width\n          const offsetX = x - rect.x\n          const proportion = offsetX / width\n          element.value = min + (max - min) * proportion\n          element.dispatchEvent(new InputEvent('input', { bubbles: true }))\n        }\n      }\n\n      for (let i = 0; i < element.childNodes.length; i++) {\n        traverse(element.childNodes[i])\n      }\n    }\n  }\n\n  traverse(element)\n}\n\nexport { HTMLMesh }\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}