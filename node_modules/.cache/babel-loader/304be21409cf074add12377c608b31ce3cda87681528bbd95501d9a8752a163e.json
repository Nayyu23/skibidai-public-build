{"ast":null,"code":"import _classCallCheck from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _get from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/get.js\";\nimport _getPrototypeOf from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js\";\nimport _inherits from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = function __defNormalProp(obj, key, value) {\n  return key in obj ? __defProp(obj, key, {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: value\n  }) : obj[key] = value;\n};\nvar __publicField = function __publicField(obj, key, value) {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nimport { BufferGeometry, Vector3, Uint32BufferAttribute, Float32BufferAttribute, DynamicDrawUsage, MathUtils } from \"three\";\nimport { SimplexNoise } from \"../math/SimplexNoise.js\";\nvar _LightningStrike = /*#__PURE__*/function (_BufferGeometry) {\n  _inherits(_LightningStrike, _BufferGeometry);\n  var _super = _createSuper(_LightningStrike);\n  function _LightningStrike() {\n    var _this;\n    var rayParameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    _classCallCheck(this, _LightningStrike);\n    _this = _super.call(this);\n    _this.isLightningStrike = true;\n    _this.type = \"LightningStrike\";\n    _this.init(_LightningStrike.copyParameters(rayParameters, rayParameters));\n    _this.createMesh();\n    return _this;\n  }\n  _createClass(_LightningStrike, [{\n    key: \"update\",\n    value: function update(time) {\n      if (this.isStatic) return;\n      if (this.rayParameters.isEternal || this.rayParameters.birthTime <= time && time <= this.rayParameters.deathTime) {\n        this.updateMesh(time);\n        if (time < this.subrays[0].endPropagationTime) {\n          this.state = _LightningStrike.RAY_PROPAGATING;\n        } else if (time > this.subrays[0].beginVanishingTime) {\n          this.state = _LightningStrike.RAY_VANISHING;\n        } else {\n          this.state = _LightningStrike.RAY_STEADY;\n        }\n        this.visible = true;\n      } else {\n        this.visible = false;\n        if (time < this.rayParameters.birthTime) {\n          this.state = _LightningStrike.RAY_UNBORN;\n        } else {\n          this.state = _LightningStrike.RAY_EXTINGUISHED;\n        }\n      }\n    }\n  }, {\n    key: \"init\",\n    value: function init(rayParameters) {\n      this.rayParameters = rayParameters;\n      this.maxIterations = rayParameters.maxIterations !== void 0 ? Math.floor(rayParameters.maxIterations) : 9;\n      rayParameters.maxIterations = this.maxIterations;\n      this.isStatic = rayParameters.isStatic !== void 0 ? rayParameters.isStatic : false;\n      rayParameters.isStatic = this.isStatic;\n      this.ramification = rayParameters.ramification !== void 0 ? Math.floor(rayParameters.ramification) : 5;\n      rayParameters.ramification = this.ramification;\n      this.maxSubrayRecursion = rayParameters.maxSubrayRecursion !== void 0 ? Math.floor(rayParameters.maxSubrayRecursion) : 3;\n      rayParameters.maxSubrayRecursion = this.maxSubrayRecursion;\n      this.recursionProbability = rayParameters.recursionProbability !== void 0 ? rayParameters.recursionProbability : 0.6;\n      rayParameters.recursionProbability = this.recursionProbability;\n      this.generateUVs = rayParameters.generateUVs !== void 0 ? rayParameters.generateUVs : false;\n      rayParameters.generateUVs = this.generateUVs;\n      if (rayParameters.randomGenerator !== void 0) {\n        this.randomGenerator = rayParameters.randomGenerator;\n        this.seedGenerator = rayParameters.randomGenerator;\n        if (rayParameters.noiseSeed !== void 0) {\n          this.seedGenerator.setSeed(rayParameters.noiseSeed);\n        }\n      } else {\n        this.randomGenerator = _LightningStrike.createRandomGenerator();\n        this.seedGenerator = Math;\n      }\n      if (rayParameters.onDecideSubrayCreation !== void 0) {\n        this.onDecideSubrayCreation = rayParameters.onDecideSubrayCreation;\n      } else {\n        this.createDefaultSubrayCreationCallbacks();\n        if (rayParameters.onSubrayCreation !== void 0) {\n          this.onSubrayCreation = rayParameters.onSubrayCreation;\n        }\n      }\n      this.state = _LightningStrike.RAY_INITIALIZED;\n      this.maxSubrays = Math.ceil(1 + Math.pow(this.ramification, Math.max(0, this.maxSubrayRecursion - 1)));\n      rayParameters.maxSubrays = this.maxSubrays;\n      this.maxRaySegments = 2 * (1 << this.maxIterations);\n      this.subrays = [];\n      for (var i = 0; i < this.maxSubrays; i++) {\n        this.subrays.push(this.createSubray());\n      }\n      this.raySegments = [];\n      for (var _i = 0; _i < this.maxRaySegments; _i++) {\n        this.raySegments.push(this.createSegment());\n      }\n      this.time = 0;\n      this.timeFraction = 0;\n      this.currentSegmentCallback = null;\n      this.currentCreateTriangleVertices = this.generateUVs ? this.createTriangleVerticesWithUVs : this.createTriangleVerticesWithoutUVs;\n      this.numSubrays = 0;\n      this.currentSubray = null;\n      this.currentSegmentIndex = 0;\n      this.isInitialSegment = false;\n      this.subrayProbability = 0;\n      this.currentVertex = 0;\n      this.currentIndex = 0;\n      this.currentCoordinate = 0;\n      this.currentUVCoordinate = 0;\n      this.vertices = null;\n      this.uvs = null;\n      this.indices = null;\n      this.positionAttribute = null;\n      this.uvsAttribute = null;\n      this.simplexX = new SimplexNoise(this.seedGenerator);\n      this.simplexY = new SimplexNoise(this.seedGenerator);\n      this.simplexZ = new SimplexNoise(this.seedGenerator);\n      this.forwards = new Vector3();\n      this.forwardsFill = new Vector3();\n      this.side = new Vector3();\n      this.down = new Vector3();\n      this.middlePos = new Vector3();\n      this.middleLinPos = new Vector3();\n      this.newPos = new Vector3();\n      this.vPos = new Vector3();\n      this.cross1 = new Vector3();\n    }\n  }, {\n    key: \"createMesh\",\n    value: function createMesh() {\n      var maxDrawableSegmentsPerSubRay = 1 << this.maxIterations;\n      var maxVerts = 3 * (maxDrawableSegmentsPerSubRay + 1) * this.maxSubrays;\n      var maxIndices = 18 * maxDrawableSegmentsPerSubRay * this.maxSubrays;\n      this.vertices = new Float32Array(maxVerts * 3);\n      this.indices = new Uint32Array(maxIndices);\n      if (this.generateUVs) {\n        this.uvs = new Float32Array(maxVerts * 2);\n      }\n      this.fillMesh(0);\n      this.setIndex(new Uint32BufferAttribute(this.indices, 1));\n      this.positionAttribute = new Float32BufferAttribute(this.vertices, 3);\n      this.setAttribute(\"position\", this.positionAttribute);\n      if (this.generateUVs) {\n        this.uvsAttribute = new Float32BufferAttribute(new Float32Array(this.uvs), 2);\n        this.setAttribute(\"uv\", this.uvsAttribute);\n      }\n      if (!this.isStatic) {\n        this.index.usage = DynamicDrawUsage;\n        this.positionAttribute.usage = DynamicDrawUsage;\n        if (this.generateUVs) {\n          this.uvsAttribute.usage = DynamicDrawUsage;\n        }\n      }\n      this.vertices = this.positionAttribute.array;\n      this.indices = this.index.array;\n      if (this.generateUVs) {\n        this.uvs = this.uvsAttribute.array;\n      }\n    }\n  }, {\n    key: \"updateMesh\",\n    value: function updateMesh(time) {\n      this.fillMesh(time);\n      this.drawRange.count = this.currentIndex;\n      this.index.needsUpdate = true;\n      this.positionAttribute.needsUpdate = true;\n      if (this.generateUVs) {\n        this.uvsAttribute.needsUpdate = true;\n      }\n    }\n  }, {\n    key: \"fillMesh\",\n    value: function fillMesh(time) {\n      var scope = this;\n      this.currentVertex = 0;\n      this.currentIndex = 0;\n      this.currentCoordinate = 0;\n      this.currentUVCoordinate = 0;\n      this.fractalRay(time, function fillVertices(segment) {\n        var subray = scope.currentSubray;\n        if (time < subray.birthTime) {\n          return;\n        } else if (this.rayParameters.isEternal && scope.currentSubray.recursion == 0) {\n          scope.createPrism(segment);\n          scope.onDecideSubrayCreation(segment, scope);\n        } else if (time < subray.endPropagationTime) {\n          if (scope.timeFraction >= segment.fraction0 * subray.propagationTimeFactor) {\n            scope.createPrism(segment);\n            scope.onDecideSubrayCreation(segment, scope);\n          }\n        } else if (time < subray.beginVanishingTime) {\n          scope.createPrism(segment);\n          scope.onDecideSubrayCreation(segment, scope);\n        } else {\n          if (scope.timeFraction <= subray.vanishingTimeFactor + segment.fraction1 * (1 - subray.vanishingTimeFactor)) {\n            scope.createPrism(segment);\n          }\n          scope.onDecideSubrayCreation(segment, scope);\n        }\n      });\n    }\n  }, {\n    key: \"addNewSubray\",\n    value: function addNewSubray() {\n      return this.subrays[this.numSubrays++];\n    }\n  }, {\n    key: \"initSubray\",\n    value: function initSubray(subray, rayParameters) {\n      subray.pos0.copy(rayParameters.sourceOffset);\n      subray.pos1.copy(rayParameters.destOffset);\n      subray.up0.copy(rayParameters.up0);\n      subray.up1.copy(rayParameters.up1);\n      subray.radius0 = rayParameters.radius0;\n      subray.radius1 = rayParameters.radius1;\n      subray.birthTime = rayParameters.birthTime;\n      subray.deathTime = rayParameters.deathTime;\n      subray.timeScale = rayParameters.timeScale;\n      subray.roughness = rayParameters.roughness;\n      subray.straightness = rayParameters.straightness;\n      subray.propagationTimeFactor = rayParameters.propagationTimeFactor;\n      subray.vanishingTimeFactor = rayParameters.vanishingTimeFactor;\n      subray.maxIterations = this.maxIterations;\n      subray.seed = rayParameters.noiseSeed !== void 0 ? rayParameters.noiseSeed : 0;\n      subray.recursion = 0;\n    }\n  }, {\n    key: \"fractalRay\",\n    value: function fractalRay(time, segmentCallback) {\n      this.time = time;\n      this.currentSegmentCallback = segmentCallback;\n      this.numSubrays = 0;\n      this.initSubray(this.addNewSubray(), this.rayParameters);\n      for (var subrayIndex = 0; subrayIndex < this.numSubrays; subrayIndex++) {\n        var subray = this.subrays[subrayIndex];\n        this.currentSubray = subray;\n        this.randomGenerator.setSeed(subray.seed);\n        subray.endPropagationTime = MathUtils.lerp(subray.birthTime, subray.deathTime, subray.propagationTimeFactor);\n        subray.beginVanishingTime = MathUtils.lerp(subray.deathTime, subray.birthTime, 1 - subray.vanishingTimeFactor);\n        var random1 = this.randomGenerator.random;\n        subray.linPos0.set(random1(), random1(), random1()).multiplyScalar(1e3);\n        subray.linPos1.set(random1(), random1(), random1()).multiplyScalar(1e3);\n        this.timeFraction = (time - subray.birthTime) / (subray.deathTime - subray.birthTime);\n        this.currentSegmentIndex = 0;\n        this.isInitialSegment = true;\n        var segment = this.getNewSegment();\n        segment.iteration = 0;\n        segment.pos0.copy(subray.pos0);\n        segment.pos1.copy(subray.pos1);\n        segment.linPos0.copy(subray.linPos0);\n        segment.linPos1.copy(subray.linPos1);\n        segment.up0.copy(subray.up0);\n        segment.up1.copy(subray.up1);\n        segment.radius0 = subray.radius0;\n        segment.radius1 = subray.radius1;\n        segment.fraction0 = 0;\n        segment.fraction1 = 1;\n        segment.positionVariationFactor = 1 - subray.straightness;\n        this.subrayProbability = this.ramification * Math.pow(this.recursionProbability, subray.recursion) / (1 << subray.maxIterations);\n        this.fractalRayRecursive(segment);\n      }\n      this.currentSegmentCallback = null;\n      this.currentSubray = null;\n    }\n  }, {\n    key: \"fractalRayRecursive\",\n    value: function fractalRayRecursive(segment) {\n      if (segment.iteration >= this.currentSubray.maxIterations) {\n        this.currentSegmentCallback(segment);\n        return;\n      }\n      this.forwards.subVectors(segment.pos1, segment.pos0);\n      var lForwards = this.forwards.length();\n      if (lForwards < 1e-6) {\n        this.forwards.set(0, 0, 0.01);\n        lForwards = this.forwards.length();\n      }\n      var middleRadius = (segment.radius0 + segment.radius1) * 0.5;\n      var middleFraction = (segment.fraction0 + segment.fraction1) * 0.5;\n      var timeDimension = this.time * this.currentSubray.timeScale * Math.pow(2, segment.iteration);\n      this.middlePos.lerpVectors(segment.pos0, segment.pos1, 0.5);\n      this.middleLinPos.lerpVectors(segment.linPos0, segment.linPos1, 0.5);\n      var p = this.middleLinPos;\n      this.newPos.set(this.simplexX.noise4d(p.x, p.y, p.z, timeDimension), this.simplexY.noise4d(p.x, p.y, p.z, timeDimension), this.simplexZ.noise4d(p.x, p.y, p.z, timeDimension));\n      this.newPos.multiplyScalar(segment.positionVariationFactor * lForwards);\n      this.newPos.add(this.middlePos);\n      var newSegment1 = this.getNewSegment();\n      newSegment1.pos0.copy(segment.pos0);\n      newSegment1.pos1.copy(this.newPos);\n      newSegment1.linPos0.copy(segment.linPos0);\n      newSegment1.linPos1.copy(this.middleLinPos);\n      newSegment1.up0.copy(segment.up0);\n      newSegment1.up1.copy(segment.up1);\n      newSegment1.radius0 = segment.radius0;\n      newSegment1.radius1 = middleRadius;\n      newSegment1.fraction0 = segment.fraction0;\n      newSegment1.fraction1 = middleFraction;\n      newSegment1.positionVariationFactor = segment.positionVariationFactor * this.currentSubray.roughness;\n      newSegment1.iteration = segment.iteration + 1;\n      var newSegment2 = this.getNewSegment();\n      newSegment2.pos0.copy(this.newPos);\n      newSegment2.pos1.copy(segment.pos1);\n      newSegment2.linPos0.copy(this.middleLinPos);\n      newSegment2.linPos1.copy(segment.linPos1);\n      this.cross1.crossVectors(segment.up0, this.forwards.normalize());\n      newSegment2.up0.crossVectors(this.forwards, this.cross1).normalize();\n      newSegment2.up1.copy(segment.up1);\n      newSegment2.radius0 = middleRadius;\n      newSegment2.radius1 = segment.radius1;\n      newSegment2.fraction0 = middleFraction;\n      newSegment2.fraction1 = segment.fraction1;\n      newSegment2.positionVariationFactor = segment.positionVariationFactor * this.currentSubray.roughness;\n      newSegment2.iteration = segment.iteration + 1;\n      this.fractalRayRecursive(newSegment1);\n      this.fractalRayRecursive(newSegment2);\n    }\n  }, {\n    key: \"createPrism\",\n    value: function createPrism(segment) {\n      this.forwardsFill.subVectors(segment.pos1, segment.pos0).normalize();\n      if (this.isInitialSegment) {\n        this.currentCreateTriangleVertices(segment.pos0, segment.up0, this.forwardsFill, segment.radius0, 0);\n        this.isInitialSegment = false;\n      }\n      this.currentCreateTriangleVertices(segment.pos1, segment.up0, this.forwardsFill, segment.radius1, segment.fraction1);\n      this.createPrismFaces();\n    }\n  }, {\n    key: \"createTriangleVerticesWithoutUVs\",\n    value: function createTriangleVerticesWithoutUVs(pos, up, forwards, radius) {\n      this.side.crossVectors(up, forwards).multiplyScalar(radius * _LightningStrike.COS30DEG);\n      this.down.copy(up).multiplyScalar(-radius * _LightningStrike.SIN30DEG);\n      var p = this.vPos;\n      var v = this.vertices;\n      p.copy(pos).sub(this.side).add(this.down);\n      v[this.currentCoordinate++] = p.x;\n      v[this.currentCoordinate++] = p.y;\n      v[this.currentCoordinate++] = p.z;\n      p.copy(pos).add(this.side).add(this.down);\n      v[this.currentCoordinate++] = p.x;\n      v[this.currentCoordinate++] = p.y;\n      v[this.currentCoordinate++] = p.z;\n      p.copy(up).multiplyScalar(radius).add(pos);\n      v[this.currentCoordinate++] = p.x;\n      v[this.currentCoordinate++] = p.y;\n      v[this.currentCoordinate++] = p.z;\n      this.currentVertex += 3;\n    }\n  }, {\n    key: \"createTriangleVerticesWithUVs\",\n    value: function createTriangleVerticesWithUVs(pos, up, forwards, radius, u) {\n      this.side.crossVectors(up, forwards).multiplyScalar(radius * _LightningStrike.COS30DEG);\n      this.down.copy(up).multiplyScalar(-radius * _LightningStrike.SIN30DEG);\n      var p = this.vPos;\n      var v = this.vertices;\n      var uv = this.uvs;\n      p.copy(pos).sub(this.side).add(this.down);\n      v[this.currentCoordinate++] = p.x;\n      v[this.currentCoordinate++] = p.y;\n      v[this.currentCoordinate++] = p.z;\n      uv[this.currentUVCoordinate++] = u;\n      uv[this.currentUVCoordinate++] = 0;\n      p.copy(pos).add(this.side).add(this.down);\n      v[this.currentCoordinate++] = p.x;\n      v[this.currentCoordinate++] = p.y;\n      v[this.currentCoordinate++] = p.z;\n      uv[this.currentUVCoordinate++] = u;\n      uv[this.currentUVCoordinate++] = 0.5;\n      p.copy(up).multiplyScalar(radius).add(pos);\n      v[this.currentCoordinate++] = p.x;\n      v[this.currentCoordinate++] = p.y;\n      v[this.currentCoordinate++] = p.z;\n      uv[this.currentUVCoordinate++] = u;\n      uv[this.currentUVCoordinate++] = 1;\n      this.currentVertex += 3;\n    }\n  }, {\n    key: \"createPrismFaces\",\n    value: function createPrismFaces(vertex) {\n      var indices = this.indices;\n      vertex = this.currentVertex - 6;\n      indices[this.currentIndex++] = vertex + 1;\n      indices[this.currentIndex++] = vertex + 2;\n      indices[this.currentIndex++] = vertex + 5;\n      indices[this.currentIndex++] = vertex + 1;\n      indices[this.currentIndex++] = vertex + 5;\n      indices[this.currentIndex++] = vertex + 4;\n      indices[this.currentIndex++] = vertex + 0;\n      indices[this.currentIndex++] = vertex + 1;\n      indices[this.currentIndex++] = vertex + 4;\n      indices[this.currentIndex++] = vertex + 0;\n      indices[this.currentIndex++] = vertex + 4;\n      indices[this.currentIndex++] = vertex + 3;\n      indices[this.currentIndex++] = vertex + 2;\n      indices[this.currentIndex++] = vertex + 0;\n      indices[this.currentIndex++] = vertex + 3;\n      indices[this.currentIndex++] = vertex + 2;\n      indices[this.currentIndex++] = vertex + 3;\n      indices[this.currentIndex++] = vertex + 5;\n    }\n  }, {\n    key: \"createDefaultSubrayCreationCallbacks\",\n    value: function createDefaultSubrayCreationCallbacks() {\n      var random1 = this.randomGenerator.random;\n      this.onDecideSubrayCreation = function (segment, lightningStrike) {\n        var subray = lightningStrike.currentSubray;\n        var period = lightningStrike.rayParameters.subrayPeriod;\n        var dutyCycle = lightningStrike.rayParameters.subrayDutyCycle;\n        var phase0 = lightningStrike.rayParameters.isEternal && subray.recursion == 0 ? -random1() * period : MathUtils.lerp(subray.birthTime, subray.endPropagationTime, segment.fraction0) - random1() * period;\n        var phase = lightningStrike.time - phase0;\n        var currentCycle = Math.floor(phase / period);\n        var childSubraySeed = random1() * (currentCycle + 1);\n        var isActive = phase % period <= dutyCycle * period;\n        var probability = 0;\n        if (isActive) {\n          probability = lightningStrike.subrayProbability;\n        }\n        if (subray.recursion < lightningStrike.maxSubrayRecursion && lightningStrike.numSubrays < lightningStrike.maxSubrays && random1() < probability) {\n          var childSubray = lightningStrike.addNewSubray();\n          var parentSeed = lightningStrike.randomGenerator.getSeed();\n          childSubray.seed = childSubraySeed;\n          lightningStrike.randomGenerator.setSeed(childSubraySeed);\n          childSubray.recursion = subray.recursion + 1;\n          childSubray.maxIterations = Math.max(1, subray.maxIterations - 1);\n          childSubray.linPos0.set(random1(), random1(), random1()).multiplyScalar(1e3);\n          childSubray.linPos1.set(random1(), random1(), random1()).multiplyScalar(1e3);\n          childSubray.up0.copy(subray.up0);\n          childSubray.up1.copy(subray.up1);\n          childSubray.radius0 = segment.radius0 * lightningStrike.rayParameters.radius0Factor;\n          childSubray.radius1 = Math.min(lightningStrike.rayParameters.minRadius, segment.radius1 * lightningStrike.rayParameters.radius1Factor);\n          childSubray.birthTime = phase0 + currentCycle * period;\n          childSubray.deathTime = childSubray.birthTime + period * dutyCycle;\n          if (!lightningStrike.rayParameters.isEternal && subray.recursion == 0) {\n            childSubray.birthTime = Math.max(childSubray.birthTime, subray.birthTime);\n            childSubray.deathTime = Math.min(childSubray.deathTime, subray.deathTime);\n          }\n          childSubray.timeScale = subray.timeScale * 2;\n          childSubray.roughness = subray.roughness;\n          childSubray.straightness = subray.straightness;\n          childSubray.propagationTimeFactor = subray.propagationTimeFactor;\n          childSubray.vanishingTimeFactor = subray.vanishingTimeFactor;\n          lightningStrike.onSubrayCreation(segment, subray, childSubray, lightningStrike);\n          lightningStrike.randomGenerator.setSeed(parentSeed);\n        }\n      };\n      var vec1Pos = new Vector3();\n      var vec2Forward = new Vector3();\n      var vec3Side = new Vector3();\n      var vec4Up = new Vector3();\n      this.onSubrayCreation = function (segment, parentSubray, childSubray, lightningStrike) {\n        lightningStrike.subrayCylinderPosition(segment, parentSubray, childSubray, 0.5, 0.6, 0.2);\n      };\n      this.subrayConePosition = function (segment, parentSubray, childSubray, heightFactor, sideWidthFactor, minSideWidthFactor) {\n        childSubray.pos0.copy(segment.pos0);\n        vec1Pos.subVectors(parentSubray.pos1, parentSubray.pos0);\n        vec2Forward.copy(vec1Pos).normalize();\n        vec1Pos.multiplyScalar(segment.fraction0 + (1 - segment.fraction0) * (random1() * heightFactor));\n        var length = vec1Pos.length();\n        vec3Side.crossVectors(parentSubray.up0, vec2Forward);\n        var angle = 2 * Math.PI * random1();\n        vec3Side.multiplyScalar(Math.cos(angle));\n        vec4Up.copy(parentSubray.up0).multiplyScalar(Math.sin(angle));\n        childSubray.pos1.copy(vec3Side).add(vec4Up).multiplyScalar(length * sideWidthFactor * (minSideWidthFactor + random1() * (1 - minSideWidthFactor))).add(vec1Pos).add(parentSubray.pos0);\n      };\n      this.subrayCylinderPosition = function (segment, parentSubray, childSubray, heightFactor, sideWidthFactor, minSideWidthFactor) {\n        childSubray.pos0.copy(segment.pos0);\n        vec1Pos.subVectors(parentSubray.pos1, parentSubray.pos0);\n        vec2Forward.copy(vec1Pos).normalize();\n        vec1Pos.multiplyScalar(segment.fraction0 + (1 - segment.fraction0) * ((2 * random1() - 1) * heightFactor));\n        var length = vec1Pos.length();\n        vec3Side.crossVectors(parentSubray.up0, vec2Forward);\n        var angle = 2 * Math.PI * random1();\n        vec3Side.multiplyScalar(Math.cos(angle));\n        vec4Up.copy(parentSubray.up0).multiplyScalar(Math.sin(angle));\n        childSubray.pos1.copy(vec3Side).add(vec4Up).multiplyScalar(length * sideWidthFactor * (minSideWidthFactor + random1() * (1 - minSideWidthFactor))).add(vec1Pos).add(parentSubray.pos0);\n      };\n    }\n  }, {\n    key: \"createSubray\",\n    value: function createSubray() {\n      return {\n        seed: 0,\n        maxIterations: 0,\n        recursion: 0,\n        pos0: new Vector3(),\n        pos1: new Vector3(),\n        linPos0: new Vector3(),\n        linPos1: new Vector3(),\n        up0: new Vector3(),\n        up1: new Vector3(),\n        radius0: 0,\n        radius1: 0,\n        birthTime: 0,\n        deathTime: 0,\n        timeScale: 0,\n        roughness: 0,\n        straightness: 0,\n        propagationTimeFactor: 0,\n        vanishingTimeFactor: 0,\n        endPropagationTime: 0,\n        beginVanishingTime: 0\n      };\n    }\n  }, {\n    key: \"createSegment\",\n    value: function createSegment() {\n      return {\n        iteration: 0,\n        pos0: new Vector3(),\n        pos1: new Vector3(),\n        linPos0: new Vector3(),\n        linPos1: new Vector3(),\n        up0: new Vector3(),\n        up1: new Vector3(),\n        radius0: 0,\n        radius1: 0,\n        fraction0: 0,\n        fraction1: 0,\n        positionVariationFactor: 0\n      };\n    }\n  }, {\n    key: \"getNewSegment\",\n    value: function getNewSegment() {\n      return this.raySegments[this.currentSegmentIndex++];\n    }\n  }, {\n    key: \"copy\",\n    value: function copy(source) {\n      _get(_getPrototypeOf(_LightningStrike.prototype), \"copy\", this).call(this, source);\n      this.init(_LightningStrike.copyParameters({}, source.rayParameters));\n      return this;\n    }\n  }, {\n    key: \"clone\",\n    value: function clone() {\n      return new this.constructor(_LightningStrike.copyParameters({}, this.rayParameters));\n    }\n  }], [{\n    key: \"createRandomGenerator\",\n    value: function createRandomGenerator() {\n      var numSeeds = 2053;\n      var seeds = [];\n      for (var i = 0; i < numSeeds; i++) {\n        seeds.push(Math.random());\n      }\n      var generator = {\n        currentSeed: 0,\n        random: function random() {\n          var value = seeds[generator.currentSeed];\n          generator.currentSeed = (generator.currentSeed + 1) % numSeeds;\n          return value;\n        },\n        getSeed: function getSeed() {\n          return generator.currentSeed / numSeeds;\n        },\n        setSeed: function setSeed(seed) {\n          generator.currentSeed = Math.floor(seed * numSeeds) % numSeeds;\n        }\n      };\n      return generator;\n    }\n  }, {\n    key: \"copyParameters\",\n    value: function copyParameters() {\n      var dest = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var source = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var vecCopy = function vecCopy(v) {\n        if (source === dest) {\n          return v;\n        } else {\n          return v.clone();\n        }\n      };\n      dest.sourceOffset = source.sourceOffset !== void 0 ? vecCopy(source.sourceOffset) : new Vector3(0, 100, 0), dest.destOffset = source.destOffset !== void 0 ? vecCopy(source.destOffset) : new Vector3(0, 0, 0), dest.timeScale = source.timeScale !== void 0 ? source.timeScale : 1, dest.roughness = source.roughness !== void 0 ? source.roughness : 0.9, dest.straightness = source.straightness !== void 0 ? source.straightness : 0.7, dest.up0 = source.up0 !== void 0 ? vecCopy(source.up0) : new Vector3(0, 0, 1);\n      dest.up1 = source.up1 !== void 0 ? vecCopy(source.up1) : new Vector3(0, 0, 1), dest.radius0 = source.radius0 !== void 0 ? source.radius0 : 1, dest.radius1 = source.radius1 !== void 0 ? source.radius1 : 1, dest.radius0Factor = source.radius0Factor !== void 0 ? source.radius0Factor : 0.5, dest.radius1Factor = source.radius1Factor !== void 0 ? source.radius1Factor : 0.2, dest.minRadius = source.minRadius !== void 0 ? source.minRadius : 0.2,\n      // These parameters should not be changed after lightning creation. They can be changed but the ray will change its form abruptly:\n      dest.isEternal = source.isEternal !== void 0 ? source.isEternal : source.birthTime === void 0 || source.deathTime === void 0, dest.birthTime = source.birthTime, dest.deathTime = source.deathTime, dest.propagationTimeFactor = source.propagationTimeFactor !== void 0 ? source.propagationTimeFactor : 0.1, dest.vanishingTimeFactor = source.vanishingTimeFactor !== void 0 ? source.vanishingTimeFactor : 0.9, dest.subrayPeriod = source.subrayPeriod !== void 0 ? source.subrayPeriod : 4, dest.subrayDutyCycle = source.subrayDutyCycle !== void 0 ? source.subrayDutyCycle : 0.6;\n      dest.maxIterations = source.maxIterations !== void 0 ? source.maxIterations : 9;\n      dest.isStatic = source.isStatic !== void 0 ? source.isStatic : false;\n      dest.ramification = source.ramification !== void 0 ? source.ramification : 5;\n      dest.maxSubrayRecursion = source.maxSubrayRecursion !== void 0 ? source.maxSubrayRecursion : 3;\n      dest.recursionProbability = source.recursionProbability !== void 0 ? source.recursionProbability : 0.6;\n      dest.generateUVs = source.generateUVs !== void 0 ? source.generateUVs : false;\n      dest.randomGenerator = source.randomGenerator, dest.noiseSeed = source.noiseSeed, dest.onDecideSubrayCreation = source.onDecideSubrayCreation, dest.onSubrayCreation = source.onSubrayCreation;\n      return dest;\n    }\n  }]);\n  return _LightningStrike;\n}(BufferGeometry);\nvar LightningStrike = _LightningStrike;\n// Ray states\n__publicField(LightningStrike, \"RAY_INITIALIZED\", 0);\n__publicField(LightningStrike, \"RAY_UNBORN\", 1);\n__publicField(LightningStrike, \"RAY_PROPAGATING\", 2);\n__publicField(LightningStrike, \"RAY_STEADY\", 3);\n__publicField(LightningStrike, \"RAY_VANISHING\", 4);\n__publicField(LightningStrike, \"RAY_EXTINGUISHED\", 5);\n__publicField(LightningStrike, \"COS30DEG\", Math.cos(30 * Math.PI / 180));\n__publicField(LightningStrike, \"SIN30DEG\", Math.sin(30 * Math.PI / 180));\nexport { LightningStrike };","map":{"version":3,"names":["_LightningStrike","_BufferGeometry","_inherits","_super","_createSuper","_this","rayParameters","arguments","length","undefined","_classCallCheck","call","isLightningStrike","type","init","copyParameters","createMesh","_createClass","key","value","update","time","isStatic","isEternal","birthTime","deathTime","updateMesh","subrays","endPropagationTime","state","RAY_PROPAGATING","beginVanishingTime","RAY_VANISHING","RAY_STEADY","visible","RAY_UNBORN","RAY_EXTINGUISHED","maxIterations","Math","floor","ramification","maxSubrayRecursion","recursionProbability","generateUVs","randomGenerator","seedGenerator","noiseSeed","setSeed","createRandomGenerator","onDecideSubrayCreation","createDefaultSubrayCreationCallbacks","onSubrayCreation","RAY_INITIALIZED","maxSubrays","ceil","pow","max","maxRaySegments","i","push","createSubray","raySegments","createSegment","timeFraction","currentSegmentCallback","currentCreateTriangleVertices","createTriangleVerticesWithUVs","createTriangleVerticesWithoutUVs","numSubrays","currentSubray","currentSegmentIndex","isInitialSegment","subrayProbability","currentVertex","currentIndex","currentCoordinate","currentUVCoordinate","vertices","uvs","indices","positionAttribute","uvsAttribute","simplexX","SimplexNoise","simplexY","simplexZ","forwards","Vector3","forwardsFill","side","down","middlePos","middleLinPos","newPos","vPos","cross1","maxDrawableSegmentsPerSubRay","maxVerts","maxIndices","Float32Array","Uint32Array","fillMesh","setIndex","Uint32BufferAttribute","Float32BufferAttribute","setAttribute","index","usage","DynamicDrawUsage","array","drawRange","count","needsUpdate","scope","fractalRay","fillVertices","segment","subray","recursion","createPrism","fraction0","propagationTimeFactor","vanishingTimeFactor","fraction1","addNewSubray","initSubray","pos0","copy","sourceOffset","pos1","destOffset","up0","up1","radius0","radius1","timeScale","roughness","straightness","seed","segmentCallback","subrayIndex","MathUtils","lerp","random1","random","linPos0","set","multiplyScalar","linPos1","getNewSegment","iteration","positionVariationFactor","fractalRayRecursive","subVectors","lForwards","middleRadius","middleFraction","timeDimension","lerpVectors","p","noise4d","x","y","z","add","newSegment1","newSegment2","crossVectors","normalize","createPrismFaces","pos","up","radius","COS30DEG","SIN30DEG","v","sub","u","uv","vertex","lightningStrike","period","subrayPeriod","dutyCycle","subrayDutyCycle","phase0","phase","currentCycle","childSubraySeed","isActive","probability","childSubray","parentSeed","getSeed","radius0Factor","min","minRadius","radius1Factor","vec1Pos","vec2Forward","vec3Side","vec4Up","parentSubray","subrayCylinderPosition","subrayConePosition","heightFactor","sideWidthFactor","minSideWidthFactor","angle","PI","cos","sin","source","_get","_getPrototypeOf","prototype","clone","constructor","numSeeds","seeds","generator","currentSeed","dest","vecCopy","BufferGeometry","LightningStrike","__publicField"],"sources":["C:\\Users\\Nayyu\\Desktop\\skibidai-public-build\\node_modules\\src\\geometries\\LightningStrike.js"],"sourcesContent":["import {\n  BufferGeometry,\n  DynamicDrawUsage,\n  Float32BufferAttribute,\n  MathUtils,\n  Uint32BufferAttribute,\n  Vector3,\n} from 'three'\nimport { SimplexNoise } from '../math/SimplexNoise'\n\n/**\n * @fileoverview LightningStrike object for creating lightning strikes and voltaic arcs.\n *\n *\n * Usage\n *\n * var myRay = new LightningStrike( paramsObject );\n * var myRayMesh = new THREE.Mesh( myRay, myMaterial );\n * scene.add( myRayMesh );\n * ...\n * myRay.update( currentTime );\n *\n * The \"currentTime\" can vary its rate, go forwards, backwards or even jump, but it cannot be negative.\n *\n * You should normally leave the ray position to (0, 0, 0). You should control it by changing the sourceOffset and destOffset parameters.\n *\n *\n * LightningStrike parameters\n *\n * The paramsObject can contain any of the following parameters.\n *\n * Legend:\n * 'LightningStrike' (also called 'ray'): An independent voltaic arc with its ramifications and defined with a set of parameters.\n * 'Subray': A ramification of the ray. It is not a LightningStrike object.\n * 'Segment': A linear segment piece of a subray.\n * 'Leaf segment': A ray segment which cannot be smaller.\n *\n *\n * The following parameters can be changed any time and if they vary smoothly, the ray form will also change smoothly:\n *\n * @param {Vector3} sourceOffset The point where the ray starts.\n *\n * @param {Vector3} destOffset The point where the ray ends.\n *\n * @param {double} timeScale The rate at wich the ray form changes in time. Default: 1\n *\n * @param {double} roughness From 0 to 1. The higher the value, the more wrinkled is the ray. Default: 0.9\n *\n * @param {double} straightness From 0 to 1. The higher the value, the more straight will be a subray path. Default: 0.7\n *\n * @param {Vector3} up0 Ray 'up' direction at the ray starting point. Must be normalized. It should be perpendicular to the ray forward direction but it doesn't matter much.\n *\n * @param {Vector3} up1 Like the up0 parameter but at the end of the ray. Must be normalized.\n *\n * @param {double} radius0 Radius of the main ray trunk at the start point. Default: 1\n *\n * @param {double} radius1 Radius of the main ray trunk at the end point. Default: 1\n *\n * @param {double} radius0Factor The radius0 of a subray is this factor times the radius0 of its parent subray. Default: 0.5\n *\n * @param {double} radius1Factor The radius1 of a subray is this factor times the radius1 of its parent subray. Default: 0.2\n *\n * @param {minRadius} Minimum value a subray radius0 or radius1 can get. Default: 0.1\n *\n *\n * The following parameters should not be changed after lightning creation. They can be changed but the ray will change its form abruptly:\n *\n * @param {boolean} isEternal If true the ray never extinguishes. Otherwise its life is controlled by the 'birthTime' and 'deathTime' parameters. Default: true if any of those two parameters is undefined.\n *\n * @param {double} birthTime The time at which the ray starts its life and begins propagating. Only if isEternal is false. Default: None.\n *\n * @param {double} deathTime The time at which the ray ends vanishing and its life. Only if isEternal is false. Default: None.\n *\n * @param {double} propagationTimeFactor From 0 to 1. Lifetime factor at which the ray ends propagating and enters the steady phase. For example, 0.1 means it is propagating 1/10 of its lifetime. Default: 0.1\n *\n * @param {double} vanishingTimeFactor From 0 to 1. Lifetime factor at which the ray ends the steady phase and begins vanishing. For example, 0.9 means it is vanishing 1/10 of its lifetime. Default: 0.9\n *\n * @param {double} subrayPeriod Subrays cycle periodically. This is their time period. Default: 4\n *\n * @param {double} subrayDutyCycle From 0 to 1. This is the fraction of time a subray is active. Default: 0.6\n *\n *\n * These parameters cannot change after lightning creation:\n *\n * @param {integer} maxIterations: Greater than 0. The number of ray's leaf segments is 2**maxIterations. Default: 9\n *\n * @param {boolean} isStatic Set to true only for rays which won't change over time and are not attached to moving objects (Rare case). It is used to set the vertex buffers non-dynamic. You can omit calling update() for these rays.\n *\n * @param {integer} ramification Greater than 0. Maximum number of child subrays a subray can have. Default: 5\n *\n * @param {integer} maxSubrayRecursion Greater than 0. Maximum level of recursion (subray descendant generations). Default: 3\n *\n * @param {double} recursionProbability From 0 to 1. The lower the value, the less chance each new generation of subrays has to generate new subrays. Default: 0.6\n *\n * @param {boolean} generateUVs If true, the ray geometry will have uv coordinates generated. u runs along the ray, and v across its perimeter. Default: false.\n *\n * @param {Object} randomGenerator Set here your random number generator which will seed the SimplexNoise and other decisions during ray tree creation.\n * It can be used to generate repeatable rays. For that, set also the noiseSeed parameter, and each ray created with that generator and seed pair will be identical in time.\n * The randomGenerator parameter should be an object with a random() function similar to Math.random, but seedable.\n * It must have also a getSeed() method, which returns the current seed, and a setSeed( seed ) method, which accepts as seed a fractional number from 0 to 1, as well as any other number.\n * The default value is an internal generator for some uses and Math.random for others (It is non-repeatable even if noiseSeed is supplied)\n *\n * @param {double} noiseSeed Seed used to make repeatable rays (see the randomGenerator)\n *\n * @param {function} onDecideSubrayCreation Set this to change the callback which decides subray creation. You can look at the default callback in the code (createDefaultSubrayCreationCallbacks)for more info.\n *\n * @param {function} onSubrayCreation This is another callback, more simple than the previous one. It can be used to adapt the form of subrays or other parameters once a subray has been created and initialized. It is used in the examples to adapt subrays to a sphere or to a plane.\n *\n *\n */\n\nclass LightningStrike extends BufferGeometry {\n  // Ray states\n  static RAY_INITIALIZED = 0\n  static RAY_UNBORN = 1\n  static RAY_PROPAGATING = 2\n  static RAY_STEADY = 3\n  static RAY_VANISHING = 4\n  static RAY_EXTINGUISHED = 5\n\n  static COS30DEG = Math.cos((30 * Math.PI) / 180)\n  static SIN30DEG = Math.sin((30 * Math.PI) / 180)\n\n  constructor(rayParameters = {}) {\n    super()\n\n    this.isLightningStrike = true\n\n    this.type = 'LightningStrike'\n\n    // Set parameters, and set undefined parameters to default values\n    this.init(LightningStrike.copyParameters(rayParameters, rayParameters))\n\n    // Creates and populates the mesh\n    this.createMesh()\n  }\n\n  static createRandomGenerator() {\n    const numSeeds = 2053\n    const seeds = []\n\n    for (let i = 0; i < numSeeds; i++) {\n      seeds.push(Math.random())\n    }\n\n    const generator = {\n      currentSeed: 0,\n\n      random: function () {\n        const value = seeds[generator.currentSeed]\n\n        generator.currentSeed = (generator.currentSeed + 1) % numSeeds\n\n        return value\n      },\n\n      getSeed: function () {\n        return generator.currentSeed / numSeeds\n      },\n\n      setSeed: function (seed) {\n        generator.currentSeed = Math.floor(seed * numSeeds) % numSeeds\n      },\n    }\n\n    return generator\n  }\n\n  static copyParameters(dest = {}, source = {}) {\n    const vecCopy = function (v) {\n      if (source === dest) {\n        return v\n      } else {\n        return v.clone()\n      }\n    }\n\n    ;(dest.sourceOffset = source.sourceOffset !== undefined ? vecCopy(source.sourceOffset) : new Vector3(0, 100, 0)),\n      (dest.destOffset = source.destOffset !== undefined ? vecCopy(source.destOffset) : new Vector3(0, 0, 0)),\n      (dest.timeScale = source.timeScale !== undefined ? source.timeScale : 1),\n      (dest.roughness = source.roughness !== undefined ? source.roughness : 0.9),\n      (dest.straightness = source.straightness !== undefined ? source.straightness : 0.7),\n      (dest.up0 = source.up0 !== undefined ? vecCopy(source.up0) : new Vector3(0, 0, 1))\n    ;(dest.up1 = source.up1 !== undefined ? vecCopy(source.up1) : new Vector3(0, 0, 1)),\n      (dest.radius0 = source.radius0 !== undefined ? source.radius0 : 1),\n      (dest.radius1 = source.radius1 !== undefined ? source.radius1 : 1),\n      (dest.radius0Factor = source.radius0Factor !== undefined ? source.radius0Factor : 0.5),\n      (dest.radius1Factor = source.radius1Factor !== undefined ? source.radius1Factor : 0.2),\n      (dest.minRadius = source.minRadius !== undefined ? source.minRadius : 0.2),\n      // These parameters should not be changed after lightning creation. They can be changed but the ray will change its form abruptly:\n\n      (dest.isEternal =\n        source.isEternal !== undefined\n          ? source.isEternal\n          : source.birthTime === undefined || source.deathTime === undefined),\n      (dest.birthTime = source.birthTime),\n      (dest.deathTime = source.deathTime),\n      (dest.propagationTimeFactor = source.propagationTimeFactor !== undefined ? source.propagationTimeFactor : 0.1),\n      (dest.vanishingTimeFactor = source.vanishingTimeFactor !== undefined ? source.vanishingTimeFactor : 0.9),\n      (dest.subrayPeriod = source.subrayPeriod !== undefined ? source.subrayPeriod : 4),\n      (dest.subrayDutyCycle = source.subrayDutyCycle !== undefined ? source.subrayDutyCycle : 0.6)\n\n    // These parameters cannot change after lightning creation:\n\n    dest.maxIterations = source.maxIterations !== undefined ? source.maxIterations : 9\n    dest.isStatic = source.isStatic !== undefined ? source.isStatic : false\n    dest.ramification = source.ramification !== undefined ? source.ramification : 5\n    dest.maxSubrayRecursion = source.maxSubrayRecursion !== undefined ? source.maxSubrayRecursion : 3\n    dest.recursionProbability = source.recursionProbability !== undefined ? source.recursionProbability : 0.6\n    dest.generateUVs = source.generateUVs !== undefined ? source.generateUVs : false\n    ;(dest.randomGenerator = source.randomGenerator),\n      (dest.noiseSeed = source.noiseSeed),\n      (dest.onDecideSubrayCreation = source.onDecideSubrayCreation),\n      (dest.onSubrayCreation = source.onSubrayCreation)\n\n    return dest\n  }\n\n  update(time) {\n    if (this.isStatic) return\n\n    if (\n      this.rayParameters.isEternal ||\n      (this.rayParameters.birthTime <= time && time <= this.rayParameters.deathTime)\n    ) {\n      this.updateMesh(time)\n\n      if (time < this.subrays[0].endPropagationTime) {\n        this.state = LightningStrike.RAY_PROPAGATING\n      } else if (time > this.subrays[0].beginVanishingTime) {\n        this.state = LightningStrike.RAY_VANISHING\n      } else {\n        this.state = LightningStrike.RAY_STEADY\n      }\n\n      this.visible = true\n    } else {\n      this.visible = false\n\n      if (time < this.rayParameters.birthTime) {\n        this.state = LightningStrike.RAY_UNBORN\n      } else {\n        this.state = LightningStrike.RAY_EXTINGUISHED\n      }\n    }\n  }\n\n  init(rayParameters) {\n    // Init all the state from the parameters\n\n    this.rayParameters = rayParameters\n\n    // These parameters cannot change after lightning creation:\n\n    this.maxIterations = rayParameters.maxIterations !== undefined ? Math.floor(rayParameters.maxIterations) : 9\n    rayParameters.maxIterations = this.maxIterations\n    this.isStatic = rayParameters.isStatic !== undefined ? rayParameters.isStatic : false\n    rayParameters.isStatic = this.isStatic\n    this.ramification = rayParameters.ramification !== undefined ? Math.floor(rayParameters.ramification) : 5\n    rayParameters.ramification = this.ramification\n    this.maxSubrayRecursion =\n      rayParameters.maxSubrayRecursion !== undefined ? Math.floor(rayParameters.maxSubrayRecursion) : 3\n    rayParameters.maxSubrayRecursion = this.maxSubrayRecursion\n    this.recursionProbability =\n      rayParameters.recursionProbability !== undefined ? rayParameters.recursionProbability : 0.6\n    rayParameters.recursionProbability = this.recursionProbability\n    this.generateUVs = rayParameters.generateUVs !== undefined ? rayParameters.generateUVs : false\n    rayParameters.generateUVs = this.generateUVs\n\n    // Random generator\n    if (rayParameters.randomGenerator !== undefined) {\n      this.randomGenerator = rayParameters.randomGenerator\n      this.seedGenerator = rayParameters.randomGenerator\n\n      if (rayParameters.noiseSeed !== undefined) {\n        this.seedGenerator.setSeed(rayParameters.noiseSeed)\n      }\n    } else {\n      this.randomGenerator = LightningStrike.createRandomGenerator()\n      this.seedGenerator = Math\n    }\n\n    // Ray creation callbacks\n    if (rayParameters.onDecideSubrayCreation !== undefined) {\n      this.onDecideSubrayCreation = rayParameters.onDecideSubrayCreation\n    } else {\n      this.createDefaultSubrayCreationCallbacks()\n\n      if (rayParameters.onSubrayCreation !== undefined) {\n        this.onSubrayCreation = rayParameters.onSubrayCreation\n      }\n    }\n\n    // Internal state\n\n    this.state = LightningStrike.RAY_INITIALIZED\n\n    this.maxSubrays = Math.ceil(1 + Math.pow(this.ramification, Math.max(0, this.maxSubrayRecursion - 1)))\n    rayParameters.maxSubrays = this.maxSubrays\n\n    this.maxRaySegments = 2 * (1 << this.maxIterations)\n\n    this.subrays = []\n\n    for (let i = 0; i < this.maxSubrays; i++) {\n      this.subrays.push(this.createSubray())\n    }\n\n    this.raySegments = []\n\n    for (let i = 0; i < this.maxRaySegments; i++) {\n      this.raySegments.push(this.createSegment())\n    }\n\n    this.time = 0\n    this.timeFraction = 0\n    this.currentSegmentCallback = null\n    this.currentCreateTriangleVertices = this.generateUVs\n      ? this.createTriangleVerticesWithUVs\n      : this.createTriangleVerticesWithoutUVs\n    this.numSubrays = 0\n    this.currentSubray = null\n    this.currentSegmentIndex = 0\n    this.isInitialSegment = false\n    this.subrayProbability = 0\n\n    this.currentVertex = 0\n    this.currentIndex = 0\n    this.currentCoordinate = 0\n    this.currentUVCoordinate = 0\n    this.vertices = null\n    this.uvs = null\n    this.indices = null\n    this.positionAttribute = null\n    this.uvsAttribute = null\n\n    this.simplexX = new SimplexNoise(this.seedGenerator)\n    this.simplexY = new SimplexNoise(this.seedGenerator)\n    this.simplexZ = new SimplexNoise(this.seedGenerator)\n\n    // Temp vectors\n    this.forwards = new Vector3()\n    this.forwardsFill = new Vector3()\n    this.side = new Vector3()\n    this.down = new Vector3()\n    this.middlePos = new Vector3()\n    this.middleLinPos = new Vector3()\n    this.newPos = new Vector3()\n    this.vPos = new Vector3()\n    this.cross1 = new Vector3()\n  }\n\n  createMesh() {\n    const maxDrawableSegmentsPerSubRay = 1 << this.maxIterations\n\n    const maxVerts = 3 * (maxDrawableSegmentsPerSubRay + 1) * this.maxSubrays\n    const maxIndices = 18 * maxDrawableSegmentsPerSubRay * this.maxSubrays\n\n    this.vertices = new Float32Array(maxVerts * 3)\n    this.indices = new Uint32Array(maxIndices)\n\n    if (this.generateUVs) {\n      this.uvs = new Float32Array(maxVerts * 2)\n    }\n\n    // Populate the mesh\n    this.fillMesh(0)\n\n    this.setIndex(new Uint32BufferAttribute(this.indices, 1))\n\n    this.positionAttribute = new Float32BufferAttribute(this.vertices, 3)\n    this.setAttribute('position', this.positionAttribute)\n\n    if (this.generateUVs) {\n      this.uvsAttribute = new Float32BufferAttribute(new Float32Array(this.uvs), 2)\n      this.setAttribute('uv', this.uvsAttribute)\n    }\n\n    if (!this.isStatic) {\n      this.index.usage = DynamicDrawUsage\n      this.positionAttribute.usage = DynamicDrawUsage\n\n      if (this.generateUVs) {\n        this.uvsAttribute.usage = DynamicDrawUsage\n      }\n    }\n\n    // Store buffers for later modification\n    this.vertices = this.positionAttribute.array\n    this.indices = this.index.array\n\n    if (this.generateUVs) {\n      this.uvs = this.uvsAttribute.array\n    }\n  }\n\n  updateMesh(time) {\n    this.fillMesh(time)\n\n    this.drawRange.count = this.currentIndex\n\n    this.index.needsUpdate = true\n\n    this.positionAttribute.needsUpdate = true\n\n    if (this.generateUVs) {\n      this.uvsAttribute.needsUpdate = true\n    }\n  }\n\n  fillMesh(time) {\n    const scope = this\n\n    this.currentVertex = 0\n    this.currentIndex = 0\n    this.currentCoordinate = 0\n    this.currentUVCoordinate = 0\n\n    this.fractalRay(time, function fillVertices(segment) {\n      const subray = scope.currentSubray\n\n      if (time < subray.birthTime) {\n        //&& ( ! this.rayParameters.isEternal || scope.currentSubray.recursion > 0 ) ) {\n\n        return\n      } else if (this.rayParameters.isEternal && scope.currentSubray.recursion == 0) {\n        // Eternal rays don't propagate nor vanish, but its subrays do\n\n        scope.createPrism(segment)\n\n        scope.onDecideSubrayCreation(segment, scope)\n      } else if (time < subray.endPropagationTime) {\n        if (scope.timeFraction >= segment.fraction0 * subray.propagationTimeFactor) {\n          // Ray propagation has arrived to this segment\n\n          scope.createPrism(segment)\n\n          scope.onDecideSubrayCreation(segment, scope)\n        }\n      } else if (time < subray.beginVanishingTime) {\n        // Ray is steady (nor propagating nor vanishing)\n\n        scope.createPrism(segment)\n\n        scope.onDecideSubrayCreation(segment, scope)\n      } else {\n        if (scope.timeFraction <= subray.vanishingTimeFactor + segment.fraction1 * (1 - subray.vanishingTimeFactor)) {\n          // Segment has not yet vanished\n\n          scope.createPrism(segment)\n        }\n\n        scope.onDecideSubrayCreation(segment, scope)\n      }\n    })\n  }\n\n  addNewSubray(/*rayParameters*/) {\n    return this.subrays[this.numSubrays++]\n  }\n\n  initSubray(subray, rayParameters) {\n    subray.pos0.copy(rayParameters.sourceOffset)\n    subray.pos1.copy(rayParameters.destOffset)\n    subray.up0.copy(rayParameters.up0)\n    subray.up1.copy(rayParameters.up1)\n    subray.radius0 = rayParameters.radius0\n    subray.radius1 = rayParameters.radius1\n    subray.birthTime = rayParameters.birthTime\n    subray.deathTime = rayParameters.deathTime\n    subray.timeScale = rayParameters.timeScale\n    subray.roughness = rayParameters.roughness\n    subray.straightness = rayParameters.straightness\n    subray.propagationTimeFactor = rayParameters.propagationTimeFactor\n    subray.vanishingTimeFactor = rayParameters.vanishingTimeFactor\n\n    subray.maxIterations = this.maxIterations\n    subray.seed = rayParameters.noiseSeed !== undefined ? rayParameters.noiseSeed : 0\n    subray.recursion = 0\n  }\n\n  fractalRay(time, segmentCallback) {\n    this.time = time\n    this.currentSegmentCallback = segmentCallback\n    this.numSubrays = 0\n\n    // Add the top level subray\n    this.initSubray(this.addNewSubray(), this.rayParameters)\n\n    // Process all subrays that are being generated until consuming all of them\n    for (let subrayIndex = 0; subrayIndex < this.numSubrays; subrayIndex++) {\n      const subray = this.subrays[subrayIndex]\n      this.currentSubray = subray\n\n      this.randomGenerator.setSeed(subray.seed)\n\n      subray.endPropagationTime = MathUtils.lerp(subray.birthTime, subray.deathTime, subray.propagationTimeFactor)\n      subray.beginVanishingTime = MathUtils.lerp(subray.deathTime, subray.birthTime, 1 - subray.vanishingTimeFactor)\n\n      const random1 = this.randomGenerator.random\n      subray.linPos0.set(random1(), random1(), random1()).multiplyScalar(1000)\n      subray.linPos1.set(random1(), random1(), random1()).multiplyScalar(1000)\n\n      this.timeFraction = (time - subray.birthTime) / (subray.deathTime - subray.birthTime)\n\n      this.currentSegmentIndex = 0\n      this.isInitialSegment = true\n\n      const segment = this.getNewSegment()\n      segment.iteration = 0\n      segment.pos0.copy(subray.pos0)\n      segment.pos1.copy(subray.pos1)\n      segment.linPos0.copy(subray.linPos0)\n      segment.linPos1.copy(subray.linPos1)\n      segment.up0.copy(subray.up0)\n      segment.up1.copy(subray.up1)\n      segment.radius0 = subray.radius0\n      segment.radius1 = subray.radius1\n      segment.fraction0 = 0\n      segment.fraction1 = 1\n      segment.positionVariationFactor = 1 - subray.straightness\n\n      this.subrayProbability =\n        (this.ramification * Math.pow(this.recursionProbability, subray.recursion)) / (1 << subray.maxIterations)\n\n      this.fractalRayRecursive(segment)\n    }\n\n    this.currentSegmentCallback = null\n    this.currentSubray = null\n  }\n\n  fractalRayRecursive(segment) {\n    // Leave recursion condition\n    if (segment.iteration >= this.currentSubray.maxIterations) {\n      this.currentSegmentCallback(segment)\n\n      return\n    }\n\n    // Interpolation\n    this.forwards.subVectors(segment.pos1, segment.pos0)\n    let lForwards = this.forwards.length()\n\n    if (lForwards < 0.000001) {\n      this.forwards.set(0, 0, 0.01)\n      lForwards = this.forwards.length()\n    }\n\n    const middleRadius = (segment.radius0 + segment.radius1) * 0.5\n    const middleFraction = (segment.fraction0 + segment.fraction1) * 0.5\n\n    const timeDimension = this.time * this.currentSubray.timeScale * Math.pow(2, segment.iteration)\n\n    this.middlePos.lerpVectors(segment.pos0, segment.pos1, 0.5)\n    this.middleLinPos.lerpVectors(segment.linPos0, segment.linPos1, 0.5)\n    const p = this.middleLinPos\n\n    // Noise\n    this.newPos.set(\n      this.simplexX.noise4d(p.x, p.y, p.z, timeDimension),\n      this.simplexY.noise4d(p.x, p.y, p.z, timeDimension),\n      this.simplexZ.noise4d(p.x, p.y, p.z, timeDimension),\n    )\n\n    this.newPos.multiplyScalar(segment.positionVariationFactor * lForwards)\n    this.newPos.add(this.middlePos)\n\n    // Recursion\n\n    const newSegment1 = this.getNewSegment()\n    newSegment1.pos0.copy(segment.pos0)\n    newSegment1.pos1.copy(this.newPos)\n    newSegment1.linPos0.copy(segment.linPos0)\n    newSegment1.linPos1.copy(this.middleLinPos)\n    newSegment1.up0.copy(segment.up0)\n    newSegment1.up1.copy(segment.up1)\n    newSegment1.radius0 = segment.radius0\n    newSegment1.radius1 = middleRadius\n    newSegment1.fraction0 = segment.fraction0\n    newSegment1.fraction1 = middleFraction\n    newSegment1.positionVariationFactor = segment.positionVariationFactor * this.currentSubray.roughness\n    newSegment1.iteration = segment.iteration + 1\n\n    const newSegment2 = this.getNewSegment()\n    newSegment2.pos0.copy(this.newPos)\n    newSegment2.pos1.copy(segment.pos1)\n    newSegment2.linPos0.copy(this.middleLinPos)\n    newSegment2.linPos1.copy(segment.linPos1)\n    this.cross1.crossVectors(segment.up0, this.forwards.normalize())\n    newSegment2.up0.crossVectors(this.forwards, this.cross1).normalize()\n    newSegment2.up1.copy(segment.up1)\n    newSegment2.radius0 = middleRadius\n    newSegment2.radius1 = segment.radius1\n    newSegment2.fraction0 = middleFraction\n    newSegment2.fraction1 = segment.fraction1\n    newSegment2.positionVariationFactor = segment.positionVariationFactor * this.currentSubray.roughness\n    newSegment2.iteration = segment.iteration + 1\n\n    this.fractalRayRecursive(newSegment1)\n\n    this.fractalRayRecursive(newSegment2)\n  }\n\n  createPrism(segment) {\n    // Creates one triangular prism and its vertices at the segment\n\n    this.forwardsFill.subVectors(segment.pos1, segment.pos0).normalize()\n\n    if (this.isInitialSegment) {\n      this.currentCreateTriangleVertices(segment.pos0, segment.up0, this.forwardsFill, segment.radius0, 0)\n\n      this.isInitialSegment = false\n    }\n\n    this.currentCreateTriangleVertices(segment.pos1, segment.up0, this.forwardsFill, segment.radius1, segment.fraction1)\n\n    this.createPrismFaces()\n  }\n\n  createTriangleVerticesWithoutUVs(pos, up, forwards, radius) {\n    // Create an equilateral triangle (only vertices)\n\n    this.side.crossVectors(up, forwards).multiplyScalar(radius * LightningStrike.COS30DEG)\n    this.down.copy(up).multiplyScalar(-radius * LightningStrike.SIN30DEG)\n\n    const p = this.vPos\n    const v = this.vertices\n\n    p.copy(pos).sub(this.side).add(this.down)\n\n    v[this.currentCoordinate++] = p.x\n    v[this.currentCoordinate++] = p.y\n    v[this.currentCoordinate++] = p.z\n\n    p.copy(pos).add(this.side).add(this.down)\n\n    v[this.currentCoordinate++] = p.x\n    v[this.currentCoordinate++] = p.y\n    v[this.currentCoordinate++] = p.z\n\n    p.copy(up).multiplyScalar(radius).add(pos)\n\n    v[this.currentCoordinate++] = p.x\n    v[this.currentCoordinate++] = p.y\n    v[this.currentCoordinate++] = p.z\n\n    this.currentVertex += 3\n  }\n\n  createTriangleVerticesWithUVs(pos, up, forwards, radius, u) {\n    // Create an equilateral triangle (only vertices)\n\n    this.side.crossVectors(up, forwards).multiplyScalar(radius * LightningStrike.COS30DEG)\n    this.down.copy(up).multiplyScalar(-radius * LightningStrike.SIN30DEG)\n\n    const p = this.vPos\n    const v = this.vertices\n    const uv = this.uvs\n\n    p.copy(pos).sub(this.side).add(this.down)\n\n    v[this.currentCoordinate++] = p.x\n    v[this.currentCoordinate++] = p.y\n    v[this.currentCoordinate++] = p.z\n\n    uv[this.currentUVCoordinate++] = u\n    uv[this.currentUVCoordinate++] = 0\n\n    p.copy(pos).add(this.side).add(this.down)\n\n    v[this.currentCoordinate++] = p.x\n    v[this.currentCoordinate++] = p.y\n    v[this.currentCoordinate++] = p.z\n\n    uv[this.currentUVCoordinate++] = u\n    uv[this.currentUVCoordinate++] = 0.5\n\n    p.copy(up).multiplyScalar(radius).add(pos)\n\n    v[this.currentCoordinate++] = p.x\n    v[this.currentCoordinate++] = p.y\n    v[this.currentCoordinate++] = p.z\n\n    uv[this.currentUVCoordinate++] = u\n    uv[this.currentUVCoordinate++] = 1\n\n    this.currentVertex += 3\n  }\n\n  createPrismFaces(vertex /*, index*/) {\n    const indices = this.indices\n    vertex = this.currentVertex - 6\n\n    indices[this.currentIndex++] = vertex + 1\n    indices[this.currentIndex++] = vertex + 2\n    indices[this.currentIndex++] = vertex + 5\n    indices[this.currentIndex++] = vertex + 1\n    indices[this.currentIndex++] = vertex + 5\n    indices[this.currentIndex++] = vertex + 4\n    indices[this.currentIndex++] = vertex + 0\n    indices[this.currentIndex++] = vertex + 1\n    indices[this.currentIndex++] = vertex + 4\n    indices[this.currentIndex++] = vertex + 0\n    indices[this.currentIndex++] = vertex + 4\n    indices[this.currentIndex++] = vertex + 3\n    indices[this.currentIndex++] = vertex + 2\n    indices[this.currentIndex++] = vertex + 0\n    indices[this.currentIndex++] = vertex + 3\n    indices[this.currentIndex++] = vertex + 2\n    indices[this.currentIndex++] = vertex + 3\n    indices[this.currentIndex++] = vertex + 5\n  }\n\n  createDefaultSubrayCreationCallbacks() {\n    const random1 = this.randomGenerator.random\n\n    this.onDecideSubrayCreation = function (segment, lightningStrike) {\n      // Decide subrays creation at parent (sub)ray segment\n\n      const subray = lightningStrike.currentSubray\n\n      const period = lightningStrike.rayParameters.subrayPeriod\n      const dutyCycle = lightningStrike.rayParameters.subrayDutyCycle\n\n      const phase0 =\n        lightningStrike.rayParameters.isEternal && subray.recursion == 0\n          ? -random1() * period\n          : MathUtils.lerp(subray.birthTime, subray.endPropagationTime, segment.fraction0) - random1() * period\n\n      const phase = lightningStrike.time - phase0\n      const currentCycle = Math.floor(phase / period)\n\n      const childSubraySeed = random1() * (currentCycle + 1)\n\n      const isActive = phase % period <= dutyCycle * period\n\n      let probability = 0\n\n      if (isActive) {\n        probability = lightningStrike.subrayProbability\n        // Distribution test: probability *= segment.fraction0 > 0.5 && segment.fraction0 < 0.9 ? 1 / 0.4 : 0;\n      }\n\n      if (\n        subray.recursion < lightningStrike.maxSubrayRecursion &&\n        lightningStrike.numSubrays < lightningStrike.maxSubrays &&\n        random1() < probability\n      ) {\n        const childSubray = lightningStrike.addNewSubray()\n\n        const parentSeed = lightningStrike.randomGenerator.getSeed()\n        childSubray.seed = childSubraySeed\n        lightningStrike.randomGenerator.setSeed(childSubraySeed)\n\n        childSubray.recursion = subray.recursion + 1\n        childSubray.maxIterations = Math.max(1, subray.maxIterations - 1)\n\n        childSubray.linPos0.set(random1(), random1(), random1()).multiplyScalar(1000)\n        childSubray.linPos1.set(random1(), random1(), random1()).multiplyScalar(1000)\n        childSubray.up0.copy(subray.up0)\n        childSubray.up1.copy(subray.up1)\n        childSubray.radius0 = segment.radius0 * lightningStrike.rayParameters.radius0Factor\n        childSubray.radius1 = Math.min(\n          lightningStrike.rayParameters.minRadius,\n          segment.radius1 * lightningStrike.rayParameters.radius1Factor,\n        )\n\n        childSubray.birthTime = phase0 + currentCycle * period\n        childSubray.deathTime = childSubray.birthTime + period * dutyCycle\n\n        if (!lightningStrike.rayParameters.isEternal && subray.recursion == 0) {\n          childSubray.birthTime = Math.max(childSubray.birthTime, subray.birthTime)\n          childSubray.deathTime = Math.min(childSubray.deathTime, subray.deathTime)\n        }\n\n        childSubray.timeScale = subray.timeScale * 2\n        childSubray.roughness = subray.roughness\n        childSubray.straightness = subray.straightness\n        childSubray.propagationTimeFactor = subray.propagationTimeFactor\n        childSubray.vanishingTimeFactor = subray.vanishingTimeFactor\n\n        lightningStrike.onSubrayCreation(segment, subray, childSubray, lightningStrike)\n\n        lightningStrike.randomGenerator.setSeed(parentSeed)\n      }\n    }\n\n    const vec1Pos = new Vector3()\n    const vec2Forward = new Vector3()\n    const vec3Side = new Vector3()\n    const vec4Up = new Vector3()\n\n    this.onSubrayCreation = function (segment, parentSubray, childSubray, lightningStrike) {\n      // Decide childSubray origin and destination positions (pos0 and pos1) and possibly other properties of childSubray\n\n      // Just use the default cone position generator\n      lightningStrike.subrayCylinderPosition(segment, parentSubray, childSubray, 0.5, 0.6, 0.2)\n    }\n\n    this.subrayConePosition = function (\n      segment,\n      parentSubray,\n      childSubray,\n      heightFactor,\n      sideWidthFactor,\n      minSideWidthFactor,\n    ) {\n      // Sets childSubray pos0 and pos1 in a cone\n\n      childSubray.pos0.copy(segment.pos0)\n\n      vec1Pos.subVectors(parentSubray.pos1, parentSubray.pos0)\n      vec2Forward.copy(vec1Pos).normalize()\n      vec1Pos.multiplyScalar(segment.fraction0 + (1 - segment.fraction0) * (random1() * heightFactor))\n      const length = vec1Pos.length()\n      vec3Side.crossVectors(parentSubray.up0, vec2Forward)\n      const angle = 2 * Math.PI * random1()\n      vec3Side.multiplyScalar(Math.cos(angle))\n      vec4Up.copy(parentSubray.up0).multiplyScalar(Math.sin(angle))\n\n      childSubray.pos1\n        .copy(vec3Side)\n        .add(vec4Up)\n        .multiplyScalar(length * sideWidthFactor * (minSideWidthFactor + random1() * (1 - minSideWidthFactor)))\n        .add(vec1Pos)\n        .add(parentSubray.pos0)\n    }\n\n    this.subrayCylinderPosition = function (\n      segment,\n      parentSubray,\n      childSubray,\n      heightFactor,\n      sideWidthFactor,\n      minSideWidthFactor,\n    ) {\n      // Sets childSubray pos0 and pos1 in a cylinder\n\n      childSubray.pos0.copy(segment.pos0)\n\n      vec1Pos.subVectors(parentSubray.pos1, parentSubray.pos0)\n      vec2Forward.copy(vec1Pos).normalize()\n      vec1Pos.multiplyScalar(segment.fraction0 + (1 - segment.fraction0) * ((2 * random1() - 1) * heightFactor))\n      const length = vec1Pos.length()\n      vec3Side.crossVectors(parentSubray.up0, vec2Forward)\n      const angle = 2 * Math.PI * random1()\n      vec3Side.multiplyScalar(Math.cos(angle))\n      vec4Up.copy(parentSubray.up0).multiplyScalar(Math.sin(angle))\n\n      childSubray.pos1\n        .copy(vec3Side)\n        .add(vec4Up)\n        .multiplyScalar(length * sideWidthFactor * (minSideWidthFactor + random1() * (1 - minSideWidthFactor)))\n        .add(vec1Pos)\n        .add(parentSubray.pos0)\n    }\n  }\n\n  createSubray() {\n    return {\n      seed: 0,\n      maxIterations: 0,\n      recursion: 0,\n      pos0: new Vector3(),\n      pos1: new Vector3(),\n      linPos0: new Vector3(),\n      linPos1: new Vector3(),\n      up0: new Vector3(),\n      up1: new Vector3(),\n      radius0: 0,\n      radius1: 0,\n      birthTime: 0,\n      deathTime: 0,\n      timeScale: 0,\n      roughness: 0,\n      straightness: 0,\n      propagationTimeFactor: 0,\n      vanishingTimeFactor: 0,\n      endPropagationTime: 0,\n      beginVanishingTime: 0,\n    }\n  }\n\n  createSegment() {\n    return {\n      iteration: 0,\n      pos0: new Vector3(),\n      pos1: new Vector3(),\n      linPos0: new Vector3(),\n      linPos1: new Vector3(),\n      up0: new Vector3(),\n      up1: new Vector3(),\n      radius0: 0,\n      radius1: 0,\n      fraction0: 0,\n      fraction1: 0,\n      positionVariationFactor: 0,\n    }\n  }\n\n  getNewSegment() {\n    return this.raySegments[this.currentSegmentIndex++]\n  }\n\n  copy(source) {\n    super.copy(source)\n\n    this.init(LightningStrike.copyParameters({}, source.rayParameters))\n\n    return this\n  }\n\n  clone() {\n    return new this.constructor(LightningStrike.copyParameters({}, this.rayParameters))\n  }\n}\n\nexport { LightningStrike }\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}