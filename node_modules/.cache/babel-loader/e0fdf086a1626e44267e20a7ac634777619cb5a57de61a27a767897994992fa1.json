{"ast":null,"code":"import _classCallCheck from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _inherits from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport { Loader, FileLoader, BufferGeometry, BufferAttribute } from \"three\";\nvar _taskCache = /* @__PURE__ */new WeakMap();\nvar DRACOLoader = /*#__PURE__*/function (_Loader) {\n  _inherits(DRACOLoader, _Loader);\n  var _super = _createSuper(DRACOLoader);\n  function DRACOLoader(manager) {\n    var _this;\n    _classCallCheck(this, DRACOLoader);\n    _this = _super.call(this, manager);\n    _this.decoderPath = \"\";\n    _this.decoderConfig = {};\n    _this.decoderBinary = null;\n    _this.decoderPending = null;\n    _this.workerLimit = 4;\n    _this.workerPool = [];\n    _this.workerNextTaskID = 1;\n    _this.workerSourceURL = \"\";\n    _this.defaultAttributeIDs = {\n      position: \"POSITION\",\n      normal: \"NORMAL\",\n      color: \"COLOR\",\n      uv: \"TEX_COORD\"\n    };\n    _this.defaultAttributeTypes = {\n      position: \"Float32Array\",\n      normal: \"Float32Array\",\n      color: \"Float32Array\",\n      uv: \"Float32Array\"\n    };\n    return _this;\n  }\n  _createClass(DRACOLoader, [{\n    key: \"setDecoderPath\",\n    value: function setDecoderPath(path) {\n      this.decoderPath = path;\n      return this;\n    }\n  }, {\n    key: \"setDecoderConfig\",\n    value: function setDecoderConfig(config) {\n      this.decoderConfig = config;\n      return this;\n    }\n  }, {\n    key: \"setWorkerLimit\",\n    value: function setWorkerLimit(workerLimit) {\n      this.workerLimit = workerLimit;\n      return this;\n    }\n  }, {\n    key: \"load\",\n    value: function load(url, onLoad, onProgress, onError) {\n      var _this2 = this;\n      var loader = new FileLoader(this.manager);\n      loader.setPath(this.path);\n      loader.setResponseType(\"arraybuffer\");\n      loader.setRequestHeader(this.requestHeader);\n      loader.setWithCredentials(this.withCredentials);\n      loader.load(url, function (buffer) {\n        var taskConfig = {\n          attributeIDs: _this2.defaultAttributeIDs,\n          attributeTypes: _this2.defaultAttributeTypes,\n          useUniqueIDs: false\n        };\n        _this2.decodeGeometry(buffer, taskConfig).then(onLoad).catch(onError);\n      }, onProgress, onError);\n    }\n    /** @deprecated Kept for backward-compatibility with previous DRACOLoader versions. */\n  }, {\n    key: \"decodeDracoFile\",\n    value: function decodeDracoFile(buffer, callback, attributeIDs, attributeTypes) {\n      var taskConfig = {\n        attributeIDs: attributeIDs || this.defaultAttributeIDs,\n        attributeTypes: attributeTypes || this.defaultAttributeTypes,\n        useUniqueIDs: !!attributeIDs\n      };\n      this.decodeGeometry(buffer, taskConfig).then(callback);\n    }\n  }, {\n    key: \"decodeGeometry\",\n    value: function decodeGeometry(buffer, taskConfig) {\n      var _this3 = this;\n      for (var attribute in taskConfig.attributeTypes) {\n        var type = taskConfig.attributeTypes[attribute];\n        if (type.BYTES_PER_ELEMENT !== void 0) {\n          taskConfig.attributeTypes[attribute] = type.name;\n        }\n      }\n      var taskKey = JSON.stringify(taskConfig);\n      if (_taskCache.has(buffer)) {\n        var cachedTask = _taskCache.get(buffer);\n        if (cachedTask.key === taskKey) {\n          return cachedTask.promise;\n        } else if (buffer.byteLength === 0) {\n          throw new Error(\"THREE.DRACOLoader: Unable to re-decode a buffer with different settings. Buffer has already been transferred.\");\n        }\n      }\n      var worker;\n      var taskID = this.workerNextTaskID++;\n      var taskCost = buffer.byteLength;\n      var geometryPending = this._getWorker(taskID, taskCost).then(function (_worker) {\n        worker = _worker;\n        return new Promise(function (resolve, reject) {\n          worker._callbacks[taskID] = {\n            resolve: resolve,\n            reject: reject\n          };\n          worker.postMessage({\n            type: \"decode\",\n            id: taskID,\n            taskConfig: taskConfig,\n            buffer: buffer\n          }, [buffer]);\n        });\n      }).then(function (message) {\n        return _this3._createGeometry(message.geometry);\n      });\n      geometryPending.catch(function () {\n        return true;\n      }).then(function () {\n        if (worker && taskID) {\n          _this3._releaseTask(worker, taskID);\n        }\n      });\n      _taskCache.set(buffer, {\n        key: taskKey,\n        promise: geometryPending\n      });\n      return geometryPending;\n    }\n  }, {\n    key: \"_createGeometry\",\n    value: function _createGeometry(geometryData) {\n      var geometry = new BufferGeometry();\n      if (geometryData.index) {\n        geometry.setIndex(new BufferAttribute(geometryData.index.array, 1));\n      }\n      for (var i = 0; i < geometryData.attributes.length; i++) {\n        var attribute = geometryData.attributes[i];\n        var name = attribute.name;\n        var array = attribute.array;\n        var itemSize = attribute.itemSize;\n        geometry.setAttribute(name, new BufferAttribute(array, itemSize));\n      }\n      return geometry;\n    }\n  }, {\n    key: \"_loadLibrary\",\n    value: function _loadLibrary(url, responseType) {\n      var loader = new FileLoader(this.manager);\n      loader.setPath(this.decoderPath);\n      loader.setResponseType(responseType);\n      loader.setWithCredentials(this.withCredentials);\n      return new Promise(function (resolve, reject) {\n        loader.load(url, resolve, void 0, reject);\n      });\n    }\n  }, {\n    key: \"preload\",\n    value: function preload() {\n      this._initDecoder();\n      return this;\n    }\n  }, {\n    key: \"_initDecoder\",\n    value: function _initDecoder() {\n      var _this4 = this;\n      if (this.decoderPending) return this.decoderPending;\n      var useJS = typeof WebAssembly !== \"object\" || this.decoderConfig.type === \"js\";\n      var librariesPending = [];\n      if (useJS) {\n        librariesPending.push(this._loadLibrary(\"draco_decoder.js\", \"text\"));\n      } else {\n        librariesPending.push(this._loadLibrary(\"draco_wasm_wrapper.js\", \"text\"));\n        librariesPending.push(this._loadLibrary(\"draco_decoder.wasm\", \"arraybuffer\"));\n      }\n      this.decoderPending = Promise.all(librariesPending).then(function (libraries) {\n        var jsContent = libraries[0];\n        if (!useJS) {\n          _this4.decoderConfig.wasmBinary = libraries[1];\n        }\n        var fn = DRACOWorker.toString();\n        var body = [\"/* draco decoder */\", jsContent, \"\", \"/* worker */\", fn.substring(fn.indexOf(\"{\") + 1, fn.lastIndexOf(\"}\"))].join(\"\\n\");\n        _this4.workerSourceURL = URL.createObjectURL(new Blob([body]));\n      });\n      return this.decoderPending;\n    }\n  }, {\n    key: \"_getWorker\",\n    value: function _getWorker(taskID, taskCost) {\n      var _this5 = this;\n      return this._initDecoder().then(function () {\n        if (_this5.workerPool.length < _this5.workerLimit) {\n          var worker2 = new Worker(_this5.workerSourceURL);\n          worker2._callbacks = {};\n          worker2._taskCosts = {};\n          worker2._taskLoad = 0;\n          worker2.postMessage({\n            type: \"init\",\n            decoderConfig: _this5.decoderConfig\n          });\n          worker2.onmessage = function (e) {\n            var message = e.data;\n            switch (message.type) {\n              case \"decode\":\n                worker2._callbacks[message.id].resolve(message);\n                break;\n              case \"error\":\n                worker2._callbacks[message.id].reject(message);\n                break;\n              default:\n                console.error('THREE.DRACOLoader: Unexpected message, \"' + message.type + '\"');\n            }\n          };\n          _this5.workerPool.push(worker2);\n        } else {\n          _this5.workerPool.sort(function (a, b) {\n            return a._taskLoad > b._taskLoad ? -1 : 1;\n          });\n        }\n        var worker = _this5.workerPool[_this5.workerPool.length - 1];\n        worker._taskCosts[taskID] = taskCost;\n        worker._taskLoad += taskCost;\n        return worker;\n      });\n    }\n  }, {\n    key: \"_releaseTask\",\n    value: function _releaseTask(worker, taskID) {\n      worker._taskLoad -= worker._taskCosts[taskID];\n      delete worker._callbacks[taskID];\n      delete worker._taskCosts[taskID];\n    }\n  }, {\n    key: \"debug\",\n    value: function debug() {\n      console.log(\"Task load: \", this.workerPool.map(function (worker) {\n        return worker._taskLoad;\n      }));\n    }\n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      for (var i = 0; i < this.workerPool.length; ++i) {\n        this.workerPool[i].terminate();\n      }\n      this.workerPool.length = 0;\n      return this;\n    }\n  }]);\n  return DRACOLoader;\n}(Loader);\nfunction DRACOWorker() {\n  var decoderConfig;\n  var decoderPending;\n  onmessage = function onmessage(e) {\n    var message = e.data;\n    switch (message.type) {\n      case \"init\":\n        decoderConfig = message.decoderConfig;\n        decoderPending = new Promise(function (resolve) {\n          decoderConfig.onModuleLoaded = function (draco) {\n            resolve({\n              draco: draco\n            });\n          };\n          DracoDecoderModule(decoderConfig);\n        });\n        break;\n      case \"decode\":\n        var buffer = message.buffer;\n        var taskConfig = message.taskConfig;\n        decoderPending.then(function (module) {\n          var draco = module.draco;\n          var decoder = new draco.Decoder();\n          var decoderBuffer = new draco.DecoderBuffer();\n          decoderBuffer.Init(new Int8Array(buffer), buffer.byteLength);\n          try {\n            var geometry = decodeGeometry(draco, decoder, decoderBuffer, taskConfig);\n            var buffers = geometry.attributes.map(function (attr) {\n              return attr.array.buffer;\n            });\n            if (geometry.index) buffers.push(geometry.index.array.buffer);\n            self.postMessage({\n              type: \"decode\",\n              id: message.id,\n              geometry: geometry\n            }, buffers);\n          } catch (error) {\n            console.error(error);\n            self.postMessage({\n              type: \"error\",\n              id: message.id,\n              error: error.message\n            });\n          } finally {\n            draco.destroy(decoderBuffer);\n            draco.destroy(decoder);\n          }\n        });\n        break;\n    }\n  };\n  function decodeGeometry(draco, decoder, decoderBuffer, taskConfig) {\n    var attributeIDs = taskConfig.attributeIDs;\n    var attributeTypes = taskConfig.attributeTypes;\n    var dracoGeometry;\n    var decodingStatus;\n    var geometryType = decoder.GetEncodedGeometryType(decoderBuffer);\n    if (geometryType === draco.TRIANGULAR_MESH) {\n      dracoGeometry = new draco.Mesh();\n      decodingStatus = decoder.DecodeBufferToMesh(decoderBuffer, dracoGeometry);\n    } else if (geometryType === draco.POINT_CLOUD) {\n      dracoGeometry = new draco.PointCloud();\n      decodingStatus = decoder.DecodeBufferToPointCloud(decoderBuffer, dracoGeometry);\n    } else {\n      throw new Error(\"THREE.DRACOLoader: Unexpected geometry type.\");\n    }\n    if (!decodingStatus.ok() || dracoGeometry.ptr === 0) {\n      throw new Error(\"THREE.DRACOLoader: Decoding failed: \" + decodingStatus.error_msg());\n    }\n    var geometry = {\n      index: null,\n      attributes: []\n    };\n    for (var attributeName in attributeIDs) {\n      var attributeType = self[attributeTypes[attributeName]];\n      var attribute = void 0;\n      var attributeID = void 0;\n      if (taskConfig.useUniqueIDs) {\n        attributeID = attributeIDs[attributeName];\n        attribute = decoder.GetAttributeByUniqueId(dracoGeometry, attributeID);\n      } else {\n        attributeID = decoder.GetAttributeId(dracoGeometry, draco[attributeIDs[attributeName]]);\n        if (attributeID === -1) continue;\n        attribute = decoder.GetAttribute(dracoGeometry, attributeID);\n      }\n      geometry.attributes.push(decodeAttribute(draco, decoder, dracoGeometry, attributeName, attributeType, attribute));\n    }\n    if (geometryType === draco.TRIANGULAR_MESH) {\n      geometry.index = decodeIndex(draco, decoder, dracoGeometry);\n    }\n    draco.destroy(dracoGeometry);\n    return geometry;\n  }\n  function decodeIndex(draco, decoder, dracoGeometry) {\n    var numFaces = dracoGeometry.num_faces();\n    var numIndices = numFaces * 3;\n    var byteLength = numIndices * 4;\n    var ptr = draco._malloc(byteLength);\n    decoder.GetTrianglesUInt32Array(dracoGeometry, byteLength, ptr);\n    var index = new Uint32Array(draco.HEAPF32.buffer, ptr, numIndices).slice();\n    draco._free(ptr);\n    return {\n      array: index,\n      itemSize: 1\n    };\n  }\n  function decodeAttribute(draco, decoder, dracoGeometry, attributeName, attributeType, attribute) {\n    var numComponents = attribute.num_components();\n    var numPoints = dracoGeometry.num_points();\n    var numValues = numPoints * numComponents;\n    var byteLength = numValues * attributeType.BYTES_PER_ELEMENT;\n    var dataType = getDracoDataType(draco, attributeType);\n    var ptr = draco._malloc(byteLength);\n    decoder.GetAttributeDataArrayForAllPoints(dracoGeometry, attribute, dataType, byteLength, ptr);\n    var array = new attributeType(draco.HEAPF32.buffer, ptr, numValues).slice();\n    draco._free(ptr);\n    return {\n      name: attributeName,\n      array: array,\n      itemSize: numComponents\n    };\n  }\n  function getDracoDataType(draco, attributeType) {\n    switch (attributeType) {\n      case Float32Array:\n        return draco.DT_FLOAT32;\n      case Int8Array:\n        return draco.DT_INT8;\n      case Int16Array:\n        return draco.DT_INT16;\n      case Int32Array:\n        return draco.DT_INT32;\n      case Uint8Array:\n        return draco.DT_UINT8;\n      case Uint16Array:\n        return draco.DT_UINT16;\n      case Uint32Array:\n        return draco.DT_UINT32;\n    }\n  }\n}\nexport { DRACOLoader };","map":{"version":3,"names":["_taskCache","WeakMap","DRACOLoader","_Loader","_inherits","_super","_createSuper","manager","_this","_classCallCheck","call","decoderPath","decoderConfig","decoderBinary","decoderPending","workerLimit","workerPool","workerNextTaskID","workerSourceURL","defaultAttributeIDs","position","normal","color","uv","defaultAttributeTypes","_createClass","key","value","setDecoderPath","path","setDecoderConfig","config","setWorkerLimit","load","url","onLoad","onProgress","onError","_this2","loader","FileLoader","setPath","setResponseType","setRequestHeader","requestHeader","setWithCredentials","withCredentials","buffer","taskConfig","attributeIDs","attributeTypes","useUniqueIDs","decodeGeometry","then","catch","decodeDracoFile","callback","_this3","attribute","type","BYTES_PER_ELEMENT","name","taskKey","JSON","stringify","has","cachedTask","get","promise","byteLength","Error","worker","taskID","taskCost","geometryPending","_getWorker","_worker","Promise","resolve","reject","_callbacks","postMessage","id","message","_createGeometry","geometry","_releaseTask","set","geometryData","BufferGeometry","index","setIndex","BufferAttribute","array","i","attributes","length","itemSize","setAttribute","_loadLibrary","responseType","preload","_initDecoder","_this4","useJS","WebAssembly","librariesPending","push","all","libraries","jsContent","wasmBinary","fn","DRACOWorker","toString","body","substring","indexOf","lastIndexOf","join","URL","createObjectURL","Blob","_this5","worker2","Worker","_taskCosts","_taskLoad","onmessage","e","data","console","error","sort","a","b","debug","log","map","dispose","terminate","Loader","onModuleLoaded","draco","DracoDecoderModule","module","decoder","Decoder","decoderBuffer","DecoderBuffer","Init","Int8Array","buffers","attr","self","destroy","dracoGeometry","decodingStatus","geometryType","GetEncodedGeometryType","TRIANGULAR_MESH","Mesh","DecodeBufferToMesh","POINT_CLOUD","PointCloud","DecodeBufferToPointCloud","ok","ptr","error_msg","attributeName","attributeType","attributeID","GetAttributeByUniqueId","GetAttributeId","GetAttribute","decodeAttribute","decodeIndex","numFaces","num_faces","numIndices","_malloc","GetTrianglesUInt32Array","Uint32Array","HEAPF32","slice","_free","numComponents","num_components","numPoints","num_points","numValues","dataType","getDracoDataType","GetAttributeDataArrayForAllPoints","Float32Array","DT_FLOAT32","DT_INT8","Int16Array","DT_INT16","Int32Array","DT_INT32","Uint8Array","DT_UINT8","Uint16Array","DT_UINT16","DT_UINT32"],"sources":["C:\\Users\\Nayyu\\Desktop\\skibidai-public-build\\node_modules\\src\\loaders\\DRACOLoader.js"],"sourcesContent":["import { BufferAttribute, BufferGeometry, FileLoader, Loader } from 'three'\n\nconst _taskCache = new WeakMap()\n\nclass DRACOLoader extends Loader {\n  constructor(manager) {\n    super(manager)\n\n    this.decoderPath = ''\n    this.decoderConfig = {}\n    this.decoderBinary = null\n    this.decoderPending = null\n\n    this.workerLimit = 4\n    this.workerPool = []\n    this.workerNextTaskID = 1\n    this.workerSourceURL = ''\n\n    this.defaultAttributeIDs = {\n      position: 'POSITION',\n      normal: 'NORMAL',\n      color: 'COLOR',\n      uv: 'TEX_COORD',\n    }\n    this.defaultAttributeTypes = {\n      position: 'Float32Array',\n      normal: 'Float32Array',\n      color: 'Float32Array',\n      uv: 'Float32Array',\n    }\n  }\n\n  setDecoderPath(path) {\n    this.decoderPath = path\n\n    return this\n  }\n\n  setDecoderConfig(config) {\n    this.decoderConfig = config\n\n    return this\n  }\n\n  setWorkerLimit(workerLimit) {\n    this.workerLimit = workerLimit\n\n    return this\n  }\n\n  load(url, onLoad, onProgress, onError) {\n    const loader = new FileLoader(this.manager)\n\n    loader.setPath(this.path)\n    loader.setResponseType('arraybuffer')\n    loader.setRequestHeader(this.requestHeader)\n    loader.setWithCredentials(this.withCredentials)\n\n    loader.load(\n      url,\n      (buffer) => {\n        const taskConfig = {\n          attributeIDs: this.defaultAttributeIDs,\n          attributeTypes: this.defaultAttributeTypes,\n          useUniqueIDs: false,\n        }\n\n        this.decodeGeometry(buffer, taskConfig).then(onLoad).catch(onError)\n      },\n      onProgress,\n      onError,\n    )\n  }\n\n  /** @deprecated Kept for backward-compatibility with previous DRACOLoader versions. */\n  decodeDracoFile(buffer, callback, attributeIDs, attributeTypes) {\n    const taskConfig = {\n      attributeIDs: attributeIDs || this.defaultAttributeIDs,\n      attributeTypes: attributeTypes || this.defaultAttributeTypes,\n      useUniqueIDs: !!attributeIDs,\n    }\n\n    this.decodeGeometry(buffer, taskConfig).then(callback)\n  }\n\n  decodeGeometry(buffer, taskConfig) {\n    // TODO: For backward-compatibility, support 'attributeTypes' objects containing\n    // references (rather than names) to typed array constructors. These must be\n    // serialized before sending them to the worker.\n    for (const attribute in taskConfig.attributeTypes) {\n      const type = taskConfig.attributeTypes[attribute]\n\n      if (type.BYTES_PER_ELEMENT !== undefined) {\n        taskConfig.attributeTypes[attribute] = type.name\n      }\n    }\n\n    //\n\n    const taskKey = JSON.stringify(taskConfig)\n\n    // Check for an existing task using this buffer. A transferred buffer cannot be transferred\n    // again from this thread.\n    if (_taskCache.has(buffer)) {\n      const cachedTask = _taskCache.get(buffer)\n\n      if (cachedTask.key === taskKey) {\n        return cachedTask.promise\n      } else if (buffer.byteLength === 0) {\n        // Technically, it would be possible to wait for the previous task to complete,\n        // transfer the buffer back, and decode again with the second configuration. That\n        // is complex, and I don't know of any reason to decode a Draco buffer twice in\n        // different ways, so this is left unimplemented.\n        throw new Error(\n          'THREE.DRACOLoader: Unable to re-decode a buffer with different ' +\n            'settings. Buffer has already been transferred.',\n        )\n      }\n    }\n\n    //\n\n    let worker\n    const taskID = this.workerNextTaskID++\n    const taskCost = buffer.byteLength\n\n    // Obtain a worker and assign a task, and construct a geometry instance\n    // when the task completes.\n    const geometryPending = this._getWorker(taskID, taskCost)\n      .then((_worker) => {\n        worker = _worker\n\n        return new Promise((resolve, reject) => {\n          worker._callbacks[taskID] = { resolve, reject }\n\n          worker.postMessage({ type: 'decode', id: taskID, taskConfig, buffer }, [buffer])\n\n          // this.debug();\n        })\n      })\n      .then((message) => this._createGeometry(message.geometry))\n\n    // Remove task from the task list.\n    // Note: replaced '.finally()' with '.catch().then()' block - iOS 11 support (#19416)\n    geometryPending\n      .catch(() => true)\n      .then(() => {\n        if (worker && taskID) {\n          this._releaseTask(worker, taskID)\n\n          // this.debug();\n        }\n      })\n\n    // Cache the task result.\n    _taskCache.set(buffer, {\n      key: taskKey,\n      promise: geometryPending,\n    })\n\n    return geometryPending\n  }\n\n  _createGeometry(geometryData) {\n    const geometry = new BufferGeometry()\n\n    if (geometryData.index) {\n      geometry.setIndex(new BufferAttribute(geometryData.index.array, 1))\n    }\n\n    for (let i = 0; i < geometryData.attributes.length; i++) {\n      const attribute = geometryData.attributes[i]\n      const name = attribute.name\n      const array = attribute.array\n      const itemSize = attribute.itemSize\n\n      geometry.setAttribute(name, new BufferAttribute(array, itemSize))\n    }\n\n    return geometry\n  }\n\n  _loadLibrary(url, responseType) {\n    const loader = new FileLoader(this.manager)\n    loader.setPath(this.decoderPath)\n    loader.setResponseType(responseType)\n    loader.setWithCredentials(this.withCredentials)\n\n    return new Promise((resolve, reject) => {\n      loader.load(url, resolve, undefined, reject)\n    })\n  }\n\n  preload() {\n    this._initDecoder()\n\n    return this\n  }\n\n  _initDecoder() {\n    if (this.decoderPending) return this.decoderPending\n\n    const useJS = typeof WebAssembly !== 'object' || this.decoderConfig.type === 'js'\n    const librariesPending = []\n\n    if (useJS) {\n      librariesPending.push(this._loadLibrary('draco_decoder.js', 'text'))\n    } else {\n      librariesPending.push(this._loadLibrary('draco_wasm_wrapper.js', 'text'))\n      librariesPending.push(this._loadLibrary('draco_decoder.wasm', 'arraybuffer'))\n    }\n\n    this.decoderPending = Promise.all(librariesPending).then((libraries) => {\n      const jsContent = libraries[0]\n\n      if (!useJS) {\n        this.decoderConfig.wasmBinary = libraries[1]\n      }\n\n      const fn = DRACOWorker.toString()\n\n      const body = [\n        '/* draco decoder */',\n        jsContent,\n        '',\n        '/* worker */',\n        fn.substring(fn.indexOf('{') + 1, fn.lastIndexOf('}')),\n      ].join('\\n')\n\n      this.workerSourceURL = URL.createObjectURL(new Blob([body]))\n    })\n\n    return this.decoderPending\n  }\n\n  _getWorker(taskID, taskCost) {\n    return this._initDecoder().then(() => {\n      if (this.workerPool.length < this.workerLimit) {\n        const worker = new Worker(this.workerSourceURL)\n\n        worker._callbacks = {}\n        worker._taskCosts = {}\n        worker._taskLoad = 0\n\n        worker.postMessage({ type: 'init', decoderConfig: this.decoderConfig })\n\n        worker.onmessage = function (e) {\n          const message = e.data\n\n          switch (message.type) {\n            case 'decode':\n              worker._callbacks[message.id].resolve(message)\n              break\n\n            case 'error':\n              worker._callbacks[message.id].reject(message)\n              break\n\n            default:\n              console.error('THREE.DRACOLoader: Unexpected message, \"' + message.type + '\"')\n          }\n        }\n\n        this.workerPool.push(worker)\n      } else {\n        this.workerPool.sort(function (a, b) {\n          return a._taskLoad > b._taskLoad ? -1 : 1\n        })\n      }\n\n      const worker = this.workerPool[this.workerPool.length - 1]\n      worker._taskCosts[taskID] = taskCost\n      worker._taskLoad += taskCost\n      return worker\n    })\n  }\n\n  _releaseTask(worker, taskID) {\n    worker._taskLoad -= worker._taskCosts[taskID]\n    delete worker._callbacks[taskID]\n    delete worker._taskCosts[taskID]\n  }\n\n  debug() {\n    console.log(\n      'Task load: ',\n      this.workerPool.map((worker) => worker._taskLoad),\n    )\n  }\n\n  dispose() {\n    for (let i = 0; i < this.workerPool.length; ++i) {\n      this.workerPool[i].terminate()\n    }\n\n    this.workerPool.length = 0\n\n    return this\n  }\n}\n\n/* WEB WORKER */\n\nfunction DRACOWorker() {\n  let decoderConfig\n  let decoderPending\n\n  onmessage = function (e) {\n    const message = e.data\n\n    switch (message.type) {\n      case 'init':\n        decoderConfig = message.decoderConfig\n        decoderPending = new Promise(function (resolve /*, reject*/) {\n          decoderConfig.onModuleLoaded = function (draco) {\n            // Module is Promise-like. Wrap before resolving to avoid loop.\n            resolve({ draco: draco })\n          }\n\n          DracoDecoderModule(decoderConfig)\n        })\n        break\n\n      case 'decode':\n        const buffer = message.buffer\n        const taskConfig = message.taskConfig\n        decoderPending.then((module) => {\n          const draco = module.draco\n          const decoder = new draco.Decoder()\n          const decoderBuffer = new draco.DecoderBuffer()\n          decoderBuffer.Init(new Int8Array(buffer), buffer.byteLength)\n\n          try {\n            const geometry = decodeGeometry(draco, decoder, decoderBuffer, taskConfig)\n\n            const buffers = geometry.attributes.map((attr) => attr.array.buffer)\n\n            if (geometry.index) buffers.push(geometry.index.array.buffer)\n\n            self.postMessage({ type: 'decode', id: message.id, geometry }, buffers)\n          } catch (error) {\n            console.error(error)\n\n            self.postMessage({ type: 'error', id: message.id, error: error.message })\n          } finally {\n            draco.destroy(decoderBuffer)\n            draco.destroy(decoder)\n          }\n        })\n        break\n    }\n  }\n\n  function decodeGeometry(draco, decoder, decoderBuffer, taskConfig) {\n    const attributeIDs = taskConfig.attributeIDs\n    const attributeTypes = taskConfig.attributeTypes\n\n    let dracoGeometry\n    let decodingStatus\n\n    const geometryType = decoder.GetEncodedGeometryType(decoderBuffer)\n\n    if (geometryType === draco.TRIANGULAR_MESH) {\n      dracoGeometry = new draco.Mesh()\n      decodingStatus = decoder.DecodeBufferToMesh(decoderBuffer, dracoGeometry)\n    } else if (geometryType === draco.POINT_CLOUD) {\n      dracoGeometry = new draco.PointCloud()\n      decodingStatus = decoder.DecodeBufferToPointCloud(decoderBuffer, dracoGeometry)\n    } else {\n      throw new Error('THREE.DRACOLoader: Unexpected geometry type.')\n    }\n\n    if (!decodingStatus.ok() || dracoGeometry.ptr === 0) {\n      throw new Error('THREE.DRACOLoader: Decoding failed: ' + decodingStatus.error_msg())\n    }\n\n    const geometry = { index: null, attributes: [] }\n\n    // Gather all vertex attributes.\n    for (const attributeName in attributeIDs) {\n      const attributeType = self[attributeTypes[attributeName]]\n\n      let attribute\n      let attributeID\n\n      // A Draco file may be created with default vertex attributes, whose attribute IDs\n      // are mapped 1:1 from their semantic name (POSITION, NORMAL, ...). Alternatively,\n      // a Draco file may contain a custom set of attributes, identified by known unique\n      // IDs. glTF files always do the latter, and `.drc` files typically do the former.\n      if (taskConfig.useUniqueIDs) {\n        attributeID = attributeIDs[attributeName]\n        attribute = decoder.GetAttributeByUniqueId(dracoGeometry, attributeID)\n      } else {\n        attributeID = decoder.GetAttributeId(dracoGeometry, draco[attributeIDs[attributeName]])\n\n        if (attributeID === -1) continue\n\n        attribute = decoder.GetAttribute(dracoGeometry, attributeID)\n      }\n\n      geometry.attributes.push(decodeAttribute(draco, decoder, dracoGeometry, attributeName, attributeType, attribute))\n    }\n\n    // Add index.\n    if (geometryType === draco.TRIANGULAR_MESH) {\n      geometry.index = decodeIndex(draco, decoder, dracoGeometry)\n    }\n\n    draco.destroy(dracoGeometry)\n\n    return geometry\n  }\n\n  function decodeIndex(draco, decoder, dracoGeometry) {\n    const numFaces = dracoGeometry.num_faces()\n    const numIndices = numFaces * 3\n    const byteLength = numIndices * 4\n\n    const ptr = draco._malloc(byteLength)\n    decoder.GetTrianglesUInt32Array(dracoGeometry, byteLength, ptr)\n    const index = new Uint32Array(draco.HEAPF32.buffer, ptr, numIndices).slice()\n    draco._free(ptr)\n\n    return { array: index, itemSize: 1 }\n  }\n\n  function decodeAttribute(draco, decoder, dracoGeometry, attributeName, attributeType, attribute) {\n    const numComponents = attribute.num_components()\n    const numPoints = dracoGeometry.num_points()\n    const numValues = numPoints * numComponents\n    const byteLength = numValues * attributeType.BYTES_PER_ELEMENT\n    const dataType = getDracoDataType(draco, attributeType)\n\n    const ptr = draco._malloc(byteLength)\n    decoder.GetAttributeDataArrayForAllPoints(dracoGeometry, attribute, dataType, byteLength, ptr)\n    const array = new attributeType(draco.HEAPF32.buffer, ptr, numValues).slice()\n    draco._free(ptr)\n\n    return {\n      name: attributeName,\n      array: array,\n      itemSize: numComponents,\n    }\n  }\n\n  function getDracoDataType(draco, attributeType) {\n    switch (attributeType) {\n      case Float32Array:\n        return draco.DT_FLOAT32\n      case Int8Array:\n        return draco.DT_INT8\n      case Int16Array:\n        return draco.DT_INT16\n      case Int32Array:\n        return draco.DT_INT32\n      case Uint8Array:\n        return draco.DT_UINT8\n      case Uint16Array:\n        return draco.DT_UINT16\n      case Uint32Array:\n        return draco.DT_UINT32\n    }\n  }\n}\n\nexport { DRACOLoader }\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}