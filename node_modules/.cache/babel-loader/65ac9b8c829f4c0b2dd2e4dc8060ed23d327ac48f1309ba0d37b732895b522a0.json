{"ast":null,"code":"import _classCallCheck from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport { Vector3, Color, SphericalHarmonics3, LightProbe } from \"three\";\nvar LightProbeGenerator = /*#__PURE__*/function () {\n  function LightProbeGenerator() {\n    _classCallCheck(this, LightProbeGenerator);\n  }\n  _createClass(LightProbeGenerator, null, [{\n    key: \"fromCubeTexture\",\n    value:\n    // https://www.ppsloan.org/publications/StupidSH36.pdf\n    function fromCubeTexture(cubeTexture) {\n      var totalWeight = 0;\n      var coord = new Vector3();\n      var dir = new Vector3();\n      var color = new Color();\n      var shBasis = [0, 0, 0, 0, 0, 0, 0, 0, 0];\n      var sh = new SphericalHarmonics3();\n      var shCoefficients = sh.coefficients;\n      for (var faceIndex = 0; faceIndex < 6; faceIndex++) {\n        var image = cubeTexture.image[faceIndex];\n        var width = image.width;\n        var height = image.height;\n        var canvas = document.createElement(\"canvas\");\n        canvas.width = width;\n        canvas.height = height;\n        var context = canvas.getContext(\"2d\");\n        context.drawImage(image, 0, 0, width, height);\n        var imageData = context.getImageData(0, 0, width, height);\n        var data = imageData.data;\n        var imageWidth = imageData.width;\n        var pixelSize = 2 / imageWidth;\n        for (var i = 0, il = data.length; i < il; i += 4) {\n          color.setRGB(data[i] / 255, data[i + 1] / 255, data[i + 2] / 255);\n          if (\"colorSpace\" in cubeTexture) {\n            if (cubeTexture.colorSpace === \"srgb\") {\n              color.convertSRGBToLinear();\n            }\n          } else if (cubeTexture.encoding === 3001) {\n            color.convertSRGBToLinear();\n          }\n          var pixelIndex = i / 4;\n          var col = -1 + (pixelIndex % imageWidth + 0.5) * pixelSize;\n          var row = 1 - (Math.floor(pixelIndex / imageWidth) + 0.5) * pixelSize;\n          switch (faceIndex) {\n            case 0:\n              coord.set(-1, row, -col);\n              break;\n            case 1:\n              coord.set(1, row, col);\n              break;\n            case 2:\n              coord.set(-col, 1, -row);\n              break;\n            case 3:\n              coord.set(-col, -1, row);\n              break;\n            case 4:\n              coord.set(-col, row, 1);\n              break;\n            case 5:\n              coord.set(col, row, -1);\n              break;\n          }\n          var lengthSq = coord.lengthSq();\n          var weight = 4 / (Math.sqrt(lengthSq) * lengthSq);\n          totalWeight += weight;\n          dir.copy(coord).normalize();\n          SphericalHarmonics3.getBasisAt(dir, shBasis);\n          for (var j = 0; j < 9; j++) {\n            shCoefficients[j].x += shBasis[j] * color.r * weight;\n            shCoefficients[j].y += shBasis[j] * color.g * weight;\n            shCoefficients[j].z += shBasis[j] * color.b * weight;\n          }\n        }\n      }\n      var norm = 4 * Math.PI / totalWeight;\n      for (var _j = 0; _j < 9; _j++) {\n        shCoefficients[_j].x *= norm;\n        shCoefficients[_j].y *= norm;\n        shCoefficients[_j].z *= norm;\n      }\n      return new LightProbe(sh);\n    }\n  }, {\n    key: \"fromCubeRenderTarget\",\n    value: function fromCubeRenderTarget(renderer, cubeRenderTarget) {\n      var totalWeight = 0;\n      var coord = new Vector3();\n      var dir = new Vector3();\n      var color = new Color();\n      var shBasis = [0, 0, 0, 0, 0, 0, 0, 0, 0];\n      var sh = new SphericalHarmonics3();\n      var shCoefficients = sh.coefficients;\n      for (var faceIndex = 0; faceIndex < 6; faceIndex++) {\n        var imageWidth = cubeRenderTarget.width;\n        var data = new Uint8Array(imageWidth * imageWidth * 4);\n        renderer.readRenderTargetPixels(cubeRenderTarget, 0, 0, imageWidth, imageWidth, data, faceIndex);\n        var pixelSize = 2 / imageWidth;\n        for (var i = 0, il = data.length; i < il; i += 4) {\n          color.setRGB(data[i] / 255, data[i + 1] / 255, data[i + 2] / 255);\n          if (\"colorSpace\" in cubeRenderTarget.texture) {\n            if (cubeRenderTarget.texture.colorSpace === \"srgb\") {\n              color.convertSRGBToLinear();\n            }\n          } else if (cubeRenderTarget.texture.encoding === 3001) {\n            color.convertSRGBToLinear();\n          }\n          var pixelIndex = i / 4;\n          var col = -1 + (pixelIndex % imageWidth + 0.5) * pixelSize;\n          var row = 1 - (Math.floor(pixelIndex / imageWidth) + 0.5) * pixelSize;\n          switch (faceIndex) {\n            case 0:\n              coord.set(1, row, -col);\n              break;\n            case 1:\n              coord.set(-1, row, col);\n              break;\n            case 2:\n              coord.set(col, 1, -row);\n              break;\n            case 3:\n              coord.set(col, -1, row);\n              break;\n            case 4:\n              coord.set(col, row, 1);\n              break;\n            case 5:\n              coord.set(-col, row, -1);\n              break;\n          }\n          var lengthSq = coord.lengthSq();\n          var weight = 4 / (Math.sqrt(lengthSq) * lengthSq);\n          totalWeight += weight;\n          dir.copy(coord).normalize();\n          SphericalHarmonics3.getBasisAt(dir, shBasis);\n          for (var j = 0; j < 9; j++) {\n            shCoefficients[j].x += shBasis[j] * color.r * weight;\n            shCoefficients[j].y += shBasis[j] * color.g * weight;\n            shCoefficients[j].z += shBasis[j] * color.b * weight;\n          }\n        }\n      }\n      var norm = 4 * Math.PI / totalWeight;\n      for (var _j2 = 0; _j2 < 9; _j2++) {\n        shCoefficients[_j2].x *= norm;\n        shCoefficients[_j2].y *= norm;\n        shCoefficients[_j2].z *= norm;\n      }\n      return new LightProbe(sh);\n    }\n  }]);\n  return LightProbeGenerator;\n}();\nexport { LightProbeGenerator };","map":{"version":3,"names":["LightProbeGenerator","_classCallCheck","_createClass","key","value","fromCubeTexture","cubeTexture","totalWeight","coord","Vector3","dir","color","Color","shBasis","sh","SphericalHarmonics3","shCoefficients","coefficients","faceIndex","image","width","height","canvas","document","createElement","context","getContext","drawImage","imageData","getImageData","data","imageWidth","pixelSize","i","il","length","setRGB","colorSpace","convertSRGBToLinear","encoding","pixelIndex","col","row","Math","floor","set","lengthSq","weight","sqrt","copy","normalize","getBasisAt","j","x","r","y","g","z","b","norm","PI","LightProbe","fromCubeRenderTarget","renderer","cubeRenderTarget","Uint8Array","readRenderTargetPixels","texture"],"sources":["C:\\Users\\Nayyu\\Desktop\\skibidai-public-build\\node_modules\\src\\lights\\LightProbeGenerator.js"],"sourcesContent":["import { Color, LightProbe, SphericalHarmonics3, Vector3 } from 'three'\n\nclass LightProbeGenerator {\n  // https://www.ppsloan.org/publications/StupidSH36.pdf\n  static fromCubeTexture(cubeTexture) {\n    let totalWeight = 0\n\n    const coord = new Vector3()\n\n    const dir = new Vector3()\n\n    const color = new Color()\n\n    const shBasis = [0, 0, 0, 0, 0, 0, 0, 0, 0]\n\n    const sh = new SphericalHarmonics3()\n    const shCoefficients = sh.coefficients\n\n    for (let faceIndex = 0; faceIndex < 6; faceIndex++) {\n      const image = cubeTexture.image[faceIndex]\n\n      const width = image.width\n      const height = image.height\n\n      const canvas = document.createElement('canvas')\n\n      canvas.width = width\n      canvas.height = height\n\n      const context = canvas.getContext('2d')\n\n      context.drawImage(image, 0, 0, width, height)\n\n      const imageData = context.getImageData(0, 0, width, height)\n\n      const data = imageData.data\n\n      const imageWidth = imageData.width // assumed to be square\n\n      const pixelSize = 2 / imageWidth\n\n      for (let i = 0, il = data.length; i < il; i += 4) {\n        // RGBA assumed\n\n        // pixel color\n        color.setRGB(data[i] / 255, data[i + 1] / 255, data[i + 2] / 255)\n\n        // convert to linear color space\n        if ('colorSpace' in cubeTexture) {\n          if (cubeTexture.colorSpace === 'srgb') {\n            color.convertSRGBToLinear()\n          }\n        } else if (cubeTexture.encoding === 3001) {\n          // sRGBEncoding\n          color.convertSRGBToLinear()\n        }\n\n        // pixel coordinate on unit cube\n\n        const pixelIndex = i / 4\n\n        const col = -1 + ((pixelIndex % imageWidth) + 0.5) * pixelSize\n\n        const row = 1 - (Math.floor(pixelIndex / imageWidth) + 0.5) * pixelSize\n\n        switch (faceIndex) {\n          case 0:\n            coord.set(-1, row, -col)\n            break\n\n          case 1:\n            coord.set(1, row, col)\n            break\n\n          case 2:\n            coord.set(-col, 1, -row)\n            break\n\n          case 3:\n            coord.set(-col, -1, row)\n            break\n\n          case 4:\n            coord.set(-col, row, 1)\n            break\n\n          case 5:\n            coord.set(col, row, -1)\n            break\n        }\n\n        // weight assigned to this pixel\n\n        const lengthSq = coord.lengthSq()\n\n        const weight = 4 / (Math.sqrt(lengthSq) * lengthSq)\n\n        totalWeight += weight\n\n        // direction vector to this pixel\n        dir.copy(coord).normalize()\n\n        // evaluate SH basis functions in direction dir\n        SphericalHarmonics3.getBasisAt(dir, shBasis)\n\n        // accummuulate\n        for (let j = 0; j < 9; j++) {\n          shCoefficients[j].x += shBasis[j] * color.r * weight\n          shCoefficients[j].y += shBasis[j] * color.g * weight\n          shCoefficients[j].z += shBasis[j] * color.b * weight\n        }\n      }\n    }\n\n    // normalize\n    const norm = (4 * Math.PI) / totalWeight\n\n    for (let j = 0; j < 9; j++) {\n      shCoefficients[j].x *= norm\n      shCoefficients[j].y *= norm\n      shCoefficients[j].z *= norm\n    }\n\n    return new LightProbe(sh)\n  }\n\n  static fromCubeRenderTarget(renderer, cubeRenderTarget) {\n    // The renderTarget must be set to RGBA in order to make readRenderTargetPixels works\n    let totalWeight = 0\n\n    const coord = new Vector3()\n\n    const dir = new Vector3()\n\n    const color = new Color()\n\n    const shBasis = [0, 0, 0, 0, 0, 0, 0, 0, 0]\n\n    const sh = new SphericalHarmonics3()\n    const shCoefficients = sh.coefficients\n\n    for (let faceIndex = 0; faceIndex < 6; faceIndex++) {\n      const imageWidth = cubeRenderTarget.width // assumed to be square\n      const data = new Uint8Array(imageWidth * imageWidth * 4)\n      renderer.readRenderTargetPixels(cubeRenderTarget, 0, 0, imageWidth, imageWidth, data, faceIndex)\n\n      const pixelSize = 2 / imageWidth\n\n      for (let i = 0, il = data.length; i < il; i += 4) {\n        // RGBA assumed\n\n        // pixel color\n        color.setRGB(data[i] / 255, data[i + 1] / 255, data[i + 2] / 255)\n\n        // convert to linear color space\n        if ('colorSpace' in cubeRenderTarget.texture) {\n          if (cubeRenderTarget.texture.colorSpace === 'srgb') {\n            color.convertSRGBToLinear()\n          }\n        } else if (cubeRenderTarget.texture.encoding === 3001) {\n          // sRGBEncoding\n          color.convertSRGBToLinear()\n        }\n\n        // pixel coordinate on unit cube\n\n        const pixelIndex = i / 4\n\n        const col = -1 + ((pixelIndex % imageWidth) + 0.5) * pixelSize\n\n        const row = 1 - (Math.floor(pixelIndex / imageWidth) + 0.5) * pixelSize\n\n        switch (faceIndex) {\n          case 0:\n            coord.set(1, row, -col)\n            break\n\n          case 1:\n            coord.set(-1, row, col)\n            break\n\n          case 2:\n            coord.set(col, 1, -row)\n            break\n\n          case 3:\n            coord.set(col, -1, row)\n            break\n\n          case 4:\n            coord.set(col, row, 1)\n            break\n\n          case 5:\n            coord.set(-col, row, -1)\n            break\n        }\n\n        // weight assigned to this pixel\n\n        const lengthSq = coord.lengthSq()\n\n        const weight = 4 / (Math.sqrt(lengthSq) * lengthSq)\n\n        totalWeight += weight\n\n        // direction vector to this pixel\n        dir.copy(coord).normalize()\n\n        // evaluate SH basis functions in direction dir\n        SphericalHarmonics3.getBasisAt(dir, shBasis)\n\n        // accummuulate\n        for (let j = 0; j < 9; j++) {\n          shCoefficients[j].x += shBasis[j] * color.r * weight\n          shCoefficients[j].y += shBasis[j] * color.g * weight\n          shCoefficients[j].z += shBasis[j] * color.b * weight\n        }\n      }\n    }\n\n    // normalize\n    const norm = (4 * Math.PI) / totalWeight\n\n    for (let j = 0; j < 9; j++) {\n      shCoefficients[j].x *= norm\n      shCoefficients[j].y *= norm\n      shCoefficients[j].z *= norm\n    }\n\n    return new LightProbe(sh)\n  }\n}\n\nexport { LightProbeGenerator }\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}