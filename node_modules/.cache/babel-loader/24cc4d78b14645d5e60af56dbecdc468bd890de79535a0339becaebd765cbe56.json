{"ast":null,"code":"import _objectSpread from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _classCallCheck from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = function __defNormalProp(obj, key, value) {\n  return key in obj ? __defProp(obj, key, {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: value\n  }) : obj[key] = value;\n};\nvar __publicField = function __publicField(obj, key, value) {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nimport { InterleavedBufferAttribute, Matrix4, MeshLambertMaterial, MeshBasicMaterial, MeshPhongMaterial, Color, DoubleSide, Mesh } from \"three\";\nimport { UV1 } from \"../_polyfill/uv1.js\";\nvar ColladaExporter = /*#__PURE__*/function () {\n  function ColladaExporter() {\n    _classCallCheck(this, ColladaExporter);\n    __publicField(this, \"options\");\n    __publicField(this, \"geometryInfo\");\n    __publicField(this, \"materialMap\");\n    __publicField(this, \"imageMap\");\n    __publicField(this, \"textures\");\n    __publicField(this, \"libraryImages\");\n    __publicField(this, \"libraryGeometries\");\n    __publicField(this, \"libraryEffects\");\n    __publicField(this, \"libraryMaterials\");\n    __publicField(this, \"canvas\");\n    __publicField(this, \"ctx\");\n    __publicField(this, \"transMat\");\n    __publicField(this, \"getFuncs\", [\"getX\", \"getY\", \"getZ\", \"getW\"]);\n    this.options = {\n      version: \"1.4.1\",\n      author: null,\n      textureDirectory: \"\",\n      upAxis: \"Y_UP\",\n      unitName: null,\n      unitMeter: null\n    };\n    this.geometryInfo = /* @__PURE__ */new WeakMap();\n    this.materialMap = /* @__PURE__ */new WeakMap();\n    this.imageMap = /* @__PURE__ */new WeakMap();\n    this.textures = [];\n    this.libraryImages = [];\n    this.libraryGeometries = [];\n    this.libraryEffects = [];\n    this.libraryMaterials = [];\n    this.canvas = null;\n    this.ctx = null;\n    this.transMat = null;\n  }\n  _createClass(ColladaExporter, [{\n    key: \"parse\",\n    value: function parse(object, onDone) {\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      this.options = _objectSpread(_objectSpread({}, this.options), options);\n      if (this.options.upAxis.match(/^[XYZ]_UP$/) === null) {\n        console.error(\"ColladaExporter: Invalid upAxis: valid values are X_UP, Y_UP or Z_UP.\");\n        return null;\n      }\n      if (this.options.unitName !== null && this.options.unitMeter === null) {\n        console.error(\"ColladaExporter: unitMeter needs to be specified if unitName is specified.\");\n        return null;\n      }\n      if (this.options.unitMeter !== null && this.options.unitName === null) {\n        console.error(\"ColladaExporter: unitName needs to be specified if unitMeter is specified.\");\n        return null;\n      }\n      if (this.options.textureDirectory !== \"\") {\n        this.options.textureDirectory = \"\".concat(this.options.textureDirectory, \"/\").replace(/\\\\/g, \"/\").replace(/\\/+/g, \"/\");\n      }\n      if (this.options.version !== \"1.4.1\" && this.options.version !== \"1.5.0\") {\n        console.warn(\"ColladaExporter : Version \".concat(this.options.version, \" not supported for export. Only 1.4.1 and 1.5.0.\"));\n        return null;\n      }\n      var libraryVisualScenes = this.processObject(object);\n      var specLink = this.options.version === \"1.4.1\" ? \"http://www.collada.org/2005/11/COLLADASchema\" : \"https://www.khronos.org/collada/\";\n      var dae = \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\" standalone=\\\"no\\\" ?>\".concat(\"<COLLADA xmlns=\\\"\".concat(specLink, \"\\\" version=\\\"\").concat(this.options.version, \"\\\">\"), \"<asset><contributor><authoring_tool>three.js Collada Exporter</authoring_tool>\", this.options.author !== null ? \"<author>\".concat(this.options.author, \"</author>\") : \"\", \"</contributor>\", \"<created>\".concat( /* @__PURE__ */new Date().toISOString(), \"</created>\"), \"<modified>\".concat( /* @__PURE__ */new Date().toISOString(), \"</modified>\"), \"<up_axis>Y_UP</up_axis></asset>\");\n      dae += \"<library_images>\".concat(this.libraryImages.join(\"\"), \"</library_images>\");\n      dae += \"<library_effects>\".concat(this.libraryEffects.join(\"\"), \"</library_effects>\");\n      dae += \"<library_materials>\".concat(this.libraryMaterials.join(\"\"), \"</library_materials>\");\n      dae += \"<library_geometries>\".concat(this.libraryGeometries.join(\"\"), \"</library_geometries>\");\n      dae += \"<library_visual_scenes><visual_scene id=\\\"Scene\\\" name=\\\"scene\\\">\".concat(libraryVisualScenes, \"</visual_scene></library_visual_scenes>\");\n      dae += '<scene><instance_visual_scene url=\"#Scene\"/></scene>';\n      dae += \"</COLLADA>\";\n      var res = {\n        data: this.format(dae),\n        textures: this.textures\n      };\n      if (typeof onDone === \"function\") {\n        requestAnimationFrame(function () {\n          return onDone(res);\n        });\n      }\n      return res;\n    }\n    // Convert the urdf xml into a well-formatted, indented format\n  }, {\n    key: \"format\",\n    value: function format(urdf) {\n      var _a, _b;\n      var IS_END_TAG = /^<\\//;\n      var IS_SELF_CLOSING = /(\\?>$)|(\\/>$)/;\n      var HAS_TEXT = /<[^>]+>[^<]*<\\/[^<]+>/;\n      var pad = function pad(ch, num) {\n        return num > 0 ? ch + pad(ch, num - 1) : \"\";\n      };\n      var tagnum = 0;\n      return (_b = (_a = urdf.match(/(<[^>]+>[^<]+<\\/[^<]+>)|(<[^>]+>)/g)) == null ? void 0 : _a.map(function (tag) {\n        if (!HAS_TEXT.test(tag) && !IS_SELF_CLOSING.test(tag) && IS_END_TAG.test(tag)) {\n          tagnum--;\n        }\n        var res = \"\".concat(pad(\"  \", tagnum)).concat(tag);\n        if (!HAS_TEXT.test(tag) && !IS_SELF_CLOSING.test(tag) && !IS_END_TAG.test(tag)) {\n          tagnum++;\n        }\n        return res;\n      }).join(\"\\n\")) != null ? _b : \"\";\n    }\n    // Convert an image into a png format for saving\n  }, {\n    key: \"base64ToBuffer\",\n    value: function base64ToBuffer(str) {\n      var b = atob(str);\n      var buf = new Uint8Array(b.length);\n      for (var i = 0, l = buf.length; i < l; i++) {\n        buf[i] = b.charCodeAt(i);\n      }\n      return buf;\n    }\n  }, {\n    key: \"imageToData\",\n    value: function imageToData(image, ext) {\n      var _a;\n      this.canvas = this.canvas || document.createElement(\"canvas\");\n      this.ctx = this.ctx || this.canvas.getContext(\"2d\");\n      this.canvas.width = image.width instanceof SVGAnimatedLength ? 0 : image.width;\n      this.canvas.height = image.height instanceof SVGAnimatedLength ? 0 : image.height;\n      (_a = this.ctx) == null ? void 0 : _a.drawImage(image, 0, 0);\n      var base64data = this.canvas.toDataURL(\"image/\".concat(ext), 1).replace(/^data:image\\/(png|jpg);base64,/, \"\");\n      return this.base64ToBuffer(base64data);\n    }\n    // gets the attribute array. Generate a new array if the attribute is interleaved\n  }, {\n    key: \"attrBufferToArray\",\n    value: function attrBufferToArray(attr) {\n      if (attr instanceof InterleavedBufferAttribute && attr.isInterleavedBufferAttribute) {\n        var TypedArrayConstructor = attr.array.constructor;\n        var arr = new TypedArrayConstructor(attr.count * attr.itemSize);\n        var size = attr.itemSize;\n        for (var i = 0, l = attr.count; i < l; i++) {\n          for (var j = 0; j < size; j++) {\n            arr[i * size + j] = attr[this.getFuncs[j]](i);\n          }\n        }\n        return arr;\n      } else {\n        return attr.array;\n      }\n    }\n    // Returns an array of the same type starting at the `st` index,\n    // and `ct` length\n  }, {\n    key: \"subArray\",\n    value: function subArray(arr, st, ct) {\n      if (Array.isArray(arr)) {\n        return arr.slice(st, st + ct);\n      } else {\n        var TypedArrayConstructor = arr.constructor;\n        return new TypedArrayConstructor(arr.buffer, st * arr.BYTES_PER_ELEMENT, ct);\n      }\n    }\n    // Returns the string for a geometry's attribute\n  }, {\n    key: \"getAttribute\",\n    value: function getAttribute(attr, name, params, type) {\n      var array = this.attrBufferToArray(attr);\n      var res = Array.isArray(array) ? \"\".concat(\"<source id=\\\"\".concat(name, \"\\\"><float_array id=\\\"\").concat(name, \"-array\\\" count=\\\"\").concat(array.length, \"\\\">\") + array.join(\" \"), \"</float_array><technique_common>\", \"<accessor source=\\\"#\".concat(name, \"-array\\\" count=\\\"\").concat(Math.floor(array.length / attr.itemSize), \"\\\" stride=\\\"\").concat(attr.itemSize, \"\\\">\")).concat(params.map(function (n) {\n        return \"<param name=\\\"\".concat(n, \"\\\" type=\\\"\").concat(type, \"\\\" />\");\n      }).join(\"\"), \"</accessor></technique_common></source>\") : \"\";\n      return res;\n    }\n    // Returns the string for a node's transform information\n  }, {\n    key: \"getTransform\",\n    value: function getTransform(o) {\n      o.updateMatrix();\n      this.transMat = this.transMat || new Matrix4();\n      this.transMat.copy(o.matrix);\n      this.transMat.transpose();\n      return \"<matrix>\".concat(this.transMat.toArray().join(\" \"), \"</matrix>\");\n    }\n    // Process the given piece of geometry into the geometry library\n    // Returns the mesh id\n  }, {\n    key: \"processGeometry\",\n    value: function processGeometry(g) {\n      var info = this.geometryInfo.get(g);\n      if (!info) {\n        var bufferGeometry = g;\n        if (!bufferGeometry.isBufferGeometry) {\n          throw new Error(\"THREE.ColladaExporter: Geometry is not of type THREE.BufferGeometry.\");\n        }\n        var meshid = \"Mesh\".concat(this.libraryGeometries.length + 1);\n        var indexCount = bufferGeometry.index ? bufferGeometry.index.count * bufferGeometry.index.itemSize : bufferGeometry.attributes.position.count;\n        var groups = bufferGeometry.groups != null && bufferGeometry.groups.length !== 0 ? bufferGeometry.groups : [{\n          start: 0,\n          count: indexCount,\n          materialIndex: 0\n        }];\n        var gname = g.name ? \" name=\\\"\".concat(g.name, \"\\\"\") : \"\";\n        var gnode = \"<geometry id=\\\"\".concat(meshid, \"\\\"\").concat(gname, \"><mesh>\");\n        var posName = \"\".concat(meshid, \"-position\");\n        var vertName = \"\".concat(meshid, \"-vertices\");\n        gnode += this.getAttribute(bufferGeometry.attributes.position, posName, [\"X\", \"Y\", \"Z\"], \"float\");\n        gnode += \"<vertices id=\\\"\".concat(vertName, \"\\\"><input semantic=\\\"POSITION\\\" source=\\\"#\").concat(posName, \"\\\" /></vertices>\");\n        var triangleInputs = \"<input semantic=\\\"VERTEX\\\" source=\\\"#\".concat(vertName, \"\\\" offset=\\\"0\\\" />\");\n        if (\"normal\" in bufferGeometry.attributes) {\n          var normName = \"\".concat(meshid, \"-normal\");\n          gnode += this.getAttribute(bufferGeometry.attributes.normal, normName, [\"X\", \"Y\", \"Z\"], \"float\");\n          triangleInputs += \"<input semantic=\\\"NORMAL\\\" source=\\\"#\".concat(normName, \"\\\" offset=\\\"0\\\" />\");\n        }\n        if (\"uv\" in bufferGeometry.attributes) {\n          var uvName = \"\".concat(meshid, \"-texcoord\");\n          gnode += this.getAttribute(bufferGeometry.attributes.uv, uvName, [\"S\", \"T\"], \"float\");\n          triangleInputs += \"<input semantic=\\\"TEXCOORD\\\" source=\\\"#\".concat(uvName, \"\\\" offset=\\\"0\\\" set=\\\"0\\\" />\");\n        }\n        if (UV1 in bufferGeometry.attributes) {\n          var _uvName = \"\".concat(meshid, \"-texcoord2\");\n          gnode += this.getAttribute(bufferGeometry.attributes[UV1], _uvName, [\"S\", \"T\"], \"float\");\n          triangleInputs += \"<input semantic=\\\"TEXCOORD\\\" source=\\\"#\".concat(_uvName, \"\\\" offset=\\\"0\\\" set=\\\"1\\\" />\");\n        }\n        if (\"color\" in bufferGeometry.attributes) {\n          var colName = \"\".concat(meshid, \"-color\");\n          gnode += this.getAttribute(bufferGeometry.attributes.color, colName, [\"X\", \"Y\", \"Z\"], \"uint8\");\n          triangleInputs += \"<input semantic=\\\"COLOR\\\" source=\\\"#\".concat(colName, \"\\\" offset=\\\"0\\\" />\");\n        }\n        var indexArray = null;\n        if (bufferGeometry.index) {\n          indexArray = this.attrBufferToArray(bufferGeometry.index);\n        } else {\n          indexArray = new Array(indexCount);\n          for (var i = 0, l = indexArray.length; i < l && Array.isArray(indexArray); i++) indexArray[i] = i;\n        }\n        for (var _i = 0, _l = groups.length; _i < _l; _i++) {\n          var group = groups[_i];\n          var subarr = this.subArray(indexArray, group.start, group.count);\n          var polycount = subarr.length / 3;\n          gnode += \"<triangles material=\\\"MESH_MATERIAL_\".concat(group.materialIndex, \"\\\" count=\\\"\").concat(polycount, \"\\\">\");\n          gnode += triangleInputs;\n          gnode += \"<p>\".concat(subarr.join(\" \"), \"</p>\");\n          gnode += \"</triangles>\";\n        }\n        gnode += \"</mesh></geometry>\";\n        this.libraryGeometries.push(gnode);\n        info = {\n          meshid: meshid,\n          bufferGeometry: bufferGeometry\n        };\n        this.geometryInfo.set(g, info);\n      }\n      return info;\n    }\n    // Process the given texture into the image library\n    // Returns the image library\n  }, {\n    key: \"processTexture\",\n    value: function processTexture(tex) {\n      var texid = this.imageMap.get(tex);\n      if (texid == null) {\n        texid = \"image-\".concat(this.libraryImages.length + 1);\n        var ext = \"png\";\n        var name = tex.name || texid;\n        var imageNode = \"<image id=\\\"\".concat(texid, \"\\\" name=\\\"\").concat(name, \"\\\">\");\n        if (this.options.version === \"1.5.0\") {\n          imageNode += \"<init_from><ref>\".concat(this.options.textureDirectory).concat(name, \".\").concat(ext, \"</ref></init_from>\");\n        } else {\n          imageNode += \"<init_from>\".concat(this.options.textureDirectory).concat(name, \".\").concat(ext, \"</init_from>\");\n        }\n        imageNode += \"</image>\";\n        this.libraryImages.push(imageNode);\n        this.imageMap.set(tex, texid);\n        this.textures.push({\n          directory: this.options.textureDirectory,\n          name: name,\n          ext: ext,\n          data: this.imageToData(tex.image, ext),\n          original: tex\n        });\n      }\n      return texid;\n    }\n    // Process the given material into the material and effect libraries\n    // Returns the material id\n  }, {\n    key: \"processMaterial\",\n    value: function processMaterial(m) {\n      var matid = this.materialMap.get(m);\n      if (matid == null) {\n        matid = \"Mat\".concat(this.libraryEffects.length + 1);\n        var type = \"phong\";\n        if (m instanceof MeshLambertMaterial) {\n          type = \"lambert\";\n        } else if (m instanceof MeshBasicMaterial) {\n          type = \"constant\";\n          if (m.map !== null) {\n            console.warn(\"ColladaExporter: Texture maps not supported with MeshBasicMaterial.\");\n          }\n        }\n        if (m instanceof MeshPhongMaterial) {\n          var emissive = m.emissive ? m.emissive : new Color(0, 0, 0);\n          var diffuse = m.color ? m.color : new Color(0, 0, 0);\n          var specular = m.specular ? m.specular : new Color(1, 1, 1);\n          var shininess = m.shininess || 0;\n          var reflectivity = m.reflectivity || 0;\n          var transparencyNode = \"\";\n          if (m.transparent) {\n            transparencyNode += \"<transparent>\".concat(m.map ? '<texture texture=\"diffuse-sampler\"></texture>' : \"<float>1</float>\", \"</transparent>\");\n            if (m.opacity < 1) {\n              transparencyNode += \"<transparency><float>\".concat(m.opacity, \"</float></transparency>\");\n            }\n          }\n          var techniqueNode = \"\".concat(\"<technique sid=\\\"common\\\"><\".concat(type, \">\"), \"<emission>\", m.emissiveMap ? '<texture texture=\"emissive-sampler\" texcoord=\"TEXCOORD\" />' : \"<color sid=\\\"emission\\\">\".concat(emissive.r, \" \").concat(emissive.g, \" \").concat(emissive.b, \" 1</color>\"), \"</emission>\").concat(type !== \"constant\" ? \"<diffuse>\".concat(m.map ? '<texture texture=\"diffuse-sampler\" texcoord=\"TEXCOORD\" />' : \"<color sid=\\\"diffuse\\\">\".concat(diffuse.r, \" \").concat(diffuse.g, \" \").concat(diffuse.b, \" 1</color>\"), \"</diffuse>\") : \"\").concat(type !== \"constant\" ? \"<bump>\".concat(m.normalMap ? '<texture texture=\"bump-sampler\" texcoord=\"TEXCOORD\" />' : \"\", \"</bump>\") : \"\").concat(type === \"phong\" ? \"\".concat(\"<specular><color sid=\\\"specular\\\">\".concat(specular.r, \" \").concat(specular.g, \" \").concat(specular.b, \" 1</color></specular>\"), \"<shininess>\", m.specularMap ? '<texture texture=\"specular-sampler\" texcoord=\"TEXCOORD\" />' : \"<float sid=\\\"shininess\\\">\".concat(shininess, \"</float>\"), \"</shininess>\") : \"\", \"<reflective><color>\".concat(diffuse.r, \" \").concat(diffuse.g, \" \").concat(diffuse.b, \" 1</color></reflective>\"), \"<reflectivity><float>\".concat(reflectivity, \"</float></reflectivity>\")).concat(transparencyNode, \"</\".concat(type, \"></technique>\"));\n          var effectnode = \"\".concat(\"<effect id=\\\"\".concat(matid, \"-effect\\\">\"), \"<profile_COMMON>\", m.map ? \"<newparam sid=\\\"diffuse-surface\\\"><surface type=\\\"2D\\\">\".concat(\"<init_from>\".concat(this.processTexture(m.map), \"</init_from>\"), \"</surface></newparam><newparam sid=\\\"diffuse-sampler\\\"><sampler2D><source>diffuse-surface</source></sampler2D></newparam>\") : \"\").concat(m.specularMap ? \"<newparam sid=\\\"specular-surface\\\"><surface type=\\\"2D\\\">\".concat(\"<init_from>\".concat(this.processTexture(m.specularMap), \"</init_from>\"), \"</surface></newparam><newparam sid=\\\"specular-sampler\\\"><sampler2D><source>specular-surface</source></sampler2D></newparam>\") : \"\").concat(m.emissiveMap ? \"<newparam sid=\\\"emissive-surface\\\"><surface type=\\\"2D\\\">\".concat(\"<init_from>\".concat(this.processTexture(m.emissiveMap), \"</init_from>\"), \"</surface></newparam><newparam sid=\\\"emissive-sampler\\\"><sampler2D><source>emissive-surface</source></sampler2D></newparam>\") : \"\").concat(m.normalMap ? \"<newparam sid=\\\"bump-surface\\\"><surface type=\\\"2D\\\">\".concat(\"<init_from>\".concat(this.processTexture(m.normalMap), \"</init_from>\"), \"</surface></newparam><newparam sid=\\\"bump-sampler\\\"><sampler2D><source>bump-surface</source></sampler2D></newparam>\") : \"\").concat(techniqueNode).concat(m.side === DoubleSide ? '<extra><technique profile=\"THREEJS\"><double_sided sid=\"double_sided\" type=\"int\">1</double_sided></technique></extra>' : \"\", \"</profile_COMMON></effect>\");\n          var materialName = m.name ? \" name=\\\"\".concat(m.name, \"\\\"\") : \"\";\n          var materialNode = \"<material id=\\\"\".concat(matid, \"\\\"\").concat(materialName, \"><instance_effect url=\\\"#\").concat(matid, \"-effect\\\" /></material>\");\n          this.libraryMaterials.push(materialNode);\n          this.libraryEffects.push(effectnode);\n          this.materialMap.set(m, matid);\n        }\n      }\n      return matid;\n    }\n    // Recursively process the object into a scene\n  }, {\n    key: \"processObject\",\n    value: function processObject(o) {\n      var _this = this;\n      var node = \"<node name=\\\"\".concat(o.name, \"\\\">\");\n      node += this.getTransform(o);\n      var a = new Mesh();\n      a.geometry;\n      if (o instanceof Mesh && o.isMesh && o.geometry !== null) {\n        var geomInfo = this.processGeometry(o.geometry);\n        var meshid = geomInfo.meshid;\n        var geometry = geomInfo.bufferGeometry;\n        var matids = null;\n        var matidsArray;\n        var mat = o.material || new MeshBasicMaterial();\n        var materials = Array.isArray(mat) ? mat : [mat];\n        if (geometry.groups.length > materials.length) {\n          matidsArray = new Array(geometry.groups.length);\n        } else {\n          matidsArray = new Array(materials.length);\n        }\n        matids = matidsArray.fill(null).map(function (_, i) {\n          return _this.processMaterial(materials[i % materials.length]);\n        });\n        node += \"\".concat(\"<instance_geometry url=\\\"#\".concat(meshid, \"\\\">\") + (matids != null ? \"<bind_material><technique_common>\".concat(matids.map(function (id, i) {\n          return \"\".concat(\"<instance_material symbol=\\\"MESH_MATERIAL_\".concat(i, \"\\\" target=\\\"#\").concat(id, \"\\\" >\"), \"<bind_vertex_input semantic=\\\"TEXCOORD\\\" input_semantic=\\\"TEXCOORD\\\" input_set=\\\"0\\\" /></instance_material>\");\n        }).join(\"\"), \"</technique_common></bind_material>\") : \"\"), \"</instance_geometry>\");\n      }\n      o.children.forEach(function (c) {\n        return node += _this.processObject(c);\n      });\n      node += \"</node>\";\n      return node;\n    }\n  }]);\n  return ColladaExporter;\n}();\nexport { ColladaExporter };","map":{"version":3,"names":["ColladaExporter","_classCallCheck","__publicField","options","version","author","textureDirectory","upAxis","unitName","unitMeter","geometryInfo","WeakMap","materialMap","imageMap","textures","libraryImages","libraryGeometries","libraryEffects","libraryMaterials","canvas","ctx","transMat","_createClass","key","value","parse","object","onDone","arguments","length","undefined","_objectSpread","match","console","error","concat","replace","warn","libraryVisualScenes","processObject","specLink","dae","Date","toISOString","join","res","data","format","requestAnimationFrame","urdf","IS_END_TAG","IS_SELF_CLOSING","HAS_TEXT","pad","ch","num","tagnum","_b","_a","map","tag","test","base64ToBuffer","str","b","atob","buf","Uint8Array","i","l","charCodeAt","imageToData","image","ext","document","createElement","getContext","width","SVGAnimatedLength","height","drawImage","base64data","toDataURL","attrBufferToArray","attr","InterleavedBufferAttribute","isInterleavedBufferAttribute","TypedArrayConstructor","array","constructor","arr","count","itemSize","size","j","getFuncs","subArray","st","ct","Array","isArray","slice","buffer","BYTES_PER_ELEMENT","getAttribute","name","params","type","Math","floor","n","getTransform","o","updateMatrix","Matrix4","copy","matrix","transpose","toArray","processGeometry","g","info","get","bufferGeometry","isBufferGeometry","Error","meshid","indexCount","index","attributes","position","groups","start","materialIndex","gname","gnode","posName","vertName","triangleInputs","normName","normal","uvName","uv","UV1","colName","color","indexArray","group","subarr","polycount","push","set","processTexture","tex","texid","imageNode","directory","original","processMaterial","m","matid","MeshLambertMaterial","MeshBasicMaterial","MeshPhongMaterial","emissive","Color","diffuse","specular","shininess","reflectivity","transparencyNode","transparent","opacity","techniqueNode","emissiveMap","r","normalMap","specularMap","effectnode","side","DoubleSide","materialName","materialNode","_this","node","a","Mesh","geometry","isMesh","geomInfo","matids","matidsArray","mat","material","materials","fill","_","id","children","forEach","c"],"sources":["C:\\Users\\Nayyu\\Desktop\\skibidai-public-build\\node_modules\\src\\exporters\\ColladaExporter.ts"],"sourcesContent":["import {\n  BufferAttribute,\n  BufferGeometry,\n  Color,\n  DoubleSide,\n  InterleavedBufferAttribute,\n  Material,\n  Matrix4,\n  Mesh,\n  MeshBasicMaterial,\n  MeshLambertMaterial,\n  MeshPhongMaterial,\n  Object3D,\n  Texture,\n} from 'three'\nimport type { TypedArray, TypedArrayConstructors } from '../types/shared'\nimport { UV1 } from '../_polyfill/uv1'\n\n/**\n * https://github.com/gkjohnson/collada-exporter-js\n *\n * Usage:\n *  const exporter = new ColladaExporter();\n *\n *  const data = exporter.parse(mesh);\n *\n * Format Definition:\n *  https://www.khronos.org/collada/\n */\n\nexport interface ColladaExporterOptions {\n  author?: string\n  textureDirectory?: string\n  version?: string\n}\n\nexport interface ColladaExporterResult {\n  data: string\n  textures: object[]\n}\n\ntype GeometryInfo = { meshid: string; bufferGeometry: BufferGeometry }\n\ntype MaterialRepresentation = MeshPhongMaterial | MeshBasicMaterial | MeshLambertMaterial\n\nclass ColladaExporter {\n  private options: {\n    version: string\n    author: string | null\n    textureDirectory: string\n    upAxis: string\n    unitName: string | null\n    unitMeter: string | null\n  }\n\n  private geometryInfo: WeakMap<BufferGeometry, GeometryInfo>\n  private materialMap: WeakMap<MaterialRepresentation, string>\n  private imageMap: WeakMap<Texture, string>\n  private textures: {\n    directory: string\n    name: string\n    ext: string\n    data: Uint8Array\n    original: Texture\n  }[]\n\n  private libraryImages: string[]\n  private libraryGeometries: string[]\n  private libraryEffects: string[]\n  private libraryMaterials: string[]\n\n  private canvas: HTMLCanvasElement | null\n  private ctx: CanvasRenderingContext2D | null\n\n  private transMat: Matrix4 | null\n\n  private getFuncs = ['getX', 'getY', 'getZ', 'getW'] as const\n\n  constructor() {\n    this.options = {\n      version: '1.4.1',\n      author: null,\n      textureDirectory: '',\n      upAxis: 'Y_UP',\n      unitName: null,\n      unitMeter: null,\n    }\n\n    this.geometryInfo = new WeakMap()\n    this.materialMap = new WeakMap()\n    this.imageMap = new WeakMap()\n    this.textures = []\n\n    this.libraryImages = []\n    this.libraryGeometries = []\n    this.libraryEffects = []\n    this.libraryMaterials = []\n\n    this.canvas = null\n    this.ctx = null\n\n    this.transMat = null\n  }\n\n  public parse(\n    object: Object3D,\n    onDone: (res: ColladaExporterResult) => void,\n    options: ColladaExporterOptions = {},\n  ): ColladaExporterResult | null {\n    this.options = { ...this.options, ...options }\n\n    if (this.options.upAxis.match(/^[XYZ]_UP$/) === null) {\n      console.error('ColladaExporter: Invalid upAxis: valid values are X_UP, Y_UP or Z_UP.')\n      return null\n    }\n\n    if (this.options.unitName !== null && this.options.unitMeter === null) {\n      console.error('ColladaExporter: unitMeter needs to be specified if unitName is specified.')\n      return null\n    }\n\n    if (this.options.unitMeter !== null && this.options.unitName === null) {\n      console.error('ColladaExporter: unitName needs to be specified if unitMeter is specified.')\n      return null\n    }\n\n    if (this.options.textureDirectory !== '') {\n      this.options.textureDirectory = `${this.options.textureDirectory}/`.replace(/\\\\/g, '/').replace(/\\/+/g, '/')\n    }\n\n    if (this.options.version !== '1.4.1' && this.options.version !== '1.5.0') {\n      console.warn(`ColladaExporter : Version ${this.options.version} not supported for export. Only 1.4.1 and 1.5.0.`)\n      return null\n    }\n\n    const libraryVisualScenes = this.processObject(object)\n\n    const specLink =\n      this.options.version === '1.4.1'\n        ? 'http://www.collada.org/2005/11/COLLADASchema'\n        : 'https://www.khronos.org/collada/'\n    let dae = `<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\" ?>${`<COLLADA xmlns=\"${specLink}\" version=\"${this.options.version}\">`}<asset><contributor><authoring_tool>three.js Collada Exporter</authoring_tool>${\n      this.options.author !== null ? `<author>${this.options.author}</author>` : ''\n    }</contributor>${`<created>${new Date().toISOString()}</created>`}${`<modified>${new Date().toISOString()}</modified>`}<up_axis>Y_UP</up_axis></asset>`\n\n    dae += `<library_images>${this.libraryImages.join('')}</library_images>`\n\n    dae += `<library_effects>${this.libraryEffects.join('')}</library_effects>`\n\n    dae += `<library_materials>${this.libraryMaterials.join('')}</library_materials>`\n\n    dae += `<library_geometries>${this.libraryGeometries.join('')}</library_geometries>`\n\n    dae += `<library_visual_scenes><visual_scene id=\"Scene\" name=\"scene\">${libraryVisualScenes}</visual_scene></library_visual_scenes>`\n\n    dae += '<scene><instance_visual_scene url=\"#Scene\"/></scene>'\n\n    dae += '</COLLADA>'\n\n    const res = {\n      data: this.format(dae),\n      textures: this.textures,\n    }\n\n    if (typeof onDone === 'function') {\n      requestAnimationFrame(() => onDone(res))\n    }\n\n    return res\n  }\n\n  // Convert the urdf xml into a well-formatted, indented format\n  private format(urdf: string): string {\n    const IS_END_TAG = /^<\\//\n    const IS_SELF_CLOSING = /(\\?>$)|(\\/>$)/\n    const HAS_TEXT = /<[^>]+>[^<]*<\\/[^<]+>/\n\n    const pad = (ch: string, num: number): string => (num > 0 ? ch + pad(ch, num - 1) : '')\n\n    let tagnum = 0\n\n    return (\n      urdf\n        .match(/(<[^>]+>[^<]+<\\/[^<]+>)|(<[^>]+>)/g)\n        ?.map((tag) => {\n          if (!HAS_TEXT.test(tag) && !IS_SELF_CLOSING.test(tag) && IS_END_TAG.test(tag)) {\n            tagnum--\n          }\n\n          const res = `${pad('  ', tagnum)}${tag}`\n\n          if (!HAS_TEXT.test(tag) && !IS_SELF_CLOSING.test(tag) && !IS_END_TAG.test(tag)) {\n            tagnum++\n          }\n\n          return res\n        })\n        .join('\\n') ?? ''\n    )\n  }\n\n  // Convert an image into a png format for saving\n  private base64ToBuffer(str: string): Uint8Array {\n    const b = atob(str)\n    const buf = new Uint8Array(b.length)\n\n    for (let i = 0, l = buf.length; i < l; i++) {\n      buf[i] = b.charCodeAt(i)\n    }\n\n    return buf\n  }\n\n  private imageToData(image: CanvasImageSource, ext: string): Uint8Array {\n    this.canvas = this.canvas || document.createElement('canvas')\n    this.ctx = this.ctx || this.canvas.getContext('2d')\n\n    this.canvas.width = image.width instanceof SVGAnimatedLength ? 0 : image.width\n    this.canvas.height = image.height instanceof SVGAnimatedLength ? 0 : image.height\n\n    this.ctx?.drawImage(image, 0, 0)\n\n    // Get the base64 encoded data\n    const base64data = this.canvas.toDataURL(`image/${ext}`, 1).replace(/^data:image\\/(png|jpg);base64,/, '')\n\n    // Convert to a uint8 array\n    return this.base64ToBuffer(base64data)\n  }\n\n  // gets the attribute array. Generate a new array if the attribute is interleaved\n  private attrBufferToArray(attr: InterleavedBufferAttribute | BufferAttribute): number[] | ArrayLike<number> {\n    if (attr instanceof InterleavedBufferAttribute && attr.isInterleavedBufferAttribute) {\n      // use the typed array constructor to save on memory\n      const TypedArrayConstructor: TypedArrayConstructors = attr.array.constructor\n      // @ts-ignore\n      const arr: number[] = new TypedArrayConstructor(attr.count * attr.itemSize)\n      const size = attr.itemSize\n\n      for (let i = 0, l = attr.count; i < l; i++) {\n        for (let j = 0; j < size; j++) {\n          arr[i * size + j] = attr[this.getFuncs[j]](i)\n        }\n      }\n\n      return arr\n    } else {\n      return attr.array\n    }\n  }\n\n  // Returns an array of the same type starting at the `st` index,\n  // and `ct` length\n  private subArray(arr: number[] | ArrayLike<number>, st: number, ct: number): TypedArray | number[] {\n    if (Array.isArray(arr)) {\n      return arr.slice(st, st + ct)\n    } else {\n      const TypedArrayConstructor: TypedArrayConstructors = arr.constructor\n      // @ts-ignore\n      return new TypedArrayConstructor(arr.buffer, st * arr.BYTES_PER_ELEMENT, ct)\n    }\n  }\n\n  // Returns the string for a geometry's attribute\n  private getAttribute(\n    attr: InterleavedBufferAttribute | BufferAttribute,\n    name: string,\n    params: string[],\n    type: string,\n  ): string {\n    const array = this.attrBufferToArray(attr)\n    const res = Array.isArray(array)\n      ? `${\n          `<source id=\"${name}\">` + `<float_array id=\"${name}-array\" count=\"${array.length}\">` + array.join(' ')\n        }</float_array><technique_common>${`<accessor source=\"#${name}-array\" count=\"${Math.floor(\n          array.length / attr.itemSize,\n        )}\" stride=\"${attr.itemSize}\">`}${params\n          .map((n) => `<param name=\"${n}\" type=\"${type}\" />`)\n          .join('')}</accessor></technique_common></source>`\n      : ''\n\n    return res\n  }\n\n  // Returns the string for a node's transform information\n  private getTransform(o: Object3D): string {\n    // ensure the object's matrix is up to date\n    // before saving the transform\n    o.updateMatrix()\n\n    this.transMat = this.transMat || new Matrix4()\n    this.transMat.copy(o.matrix)\n    this.transMat.transpose()\n    return `<matrix>${this.transMat.toArray().join(' ')}</matrix>`\n  }\n\n  // Process the given piece of geometry into the geometry library\n  // Returns the mesh id\n  private processGeometry(g: BufferGeometry): GeometryInfo {\n    let info = this.geometryInfo.get(g)\n\n    if (!info) {\n      // convert the geometry to bufferGeometry if it isn't already\n      const bufferGeometry = g\n\n      if (!bufferGeometry.isBufferGeometry) {\n        throw new Error('THREE.ColladaExporter: Geometry is not of type THREE.BufferGeometry.')\n      }\n\n      const meshid = `Mesh${this.libraryGeometries.length + 1}`\n\n      const indexCount = bufferGeometry.index\n        ? bufferGeometry.index.count * bufferGeometry.index.itemSize\n        : bufferGeometry.attributes.position.count\n\n      const groups =\n        bufferGeometry.groups != null && bufferGeometry.groups.length !== 0\n          ? bufferGeometry.groups\n          : [{ start: 0, count: indexCount, materialIndex: 0 }]\n\n      const gname = g.name ? ` name=\"${g.name}\"` : ''\n      let gnode = `<geometry id=\"${meshid}\"${gname}><mesh>`\n\n      // define the geometry node and the vertices for the geometry\n      const posName = `${meshid}-position`\n      const vertName = `${meshid}-vertices`\n      gnode += this.getAttribute(bufferGeometry.attributes.position, posName, ['X', 'Y', 'Z'], 'float')\n      gnode += `<vertices id=\"${vertName}\"><input semantic=\"POSITION\" source=\"#${posName}\" /></vertices>`\n\n      // NOTE: We're not optimizing the attribute arrays here, so they're all the same length and\n      // can therefore share the same triangle indices. However, MeshLab seems to have trouble opening\n      // models with attributes that share an offset.\n      // MeshLab Bug#424: https://sourceforge.net/p/meshlab/bugs/424/\n\n      // serialize normals\n      let triangleInputs = `<input semantic=\"VERTEX\" source=\"#${vertName}\" offset=\"0\" />`\n      if ('normal' in bufferGeometry.attributes) {\n        const normName = `${meshid}-normal`\n        gnode += this.getAttribute(bufferGeometry.attributes.normal, normName, ['X', 'Y', 'Z'], 'float')\n        triangleInputs += `<input semantic=\"NORMAL\" source=\"#${normName}\" offset=\"0\" />`\n      }\n\n      // serialize uvs\n      if ('uv' in bufferGeometry.attributes) {\n        const uvName = `${meshid}-texcoord`\n        gnode += this.getAttribute(bufferGeometry.attributes.uv, uvName, ['S', 'T'], 'float')\n        triangleInputs += `<input semantic=\"TEXCOORD\" source=\"#${uvName}\" offset=\"0\" set=\"0\" />`\n      }\n\n      // serialize lightmap uvs\n      if (UV1 in bufferGeometry.attributes) {\n        const uvName = `${meshid}-texcoord2`\n        gnode += this.getAttribute(bufferGeometry.attributes[UV1], uvName, ['S', 'T'], 'float')\n        triangleInputs += `<input semantic=\"TEXCOORD\" source=\"#${uvName}\" offset=\"0\" set=\"1\" />`\n      }\n\n      // serialize colors\n      if ('color' in bufferGeometry.attributes) {\n        const colName = `${meshid}-color`\n        gnode += this.getAttribute(bufferGeometry.attributes.color, colName, ['X', 'Y', 'Z'], 'uint8')\n        triangleInputs += `<input semantic=\"COLOR\" source=\"#${colName}\" offset=\"0\" />`\n      }\n\n      let indexArray: number[] | ArrayLike<number> | null = null\n      if (bufferGeometry.index) {\n        indexArray = this.attrBufferToArray(bufferGeometry.index)\n      } else {\n        indexArray = new Array(indexCount)\n        for (let i = 0, l = indexArray.length; i < l && Array.isArray(indexArray); i++) indexArray[i] = i\n      }\n\n      for (let i = 0, l = groups.length; i < l; i++) {\n        const group = groups[i]\n        const subarr = this.subArray(indexArray, group.start, group.count)\n        const polycount = subarr.length / 3\n        gnode += `<triangles material=\"MESH_MATERIAL_${group.materialIndex}\" count=\"${polycount}\">`\n        gnode += triangleInputs\n\n        gnode += `<p>${subarr.join(' ')}</p>`\n        gnode += '</triangles>'\n      }\n\n      gnode += '</mesh></geometry>'\n\n      this.libraryGeometries.push(gnode)\n\n      info = { meshid, bufferGeometry }\n      this.geometryInfo.set(g, info)\n    }\n\n    return info\n  }\n\n  // Process the given texture into the image library\n  // Returns the image library\n  private processTexture(tex: Texture): string {\n    let texid = this.imageMap.get(tex)\n    if (texid == null) {\n      texid = `image-${this.libraryImages.length + 1}`\n\n      const ext = 'png'\n      const name = tex.name || texid\n      let imageNode = `<image id=\"${texid}\" name=\"${name}\">`\n\n      if (this.options.version === '1.5.0') {\n        imageNode += `<init_from><ref>${this.options.textureDirectory}${name}.${ext}</ref></init_from>`\n      } else {\n        // version image node 1.4.1\n        imageNode += `<init_from>${this.options.textureDirectory}${name}.${ext}</init_from>`\n      }\n\n      imageNode += '</image>'\n\n      this.libraryImages.push(imageNode)\n      this.imageMap.set(tex, texid)\n      this.textures.push({\n        directory: this.options.textureDirectory,\n        name,\n        ext,\n        data: this.imageToData(tex.image, ext),\n        original: tex,\n      })\n    }\n\n    return texid\n  }\n\n  // Process the given material into the material and effect libraries\n  // Returns the material id\n  private processMaterial(m: MaterialRepresentation): string {\n    let matid = this.materialMap.get(m)\n\n    if (matid == null) {\n      matid = `Mat${this.libraryEffects.length + 1}`\n\n      let type = 'phong'\n\n      if (m instanceof MeshLambertMaterial) {\n        type = 'lambert'\n      } else if (m instanceof MeshBasicMaterial) {\n        type = 'constant'\n\n        if (m.map !== null) {\n          // The Collada spec does not support diffuse texture maps with the\n          // constant shader type.\n          // mrdoob/three.js#15469\n          console.warn('ColladaExporter: Texture maps not supported with MeshBasicMaterial.')\n        }\n      }\n\n      if (m instanceof MeshPhongMaterial) {\n        const emissive = m.emissive ? m.emissive : new Color(0, 0, 0)\n        const diffuse = m.color ? m.color : new Color(0, 0, 0)\n        const specular = m.specular ? m.specular : new Color(1, 1, 1)\n        const shininess = m.shininess || 0\n        const reflectivity = m.reflectivity || 0\n\n        // Do not export and alpha map for the reasons mentioned in issue (#13792)\n        // in three.js alpha maps are black and white, but collada expects the alpha\n        // channel to specify the transparency\n        let transparencyNode = ''\n        if (m.transparent) {\n          transparencyNode += `<transparent>${\n            m.map ? '<texture texture=\"diffuse-sampler\"></texture>' : '<float>1</float>'\n          }</transparent>`\n\n          if (m.opacity < 1) {\n            transparencyNode += `<transparency><float>${m.opacity}</float></transparency>`\n          }\n        }\n\n        const techniqueNode = `${`<technique sid=\"common\"><${type}>`}<emission>${\n          m.emissiveMap\n            ? '<texture texture=\"emissive-sampler\" texcoord=\"TEXCOORD\" />'\n            : `<color sid=\"emission\">${emissive.r} ${emissive.g} ${emissive.b} 1</color>`\n        }</emission>${\n          type !== 'constant'\n            ? `<diffuse>${\n                m.map\n                  ? '<texture texture=\"diffuse-sampler\" texcoord=\"TEXCOORD\" />'\n                  : `<color sid=\"diffuse\">${diffuse.r} ${diffuse.g} ${diffuse.b} 1</color>`\n              }</diffuse>`\n            : ''\n        }${\n          type !== 'constant'\n            ? `<bump>${m.normalMap ? '<texture texture=\"bump-sampler\" texcoord=\"TEXCOORD\" />' : ''}</bump>`\n            : ''\n        }${\n          type === 'phong'\n            ? `${`<specular><color sid=\"specular\">${specular.r} ${specular.g} ${specular.b} 1</color></specular>`}<shininess>${\n                m.specularMap\n                  ? '<texture texture=\"specular-sampler\" texcoord=\"TEXCOORD\" />'\n                  : `<float sid=\"shininess\">${shininess}</float>`\n              }</shininess>`\n            : ''\n        }${`<reflective><color>${diffuse.r} ${diffuse.g} ${diffuse.b} 1</color></reflective>`}${`<reflectivity><float>${reflectivity}</float></reflectivity>`}${transparencyNode}${`</${type}></technique>`}`\n\n        const effectnode = `${`<effect id=\"${matid}-effect\">`}<profile_COMMON>${\n          m.map\n            ? `<newparam sid=\"diffuse-surface\"><surface type=\"2D\">${`<init_from>${this.processTexture(\n                m.map,\n              )}</init_from>`}</surface></newparam><newparam sid=\"diffuse-sampler\"><sampler2D><source>diffuse-surface</source></sampler2D></newparam>`\n            : ''\n        }${\n          m.specularMap\n            ? `<newparam sid=\"specular-surface\"><surface type=\"2D\">${`<init_from>${this.processTexture(\n                m.specularMap,\n              )}</init_from>`}</surface></newparam><newparam sid=\"specular-sampler\"><sampler2D><source>specular-surface</source></sampler2D></newparam>`\n            : ''\n        }${\n          m.emissiveMap\n            ? `<newparam sid=\"emissive-surface\"><surface type=\"2D\">${`<init_from>${this.processTexture(\n                m.emissiveMap,\n              )}</init_from>`}</surface></newparam><newparam sid=\"emissive-sampler\"><sampler2D><source>emissive-surface</source></sampler2D></newparam>`\n            : ''\n        }${\n          m.normalMap\n            ? `<newparam sid=\"bump-surface\"><surface type=\"2D\">${`<init_from>${this.processTexture(\n                m.normalMap,\n              )}</init_from>`}</surface></newparam><newparam sid=\"bump-sampler\"><sampler2D><source>bump-surface</source></sampler2D></newparam>`\n            : ''\n        }${techniqueNode}${\n          m.side === DoubleSide\n            ? '<extra><technique profile=\"THREEJS\"><double_sided sid=\"double_sided\" type=\"int\">1</double_sided></technique></extra>'\n            : ''\n        }</profile_COMMON></effect>`\n\n        const materialName = m.name ? ` name=\"${m.name}\"` : ''\n        const materialNode = `<material id=\"${matid}\"${materialName}><instance_effect url=\"#${matid}-effect\" /></material>`\n\n        this.libraryMaterials.push(materialNode)\n        this.libraryEffects.push(effectnode)\n        this.materialMap.set(m, matid)\n      }\n    }\n\n    return matid\n  }\n\n  // Recursively process the object into a scene\n  private processObject(o: Object3D): string {\n    let node = `<node name=\"${o.name}\">`\n\n    node += this.getTransform(o)\n    const a: Mesh<BufferGeometry, Material | Material[]> = new Mesh()\n    a.geometry\n\n    if (o instanceof Mesh && o.isMesh && o.geometry !== null) {\n      // function returns the id associated with the mesh and a \"BufferGeometry\" version\n      // of the geometry in case it's not a geometry.\n      const geomInfo = this.processGeometry(o.geometry)\n      const meshid = geomInfo.meshid\n      const geometry = geomInfo.bufferGeometry\n\n      // ids of the materials to bind to the geometry\n      let matids = null\n      let matidsArray\n\n      // get a list of materials to bind to the sub groups of the geometry.\n      // If the amount of subgroups is greater than the materials, than reuse\n      // the materials.\n      const mat: MaterialRepresentation | MaterialRepresentation[] = o.material || new MeshBasicMaterial()\n      const materials = Array.isArray(mat) ? mat : [mat]\n\n      if (geometry.groups.length > materials.length) {\n        matidsArray = new Array(geometry.groups.length)\n      } else {\n        matidsArray = new Array(materials.length)\n      }\n\n      matids = matidsArray.fill(null).map((_, i) => this.processMaterial(materials[i % materials.length]))\n\n      node += `${\n        `<instance_geometry url=\"#${meshid}\">` +\n        (matids != null\n          ? `<bind_material><technique_common>${matids\n              .map(\n                (id, i) =>\n                  `${`<instance_material symbol=\"MESH_MATERIAL_${i}\" target=\"#${id}\" >`}<bind_vertex_input semantic=\"TEXCOORD\" input_semantic=\"TEXCOORD\" input_set=\"0\" /></instance_material>`,\n              )\n              .join('')}</technique_common></bind_material>`\n          : '')\n      }</instance_geometry>`\n    }\n\n    o.children.forEach((c) => (node += this.processObject(c)))\n\n    node += '</node>'\n\n    return node\n  }\n}\n\nexport { ColladaExporter }\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}