{"ast":null,"code":"import _createClass from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _classCallCheck from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport { Scene, Camera, Mesh, PlaneGeometry, ShaderMaterial, WebGLRenderTarget, RGBAFormat, DataTexture, FloatType, NoToneMapping, NearestFilter, ClampToEdgeWrapping } from \"three\";\nvar GPUComputationRenderer = /*#__PURE__*/_createClass(function GPUComputationRenderer(sizeX, sizeY, renderer) {\n  _classCallCheck(this, GPUComputationRenderer);\n  this.variables = [];\n  this.currentTextureIndex = 0;\n  var dataType = FloatType;\n  var scene = new Scene();\n  var camera = new Camera();\n  camera.position.z = 1;\n  var passThruUniforms = {\n    passThruTexture: {\n      value: null\n    }\n  };\n  var passThruShader = createShaderMaterial(getPassThroughFragmentShader(), passThruUniforms);\n  var mesh = new Mesh(new PlaneGeometry(2, 2), passThruShader);\n  scene.add(mesh);\n  this.setDataType = function (type) {\n    dataType = type;\n    return this;\n  };\n  this.addVariable = function (variableName, computeFragmentShader, initialValueTexture) {\n    var material = this.createShaderMaterial(computeFragmentShader);\n    var variable = {\n      name: variableName,\n      initialValueTexture: initialValueTexture,\n      material: material,\n      dependencies: null,\n      renderTargets: [],\n      wrapS: null,\n      wrapT: null,\n      minFilter: NearestFilter,\n      magFilter: NearestFilter\n    };\n    this.variables.push(variable);\n    return variable;\n  };\n  this.setVariableDependencies = function (variable, dependencies) {\n    variable.dependencies = dependencies;\n  };\n  this.init = function () {\n    if (renderer.capabilities.isWebGL2 === false && renderer.extensions.has(\"OES_texture_float\") === false) {\n      return \"No OES_texture_float support for float textures.\";\n    }\n    if (renderer.capabilities.maxVertexTextures === 0) {\n      return \"No support for vertex shader textures.\";\n    }\n    for (var i = 0; i < this.variables.length; i++) {\n      var variable = this.variables[i];\n      variable.renderTargets[0] = this.createRenderTarget(sizeX, sizeY, variable.wrapS, variable.wrapT, variable.minFilter, variable.magFilter);\n      variable.renderTargets[1] = this.createRenderTarget(sizeX, sizeY, variable.wrapS, variable.wrapT, variable.minFilter, variable.magFilter);\n      this.renderTexture(variable.initialValueTexture, variable.renderTargets[0]);\n      this.renderTexture(variable.initialValueTexture, variable.renderTargets[1]);\n      var material = variable.material;\n      var uniforms = material.uniforms;\n      if (variable.dependencies !== null) {\n        for (var d = 0; d < variable.dependencies.length; d++) {\n          var depVar = variable.dependencies[d];\n          if (depVar.name !== variable.name) {\n            var found = false;\n            for (var j = 0; j < this.variables.length; j++) {\n              if (depVar.name === this.variables[j].name) {\n                found = true;\n                break;\n              }\n            }\n            if (!found) {\n              return \"Variable dependency not found. Variable=\" + variable.name + \", dependency=\" + depVar.name;\n            }\n          }\n          uniforms[depVar.name] = {\n            value: null\n          };\n          material.fragmentShader = \"\\nuniform sampler2D \" + depVar.name + \";\\n\" + material.fragmentShader;\n        }\n      }\n    }\n    this.currentTextureIndex = 0;\n    return null;\n  };\n  this.compute = function () {\n    var currentTextureIndex = this.currentTextureIndex;\n    var nextTextureIndex = this.currentTextureIndex === 0 ? 1 : 0;\n    for (var i = 0, il = this.variables.length; i < il; i++) {\n      var variable = this.variables[i];\n      if (variable.dependencies !== null) {\n        var uniforms = variable.material.uniforms;\n        for (var d = 0, dl = variable.dependencies.length; d < dl; d++) {\n          var depVar = variable.dependencies[d];\n          uniforms[depVar.name].value = depVar.renderTargets[currentTextureIndex].texture;\n        }\n      }\n      this.doRenderTarget(variable.material, variable.renderTargets[nextTextureIndex]);\n    }\n    this.currentTextureIndex = nextTextureIndex;\n  };\n  this.getCurrentRenderTarget = function (variable) {\n    return variable.renderTargets[this.currentTextureIndex];\n  };\n  this.getAlternateRenderTarget = function (variable) {\n    return variable.renderTargets[this.currentTextureIndex === 0 ? 1 : 0];\n  };\n  this.dispose = function () {\n    mesh.geometry.dispose();\n    mesh.material.dispose();\n    var variables = this.variables;\n    for (var i = 0; i < variables.length; i++) {\n      var variable = variables[i];\n      if (variable.initialValueTexture) variable.initialValueTexture.dispose();\n      var renderTargets = variable.renderTargets;\n      for (var j = 0; j < renderTargets.length; j++) {\n        var renderTarget = renderTargets[j];\n        renderTarget.dispose();\n      }\n    }\n  };\n  function addResolutionDefine(materialShader) {\n    materialShader.defines.resolution = \"vec2( \" + sizeX.toFixed(1) + \", \" + sizeY.toFixed(1) + \" )\";\n  }\n  this.addResolutionDefine = addResolutionDefine;\n  function createShaderMaterial(computeFragmentShader, uniforms) {\n    uniforms = uniforms || {};\n    var material = new ShaderMaterial({\n      uniforms: uniforms,\n      vertexShader: getPassThroughVertexShader(),\n      fragmentShader: computeFragmentShader\n    });\n    addResolutionDefine(material);\n    return material;\n  }\n  this.createShaderMaterial = createShaderMaterial;\n  this.createRenderTarget = function (sizeXTexture, sizeYTexture, wrapS, wrapT, minFilter, magFilter) {\n    sizeXTexture = sizeXTexture || sizeX;\n    sizeYTexture = sizeYTexture || sizeY;\n    wrapS = wrapS || ClampToEdgeWrapping;\n    wrapT = wrapT || ClampToEdgeWrapping;\n    minFilter = minFilter || NearestFilter;\n    magFilter = magFilter || NearestFilter;\n    var renderTarget = new WebGLRenderTarget(sizeXTexture, sizeYTexture, {\n      wrapS: wrapS,\n      wrapT: wrapT,\n      minFilter: minFilter,\n      magFilter: magFilter,\n      format: RGBAFormat,\n      type: dataType,\n      depthBuffer: false\n    });\n    return renderTarget;\n  };\n  this.createTexture = function () {\n    var data = new Float32Array(sizeX * sizeY * 4);\n    var texture = new DataTexture(data, sizeX, sizeY, RGBAFormat, FloatType);\n    texture.needsUpdate = true;\n    return texture;\n  };\n  this.renderTexture = function (input, output) {\n    passThruUniforms.passThruTexture.value = input;\n    this.doRenderTarget(passThruShader, output);\n    passThruUniforms.passThruTexture.value = null;\n  };\n  this.doRenderTarget = function (material, output) {\n    var currentRenderTarget = renderer.getRenderTarget();\n    var currentXrEnabled = renderer.xr.enabled;\n    var currentShadowAutoUpdate = renderer.shadowMap.autoUpdate;\n    var currentOutputColorSpace = renderer.outputColorSpace;\n    var currentToneMapping = renderer.toneMapping;\n    renderer.xr.enabled = false;\n    renderer.shadowMap.autoUpdate = false;\n    if (\"outputColorSpace\" in renderer) renderer.outputColorSpace = \"srgb-linear\";else renderer.encoding = 3e3;\n    renderer.toneMapping = NoToneMapping;\n    mesh.material = material;\n    renderer.setRenderTarget(output);\n    renderer.render(scene, camera);\n    mesh.material = passThruShader;\n    renderer.xr.enabled = currentXrEnabled;\n    renderer.shadowMap.autoUpdate = currentShadowAutoUpdate;\n    renderer.outputColorSpace = currentOutputColorSpace;\n    renderer.toneMapping = currentToneMapping;\n    renderer.setRenderTarget(currentRenderTarget);\n  };\n  function getPassThroughVertexShader() {\n    return \"void main()\t{\\n\\n\tgl_Position = vec4( position, 1.0 );\\n\\n}\\n\";\n  }\n  function getPassThroughFragmentShader() {\n    return \"uniform sampler2D passThruTexture;\\n\\nvoid main() {\\n\\n\tvec2 uv = gl_FragCoord.xy / resolution.xy;\\n\\n\tgl_FragColor = texture2D( passThruTexture, uv );\\n\\n}\\n\";\n  }\n});\nexport { GPUComputationRenderer };","map":{"version":3,"names":["GPUComputationRenderer","_createClass","sizeX","sizeY","renderer","_classCallCheck","variables","currentTextureIndex","dataType","FloatType","scene","Scene","camera","Camera","position","z","passThruUniforms","passThruTexture","value","passThruShader","createShaderMaterial","getPassThroughFragmentShader","mesh","Mesh","PlaneGeometry","add","setDataType","type","addVariable","variableName","computeFragmentShader","initialValueTexture","material","variable","name","dependencies","renderTargets","wrapS","wrapT","minFilter","NearestFilter","magFilter","push","setVariableDependencies","init","capabilities","isWebGL2","extensions","has","maxVertexTextures","i","length","createRenderTarget","renderTexture","uniforms","d","depVar","found","j","fragmentShader","compute","nextTextureIndex","il","dl","texture","doRenderTarget","getCurrentRenderTarget","getAlternateRenderTarget","dispose","geometry","renderTarget","addResolutionDefine","materialShader","defines","resolution","toFixed","ShaderMaterial","vertexShader","getPassThroughVertexShader","sizeXTexture","sizeYTexture","ClampToEdgeWrapping","WebGLRenderTarget","format","RGBAFormat","depthBuffer","createTexture","data","Float32Array","DataTexture","needsUpdate","input","output","currentRenderTarget","getRenderTarget","currentXrEnabled","xr","enabled","currentShadowAutoUpdate","shadowMap","autoUpdate","currentOutputColorSpace","outputColorSpace","currentToneMapping","toneMapping","encoding","NoToneMapping","setRenderTarget","render"],"sources":["C:\\Users\\Nayyu\\Desktop\\skibidai-public-build\\node_modules\\src\\misc\\GPUComputationRenderer.js"],"sourcesContent":["import {\n  Camera,\n  ClampToEdgeWrapping,\n  DataTexture,\n  FloatType,\n  Mesh,\n  NearestFilter,\n  NoToneMapping,\n  PlaneGeometry,\n  RGBAFormat,\n  Scene,\n  ShaderMaterial,\n  WebGLRenderTarget,\n} from 'three'\n\n/**\n * GPUComputationRenderer, based on SimulationRenderer by zz85\n *\n * The GPUComputationRenderer uses the concept of variables. These variables are RGBA float textures that hold 4 floats\n * for each compute element (texel)\n *\n * Each variable has a fragment shader that defines the computation made to obtain the variable in question.\n * You can use as many variables you need, and make dependencies so you can use textures of other variables in the shader\n * (the sampler uniforms are added automatically) Most of the variables will need themselves as dependency.\n *\n * The renderer has actually two render targets per variable, to make ping-pong. Textures from the current frame are used\n * as inputs to render the textures of the next frame.\n *\n * The render targets of the variables can be used as input textures for your visualization shaders.\n *\n * Variable names should be valid identifiers and should not collide with THREE GLSL used identifiers.\n * a common approach could be to use 'texture' prefixing the variable name; i.e texturePosition, textureVelocity...\n *\n * The size of the computation (sizeX * sizeY) is defined as 'resolution' automatically in the shader. For example:\n * #DEFINE resolution vec2( 1024.0, 1024.0 )\n *\n * -------------\n *\n * Basic use:\n *\n * // Initialization...\n *\n * // Create computation renderer\n * const gpuCompute = new GPUComputationRenderer( 1024, 1024, renderer );\n *\n * // Create initial state float textures\n * const pos0 = gpuCompute.createTexture();\n * const vel0 = gpuCompute.createTexture();\n * // and fill in here the texture data...\n *\n * // Add texture variables\n * const velVar = gpuCompute.addVariable( \"textureVelocity\", fragmentShaderVel, pos0 );\n * const posVar = gpuCompute.addVariable( \"texturePosition\", fragmentShaderPos, vel0 );\n *\n * // Add variable dependencies\n * gpuCompute.setVariableDependencies( velVar, [ velVar, posVar ] );\n * gpuCompute.setVariableDependencies( posVar, [ velVar, posVar ] );\n *\n * // Add custom uniforms\n * velVar.material.uniforms.time = { value: 0.0 };\n *\n * // Check for completeness\n * const error = gpuCompute.init();\n * if ( error !== null ) {\n *\t\tconsole.error( error );\n * }\n *\n *\n * // In each frame...\n *\n * // Compute!\n * gpuCompute.compute();\n *\n * // Update texture uniforms in your visualization materials with the gpu renderer output\n * myMaterial.uniforms.myTexture.value = gpuCompute.getCurrentRenderTarget( posVar ).texture;\n *\n * // Do your rendering\n * renderer.render( myScene, myCamera );\n *\n * -------------\n *\n * Also, you can use utility functions to create ShaderMaterial and perform computations (rendering between textures)\n * Note that the shaders can have multiple input textures.\n *\n * const myFilter1 = gpuCompute.createShaderMaterial( myFilterFragmentShader1, { theTexture: { value: null } } );\n * const myFilter2 = gpuCompute.createShaderMaterial( myFilterFragmentShader2, { theTexture: { value: null } } );\n *\n * const inputTexture = gpuCompute.createTexture();\n *\n * // Fill in here inputTexture...\n *\n * myFilter1.uniforms.theTexture.value = inputTexture;\n *\n * const myRenderTarget = gpuCompute.createRenderTarget();\n * myFilter2.uniforms.theTexture.value = myRenderTarget.texture;\n *\n * const outputRenderTarget = gpuCompute.createRenderTarget();\n *\n * // Now use the output texture where you want:\n * myMaterial.uniforms.map.value = outputRenderTarget.texture;\n *\n * // And compute each frame, before rendering to screen:\n * gpuCompute.doRenderTarget( myFilter1, myRenderTarget );\n * gpuCompute.doRenderTarget( myFilter2, outputRenderTarget );\n *\n *\n *\n * @param {int} sizeX Computation problem size is always 2d: sizeX * sizeY elements.\n * @param {int} sizeY Computation problem size is always 2d: sizeX * sizeY elements.\n * @param {WebGLRenderer} renderer The renderer\n */\n\nclass GPUComputationRenderer {\n  constructor(sizeX, sizeY, renderer) {\n    this.variables = []\n\n    this.currentTextureIndex = 0\n\n    let dataType = FloatType\n\n    const scene = new Scene()\n\n    const camera = new Camera()\n    camera.position.z = 1\n\n    const passThruUniforms = {\n      passThruTexture: { value: null },\n    }\n\n    const passThruShader = createShaderMaterial(getPassThroughFragmentShader(), passThruUniforms)\n\n    const mesh = new Mesh(new PlaneGeometry(2, 2), passThruShader)\n    scene.add(mesh)\n\n    this.setDataType = function (type) {\n      dataType = type\n      return this\n    }\n\n    this.addVariable = function (variableName, computeFragmentShader, initialValueTexture) {\n      const material = this.createShaderMaterial(computeFragmentShader)\n\n      const variable = {\n        name: variableName,\n        initialValueTexture: initialValueTexture,\n        material: material,\n        dependencies: null,\n        renderTargets: [],\n        wrapS: null,\n        wrapT: null,\n        minFilter: NearestFilter,\n        magFilter: NearestFilter,\n      }\n\n      this.variables.push(variable)\n\n      return variable\n    }\n\n    this.setVariableDependencies = function (variable, dependencies) {\n      variable.dependencies = dependencies\n    }\n\n    this.init = function () {\n      if (renderer.capabilities.isWebGL2 === false && renderer.extensions.has('OES_texture_float') === false) {\n        return 'No OES_texture_float support for float textures.'\n      }\n\n      if (renderer.capabilities.maxVertexTextures === 0) {\n        return 'No support for vertex shader textures.'\n      }\n\n      for (let i = 0; i < this.variables.length; i++) {\n        const variable = this.variables[i]\n\n        // Creates rendertargets and initialize them with input texture\n        variable.renderTargets[0] = this.createRenderTarget(\n          sizeX,\n          sizeY,\n          variable.wrapS,\n          variable.wrapT,\n          variable.minFilter,\n          variable.magFilter,\n        )\n        variable.renderTargets[1] = this.createRenderTarget(\n          sizeX,\n          sizeY,\n          variable.wrapS,\n          variable.wrapT,\n          variable.minFilter,\n          variable.magFilter,\n        )\n        this.renderTexture(variable.initialValueTexture, variable.renderTargets[0])\n        this.renderTexture(variable.initialValueTexture, variable.renderTargets[1])\n\n        // Adds dependencies uniforms to the ShaderMaterial\n        const material = variable.material\n        const uniforms = material.uniforms\n\n        if (variable.dependencies !== null) {\n          for (let d = 0; d < variable.dependencies.length; d++) {\n            const depVar = variable.dependencies[d]\n\n            if (depVar.name !== variable.name) {\n              // Checks if variable exists\n              let found = false\n\n              for (let j = 0; j < this.variables.length; j++) {\n                if (depVar.name === this.variables[j].name) {\n                  found = true\n                  break\n                }\n              }\n\n              if (!found) {\n                return 'Variable dependency not found. Variable=' + variable.name + ', dependency=' + depVar.name\n              }\n            }\n\n            uniforms[depVar.name] = { value: null }\n\n            material.fragmentShader = '\\nuniform sampler2D ' + depVar.name + ';\\n' + material.fragmentShader\n          }\n        }\n      }\n\n      this.currentTextureIndex = 0\n\n      return null\n    }\n\n    this.compute = function () {\n      const currentTextureIndex = this.currentTextureIndex\n      const nextTextureIndex = this.currentTextureIndex === 0 ? 1 : 0\n\n      for (let i = 0, il = this.variables.length; i < il; i++) {\n        const variable = this.variables[i]\n\n        // Sets texture dependencies uniforms\n        if (variable.dependencies !== null) {\n          const uniforms = variable.material.uniforms\n\n          for (let d = 0, dl = variable.dependencies.length; d < dl; d++) {\n            const depVar = variable.dependencies[d]\n\n            uniforms[depVar.name].value = depVar.renderTargets[currentTextureIndex].texture\n          }\n        }\n\n        // Performs the computation for this variable\n        this.doRenderTarget(variable.material, variable.renderTargets[nextTextureIndex])\n      }\n\n      this.currentTextureIndex = nextTextureIndex\n    }\n\n    this.getCurrentRenderTarget = function (variable) {\n      return variable.renderTargets[this.currentTextureIndex]\n    }\n\n    this.getAlternateRenderTarget = function (variable) {\n      return variable.renderTargets[this.currentTextureIndex === 0 ? 1 : 0]\n    }\n\n    this.dispose = function () {\n      mesh.geometry.dispose()\n      mesh.material.dispose()\n\n      const variables = this.variables\n\n      for (let i = 0; i < variables.length; i++) {\n        const variable = variables[i]\n\n        if (variable.initialValueTexture) variable.initialValueTexture.dispose()\n\n        const renderTargets = variable.renderTargets\n\n        for (let j = 0; j < renderTargets.length; j++) {\n          const renderTarget = renderTargets[j]\n          renderTarget.dispose()\n        }\n      }\n    }\n\n    function addResolutionDefine(materialShader) {\n      materialShader.defines.resolution = 'vec2( ' + sizeX.toFixed(1) + ', ' + sizeY.toFixed(1) + ' )'\n    }\n\n    this.addResolutionDefine = addResolutionDefine\n\n    // The following functions can be used to compute things manually\n\n    function createShaderMaterial(computeFragmentShader, uniforms) {\n      uniforms = uniforms || {}\n\n      const material = new ShaderMaterial({\n        uniforms: uniforms,\n        vertexShader: getPassThroughVertexShader(),\n        fragmentShader: computeFragmentShader,\n      })\n\n      addResolutionDefine(material)\n\n      return material\n    }\n\n    this.createShaderMaterial = createShaderMaterial\n\n    this.createRenderTarget = function (sizeXTexture, sizeYTexture, wrapS, wrapT, minFilter, magFilter) {\n      sizeXTexture = sizeXTexture || sizeX\n      sizeYTexture = sizeYTexture || sizeY\n\n      wrapS = wrapS || ClampToEdgeWrapping\n      wrapT = wrapT || ClampToEdgeWrapping\n\n      minFilter = minFilter || NearestFilter\n      magFilter = magFilter || NearestFilter\n\n      const renderTarget = new WebGLRenderTarget(sizeXTexture, sizeYTexture, {\n        wrapS: wrapS,\n        wrapT: wrapT,\n        minFilter: minFilter,\n        magFilter: magFilter,\n        format: RGBAFormat,\n        type: dataType,\n        depthBuffer: false,\n      })\n\n      return renderTarget\n    }\n\n    this.createTexture = function () {\n      const data = new Float32Array(sizeX * sizeY * 4)\n      const texture = new DataTexture(data, sizeX, sizeY, RGBAFormat, FloatType)\n      texture.needsUpdate = true\n      return texture\n    }\n\n    this.renderTexture = function (input, output) {\n      // Takes a texture, and render out in rendertarget\n      // input = Texture\n      // output = RenderTarget\n\n      passThruUniforms.passThruTexture.value = input\n\n      this.doRenderTarget(passThruShader, output)\n\n      passThruUniforms.passThruTexture.value = null\n    }\n\n    this.doRenderTarget = function (material, output) {\n      const currentRenderTarget = renderer.getRenderTarget()\n\n      const currentXrEnabled = renderer.xr.enabled\n      const currentShadowAutoUpdate = renderer.shadowMap.autoUpdate\n      const currentOutputColorSpace = renderer.outputColorSpace\n      const currentToneMapping = renderer.toneMapping\n\n      renderer.xr.enabled = false // Avoid camera modification\n      renderer.shadowMap.autoUpdate = false // Avoid re-computing shadows\n      if ('outputColorSpace' in renderer) renderer.outputColorSpace = 'srgb-linear'\n      else renderer.encoding = 3000 // LinearEncoding\n      renderer.toneMapping = NoToneMapping\n\n      mesh.material = material\n      renderer.setRenderTarget(output)\n      renderer.render(scene, camera)\n      mesh.material = passThruShader\n\n      renderer.xr.enabled = currentXrEnabled\n      renderer.shadowMap.autoUpdate = currentShadowAutoUpdate\n      renderer.outputColorSpace = currentOutputColorSpace\n      renderer.toneMapping = currentToneMapping\n\n      renderer.setRenderTarget(currentRenderTarget)\n    }\n\n    // Shaders\n\n    function getPassThroughVertexShader() {\n      return 'void main()\t{\\n' + '\\n' + '\tgl_Position = vec4( position, 1.0 );\\n' + '\\n' + '}\\n'\n    }\n\n    function getPassThroughFragmentShader() {\n      return (\n        'uniform sampler2D passThruTexture;\\n' +\n        '\\n' +\n        'void main() {\\n' +\n        '\\n' +\n        '\tvec2 uv = gl_FragCoord.xy / resolution.xy;\\n' +\n        '\\n' +\n        '\tgl_FragColor = texture2D( passThruTexture, uv );\\n' +\n        '\\n' +\n        '}\\n'\n      )\n    }\n  }\n}\n\nexport { GPUComputationRenderer }\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}