{"ast":null,"code":"import _classCallCheck from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _inherits from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport { Loader, FileLoader, Vector3, Matrix4 } from \"three\";\nimport { gunzipSync } from \"fflate\";\nimport { Volume } from \"../misc/Volume.js\";\nvar NRRDLoader = /*#__PURE__*/function (_Loader) {\n  _inherits(NRRDLoader, _Loader);\n  var _super = _createSuper(NRRDLoader);\n  function NRRDLoader(manager) {\n    _classCallCheck(this, NRRDLoader);\n    return _super.call(this, manager);\n  }\n  _createClass(NRRDLoader, [{\n    key: \"load\",\n    value: function load(url, onLoad, onProgress, onError) {\n      var scope = this;\n      var loader = new FileLoader(scope.manager);\n      loader.setPath(scope.path);\n      loader.setResponseType(\"arraybuffer\");\n      loader.setRequestHeader(scope.requestHeader);\n      loader.setWithCredentials(scope.withCredentials);\n      loader.load(url, function (data) {\n        try {\n          onLoad(scope.parse(data));\n        } catch (e) {\n          if (onError) {\n            onError(e);\n          } else {\n            console.error(e);\n          }\n          scope.manager.itemError(url);\n        }\n      }, onProgress, onError);\n    }\n  }, {\n    key: \"parse\",\n    value: function parse(data) {\n      var _data = data;\n      var _dataPointer = 0;\n      var _nativeLittleEndian = new Int8Array(new Int16Array([1]).buffer)[0] > 0;\n      var _littleEndian = true;\n      var headerObject = {};\n      function scan(type, chunks) {\n        if (chunks === void 0 || chunks === null) {\n          chunks = 1;\n        }\n        var _chunkSize = 1;\n        var _array_type = Uint8Array;\n        switch (type) {\n          case \"uchar\":\n            break;\n          case \"schar\":\n            _array_type = Int8Array;\n            break;\n          case \"ushort\":\n            _array_type = Uint16Array;\n            _chunkSize = 2;\n            break;\n          case \"sshort\":\n            _array_type = Int16Array;\n            _chunkSize = 2;\n            break;\n          case \"uint\":\n            _array_type = Uint32Array;\n            _chunkSize = 4;\n            break;\n          case \"sint\":\n            _array_type = Int32Array;\n            _chunkSize = 4;\n            break;\n          case \"float\":\n            _array_type = Float32Array;\n            _chunkSize = 4;\n            break;\n          case \"complex\":\n            _array_type = Float64Array;\n            _chunkSize = 8;\n            break;\n          case \"double\":\n            _array_type = Float64Array;\n            _chunkSize = 8;\n            break;\n        }\n        var _bytes2 = new _array_type(_data.slice(_dataPointer, _dataPointer += chunks * _chunkSize));\n        if (_nativeLittleEndian != _littleEndian) {\n          _bytes2 = flipEndianness(_bytes2, _chunkSize);\n        }\n        if (chunks == 1) {\n          return _bytes2[0];\n        }\n        return _bytes2;\n      }\n      function flipEndianness(array, chunkSize) {\n        var u8 = new Uint8Array(array.buffer, array.byteOffset, array.byteLength);\n        for (var i2 = 0; i2 < array.byteLength; i2 += chunkSize) {\n          for (var j = i2 + chunkSize - 1, k = i2; j > k; j--, k++) {\n            var tmp = u8[k];\n            u8[k] = u8[j];\n            u8[j] = tmp;\n          }\n        }\n        return array;\n      }\n      function parseHeader(header) {\n        var data2, field, fn, i2, l, m, _i, _len;\n        var lines = header.split(/\\r?\\n/);\n        for (_i = 0, _len = lines.length; _i < _len; _i++) {\n          l = lines[_i];\n          if (l.match(/NRRD\\d+/)) {\n            headerObject.isNrrd = true;\n          } else if (l.match(/^#/)) ;else if (m = l.match(/(.*):(.*)/)) {\n            field = m[1].trim();\n            data2 = m[2].trim();\n            fn = _fieldFunctions[field];\n            if (fn) {\n              fn.call(headerObject, data2);\n            } else {\n              headerObject[field] = data2;\n            }\n          }\n        }\n        if (!headerObject.isNrrd) {\n          throw new Error(\"Not an NRRD file\");\n        }\n        if (headerObject.encoding === \"bz2\" || headerObject.encoding === \"bzip2\") {\n          throw new Error(\"Bzip is not supported\");\n        }\n        if (!headerObject.vectors) {\n          headerObject.vectors = [new Vector3(1, 0, 0), new Vector3(0, 1, 0), new Vector3(0, 0, 1)];\n          if (headerObject.spacings) {\n            for (i2 = 0; i2 <= 2; i2++) {\n              if (!isNaN(headerObject.spacings[i2])) {\n                headerObject.vectors[i2].multiplyScalar(headerObject.spacings[i2]);\n              }\n            }\n          }\n        }\n      }\n      function parseDataAsText(data2, start, end) {\n        var number = \"\";\n        start = start || 0;\n        end = end || data2.length;\n        var value;\n        var lengthOfTheResult = headerObject.sizes.reduce(function (previous, current) {\n          return previous * current;\n        }, 1);\n        var base = 10;\n        if (headerObject.encoding === \"hex\") {\n          base = 16;\n        }\n        var result = new headerObject.__array(lengthOfTheResult);\n        var resultIndex = 0;\n        var parsingFunction = parseInt;\n        if (headerObject.__array === Float32Array || headerObject.__array === Float64Array) {\n          parsingFunction = parseFloat;\n        }\n        for (var i2 = start; i2 < end; i2++) {\n          value = data2[i2];\n          if ((value < 9 || value > 13) && value !== 32) {\n            number += String.fromCharCode(value);\n          } else {\n            if (number !== \"\") {\n              result[resultIndex] = parsingFunction(number, base);\n              resultIndex++;\n            }\n            number = \"\";\n          }\n        }\n        if (number !== \"\") {\n          result[resultIndex] = parsingFunction(number, base);\n          resultIndex++;\n        }\n        return result;\n      }\n      var _bytes = scan(\"uchar\", data.byteLength);\n      var _length = _bytes.length;\n      var _header = null;\n      var _data_start = 0;\n      var i;\n      for (i = 1; i < _length; i++) {\n        if (_bytes[i - 1] == 10 && _bytes[i] == 10) {\n          _header = this.parseChars(_bytes, 0, i - 2);\n          _data_start = i + 1;\n          break;\n        }\n      }\n      parseHeader(_header);\n      _data = _bytes.subarray(_data_start);\n      if (headerObject.encoding.substring(0, 2) === \"gz\") {\n        _data = gunzipSync(new Uint8Array(_data));\n      } else if (headerObject.encoding === \"ascii\" || headerObject.encoding === \"text\" || headerObject.encoding === \"txt\" || headerObject.encoding === \"hex\") {\n        _data = parseDataAsText(_data);\n      } else if (headerObject.encoding === \"raw\") {\n        var _copy = new Uint8Array(_data.length);\n        for (var i2 = 0; i2 < _data.length; i2++) {\n          _copy[i2] = _data[i2];\n        }\n        _data = _copy;\n      }\n      _data = _data.buffer;\n      var volume = new Volume();\n      volume.header = headerObject;\n      volume.data = new headerObject.__array(_data);\n      var min_max = volume.computeMinMax();\n      var min = min_max[0];\n      var max = min_max[1];\n      volume.windowLow = min;\n      volume.windowHigh = max;\n      volume.dimensions = [headerObject.sizes[0], headerObject.sizes[1], headerObject.sizes[2]];\n      volume.xLength = volume.dimensions[0];\n      volume.yLength = volume.dimensions[1];\n      volume.zLength = volume.dimensions[2];\n      var spacingX = new Vector3(headerObject.vectors[0][0], headerObject.vectors[0][1], headerObject.vectors[0][2]).length();\n      var spacingY = new Vector3(headerObject.vectors[1][0], headerObject.vectors[1][1], headerObject.vectors[1][2]).length();\n      var spacingZ = new Vector3(headerObject.vectors[2][0], headerObject.vectors[2][1], headerObject.vectors[2][2]).length();\n      volume.spacing = [spacingX, spacingY, spacingZ];\n      volume.matrix = new Matrix4();\n      var _spaceX = 1;\n      var _spaceY = 1;\n      var _spaceZ = 1;\n      if (headerObject.space == \"left-posterior-superior\") {\n        _spaceX = -1;\n        _spaceY = -1;\n      } else if (headerObject.space === \"left-anterior-superior\") {\n        _spaceX = -1;\n      }\n      if (!headerObject.vectors) {\n        volume.matrix.set(_spaceX, 0, 0, 0, 0, _spaceY, 0, 0, 0, 0, _spaceZ, 0, 0, 0, 0, 1);\n      } else {\n        var v = headerObject.vectors;\n        volume.matrix.set(_spaceX * v[0][0], _spaceX * v[1][0], _spaceX * v[2][0], 0, _spaceY * v[0][1], _spaceY * v[1][1], _spaceY * v[2][1], 0, _spaceZ * v[0][2], _spaceZ * v[1][2], _spaceZ * v[2][2], 0, 0, 0, 0, 1);\n      }\n      volume.inverseMatrix = new Matrix4();\n      volume.inverseMatrix.copy(volume.matrix).invert();\n      volume.RASDimensions = new Vector3(volume.xLength, volume.yLength, volume.zLength).applyMatrix4(volume.matrix).round().toArray().map(Math.abs);\n      if (volume.lowerThreshold === -Infinity) {\n        volume.lowerThreshold = min;\n      }\n      if (volume.upperThreshold === Infinity) {\n        volume.upperThreshold = max;\n      }\n      return volume;\n    }\n  }, {\n    key: \"parseChars\",\n    value: function parseChars(array, start, end) {\n      if (start === void 0) {\n        start = 0;\n      }\n      if (end === void 0) {\n        end = array.length;\n      }\n      var output = \"\";\n      var i = 0;\n      for (i = start; i < end; ++i) {\n        output += String.fromCharCode(array[i]);\n      }\n      return output;\n    }\n  }]);\n  return NRRDLoader;\n}(Loader);\nvar _fieldFunctions = {\n  type: function type(data) {\n    switch (data) {\n      case \"uchar\":\n      case \"unsigned char\":\n      case \"uint8\":\n      case \"uint8_t\":\n        this.__array = Uint8Array;\n        break;\n      case \"signed char\":\n      case \"int8\":\n      case \"int8_t\":\n        this.__array = Int8Array;\n        break;\n      case \"short\":\n      case \"short int\":\n      case \"signed short\":\n      case \"signed short int\":\n      case \"int16\":\n      case \"int16_t\":\n        this.__array = Int16Array;\n        break;\n      case \"ushort\":\n      case \"unsigned short\":\n      case \"unsigned short int\":\n      case \"uint16\":\n      case \"uint16_t\":\n        this.__array = Uint16Array;\n        break;\n      case \"int\":\n      case \"signed int\":\n      case \"int32\":\n      case \"int32_t\":\n        this.__array = Int32Array;\n        break;\n      case \"uint\":\n      case \"unsigned int\":\n      case \"uint32\":\n      case \"uint32_t\":\n        this.__array = Uint32Array;\n        break;\n      case \"float\":\n        this.__array = Float32Array;\n        break;\n      case \"double\":\n        this.__array = Float64Array;\n        break;\n      default:\n        throw new Error(\"Unsupported NRRD data type: \" + data);\n    }\n    return this.type = data;\n  },\n  endian: function endian(data) {\n    return this.endian = data;\n  },\n  encoding: function encoding(data) {\n    return this.encoding = data;\n  },\n  dimension: function dimension(data) {\n    return this.dim = parseInt(data, 10);\n  },\n  sizes: function sizes(data) {\n    var i;\n    return this.sizes = function () {\n      var _ref = data.split(/\\s+/);\n      var _results = [];\n      for (var _i = 0, _len = _ref.length; _i < _len; _i++) {\n        i = _ref[_i];\n        _results.push(parseInt(i, 10));\n      }\n      return _results;\n    }();\n  },\n  space: function space(data) {\n    return this.space = data;\n  },\n  \"space origin\": function spaceOrigin(data) {\n    return this.space_origin = data.split(\"(\")[1].split(\")\")[0].split(\",\");\n  },\n  \"space directions\": function spaceDirections(data) {\n    var f, v;\n    var parts = data.match(/\\(.*?\\)/g);\n    return this.vectors = function () {\n      var _results = [];\n      for (var _i = 0, _len = parts.length; _i < _len; _i++) {\n        v = parts[_i];\n        _results.push(function () {\n          var _ref = v.slice(1, -1).split(/,/);\n          var _results2 = [];\n          for (var _j = 0, _len2 = _ref.length; _j < _len2; _j++) {\n            f = _ref[_j];\n            _results2.push(parseFloat(f));\n          }\n          return _results2;\n        }());\n      }\n      return _results;\n    }();\n  },\n  spacings: function spacings(data) {\n    var f;\n    var parts = data.split(/\\s+/);\n    return this.spacings = function () {\n      var _results = [];\n      for (var _i = 0, _len = parts.length; _i < _len; _i++) {\n        f = parts[_i];\n        _results.push(parseFloat(f));\n      }\n      return _results;\n    }();\n  }\n};\nexport { NRRDLoader };","map":{"version":3,"names":["NRRDLoader","_Loader","_inherits","_super","_createSuper","manager","_classCallCheck","call","_createClass","key","value","load","url","onLoad","onProgress","onError","scope","loader","FileLoader","setPath","path","setResponseType","setRequestHeader","requestHeader","setWithCredentials","withCredentials","data","parse","e","console","error","itemError","_data","_dataPointer","_nativeLittleEndian","Int8Array","Int16Array","buffer","_littleEndian","headerObject","scan","type","chunks","_chunkSize","_array_type","Uint8Array","Uint16Array","Uint32Array","Int32Array","Float32Array","Float64Array","_bytes2","slice","flipEndianness","array","chunkSize","u8","byteOffset","byteLength","i2","j","k","tmp","parseHeader","header","data2","field","fn","l","m","_i","_len","lines","split","length","match","isNrrd","trim","_fieldFunctions","Error","encoding","vectors","Vector3","spacings","isNaN","multiplyScalar","parseDataAsText","start","end","number","lengthOfTheResult","sizes","reduce","previous","current","base","result","__array","resultIndex","parsingFunction","parseInt","parseFloat","String","fromCharCode","_bytes","_length","_header","_data_start","i","parseChars","subarray","substring","gunzipSync","_copy","volume","Volume","min_max","computeMinMax","min","max","windowLow","windowHigh","dimensions","xLength","yLength","zLength","spacingX","spacingY","spacingZ","spacing","matrix","Matrix4","_spaceX","_spaceY","_spaceZ","space","set","v","inverseMatrix","copy","invert","RASDimensions","applyMatrix4","round","toArray","map","Math","abs","lowerThreshold","Infinity","upperThreshold","output","Loader","endian","dimension","dim","_ref","_results","push","spaceOrigin","space_origin","spaceDirections","f","parts","_results2","_j","_len2"],"sources":["C:\\Users\\Nayyu\\Desktop\\skibidai-public-build\\node_modules\\src\\loaders\\NRRDLoader.js"],"sourcesContent":["import { FileLoader, Loader, Matrix4, Vector3 } from 'three'\nimport { gunzipSync } from 'fflate'\nimport { Volume } from '../misc/Volume'\n\nclass NRRDLoader extends Loader {\n  constructor(manager) {\n    super(manager)\n  }\n\n  load(url, onLoad, onProgress, onError) {\n    const scope = this\n\n    const loader = new FileLoader(scope.manager)\n    loader.setPath(scope.path)\n    loader.setResponseType('arraybuffer')\n    loader.setRequestHeader(scope.requestHeader)\n    loader.setWithCredentials(scope.withCredentials)\n    loader.load(\n      url,\n      function (data) {\n        try {\n          onLoad(scope.parse(data))\n        } catch (e) {\n          if (onError) {\n            onError(e)\n          } else {\n            console.error(e)\n          }\n\n          scope.manager.itemError(url)\n        }\n      },\n      onProgress,\n      onError,\n    )\n  }\n\n  parse(data) {\n    // this parser is largely inspired from the XTK NRRD parser : https://github.com/xtk/X\n\n    let _data = data\n\n    let _dataPointer = 0\n\n    const _nativeLittleEndian = new Int8Array(new Int16Array([1]).buffer)[0] > 0\n\n    const _littleEndian = true\n\n    const headerObject = {}\n\n    function scan(type, chunks) {\n      if (chunks === undefined || chunks === null) {\n        chunks = 1\n      }\n\n      let _chunkSize = 1\n      let _array_type = Uint8Array\n\n      switch (type) {\n        // 1 byte data types\n        case 'uchar':\n          break\n        case 'schar':\n          _array_type = Int8Array\n          break\n        // 2 byte data types\n        case 'ushort':\n          _array_type = Uint16Array\n          _chunkSize = 2\n          break\n        case 'sshort':\n          _array_type = Int16Array\n          _chunkSize = 2\n          break\n        // 4 byte data types\n        case 'uint':\n          _array_type = Uint32Array\n          _chunkSize = 4\n          break\n        case 'sint':\n          _array_type = Int32Array\n          _chunkSize = 4\n          break\n        case 'float':\n          _array_type = Float32Array\n          _chunkSize = 4\n          break\n        case 'complex':\n          _array_type = Float64Array\n          _chunkSize = 8\n          break\n        case 'double':\n          _array_type = Float64Array\n          _chunkSize = 8\n          break\n      }\n\n      // increase the data pointer in-place\n      let _bytes = new _array_type(_data.slice(_dataPointer, (_dataPointer += chunks * _chunkSize)))\n\n      // if required, flip the endianness of the bytes\n      if (_nativeLittleEndian != _littleEndian) {\n        // we need to flip here since the format doesn't match the native endianness\n        _bytes = flipEndianness(_bytes, _chunkSize)\n      }\n\n      if (chunks == 1) {\n        // if only one chunk was requested, just return one value\n        return _bytes[0]\n      }\n\n      // return the byte array\n      return _bytes\n    }\n\n    //Flips typed array endianness in-place. Based on https://github.com/kig/DataStream.js/blob/master/DataStream.js.\n\n    function flipEndianness(array, chunkSize) {\n      const u8 = new Uint8Array(array.buffer, array.byteOffset, array.byteLength)\n      for (let i = 0; i < array.byteLength; i += chunkSize) {\n        for (let j = i + chunkSize - 1, k = i; j > k; j--, k++) {\n          const tmp = u8[k]\n          u8[k] = u8[j]\n          u8[j] = tmp\n        }\n      }\n\n      return array\n    }\n\n    //parse the header\n    function parseHeader(header) {\n      let data, field, fn, i, l, m, _i, _len\n      const lines = header.split(/\\r?\\n/)\n      for (_i = 0, _len = lines.length; _i < _len; _i++) {\n        l = lines[_i]\n        if (l.match(/NRRD\\d+/)) {\n          headerObject.isNrrd = true\n        } else if (l.match(/^#/)) {\n        } else if ((m = l.match(/(.*):(.*)/))) {\n          field = m[1].trim()\n          data = m[2].trim()\n          fn = _fieldFunctions[field]\n          if (fn) {\n            fn.call(headerObject, data)\n          } else {\n            headerObject[field] = data\n          }\n        }\n      }\n\n      if (!headerObject.isNrrd) {\n        throw new Error('Not an NRRD file')\n      }\n\n      if (headerObject.encoding === 'bz2' || headerObject.encoding === 'bzip2') {\n        throw new Error('Bzip is not supported')\n      }\n\n      if (!headerObject.vectors) {\n        //if no space direction is set, let's use the identity\n        headerObject.vectors = [new Vector3(1, 0, 0), new Vector3(0, 1, 0), new Vector3(0, 0, 1)]\n        //apply spacing if defined\n        if (headerObject.spacings) {\n          for (i = 0; i <= 2; i++) {\n            if (!isNaN(headerObject.spacings[i])) {\n              headerObject.vectors[i].multiplyScalar(headerObject.spacings[i])\n            }\n          }\n        }\n      }\n    }\n\n    //parse the data when registred as one of this type : 'text', 'ascii', 'txt'\n    function parseDataAsText(data, start, end) {\n      let number = ''\n      start = start || 0\n      end = end || data.length\n      let value\n      //length of the result is the product of the sizes\n      const lengthOfTheResult = headerObject.sizes.reduce(function (previous, current) {\n        return previous * current\n      }, 1)\n\n      let base = 10\n      if (headerObject.encoding === 'hex') {\n        base = 16\n      }\n\n      const result = new headerObject.__array(lengthOfTheResult)\n      let resultIndex = 0\n      let parsingFunction = parseInt\n      if (headerObject.__array === Float32Array || headerObject.__array === Float64Array) {\n        parsingFunction = parseFloat\n      }\n\n      for (let i = start; i < end; i++) {\n        value = data[i]\n        //if value is not a space\n        if ((value < 9 || value > 13) && value !== 32) {\n          number += String.fromCharCode(value)\n        } else {\n          if (number !== '') {\n            result[resultIndex] = parsingFunction(number, base)\n            resultIndex++\n          }\n\n          number = ''\n        }\n      }\n\n      if (number !== '') {\n        result[resultIndex] = parsingFunction(number, base)\n        resultIndex++\n      }\n\n      return result\n    }\n\n    const _bytes = scan('uchar', data.byteLength)\n    const _length = _bytes.length\n    let _header = null\n    let _data_start = 0\n    let i\n    for (i = 1; i < _length; i++) {\n      if (_bytes[i - 1] == 10 && _bytes[i] == 10) {\n        // we found two line breaks in a row\n        // now we know what the header is\n        _header = this.parseChars(_bytes, 0, i - 2)\n        // this is were the data starts\n        _data_start = i + 1\n        break\n      }\n    }\n\n    // parse the header\n    parseHeader(_header)\n\n    _data = _bytes.subarray(_data_start) // the data without header\n    if (headerObject.encoding.substring(0, 2) === 'gz') {\n      // we need to decompress the datastream\n      // here we start the unzipping and get a typed Uint8Array back\n      _data = gunzipSync(new Uint8Array(_data))\n    } else if (\n      headerObject.encoding === 'ascii' ||\n      headerObject.encoding === 'text' ||\n      headerObject.encoding === 'txt' ||\n      headerObject.encoding === 'hex'\n    ) {\n      _data = parseDataAsText(_data)\n    } else if (headerObject.encoding === 'raw') {\n      //we need to copy the array to create a new array buffer, else we retrieve the original arraybuffer with the header\n      const _copy = new Uint8Array(_data.length)\n\n      for (let i = 0; i < _data.length; i++) {\n        _copy[i] = _data[i]\n      }\n\n      _data = _copy\n    }\n\n    // .. let's use the underlying array buffer\n    _data = _data.buffer\n\n    const volume = new Volume()\n    volume.header = headerObject\n    //\n    // parse the (unzipped) data to a datastream of the correct type\n    //\n    volume.data = new headerObject.__array(_data)\n    // get the min and max intensities\n    const min_max = volume.computeMinMax()\n    const min = min_max[0]\n    const max = min_max[1]\n    // attach the scalar range to the volume\n    volume.windowLow = min\n    volume.windowHigh = max\n\n    // get the image dimensions\n    volume.dimensions = [headerObject.sizes[0], headerObject.sizes[1], headerObject.sizes[2]]\n    volume.xLength = volume.dimensions[0]\n    volume.yLength = volume.dimensions[1]\n    volume.zLength = volume.dimensions[2]\n    // spacing\n    const spacingX = new Vector3(\n      headerObject.vectors[0][0],\n      headerObject.vectors[0][1],\n      headerObject.vectors[0][2],\n    ).length()\n    const spacingY = new Vector3(\n      headerObject.vectors[1][0],\n      headerObject.vectors[1][1],\n      headerObject.vectors[1][2],\n    ).length()\n    const spacingZ = new Vector3(\n      headerObject.vectors[2][0],\n      headerObject.vectors[2][1],\n      headerObject.vectors[2][2],\n    ).length()\n    volume.spacing = [spacingX, spacingY, spacingZ]\n\n    // Create IJKtoRAS matrix\n    volume.matrix = new Matrix4()\n\n    let _spaceX = 1\n    let _spaceY = 1\n    const _spaceZ = 1\n\n    if (headerObject.space == 'left-posterior-superior') {\n      _spaceX = -1\n      _spaceY = -1\n    } else if (headerObject.space === 'left-anterior-superior') {\n      _spaceX = -1\n    }\n\n    if (!headerObject.vectors) {\n      volume.matrix.set(_spaceX, 0, 0, 0, 0, _spaceY, 0, 0, 0, 0, _spaceZ, 0, 0, 0, 0, 1)\n    } else {\n      const v = headerObject.vectors\n\n      volume.matrix.set(\n        _spaceX * v[0][0],\n        _spaceX * v[1][0],\n        _spaceX * v[2][0],\n        0,\n        _spaceY * v[0][1],\n        _spaceY * v[1][1],\n        _spaceY * v[2][1],\n        0,\n        _spaceZ * v[0][2],\n        _spaceZ * v[1][2],\n        _spaceZ * v[2][2],\n        0,\n        0,\n        0,\n        0,\n        1,\n      )\n    }\n\n    volume.inverseMatrix = new Matrix4()\n    volume.inverseMatrix.copy(volume.matrix).invert()\n    volume.RASDimensions = new Vector3(volume.xLength, volume.yLength, volume.zLength)\n      .applyMatrix4(volume.matrix)\n      .round()\n      .toArray()\n      .map(Math.abs)\n\n    // .. and set the default threshold\n    // only if the threshold was not already set\n    if (volume.lowerThreshold === -Infinity) {\n      volume.lowerThreshold = min\n    }\n\n    if (volume.upperThreshold === Infinity) {\n      volume.upperThreshold = max\n    }\n\n    return volume\n  }\n\n  parseChars(array, start, end) {\n    // without borders, use the whole array\n    if (start === undefined) {\n      start = 0\n    }\n\n    if (end === undefined) {\n      end = array.length\n    }\n\n    let output = ''\n    // create and append the chars\n    let i = 0\n    for (i = start; i < end; ++i) {\n      output += String.fromCharCode(array[i])\n    }\n\n    return output\n  }\n}\n\nconst _fieldFunctions = {\n  type: function (data) {\n    switch (data) {\n      case 'uchar':\n      case 'unsigned char':\n      case 'uint8':\n      case 'uint8_t':\n        this.__array = Uint8Array\n        break\n      case 'signed char':\n      case 'int8':\n      case 'int8_t':\n        this.__array = Int8Array\n        break\n      case 'short':\n      case 'short int':\n      case 'signed short':\n      case 'signed short int':\n      case 'int16':\n      case 'int16_t':\n        this.__array = Int16Array\n        break\n      case 'ushort':\n      case 'unsigned short':\n      case 'unsigned short int':\n      case 'uint16':\n      case 'uint16_t':\n        this.__array = Uint16Array\n        break\n      case 'int':\n      case 'signed int':\n      case 'int32':\n      case 'int32_t':\n        this.__array = Int32Array\n        break\n      case 'uint':\n      case 'unsigned int':\n      case 'uint32':\n      case 'uint32_t':\n        this.__array = Uint32Array\n        break\n      case 'float':\n        this.__array = Float32Array\n        break\n      case 'double':\n        this.__array = Float64Array\n        break\n      default:\n        throw new Error('Unsupported NRRD data type: ' + data)\n    }\n\n    return (this.type = data)\n  },\n\n  endian: function (data) {\n    return (this.endian = data)\n  },\n\n  encoding: function (data) {\n    return (this.encoding = data)\n  },\n\n  dimension: function (data) {\n    return (this.dim = parseInt(data, 10))\n  },\n\n  sizes: function (data) {\n    let i\n    return (this.sizes = (function () {\n      const _ref = data.split(/\\s+/)\n      const _results = []\n\n      for (let _i = 0, _len = _ref.length; _i < _len; _i++) {\n        i = _ref[_i]\n        _results.push(parseInt(i, 10))\n      }\n\n      return _results\n    })())\n  },\n\n  space: function (data) {\n    return (this.space = data)\n  },\n\n  'space origin': function (data) {\n    return (this.space_origin = data.split('(')[1].split(')')[0].split(','))\n  },\n\n  'space directions': function (data) {\n    let f, v\n    const parts = data.match(/\\(.*?\\)/g)\n    return (this.vectors = (function () {\n      const _results = []\n\n      for (let _i = 0, _len = parts.length; _i < _len; _i++) {\n        v = parts[_i]\n        _results.push(\n          (function () {\n            const _ref = v.slice(1, -1).split(/,/)\n            const _results2 = []\n\n            for (let _j = 0, _len2 = _ref.length; _j < _len2; _j++) {\n              f = _ref[_j]\n              _results2.push(parseFloat(f))\n            }\n\n            return _results2\n          })(),\n        )\n      }\n\n      return _results\n    })())\n  },\n\n  spacings: function (data) {\n    let f\n    const parts = data.split(/\\s+/)\n    return (this.spacings = (function () {\n      const _results = []\n\n      for (let _i = 0, _len = parts.length; _i < _len; _i++) {\n        f = parts[_i]\n        _results.push(parseFloat(f))\n      }\n\n      return _results\n    })())\n  },\n}\n\nexport { NRRDLoader }\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}