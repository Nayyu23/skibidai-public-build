{"ast":null,"code":"import _classCallCheck from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport { Vector3, Line3, Plane, Triangle } from \"three\";\nvar Visible = 0;\nvar Deleted = 1;\nvar _v1 = new Vector3();\nvar _line3 = new Line3();\nvar _plane = new Plane();\nvar _closestPoint = new Vector3();\nvar _triangle = new Triangle();\nvar ConvexHull = /*#__PURE__*/function () {\n  function ConvexHull() {\n    _classCallCheck(this, ConvexHull);\n    this.tolerance = -1;\n    this.faces = [];\n    this.newFaces = [];\n    this.assigned = new VertexList();\n    this.unassigned = new VertexList();\n    this.vertices = [];\n  }\n  _createClass(ConvexHull, [{\n    key: \"setFromPoints\",\n    value: function setFromPoints(points) {\n      if (points.length >= 4) {\n        this.makeEmpty();\n        for (var i = 0, l = points.length; i < l; i++) {\n          this.vertices.push(new VertexNode(points[i]));\n        }\n        this.compute();\n      }\n      return this;\n    }\n  }, {\n    key: \"setFromObject\",\n    value: function setFromObject(object) {\n      var points = [];\n      object.updateMatrixWorld(true);\n      object.traverse(function (node) {\n        var geometry = node.geometry;\n        if (geometry !== void 0) {\n          var attribute = geometry.attributes.position;\n          if (attribute !== void 0) {\n            for (var i = 0, l = attribute.count; i < l; i++) {\n              var point = new Vector3();\n              point.fromBufferAttribute(attribute, i).applyMatrix4(node.matrixWorld);\n              points.push(point);\n            }\n          }\n        }\n      });\n      return this.setFromPoints(points);\n    }\n  }, {\n    key: \"containsPoint\",\n    value: function containsPoint(point) {\n      var faces = this.faces;\n      for (var i = 0, l = faces.length; i < l; i++) {\n        var face = faces[i];\n        if (face.distanceToPoint(point) > this.tolerance) return false;\n      }\n      return true;\n    }\n  }, {\n    key: \"intersectRay\",\n    value: function intersectRay(ray, target) {\n      var faces = this.faces;\n      var tNear = -Infinity;\n      var tFar = Infinity;\n      for (var i = 0, l = faces.length; i < l; i++) {\n        var face = faces[i];\n        var vN = face.distanceToPoint(ray.origin);\n        var vD = face.normal.dot(ray.direction);\n        if (vN > 0 && vD >= 0) return null;\n        var t = vD !== 0 ? -vN / vD : 0;\n        if (t <= 0) continue;\n        if (vD > 0) {\n          tFar = Math.min(t, tFar);\n        } else {\n          tNear = Math.max(t, tNear);\n        }\n        if (tNear > tFar) {\n          return null;\n        }\n      }\n      if (tNear !== -Infinity) {\n        ray.at(tNear, target);\n      } else {\n        ray.at(tFar, target);\n      }\n      return target;\n    }\n  }, {\n    key: \"intersectsRay\",\n    value: function intersectsRay(ray) {\n      return this.intersectRay(ray, _v1) !== null;\n    }\n  }, {\n    key: \"makeEmpty\",\n    value: function makeEmpty() {\n      this.faces = [];\n      this.vertices = [];\n      return this;\n    }\n    // Adds a vertex to the 'assigned' list of vertices and assigns it to the given face\n  }, {\n    key: \"addVertexToFace\",\n    value: function addVertexToFace(vertex, face) {\n      vertex.face = face;\n      if (face.outside === null) {\n        this.assigned.append(vertex);\n      } else {\n        this.assigned.insertBefore(face.outside, vertex);\n      }\n      face.outside = vertex;\n      return this;\n    }\n    // Removes a vertex from the 'assigned' list of vertices and from the given face\n  }, {\n    key: \"removeVertexFromFace\",\n    value: function removeVertexFromFace(vertex, face) {\n      if (vertex === face.outside) {\n        if (vertex.next !== null && vertex.next.face === face) {\n          face.outside = vertex.next;\n        } else {\n          face.outside = null;\n        }\n      }\n      this.assigned.remove(vertex);\n      return this;\n    }\n    // Removes all the visible vertices that a given face is able to see which are stored in the 'assigned' vertex list\n  }, {\n    key: \"removeAllVerticesFromFace\",\n    value: function removeAllVerticesFromFace(face) {\n      if (face.outside !== null) {\n        var start = face.outside;\n        var end = face.outside;\n        while (end.next !== null && end.next.face === face) {\n          end = end.next;\n        }\n        this.assigned.removeSubList(start, end);\n        start.prev = end.next = null;\n        face.outside = null;\n        return start;\n      }\n    }\n    // Removes all the visible vertices that 'face' is able to see\n  }, {\n    key: \"deleteFaceVertices\",\n    value: function deleteFaceVertices(face, absorbingFace) {\n      var faceVertices = this.removeAllVerticesFromFace(face);\n      if (faceVertices !== void 0) {\n        if (absorbingFace === void 0) {\n          this.unassigned.appendChain(faceVertices);\n        } else {\n          var vertex = faceVertices;\n          do {\n            var nextVertex = vertex.next;\n            var distance = absorbingFace.distanceToPoint(vertex.point);\n            if (distance > this.tolerance) {\n              this.addVertexToFace(vertex, absorbingFace);\n            } else {\n              this.unassigned.append(vertex);\n            }\n            vertex = nextVertex;\n          } while (vertex !== null);\n        }\n      }\n      return this;\n    }\n    // Reassigns as many vertices as possible from the unassigned list to the new faces\n  }, {\n    key: \"resolveUnassignedPoints\",\n    value: function resolveUnassignedPoints(newFaces) {\n      if (this.unassigned.isEmpty() === false) {\n        var vertex = this.unassigned.first();\n        do {\n          var nextVertex = vertex.next;\n          var maxDistance = this.tolerance;\n          var maxFace = null;\n          for (var i = 0; i < newFaces.length; i++) {\n            var face = newFaces[i];\n            if (face.mark === Visible) {\n              var distance = face.distanceToPoint(vertex.point);\n              if (distance > maxDistance) {\n                maxDistance = distance;\n                maxFace = face;\n              }\n              if (maxDistance > 1e3 * this.tolerance) break;\n            }\n          }\n          if (maxFace !== null) {\n            this.addVertexToFace(vertex, maxFace);\n          }\n          vertex = nextVertex;\n        } while (vertex !== null);\n      }\n      return this;\n    }\n    // Computes the extremes of a simplex which will be the initial hull\n  }, {\n    key: \"computeExtremes\",\n    value: function computeExtremes() {\n      var min = new Vector3();\n      var max = new Vector3();\n      var minVertices = [];\n      var maxVertices = [];\n      for (var i = 0; i < 3; i++) {\n        minVertices[i] = maxVertices[i] = this.vertices[0];\n      }\n      min.copy(this.vertices[0].point);\n      max.copy(this.vertices[0].point);\n      for (var _i = 0, l = this.vertices.length; _i < l; _i++) {\n        var vertex = this.vertices[_i];\n        var point = vertex.point;\n        for (var j = 0; j < 3; j++) {\n          if (point.getComponent(j) < min.getComponent(j)) {\n            min.setComponent(j, point.getComponent(j));\n            minVertices[j] = vertex;\n          }\n        }\n        for (var _j = 0; _j < 3; _j++) {\n          if (point.getComponent(_j) > max.getComponent(_j)) {\n            max.setComponent(_j, point.getComponent(_j));\n            maxVertices[_j] = vertex;\n          }\n        }\n      }\n      this.tolerance = 3 * Number.EPSILON * (Math.max(Math.abs(min.x), Math.abs(max.x)) + Math.max(Math.abs(min.y), Math.abs(max.y)) + Math.max(Math.abs(min.z), Math.abs(max.z)));\n      return {\n        min: minVertices,\n        max: maxVertices\n      };\n    }\n    // Computes the initial simplex assigning to its faces all the points\n    // that are candidates to form part of the hull\n  }, {\n    key: \"computeInitialHull\",\n    value: function computeInitialHull() {\n      var vertices = this.vertices;\n      var extremes = this.computeExtremes();\n      var min = extremes.min;\n      var max = extremes.max;\n      var maxDistance = 0;\n      var index = 0;\n      for (var i = 0; i < 3; i++) {\n        var distance = max[i].point.getComponent(i) - min[i].point.getComponent(i);\n        if (distance > maxDistance) {\n          maxDistance = distance;\n          index = i;\n        }\n      }\n      var v0 = min[index];\n      var v1 = max[index];\n      var v2;\n      var v3;\n      maxDistance = 0;\n      _line3.set(v0.point, v1.point);\n      for (var _i2 = 0, l = this.vertices.length; _i2 < l; _i2++) {\n        var vertex = vertices[_i2];\n        if (vertex !== v0 && vertex !== v1) {\n          _line3.closestPointToPoint(vertex.point, true, _closestPoint);\n          var _distance = _closestPoint.distanceToSquared(vertex.point);\n          if (_distance > maxDistance) {\n            maxDistance = _distance;\n            v2 = vertex;\n          }\n        }\n      }\n      maxDistance = -1;\n      _plane.setFromCoplanarPoints(v0.point, v1.point, v2.point);\n      for (var _i3 = 0, _l = this.vertices.length; _i3 < _l; _i3++) {\n        var _vertex = vertices[_i3];\n        if (_vertex !== v0 && _vertex !== v1 && _vertex !== v2) {\n          var _distance2 = Math.abs(_plane.distanceToPoint(_vertex.point));\n          if (_distance2 > maxDistance) {\n            maxDistance = _distance2;\n            v3 = _vertex;\n          }\n        }\n      }\n      var faces = [];\n      if (_plane.distanceToPoint(v3.point) < 0) {\n        faces.push(Face.create(v0, v1, v2), Face.create(v3, v1, v0), Face.create(v3, v2, v1), Face.create(v3, v0, v2));\n        for (var _i4 = 0; _i4 < 3; _i4++) {\n          var j = (_i4 + 1) % 3;\n          faces[_i4 + 1].getEdge(2).setTwin(faces[0].getEdge(j));\n          faces[_i4 + 1].getEdge(1).setTwin(faces[j + 1].getEdge(0));\n        }\n      } else {\n        faces.push(Face.create(v0, v2, v1), Face.create(v3, v0, v1), Face.create(v3, v1, v2), Face.create(v3, v2, v0));\n        for (var _i5 = 0; _i5 < 3; _i5++) {\n          var _j2 = (_i5 + 1) % 3;\n          faces[_i5 + 1].getEdge(2).setTwin(faces[0].getEdge((3 - _i5) % 3));\n          faces[_i5 + 1].getEdge(0).setTwin(faces[_j2 + 1].getEdge(1));\n        }\n      }\n      for (var _i6 = 0; _i6 < 4; _i6++) {\n        this.faces.push(faces[_i6]);\n      }\n      for (var _i7 = 0, _l2 = vertices.length; _i7 < _l2; _i7++) {\n        var _vertex2 = vertices[_i7];\n        if (_vertex2 !== v0 && _vertex2 !== v1 && _vertex2 !== v2 && _vertex2 !== v3) {\n          maxDistance = this.tolerance;\n          var maxFace = null;\n          for (var _j3 = 0; _j3 < 4; _j3++) {\n            var _distance3 = this.faces[_j3].distanceToPoint(_vertex2.point);\n            if (_distance3 > maxDistance) {\n              maxDistance = _distance3;\n              maxFace = this.faces[_j3];\n            }\n          }\n          if (maxFace !== null) {\n            this.addVertexToFace(_vertex2, maxFace);\n          }\n        }\n      }\n      return this;\n    }\n    // Removes inactive faces\n  }, {\n    key: \"reindexFaces\",\n    value: function reindexFaces() {\n      var activeFaces = [];\n      for (var i = 0; i < this.faces.length; i++) {\n        var face = this.faces[i];\n        if (face.mark === Visible) {\n          activeFaces.push(face);\n        }\n      }\n      this.faces = activeFaces;\n      return this;\n    }\n    // Finds the next vertex to create faces with the current hull\n  }, {\n    key: \"nextVertexToAdd\",\n    value: function nextVertexToAdd() {\n      if (this.assigned.isEmpty() === false) {\n        var eyeVertex,\n          maxDistance = 0;\n        var eyeFace = this.assigned.first().face;\n        var vertex = eyeFace.outside;\n        do {\n          var distance = eyeFace.distanceToPoint(vertex.point);\n          if (distance > maxDistance) {\n            maxDistance = distance;\n            eyeVertex = vertex;\n          }\n          vertex = vertex.next;\n        } while (vertex !== null && vertex.face === eyeFace);\n        return eyeVertex;\n      }\n    }\n    // Computes a chain of half edges in CCW order called the 'horizon'.\n    // For an edge to be part of the horizon it must join a face that can see\n    // 'eyePoint' and a face that cannot see 'eyePoint'.\n  }, {\n    key: \"computeHorizon\",\n    value: function computeHorizon(eyePoint, crossEdge, face, horizon) {\n      this.deleteFaceVertices(face);\n      face.mark = Deleted;\n      var edge;\n      if (crossEdge === null) {\n        edge = crossEdge = face.getEdge(0);\n      } else {\n        edge = crossEdge.next;\n      }\n      do {\n        var twinEdge = edge.twin;\n        var oppositeFace = twinEdge.face;\n        if (oppositeFace.mark === Visible) {\n          if (oppositeFace.distanceToPoint(eyePoint) > this.tolerance) {\n            this.computeHorizon(eyePoint, twinEdge, oppositeFace, horizon);\n          } else {\n            horizon.push(edge);\n          }\n        }\n        edge = edge.next;\n      } while (edge !== crossEdge);\n      return this;\n    }\n    // Creates a face with the vertices 'eyeVertex.point', 'horizonEdge.tail' and 'horizonEdge.head' in CCW order\n  }, {\n    key: \"addAdjoiningFace\",\n    value: function addAdjoiningFace(eyeVertex, horizonEdge) {\n      var face = Face.create(eyeVertex, horizonEdge.tail(), horizonEdge.head());\n      this.faces.push(face);\n      face.getEdge(-1).setTwin(horizonEdge.twin);\n      return face.getEdge(0);\n    }\n    //  Adds 'horizon.length' faces to the hull, each face will be linked with the\n    //  horizon opposite face and the face on the left/right\n  }, {\n    key: \"addNewFaces\",\n    value: function addNewFaces(eyeVertex, horizon) {\n      this.newFaces = [];\n      var firstSideEdge = null;\n      var previousSideEdge = null;\n      for (var i = 0; i < horizon.length; i++) {\n        var horizonEdge = horizon[i];\n        var sideEdge = this.addAdjoiningFace(eyeVertex, horizonEdge);\n        if (firstSideEdge === null) {\n          firstSideEdge = sideEdge;\n        } else {\n          sideEdge.next.setTwin(previousSideEdge);\n        }\n        this.newFaces.push(sideEdge.face);\n        previousSideEdge = sideEdge;\n      }\n      firstSideEdge.next.setTwin(previousSideEdge);\n      return this;\n    }\n    // Adds a vertex to the hull\n  }, {\n    key: \"addVertexToHull\",\n    value: function addVertexToHull(eyeVertex) {\n      var horizon = [];\n      this.unassigned.clear();\n      this.removeVertexFromFace(eyeVertex, eyeVertex.face);\n      this.computeHorizon(eyeVertex.point, null, eyeVertex.face, horizon);\n      this.addNewFaces(eyeVertex, horizon);\n      this.resolveUnassignedPoints(this.newFaces);\n      return this;\n    }\n  }, {\n    key: \"cleanup\",\n    value: function cleanup() {\n      this.assigned.clear();\n      this.unassigned.clear();\n      this.newFaces = [];\n      return this;\n    }\n  }, {\n    key: \"compute\",\n    value: function compute() {\n      var vertex;\n      this.computeInitialHull();\n      while ((vertex = this.nextVertexToAdd()) !== void 0) {\n        this.addVertexToHull(vertex);\n      }\n      this.reindexFaces();\n      this.cleanup();\n      return this;\n    }\n  }]);\n  return ConvexHull;\n}();\nvar Face = /*#__PURE__*/function () {\n  function Face() {\n    _classCallCheck(this, Face);\n    this.normal = new Vector3();\n    this.midpoint = new Vector3();\n    this.area = 0;\n    this.constant = 0;\n    this.outside = null;\n    this.mark = Visible;\n    this.edge = null;\n  }\n  _createClass(Face, [{\n    key: \"getEdge\",\n    value: function getEdge(i) {\n      var edge = this.edge;\n      while (i > 0) {\n        edge = edge.next;\n        i--;\n      }\n      while (i < 0) {\n        edge = edge.prev;\n        i++;\n      }\n      return edge;\n    }\n  }, {\n    key: \"compute\",\n    value: function compute() {\n      var a = this.edge.tail();\n      var b = this.edge.head();\n      var c = this.edge.next.head();\n      _triangle.set(a.point, b.point, c.point);\n      _triangle.getNormal(this.normal);\n      _triangle.getMidpoint(this.midpoint);\n      this.area = _triangle.getArea();\n      this.constant = this.normal.dot(this.midpoint);\n      return this;\n    }\n  }, {\n    key: \"distanceToPoint\",\n    value: function distanceToPoint(point) {\n      return this.normal.dot(point) - this.constant;\n    }\n  }], [{\n    key: \"create\",\n    value: function create(a, b, c) {\n      var face = new Face();\n      var e0 = new HalfEdge(a, face);\n      var e1 = new HalfEdge(b, face);\n      var e2 = new HalfEdge(c, face);\n      e0.next = e2.prev = e1;\n      e1.next = e0.prev = e2;\n      e2.next = e1.prev = e0;\n      face.edge = e0;\n      return face.compute();\n    }\n  }]);\n  return Face;\n}();\nvar HalfEdge = /*#__PURE__*/function () {\n  function HalfEdge(vertex, face) {\n    _classCallCheck(this, HalfEdge);\n    this.vertex = vertex;\n    this.prev = null;\n    this.next = null;\n    this.twin = null;\n    this.face = face;\n  }\n  _createClass(HalfEdge, [{\n    key: \"head\",\n    value: function head() {\n      return this.vertex;\n    }\n  }, {\n    key: \"tail\",\n    value: function tail() {\n      return this.prev ? this.prev.vertex : null;\n    }\n  }, {\n    key: \"length\",\n    value: function length() {\n      var head = this.head();\n      var tail = this.tail();\n      if (tail !== null) {\n        return tail.point.distanceTo(head.point);\n      }\n      return -1;\n    }\n  }, {\n    key: \"lengthSquared\",\n    value: function lengthSquared() {\n      var head = this.head();\n      var tail = this.tail();\n      if (tail !== null) {\n        return tail.point.distanceToSquared(head.point);\n      }\n      return -1;\n    }\n  }, {\n    key: \"setTwin\",\n    value: function setTwin(edge) {\n      this.twin = edge;\n      edge.twin = this;\n      return this;\n    }\n  }]);\n  return HalfEdge;\n}();\nvar VertexNode = /*#__PURE__*/_createClass(function VertexNode(point) {\n  _classCallCheck(this, VertexNode);\n  this.point = point;\n  this.prev = null;\n  this.next = null;\n  this.face = null;\n});\nvar VertexList = /*#__PURE__*/function () {\n  function VertexList() {\n    _classCallCheck(this, VertexList);\n    this.head = null;\n    this.tail = null;\n  }\n  _createClass(VertexList, [{\n    key: \"first\",\n    value: function first() {\n      return this.head;\n    }\n  }, {\n    key: \"last\",\n    value: function last() {\n      return this.tail;\n    }\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      this.head = this.tail = null;\n      return this;\n    }\n    // Inserts a vertex before the target vertex\n  }, {\n    key: \"insertBefore\",\n    value: function insertBefore(target, vertex) {\n      vertex.prev = target.prev;\n      vertex.next = target;\n      if (vertex.prev === null) {\n        this.head = vertex;\n      } else {\n        vertex.prev.next = vertex;\n      }\n      target.prev = vertex;\n      return this;\n    }\n    // Inserts a vertex after the target vertex\n  }, {\n    key: \"insertAfter\",\n    value: function insertAfter(target, vertex) {\n      vertex.prev = target;\n      vertex.next = target.next;\n      if (vertex.next === null) {\n        this.tail = vertex;\n      } else {\n        vertex.next.prev = vertex;\n      }\n      target.next = vertex;\n      return this;\n    }\n    // Appends a vertex to the end of the linked list\n  }, {\n    key: \"append\",\n    value: function append(vertex) {\n      if (this.head === null) {\n        this.head = vertex;\n      } else {\n        this.tail.next = vertex;\n      }\n      vertex.prev = this.tail;\n      vertex.next = null;\n      this.tail = vertex;\n      return this;\n    }\n    // Appends a chain of vertices where 'vertex' is the head.\n  }, {\n    key: \"appendChain\",\n    value: function appendChain(vertex) {\n      if (this.head === null) {\n        this.head = vertex;\n      } else {\n        this.tail.next = vertex;\n      }\n      vertex.prev = this.tail;\n      while (vertex.next !== null) {\n        vertex = vertex.next;\n      }\n      this.tail = vertex;\n      return this;\n    }\n    // Removes a vertex from the linked list\n  }, {\n    key: \"remove\",\n    value: function remove(vertex) {\n      if (vertex.prev === null) {\n        this.head = vertex.next;\n      } else {\n        vertex.prev.next = vertex.next;\n      }\n      if (vertex.next === null) {\n        this.tail = vertex.prev;\n      } else {\n        vertex.next.prev = vertex.prev;\n      }\n      return this;\n    }\n    // Removes a list of vertices whose 'head' is 'a' and whose 'tail' is b\n  }, {\n    key: \"removeSubList\",\n    value: function removeSubList(a, b) {\n      if (a.prev === null) {\n        this.head = b.next;\n      } else {\n        a.prev.next = b.next;\n      }\n      if (b.next === null) {\n        this.tail = a.prev;\n      } else {\n        b.next.prev = a.prev;\n      }\n      return this;\n    }\n  }, {\n    key: \"isEmpty\",\n    value: function isEmpty() {\n      return this.head === null;\n    }\n  }]);\n  return VertexList;\n}();\nexport { ConvexHull, Face, HalfEdge, VertexList, VertexNode };","map":{"version":3,"names":["Visible","Deleted","_v1","Vector3","_line3","Line3","_plane","Plane","_closestPoint","_triangle","Triangle","ConvexHull","_classCallCheck","tolerance","faces","newFaces","assigned","VertexList","unassigned","vertices","_createClass","key","value","setFromPoints","points","length","makeEmpty","i","l","push","VertexNode","compute","setFromObject","object","updateMatrixWorld","traverse","node","geometry","attribute","attributes","position","count","point","fromBufferAttribute","applyMatrix4","matrixWorld","containsPoint","face","distanceToPoint","intersectRay","ray","target","tNear","Infinity","tFar","vN","origin","vD","normal","dot","direction","t","Math","min","max","at","intersectsRay","addVertexToFace","vertex","outside","append","insertBefore","removeVertexFromFace","next","remove","removeAllVerticesFromFace","start","end","removeSubList","prev","deleteFaceVertices","absorbingFace","faceVertices","appendChain","nextVertex","distance","resolveUnassignedPoints","isEmpty","first","maxDistance","maxFace","mark","computeExtremes","minVertices","maxVertices","copy","j","getComponent","setComponent","Number","EPSILON","abs","x","y","z","computeInitialHull","extremes","index","v0","v1","v2","v3","set","closestPointToPoint","distanceToSquared","setFromCoplanarPoints","Face","create","getEdge","setTwin","reindexFaces","activeFaces","nextVertexToAdd","eyeVertex","eyeFace","computeHorizon","eyePoint","crossEdge","horizon","edge","twinEdge","twin","oppositeFace","addAdjoiningFace","horizonEdge","tail","head","addNewFaces","firstSideEdge","previousSideEdge","sideEdge","addVertexToHull","clear","cleanup","midpoint","area","constant","a","b","c","getNormal","getMidpoint","getArea","e0","HalfEdge","e1","e2","distanceTo","lengthSquared","last","insertAfter"],"sources":["C:\\Users\\Nayyu\\Desktop\\skibidai-public-build\\node_modules\\src\\math\\ConvexHull.js"],"sourcesContent":["import { Line3, Plane, Triangle, Vector3 } from 'three'\n\n/**\n * Ported from: https://github.com/maurizzzio/quickhull3d/ by Mauricio Poppe (https://github.com/maurizzzio)\n */\n\nconst Visible = 0\nconst Deleted = 1\n\nconst _v1 = new Vector3()\nconst _line3 = new Line3()\nconst _plane = new Plane()\nconst _closestPoint = new Vector3()\nconst _triangle = new Triangle()\n\nclass ConvexHull {\n  constructor() {\n    this.tolerance = -1\n\n    this.faces = [] // the generated faces of the convex hull\n    this.newFaces = [] // this array holds the faces that are generated within a single iteration\n\n    // the vertex lists work as follows:\n    //\n    // let 'a' and 'b' be 'Face' instances\n    // let 'v' be points wrapped as instance of 'Vertex'\n    //\n    //     [v, v, ..., v, v, v, ...]\n    //      ^             ^\n    //      |             |\n    //  a.outside     b.outside\n    //\n    this.assigned = new VertexList()\n    this.unassigned = new VertexList()\n\n    this.vertices = [] // vertices of the hull (internal representation of given geometry data)\n  }\n\n  setFromPoints(points) {\n    // The algorithm needs at least four points.\n\n    if (points.length >= 4) {\n      this.makeEmpty()\n\n      for (let i = 0, l = points.length; i < l; i++) {\n        this.vertices.push(new VertexNode(points[i]))\n      }\n\n      this.compute()\n    }\n\n    return this\n  }\n\n  setFromObject(object) {\n    const points = []\n\n    object.updateMatrixWorld(true)\n\n    object.traverse(function (node) {\n      const geometry = node.geometry\n\n      if (geometry !== undefined) {\n        const attribute = geometry.attributes.position\n\n        if (attribute !== undefined) {\n          for (let i = 0, l = attribute.count; i < l; i++) {\n            const point = new Vector3()\n\n            point.fromBufferAttribute(attribute, i).applyMatrix4(node.matrixWorld)\n\n            points.push(point)\n          }\n        }\n      }\n    })\n\n    return this.setFromPoints(points)\n  }\n\n  containsPoint(point) {\n    const faces = this.faces\n\n    for (let i = 0, l = faces.length; i < l; i++) {\n      const face = faces[i]\n\n      // compute signed distance and check on what half space the point lies\n\n      if (face.distanceToPoint(point) > this.tolerance) return false\n    }\n\n    return true\n  }\n\n  intersectRay(ray, target) {\n    // based on \"Fast Ray-Convex Polyhedron Intersection\" by Eric Haines, GRAPHICS GEMS II\n\n    const faces = this.faces\n\n    let tNear = -Infinity\n    let tFar = Infinity\n\n    for (let i = 0, l = faces.length; i < l; i++) {\n      const face = faces[i]\n\n      // interpret faces as planes for the further computation\n\n      const vN = face.distanceToPoint(ray.origin)\n      const vD = face.normal.dot(ray.direction)\n\n      // if the origin is on the positive side of a plane (so the plane can \"see\" the origin) and\n      // the ray is turned away or parallel to the plane, there is no intersection\n\n      if (vN > 0 && vD >= 0) return null\n\n      // compute the distance from the ray’s origin to the intersection with the plane\n\n      const t = vD !== 0 ? -vN / vD : 0\n\n      // only proceed if the distance is positive. a negative distance means the intersection point\n      // lies \"behind\" the origin\n\n      if (t <= 0) continue\n\n      // now categorized plane as front-facing or back-facing\n\n      if (vD > 0) {\n        // plane faces away from the ray, so this plane is a back-face\n\n        tFar = Math.min(t, tFar)\n      } else {\n        // front-face\n\n        tNear = Math.max(t, tNear)\n      }\n\n      if (tNear > tFar) {\n        // if tNear ever is greater than tFar, the ray must miss the convex hull\n\n        return null\n      }\n    }\n\n    // evaluate intersection point\n\n    // always try tNear first since its the closer intersection point\n\n    if (tNear !== -Infinity) {\n      ray.at(tNear, target)\n    } else {\n      ray.at(tFar, target)\n    }\n\n    return target\n  }\n\n  intersectsRay(ray) {\n    return this.intersectRay(ray, _v1) !== null\n  }\n\n  makeEmpty() {\n    this.faces = []\n    this.vertices = []\n\n    return this\n  }\n\n  // Adds a vertex to the 'assigned' list of vertices and assigns it to the given face\n\n  addVertexToFace(vertex, face) {\n    vertex.face = face\n\n    if (face.outside === null) {\n      this.assigned.append(vertex)\n    } else {\n      this.assigned.insertBefore(face.outside, vertex)\n    }\n\n    face.outside = vertex\n\n    return this\n  }\n\n  // Removes a vertex from the 'assigned' list of vertices and from the given face\n\n  removeVertexFromFace(vertex, face) {\n    if (vertex === face.outside) {\n      // fix face.outside link\n\n      if (vertex.next !== null && vertex.next.face === face) {\n        // face has at least 2 outside vertices, move the 'outside' reference\n\n        face.outside = vertex.next\n      } else {\n        // vertex was the only outside vertex that face had\n\n        face.outside = null\n      }\n    }\n\n    this.assigned.remove(vertex)\n\n    return this\n  }\n\n  // Removes all the visible vertices that a given face is able to see which are stored in the 'assigned' vertex list\n\n  removeAllVerticesFromFace(face) {\n    if (face.outside !== null) {\n      // reference to the first and last vertex of this face\n\n      const start = face.outside\n      let end = face.outside\n\n      while (end.next !== null && end.next.face === face) {\n        end = end.next\n      }\n\n      this.assigned.removeSubList(start, end)\n\n      // fix references\n\n      start.prev = end.next = null\n      face.outside = null\n\n      return start\n    }\n  }\n\n  // Removes all the visible vertices that 'face' is able to see\n\n  deleteFaceVertices(face, absorbingFace) {\n    const faceVertices = this.removeAllVerticesFromFace(face)\n\n    if (faceVertices !== undefined) {\n      if (absorbingFace === undefined) {\n        // mark the vertices to be reassigned to some other face\n\n        this.unassigned.appendChain(faceVertices)\n      } else {\n        // if there's an absorbing face try to assign as many vertices as possible to it\n\n        let vertex = faceVertices\n\n        do {\n          // we need to buffer the subsequent vertex at this point because the 'vertex.next' reference\n          // will be changed by upcoming method calls\n\n          const nextVertex = vertex.next\n\n          const distance = absorbingFace.distanceToPoint(vertex.point)\n\n          // check if 'vertex' is able to see 'absorbingFace'\n\n          if (distance > this.tolerance) {\n            this.addVertexToFace(vertex, absorbingFace)\n          } else {\n            this.unassigned.append(vertex)\n          }\n\n          // now assign next vertex\n\n          vertex = nextVertex\n        } while (vertex !== null)\n      }\n    }\n\n    return this\n  }\n\n  // Reassigns as many vertices as possible from the unassigned list to the new faces\n\n  resolveUnassignedPoints(newFaces) {\n    if (this.unassigned.isEmpty() === false) {\n      let vertex = this.unassigned.first()\n\n      do {\n        // buffer 'next' reference, see .deleteFaceVertices()\n\n        const nextVertex = vertex.next\n\n        let maxDistance = this.tolerance\n\n        let maxFace = null\n\n        for (let i = 0; i < newFaces.length; i++) {\n          const face = newFaces[i]\n\n          if (face.mark === Visible) {\n            const distance = face.distanceToPoint(vertex.point)\n\n            if (distance > maxDistance) {\n              maxDistance = distance\n              maxFace = face\n            }\n\n            if (maxDistance > 1000 * this.tolerance) break\n          }\n        }\n\n        // 'maxFace' can be null e.g. if there are identical vertices\n\n        if (maxFace !== null) {\n          this.addVertexToFace(vertex, maxFace)\n        }\n\n        vertex = nextVertex\n      } while (vertex !== null)\n    }\n\n    return this\n  }\n\n  // Computes the extremes of a simplex which will be the initial hull\n\n  computeExtremes() {\n    const min = new Vector3()\n    const max = new Vector3()\n\n    const minVertices = []\n    const maxVertices = []\n\n    // initially assume that the first vertex is the min/max\n\n    for (let i = 0; i < 3; i++) {\n      minVertices[i] = maxVertices[i] = this.vertices[0]\n    }\n\n    min.copy(this.vertices[0].point)\n    max.copy(this.vertices[0].point)\n\n    // compute the min/max vertex on all six directions\n\n    for (let i = 0, l = this.vertices.length; i < l; i++) {\n      const vertex = this.vertices[i]\n      const point = vertex.point\n\n      // update the min coordinates\n\n      for (let j = 0; j < 3; j++) {\n        if (point.getComponent(j) < min.getComponent(j)) {\n          min.setComponent(j, point.getComponent(j))\n          minVertices[j] = vertex\n        }\n      }\n\n      // update the max coordinates\n\n      for (let j = 0; j < 3; j++) {\n        if (point.getComponent(j) > max.getComponent(j)) {\n          max.setComponent(j, point.getComponent(j))\n          maxVertices[j] = vertex\n        }\n      }\n    }\n\n    // use min/max vectors to compute an optimal epsilon\n\n    this.tolerance =\n      3 *\n      Number.EPSILON *\n      (Math.max(Math.abs(min.x), Math.abs(max.x)) +\n        Math.max(Math.abs(min.y), Math.abs(max.y)) +\n        Math.max(Math.abs(min.z), Math.abs(max.z)))\n\n    return { min: minVertices, max: maxVertices }\n  }\n\n  // Computes the initial simplex assigning to its faces all the points\n  // that are candidates to form part of the hull\n\n  computeInitialHull() {\n    const vertices = this.vertices\n    const extremes = this.computeExtremes()\n    const min = extremes.min\n    const max = extremes.max\n\n    // 1. Find the two vertices 'v0' and 'v1' with the greatest 1d separation\n    // (max.x - min.x)\n    // (max.y - min.y)\n    // (max.z - min.z)\n\n    let maxDistance = 0\n    let index = 0\n\n    for (let i = 0; i < 3; i++) {\n      const distance = max[i].point.getComponent(i) - min[i].point.getComponent(i)\n\n      if (distance > maxDistance) {\n        maxDistance = distance\n        index = i\n      }\n    }\n\n    const v0 = min[index]\n    const v1 = max[index]\n    let v2\n    let v3\n\n    // 2. The next vertex 'v2' is the one farthest to the line formed by 'v0' and 'v1'\n\n    maxDistance = 0\n    _line3.set(v0.point, v1.point)\n\n    for (let i = 0, l = this.vertices.length; i < l; i++) {\n      const vertex = vertices[i]\n\n      if (vertex !== v0 && vertex !== v1) {\n        _line3.closestPointToPoint(vertex.point, true, _closestPoint)\n\n        const distance = _closestPoint.distanceToSquared(vertex.point)\n\n        if (distance > maxDistance) {\n          maxDistance = distance\n          v2 = vertex\n        }\n      }\n    }\n\n    // 3. The next vertex 'v3' is the one farthest to the plane 'v0', 'v1', 'v2'\n\n    maxDistance = -1\n    _plane.setFromCoplanarPoints(v0.point, v1.point, v2.point)\n\n    for (let i = 0, l = this.vertices.length; i < l; i++) {\n      const vertex = vertices[i]\n\n      if (vertex !== v0 && vertex !== v1 && vertex !== v2) {\n        const distance = Math.abs(_plane.distanceToPoint(vertex.point))\n\n        if (distance > maxDistance) {\n          maxDistance = distance\n          v3 = vertex\n        }\n      }\n    }\n\n    const faces = []\n\n    if (_plane.distanceToPoint(v3.point) < 0) {\n      // the face is not able to see the point so 'plane.normal' is pointing outside the tetrahedron\n\n      faces.push(Face.create(v0, v1, v2), Face.create(v3, v1, v0), Face.create(v3, v2, v1), Face.create(v3, v0, v2))\n\n      // set the twin edge\n\n      for (let i = 0; i < 3; i++) {\n        const j = (i + 1) % 3\n\n        // join face[ i ] i > 0, with the first face\n\n        faces[i + 1].getEdge(2).setTwin(faces[0].getEdge(j))\n\n        // join face[ i ] with face[ i + 1 ], 1 <= i <= 3\n\n        faces[i + 1].getEdge(1).setTwin(faces[j + 1].getEdge(0))\n      }\n    } else {\n      // the face is able to see the point so 'plane.normal' is pointing inside the tetrahedron\n\n      faces.push(Face.create(v0, v2, v1), Face.create(v3, v0, v1), Face.create(v3, v1, v2), Face.create(v3, v2, v0))\n\n      // set the twin edge\n\n      for (let i = 0; i < 3; i++) {\n        const j = (i + 1) % 3\n\n        // join face[ i ] i > 0, with the first face\n\n        faces[i + 1].getEdge(2).setTwin(faces[0].getEdge((3 - i) % 3))\n\n        // join face[ i ] with face[ i + 1 ]\n\n        faces[i + 1].getEdge(0).setTwin(faces[j + 1].getEdge(1))\n      }\n    }\n\n    // the initial hull is the tetrahedron\n\n    for (let i = 0; i < 4; i++) {\n      this.faces.push(faces[i])\n    }\n\n    // initial assignment of vertices to the faces of the tetrahedron\n\n    for (let i = 0, l = vertices.length; i < l; i++) {\n      const vertex = vertices[i]\n\n      if (vertex !== v0 && vertex !== v1 && vertex !== v2 && vertex !== v3) {\n        maxDistance = this.tolerance\n        let maxFace = null\n\n        for (let j = 0; j < 4; j++) {\n          const distance = this.faces[j].distanceToPoint(vertex.point)\n\n          if (distance > maxDistance) {\n            maxDistance = distance\n            maxFace = this.faces[j]\n          }\n        }\n\n        if (maxFace !== null) {\n          this.addVertexToFace(vertex, maxFace)\n        }\n      }\n    }\n\n    return this\n  }\n\n  // Removes inactive faces\n\n  reindexFaces() {\n    const activeFaces = []\n\n    for (let i = 0; i < this.faces.length; i++) {\n      const face = this.faces[i]\n\n      if (face.mark === Visible) {\n        activeFaces.push(face)\n      }\n    }\n\n    this.faces = activeFaces\n\n    return this\n  }\n\n  // Finds the next vertex to create faces with the current hull\n\n  nextVertexToAdd() {\n    // if the 'assigned' list of vertices is empty, no vertices are left. return with 'undefined'\n\n    if (this.assigned.isEmpty() === false) {\n      let eyeVertex,\n        maxDistance = 0\n\n      // grap the first available face and start with the first visible vertex of that face\n\n      const eyeFace = this.assigned.first().face\n      let vertex = eyeFace.outside\n\n      // now calculate the farthest vertex that face can see\n\n      do {\n        const distance = eyeFace.distanceToPoint(vertex.point)\n\n        if (distance > maxDistance) {\n          maxDistance = distance\n          eyeVertex = vertex\n        }\n\n        vertex = vertex.next\n      } while (vertex !== null && vertex.face === eyeFace)\n\n      return eyeVertex\n    }\n  }\n\n  // Computes a chain of half edges in CCW order called the 'horizon'.\n  // For an edge to be part of the horizon it must join a face that can see\n  // 'eyePoint' and a face that cannot see 'eyePoint'.\n\n  computeHorizon(eyePoint, crossEdge, face, horizon) {\n    // moves face's vertices to the 'unassigned' vertex list\n\n    this.deleteFaceVertices(face)\n\n    face.mark = Deleted\n\n    let edge\n\n    if (crossEdge === null) {\n      edge = crossEdge = face.getEdge(0)\n    } else {\n      // start from the next edge since 'crossEdge' was already analyzed\n      // (actually 'crossEdge.twin' was the edge who called this method recursively)\n\n      edge = crossEdge.next\n    }\n\n    do {\n      const twinEdge = edge.twin\n      const oppositeFace = twinEdge.face\n\n      if (oppositeFace.mark === Visible) {\n        if (oppositeFace.distanceToPoint(eyePoint) > this.tolerance) {\n          // the opposite face can see the vertex, so proceed with next edge\n\n          this.computeHorizon(eyePoint, twinEdge, oppositeFace, horizon)\n        } else {\n          // the opposite face can't see the vertex, so this edge is part of the horizon\n\n          horizon.push(edge)\n        }\n      }\n\n      edge = edge.next\n    } while (edge !== crossEdge)\n\n    return this\n  }\n\n  // Creates a face with the vertices 'eyeVertex.point', 'horizonEdge.tail' and 'horizonEdge.head' in CCW order\n\n  addAdjoiningFace(eyeVertex, horizonEdge) {\n    // all the half edges are created in ccw order thus the face is always pointing outside the hull\n\n    const face = Face.create(eyeVertex, horizonEdge.tail(), horizonEdge.head())\n\n    this.faces.push(face)\n\n    // join face.getEdge( - 1 ) with the horizon's opposite edge face.getEdge( - 1 ) = face.getEdge( 2 )\n\n    face.getEdge(-1).setTwin(horizonEdge.twin)\n\n    return face.getEdge(0) // the half edge whose vertex is the eyeVertex\n  }\n\n  //  Adds 'horizon.length' faces to the hull, each face will be linked with the\n  //  horizon opposite face and the face on the left/right\n\n  addNewFaces(eyeVertex, horizon) {\n    this.newFaces = []\n\n    let firstSideEdge = null\n    let previousSideEdge = null\n\n    for (let i = 0; i < horizon.length; i++) {\n      const horizonEdge = horizon[i]\n\n      // returns the right side edge\n\n      const sideEdge = this.addAdjoiningFace(eyeVertex, horizonEdge)\n\n      if (firstSideEdge === null) {\n        firstSideEdge = sideEdge\n      } else {\n        // joins face.getEdge( 1 ) with previousFace.getEdge( 0 )\n\n        sideEdge.next.setTwin(previousSideEdge)\n      }\n\n      this.newFaces.push(sideEdge.face)\n      previousSideEdge = sideEdge\n    }\n\n    // perform final join of new faces\n\n    firstSideEdge.next.setTwin(previousSideEdge)\n\n    return this\n  }\n\n  // Adds a vertex to the hull\n\n  addVertexToHull(eyeVertex) {\n    const horizon = []\n\n    this.unassigned.clear()\n\n    // remove 'eyeVertex' from 'eyeVertex.face' so that it can't be added to the 'unassigned' vertex list\n\n    this.removeVertexFromFace(eyeVertex, eyeVertex.face)\n\n    this.computeHorizon(eyeVertex.point, null, eyeVertex.face, horizon)\n\n    this.addNewFaces(eyeVertex, horizon)\n\n    // reassign 'unassigned' vertices to the new faces\n\n    this.resolveUnassignedPoints(this.newFaces)\n\n    return this\n  }\n\n  cleanup() {\n    this.assigned.clear()\n    this.unassigned.clear()\n    this.newFaces = []\n\n    return this\n  }\n\n  compute() {\n    let vertex\n\n    this.computeInitialHull()\n\n    // add all available vertices gradually to the hull\n\n    while ((vertex = this.nextVertexToAdd()) !== undefined) {\n      this.addVertexToHull(vertex)\n    }\n\n    this.reindexFaces()\n\n    this.cleanup()\n\n    return this\n  }\n}\n\n//\n\nclass Face {\n  constructor() {\n    this.normal = new Vector3()\n    this.midpoint = new Vector3()\n    this.area = 0\n\n    this.constant = 0 // signed distance from face to the origin\n    this.outside = null // reference to a vertex in a vertex list this face can see\n    this.mark = Visible\n    this.edge = null\n  }\n\n  static create(a, b, c) {\n    const face = new Face()\n\n    const e0 = new HalfEdge(a, face)\n    const e1 = new HalfEdge(b, face)\n    const e2 = new HalfEdge(c, face)\n\n    // join edges\n\n    e0.next = e2.prev = e1\n    e1.next = e0.prev = e2\n    e2.next = e1.prev = e0\n\n    // main half edge reference\n\n    face.edge = e0\n\n    return face.compute()\n  }\n\n  getEdge(i) {\n    let edge = this.edge\n\n    while (i > 0) {\n      edge = edge.next\n      i--\n    }\n\n    while (i < 0) {\n      edge = edge.prev\n      i++\n    }\n\n    return edge\n  }\n\n  compute() {\n    const a = this.edge.tail()\n    const b = this.edge.head()\n    const c = this.edge.next.head()\n\n    _triangle.set(a.point, b.point, c.point)\n\n    _triangle.getNormal(this.normal)\n    _triangle.getMidpoint(this.midpoint)\n    this.area = _triangle.getArea()\n\n    this.constant = this.normal.dot(this.midpoint)\n\n    return this\n  }\n\n  distanceToPoint(point) {\n    return this.normal.dot(point) - this.constant\n  }\n}\n\n// Entity for a Doubly-Connected Edge List (DCEL).\n\nclass HalfEdge {\n  constructor(vertex, face) {\n    this.vertex = vertex\n    this.prev = null\n    this.next = null\n    this.twin = null\n    this.face = face\n  }\n\n  head() {\n    return this.vertex\n  }\n\n  tail() {\n    return this.prev ? this.prev.vertex : null\n  }\n\n  length() {\n    const head = this.head()\n    const tail = this.tail()\n\n    if (tail !== null) {\n      return tail.point.distanceTo(head.point)\n    }\n\n    return -1\n  }\n\n  lengthSquared() {\n    const head = this.head()\n    const tail = this.tail()\n\n    if (tail !== null) {\n      return tail.point.distanceToSquared(head.point)\n    }\n\n    return -1\n  }\n\n  setTwin(edge) {\n    this.twin = edge\n    edge.twin = this\n\n    return this\n  }\n}\n\n// A vertex as a double linked list node.\n\nclass VertexNode {\n  constructor(point) {\n    this.point = point\n    this.prev = null\n    this.next = null\n    this.face = null // the face that is able to see this vertex\n  }\n}\n\n// A double linked list that contains vertex nodes.\n\nclass VertexList {\n  constructor() {\n    this.head = null\n    this.tail = null\n  }\n\n  first() {\n    return this.head\n  }\n\n  last() {\n    return this.tail\n  }\n\n  clear() {\n    this.head = this.tail = null\n\n    return this\n  }\n\n  // Inserts a vertex before the target vertex\n\n  insertBefore(target, vertex) {\n    vertex.prev = target.prev\n    vertex.next = target\n\n    if (vertex.prev === null) {\n      this.head = vertex\n    } else {\n      vertex.prev.next = vertex\n    }\n\n    target.prev = vertex\n\n    return this\n  }\n\n  // Inserts a vertex after the target vertex\n\n  insertAfter(target, vertex) {\n    vertex.prev = target\n    vertex.next = target.next\n\n    if (vertex.next === null) {\n      this.tail = vertex\n    } else {\n      vertex.next.prev = vertex\n    }\n\n    target.next = vertex\n\n    return this\n  }\n\n  // Appends a vertex to the end of the linked list\n\n  append(vertex) {\n    if (this.head === null) {\n      this.head = vertex\n    } else {\n      this.tail.next = vertex\n    }\n\n    vertex.prev = this.tail\n    vertex.next = null // the tail has no subsequent vertex\n\n    this.tail = vertex\n\n    return this\n  }\n\n  // Appends a chain of vertices where 'vertex' is the head.\n\n  appendChain(vertex) {\n    if (this.head === null) {\n      this.head = vertex\n    } else {\n      this.tail.next = vertex\n    }\n\n    vertex.prev = this.tail\n\n    // ensure that the 'tail' reference points to the last vertex of the chain\n\n    while (vertex.next !== null) {\n      vertex = vertex.next\n    }\n\n    this.tail = vertex\n\n    return this\n  }\n\n  // Removes a vertex from the linked list\n\n  remove(vertex) {\n    if (vertex.prev === null) {\n      this.head = vertex.next\n    } else {\n      vertex.prev.next = vertex.next\n    }\n\n    if (vertex.next === null) {\n      this.tail = vertex.prev\n    } else {\n      vertex.next.prev = vertex.prev\n    }\n\n    return this\n  }\n\n  // Removes a list of vertices whose 'head' is 'a' and whose 'tail' is b\n\n  removeSubList(a, b) {\n    if (a.prev === null) {\n      this.head = b.next\n    } else {\n      a.prev.next = b.next\n    }\n\n    if (b.next === null) {\n      this.tail = a.prev\n    } else {\n      b.next.prev = a.prev\n    }\n\n    return this\n  }\n\n  isEmpty() {\n    return this.head === null\n  }\n}\n\nexport { ConvexHull, Face, HalfEdge, VertexNode, VertexList }\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}