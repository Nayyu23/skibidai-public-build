{"ast":null,"code":"import _slicedToArray from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _objectWithoutProperties from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js\";\nvar _excluded = [\"startFrame\", \"endFrame\", \"fps\", \"frameName\", \"textureDataURL\", \"textureImageURL\", \"loop\", \"numberOfFrames\", \"autoPlay\", \"animationNames\", \"onStart\", \"onEnd\", \"onLoopEnd\", \"onFrame\", \"play\", \"pause\", \"flipX\", \"alphaTest\", \"children\", \"asSprite\", \"offset\", \"playBackwards\", \"resetOnEnd\", \"maxItems\", \"instanceItems\", \"spriteDataset\"];\nimport _extends from '@babel/runtime/helpers/esm/extends';\nimport * as React from 'react';\nimport { useFrame } from '@react-three/fiber';\nimport * as THREE from 'three';\nimport { Instances, Instance } from './Instances.js';\nimport { useSpriteLoader } from './useSpriteLoader.js';\nvar context = /*#__PURE__*/React.createContext(null);\nfunction useSpriteAnimator() {\n  return React.useContext(context);\n}\nvar SpriteAnimator = /* @__PURE__ */React.forwardRef(function (_ref, fref) {\n  var startFrame = _ref.startFrame,\n    endFrame = _ref.endFrame,\n    fps = _ref.fps,\n    frameName = _ref.frameName,\n    textureDataURL = _ref.textureDataURL,\n    textureImageURL = _ref.textureImageURL,\n    loop = _ref.loop,\n    numberOfFrames = _ref.numberOfFrames,\n    autoPlay = _ref.autoPlay,\n    animationNames = _ref.animationNames,\n    onStart = _ref.onStart,\n    onEnd = _ref.onEnd,\n    onLoopEnd = _ref.onLoopEnd,\n    onFrame = _ref.onFrame,\n    play = _ref.play,\n    pause = _ref.pause,\n    flipX = _ref.flipX,\n    alphaTest = _ref.alphaTest,\n    children = _ref.children,\n    asSprite = _ref.asSprite,\n    offset = _ref.offset,\n    playBackwards = _ref.playBackwards,\n    resetOnEnd = _ref.resetOnEnd,\n    maxItems = _ref.maxItems,\n    instanceItems = _ref.instanceItems,\n    spriteDataset = _ref.spriteDataset,\n    props = _objectWithoutProperties(_ref, _excluded);\n  var _props$scale;\n  var ref = React.useRef();\n  var spriteData = React.useRef(null);\n  var matRef = React.useRef();\n  var spriteRef = React.useRef();\n  var timerOffset = React.useRef(window.performance.now());\n  var currentFrame = React.useRef(startFrame || 0);\n  var currentFrameName = React.useRef(frameName || '');\n  var fpsInterval = 1000 / (fps || 30);\n  var _React$useState = React.useState(new THREE.Texture()),\n    _React$useState2 = _slicedToArray(_React$useState, 2),\n    spriteTexture = _React$useState2[0],\n    setSpriteTexture = _React$useState2[1];\n  var totalFrames = React.useRef(0);\n  var _React$useState3 = React.useState([1, 1, 1]),\n    _React$useState4 = _slicedToArray(_React$useState3, 2),\n    aspect = _React$useState4[0],\n    setAspect = _React$useState4[1];\n  var flipOffset = flipX ? -1 : 1;\n  var _React$useState5 = React.useState(asSprite !== null && asSprite !== void 0 ? asSprite : true),\n    _React$useState6 = _slicedToArray(_React$useState5, 2),\n    displayAsSprite = _React$useState6[0],\n    setDisplayAsSprite = _React$useState6[1];\n  var pauseRef = React.useRef(pause);\n  var pos = React.useRef(offset);\n  var softEnd = React.useRef(false);\n  var frameBuffer = React.useRef([]);\n  var _useSpriteLoader = useSpriteLoader(null, null, animationNames, numberOfFrames),\n    spriteObj = _useSpriteLoader.spriteObj,\n    loadJsonAndTexture = _useSpriteLoader.loadJsonAndTexture;\n  //\n\n  function reset() {}\n  var state = React.useMemo(function () {\n    return {\n      current: pos.current,\n      offset: pos.current,\n      imageUrl: textureImageURL,\n      reset: reset,\n      hasEnded: false,\n      ref: fref\n    };\n  }, [textureImageURL, spriteDataset]);\n  React.useImperativeHandle(fref, function () {\n    return ref.current;\n  }, []);\n  React.useLayoutEffect(function () {\n    pos.current = offset;\n  }, [offset]);\n  var calculateAspectRatio = function calculateAspectRatio(width, height) {\n    var aspectRatio = height / width;\n    if (spriteRef.current) {\n      spriteRef.current.scale.set(1, aspectRatio, 1);\n    }\n    return [1, aspectRatio, 1];\n  };\n\n  // initial loads\n  React.useEffect(function () {\n    if (spriteDataset) {\n      var _spriteDataset$sprite;\n      parseSpriteDataLite(spriteDataset == null || (_spriteDataset$sprite = spriteDataset.spriteTexture) == null ? void 0 : _spriteDataset$sprite.clone(), spriteDataset.spriteData);\n    } else {\n      loadJsonAndTexture(textureImageURL, textureDataURL);\n    }\n  }, [spriteDataset]);\n  React.useEffect(function () {\n    if (spriteObj) {\n      var _spriteObj$spriteText;\n      parseSpriteDataLite(spriteObj == null || (_spriteObj$spriteText = spriteObj.spriteTexture) == null ? void 0 : _spriteObj$spriteText.clone(), spriteObj == null ? void 0 : spriteObj.spriteData);\n    }\n  }, [spriteObj]);\n  React.useEffect(function () {\n    setDisplayAsSprite(asSprite !== null && asSprite !== void 0 ? asSprite : true);\n  }, [asSprite]);\n\n  // support backwards play\n  React.useEffect(function () {\n    state.hasEnded = false;\n    if (spriteData.current && playBackwards === true) {\n      currentFrame.current = spriteData.current.frames.length - 1;\n    } else {\n      currentFrame.current = 0;\n    }\n  }, [playBackwards]);\n  React.useLayoutEffect(function () {\n    modifySpritePosition();\n  }, [spriteTexture, flipX]);\n  React.useEffect(function () {\n    if (autoPlay) {\n      pauseRef.current = false;\n    }\n  }, [autoPlay]);\n  React.useLayoutEffect(function () {\n    if (currentFrameName.current !== frameName && frameName) {\n      currentFrame.current = 0;\n      currentFrameName.current = frameName;\n      state.hasEnded = false;\n      // modifySpritePosition()\n      if (spriteData.current) {\n        var _getFirstItem$sourceS = getFirstItem(spriteData.current.frames).sourceSize,\n          w = _getFirstItem$sourceS.w,\n          h = _getFirstItem$sourceS.h;\n        var _aspect = calculateAspectRatio(w, h);\n        setAspect(_aspect);\n      }\n    }\n  }, [frameName]);\n\n  // lite version for pre-loaded assets\n  var parseSpriteDataLite = function parseSpriteDataLite(textureData) {\n    var frameData = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    if (frameData === null) {\n      if (numberOfFrames) {\n        //get size from texture\n        var width = textureData.image.width;\n        var height = textureData.image.height;\n        totalFrames.current = numberOfFrames;\n        if (playBackwards) {\n          currentFrame.current = numberOfFrames - 1;\n        }\n        spriteData.current = {\n          frames: [],\n          meta: {\n            version: '1.0',\n            size: {\n              w: width,\n              h: height\n            },\n            scale: '1'\n          }\n        };\n        spriteData.current.frames = frameData;\n      }\n    } else {\n      spriteData.current = frameData;\n      totalFrames.current = spriteData.current.frames.length;\n      if (playBackwards) {\n        currentFrame.current = totalFrames.current - 1;\n      }\n      var _getFirstItem$sourceS2 = getFirstItem(spriteData.current.frames).sourceSize,\n        w = _getFirstItem$sourceS2.w,\n        h = _getFirstItem$sourceS2.h;\n      var _aspect2 = calculateAspectRatio(w, h);\n      setAspect(_aspect2);\n      if (matRef.current) {\n        matRef.current.map = textureData;\n      }\n    }\n\n    // buffer for instanced\n    if (instanceItems) {\n      for (var i = 0; i < instanceItems.length; i++) {\n        var keys = Object.keys(spriteData.current.frames);\n        var randomKey = keys[Math.floor(Math.random() * keys.length)];\n        frameBuffer.current.push({\n          key: i,\n          frames: spriteData.current.frames,\n          selectedFrame: randomKey,\n          offset: {\n            x: 0,\n            y: 0\n          }\n        });\n      }\n    }\n    setSpriteTexture(textureData);\n  };\n\n  // modify the sprite material after json is parsed and state updated\n  var modifySpritePosition = function modifySpritePosition() {\n    if (!spriteData.current) return;\n    var _spriteData$current2 = spriteData.current,\n      metaInfo = _spriteData$current2.meta.size,\n      frames = _spriteData$current2.frames;\n    var _ref2 = Array.isArray(frames) ? frames[0].sourceSize : frameName ? frames[frameName] ? frames[frameName][0].sourceSize : {\n        w: 0,\n        h: 0\n      } : {\n        w: 0,\n        h: 0\n      },\n      frameW = _ref2.w,\n      frameH = _ref2.h;\n    matRef.current.map.wrapS = matRef.current.map.wrapT = THREE.RepeatWrapping;\n    matRef.current.map.center.set(0, 0);\n    matRef.current.map.repeat.set(1 * flipOffset / (metaInfo.w / frameW), 1 / (metaInfo.h / frameH));\n\n    //const framesH = (metaInfo.w - 1) / frameW\n    var framesV = (metaInfo.h - 1) / frameH;\n    var frameOffsetY = 1 / framesV;\n    matRef.current.map.offset.x = 0.0; //-matRef.current.map.repeat.x\n    matRef.current.map.offset.y = 1 - frameOffsetY;\n    if (onStart) {\n      onStart({\n        currentFrameName: frameName,\n        currentFrame: currentFrame.current\n      });\n    }\n  };\n\n  // run the animation on each frame\n  var runAnimation = function runAnimation() {\n    //if (!frameName) return\n\n    var now = window.performance.now();\n    var diff = now - timerOffset.current;\n    var _spriteData$current3 = spriteData.current,\n      metaInfo = _spriteData$current3.meta.size,\n      frames = _spriteData$current3.frames;\n    var _getFirstItem$sourceS3 = getFirstItem(frames).sourceSize,\n      frameW = _getFirstItem$sourceS3.w,\n      frameH = _getFirstItem$sourceS3.h;\n    var spriteFrames = Array.isArray(frames) ? frames : frameName ? frames[frameName] : [];\n    var _endFrame = endFrame || spriteFrames.length - 1;\n    var _offset = offset === undefined ? state.current : offset;\n\n    // conditionals to support backwards play\n    var endCondition = playBackwards ? currentFrame.current < 0 : currentFrame.current > _endFrame;\n    var onStartCondition = playBackwards ? currentFrame.current === _endFrame : currentFrame.current === 0;\n    var manualProgressEndCondition = playBackwards ? currentFrame.current < 0 : currentFrame.current >= _endFrame;\n    if (endCondition) {\n      currentFrame.current = loop ? startFrame !== null && startFrame !== void 0 ? startFrame : 0 : 0;\n      if (playBackwards) {\n        currentFrame.current = _endFrame;\n      }\n      if (loop) {\n        onLoopEnd == null || onLoopEnd({\n          currentFrameName: frameName,\n          currentFrame: currentFrame.current\n        });\n      } else {\n        onEnd == null || onEnd({\n          currentFrameName: frameName,\n          currentFrame: currentFrame.current\n        });\n        state.hasEnded = resetOnEnd ? false : true;\n        if (resetOnEnd) {\n          pauseRef.current = true;\n          //calculateFinalPosition(frameW, frameH, metaInfo, spriteFrames)\n        }\n      }\n\n      if (!loop) return;\n    } else if (onStartCondition) {\n      onStart == null || onStart({\n        currentFrameName: frameName,\n        currentFrame: currentFrame.current\n      });\n    }\n\n    // for manual update\n    if (_offset !== undefined && manualProgressEndCondition) {\n      if (softEnd.current === false) {\n        onEnd == null || onEnd({\n          currentFrameName: frameName,\n          currentFrame: currentFrame.current\n        });\n        softEnd.current = true;\n      }\n    } else {\n      // same for start?\n      softEnd.current = false;\n    }\n\n    // clock to limit fps\n    if (diff <= fpsInterval) return;\n    timerOffset.current = now - diff % fpsInterval;\n    calculateFinalPosition(frameW, frameH, metaInfo, spriteFrames);\n  };\n  var calculateFinalPosition = function calculateFinalPosition(frameW, frameH, metaInfo, spriteFrames) {\n    // get the manual update offset to find the next frame\n    var _offset = offset === undefined ? state.current : offset;\n    var targetFrame = currentFrame.current;\n    var finalValX = 0;\n    var finalValY = 0;\n    calculateAspectRatio(frameW, frameH);\n    var framesH = Math.round((metaInfo.w - 1) / frameW);\n    var framesV = Math.round((metaInfo.h - 1) / frameH);\n    if (!spriteFrames[targetFrame]) {\n      return;\n    }\n    var _spriteFrames$targetF = spriteFrames[targetFrame],\n      _spriteFrames$targetF2 = _spriteFrames$targetF.frame,\n      frameX = _spriteFrames$targetF2.x,\n      frameY = _spriteFrames$targetF2.y,\n      _spriteFrames$targetF3 = _spriteFrames$targetF.sourceSize,\n      originalSizeX = _spriteFrames$targetF3.w,\n      originalSizeY = _spriteFrames$targetF3.h;\n    var frameOffsetX = 1 / framesH;\n    var frameOffsetY = 1 / framesV;\n    finalValX = flipOffset > 0 ? frameOffsetX * (frameX / originalSizeX) : frameOffsetX * (frameX / originalSizeX) - matRef.current.map.repeat.x;\n    finalValY = Math.abs(1 - frameOffsetY) - frameOffsetY * (frameY / originalSizeY);\n    matRef.current.map.offset.x = finalValX;\n    matRef.current.map.offset.y = finalValY;\n\n    // if manual update is active\n    if (_offset !== undefined && _offset !== null) {\n      // Calculate the frame index, based on offset given from the provider\n      var frameIndex = Math.floor(_offset * spriteFrames.length);\n\n      // Ensure the frame index is within the valid range\n      frameIndex = Math.max(0, Math.min(frameIndex, spriteFrames.length - 1));\n      if (isNaN(frameIndex)) {\n        frameIndex = 0; //fallback\n      }\n\n      currentFrame.current = frameIndex;\n    } else {\n      // auto update\n      if (playBackwards) {\n        currentFrame.current -= 1;\n      } else {\n        currentFrame.current += 1;\n      }\n    }\n  };\n\n  // *** Warning! It runs on every frame! ***\n  useFrame(function (_state, _delta) {\n    var _spriteData$current, _matRef$current;\n    if (!((_spriteData$current = spriteData.current) != null && _spriteData$current.frames) || !((_matRef$current = matRef.current) != null && _matRef$current.map)) {\n      return;\n    }\n    if (pauseRef.current) {\n      return;\n    }\n    if (!state.hasEnded && (autoPlay || play)) {\n      runAnimation();\n      onFrame && onFrame({\n        currentFrameName: currentFrameName.current,\n        currentFrame: currentFrame.current\n      });\n    }\n  });\n\n  // utils\n  var getFirstItem = function getFirstItem(param) {\n    if (Array.isArray(param)) {\n      return param[0];\n    } else if (typeof param === 'object' && param !== null) {\n      var keys = Object.keys(param);\n      return frameName ? param[frameName][0] : param[keys[0]][0];\n    } else {\n      return {\n        w: 0,\n        h: 0\n      };\n    }\n  };\n  function multiplyScale(initialScale, newScale) {\n    var _newScale = [];\n\n    // If newScale is a single number, convert it to a Vector3\n    if (typeof newScale === 'number') {\n      _newScale = [newScale, newScale, newScale];\n    } else if (Array.isArray(newScale)) {\n      // If newScale is an array, convert it to a Vector3\n      _newScale = newScale;\n    } else if (newScale instanceof THREE.Vector3) {\n      _newScale = [newScale.x, newScale.y, newScale.z];\n    }\n\n    // Multiply the scale values element-wise\n    var result = initialScale.map(function (value, index) {\n      return value * _newScale[index];\n    });\n    // Convert the result to an array of numbers\n    return result;\n  }\n  return /*#__PURE__*/React.createElement(\"group\", _extends({}, props, {\n    ref: ref,\n    scale: multiplyScale(aspect !== null && aspect !== void 0 ? aspect : [1, 1, 1], (_props$scale = props.scale) !== null && _props$scale !== void 0 ? _props$scale : 1.0)\n  }), /*#__PURE__*/React.createElement(context.Provider, {\n    value: state\n  }, /*#__PURE__*/React.createElement(React.Suspense, {\n    fallback: null\n  }, displayAsSprite && /*#__PURE__*/React.createElement(\"sprite\", {\n    ref: spriteRef,\n    scale: 1.0\n  }, /*#__PURE__*/React.createElement(\"spriteMaterial\", {\n    premultipliedAlpha: false,\n    toneMapped: false,\n    ref: matRef,\n    map: spriteTexture,\n    transparent: true,\n    alphaTest: alphaTest !== null && alphaTest !== void 0 ? alphaTest : 0.0\n  })), !displayAsSprite && /*#__PURE__*/React.createElement(Instances, {\n    limit: maxItems !== null && maxItems !== void 0 ? maxItems : 1 // Optional: max amount of items (for calculating buffer size)\n  }, /*#__PURE__*/React.createElement(\"planeGeometry\", {\n    args: [1, 1]\n  }), /*#__PURE__*/React.createElement(\"meshBasicMaterial\", {\n    premultipliedAlpha: false,\n    toneMapped: false,\n    side: THREE.DoubleSide,\n    ref: matRef,\n    map: spriteTexture,\n    transparent: true,\n    alphaTest: alphaTest !== null && alphaTest !== void 0 ? alphaTest : 0.0\n  }), (instanceItems !== null && instanceItems !== void 0 ? instanceItems : [0]).map(function (item, index) {\n    return /*#__PURE__*/React.createElement(Instance, {\n      key: index,\n      ref: (instanceItems == null ? void 0 : instanceItems.length) === 1 ? spriteRef : null,\n      position: item,\n      scale: 1.0\n    });\n  }))), children));\n});\nexport { SpriteAnimator, useSpriteAnimator };","map":{"version":3,"names":["_extends","React","useFrame","THREE","Instances","Instance","useSpriteLoader","context","createContext","useSpriteAnimator","useContext","SpriteAnimator","forwardRef","_ref","fref","startFrame","endFrame","fps","frameName","textureDataURL","textureImageURL","loop","numberOfFrames","autoPlay","animationNames","onStart","onEnd","onLoopEnd","onFrame","play","pause","flipX","alphaTest","children","asSprite","offset","playBackwards","resetOnEnd","maxItems","instanceItems","spriteDataset","props","_objectWithoutProperties","_excluded","_props$scale","ref","useRef","spriteData","matRef","spriteRef","timerOffset","window","performance","now","currentFrame","currentFrameName","fpsInterval","_React$useState","useState","Texture","_React$useState2","_slicedToArray","spriteTexture","setSpriteTexture","totalFrames","_React$useState3","_React$useState4","aspect","setAspect","flipOffset","_React$useState5","_React$useState6","displayAsSprite","setDisplayAsSprite","pauseRef","pos","softEnd","frameBuffer","_useSpriteLoader","spriteObj","loadJsonAndTexture","reset","state","useMemo","current","imageUrl","hasEnded","useImperativeHandle","useLayoutEffect","calculateAspectRatio","width","height","aspectRatio","scale","set","useEffect","_spriteDataset$sprite","parseSpriteDataLite","clone","_spriteObj$spriteText","frames","length","modifySpritePosition","_getFirstItem$sourceS","getFirstItem","sourceSize","w","h","_aspect","textureData","frameData","arguments","undefined","image","meta","version","size","_getFirstItem$sourceS2","map","i","keys","Object","randomKey","Math","floor","random","push","key","selectedFrame","x","y","_spriteData$current2","metaInfo","_ref2","Array","isArray","frameW","frameH","wrapS","wrapT","RepeatWrapping","center","repeat","framesV","frameOffsetY","runAnimation","diff","_spriteData$current3","_getFirstItem$sourceS3","spriteFrames","_endFrame","_offset","endCondition","onStartCondition","manualProgressEndCondition","calculateFinalPosition","targetFrame","finalValX","finalValY","framesH","round","_spriteFrames$targetF","_spriteFrames$targetF2","frame","frameX","frameY","_spriteFrames$targetF3","originalSizeX","originalSizeY","frameOffsetX","abs","frameIndex","max","min","isNaN","_state","_delta","_spriteData$current","_matRef$current","param","multiplyScale","initialScale","newScale","_newScale","Vector3","z","result","value","index","createElement","Provider","Suspense","fallback","premultipliedAlpha","toneMapped","transparent","limit","args","side","DoubleSide","item","position"],"sources":["C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@react-three/drei/core/SpriteAnimator.js"],"sourcesContent":["import _extends from '@babel/runtime/helpers/esm/extends';\nimport * as React from 'react';\nimport { useFrame } from '@react-three/fiber';\nimport * as THREE from 'three';\nimport { Instances, Instance } from './Instances.js';\nimport { useSpriteLoader } from './useSpriteLoader.js';\n\nconst context = /*#__PURE__*/React.createContext(null);\nfunction useSpriteAnimator() {\n  return React.useContext(context);\n}\nconst SpriteAnimator = /* @__PURE__ */React.forwardRef(({\n  startFrame,\n  endFrame,\n  fps,\n  frameName,\n  textureDataURL,\n  textureImageURL,\n  loop,\n  numberOfFrames,\n  autoPlay,\n  animationNames,\n  onStart,\n  onEnd,\n  onLoopEnd,\n  onFrame,\n  play,\n  pause,\n  flipX,\n  alphaTest,\n  children,\n  asSprite,\n  offset,\n  playBackwards,\n  resetOnEnd,\n  maxItems,\n  instanceItems,\n  spriteDataset,\n  ...props\n}, fref) => {\n  var _props$scale;\n  const ref = React.useRef();\n  const spriteData = React.useRef(null);\n  const matRef = React.useRef();\n  const spriteRef = React.useRef();\n  const timerOffset = React.useRef(window.performance.now());\n  const currentFrame = React.useRef(startFrame || 0);\n  const currentFrameName = React.useRef(frameName || '');\n  const fpsInterval = 1000 / (fps || 30);\n  const [spriteTexture, setSpriteTexture] = React.useState(new THREE.Texture());\n  const totalFrames = React.useRef(0);\n  const [aspect, setAspect] = React.useState([1, 1, 1]);\n  const flipOffset = flipX ? -1 : 1;\n  const [displayAsSprite, setDisplayAsSprite] = React.useState(asSprite !== null && asSprite !== void 0 ? asSprite : true);\n  const pauseRef = React.useRef(pause);\n  const pos = React.useRef(offset);\n  const softEnd = React.useRef(false);\n  const frameBuffer = React.useRef([]);\n  const {\n    spriteObj,\n    loadJsonAndTexture\n  } = useSpriteLoader(null, null, animationNames, numberOfFrames);\n  //\n\n  function reset() {}\n  const state = React.useMemo(() => ({\n    current: pos.current,\n    offset: pos.current,\n    imageUrl: textureImageURL,\n    reset: reset,\n    hasEnded: false,\n    ref: fref\n  }), [textureImageURL, spriteDataset]);\n  React.useImperativeHandle(fref, () => ref.current, []);\n  React.useLayoutEffect(() => {\n    pos.current = offset;\n  }, [offset]);\n  const calculateAspectRatio = (width, height) => {\n    const aspectRatio = height / width;\n    if (spriteRef.current) {\n      spriteRef.current.scale.set(1, aspectRatio, 1);\n    }\n    return [1, aspectRatio, 1];\n  };\n\n  // initial loads\n  React.useEffect(() => {\n    if (spriteDataset) {\n      var _spriteDataset$sprite;\n      parseSpriteDataLite(spriteDataset == null || (_spriteDataset$sprite = spriteDataset.spriteTexture) == null ? void 0 : _spriteDataset$sprite.clone(), spriteDataset.spriteData);\n    } else {\n      loadJsonAndTexture(textureImageURL, textureDataURL);\n    }\n  }, [spriteDataset]);\n  React.useEffect(() => {\n    if (spriteObj) {\n      var _spriteObj$spriteText;\n      parseSpriteDataLite(spriteObj == null || (_spriteObj$spriteText = spriteObj.spriteTexture) == null ? void 0 : _spriteObj$spriteText.clone(), spriteObj == null ? void 0 : spriteObj.spriteData);\n    }\n  }, [spriteObj]);\n  React.useEffect(() => {\n    setDisplayAsSprite(asSprite !== null && asSprite !== void 0 ? asSprite : true);\n  }, [asSprite]);\n\n  // support backwards play\n  React.useEffect(() => {\n    state.hasEnded = false;\n    if (spriteData.current && playBackwards === true) {\n      currentFrame.current = spriteData.current.frames.length - 1;\n    } else {\n      currentFrame.current = 0;\n    }\n  }, [playBackwards]);\n  React.useLayoutEffect(() => {\n    modifySpritePosition();\n  }, [spriteTexture, flipX]);\n  React.useEffect(() => {\n    if (autoPlay) {\n      pauseRef.current = false;\n    }\n  }, [autoPlay]);\n  React.useLayoutEffect(() => {\n    if (currentFrameName.current !== frameName && frameName) {\n      currentFrame.current = 0;\n      currentFrameName.current = frameName;\n      state.hasEnded = false;\n      // modifySpritePosition()\n      if (spriteData.current) {\n        const {\n          w,\n          h\n        } = getFirstItem(spriteData.current.frames).sourceSize;\n        const _aspect = calculateAspectRatio(w, h);\n        setAspect(_aspect);\n      }\n    }\n  }, [frameName]);\n\n  // lite version for pre-loaded assets\n  const parseSpriteDataLite = (textureData, frameData = null) => {\n    if (frameData === null) {\n      if (numberOfFrames) {\n        //get size from texture\n        const width = textureData.image.width;\n        const height = textureData.image.height;\n        totalFrames.current = numberOfFrames;\n        if (playBackwards) {\n          currentFrame.current = numberOfFrames - 1;\n        }\n        spriteData.current = {\n          frames: [],\n          meta: {\n            version: '1.0',\n            size: {\n              w: width,\n              h: height\n            },\n            scale: '1'\n          }\n        };\n        spriteData.current.frames = frameData;\n      }\n    } else {\n      spriteData.current = frameData;\n      totalFrames.current = spriteData.current.frames.length;\n      if (playBackwards) {\n        currentFrame.current = totalFrames.current - 1;\n      }\n      const {\n        w,\n        h\n      } = getFirstItem(spriteData.current.frames).sourceSize;\n      const aspect = calculateAspectRatio(w, h);\n      setAspect(aspect);\n      if (matRef.current) {\n        matRef.current.map = textureData;\n      }\n    }\n\n    // buffer for instanced\n    if (instanceItems) {\n      for (var i = 0; i < instanceItems.length; i++) {\n        const keys = Object.keys(spriteData.current.frames);\n        const randomKey = keys[Math.floor(Math.random() * keys.length)];\n        frameBuffer.current.push({\n          key: i,\n          frames: spriteData.current.frames,\n          selectedFrame: randomKey,\n          offset: {\n            x: 0,\n            y: 0\n          }\n        });\n      }\n    }\n    setSpriteTexture(textureData);\n  };\n\n  // modify the sprite material after json is parsed and state updated\n  const modifySpritePosition = () => {\n    if (!spriteData.current) return;\n    const {\n      meta: {\n        size: metaInfo\n      },\n      frames\n    } = spriteData.current;\n    const {\n      w: frameW,\n      h: frameH\n    } = Array.isArray(frames) ? frames[0].sourceSize : frameName ? frames[frameName] ? frames[frameName][0].sourceSize : {\n      w: 0,\n      h: 0\n    } : {\n      w: 0,\n      h: 0\n    };\n    matRef.current.map.wrapS = matRef.current.map.wrapT = THREE.RepeatWrapping;\n    matRef.current.map.center.set(0, 0);\n    matRef.current.map.repeat.set(1 * flipOffset / (metaInfo.w / frameW), 1 / (metaInfo.h / frameH));\n\n    //const framesH = (metaInfo.w - 1) / frameW\n    const framesV = (metaInfo.h - 1) / frameH;\n    const frameOffsetY = 1 / framesV;\n    matRef.current.map.offset.x = 0.0; //-matRef.current.map.repeat.x\n    matRef.current.map.offset.y = 1 - frameOffsetY;\n    if (onStart) {\n      onStart({\n        currentFrameName: frameName,\n        currentFrame: currentFrame.current\n      });\n    }\n  };\n\n  // run the animation on each frame\n  const runAnimation = () => {\n    //if (!frameName) return\n\n    const now = window.performance.now();\n    const diff = now - timerOffset.current;\n    const {\n      meta: {\n        size: metaInfo\n      },\n      frames\n    } = spriteData.current;\n    const {\n      w: frameW,\n      h: frameH\n    } = getFirstItem(frames).sourceSize;\n    const spriteFrames = Array.isArray(frames) ? frames : frameName ? frames[frameName] : [];\n    const _endFrame = endFrame || spriteFrames.length - 1;\n    var _offset = offset === undefined ? state.current : offset;\n\n    // conditionals to support backwards play\n    var endCondition = playBackwards ? currentFrame.current < 0 : currentFrame.current > _endFrame;\n    var onStartCondition = playBackwards ? currentFrame.current === _endFrame : currentFrame.current === 0;\n    var manualProgressEndCondition = playBackwards ? currentFrame.current < 0 : currentFrame.current >= _endFrame;\n    if (endCondition) {\n      currentFrame.current = loop ? startFrame !== null && startFrame !== void 0 ? startFrame : 0 : 0;\n      if (playBackwards) {\n        currentFrame.current = _endFrame;\n      }\n      if (loop) {\n        onLoopEnd == null || onLoopEnd({\n          currentFrameName: frameName,\n          currentFrame: currentFrame.current\n        });\n      } else {\n        onEnd == null || onEnd({\n          currentFrameName: frameName,\n          currentFrame: currentFrame.current\n        });\n        state.hasEnded = resetOnEnd ? false : true;\n        if (resetOnEnd) {\n          pauseRef.current = true;\n          //calculateFinalPosition(frameW, frameH, metaInfo, spriteFrames)\n        }\n      }\n\n      if (!loop) return;\n    } else if (onStartCondition) {\n      onStart == null || onStart({\n        currentFrameName: frameName,\n        currentFrame: currentFrame.current\n      });\n    }\n\n    // for manual update\n    if (_offset !== undefined && manualProgressEndCondition) {\n      if (softEnd.current === false) {\n        onEnd == null || onEnd({\n          currentFrameName: frameName,\n          currentFrame: currentFrame.current\n        });\n        softEnd.current = true;\n      }\n    } else {\n      // same for start?\n      softEnd.current = false;\n    }\n\n    // clock to limit fps\n    if (diff <= fpsInterval) return;\n    timerOffset.current = now - diff % fpsInterval;\n    calculateFinalPosition(frameW, frameH, metaInfo, spriteFrames);\n  };\n  const calculateFinalPosition = (frameW, frameH, metaInfo, spriteFrames) => {\n    // get the manual update offset to find the next frame\n    var _offset = offset === undefined ? state.current : offset;\n    const targetFrame = currentFrame.current;\n    let finalValX = 0;\n    let finalValY = 0;\n    calculateAspectRatio(frameW, frameH);\n    const framesH = Math.round((metaInfo.w - 1) / frameW);\n    const framesV = Math.round((metaInfo.h - 1) / frameH);\n    if (!spriteFrames[targetFrame]) {\n      return;\n    }\n    const {\n      frame: {\n        x: frameX,\n        y: frameY\n      },\n      sourceSize: {\n        w: originalSizeX,\n        h: originalSizeY\n      }\n    } = spriteFrames[targetFrame];\n    const frameOffsetX = 1 / framesH;\n    const frameOffsetY = 1 / framesV;\n    finalValX = flipOffset > 0 ? frameOffsetX * (frameX / originalSizeX) : frameOffsetX * (frameX / originalSizeX) - matRef.current.map.repeat.x;\n    finalValY = Math.abs(1 - frameOffsetY) - frameOffsetY * (frameY / originalSizeY);\n    matRef.current.map.offset.x = finalValX;\n    matRef.current.map.offset.y = finalValY;\n\n    // if manual update is active\n    if (_offset !== undefined && _offset !== null) {\n      // Calculate the frame index, based on offset given from the provider\n      let frameIndex = Math.floor(_offset * spriteFrames.length);\n\n      // Ensure the frame index is within the valid range\n      frameIndex = Math.max(0, Math.min(frameIndex, spriteFrames.length - 1));\n      if (isNaN(frameIndex)) {\n        frameIndex = 0; //fallback\n      }\n\n      currentFrame.current = frameIndex;\n    } else {\n      // auto update\n      if (playBackwards) {\n        currentFrame.current -= 1;\n      } else {\n        currentFrame.current += 1;\n      }\n    }\n  };\n\n  // *** Warning! It runs on every frame! ***\n  useFrame((_state, _delta) => {\n    var _spriteData$current, _matRef$current;\n    if (!((_spriteData$current = spriteData.current) != null && _spriteData$current.frames) || !((_matRef$current = matRef.current) != null && _matRef$current.map)) {\n      return;\n    }\n    if (pauseRef.current) {\n      return;\n    }\n    if (!state.hasEnded && (autoPlay || play)) {\n      runAnimation();\n      onFrame && onFrame({\n        currentFrameName: currentFrameName.current,\n        currentFrame: currentFrame.current\n      });\n    }\n  });\n\n  // utils\n  const getFirstItem = param => {\n    if (Array.isArray(param)) {\n      return param[0];\n    } else if (typeof param === 'object' && param !== null) {\n      const keys = Object.keys(param);\n      return frameName ? param[frameName][0] : param[keys[0]][0];\n    } else {\n      return {\n        w: 0,\n        h: 0\n      };\n    }\n  };\n  function multiplyScale(initialScale, newScale) {\n    let _newScale = [];\n\n    // If newScale is a single number, convert it to a Vector3\n    if (typeof newScale === 'number') {\n      _newScale = [newScale, newScale, newScale];\n    } else if (Array.isArray(newScale)) {\n      // If newScale is an array, convert it to a Vector3\n      _newScale = newScale;\n    } else if (newScale instanceof THREE.Vector3) {\n      _newScale = [newScale.x, newScale.y, newScale.z];\n    }\n\n    // Multiply the scale values element-wise\n    const result = initialScale.map((value, index) => value * _newScale[index]);\n    // Convert the result to an array of numbers\n    return result;\n  }\n  return /*#__PURE__*/React.createElement(\"group\", _extends({}, props, {\n    ref: ref,\n    scale: multiplyScale(aspect !== null && aspect !== void 0 ? aspect : [1, 1, 1], (_props$scale = props.scale) !== null && _props$scale !== void 0 ? _props$scale : 1.0)\n  }), /*#__PURE__*/React.createElement(context.Provider, {\n    value: state\n  }, /*#__PURE__*/React.createElement(React.Suspense, {\n    fallback: null\n  }, displayAsSprite && /*#__PURE__*/React.createElement(\"sprite\", {\n    ref: spriteRef,\n    scale: 1.0\n  }, /*#__PURE__*/React.createElement(\"spriteMaterial\", {\n    premultipliedAlpha: false,\n    toneMapped: false,\n    ref: matRef,\n    map: spriteTexture,\n    transparent: true,\n    alphaTest: alphaTest !== null && alphaTest !== void 0 ? alphaTest : 0.0\n  })), !displayAsSprite && /*#__PURE__*/React.createElement(Instances, {\n    limit: maxItems !== null && maxItems !== void 0 ? maxItems : 1 // Optional: max amount of items (for calculating buffer size)\n  }, /*#__PURE__*/React.createElement(\"planeGeometry\", {\n    args: [1, 1]\n  }), /*#__PURE__*/React.createElement(\"meshBasicMaterial\", {\n    premultipliedAlpha: false,\n    toneMapped: false,\n    side: THREE.DoubleSide,\n    ref: matRef,\n    map: spriteTexture,\n    transparent: true,\n    alphaTest: alphaTest !== null && alphaTest !== void 0 ? alphaTest : 0.0\n  }), (instanceItems !== null && instanceItems !== void 0 ? instanceItems : [0]).map((item, index) => {\n    return /*#__PURE__*/React.createElement(Instance, {\n      key: index,\n      ref: (instanceItems == null ? void 0 : instanceItems.length) === 1 ? spriteRef : null,\n      position: item,\n      scale: 1.0\n    });\n  }))), children));\n});\n\nexport { SpriteAnimator, useSpriteAnimator };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}