{"ast":null,"code":"import _createClass from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _classCallCheck from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _possibleConstructorReturn from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js\";\nimport _assertThisInitialized from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js\";\nimport _inherits from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = function __defNormalProp(obj, key, value) {\n  return key in obj ? __defProp(obj, key, {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: value\n  }) : obj[key] = value;\n};\nvar __publicField = function __publicField(obj, key, value) {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nimport { Mesh, Vector4, Color, Vector2, Matrix4, Clock, ShaderMaterial, UniformsUtils, UniformsLib, RepeatWrapping } from \"three\";\nimport { Reflector } from \"./Reflector.js\";\nimport { Refractor } from \"./Refractor.js\";\nimport { version } from \"../_polyfill/constants.js\";\nvar _Water2 = /*#__PURE__*/function (_Mesh) {\n  _inherits(_Water2, _Mesh);\n  var _super = _createSuper(_Water2);\n  function _Water2(geometry) {\n    var _this;\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    _classCallCheck(this, _Water2);\n    _this = _super.call(this, geometry);\n    _this.isWater = true;\n    _this.type = \"Water\";\n    var scope = _assertThisInitialized(_this);\n    var color = options.color !== void 0 ? new Color(options.color) : new Color(16777215);\n    var textureWidth = options.textureWidth || 512;\n    var textureHeight = options.textureHeight || 512;\n    var clipBias = options.clipBias || 0;\n    var flowDirection = options.flowDirection || new Vector2(1, 0);\n    var flowSpeed = options.flowSpeed || 0.03;\n    var reflectivity = options.reflectivity || 0.02;\n    var scale = options.scale || 1;\n    var shader = options.shader || _Water2.WaterShader;\n    var encoding = options.encoding !== void 0 ? options.encoding : 3e3;\n    var flowMap = options.flowMap || void 0;\n    var normalMap0 = options.normalMap0;\n    var normalMap1 = options.normalMap1;\n    var cycle = 0.15;\n    var halfCycle = cycle * 0.5;\n    var textureMatrix = new Matrix4();\n    var clock = new Clock();\n    if (Reflector === void 0) {\n      console.error(\"THREE.Water: Required component Reflector not found.\");\n      return _possibleConstructorReturn(_this);\n    }\n    if (Refractor === void 0) {\n      console.error(\"THREE.Water: Required component Refractor not found.\");\n      return _possibleConstructorReturn(_this);\n    }\n    var reflector = new Reflector(geometry, {\n      textureWidth: textureWidth,\n      textureHeight: textureHeight,\n      clipBias: clipBias,\n      encoding: encoding\n    });\n    var refractor = new Refractor(geometry, {\n      textureWidth: textureWidth,\n      textureHeight: textureHeight,\n      clipBias: clipBias,\n      encoding: encoding\n    });\n    reflector.matrixAutoUpdate = false;\n    refractor.matrixAutoUpdate = false;\n    _this.material = new ShaderMaterial({\n      uniforms: UniformsUtils.merge([UniformsLib[\"fog\"], shader.uniforms]),\n      vertexShader: shader.vertexShader,\n      fragmentShader: shader.fragmentShader,\n      transparent: true,\n      fog: true\n    });\n    if (flowMap !== void 0) {\n      _this.material.defines.USE_FLOWMAP = \"\";\n      _this.material.uniforms[\"tFlowMap\"] = {\n        type: \"t\",\n        value: flowMap\n      };\n    } else {\n      _this.material.uniforms[\"flowDirection\"] = {\n        type: \"v2\",\n        value: flowDirection\n      };\n    }\n    normalMap0.wrapS = normalMap0.wrapT = RepeatWrapping;\n    normalMap1.wrapS = normalMap1.wrapT = RepeatWrapping;\n    _this.material.uniforms[\"tReflectionMap\"].value = reflector.getRenderTarget().texture;\n    _this.material.uniforms[\"tRefractionMap\"].value = refractor.getRenderTarget().texture;\n    _this.material.uniforms[\"tNormalMap0\"].value = normalMap0;\n    _this.material.uniforms[\"tNormalMap1\"].value = normalMap1;\n    _this.material.uniforms[\"color\"].value = color;\n    _this.material.uniforms[\"reflectivity\"].value = reflectivity;\n    _this.material.uniforms[\"textureMatrix\"].value = textureMatrix;\n    _this.material.uniforms[\"config\"].value.x = 0;\n    _this.material.uniforms[\"config\"].value.y = halfCycle;\n    _this.material.uniforms[\"config\"].value.z = halfCycle;\n    _this.material.uniforms[\"config\"].value.w = scale;\n    function updateTextureMatrix(camera) {\n      textureMatrix.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1);\n      textureMatrix.multiply(camera.projectionMatrix);\n      textureMatrix.multiply(camera.matrixWorldInverse);\n      textureMatrix.multiply(scope.matrixWorld);\n    }\n    function updateFlow() {\n      var delta = clock.getDelta();\n      var config = scope.material.uniforms[\"config\"];\n      config.value.x += flowSpeed * delta;\n      config.value.y = config.value.x + halfCycle;\n      if (config.value.x >= cycle) {\n        config.value.x = 0;\n        config.value.y = halfCycle;\n      } else if (config.value.y >= cycle) {\n        config.value.y = config.value.y - cycle;\n      }\n    }\n    _this.onBeforeRender = function (renderer, scene, camera) {\n      updateTextureMatrix(camera);\n      updateFlow();\n      scope.visible = false;\n      reflector.matrixWorld.copy(scope.matrixWorld);\n      refractor.matrixWorld.copy(scope.matrixWorld);\n      reflector.onBeforeRender(renderer, scene, camera);\n      refractor.onBeforeRender(renderer, scene, camera);\n      scope.visible = true;\n    };\n    return _this;\n  }\n  return _createClass(_Water2);\n}(Mesh);\nvar Water2 = _Water2;\n__publicField(Water2, \"WaterShader\", {\n  uniforms: {\n    color: {\n      value: null\n    },\n    reflectivity: {\n      value: 0\n    },\n    tReflectionMap: {\n      value: null\n    },\n    tRefractionMap: {\n      value: null\n    },\n    tNormalMap0: {\n      value: null\n    },\n    tNormalMap1: {\n      value: null\n    },\n    textureMatrix: {\n      value: null\n    },\n    config: {\n      value: new Vector4()\n    }\n  },\n  vertexShader: /* glsl */\"\\n\\n\\t\\t#include <common>\\n\\t\\t#include <fog_pars_vertex>\\n\\t\\t#include <logdepthbuf_pars_vertex>\\n\\n\\t\\tuniform mat4 textureMatrix;\\n\\n\\t\\tvarying vec4 vCoord;\\n\\t\\tvarying vec2 vUv;\\n\\t\\tvarying vec3 vToEye;\\n\\n\\t\\tvoid main() {\\n\\n\\t\\t\\tvUv = uv;\\n\\t\\t\\tvCoord = textureMatrix * vec4( position, 1.0 );\\n\\n\\t\\t\\tvec4 worldPosition = modelMatrix * vec4( position, 1.0 );\\n\\t\\t\\tvToEye = cameraPosition - worldPosition.xyz;\\n\\n\\t\\t\\tvec4 mvPosition =  viewMatrix * worldPosition; // used in fog_vertex\\n\\t\\t\\tgl_Position = projectionMatrix * mvPosition;\\n\\n\\t\\t\\t#include <logdepthbuf_vertex>\\n\\t\\t\\t#include <fog_vertex>\\n\\n\\t\\t}\",\n  fragmentShader: /* glsl */\"\\n\\n\\t\\t#include <common>\\n\\t\\t#include <fog_pars_fragment>\\n\\t\\t#include <logdepthbuf_pars_fragment>\\n\\n\\t\\tuniform sampler2D tReflectionMap;\\n\\t\\tuniform sampler2D tRefractionMap;\\n\\t\\tuniform sampler2D tNormalMap0;\\n\\t\\tuniform sampler2D tNormalMap1;\\n\\n\\t\\t#ifdef USE_FLOWMAP\\n\\t\\t\\tuniform sampler2D tFlowMap;\\n\\t\\t#else\\n\\t\\t\\tuniform vec2 flowDirection;\\n\\t\\t#endif\\n\\n\\t\\tuniform vec3 color;\\n\\t\\tuniform float reflectivity;\\n\\t\\tuniform vec4 config;\\n\\n\\t\\tvarying vec4 vCoord;\\n\\t\\tvarying vec2 vUv;\\n\\t\\tvarying vec3 vToEye;\\n\\n\\t\\tvoid main() {\\n\\n\\t\\t\\t#include <logdepthbuf_fragment>\\n\\n\\t\\t\\tfloat flowMapOffset0 = config.x;\\n\\t\\t\\tfloat flowMapOffset1 = config.y;\\n\\t\\t\\tfloat halfCycle = config.z;\\n\\t\\t\\tfloat scale = config.w;\\n\\n\\t\\t\\tvec3 toEye = normalize( vToEye );\\n\\n\\t\\t\\t// determine flow direction\\n\\t\\t\\tvec2 flow;\\n\\t\\t\\t#ifdef USE_FLOWMAP\\n\\t\\t\\t\\tflow = texture2D( tFlowMap, vUv ).rg * 2.0 - 1.0;\\n\\t\\t\\t#else\\n\\t\\t\\t\\tflow = flowDirection;\\n\\t\\t\\t#endif\\n\\t\\t\\tflow.x *= - 1.0;\\n\\n\\t\\t\\t// sample normal maps (distort uvs with flowdata)\\n\\t\\t\\tvec4 normalColor0 = texture2D( tNormalMap0, ( vUv * scale ) + flow * flowMapOffset0 );\\n\\t\\t\\tvec4 normalColor1 = texture2D( tNormalMap1, ( vUv * scale ) + flow * flowMapOffset1 );\\n\\n\\t\\t\\t// linear interpolate to get the final normal color\\n\\t\\t\\tfloat flowLerp = abs( halfCycle - flowMapOffset0 ) / halfCycle;\\n\\t\\t\\tvec4 normalColor = mix( normalColor0, normalColor1, flowLerp );\\n\\n\\t\\t\\t// calculate normal vector\\n\\t\\t\\tvec3 normal = normalize( vec3( normalColor.r * 2.0 - 1.0, normalColor.b,  normalColor.g * 2.0 - 1.0 ) );\\n\\n\\t\\t\\t// calculate the fresnel term to blend reflection and refraction maps\\n\\t\\t\\tfloat theta = max( dot( toEye, normal ), 0.0 );\\n\\t\\t\\tfloat reflectance = reflectivity + ( 1.0 - reflectivity ) * pow( ( 1.0 - theta ), 5.0 );\\n\\n\\t\\t\\t// calculate final uv coords\\n\\t\\t\\tvec3 coord = vCoord.xyz / vCoord.w;\\n\\t\\t\\tvec2 uv = coord.xy + coord.z * normal.xz * 0.05;\\n\\n\\t\\t\\tvec4 reflectColor = texture2D( tReflectionMap, vec2( 1.0 - uv.x, uv.y ) );\\n\\t\\t\\tvec4 refractColor = texture2D( tRefractionMap, uv );\\n\\n\\t\\t\\t// multiply water color with the mix of both textures\\n\\t\\t\\tgl_FragColor = vec4( color, 1.0 ) * mix( refractColor, reflectColor, reflectance );\\n\\n\\t\\t\\t#include <tonemapping_fragment>\\n\\t\\t\\t#include <\".concat(version >= 154 ? \"colorspace_fragment\" : \"encodings_fragment\", \">\\n\\t\\t\\t#include <fog_fragment>\\n\\n\\t\\t}\")\n});\nexport { Water2 };","map":{"version":3,"names":["_Water2","_Mesh","_inherits","_super","_createSuper","geometry","_this","options","arguments","length","undefined","_classCallCheck","call","isWater","type","scope","_assertThisInitialized","color","Color","textureWidth","textureHeight","clipBias","flowDirection","Vector2","flowSpeed","reflectivity","scale","shader","WaterShader","encoding","flowMap","normalMap0","normalMap1","cycle","halfCycle","textureMatrix","Matrix4","clock","Clock","Reflector","console","error","_possibleConstructorReturn","Refractor","reflector","refractor","matrixAutoUpdate","material","ShaderMaterial","uniforms","UniformsUtils","merge","UniformsLib","vertexShader","fragmentShader","transparent","fog","defines","USE_FLOWMAP","value","wrapS","wrapT","RepeatWrapping","getRenderTarget","texture","x","y","z","w","updateTextureMatrix","camera","set","multiply","projectionMatrix","matrixWorldInverse","matrixWorld","updateFlow","delta","getDelta","config","onBeforeRender","renderer","scene","visible","copy","_createClass","Mesh","Water2","__publicField","tReflectionMap","tRefractionMap","tNormalMap0","tNormalMap1","Vector4","concat","version"],"sources":["C:\\Users\\Nayyu\\Desktop\\skibidai-public-build\\node_modules\\src\\objects\\Water2.js"],"sourcesContent":["import {\n  Clock,\n  Color,\n  Matrix4,\n  Mesh,\n  RepeatWrapping,\n  ShaderMaterial,\n  UniformsLib,\n  UniformsUtils,\n  Vector2,\n  Vector4,\n} from 'three'\nimport { Reflector } from './Reflector'\nimport { Refractor } from './Refractor'\nimport { version } from '../_polyfill/constants'\n\n/**\n * References:\n *\thttp://www.valvesoftware.com/publications/2010/siggraph2010_vlachos_waterflow.pdf\n * \thttp://graphicsrunner.blogspot.de/2010/08/water-using-flow-maps.html\n *\n */\n\nclass Water2 extends Mesh {\n  static WaterShader = {\n    uniforms: {\n      color: {\n        value: null,\n      },\n\n      reflectivity: {\n        value: 0,\n      },\n\n      tReflectionMap: {\n        value: null,\n      },\n\n      tRefractionMap: {\n        value: null,\n      },\n\n      tNormalMap0: {\n        value: null,\n      },\n\n      tNormalMap1: {\n        value: null,\n      },\n\n      textureMatrix: {\n        value: null,\n      },\n\n      config: {\n        value: new Vector4(),\n      },\n    },\n\n    vertexShader: /* glsl */ `\n\n\t\t#include <common>\n\t\t#include <fog_pars_vertex>\n\t\t#include <logdepthbuf_pars_vertex>\n\n\t\tuniform mat4 textureMatrix;\n\n\t\tvarying vec4 vCoord;\n\t\tvarying vec2 vUv;\n\t\tvarying vec3 vToEye;\n\n\t\tvoid main() {\n\n\t\t\tvUv = uv;\n\t\t\tvCoord = textureMatrix * vec4( position, 1.0 );\n\n\t\t\tvec4 worldPosition = modelMatrix * vec4( position, 1.0 );\n\t\t\tvToEye = cameraPosition - worldPosition.xyz;\n\n\t\t\tvec4 mvPosition =  viewMatrix * worldPosition; // used in fog_vertex\n\t\t\tgl_Position = projectionMatrix * mvPosition;\n\n\t\t\t#include <logdepthbuf_vertex>\n\t\t\t#include <fog_vertex>\n\n\t\t}`,\n\n    fragmentShader: /* glsl */ `\n\n\t\t#include <common>\n\t\t#include <fog_pars_fragment>\n\t\t#include <logdepthbuf_pars_fragment>\n\n\t\tuniform sampler2D tReflectionMap;\n\t\tuniform sampler2D tRefractionMap;\n\t\tuniform sampler2D tNormalMap0;\n\t\tuniform sampler2D tNormalMap1;\n\n\t\t#ifdef USE_FLOWMAP\n\t\t\tuniform sampler2D tFlowMap;\n\t\t#else\n\t\t\tuniform vec2 flowDirection;\n\t\t#endif\n\n\t\tuniform vec3 color;\n\t\tuniform float reflectivity;\n\t\tuniform vec4 config;\n\n\t\tvarying vec4 vCoord;\n\t\tvarying vec2 vUv;\n\t\tvarying vec3 vToEye;\n\n\t\tvoid main() {\n\n\t\t\t#include <logdepthbuf_fragment>\n\n\t\t\tfloat flowMapOffset0 = config.x;\n\t\t\tfloat flowMapOffset1 = config.y;\n\t\t\tfloat halfCycle = config.z;\n\t\t\tfloat scale = config.w;\n\n\t\t\tvec3 toEye = normalize( vToEye );\n\n\t\t\t// determine flow direction\n\t\t\tvec2 flow;\n\t\t\t#ifdef USE_FLOWMAP\n\t\t\t\tflow = texture2D( tFlowMap, vUv ).rg * 2.0 - 1.0;\n\t\t\t#else\n\t\t\t\tflow = flowDirection;\n\t\t\t#endif\n\t\t\tflow.x *= - 1.0;\n\n\t\t\t// sample normal maps (distort uvs with flowdata)\n\t\t\tvec4 normalColor0 = texture2D( tNormalMap0, ( vUv * scale ) + flow * flowMapOffset0 );\n\t\t\tvec4 normalColor1 = texture2D( tNormalMap1, ( vUv * scale ) + flow * flowMapOffset1 );\n\n\t\t\t// linear interpolate to get the final normal color\n\t\t\tfloat flowLerp = abs( halfCycle - flowMapOffset0 ) / halfCycle;\n\t\t\tvec4 normalColor = mix( normalColor0, normalColor1, flowLerp );\n\n\t\t\t// calculate normal vector\n\t\t\tvec3 normal = normalize( vec3( normalColor.r * 2.0 - 1.0, normalColor.b,  normalColor.g * 2.0 - 1.0 ) );\n\n\t\t\t// calculate the fresnel term to blend reflection and refraction maps\n\t\t\tfloat theta = max( dot( toEye, normal ), 0.0 );\n\t\t\tfloat reflectance = reflectivity + ( 1.0 - reflectivity ) * pow( ( 1.0 - theta ), 5.0 );\n\n\t\t\t// calculate final uv coords\n\t\t\tvec3 coord = vCoord.xyz / vCoord.w;\n\t\t\tvec2 uv = coord.xy + coord.z * normal.xz * 0.05;\n\n\t\t\tvec4 reflectColor = texture2D( tReflectionMap, vec2( 1.0 - uv.x, uv.y ) );\n\t\t\tvec4 refractColor = texture2D( tRefractionMap, uv );\n\n\t\t\t// multiply water color with the mix of both textures\n\t\t\tgl_FragColor = vec4( color, 1.0 ) * mix( refractColor, reflectColor, reflectance );\n\n\t\t\t#include <tonemapping_fragment>\n\t\t\t#include <${version >= 154 ? 'colorspace_fragment' : 'encodings_fragment'}>\n\t\t\t#include <fog_fragment>\n\n\t\t}`,\n  }\n\n  constructor(geometry, options = {}) {\n    super(geometry)\n\n    this.isWater = true\n\n    this.type = 'Water'\n\n    const scope = this\n\n    const color = options.color !== undefined ? new Color(options.color) : new Color(0xffffff)\n    const textureWidth = options.textureWidth || 512\n    const textureHeight = options.textureHeight || 512\n    const clipBias = options.clipBias || 0\n    const flowDirection = options.flowDirection || new Vector2(1, 0)\n    const flowSpeed = options.flowSpeed || 0.03\n    const reflectivity = options.reflectivity || 0.02\n    const scale = options.scale || 1\n    const shader = options.shader || Water2.WaterShader\n    const encoding = options.encoding !== undefined ? options.encoding : 3000\n\n    const flowMap = options.flowMap || undefined\n    const normalMap0 = options.normalMap0\n    const normalMap1 = options.normalMap1\n\n    const cycle = 0.15 // a cycle of a flow map phase\n    const halfCycle = cycle * 0.5\n    const textureMatrix = new Matrix4()\n    const clock = new Clock()\n\n    // internal components\n\n    if (Reflector === undefined) {\n      console.error('THREE.Water: Required component Reflector not found.')\n      return\n    }\n\n    if (Refractor === undefined) {\n      console.error('THREE.Water: Required component Refractor not found.')\n      return\n    }\n\n    const reflector = new Reflector(geometry, {\n      textureWidth: textureWidth,\n      textureHeight: textureHeight,\n      clipBias: clipBias,\n      encoding: encoding,\n    })\n\n    const refractor = new Refractor(geometry, {\n      textureWidth: textureWidth,\n      textureHeight: textureHeight,\n      clipBias: clipBias,\n      encoding: encoding,\n    })\n\n    reflector.matrixAutoUpdate = false\n    refractor.matrixAutoUpdate = false\n\n    // material\n\n    this.material = new ShaderMaterial({\n      uniforms: UniformsUtils.merge([UniformsLib['fog'], shader.uniforms]),\n      vertexShader: shader.vertexShader,\n      fragmentShader: shader.fragmentShader,\n      transparent: true,\n      fog: true,\n    })\n\n    if (flowMap !== undefined) {\n      this.material.defines.USE_FLOWMAP = ''\n      this.material.uniforms['tFlowMap'] = {\n        type: 't',\n        value: flowMap,\n      }\n    } else {\n      this.material.uniforms['flowDirection'] = {\n        type: 'v2',\n        value: flowDirection,\n      }\n    }\n\n    // maps\n\n    normalMap0.wrapS = normalMap0.wrapT = RepeatWrapping\n    normalMap1.wrapS = normalMap1.wrapT = RepeatWrapping\n\n    this.material.uniforms['tReflectionMap'].value = reflector.getRenderTarget().texture\n    this.material.uniforms['tRefractionMap'].value = refractor.getRenderTarget().texture\n    this.material.uniforms['tNormalMap0'].value = normalMap0\n    this.material.uniforms['tNormalMap1'].value = normalMap1\n\n    // water\n\n    this.material.uniforms['color'].value = color\n    this.material.uniforms['reflectivity'].value = reflectivity\n    this.material.uniforms['textureMatrix'].value = textureMatrix\n\n    // inital values\n\n    this.material.uniforms['config'].value.x = 0 // flowMapOffset0\n    this.material.uniforms['config'].value.y = halfCycle // flowMapOffset1\n    this.material.uniforms['config'].value.z = halfCycle // halfCycle\n    this.material.uniforms['config'].value.w = scale // scale\n\n    // functions\n\n    function updateTextureMatrix(camera) {\n      textureMatrix.set(0.5, 0.0, 0.0, 0.5, 0.0, 0.5, 0.0, 0.5, 0.0, 0.0, 0.5, 0.5, 0.0, 0.0, 0.0, 1.0)\n\n      textureMatrix.multiply(camera.projectionMatrix)\n      textureMatrix.multiply(camera.matrixWorldInverse)\n      textureMatrix.multiply(scope.matrixWorld)\n    }\n\n    function updateFlow() {\n      const delta = clock.getDelta()\n      const config = scope.material.uniforms['config']\n\n      config.value.x += flowSpeed * delta // flowMapOffset0\n      config.value.y = config.value.x + halfCycle // flowMapOffset1\n\n      // Important: The distance between offsets should be always the value of \"halfCycle\".\n      // Moreover, both offsets should be in the range of [ 0, cycle ].\n      // This approach ensures a smooth water flow and avoids \"reset\" effects.\n\n      if (config.value.x >= cycle) {\n        config.value.x = 0\n        config.value.y = halfCycle\n      } else if (config.value.y >= cycle) {\n        config.value.y = config.value.y - cycle\n      }\n    }\n\n    //\n\n    this.onBeforeRender = function (renderer, scene, camera) {\n      updateTextureMatrix(camera)\n      updateFlow()\n\n      scope.visible = false\n\n      reflector.matrixWorld.copy(scope.matrixWorld)\n      refractor.matrixWorld.copy(scope.matrixWorld)\n\n      reflector.onBeforeRender(renderer, scene, camera)\n      refractor.onBeforeRender(renderer, scene, camera)\n\n      scope.visible = true\n    }\n  }\n}\n\nexport { Water2 }\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}