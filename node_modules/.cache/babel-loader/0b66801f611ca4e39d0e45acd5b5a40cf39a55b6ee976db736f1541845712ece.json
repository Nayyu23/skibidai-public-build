{"ast":null,"code":"import _classCallCheck from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _inherits from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport { Loader, FileLoader, BufferGeometry, Float32BufferAttribute } from \"three\";\nimport { decodeText } from \"../_polyfill/LoaderUtils.js\";\nvar PLYLoader = /*#__PURE__*/function (_Loader) {\n  _inherits(PLYLoader, _Loader);\n  var _super = _createSuper(PLYLoader);\n  function PLYLoader(manager) {\n    var _this;\n    _classCallCheck(this, PLYLoader);\n    _this = _super.call(this, manager);\n    _this.propertyNameMapping = {};\n    return _this;\n  }\n  _createClass(PLYLoader, [{\n    key: \"load\",\n    value: function load(url, onLoad, onProgress, onError) {\n      var scope = this;\n      var loader = new FileLoader(this.manager);\n      loader.setPath(this.path);\n      loader.setResponseType(\"arraybuffer\");\n      loader.setRequestHeader(this.requestHeader);\n      loader.setWithCredentials(this.withCredentials);\n      loader.load(url, function (text) {\n        try {\n          onLoad(scope.parse(text));\n        } catch (e) {\n          if (onError) {\n            onError(e);\n          } else {\n            console.error(e);\n          }\n          scope.manager.itemError(url);\n        }\n      }, onProgress, onError);\n    }\n  }, {\n    key: \"setPropertyNameMapping\",\n    value: function setPropertyNameMapping(mapping) {\n      this.propertyNameMapping = mapping;\n    }\n  }, {\n    key: \"parse\",\n    value: function parse(data) {\n      function parseHeader(data2) {\n        var patternHeader = /ply([\\s\\S]*)end_header\\r?\\n/;\n        var headerText = \"\";\n        var headerLength = 0;\n        var result = patternHeader.exec(data2);\n        if (result !== null) {\n          headerText = result[1];\n          headerLength = new Blob([result[0]]).size;\n        }\n        var header = {\n          comments: [],\n          elements: [],\n          headerLength: headerLength,\n          objInfo: \"\"\n        };\n        var lines = headerText.split(\"\\n\");\n        var currentElement;\n        function make_ply_element_property(propertValues, propertyNameMapping) {\n          var property = {\n            type: propertValues[0]\n          };\n          if (property.type === \"list\") {\n            property.name = propertValues[3];\n            property.countType = propertValues[1];\n            property.itemType = propertValues[2];\n          } else {\n            property.name = propertValues[1];\n          }\n          if (property.name in propertyNameMapping) {\n            property.name = propertyNameMapping[property.name];\n          }\n          return property;\n        }\n        for (var i = 0; i < lines.length; i++) {\n          var line = lines[i];\n          line = line.trim();\n          if (line === \"\") continue;\n          var lineValues = line.split(/\\s+/);\n          var lineType = lineValues.shift();\n          line = lineValues.join(\" \");\n          switch (lineType) {\n            case \"format\":\n              header.format = lineValues[0];\n              header.version = lineValues[1];\n              break;\n            case \"comment\":\n              header.comments.push(line);\n              break;\n            case \"element\":\n              if (currentElement !== void 0) {\n                header.elements.push(currentElement);\n              }\n              currentElement = {};\n              currentElement.name = lineValues[0];\n              currentElement.count = parseInt(lineValues[1]);\n              currentElement.properties = [];\n              break;\n            case \"property\":\n              currentElement.properties.push(make_ply_element_property(lineValues, scope.propertyNameMapping));\n              break;\n            case \"obj_info\":\n              header.objInfo = line;\n              break;\n            default:\n              console.log(\"unhandled\", lineType, lineValues);\n          }\n        }\n        if (currentElement !== void 0) {\n          header.elements.push(currentElement);\n        }\n        return header;\n      }\n      function parseASCIINumber(n, type) {\n        switch (type) {\n          case \"char\":\n          case \"uchar\":\n          case \"short\":\n          case \"ushort\":\n          case \"int\":\n          case \"uint\":\n          case \"int8\":\n          case \"uint8\":\n          case \"int16\":\n          case \"uint16\":\n          case \"int32\":\n          case \"uint32\":\n            return parseInt(n);\n          case \"float\":\n          case \"double\":\n          case \"float32\":\n          case \"float64\":\n            return parseFloat(n);\n        }\n      }\n      function parseASCIIElement(properties, line) {\n        var values = line.split(/\\s+/);\n        var element = {};\n        for (var i = 0; i < properties.length; i++) {\n          if (properties[i].type === \"list\") {\n            var list = [];\n            var n = parseASCIINumber(values.shift(), properties[i].countType);\n            for (var j = 0; j < n; j++) {\n              list.push(parseASCIINumber(values.shift(), properties[i].itemType));\n            }\n            element[properties[i].name] = list;\n          } else {\n            element[properties[i].name] = parseASCIINumber(values.shift(), properties[i].type);\n          }\n        }\n        return element;\n      }\n      function parseASCII(data2, header) {\n        var buffer = {\n          indices: [],\n          vertices: [],\n          normals: [],\n          uvs: [],\n          faceVertexUvs: [],\n          colors: []\n        };\n        var result;\n        var patternBody = /end_header\\s([\\s\\S]*)$/;\n        var body = \"\";\n        if ((result = patternBody.exec(data2)) !== null) {\n          body = result[1];\n        }\n        var lines = body.split(\"\\n\");\n        var currentElement = 0;\n        var currentElementCount = 0;\n        for (var i = 0; i < lines.length; i++) {\n          var line = lines[i];\n          line = line.trim();\n          if (line === \"\") {\n            continue;\n          }\n          if (currentElementCount >= header.elements[currentElement].count) {\n            currentElement++;\n            currentElementCount = 0;\n          }\n          var element = parseASCIIElement(header.elements[currentElement].properties, line);\n          handleElement(buffer, header.elements[currentElement].name, element);\n          currentElementCount++;\n        }\n        return postProcess(buffer);\n      }\n      function postProcess(buffer) {\n        var geometry2 = new BufferGeometry();\n        if (buffer.indices.length > 0) {\n          geometry2.setIndex(buffer.indices);\n        }\n        geometry2.setAttribute(\"position\", new Float32BufferAttribute(buffer.vertices, 3));\n        if (buffer.normals.length > 0) {\n          geometry2.setAttribute(\"normal\", new Float32BufferAttribute(buffer.normals, 3));\n        }\n        if (buffer.uvs.length > 0) {\n          geometry2.setAttribute(\"uv\", new Float32BufferAttribute(buffer.uvs, 2));\n        }\n        if (buffer.colors.length > 0) {\n          geometry2.setAttribute(\"color\", new Float32BufferAttribute(buffer.colors, 3));\n        }\n        if (buffer.faceVertexUvs.length > 0) {\n          geometry2 = geometry2.toNonIndexed();\n          geometry2.setAttribute(\"uv\", new Float32BufferAttribute(buffer.faceVertexUvs, 2));\n        }\n        geometry2.computeBoundingSphere();\n        return geometry2;\n      }\n      function handleElement(buffer, elementName, element) {\n        if (elementName === \"vertex\") {\n          buffer.vertices.push(element.x, element.y, element.z);\n          if (\"nx\" in element && \"ny\" in element && \"nz\" in element) {\n            buffer.normals.push(element.nx, element.ny, element.nz);\n          }\n          if (\"s\" in element && \"t\" in element) {\n            buffer.uvs.push(element.s, element.t);\n          }\n          if (\"red\" in element && \"green\" in element && \"blue\" in element) {\n            buffer.colors.push(element.red / 255, element.green / 255, element.blue / 255);\n          }\n        } else if (elementName === \"face\") {\n          var vertex_indices = element.vertex_indices || element.vertex_index;\n          var texcoord = element.texcoord;\n          if (vertex_indices.length === 3) {\n            buffer.indices.push(vertex_indices[0], vertex_indices[1], vertex_indices[2]);\n            if (texcoord && texcoord.length === 6) {\n              buffer.faceVertexUvs.push(texcoord[0], texcoord[1]);\n              buffer.faceVertexUvs.push(texcoord[2], texcoord[3]);\n              buffer.faceVertexUvs.push(texcoord[4], texcoord[5]);\n            }\n          } else if (vertex_indices.length === 4) {\n            buffer.indices.push(vertex_indices[0], vertex_indices[1], vertex_indices[3]);\n            buffer.indices.push(vertex_indices[1], vertex_indices[2], vertex_indices[3]);\n          }\n        }\n      }\n      function binaryRead(dataview, at, type, little_endian) {\n        switch (type) {\n          case \"int8\":\n          case \"char\":\n            return [dataview.getInt8(at), 1];\n          case \"uint8\":\n          case \"uchar\":\n            return [dataview.getUint8(at), 1];\n          case \"int16\":\n          case \"short\":\n            return [dataview.getInt16(at, little_endian), 2];\n          case \"uint16\":\n          case \"ushort\":\n            return [dataview.getUint16(at, little_endian), 2];\n          case \"int32\":\n          case \"int\":\n            return [dataview.getInt32(at, little_endian), 4];\n          case \"uint32\":\n          case \"uint\":\n            return [dataview.getUint32(at, little_endian), 4];\n          case \"float32\":\n          case \"float\":\n            return [dataview.getFloat32(at, little_endian), 4];\n          case \"float64\":\n          case \"double\":\n            return [dataview.getFloat64(at, little_endian), 8];\n        }\n      }\n      function binaryReadElement(dataview, at, properties, little_endian) {\n        var element = {};\n        var result,\n          read = 0;\n        for (var i = 0; i < properties.length; i++) {\n          if (properties[i].type === \"list\") {\n            var list = [];\n            result = binaryRead(dataview, at + read, properties[i].countType, little_endian);\n            var n = result[0];\n            read += result[1];\n            for (var j = 0; j < n; j++) {\n              result = binaryRead(dataview, at + read, properties[i].itemType, little_endian);\n              list.push(result[0]);\n              read += result[1];\n            }\n            element[properties[i].name] = list;\n          } else {\n            result = binaryRead(dataview, at + read, properties[i].type, little_endian);\n            element[properties[i].name] = result[0];\n            read += result[1];\n          }\n        }\n        return [element, read];\n      }\n      function parseBinary(data2, header) {\n        var buffer = {\n          indices: [],\n          vertices: [],\n          normals: [],\n          uvs: [],\n          faceVertexUvs: [],\n          colors: []\n        };\n        var little_endian = header.format === \"binary_little_endian\";\n        var body = new DataView(data2, header.headerLength);\n        var result,\n          loc = 0;\n        for (var currentElement = 0; currentElement < header.elements.length; currentElement++) {\n          for (var currentElementCount = 0; currentElementCount < header.elements[currentElement].count; currentElementCount++) {\n            result = binaryReadElement(body, loc, header.elements[currentElement].properties, little_endian);\n            loc += result[1];\n            var element = result[0];\n            handleElement(buffer, header.elements[currentElement].name, element);\n          }\n        }\n        return postProcess(buffer);\n      }\n      var geometry;\n      var scope = this;\n      if (data instanceof ArrayBuffer) {\n        var text = decodeText(new Uint8Array(data));\n        var header = parseHeader(text);\n        geometry = header.format === \"ascii\" ? parseASCII(text, header) : parseBinary(data, header);\n      } else {\n        geometry = parseASCII(data, parseHeader(data));\n      }\n      return geometry;\n    }\n  }]);\n  return PLYLoader;\n}(Loader);\nexport { PLYLoader };","map":{"version":3,"names":["PLYLoader","_Loader","_inherits","_super","_createSuper","manager","_this","_classCallCheck","call","propertyNameMapping","_createClass","key","value","load","url","onLoad","onProgress","onError","scope","loader","FileLoader","setPath","path","setResponseType","setRequestHeader","requestHeader","setWithCredentials","withCredentials","text","parse","e","console","error","itemError","setPropertyNameMapping","mapping","data","parseHeader","data2","patternHeader","headerText","headerLength","result","exec","Blob","size","header","comments","elements","objInfo","lines","split","currentElement","make_ply_element_property","propertValues","property","type","name","countType","itemType","i","length","line","trim","lineValues","lineType","shift","join","format","version","push","count","parseInt","properties","log","parseASCIINumber","n","parseFloat","parseASCIIElement","values","element","list","j","parseASCII","buffer","indices","vertices","normals","uvs","faceVertexUvs","colors","patternBody","body","currentElementCount","handleElement","postProcess","geometry2","BufferGeometry","setIndex","setAttribute","Float32BufferAttribute","toNonIndexed","computeBoundingSphere","elementName","x","y","z","nx","ny","nz","s","t","red","green","blue","vertex_indices","vertex_index","texcoord","binaryRead","dataview","at","little_endian","getInt8","getUint8","getInt16","getUint16","getInt32","getUint32","getFloat32","getFloat64","binaryReadElement","read","parseBinary","DataView","loc","geometry","ArrayBuffer","decodeText","Uint8Array","Loader"],"sources":["C:\\Users\\Nayyu\\Desktop\\skibidai-public-build\\node_modules\\src\\loaders\\PLYLoader.js"],"sourcesContent":["import { BufferGeometry, FileLoader, Float32BufferAttribute, Loader, LoaderUtils } from 'three'\nimport { decodeText } from '../_polyfill/LoaderUtils'\n\n/**\n * Description: A THREE loader for PLY ASCII files (known as the Polygon\n * File Format or the Stanford Triangle Format).\n *\n * Limitations: ASCII decoding assumes file is UTF-8.\n *\n * Usage:\n *\tconst loader = new PLYLoader();\n *\tloader.load('./models/ply/ascii/dolphins.ply', function (geometry) {\n *\n *\t\tscene.add( new THREE.Mesh( geometry ) );\n *\n *\t} );\n *\n * If the PLY file uses non standard property names, they can be mapped while\n * loading. For example, the following maps the properties\n * “diffuse_(red|green|blue)” in the file to standard color names.\n *\n * loader.setPropertyNameMapping( {\n *\tdiffuse_red: 'red',\n *\tdiffuse_green: 'green',\n *\tdiffuse_blue: 'blue'\n * } );\n *\n */\n\nclass PLYLoader extends Loader {\n  constructor(manager) {\n    super(manager)\n\n    this.propertyNameMapping = {}\n  }\n\n  load(url, onLoad, onProgress, onError) {\n    const scope = this\n\n    const loader = new FileLoader(this.manager)\n    loader.setPath(this.path)\n    loader.setResponseType('arraybuffer')\n    loader.setRequestHeader(this.requestHeader)\n    loader.setWithCredentials(this.withCredentials)\n    loader.load(\n      url,\n      function (text) {\n        try {\n          onLoad(scope.parse(text))\n        } catch (e) {\n          if (onError) {\n            onError(e)\n          } else {\n            console.error(e)\n          }\n\n          scope.manager.itemError(url)\n        }\n      },\n      onProgress,\n      onError,\n    )\n  }\n\n  setPropertyNameMapping(mapping) {\n    this.propertyNameMapping = mapping\n  }\n\n  parse(data) {\n    function parseHeader(data) {\n      const patternHeader = /ply([\\s\\S]*)end_header\\r?\\n/\n      let headerText = ''\n      let headerLength = 0\n      const result = patternHeader.exec(data)\n\n      if (result !== null) {\n        headerText = result[1]\n        headerLength = new Blob([result[0]]).size\n      }\n\n      const header = {\n        comments: [],\n        elements: [],\n        headerLength: headerLength,\n        objInfo: '',\n      }\n\n      const lines = headerText.split('\\n')\n      let currentElement\n\n      function make_ply_element_property(propertValues, propertyNameMapping) {\n        const property = { type: propertValues[0] }\n\n        if (property.type === 'list') {\n          property.name = propertValues[3]\n          property.countType = propertValues[1]\n          property.itemType = propertValues[2]\n        } else {\n          property.name = propertValues[1]\n        }\n\n        if (property.name in propertyNameMapping) {\n          property.name = propertyNameMapping[property.name]\n        }\n\n        return property\n      }\n\n      for (let i = 0; i < lines.length; i++) {\n        let line = lines[i]\n        line = line.trim()\n\n        if (line === '') continue\n\n        const lineValues = line.split(/\\s+/)\n        const lineType = lineValues.shift()\n        line = lineValues.join(' ')\n\n        switch (lineType) {\n          case 'format':\n            header.format = lineValues[0]\n            header.version = lineValues[1]\n\n            break\n\n          case 'comment':\n            header.comments.push(line)\n\n            break\n\n          case 'element':\n            if (currentElement !== undefined) {\n              header.elements.push(currentElement)\n            }\n\n            currentElement = {}\n            currentElement.name = lineValues[0]\n            currentElement.count = parseInt(lineValues[1])\n            currentElement.properties = []\n\n            break\n\n          case 'property':\n            currentElement.properties.push(make_ply_element_property(lineValues, scope.propertyNameMapping))\n\n            break\n\n          case 'obj_info':\n            header.objInfo = line\n\n            break\n\n          default:\n            console.log('unhandled', lineType, lineValues)\n        }\n      }\n\n      if (currentElement !== undefined) {\n        header.elements.push(currentElement)\n      }\n\n      return header\n    }\n\n    function parseASCIINumber(n, type) {\n      switch (type) {\n        case 'char':\n        case 'uchar':\n        case 'short':\n        case 'ushort':\n        case 'int':\n        case 'uint':\n        case 'int8':\n        case 'uint8':\n        case 'int16':\n        case 'uint16':\n        case 'int32':\n        case 'uint32':\n          return parseInt(n)\n\n        case 'float':\n        case 'double':\n        case 'float32':\n        case 'float64':\n          return parseFloat(n)\n      }\n    }\n\n    function parseASCIIElement(properties, line) {\n      const values = line.split(/\\s+/)\n\n      const element = {}\n\n      for (let i = 0; i < properties.length; i++) {\n        if (properties[i].type === 'list') {\n          const list = []\n          const n = parseASCIINumber(values.shift(), properties[i].countType)\n\n          for (let j = 0; j < n; j++) {\n            list.push(parseASCIINumber(values.shift(), properties[i].itemType))\n          }\n\n          element[properties[i].name] = list\n        } else {\n          element[properties[i].name] = parseASCIINumber(values.shift(), properties[i].type)\n        }\n      }\n\n      return element\n    }\n\n    function parseASCII(data, header) {\n      // PLY ascii format specification, as per http://en.wikipedia.org/wiki/PLY_(file_format)\n\n      const buffer = {\n        indices: [],\n        vertices: [],\n        normals: [],\n        uvs: [],\n        faceVertexUvs: [],\n        colors: [],\n      }\n\n      let result\n\n      const patternBody = /end_header\\s([\\s\\S]*)$/\n      let body = ''\n      if ((result = patternBody.exec(data)) !== null) {\n        body = result[1]\n      }\n\n      const lines = body.split('\\n')\n      let currentElement = 0\n      let currentElementCount = 0\n\n      for (let i = 0; i < lines.length; i++) {\n        let line = lines[i]\n        line = line.trim()\n        if (line === '') {\n          continue\n        }\n\n        if (currentElementCount >= header.elements[currentElement].count) {\n          currentElement++\n          currentElementCount = 0\n        }\n\n        const element = parseASCIIElement(header.elements[currentElement].properties, line)\n\n        handleElement(buffer, header.elements[currentElement].name, element)\n\n        currentElementCount++\n      }\n\n      return postProcess(buffer)\n    }\n\n    function postProcess(buffer) {\n      let geometry = new BufferGeometry()\n\n      // mandatory buffer data\n\n      if (buffer.indices.length > 0) {\n        geometry.setIndex(buffer.indices)\n      }\n\n      geometry.setAttribute('position', new Float32BufferAttribute(buffer.vertices, 3))\n\n      // optional buffer data\n\n      if (buffer.normals.length > 0) {\n        geometry.setAttribute('normal', new Float32BufferAttribute(buffer.normals, 3))\n      }\n\n      if (buffer.uvs.length > 0) {\n        geometry.setAttribute('uv', new Float32BufferAttribute(buffer.uvs, 2))\n      }\n\n      if (buffer.colors.length > 0) {\n        geometry.setAttribute('color', new Float32BufferAttribute(buffer.colors, 3))\n      }\n\n      if (buffer.faceVertexUvs.length > 0) {\n        geometry = geometry.toNonIndexed()\n        geometry.setAttribute('uv', new Float32BufferAttribute(buffer.faceVertexUvs, 2))\n      }\n\n      geometry.computeBoundingSphere()\n\n      return geometry\n    }\n\n    function handleElement(buffer, elementName, element) {\n      if (elementName === 'vertex') {\n        buffer.vertices.push(element.x, element.y, element.z)\n\n        if ('nx' in element && 'ny' in element && 'nz' in element) {\n          buffer.normals.push(element.nx, element.ny, element.nz)\n        }\n\n        if ('s' in element && 't' in element) {\n          buffer.uvs.push(element.s, element.t)\n        }\n\n        if ('red' in element && 'green' in element && 'blue' in element) {\n          buffer.colors.push(element.red / 255.0, element.green / 255.0, element.blue / 255.0)\n        }\n      } else if (elementName === 'face') {\n        const vertex_indices = element.vertex_indices || element.vertex_index // issue #9338\n        const texcoord = element.texcoord\n\n        if (vertex_indices.length === 3) {\n          buffer.indices.push(vertex_indices[0], vertex_indices[1], vertex_indices[2])\n\n          if (texcoord && texcoord.length === 6) {\n            buffer.faceVertexUvs.push(texcoord[0], texcoord[1])\n            buffer.faceVertexUvs.push(texcoord[2], texcoord[3])\n            buffer.faceVertexUvs.push(texcoord[4], texcoord[5])\n          }\n        } else if (vertex_indices.length === 4) {\n          buffer.indices.push(vertex_indices[0], vertex_indices[1], vertex_indices[3])\n          buffer.indices.push(vertex_indices[1], vertex_indices[2], vertex_indices[3])\n        }\n      }\n    }\n\n    function binaryRead(dataview, at, type, little_endian) {\n      switch (type) {\n        // corespondences for non-specific length types here match rply:\n        case 'int8':\n        case 'char':\n          return [dataview.getInt8(at), 1]\n        case 'uint8':\n        case 'uchar':\n          return [dataview.getUint8(at), 1]\n        case 'int16':\n        case 'short':\n          return [dataview.getInt16(at, little_endian), 2]\n        case 'uint16':\n        case 'ushort':\n          return [dataview.getUint16(at, little_endian), 2]\n        case 'int32':\n        case 'int':\n          return [dataview.getInt32(at, little_endian), 4]\n        case 'uint32':\n        case 'uint':\n          return [dataview.getUint32(at, little_endian), 4]\n        case 'float32':\n        case 'float':\n          return [dataview.getFloat32(at, little_endian), 4]\n        case 'float64':\n        case 'double':\n          return [dataview.getFloat64(at, little_endian), 8]\n      }\n    }\n\n    function binaryReadElement(dataview, at, properties, little_endian) {\n      const element = {}\n      let result,\n        read = 0\n\n      for (let i = 0; i < properties.length; i++) {\n        if (properties[i].type === 'list') {\n          const list = []\n\n          result = binaryRead(dataview, at + read, properties[i].countType, little_endian)\n          const n = result[0]\n          read += result[1]\n\n          for (let j = 0; j < n; j++) {\n            result = binaryRead(dataview, at + read, properties[i].itemType, little_endian)\n            list.push(result[0])\n            read += result[1]\n          }\n\n          element[properties[i].name] = list\n        } else {\n          result = binaryRead(dataview, at + read, properties[i].type, little_endian)\n          element[properties[i].name] = result[0]\n          read += result[1]\n        }\n      }\n\n      return [element, read]\n    }\n\n    function parseBinary(data, header) {\n      const buffer = {\n        indices: [],\n        vertices: [],\n        normals: [],\n        uvs: [],\n        faceVertexUvs: [],\n        colors: [],\n      }\n\n      const little_endian = header.format === 'binary_little_endian'\n      const body = new DataView(data, header.headerLength)\n      let result,\n        loc = 0\n\n      for (let currentElement = 0; currentElement < header.elements.length; currentElement++) {\n        for (\n          let currentElementCount = 0;\n          currentElementCount < header.elements[currentElement].count;\n          currentElementCount++\n        ) {\n          result = binaryReadElement(body, loc, header.elements[currentElement].properties, little_endian)\n          loc += result[1]\n          const element = result[0]\n\n          handleElement(buffer, header.elements[currentElement].name, element)\n        }\n      }\n\n      return postProcess(buffer)\n    }\n\n    //\n\n    let geometry\n    const scope = this\n\n    if (data instanceof ArrayBuffer) {\n      const text = decodeText(new Uint8Array(data))\n      const header = parseHeader(text)\n\n      geometry = header.format === 'ascii' ? parseASCII(text, header) : parseBinary(data, header)\n    } else {\n      geometry = parseASCII(data, parseHeader(data))\n    }\n\n    return geometry\n  }\n}\n\nexport { PLYLoader }\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}