{"ast":null,"code":"import _classCallCheck from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport { Vector3, Line3, Plane, Mesh } from \"three\";\nimport { ConvexGeometry } from \"../geometries/ConvexGeometry.js\";\nvar _v1 = new Vector3();\nvar ConvexObjectBreaker = /*#__PURE__*/function () {\n  function ConvexObjectBreaker() {\n    var minSizeForBreak = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1.4;\n    var smallDelta = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1e-4;\n    _classCallCheck(this, ConvexObjectBreaker);\n    this.minSizeForBreak = minSizeForBreak;\n    this.smallDelta = smallDelta;\n    this.tempLine1 = new Line3();\n    this.tempPlane1 = new Plane();\n    this.tempPlane2 = new Plane();\n    this.tempPlane_Cut = new Plane();\n    this.tempCM1 = new Vector3();\n    this.tempCM2 = new Vector3();\n    this.tempVector3 = new Vector3();\n    this.tempVector3_2 = new Vector3();\n    this.tempVector3_3 = new Vector3();\n    this.tempVector3_P0 = new Vector3();\n    this.tempVector3_P1 = new Vector3();\n    this.tempVector3_P2 = new Vector3();\n    this.tempVector3_N0 = new Vector3();\n    this.tempVector3_N1 = new Vector3();\n    this.tempVector3_AB = new Vector3();\n    this.tempVector3_CB = new Vector3();\n    this.tempResultObjects = {\n      object1: null,\n      object2: null\n    };\n    this.segments = [];\n    var n = 30 * 30;\n    for (var i = 0; i < n; i++) this.segments[i] = false;\n  }\n  _createClass(ConvexObjectBreaker, [{\n    key: \"prepareBreakableObject\",\n    value: function prepareBreakableObject(object, mass, velocity, angularVelocity, breakable) {\n      var userData = object.userData;\n      userData.mass = mass;\n      userData.velocity = velocity.clone();\n      userData.angularVelocity = angularVelocity.clone();\n      userData.breakable = breakable;\n    }\n    /*\n     * @param {int} maxRadialIterations Iterations for radial cuts.\n     * @param {int} maxRandomIterations Max random iterations for not-radial cuts\n     *\n     * Returns the array of pieces\n     */\n  }, {\n    key: \"subdivideByImpact\",\n    value: function subdivideByImpact(object, pointOfImpact, normal, maxRadialIterations, maxRandomIterations) {\n      var debris = [];\n      var tempPlane1 = this.tempPlane1;\n      var tempPlane2 = this.tempPlane2;\n      this.tempVector3.addVectors(pointOfImpact, normal);\n      tempPlane1.setFromCoplanarPoints(pointOfImpact, object.position, this.tempVector3);\n      var maxTotalIterations = maxRandomIterations + maxRadialIterations;\n      var scope = this;\n      function subdivideRadial(subObject, startAngle, endAngle, numIterations) {\n        if (Math.random() < numIterations * 0.05 || numIterations > maxTotalIterations) {\n          debris.push(subObject);\n          return;\n        }\n        var angle = Math.PI;\n        if (numIterations === 0) {\n          tempPlane2.normal.copy(tempPlane1.normal);\n          tempPlane2.constant = tempPlane1.constant;\n        } else {\n          if (numIterations <= maxRadialIterations) {\n            angle = (endAngle - startAngle) * (0.2 + 0.6 * Math.random()) + startAngle;\n            scope.tempVector3_2.copy(object.position).sub(pointOfImpact).applyAxisAngle(normal, angle).add(pointOfImpact);\n            tempPlane2.setFromCoplanarPoints(pointOfImpact, scope.tempVector3, scope.tempVector3_2);\n          } else {\n            angle = (0.5 * (numIterations & 1) + 0.2 * (2 - Math.random())) * Math.PI;\n            scope.tempVector3_2.copy(pointOfImpact).sub(subObject.position).applyAxisAngle(normal, angle).add(subObject.position);\n            scope.tempVector3_3.copy(normal).add(subObject.position);\n            tempPlane2.setFromCoplanarPoints(subObject.position, scope.tempVector3_3, scope.tempVector3_2);\n          }\n        }\n        scope.cutByPlane(subObject, tempPlane2, scope.tempResultObjects);\n        var obj1 = scope.tempResultObjects.object1;\n        var obj2 = scope.tempResultObjects.object2;\n        if (obj1) {\n          subdivideRadial(obj1, startAngle, angle, numIterations + 1);\n        }\n        if (obj2) {\n          subdivideRadial(obj2, angle, endAngle, numIterations + 1);\n        }\n      }\n      subdivideRadial(object, 0, 2 * Math.PI, 0);\n      return debris;\n    }\n  }, {\n    key: \"cutByPlane\",\n    value: function cutByPlane(object, plane, output) {\n      var geometry = object.geometry;\n      var coords = geometry.attributes.position.array;\n      var normals = geometry.attributes.normal.array;\n      var numPoints = coords.length / 3;\n      var numFaces = numPoints / 3;\n      var indices = geometry.getIndex();\n      if (indices) {\n        indices = indices.array;\n        numFaces = indices.length / 3;\n      }\n      function getVertexIndex(faceIdx, vert) {\n        var idx = faceIdx * 3 + vert;\n        return indices ? indices[idx] : idx;\n      }\n      var points1 = [];\n      var points2 = [];\n      var delta = this.smallDelta;\n      var numPointPairs = numPoints * numPoints;\n      for (var i = 0; i < numPointPairs; i++) this.segments[i] = false;\n      var p0 = this.tempVector3_P0;\n      var p1 = this.tempVector3_P1;\n      var n0 = this.tempVector3_N0;\n      var n1 = this.tempVector3_N1;\n      for (var _i = 0; _i < numFaces - 1; _i++) {\n        var a1 = getVertexIndex(_i, 0);\n        var b1 = getVertexIndex(_i, 1);\n        var c1 = getVertexIndex(_i, 2);\n        n0.set(normals[a1], normals[a1] + 1, normals[a1] + 2);\n        for (var j = _i + 1; j < numFaces; j++) {\n          var a2 = getVertexIndex(j, 0);\n          var b2 = getVertexIndex(j, 1);\n          var c2 = getVertexIndex(j, 2);\n          n1.set(normals[a2], normals[a2] + 1, normals[a2] + 2);\n          var coplanar = 1 - n0.dot(n1) < delta;\n          if (coplanar) {\n            if (a1 === a2 || a1 === b2 || a1 === c2) {\n              if (b1 === a2 || b1 === b2 || b1 === c2) {\n                this.segments[a1 * numPoints + b1] = true;\n                this.segments[b1 * numPoints + a1] = true;\n              } else {\n                this.segments[c1 * numPoints + a1] = true;\n                this.segments[a1 * numPoints + c1] = true;\n              }\n            } else if (b1 === a2 || b1 === b2 || b1 === c2) {\n              this.segments[c1 * numPoints + b1] = true;\n              this.segments[b1 * numPoints + c1] = true;\n            }\n          }\n        }\n      }\n      var localPlane = this.tempPlane_Cut;\n      object.updateMatrix();\n      ConvexObjectBreaker.transformPlaneToLocalSpace(plane, object.matrix, localPlane);\n      for (var _i2 = 0; _i2 < numFaces; _i2++) {\n        var va = getVertexIndex(_i2, 0);\n        var vb = getVertexIndex(_i2, 1);\n        var vc = getVertexIndex(_i2, 2);\n        for (var segment = 0; segment < 3; segment++) {\n          var i0 = segment === 0 ? va : segment === 1 ? vb : vc;\n          var i1 = segment === 0 ? vb : segment === 1 ? vc : va;\n          var segmentState = this.segments[i0 * numPoints + i1];\n          if (segmentState) continue;\n          this.segments[i0 * numPoints + i1] = true;\n          this.segments[i1 * numPoints + i0] = true;\n          p0.set(coords[3 * i0], coords[3 * i0 + 1], coords[3 * i0 + 2]);\n          p1.set(coords[3 * i1], coords[3 * i1 + 1], coords[3 * i1 + 2]);\n          var mark0 = 0;\n          var d = localPlane.distanceToPoint(p0);\n          if (d > delta) {\n            mark0 = 2;\n            points2.push(p0.clone());\n          } else if (d < -delta) {\n            mark0 = 1;\n            points1.push(p0.clone());\n          } else {\n            mark0 = 3;\n            points1.push(p0.clone());\n            points2.push(p0.clone());\n          }\n          var mark1 = 0;\n          d = localPlane.distanceToPoint(p1);\n          if (d > delta) {\n            mark1 = 2;\n            points2.push(p1.clone());\n          } else if (d < -delta) {\n            mark1 = 1;\n            points1.push(p1.clone());\n          } else {\n            mark1 = 3;\n            points1.push(p1.clone());\n            points2.push(p1.clone());\n          }\n          if (mark0 === 1 && mark1 === 2 || mark0 === 2 && mark1 === 1) {\n            this.tempLine1.start.copy(p0);\n            this.tempLine1.end.copy(p1);\n            var intersection = new Vector3();\n            intersection = localPlane.intersectLine(this.tempLine1, intersection);\n            if (intersection === null) {\n              console.error(\"Internal error: segment does not intersect plane.\");\n              output.segmentedObject1 = null;\n              output.segmentedObject2 = null;\n              return 0;\n            }\n            points1.push(intersection);\n            points2.push(intersection.clone());\n          }\n        }\n      }\n      var newMass = object.userData.mass * 0.5;\n      this.tempCM1.set(0, 0, 0);\n      var radius1 = 0;\n      var numPoints1 = points1.length;\n      if (numPoints1 > 0) {\n        for (var _i3 = 0; _i3 < numPoints1; _i3++) this.tempCM1.add(points1[_i3]);\n        this.tempCM1.divideScalar(numPoints1);\n        for (var _i4 = 0; _i4 < numPoints1; _i4++) {\n          var p = points1[_i4];\n          p.sub(this.tempCM1);\n          radius1 = Math.max(radius1, p.x, p.y, p.z);\n        }\n        this.tempCM1.add(object.position);\n      }\n      this.tempCM2.set(0, 0, 0);\n      var radius2 = 0;\n      var numPoints2 = points2.length;\n      if (numPoints2 > 0) {\n        for (var _i5 = 0; _i5 < numPoints2; _i5++) this.tempCM2.add(points2[_i5]);\n        this.tempCM2.divideScalar(numPoints2);\n        for (var _i6 = 0; _i6 < numPoints2; _i6++) {\n          var _p = points2[_i6];\n          _p.sub(this.tempCM2);\n          radius2 = Math.max(radius2, _p.x, _p.y, _p.z);\n        }\n        this.tempCM2.add(object.position);\n      }\n      var object1 = null;\n      var object2 = null;\n      var numObjects = 0;\n      if (numPoints1 > 4) {\n        object1 = new Mesh(new ConvexGeometry(points1), object.material);\n        object1.position.copy(this.tempCM1);\n        object1.quaternion.copy(object.quaternion);\n        this.prepareBreakableObject(object1, newMass, object.userData.velocity, object.userData.angularVelocity, 2 * radius1 > this.minSizeForBreak);\n        numObjects++;\n      }\n      if (numPoints2 > 4) {\n        object2 = new Mesh(new ConvexGeometry(points2), object.material);\n        object2.position.copy(this.tempCM2);\n        object2.quaternion.copy(object.quaternion);\n        this.prepareBreakableObject(object2, newMass, object.userData.velocity, object.userData.angularVelocity, 2 * radius2 > this.minSizeForBreak);\n        numObjects++;\n      }\n      output.object1 = object1;\n      output.object2 = object2;\n      return numObjects;\n    }\n  }], [{\n    key: \"transformFreeVector\",\n    value: function transformFreeVector(v, m) {\n      var x = v.x,\n        y = v.y,\n        z = v.z;\n      var e = m.elements;\n      v.x = e[0] * x + e[4] * y + e[8] * z;\n      v.y = e[1] * x + e[5] * y + e[9] * z;\n      v.z = e[2] * x + e[6] * y + e[10] * z;\n      return v;\n    }\n  }, {\n    key: \"transformFreeVectorInverse\",\n    value: function transformFreeVectorInverse(v, m) {\n      var x = v.x,\n        y = v.y,\n        z = v.z;\n      var e = m.elements;\n      v.x = e[0] * x + e[1] * y + e[2] * z;\n      v.y = e[4] * x + e[5] * y + e[6] * z;\n      v.z = e[8] * x + e[9] * y + e[10] * z;\n      return v;\n    }\n  }, {\n    key: \"transformTiedVectorInverse\",\n    value: function transformTiedVectorInverse(v, m) {\n      var x = v.x,\n        y = v.y,\n        z = v.z;\n      var e = m.elements;\n      v.x = e[0] * x + e[1] * y + e[2] * z - e[12];\n      v.y = e[4] * x + e[5] * y + e[6] * z - e[13];\n      v.z = e[8] * x + e[9] * y + e[10] * z - e[14];\n      return v;\n    }\n  }, {\n    key: \"transformPlaneToLocalSpace\",\n    value: function transformPlaneToLocalSpace(plane, m, resultPlane) {\n      resultPlane.normal.copy(plane.normal);\n      resultPlane.constant = plane.constant;\n      var referencePoint = ConvexObjectBreaker.transformTiedVectorInverse(plane.coplanarPoint(_v1), m);\n      ConvexObjectBreaker.transformFreeVectorInverse(resultPlane.normal, m);\n      resultPlane.constant = -referencePoint.dot(resultPlane.normal);\n    }\n  }]);\n  return ConvexObjectBreaker;\n}();\nexport { ConvexObjectBreaker };","map":{"version":3,"names":["_v1","Vector3","ConvexObjectBreaker","minSizeForBreak","arguments","length","undefined","smallDelta","_classCallCheck","tempLine1","Line3","tempPlane1","Plane","tempPlane2","tempPlane_Cut","tempCM1","tempCM2","tempVector3","tempVector3_2","tempVector3_3","tempVector3_P0","tempVector3_P1","tempVector3_P2","tempVector3_N0","tempVector3_N1","tempVector3_AB","tempVector3_CB","tempResultObjects","object1","object2","segments","n","i","_createClass","key","value","prepareBreakableObject","object","mass","velocity","angularVelocity","breakable","userData","clone","subdivideByImpact","pointOfImpact","normal","maxRadialIterations","maxRandomIterations","debris","addVectors","setFromCoplanarPoints","position","maxTotalIterations","scope","subdivideRadial","subObject","startAngle","endAngle","numIterations","Math","random","push","angle","PI","copy","constant","sub","applyAxisAngle","add","cutByPlane","obj1","obj2","plane","output","geometry","coords","attributes","array","normals","numPoints","numFaces","indices","getIndex","getVertexIndex","faceIdx","vert","idx","points1","points2","delta","numPointPairs","p0","p1","n0","n1","a1","b1","c1","set","j","a2","b2","c2","coplanar","dot","localPlane","updateMatrix","transformPlaneToLocalSpace","matrix","va","vb","vc","segment","i0","i1","segmentState","mark0","d","distanceToPoint","mark1","start","end","intersection","intersectLine","console","error","segmentedObject1","segmentedObject2","newMass","radius1","numPoints1","divideScalar","p","max","x","y","z","radius2","numPoints2","numObjects","Mesh","ConvexGeometry","material","quaternion","transformFreeVector","v","m","e","elements","transformFreeVectorInverse","transformTiedVectorInverse","resultPlane","referencePoint","coplanarPoint"],"sources":["C:\\Users\\Nayyu\\Desktop\\skibidai-public-build\\node_modules\\src\\misc\\ConvexObjectBreaker.js"],"sourcesContent":["import { Line3, Mesh, Plane, Vector3 } from 'three'\nimport { ConvexGeometry } from '../geometries/ConvexGeometry'\n\n/**\n * @fileoverview This class can be used to subdivide a convex Geometry object into pieces.\n *\n * Usage:\n *\n * Use the function prepareBreakableObject to prepare a Mesh object to be broken.\n *\n * Then, call the various functions to subdivide the object (subdivideByImpact, cutByPlane)\n *\n * Sub-objects that are product of subdivision don't need prepareBreakableObject to be called on them.\n *\n * Requisites for the object:\n *\n *  - Mesh object must have a buffer geometry and a material\n *\n *  - Vertex normals must be planar (not smoothed)\n *\n *  - The geometry must be convex (this is not checked in the library). You can create convex\n *  geometries with ConvexGeometry. The BoxGeometry, SphereGeometry and other convex primitives\n *  can also be used.\n *\n * Note: This lib adds member variables to object's userData member (see prepareBreakableObject function)\n * Use with caution and read the code when using with other libs.\n *\n * @param {double} minSizeForBreak Min size a debris can have to break.\n * @param {double} smallDelta Max distance to consider that a point belongs to a plane.\n *\n */\n\nconst _v1 = new Vector3()\n\nclass ConvexObjectBreaker {\n  constructor(minSizeForBreak = 1.4, smallDelta = 0.0001) {\n    this.minSizeForBreak = minSizeForBreak\n    this.smallDelta = smallDelta\n\n    this.tempLine1 = new Line3()\n    this.tempPlane1 = new Plane()\n    this.tempPlane2 = new Plane()\n    this.tempPlane_Cut = new Plane()\n    this.tempCM1 = new Vector3()\n    this.tempCM2 = new Vector3()\n    this.tempVector3 = new Vector3()\n    this.tempVector3_2 = new Vector3()\n    this.tempVector3_3 = new Vector3()\n    this.tempVector3_P0 = new Vector3()\n    this.tempVector3_P1 = new Vector3()\n    this.tempVector3_P2 = new Vector3()\n    this.tempVector3_N0 = new Vector3()\n    this.tempVector3_N1 = new Vector3()\n    this.tempVector3_AB = new Vector3()\n    this.tempVector3_CB = new Vector3()\n    this.tempResultObjects = { object1: null, object2: null }\n\n    this.segments = []\n    const n = 30 * 30\n    for (let i = 0; i < n; i++) this.segments[i] = false\n  }\n\n  prepareBreakableObject(object, mass, velocity, angularVelocity, breakable) {\n    // object is a Object3d (normally a Mesh), must have a buffer geometry, and it must be convex.\n    // Its material property is propagated to its children (sub-pieces)\n    // mass must be > 0\n\n    const userData = object.userData\n    userData.mass = mass\n    userData.velocity = velocity.clone()\n    userData.angularVelocity = angularVelocity.clone()\n    userData.breakable = breakable\n  }\n\n  /*\n   * @param {int} maxRadialIterations Iterations for radial cuts.\n   * @param {int} maxRandomIterations Max random iterations for not-radial cuts\n   *\n   * Returns the array of pieces\n   */\n  subdivideByImpact(object, pointOfImpact, normal, maxRadialIterations, maxRandomIterations) {\n    const debris = []\n\n    const tempPlane1 = this.tempPlane1\n    const tempPlane2 = this.tempPlane2\n\n    this.tempVector3.addVectors(pointOfImpact, normal)\n    tempPlane1.setFromCoplanarPoints(pointOfImpact, object.position, this.tempVector3)\n\n    const maxTotalIterations = maxRandomIterations + maxRadialIterations\n\n    const scope = this\n\n    function subdivideRadial(subObject, startAngle, endAngle, numIterations) {\n      if (Math.random() < numIterations * 0.05 || numIterations > maxTotalIterations) {\n        debris.push(subObject)\n\n        return\n      }\n\n      let angle = Math.PI\n\n      if (numIterations === 0) {\n        tempPlane2.normal.copy(tempPlane1.normal)\n        tempPlane2.constant = tempPlane1.constant\n      } else {\n        if (numIterations <= maxRadialIterations) {\n          angle = (endAngle - startAngle) * (0.2 + 0.6 * Math.random()) + startAngle\n\n          // Rotate tempPlane2 at impact point around normal axis and the angle\n          scope.tempVector3_2.copy(object.position).sub(pointOfImpact).applyAxisAngle(normal, angle).add(pointOfImpact)\n          tempPlane2.setFromCoplanarPoints(pointOfImpact, scope.tempVector3, scope.tempVector3_2)\n        } else {\n          angle = (0.5 * (numIterations & 1) + 0.2 * (2 - Math.random())) * Math.PI\n\n          // Rotate tempPlane2 at object position around normal axis and the angle\n          scope.tempVector3_2\n            .copy(pointOfImpact)\n            .sub(subObject.position)\n            .applyAxisAngle(normal, angle)\n            .add(subObject.position)\n          scope.tempVector3_3.copy(normal).add(subObject.position)\n          tempPlane2.setFromCoplanarPoints(subObject.position, scope.tempVector3_3, scope.tempVector3_2)\n        }\n      }\n\n      // Perform the cut\n      scope.cutByPlane(subObject, tempPlane2, scope.tempResultObjects)\n\n      const obj1 = scope.tempResultObjects.object1\n      const obj2 = scope.tempResultObjects.object2\n\n      if (obj1) {\n        subdivideRadial(obj1, startAngle, angle, numIterations + 1)\n      }\n\n      if (obj2) {\n        subdivideRadial(obj2, angle, endAngle, numIterations + 1)\n      }\n    }\n\n    subdivideRadial(object, 0, 2 * Math.PI, 0)\n\n    return debris\n  }\n\n  cutByPlane(object, plane, output) {\n    // Returns breakable objects in output.object1 and output.object2 members, the resulting 2 pieces of the cut.\n    // object2 can be null if the plane doesn't cut the object.\n    // object1 can be null only in case of internal error\n    // Returned value is number of pieces, 0 for error.\n\n    const geometry = object.geometry\n    const coords = geometry.attributes.position.array\n    const normals = geometry.attributes.normal.array\n\n    const numPoints = coords.length / 3\n    let numFaces = numPoints / 3\n\n    let indices = geometry.getIndex()\n\n    if (indices) {\n      indices = indices.array\n      numFaces = indices.length / 3\n    }\n\n    function getVertexIndex(faceIdx, vert) {\n      // vert = 0, 1 or 2.\n\n      const idx = faceIdx * 3 + vert\n\n      return indices ? indices[idx] : idx\n    }\n\n    const points1 = []\n    const points2 = []\n\n    const delta = this.smallDelta\n\n    // Reset segments mark\n    const numPointPairs = numPoints * numPoints\n    for (let i = 0; i < numPointPairs; i++) this.segments[i] = false\n\n    const p0 = this.tempVector3_P0\n    const p1 = this.tempVector3_P1\n    const n0 = this.tempVector3_N0\n    const n1 = this.tempVector3_N1\n\n    // Iterate through the faces to mark edges shared by coplanar faces\n    for (let i = 0; i < numFaces - 1; i++) {\n      const a1 = getVertexIndex(i, 0)\n      const b1 = getVertexIndex(i, 1)\n      const c1 = getVertexIndex(i, 2)\n\n      // Assuming all 3 vertices have the same normal\n      n0.set(normals[a1], normals[a1] + 1, normals[a1] + 2)\n\n      for (let j = i + 1; j < numFaces; j++) {\n        const a2 = getVertexIndex(j, 0)\n        const b2 = getVertexIndex(j, 1)\n        const c2 = getVertexIndex(j, 2)\n\n        // Assuming all 3 vertices have the same normal\n        n1.set(normals[a2], normals[a2] + 1, normals[a2] + 2)\n\n        const coplanar = 1 - n0.dot(n1) < delta\n\n        if (coplanar) {\n          if (a1 === a2 || a1 === b2 || a1 === c2) {\n            if (b1 === a2 || b1 === b2 || b1 === c2) {\n              this.segments[a1 * numPoints + b1] = true\n              this.segments[b1 * numPoints + a1] = true\n            } else {\n              this.segments[c1 * numPoints + a1] = true\n              this.segments[a1 * numPoints + c1] = true\n            }\n          } else if (b1 === a2 || b1 === b2 || b1 === c2) {\n            this.segments[c1 * numPoints + b1] = true\n            this.segments[b1 * numPoints + c1] = true\n          }\n        }\n      }\n    }\n\n    // Transform the plane to object local space\n    const localPlane = this.tempPlane_Cut\n    object.updateMatrix()\n    ConvexObjectBreaker.transformPlaneToLocalSpace(plane, object.matrix, localPlane)\n\n    // Iterate through the faces adding points to both pieces\n    for (let i = 0; i < numFaces; i++) {\n      const va = getVertexIndex(i, 0)\n      const vb = getVertexIndex(i, 1)\n      const vc = getVertexIndex(i, 2)\n\n      for (let segment = 0; segment < 3; segment++) {\n        const i0 = segment === 0 ? va : segment === 1 ? vb : vc\n        const i1 = segment === 0 ? vb : segment === 1 ? vc : va\n\n        const segmentState = this.segments[i0 * numPoints + i1]\n\n        if (segmentState) continue // The segment already has been processed in another face\n\n        // Mark segment as processed (also inverted segment)\n        this.segments[i0 * numPoints + i1] = true\n        this.segments[i1 * numPoints + i0] = true\n\n        p0.set(coords[3 * i0], coords[3 * i0 + 1], coords[3 * i0 + 2])\n        p1.set(coords[3 * i1], coords[3 * i1 + 1], coords[3 * i1 + 2])\n\n        // mark: 1 for negative side, 2 for positive side, 3 for coplanar point\n        let mark0 = 0\n\n        let d = localPlane.distanceToPoint(p0)\n\n        if (d > delta) {\n          mark0 = 2\n          points2.push(p0.clone())\n        } else if (d < -delta) {\n          mark0 = 1\n          points1.push(p0.clone())\n        } else {\n          mark0 = 3\n          points1.push(p0.clone())\n          points2.push(p0.clone())\n        }\n\n        // mark: 1 for negative side, 2 for positive side, 3 for coplanar point\n        let mark1 = 0\n\n        d = localPlane.distanceToPoint(p1)\n\n        if (d > delta) {\n          mark1 = 2\n          points2.push(p1.clone())\n        } else if (d < -delta) {\n          mark1 = 1\n          points1.push(p1.clone())\n        } else {\n          mark1 = 3\n          points1.push(p1.clone())\n          points2.push(p1.clone())\n        }\n\n        if ((mark0 === 1 && mark1 === 2) || (mark0 === 2 && mark1 === 1)) {\n          // Intersection of segment with the plane\n\n          this.tempLine1.start.copy(p0)\n          this.tempLine1.end.copy(p1)\n\n          let intersection = new Vector3()\n          intersection = localPlane.intersectLine(this.tempLine1, intersection)\n\n          if (intersection === null) {\n            // Shouldn't happen\n            console.error('Internal error: segment does not intersect plane.')\n            output.segmentedObject1 = null\n            output.segmentedObject2 = null\n            return 0\n          }\n\n          points1.push(intersection)\n          points2.push(intersection.clone())\n        }\n      }\n    }\n\n    // Calculate debris mass (very fast and imprecise):\n    const newMass = object.userData.mass * 0.5\n\n    // Calculate debris Center of Mass (again fast and imprecise)\n    this.tempCM1.set(0, 0, 0)\n    let radius1 = 0\n    const numPoints1 = points1.length\n\n    if (numPoints1 > 0) {\n      for (let i = 0; i < numPoints1; i++) this.tempCM1.add(points1[i])\n\n      this.tempCM1.divideScalar(numPoints1)\n      for (let i = 0; i < numPoints1; i++) {\n        const p = points1[i]\n        p.sub(this.tempCM1)\n        radius1 = Math.max(radius1, p.x, p.y, p.z)\n      }\n\n      this.tempCM1.add(object.position)\n    }\n\n    this.tempCM2.set(0, 0, 0)\n    let radius2 = 0\n    const numPoints2 = points2.length\n    if (numPoints2 > 0) {\n      for (let i = 0; i < numPoints2; i++) this.tempCM2.add(points2[i])\n\n      this.tempCM2.divideScalar(numPoints2)\n      for (let i = 0; i < numPoints2; i++) {\n        const p = points2[i]\n        p.sub(this.tempCM2)\n        radius2 = Math.max(radius2, p.x, p.y, p.z)\n      }\n\n      this.tempCM2.add(object.position)\n    }\n\n    let object1 = null\n    let object2 = null\n\n    let numObjects = 0\n\n    if (numPoints1 > 4) {\n      object1 = new Mesh(new ConvexGeometry(points1), object.material)\n      object1.position.copy(this.tempCM1)\n      object1.quaternion.copy(object.quaternion)\n\n      this.prepareBreakableObject(\n        object1,\n        newMass,\n        object.userData.velocity,\n        object.userData.angularVelocity,\n        2 * radius1 > this.minSizeForBreak,\n      )\n\n      numObjects++\n    }\n\n    if (numPoints2 > 4) {\n      object2 = new Mesh(new ConvexGeometry(points2), object.material)\n      object2.position.copy(this.tempCM2)\n      object2.quaternion.copy(object.quaternion)\n\n      this.prepareBreakableObject(\n        object2,\n        newMass,\n        object.userData.velocity,\n        object.userData.angularVelocity,\n        2 * radius2 > this.minSizeForBreak,\n      )\n\n      numObjects++\n    }\n\n    output.object1 = object1\n    output.object2 = object2\n\n    return numObjects\n  }\n\n  static transformFreeVector(v, m) {\n    // input:\n    // vector interpreted as a free vector\n    // THREE.Matrix4 orthogonal matrix (matrix without scale)\n\n    const x = v.x,\n      y = v.y,\n      z = v.z\n    const e = m.elements\n\n    v.x = e[0] * x + e[4] * y + e[8] * z\n    v.y = e[1] * x + e[5] * y + e[9] * z\n    v.z = e[2] * x + e[6] * y + e[10] * z\n\n    return v\n  }\n\n  static transformFreeVectorInverse(v, m) {\n    // input:\n    // vector interpreted as a free vector\n    // THREE.Matrix4 orthogonal matrix (matrix without scale)\n\n    const x = v.x,\n      y = v.y,\n      z = v.z\n    const e = m.elements\n\n    v.x = e[0] * x + e[1] * y + e[2] * z\n    v.y = e[4] * x + e[5] * y + e[6] * z\n    v.z = e[8] * x + e[9] * y + e[10] * z\n\n    return v\n  }\n\n  static transformTiedVectorInverse(v, m) {\n    // input:\n    // vector interpreted as a tied (ordinary) vector\n    // THREE.Matrix4 orthogonal matrix (matrix without scale)\n\n    const x = v.x,\n      y = v.y,\n      z = v.z\n    const e = m.elements\n\n    v.x = e[0] * x + e[1] * y + e[2] * z - e[12]\n    v.y = e[4] * x + e[5] * y + e[6] * z - e[13]\n    v.z = e[8] * x + e[9] * y + e[10] * z - e[14]\n\n    return v\n  }\n\n  static transformPlaneToLocalSpace(plane, m, resultPlane) {\n    resultPlane.normal.copy(plane.normal)\n    resultPlane.constant = plane.constant\n\n    const referencePoint = ConvexObjectBreaker.transformTiedVectorInverse(plane.coplanarPoint(_v1), m)\n\n    ConvexObjectBreaker.transformFreeVectorInverse(resultPlane.normal, m)\n\n    // recalculate constant (like in setFromNormalAndCoplanarPoint)\n    resultPlane.constant = -referencePoint.dot(resultPlane.normal)\n  }\n}\n\nexport { ConvexObjectBreaker }\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}