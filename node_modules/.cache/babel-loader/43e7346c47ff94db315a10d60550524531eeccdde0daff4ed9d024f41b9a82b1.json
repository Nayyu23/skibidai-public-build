{"ast":null,"code":"import _classCallCheck from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _inherits from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport { Loader, LoaderUtils, FileLoader, Group, MeshPhongMaterial, DoubleSide, AdditiveBlending, BufferGeometry, Mesh, Float32BufferAttribute, Matrix4, TextureLoader, Color } from \"three\";\nvar TDSLoader = /*#__PURE__*/function (_Loader) {\n  _inherits(TDSLoader, _Loader);\n  var _super = _createSuper(TDSLoader);\n  function TDSLoader(manager) {\n    var _this;\n    _classCallCheck(this, TDSLoader);\n    _this = _super.call(this, manager);\n    _this.debug = false;\n    _this.group = null;\n    _this.position = 0;\n    _this.materials = [];\n    _this.meshes = [];\n    return _this;\n  }\n  /**\n   * Load 3ds file from url.\n   *\n   * @method load\n   * @param {[type]} url URL for the file.\n   * @param {Function} onLoad onLoad callback, receives group Object3D as argument.\n   * @param {Function} onProgress onProgress callback.\n   * @param {Function} onError onError callback.\n   */\n  _createClass(TDSLoader, [{\n    key: \"load\",\n    value: function load(url, onLoad, onProgress, onError) {\n      var scope = this;\n      var path = this.path === \"\" ? LoaderUtils.extractUrlBase(url) : this.path;\n      var loader = new FileLoader(this.manager);\n      loader.setPath(this.path);\n      loader.setResponseType(\"arraybuffer\");\n      loader.setRequestHeader(this.requestHeader);\n      loader.setWithCredentials(this.withCredentials);\n      loader.load(url, function (data) {\n        try {\n          onLoad(scope.parse(data, path));\n        } catch (e) {\n          if (onError) {\n            onError(e);\n          } else {\n            console.error(e);\n          }\n          scope.manager.itemError(url);\n        }\n      }, onProgress, onError);\n    }\n    /**\n     * Parse arraybuffer data and load 3ds file.\n     *\n     * @method parse\n     * @param {ArrayBuffer} arraybuffer Arraybuffer data to be loaded.\n     * @param {String} path Path for external resources.\n     * @return {Group} Group loaded from 3ds file.\n     */\n  }, {\n    key: \"parse\",\n    value: function parse(arraybuffer, path) {\n      this.group = new Group();\n      this.position = 0;\n      this.materials = [];\n      this.meshes = [];\n      this.readFile(arraybuffer, path);\n      for (var i = 0; i < this.meshes.length; i++) {\n        this.group.add(this.meshes[i]);\n      }\n      return this.group;\n    }\n    /**\n     * Decode file content to read 3ds data.\n     *\n     * @method readFile\n     * @param {ArrayBuffer} arraybuffer Arraybuffer data to be loaded.\n     * @param {String} path Path for external resources.\n     */\n  }, {\n    key: \"readFile\",\n    value: function readFile(arraybuffer, path) {\n      var data = new DataView(arraybuffer);\n      var chunk = this.readChunk(data);\n      if (chunk.id === MLIBMAGIC || chunk.id === CMAGIC || chunk.id === M3DMAGIC) {\n        var next = this.nextChunk(data, chunk);\n        while (next !== 0) {\n          if (next === M3D_VERSION) {\n            var version = this.readDWord(data);\n            this.debugMessage(\"3DS file version: \" + version);\n          } else if (next === MDATA) {\n            this.resetPosition(data);\n            this.readMeshData(data, path);\n          } else {\n            this.debugMessage(\"Unknown main chunk: \" + next.toString(16));\n          }\n          next = this.nextChunk(data, chunk);\n        }\n      }\n      this.debugMessage(\"Parsed \" + this.meshes.length + \" meshes\");\n    }\n    /**\n     * Read mesh data chunk.\n     *\n     * @method readMeshData\n     * @param {Dataview} data Dataview in use.\n     * @param {String} path Path for external resources.\n     */\n  }, {\n    key: \"readMeshData\",\n    value: function readMeshData(data, path) {\n      var chunk = this.readChunk(data);\n      var next = this.nextChunk(data, chunk);\n      while (next !== 0) {\n        if (next === MESH_VERSION) {\n          var version = +this.readDWord(data);\n          this.debugMessage(\"Mesh Version: \" + version);\n        } else if (next === MASTER_SCALE) {\n          var scale = this.readFloat(data);\n          this.debugMessage(\"Master scale: \" + scale);\n          this.group.scale.set(scale, scale, scale);\n        } else if (next === NAMED_OBJECT) {\n          this.debugMessage(\"Named Object\");\n          this.resetPosition(data);\n          this.readNamedObject(data);\n        } else if (next === MAT_ENTRY) {\n          this.debugMessage(\"Material\");\n          this.resetPosition(data);\n          this.readMaterialEntry(data, path);\n        } else {\n          this.debugMessage(\"Unknown MDATA chunk: \" + next.toString(16));\n        }\n        next = this.nextChunk(data, chunk);\n      }\n    }\n    /**\n     * Read named object chunk.\n     *\n     * @method readNamedObject\n     * @param {Dataview} data Dataview in use.\n     */\n  }, {\n    key: \"readNamedObject\",\n    value: function readNamedObject(data) {\n      var chunk = this.readChunk(data);\n      var name = this.readString(data, 64);\n      chunk.cur = this.position;\n      var next = this.nextChunk(data, chunk);\n      while (next !== 0) {\n        if (next === N_TRI_OBJECT) {\n          this.resetPosition(data);\n          var mesh = this.readMesh(data);\n          mesh.name = name;\n          this.meshes.push(mesh);\n        } else {\n          this.debugMessage(\"Unknown named object chunk: \" + next.toString(16));\n        }\n        next = this.nextChunk(data, chunk);\n      }\n      this.endChunk(chunk);\n    }\n    /**\n     * Read material data chunk and add it to the material list.\n     *\n     * @method readMaterialEntry\n     * @param {Dataview} data Dataview in use.\n     * @param {String} path Path for external resources.\n     */\n  }, {\n    key: \"readMaterialEntry\",\n    value: function readMaterialEntry(data, path) {\n      var chunk = this.readChunk(data);\n      var next = this.nextChunk(data, chunk);\n      var material = new MeshPhongMaterial();\n      while (next !== 0) {\n        if (next === MAT_NAME) {\n          material.name = this.readString(data, 64);\n          this.debugMessage(\"   Name: \" + material.name);\n        } else if (next === MAT_WIRE) {\n          this.debugMessage(\"   Wireframe\");\n          material.wireframe = true;\n        } else if (next === MAT_WIRE_SIZE) {\n          var value = this.readByte(data);\n          material.wireframeLinewidth = value;\n          this.debugMessage(\"   Wireframe Thickness: \" + value);\n        } else if (next === MAT_TWO_SIDE) {\n          material.side = DoubleSide;\n          this.debugMessage(\"   DoubleSided\");\n        } else if (next === MAT_ADDITIVE) {\n          this.debugMessage(\"   Additive Blending\");\n          material.blending = AdditiveBlending;\n        } else if (next === MAT_DIFFUSE) {\n          this.debugMessage(\"   Diffuse Color\");\n          material.color = this.readColor(data);\n        } else if (next === MAT_SPECULAR) {\n          this.debugMessage(\"   Specular Color\");\n          material.specular = this.readColor(data);\n        } else if (next === MAT_AMBIENT) {\n          this.debugMessage(\"   Ambient color\");\n          material.color = this.readColor(data);\n        } else if (next === MAT_SHININESS) {\n          var shininess = this.readPercentage(data);\n          material.shininess = shininess * 100;\n          this.debugMessage(\"   Shininess : \" + shininess);\n        } else if (next === MAT_TRANSPARENCY) {\n          var transparency = this.readPercentage(data);\n          material.opacity = 1 - transparency;\n          this.debugMessage(\"  Transparency : \" + transparency);\n          material.transparent = material.opacity < 1 ? true : false;\n        } else if (next === MAT_TEXMAP) {\n          this.debugMessage(\"   ColorMap\");\n          this.resetPosition(data);\n          material.map = this.readMap(data, path);\n        } else if (next === MAT_BUMPMAP) {\n          this.debugMessage(\"   BumpMap\");\n          this.resetPosition(data);\n          material.bumpMap = this.readMap(data, path);\n        } else if (next === MAT_OPACMAP) {\n          this.debugMessage(\"   OpacityMap\");\n          this.resetPosition(data);\n          material.alphaMap = this.readMap(data, path);\n        } else if (next === MAT_SPECMAP) {\n          this.debugMessage(\"   SpecularMap\");\n          this.resetPosition(data);\n          material.specularMap = this.readMap(data, path);\n        } else {\n          this.debugMessage(\"   Unknown material chunk: \" + next.toString(16));\n        }\n        next = this.nextChunk(data, chunk);\n      }\n      this.endChunk(chunk);\n      this.materials[material.name] = material;\n    }\n    /**\n     * Read mesh data chunk.\n     *\n     * @method readMesh\n     * @param {Dataview} data Dataview in use.\n     * @return {Mesh} The parsed mesh.\n     */\n  }, {\n    key: \"readMesh\",\n    value: function readMesh(data) {\n      var chunk = this.readChunk(data);\n      var next = this.nextChunk(data, chunk);\n      var geometry = new BufferGeometry();\n      var material = new MeshPhongMaterial();\n      var mesh = new Mesh(geometry, material);\n      mesh.name = \"mesh\";\n      while (next !== 0) {\n        if (next === POINT_ARRAY) {\n          var points = this.readWord(data);\n          this.debugMessage(\"   Vertex: \" + points);\n          var vertices = [];\n          for (var i = 0; i < points; i++) {\n            vertices.push(this.readFloat(data));\n            vertices.push(this.readFloat(data));\n            vertices.push(this.readFloat(data));\n          }\n          geometry.setAttribute(\"position\", new Float32BufferAttribute(vertices, 3));\n        } else if (next === FACE_ARRAY) {\n          this.resetPosition(data);\n          this.readFaceArray(data, mesh);\n        } else if (next === TEX_VERTS) {\n          var texels = this.readWord(data);\n          this.debugMessage(\"   UV: \" + texels);\n          var uvs = [];\n          for (var _i = 0; _i < texels; _i++) {\n            uvs.push(this.readFloat(data));\n            uvs.push(this.readFloat(data));\n          }\n          geometry.setAttribute(\"uv\", new Float32BufferAttribute(uvs, 2));\n        } else if (next === MESH_MATRIX) {\n          this.debugMessage(\"   Tranformation Matrix (TODO)\");\n          var values = [];\n          for (var _i2 = 0; _i2 < 12; _i2++) {\n            values[_i2] = this.readFloat(data);\n          }\n          var matrix = new Matrix4();\n          matrix.elements[0] = values[0];\n          matrix.elements[1] = values[6];\n          matrix.elements[2] = values[3];\n          matrix.elements[3] = values[9];\n          matrix.elements[4] = values[2];\n          matrix.elements[5] = values[8];\n          matrix.elements[6] = values[5];\n          matrix.elements[7] = values[11];\n          matrix.elements[8] = values[1];\n          matrix.elements[9] = values[7];\n          matrix.elements[10] = values[4];\n          matrix.elements[11] = values[10];\n          matrix.elements[12] = 0;\n          matrix.elements[13] = 0;\n          matrix.elements[14] = 0;\n          matrix.elements[15] = 1;\n          matrix.transpose();\n          var inverse = new Matrix4();\n          inverse.copy(matrix).invert();\n          geometry.applyMatrix4(inverse);\n          matrix.decompose(mesh.position, mesh.quaternion, mesh.scale);\n        } else {\n          this.debugMessage(\"   Unknown mesh chunk: \" + next.toString(16));\n        }\n        next = this.nextChunk(data, chunk);\n      }\n      this.endChunk(chunk);\n      geometry.computeVertexNormals();\n      return mesh;\n    }\n    /**\n     * Read face array data chunk.\n     *\n     * @method readFaceArray\n     * @param {Dataview} data Dataview in use.\n     * @param {Mesh} mesh Mesh to be filled with the data read.\n     */\n  }, {\n    key: \"readFaceArray\",\n    value: function readFaceArray(data, mesh) {\n      var chunk = this.readChunk(data);\n      var faces = this.readWord(data);\n      this.debugMessage(\"   Faces: \" + faces);\n      var index = [];\n      for (var i = 0; i < faces; ++i) {\n        index.push(this.readWord(data), this.readWord(data), this.readWord(data));\n        this.readWord(data);\n      }\n      mesh.geometry.setIndex(index);\n      var materialIndex = 0;\n      var start = 0;\n      while (this.position < chunk.end) {\n        var subchunk = this.readChunk(data);\n        if (subchunk.id === MSH_MAT_GROUP) {\n          this.debugMessage(\"      Material Group\");\n          this.resetPosition(data);\n          var group = this.readMaterialGroup(data);\n          var count = group.index.length * 3;\n          mesh.geometry.addGroup(start, count, materialIndex);\n          start += count;\n          materialIndex++;\n          var material = this.materials[group.name];\n          if (Array.isArray(mesh.material) === false) mesh.material = [];\n          if (material !== void 0) {\n            mesh.material.push(material);\n          }\n        } else {\n          this.debugMessage(\"      Unknown face array chunk: \" + subchunk.toString(16));\n        }\n        this.endChunk(subchunk);\n      }\n      if (mesh.material.length === 1) mesh.material = mesh.material[0];\n      this.endChunk(chunk);\n    }\n    /**\n     * Read texture map data chunk.\n     *\n     * @method readMap\n     * @param {Dataview} data Dataview in use.\n     * @param {String} path Path for external resources.\n     * @return {Texture} Texture read from this data chunk.\n     */\n  }, {\n    key: \"readMap\",\n    value: function readMap(data, path) {\n      var chunk = this.readChunk(data);\n      var next = this.nextChunk(data, chunk);\n      var texture = {};\n      var loader = new TextureLoader(this.manager);\n      loader.setPath(this.resourcePath || path).setCrossOrigin(this.crossOrigin);\n      while (next !== 0) {\n        if (next === MAT_MAPNAME) {\n          var name = this.readString(data, 128);\n          texture = loader.load(name);\n          this.debugMessage(\"      File: \" + path + name);\n        } else if (next === MAT_MAP_UOFFSET) {\n          texture.offset.x = this.readFloat(data);\n          this.debugMessage(\"      OffsetX: \" + texture.offset.x);\n        } else if (next === MAT_MAP_VOFFSET) {\n          texture.offset.y = this.readFloat(data);\n          this.debugMessage(\"      OffsetY: \" + texture.offset.y);\n        } else if (next === MAT_MAP_USCALE) {\n          texture.repeat.x = this.readFloat(data);\n          this.debugMessage(\"      RepeatX: \" + texture.repeat.x);\n        } else if (next === MAT_MAP_VSCALE) {\n          texture.repeat.y = this.readFloat(data);\n          this.debugMessage(\"      RepeatY: \" + texture.repeat.y);\n        } else {\n          this.debugMessage(\"      Unknown map chunk: \" + next.toString(16));\n        }\n        next = this.nextChunk(data, chunk);\n      }\n      this.endChunk(chunk);\n      return texture;\n    }\n    /**\n     * Read material group data chunk.\n     *\n     * @method readMaterialGroup\n     * @param {Dataview} data Dataview in use.\n     * @return {Object} Object with name and index of the object.\n     */\n  }, {\n    key: \"readMaterialGroup\",\n    value: function readMaterialGroup(data) {\n      this.readChunk(data);\n      var name = this.readString(data, 64);\n      var numFaces = this.readWord(data);\n      this.debugMessage(\"         Name: \" + name);\n      this.debugMessage(\"         Faces: \" + numFaces);\n      var index = [];\n      for (var i = 0; i < numFaces; ++i) {\n        index.push(this.readWord(data));\n      }\n      return {\n        name: name,\n        index: index\n      };\n    }\n    /**\n     * Read a color value.\n     *\n     * @method readColor\n     * @param {DataView} data Dataview.\n     * @return {Color} Color value read..\n     */\n  }, {\n    key: \"readColor\",\n    value: function readColor(data) {\n      var chunk = this.readChunk(data);\n      var color = new Color();\n      if (chunk.id === COLOR_24 || chunk.id === LIN_COLOR_24) {\n        var r = this.readByte(data);\n        var g = this.readByte(data);\n        var b = this.readByte(data);\n        color.setRGB(r / 255, g / 255, b / 255);\n        this.debugMessage(\"      Color: \" + color.r + \", \" + color.g + \", \" + color.b);\n      } else if (chunk.id === COLOR_F || chunk.id === LIN_COLOR_F) {\n        var _r = this.readFloat(data);\n        var _g = this.readFloat(data);\n        var _b = this.readFloat(data);\n        color.setRGB(_r, _g, _b);\n        this.debugMessage(\"      Color: \" + color.r + \", \" + color.g + \", \" + color.b);\n      } else {\n        this.debugMessage(\"      Unknown color chunk: \" + chunk.toString(16));\n      }\n      this.endChunk(chunk);\n      return color;\n    }\n    /**\n     * Read next chunk of data.\n     *\n     * @method readChunk\n     * @param {DataView} data Dataview.\n     * @return {Object} Chunk of data read.\n     */\n  }, {\n    key: \"readChunk\",\n    value: function readChunk(data) {\n      var chunk = {};\n      chunk.cur = this.position;\n      chunk.id = this.readWord(data);\n      chunk.size = this.readDWord(data);\n      chunk.end = chunk.cur + chunk.size;\n      chunk.cur += 6;\n      return chunk;\n    }\n    /**\n     * Set position to the end of the current chunk of data.\n     *\n     * @method endChunk\n     * @param {Object} chunk Data chunk.\n     */\n  }, {\n    key: \"endChunk\",\n    value: function endChunk(chunk) {\n      this.position = chunk.end;\n    }\n    /**\n     * Move to the next data chunk.\n     *\n     * @method nextChunk\n     * @param {DataView} data Dataview.\n     * @param {Object} chunk Data chunk.\n     */\n  }, {\n    key: \"nextChunk\",\n    value: function nextChunk(data, chunk) {\n      if (chunk.cur >= chunk.end) {\n        return 0;\n      }\n      this.position = chunk.cur;\n      try {\n        var next = this.readChunk(data);\n        chunk.cur += next.size;\n        return next.id;\n      } catch (e) {\n        this.debugMessage(\"Unable to read chunk at \" + this.position);\n        return 0;\n      }\n    }\n    /**\n     * Reset dataview position.\n     *\n     * @method resetPosition\n     */\n  }, {\n    key: \"resetPosition\",\n    value: function resetPosition() {\n      this.position -= 6;\n    }\n    /**\n     * Read byte value.\n     *\n     * @method readByte\n     * @param {DataView} data Dataview to read data from.\n     * @return {Number} Data read from the dataview.\n     */\n  }, {\n    key: \"readByte\",\n    value: function readByte(data) {\n      var v = data.getUint8(this.position, true);\n      this.position += 1;\n      return v;\n    }\n    /**\n     * Read 32 bit float value.\n     *\n     * @method readFloat\n     * @param {DataView} data Dataview to read data from.\n     * @return {Number} Data read from the dataview.\n     */\n  }, {\n    key: \"readFloat\",\n    value: function readFloat(data) {\n      try {\n        var v = data.getFloat32(this.position, true);\n        this.position += 4;\n        return v;\n      } catch (e) {\n        this.debugMessage(e + \" \" + this.position + \" \" + data.byteLength);\n      }\n    }\n    /**\n     * Read 32 bit signed integer value.\n     *\n     * @method readInt\n     * @param {DataView} data Dataview to read data from.\n     * @return {Number} Data read from the dataview.\n     */\n  }, {\n    key: \"readInt\",\n    value: function readInt(data) {\n      var v = data.getInt32(this.position, true);\n      this.position += 4;\n      return v;\n    }\n    /**\n     * Read 16 bit signed integer value.\n     *\n     * @method readShort\n     * @param {DataView} data Dataview to read data from.\n     * @return {Number} Data read from the dataview.\n     */\n  }, {\n    key: \"readShort\",\n    value: function readShort(data) {\n      var v = data.getInt16(this.position, true);\n      this.position += 2;\n      return v;\n    }\n    /**\n     * Read 64 bit unsigned integer value.\n     *\n     * @method readDWord\n     * @param {DataView} data Dataview to read data from.\n     * @return {Number} Data read from the dataview.\n     */\n  }, {\n    key: \"readDWord\",\n    value: function readDWord(data) {\n      var v = data.getUint32(this.position, true);\n      this.position += 4;\n      return v;\n    }\n    /**\n     * Read 32 bit unsigned integer value.\n     *\n     * @method readWord\n     * @param {DataView} data Dataview to read data from.\n     * @return {Number} Data read from the dataview.\n     */\n  }, {\n    key: \"readWord\",\n    value: function readWord(data) {\n      var v = data.getUint16(this.position, true);\n      this.position += 2;\n      return v;\n    }\n    /**\n     * Read string value.\n     *\n     * @method readString\n     * @param {DataView} data Dataview to read data from.\n     * @param {Number} maxLength Max size of the string to be read.\n     * @return {String} Data read from the dataview.\n     */\n  }, {\n    key: \"readString\",\n    value: function readString(data, maxLength) {\n      var s = \"\";\n      for (var i = 0; i < maxLength; i++) {\n        var c = this.readByte(data);\n        if (!c) {\n          break;\n        }\n        s += String.fromCharCode(c);\n      }\n      return s;\n    }\n    /**\n     * Read percentage value.\n     *\n     * @method readPercentage\n     * @param {DataView} data Dataview to read data from.\n     * @return {Number} Data read from the dataview.\n     */\n  }, {\n    key: \"readPercentage\",\n    value: function readPercentage(data) {\n      var chunk = this.readChunk(data);\n      var value;\n      switch (chunk.id) {\n        case INT_PERCENTAGE:\n          value = this.readShort(data) / 100;\n          break;\n        case FLOAT_PERCENTAGE:\n          value = this.readFloat(data);\n          break;\n        default:\n          this.debugMessage(\"      Unknown percentage chunk: \" + chunk.toString(16));\n      }\n      this.endChunk(chunk);\n      return value;\n    }\n    /**\n     * Print debug message to the console.\n     *\n     * Is controlled by a flag to show or hide debug messages.\n     *\n     * @method debugMessage\n     * @param {Object} message Debug message to print to the console.\n     */\n  }, {\n    key: \"debugMessage\",\n    value: function debugMessage(message) {\n      if (this.debug) {\n        console.log(message);\n      }\n    }\n  }]);\n  return TDSLoader;\n}(Loader);\nvar M3DMAGIC = 19789;\nvar MLIBMAGIC = 15786;\nvar CMAGIC = 49725;\nvar M3D_VERSION = 2;\nvar COLOR_F = 16;\nvar COLOR_24 = 17;\nvar LIN_COLOR_24 = 18;\nvar LIN_COLOR_F = 19;\nvar INT_PERCENTAGE = 48;\nvar FLOAT_PERCENTAGE = 49;\nvar MDATA = 15677;\nvar MESH_VERSION = 15678;\nvar MASTER_SCALE = 256;\nvar MAT_ENTRY = 45055;\nvar MAT_NAME = 40960;\nvar MAT_AMBIENT = 40976;\nvar MAT_DIFFUSE = 40992;\nvar MAT_SPECULAR = 41008;\nvar MAT_SHININESS = 41024;\nvar MAT_TRANSPARENCY = 41040;\nvar MAT_TWO_SIDE = 41089;\nvar MAT_ADDITIVE = 41091;\nvar MAT_WIRE = 41093;\nvar MAT_WIRE_SIZE = 41095;\nvar MAT_TEXMAP = 41472;\nvar MAT_OPACMAP = 41488;\nvar MAT_BUMPMAP = 41520;\nvar MAT_SPECMAP = 41476;\nvar MAT_MAPNAME = 41728;\nvar MAT_MAP_USCALE = 41812;\nvar MAT_MAP_VSCALE = 41814;\nvar MAT_MAP_UOFFSET = 41816;\nvar MAT_MAP_VOFFSET = 41818;\nvar NAMED_OBJECT = 16384;\nvar N_TRI_OBJECT = 16640;\nvar POINT_ARRAY = 16656;\nvar FACE_ARRAY = 16672;\nvar MSH_MAT_GROUP = 16688;\nvar TEX_VERTS = 16704;\nvar MESH_MATRIX = 16736;\nexport { TDSLoader };","map":{"version":3,"names":["TDSLoader","_Loader","_inherits","_super","_createSuper","manager","_this","_classCallCheck","call","debug","group","position","materials","meshes","_createClass","key","value","load","url","onLoad","onProgress","onError","scope","path","LoaderUtils","extractUrlBase","loader","FileLoader","setPath","setResponseType","setRequestHeader","requestHeader","setWithCredentials","withCredentials","data","parse","e","console","error","itemError","arraybuffer","Group","readFile","i","length","add","DataView","chunk","readChunk","id","MLIBMAGIC","CMAGIC","M3DMAGIC","next","nextChunk","M3D_VERSION","version","readDWord","debugMessage","MDATA","resetPosition","readMeshData","toString","MESH_VERSION","MASTER_SCALE","scale","readFloat","set","NAMED_OBJECT","readNamedObject","MAT_ENTRY","readMaterialEntry","name","readString","cur","N_TRI_OBJECT","mesh","readMesh","push","endChunk","material","MeshPhongMaterial","MAT_NAME","MAT_WIRE","wireframe","MAT_WIRE_SIZE","readByte","wireframeLinewidth","MAT_TWO_SIDE","side","DoubleSide","MAT_ADDITIVE","blending","AdditiveBlending","MAT_DIFFUSE","color","readColor","MAT_SPECULAR","specular","MAT_AMBIENT","MAT_SHININESS","shininess","readPercentage","MAT_TRANSPARENCY","transparency","opacity","transparent","MAT_TEXMAP","map","readMap","MAT_BUMPMAP","bumpMap","MAT_OPACMAP","alphaMap","MAT_SPECMAP","specularMap","geometry","BufferGeometry","Mesh","POINT_ARRAY","points","readWord","vertices","setAttribute","Float32BufferAttribute","FACE_ARRAY","readFaceArray","TEX_VERTS","texels","uvs","MESH_MATRIX","values","matrix","Matrix4","elements","transpose","inverse","copy","invert","applyMatrix4","decompose","quaternion","computeVertexNormals","faces","index","setIndex","materialIndex","start","end","subchunk","MSH_MAT_GROUP","readMaterialGroup","count","addGroup","Array","isArray","texture","TextureLoader","resourcePath","setCrossOrigin","crossOrigin","MAT_MAPNAME","MAT_MAP_UOFFSET","offset","x","MAT_MAP_VOFFSET","y","MAT_MAP_USCALE","repeat","MAT_MAP_VSCALE","numFaces","Color","COLOR_24","LIN_COLOR_24","r","g","b","setRGB","COLOR_F","LIN_COLOR_F","size","v","getUint8","getFloat32","byteLength","readInt","getInt32","readShort","getInt16","getUint32","getUint16","maxLength","s","c","String","fromCharCode","INT_PERCENTAGE","FLOAT_PERCENTAGE","message","log","Loader"],"sources":["C:\\Users\\Nayyu\\Desktop\\skibidai-public-build\\node_modules\\src\\loaders\\TDSLoader.js"],"sourcesContent":["import {\n  AdditiveBlending,\n  BufferGeometry,\n  Color,\n  DoubleSide,\n  FileLoader,\n  Float32BufferAttribute,\n  Group,\n  Loader,\n  LoaderUtils,\n  Matrix4,\n  Mesh,\n  MeshPhongMaterial,\n  TextureLoader,\n} from 'three'\n\n/**\n * Autodesk 3DS three.js file loader, based on lib3ds.\n *\n * Loads geometry with uv and materials basic properties with texture support.\n *\n * @class TDSLoader\n * @constructor\n */\n\nclass TDSLoader extends Loader {\n  constructor(manager) {\n    super(manager)\n\n    this.debug = false\n\n    this.group = null\n    this.position = 0\n\n    this.materials = []\n    this.meshes = []\n  }\n\n  /**\n   * Load 3ds file from url.\n   *\n   * @method load\n   * @param {[type]} url URL for the file.\n   * @param {Function} onLoad onLoad callback, receives group Object3D as argument.\n   * @param {Function} onProgress onProgress callback.\n   * @param {Function} onError onError callback.\n   */\n  load(url, onLoad, onProgress, onError) {\n    const scope = this\n\n    const path = this.path === '' ? LoaderUtils.extractUrlBase(url) : this.path\n\n    const loader = new FileLoader(this.manager)\n    loader.setPath(this.path)\n    loader.setResponseType('arraybuffer')\n    loader.setRequestHeader(this.requestHeader)\n    loader.setWithCredentials(this.withCredentials)\n\n    loader.load(\n      url,\n      function (data) {\n        try {\n          onLoad(scope.parse(data, path))\n        } catch (e) {\n          if (onError) {\n            onError(e)\n          } else {\n            console.error(e)\n          }\n\n          scope.manager.itemError(url)\n        }\n      },\n      onProgress,\n      onError,\n    )\n  }\n\n  /**\n   * Parse arraybuffer data and load 3ds file.\n   *\n   * @method parse\n   * @param {ArrayBuffer} arraybuffer Arraybuffer data to be loaded.\n   * @param {String} path Path for external resources.\n   * @return {Group} Group loaded from 3ds file.\n   */\n  parse(arraybuffer, path) {\n    this.group = new Group()\n    this.position = 0\n    this.materials = []\n    this.meshes = []\n\n    this.readFile(arraybuffer, path)\n\n    for (let i = 0; i < this.meshes.length; i++) {\n      this.group.add(this.meshes[i])\n    }\n\n    return this.group\n  }\n\n  /**\n   * Decode file content to read 3ds data.\n   *\n   * @method readFile\n   * @param {ArrayBuffer} arraybuffer Arraybuffer data to be loaded.\n   * @param {String} path Path for external resources.\n   */\n  readFile(arraybuffer, path) {\n    const data = new DataView(arraybuffer)\n    const chunk = this.readChunk(data)\n\n    if (chunk.id === MLIBMAGIC || chunk.id === CMAGIC || chunk.id === M3DMAGIC) {\n      let next = this.nextChunk(data, chunk)\n\n      while (next !== 0) {\n        if (next === M3D_VERSION) {\n          const version = this.readDWord(data)\n          this.debugMessage('3DS file version: ' + version)\n        } else if (next === MDATA) {\n          this.resetPosition(data)\n          this.readMeshData(data, path)\n        } else {\n          this.debugMessage('Unknown main chunk: ' + next.toString(16))\n        }\n\n        next = this.nextChunk(data, chunk)\n      }\n    }\n\n    this.debugMessage('Parsed ' + this.meshes.length + ' meshes')\n  }\n\n  /**\n   * Read mesh data chunk.\n   *\n   * @method readMeshData\n   * @param {Dataview} data Dataview in use.\n   * @param {String} path Path for external resources.\n   */\n  readMeshData(data, path) {\n    const chunk = this.readChunk(data)\n    let next = this.nextChunk(data, chunk)\n\n    while (next !== 0) {\n      if (next === MESH_VERSION) {\n        const version = +this.readDWord(data)\n        this.debugMessage('Mesh Version: ' + version)\n      } else if (next === MASTER_SCALE) {\n        const scale = this.readFloat(data)\n        this.debugMessage('Master scale: ' + scale)\n        this.group.scale.set(scale, scale, scale)\n      } else if (next === NAMED_OBJECT) {\n        this.debugMessage('Named Object')\n        this.resetPosition(data)\n        this.readNamedObject(data)\n      } else if (next === MAT_ENTRY) {\n        this.debugMessage('Material')\n        this.resetPosition(data)\n        this.readMaterialEntry(data, path)\n      } else {\n        this.debugMessage('Unknown MDATA chunk: ' + next.toString(16))\n      }\n\n      next = this.nextChunk(data, chunk)\n    }\n  }\n\n  /**\n   * Read named object chunk.\n   *\n   * @method readNamedObject\n   * @param {Dataview} data Dataview in use.\n   */\n  readNamedObject(data) {\n    const chunk = this.readChunk(data)\n    const name = this.readString(data, 64)\n    chunk.cur = this.position\n\n    let next = this.nextChunk(data, chunk)\n    while (next !== 0) {\n      if (next === N_TRI_OBJECT) {\n        this.resetPosition(data)\n        const mesh = this.readMesh(data)\n        mesh.name = name\n        this.meshes.push(mesh)\n      } else {\n        this.debugMessage('Unknown named object chunk: ' + next.toString(16))\n      }\n\n      next = this.nextChunk(data, chunk)\n    }\n\n    this.endChunk(chunk)\n  }\n\n  /**\n   * Read material data chunk and add it to the material list.\n   *\n   * @method readMaterialEntry\n   * @param {Dataview} data Dataview in use.\n   * @param {String} path Path for external resources.\n   */\n  readMaterialEntry(data, path) {\n    const chunk = this.readChunk(data)\n    let next = this.nextChunk(data, chunk)\n    const material = new MeshPhongMaterial()\n\n    while (next !== 0) {\n      if (next === MAT_NAME) {\n        material.name = this.readString(data, 64)\n        this.debugMessage('   Name: ' + material.name)\n      } else if (next === MAT_WIRE) {\n        this.debugMessage('   Wireframe')\n        material.wireframe = true\n      } else if (next === MAT_WIRE_SIZE) {\n        const value = this.readByte(data)\n        material.wireframeLinewidth = value\n        this.debugMessage('   Wireframe Thickness: ' + value)\n      } else if (next === MAT_TWO_SIDE) {\n        material.side = DoubleSide\n        this.debugMessage('   DoubleSided')\n      } else if (next === MAT_ADDITIVE) {\n        this.debugMessage('   Additive Blending')\n        material.blending = AdditiveBlending\n      } else if (next === MAT_DIFFUSE) {\n        this.debugMessage('   Diffuse Color')\n        material.color = this.readColor(data)\n      } else if (next === MAT_SPECULAR) {\n        this.debugMessage('   Specular Color')\n        material.specular = this.readColor(data)\n      } else if (next === MAT_AMBIENT) {\n        this.debugMessage('   Ambient color')\n        material.color = this.readColor(data)\n      } else if (next === MAT_SHININESS) {\n        const shininess = this.readPercentage(data)\n        material.shininess = shininess * 100\n        this.debugMessage('   Shininess : ' + shininess)\n      } else if (next === MAT_TRANSPARENCY) {\n        const transparency = this.readPercentage(data)\n        material.opacity = 1 - transparency\n        this.debugMessage('  Transparency : ' + transparency)\n        material.transparent = material.opacity < 1 ? true : false\n      } else if (next === MAT_TEXMAP) {\n        this.debugMessage('   ColorMap')\n        this.resetPosition(data)\n        material.map = this.readMap(data, path)\n      } else if (next === MAT_BUMPMAP) {\n        this.debugMessage('   BumpMap')\n        this.resetPosition(data)\n        material.bumpMap = this.readMap(data, path)\n      } else if (next === MAT_OPACMAP) {\n        this.debugMessage('   OpacityMap')\n        this.resetPosition(data)\n        material.alphaMap = this.readMap(data, path)\n      } else if (next === MAT_SPECMAP) {\n        this.debugMessage('   SpecularMap')\n        this.resetPosition(data)\n        material.specularMap = this.readMap(data, path)\n      } else {\n        this.debugMessage('   Unknown material chunk: ' + next.toString(16))\n      }\n\n      next = this.nextChunk(data, chunk)\n    }\n\n    this.endChunk(chunk)\n\n    this.materials[material.name] = material\n  }\n\n  /**\n   * Read mesh data chunk.\n   *\n   * @method readMesh\n   * @param {Dataview} data Dataview in use.\n   * @return {Mesh} The parsed mesh.\n   */\n  readMesh(data) {\n    const chunk = this.readChunk(data)\n    let next = this.nextChunk(data, chunk)\n\n    const geometry = new BufferGeometry()\n\n    const material = new MeshPhongMaterial()\n    const mesh = new Mesh(geometry, material)\n    mesh.name = 'mesh'\n\n    while (next !== 0) {\n      if (next === POINT_ARRAY) {\n        const points = this.readWord(data)\n\n        this.debugMessage('   Vertex: ' + points)\n\n        //BufferGeometry\n\n        const vertices = []\n\n        for (let i = 0; i < points; i++) {\n          vertices.push(this.readFloat(data))\n          vertices.push(this.readFloat(data))\n          vertices.push(this.readFloat(data))\n        }\n\n        geometry.setAttribute('position', new Float32BufferAttribute(vertices, 3))\n      } else if (next === FACE_ARRAY) {\n        this.resetPosition(data)\n        this.readFaceArray(data, mesh)\n      } else if (next === TEX_VERTS) {\n        const texels = this.readWord(data)\n\n        this.debugMessage('   UV: ' + texels)\n\n        //BufferGeometry\n\n        const uvs = []\n\n        for (let i = 0; i < texels; i++) {\n          uvs.push(this.readFloat(data))\n          uvs.push(this.readFloat(data))\n        }\n\n        geometry.setAttribute('uv', new Float32BufferAttribute(uvs, 2))\n      } else if (next === MESH_MATRIX) {\n        this.debugMessage('   Tranformation Matrix (TODO)')\n\n        const values = []\n        for (let i = 0; i < 12; i++) {\n          values[i] = this.readFloat(data)\n        }\n\n        const matrix = new Matrix4()\n\n        //X Line\n        matrix.elements[0] = values[0]\n        matrix.elements[1] = values[6]\n        matrix.elements[2] = values[3]\n        matrix.elements[3] = values[9]\n\n        //Y Line\n        matrix.elements[4] = values[2]\n        matrix.elements[5] = values[8]\n        matrix.elements[6] = values[5]\n        matrix.elements[7] = values[11]\n\n        //Z Line\n        matrix.elements[8] = values[1]\n        matrix.elements[9] = values[7]\n        matrix.elements[10] = values[4]\n        matrix.elements[11] = values[10]\n\n        //W Line\n        matrix.elements[12] = 0\n        matrix.elements[13] = 0\n        matrix.elements[14] = 0\n        matrix.elements[15] = 1\n\n        matrix.transpose()\n\n        const inverse = new Matrix4()\n        inverse.copy(matrix).invert()\n        geometry.applyMatrix4(inverse)\n\n        matrix.decompose(mesh.position, mesh.quaternion, mesh.scale)\n      } else {\n        this.debugMessage('   Unknown mesh chunk: ' + next.toString(16))\n      }\n\n      next = this.nextChunk(data, chunk)\n    }\n\n    this.endChunk(chunk)\n\n    geometry.computeVertexNormals()\n\n    return mesh\n  }\n\n  /**\n   * Read face array data chunk.\n   *\n   * @method readFaceArray\n   * @param {Dataview} data Dataview in use.\n   * @param {Mesh} mesh Mesh to be filled with the data read.\n   */\n  readFaceArray(data, mesh) {\n    const chunk = this.readChunk(data)\n    const faces = this.readWord(data)\n\n    this.debugMessage('   Faces: ' + faces)\n\n    const index = []\n\n    for (let i = 0; i < faces; ++i) {\n      index.push(this.readWord(data), this.readWord(data), this.readWord(data))\n\n      this.readWord(data) // visibility\n    }\n\n    mesh.geometry.setIndex(index)\n\n    //The rest of the FACE_ARRAY chunk is subchunks\n\n    let materialIndex = 0\n    let start = 0\n\n    while (this.position < chunk.end) {\n      const subchunk = this.readChunk(data)\n\n      if (subchunk.id === MSH_MAT_GROUP) {\n        this.debugMessage('      Material Group')\n\n        this.resetPosition(data)\n\n        const group = this.readMaterialGroup(data)\n        const count = group.index.length * 3 // assuming successive indices\n\n        mesh.geometry.addGroup(start, count, materialIndex)\n\n        start += count\n        materialIndex++\n\n        const material = this.materials[group.name]\n\n        if (Array.isArray(mesh.material) === false) mesh.material = []\n\n        if (material !== undefined) {\n          mesh.material.push(material)\n        }\n      } else {\n        this.debugMessage('      Unknown face array chunk: ' + subchunk.toString(16))\n      }\n\n      this.endChunk(subchunk)\n    }\n\n    if (mesh.material.length === 1) mesh.material = mesh.material[0] // for backwards compatibility\n\n    this.endChunk(chunk)\n  }\n\n  /**\n   * Read texture map data chunk.\n   *\n   * @method readMap\n   * @param {Dataview} data Dataview in use.\n   * @param {String} path Path for external resources.\n   * @return {Texture} Texture read from this data chunk.\n   */\n  readMap(data, path) {\n    const chunk = this.readChunk(data)\n    let next = this.nextChunk(data, chunk)\n    let texture = {}\n\n    const loader = new TextureLoader(this.manager)\n    loader.setPath(this.resourcePath || path).setCrossOrigin(this.crossOrigin)\n\n    while (next !== 0) {\n      if (next === MAT_MAPNAME) {\n        const name = this.readString(data, 128)\n        texture = loader.load(name)\n\n        this.debugMessage('      File: ' + path + name)\n      } else if (next === MAT_MAP_UOFFSET) {\n        texture.offset.x = this.readFloat(data)\n        this.debugMessage('      OffsetX: ' + texture.offset.x)\n      } else if (next === MAT_MAP_VOFFSET) {\n        texture.offset.y = this.readFloat(data)\n        this.debugMessage('      OffsetY: ' + texture.offset.y)\n      } else if (next === MAT_MAP_USCALE) {\n        texture.repeat.x = this.readFloat(data)\n        this.debugMessage('      RepeatX: ' + texture.repeat.x)\n      } else if (next === MAT_MAP_VSCALE) {\n        texture.repeat.y = this.readFloat(data)\n        this.debugMessage('      RepeatY: ' + texture.repeat.y)\n      } else {\n        this.debugMessage('      Unknown map chunk: ' + next.toString(16))\n      }\n\n      next = this.nextChunk(data, chunk)\n    }\n\n    this.endChunk(chunk)\n\n    return texture\n  }\n\n  /**\n   * Read material group data chunk.\n   *\n   * @method readMaterialGroup\n   * @param {Dataview} data Dataview in use.\n   * @return {Object} Object with name and index of the object.\n   */\n  readMaterialGroup(data) {\n    this.readChunk(data)\n    const name = this.readString(data, 64)\n    const numFaces = this.readWord(data)\n\n    this.debugMessage('         Name: ' + name)\n    this.debugMessage('         Faces: ' + numFaces)\n\n    const index = []\n    for (let i = 0; i < numFaces; ++i) {\n      index.push(this.readWord(data))\n    }\n\n    return { name: name, index: index }\n  }\n\n  /**\n   * Read a color value.\n   *\n   * @method readColor\n   * @param {DataView} data Dataview.\n   * @return {Color} Color value read..\n   */\n  readColor(data) {\n    const chunk = this.readChunk(data)\n    const color = new Color()\n\n    if (chunk.id === COLOR_24 || chunk.id === LIN_COLOR_24) {\n      const r = this.readByte(data)\n      const g = this.readByte(data)\n      const b = this.readByte(data)\n\n      color.setRGB(r / 255, g / 255, b / 255)\n\n      this.debugMessage('      Color: ' + color.r + ', ' + color.g + ', ' + color.b)\n    } else if (chunk.id === COLOR_F || chunk.id === LIN_COLOR_F) {\n      const r = this.readFloat(data)\n      const g = this.readFloat(data)\n      const b = this.readFloat(data)\n\n      color.setRGB(r, g, b)\n\n      this.debugMessage('      Color: ' + color.r + ', ' + color.g + ', ' + color.b)\n    } else {\n      this.debugMessage('      Unknown color chunk: ' + chunk.toString(16))\n    }\n\n    this.endChunk(chunk)\n    return color\n  }\n\n  /**\n   * Read next chunk of data.\n   *\n   * @method readChunk\n   * @param {DataView} data Dataview.\n   * @return {Object} Chunk of data read.\n   */\n  readChunk(data) {\n    const chunk = {}\n\n    chunk.cur = this.position\n    chunk.id = this.readWord(data)\n    chunk.size = this.readDWord(data)\n    chunk.end = chunk.cur + chunk.size\n    chunk.cur += 6\n\n    return chunk\n  }\n\n  /**\n   * Set position to the end of the current chunk of data.\n   *\n   * @method endChunk\n   * @param {Object} chunk Data chunk.\n   */\n  endChunk(chunk) {\n    this.position = chunk.end\n  }\n\n  /**\n   * Move to the next data chunk.\n   *\n   * @method nextChunk\n   * @param {DataView} data Dataview.\n   * @param {Object} chunk Data chunk.\n   */\n  nextChunk(data, chunk) {\n    if (chunk.cur >= chunk.end) {\n      return 0\n    }\n\n    this.position = chunk.cur\n\n    try {\n      const next = this.readChunk(data)\n      chunk.cur += next.size\n      return next.id\n    } catch (e) {\n      this.debugMessage('Unable to read chunk at ' + this.position)\n      return 0\n    }\n  }\n\n  /**\n   * Reset dataview position.\n   *\n   * @method resetPosition\n   */\n  resetPosition() {\n    this.position -= 6\n  }\n\n  /**\n   * Read byte value.\n   *\n   * @method readByte\n   * @param {DataView} data Dataview to read data from.\n   * @return {Number} Data read from the dataview.\n   */\n  readByte(data) {\n    const v = data.getUint8(this.position, true)\n    this.position += 1\n    return v\n  }\n\n  /**\n   * Read 32 bit float value.\n   *\n   * @method readFloat\n   * @param {DataView} data Dataview to read data from.\n   * @return {Number} Data read from the dataview.\n   */\n  readFloat(data) {\n    try {\n      const v = data.getFloat32(this.position, true)\n      this.position += 4\n      return v\n    } catch (e) {\n      this.debugMessage(e + ' ' + this.position + ' ' + data.byteLength)\n    }\n  }\n\n  /**\n   * Read 32 bit signed integer value.\n   *\n   * @method readInt\n   * @param {DataView} data Dataview to read data from.\n   * @return {Number} Data read from the dataview.\n   */\n  readInt(data) {\n    const v = data.getInt32(this.position, true)\n    this.position += 4\n    return v\n  }\n\n  /**\n   * Read 16 bit signed integer value.\n   *\n   * @method readShort\n   * @param {DataView} data Dataview to read data from.\n   * @return {Number} Data read from the dataview.\n   */\n  readShort(data) {\n    const v = data.getInt16(this.position, true)\n    this.position += 2\n    return v\n  }\n\n  /**\n   * Read 64 bit unsigned integer value.\n   *\n   * @method readDWord\n   * @param {DataView} data Dataview to read data from.\n   * @return {Number} Data read from the dataview.\n   */\n  readDWord(data) {\n    const v = data.getUint32(this.position, true)\n    this.position += 4\n    return v\n  }\n\n  /**\n   * Read 32 bit unsigned integer value.\n   *\n   * @method readWord\n   * @param {DataView} data Dataview to read data from.\n   * @return {Number} Data read from the dataview.\n   */\n  readWord(data) {\n    const v = data.getUint16(this.position, true)\n    this.position += 2\n    return v\n  }\n\n  /**\n   * Read string value.\n   *\n   * @method readString\n   * @param {DataView} data Dataview to read data from.\n   * @param {Number} maxLength Max size of the string to be read.\n   * @return {String} Data read from the dataview.\n   */\n  readString(data, maxLength) {\n    let s = ''\n\n    for (let i = 0; i < maxLength; i++) {\n      const c = this.readByte(data)\n      if (!c) {\n        break\n      }\n\n      s += String.fromCharCode(c)\n    }\n\n    return s\n  }\n\n  /**\n   * Read percentage value.\n   *\n   * @method readPercentage\n   * @param {DataView} data Dataview to read data from.\n   * @return {Number} Data read from the dataview.\n   */\n  readPercentage(data) {\n    const chunk = this.readChunk(data)\n    let value\n\n    switch (chunk.id) {\n      case INT_PERCENTAGE:\n        value = this.readShort(data) / 100\n        break\n\n      case FLOAT_PERCENTAGE:\n        value = this.readFloat(data)\n        break\n\n      default:\n        this.debugMessage('      Unknown percentage chunk: ' + chunk.toString(16))\n    }\n\n    this.endChunk(chunk)\n\n    return value\n  }\n\n  /**\n   * Print debug message to the console.\n   *\n   * Is controlled by a flag to show or hide debug messages.\n   *\n   * @method debugMessage\n   * @param {Object} message Debug message to print to the console.\n   */\n  debugMessage(message) {\n    if (this.debug) {\n      console.log(message)\n    }\n  }\n}\n\n// const NULL_CHUNK = 0x0000;\nconst M3DMAGIC = 0x4d4d\n// const SMAGIC = 0x2D2D;\n// const LMAGIC = 0x2D3D;\nconst MLIBMAGIC = 0x3daa\n// const MATMAGIC = 0x3DFF;\nconst CMAGIC = 0xc23d\nconst M3D_VERSION = 0x0002\n// const M3D_KFVERSION = 0x0005;\nconst COLOR_F = 0x0010\nconst COLOR_24 = 0x0011\nconst LIN_COLOR_24 = 0x0012\nconst LIN_COLOR_F = 0x0013\nconst INT_PERCENTAGE = 0x0030\nconst FLOAT_PERCENTAGE = 0x0031\nconst MDATA = 0x3d3d\nconst MESH_VERSION = 0x3d3e\nconst MASTER_SCALE = 0x0100\n// const LO_SHADOW_BIAS = 0x1400;\n// const HI_SHADOW_BIAS = 0x1410;\n// const SHADOW_MAP_SIZE = 0x1420;\n// const SHADOW_SAMPLES = 0x1430;\n// const SHADOW_RANGE = 0x1440;\n// const SHADOW_FILTER = 0x1450;\n// const RAY_BIAS = 0x1460;\n// const O_CONSTS = 0x1500;\n// const AMBIENT_LIGHT = 0x2100;\n// const BIT_MAP = 0x1100;\n// const SOLID_BGND = 0x1200;\n// const V_GRADIENT = 0x1300;\n// const USE_BIT_MAP = 0x1101;\n// const USE_SOLID_BGND = 0x1201;\n// const USE_V_GRADIENT = 0x1301;\n// const FOG = 0x2200;\n// const FOG_BGND = 0x2210;\n// const LAYER_FOG = 0x2302;\n// const DISTANCE_CUE = 0x2300;\n// const DCUE_BGND = 0x2310;\n// const USE_FOG = 0x2201;\n// const USE_LAYER_FOG = 0x2303;\n// const USE_DISTANCE_CUE = 0x2301;\nconst MAT_ENTRY = 0xafff\nconst MAT_NAME = 0xa000\nconst MAT_AMBIENT = 0xa010\nconst MAT_DIFFUSE = 0xa020\nconst MAT_SPECULAR = 0xa030\nconst MAT_SHININESS = 0xa040\n// const MAT_SHIN2PCT = 0xA041;\nconst MAT_TRANSPARENCY = 0xa050\n// const MAT_XPFALL = 0xA052;\n// const MAT_USE_XPFALL = 0xA240;\n// const MAT_REFBLUR = 0xA053;\n// const MAT_SHADING = 0xA100;\n// const MAT_USE_REFBLUR = 0xA250;\n// const MAT_SELF_ILLUM = 0xA084;\nconst MAT_TWO_SIDE = 0xa081\n// const MAT_DECAL = 0xA082;\nconst MAT_ADDITIVE = 0xa083\nconst MAT_WIRE = 0xa085\n// const MAT_FACEMAP = 0xA088;\n// const MAT_TRANSFALLOFF_IN = 0xA08A;\n// const MAT_PHONGSOFT = 0xA08C;\n// const MAT_WIREABS = 0xA08E;\nconst MAT_WIRE_SIZE = 0xa087\nconst MAT_TEXMAP = 0xa200\n// const MAT_SXP_TEXT_DATA = 0xA320;\n// const MAT_TEXMASK = 0xA33E;\n// const MAT_SXP_TEXTMASK_DATA = 0xA32A;\n// const MAT_TEX2MAP = 0xA33A;\n// const MAT_SXP_TEXT2_DATA = 0xA321;\n// const MAT_TEX2MASK = 0xA340;\n// const MAT_SXP_TEXT2MASK_DATA = 0xA32C;\nconst MAT_OPACMAP = 0xa210\n// const MAT_SXP_OPAC_DATA = 0xA322;\n// const MAT_OPACMASK = 0xA342;\n// const MAT_SXP_OPACMASK_DATA = 0xA32E;\nconst MAT_BUMPMAP = 0xa230\n// const MAT_SXP_BUMP_DATA = 0xA324;\n// const MAT_BUMPMASK = 0xA344;\n// const MAT_SXP_BUMPMASK_DATA = 0xA330;\nconst MAT_SPECMAP = 0xa204\n// const MAT_SXP_SPEC_DATA = 0xA325;\n// const MAT_SPECMASK = 0xA348;\n// const MAT_SXP_SPECMASK_DATA = 0xA332;\n// const MAT_SHINMAP = 0xA33C;\n// const MAT_SXP_SHIN_DATA = 0xA326;\n// const MAT_SHINMASK = 0xA346;\n// const MAT_SXP_SHINMASK_DATA = 0xA334;\n// const MAT_SELFIMAP = 0xA33D;\n// const MAT_SXP_SELFI_DATA = 0xA328;\n// const MAT_SELFIMASK = 0xA34A;\n// const MAT_SXP_SELFIMASK_DATA = 0xA336;\n// const MAT_REFLMAP = 0xA220;\n// const MAT_REFLMASK = 0xA34C;\n// const MAT_SXP_REFLMASK_DATA = 0xA338;\n// const MAT_ACUBIC = 0xA310;\nconst MAT_MAPNAME = 0xa300\n// const MAT_MAP_TILING = 0xA351;\n// const MAT_MAP_TEXBLUR = 0xA353;\nconst MAT_MAP_USCALE = 0xa354\nconst MAT_MAP_VSCALE = 0xa356\nconst MAT_MAP_UOFFSET = 0xa358\nconst MAT_MAP_VOFFSET = 0xa35a\n// const MAT_MAP_ANG = 0xA35C;\n// const MAT_MAP_COL1 = 0xA360;\n// const MAT_MAP_COL2 = 0xA362;\n// const MAT_MAP_RCOL = 0xA364;\n// const MAT_MAP_GCOL = 0xA366;\n// const MAT_MAP_BCOL = 0xA368;\nconst NAMED_OBJECT = 0x4000\n// const N_DIRECT_LIGHT = 0x4600;\n// const DL_OFF = 0x4620;\n// const DL_OUTER_RANGE = 0x465A;\n// const DL_INNER_RANGE = 0x4659;\n// const DL_MULTIPLIER = 0x465B;\n// const DL_EXCLUDE = 0x4654;\n// const DL_ATTENUATE = 0x4625;\n// const DL_SPOTLIGHT = 0x4610;\n// const DL_SPOT_ROLL = 0x4656;\n// const DL_SHADOWED = 0x4630;\n// const DL_LOCAL_SHADOW2 = 0x4641;\n// const DL_SEE_CONE = 0x4650;\n// const DL_SPOT_RECTANGULAR = 0x4651;\n// const DL_SPOT_ASPECT = 0x4657;\n// const DL_SPOT_PROJECTOR = 0x4653;\n// const DL_SPOT_OVERSHOOT = 0x4652;\n// const DL_RAY_BIAS = 0x4658;\n// const DL_RAYSHAD = 0x4627;\n// const N_CAMERA = 0x4700;\n// const CAM_SEE_CONE = 0x4710;\n// const CAM_RANGES = 0x4720;\n// const OBJ_HIDDEN = 0x4010;\n// const OBJ_VIS_LOFTER = 0x4011;\n// const OBJ_DOESNT_CAST = 0x4012;\n// const OBJ_DONT_RECVSHADOW = 0x4017;\n// const OBJ_MATTE = 0x4013;\n// const OBJ_FAST = 0x4014;\n// const OBJ_PROCEDURAL = 0x4015;\n// const OBJ_FROZEN = 0x4016;\nconst N_TRI_OBJECT = 0x4100\nconst POINT_ARRAY = 0x4110\n// const POINT_FLAG_ARRAY = 0x4111;\nconst FACE_ARRAY = 0x4120\nconst MSH_MAT_GROUP = 0x4130\n// const SMOOTH_GROUP = 0x4150;\n// const MSH_BOXMAP = 0x4190;\nconst TEX_VERTS = 0x4140\nconst MESH_MATRIX = 0x4160\n// const MESH_COLOR = 0x4165;\n// const MESH_TEXTURE_INFO = 0x4170;\n// const KFDATA = 0xB000;\n// const KFHDR = 0xB00A;\n// const KFSEG = 0xB008;\n// const KFCURTIME = 0xB009;\n// const AMBIENT_NODE_TAG = 0xB001;\n// const OBJECT_NODE_TAG = 0xB002;\n// const CAMERA_NODE_TAG = 0xB003;\n// const TARGET_NODE_TAG = 0xB004;\n// const LIGHT_NODE_TAG = 0xB005;\n// const L_TARGET_NODE_TAG = 0xB006;\n// const SPOTLIGHT_NODE_TAG = 0xB007;\n// const NODE_ID = 0xB030;\n// const NODE_HDR = 0xB010;\n// const PIVOT = 0xB013;\n// const INSTANCE_NAME = 0xB011;\n// const MORPH_SMOOTH = 0xB015;\n// const BOUNDBOX = 0xB014;\n// const POS_TRACK_TAG = 0xB020;\n// const COL_TRACK_TAG = 0xB025;\n// const ROT_TRACK_TAG = 0xB021;\n// const SCL_TRACK_TAG = 0xB022;\n// const MORPH_TRACK_TAG = 0xB026;\n// const FOV_TRACK_TAG = 0xB023;\n// const ROLL_TRACK_TAG = 0xB024;\n// const HOT_TRACK_TAG = 0xB027;\n// const FALL_TRACK_TAG = 0xB028;\n// const HIDE_TRACK_TAG = 0xB029;\n// const POLY_2D = 0x5000;\n// const SHAPE_OK = 0x5010;\n// const SHAPE_NOT_OK = 0x5011;\n// const SHAPE_HOOK = 0x5020;\n// const PATH_3D = 0x6000;\n// const PATH_MATRIX = 0x6005;\n// const SHAPE_2D = 0x6010;\n// const M_SCALE = 0x6020;\n// const M_TWIST = 0x6030;\n// const M_TEETER = 0x6040;\n// const M_FIT = 0x6050;\n// const M_BEVEL = 0x6060;\n// const XZ_CURVE = 0x6070;\n// const YZ_CURVE = 0x6080;\n// const INTERPCT = 0x6090;\n// const DEFORM_LIMIT = 0x60A0;\n// const USE_CONTOUR = 0x6100;\n// const USE_TWEEN = 0x6110;\n// const USE_SCALE = 0x6120;\n// const USE_TWIST = 0x6130;\n// const USE_TEETER = 0x6140;\n// const USE_FIT = 0x6150;\n// const USE_BEVEL = 0x6160;\n// const DEFAULT_VIEW = 0x3000;\n// const VIEW_TOP = 0x3010;\n// const VIEW_BOTTOM = 0x3020;\n// const VIEW_LEFT = 0x3030;\n// const VIEW_RIGHT = 0x3040;\n// const VIEW_FRONT = 0x3050;\n// const VIEW_BACK = 0x3060;\n// const VIEW_USER = 0x3070;\n// const VIEW_CAMERA = 0x3080;\n// const VIEW_WINDOW = 0x3090;\n// const VIEWPORT_LAYOUT_OLD = 0x7000;\n// const VIEWPORT_DATA_OLD = 0x7010;\n// const VIEWPORT_LAYOUT = 0x7001;\n// const VIEWPORT_DATA = 0x7011;\n// const VIEWPORT_DATA_3 = 0x7012;\n// const VIEWPORT_SIZE = 0x7020;\n// const NETWORK_VIEW = 0x7030;\n\nexport { TDSLoader }\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}