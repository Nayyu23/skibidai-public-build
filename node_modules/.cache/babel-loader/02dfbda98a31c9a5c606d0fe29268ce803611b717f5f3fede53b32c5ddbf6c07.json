{"ast":null,"code":"import _createForOfIteratorHelper from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _createClass from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _classCallCheck from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = function __defNormalProp(obj, key, value) {\n  return key in obj ? __defProp(obj, key, {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: value\n  }) : obj[key] = value;\n};\nvar __publicField = function __publicField(obj, key, value) {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nimport { Vector3, BufferAttribute, BufferGeometry } from \"three\";\nimport * as BufferGeometryUtils from \"../utils/BufferGeometryUtils.js\";\nimport { mergeVertices } from \"../utils/BufferGeometryUtils.js\";\nvar EdgeSplitModifier = /*#__PURE__*/_createClass(function EdgeSplitModifier() {\n  var _this = this;\n  _classCallCheck(this, EdgeSplitModifier);\n  __publicField(this, \"A\", new Vector3());\n  __publicField(this, \"B\", new Vector3());\n  __publicField(this, \"C\", new Vector3());\n  __publicField(this, \"positions\", []);\n  __publicField(this, \"normals\", new Float32Array());\n  __publicField(this, \"indexes\", []);\n  __publicField(this, \"pointToIndexMap\", []);\n  __publicField(this, \"splitIndexes\", []);\n  __publicField(this, \"oldNormals\", []);\n  __publicField(this, \"computeNormals\", function () {\n    _this.normals = new Float32Array(_this.indexes.length * 3);\n    for (var i = 0; i < _this.indexes.length; i += 3) {\n      var index = _this.indexes[i];\n      _this.A.set(_this.positions[3 * index], _this.positions[3 * index + 1], _this.positions[3 * index + 2]);\n      index = _this.indexes[i + 1];\n      _this.B.set(_this.positions[3 * index], _this.positions[3 * index + 1], _this.positions[3 * index + 2]);\n      index = _this.indexes[i + 2];\n      _this.C.set(_this.positions[3 * index], _this.positions[3 * index + 1], _this.positions[3 * index + 2]);\n      _this.C.sub(_this.B);\n      _this.A.sub(_this.B);\n      var normal = _this.C.cross(_this.A).normalize();\n      for (var j = 0; j < 3; j++) {\n        _this.normals[3 * (i + j)] = normal.x;\n        _this.normals[3 * (i + j) + 1] = normal.y;\n        _this.normals[3 * (i + j) + 2] = normal.z;\n      }\n    }\n  });\n  __publicField(this, \"mapPositionsToIndexes\", function () {\n    _this.pointToIndexMap = Array(_this.positions.length / 3);\n    for (var i = 0; i < _this.indexes.length; i++) {\n      var index = _this.indexes[i];\n      if (_this.pointToIndexMap[index] == null) {\n        _this.pointToIndexMap[index] = [];\n      }\n      _this.pointToIndexMap[index].push(i);\n    }\n  });\n  __publicField(this, \"edgeSplitToGroups\", function (indexes, cutOff, firstIndex) {\n    _this.A.set(_this.normals[3 * firstIndex], _this.normals[3 * firstIndex + 1], _this.normals[3 * firstIndex + 2]).normalize();\n    var result = {\n      splitGroup: [],\n      currentGroup: [firstIndex]\n    };\n    var _iterator = _createForOfIteratorHelper(indexes),\n      _step;\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var j = _step.value;\n        if (j !== firstIndex) {\n          _this.B.set(_this.normals[3 * j], _this.normals[3 * j + 1], _this.normals[3 * j + 2]).normalize();\n          if (_this.B.dot(_this.A) < cutOff) {\n            result.splitGroup.push(j);\n          } else {\n            result.currentGroup.push(j);\n          }\n        }\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n    return result;\n  });\n  __publicField(this, \"edgeSplit\", function (indexes, cutOff) {\n    var original = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n    if (indexes.length === 0) return;\n    var groupResults = [];\n    var _iterator2 = _createForOfIteratorHelper(indexes),\n      _step2;\n    try {\n      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n        var index = _step2.value;\n        groupResults.push(_this.edgeSplitToGroups(indexes, cutOff, index));\n      }\n    } catch (err) {\n      _iterator2.e(err);\n    } finally {\n      _iterator2.f();\n    }\n    var result = groupResults[0];\n    for (var _i = 0, _groupResults = groupResults; _i < _groupResults.length; _i++) {\n      var groupResult = _groupResults[_i];\n      if (groupResult.currentGroup.length > result.currentGroup.length) {\n        result = groupResult;\n      }\n    }\n    if (original != null) {\n      _this.splitIndexes.push({\n        original: original,\n        indexes: result.currentGroup\n      });\n    }\n    if (result.splitGroup.length) {\n      _this.edgeSplit(result.splitGroup, cutOff, original || result.currentGroup[0]);\n    }\n  });\n  __publicField(this, \"modify\", function (geometry, cutOffAngle) {\n    var tryKeepNormals = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n    var hadNormals = false;\n    if (geometry.attributes.normal) {\n      hadNormals = true;\n      geometry = geometry.clone();\n      if (tryKeepNormals === true && geometry.index !== null) {\n        _this.oldNormals = geometry.attributes.normal.array;\n      }\n      geometry.deleteAttribute(\"normal\");\n    }\n    if (geometry.index == null) {\n      if (BufferGeometryUtils === void 0) {\n        throw \"THREE.EdgeSplitModifier relies on BufferGeometryUtils\";\n      }\n      geometry = mergeVertices(geometry);\n    }\n    _this.indexes = geometry.index.array;\n    _this.positions = geometry.getAttribute(\"position\").array;\n    _this.computeNormals();\n    _this.mapPositionsToIndexes();\n    _this.splitIndexes = [];\n    var _iterator3 = _createForOfIteratorHelper(_this.pointToIndexMap),\n      _step3;\n    try {\n      for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n        var vertexIndexes = _step3.value;\n        _this.edgeSplit(vertexIndexes, Math.cos(cutOffAngle) - 1e-3);\n      }\n    } catch (err) {\n      _iterator3.e(err);\n    } finally {\n      _iterator3.f();\n    }\n    var newAttributes = {};\n    for (var _i2 = 0, _Object$keys = Object.keys(geometry.attributes); _i2 < _Object$keys.length; _i2++) {\n      var name = _Object$keys[_i2];\n      var oldAttribute = geometry.attributes[name];\n      var newArray = new oldAttribute.array.constructor((_this.indexes.length + _this.splitIndexes.length) * oldAttribute.itemSize);\n      newArray.set(oldAttribute.array);\n      newAttributes[name] = new BufferAttribute(newArray, oldAttribute.itemSize, oldAttribute.normalized);\n    }\n    var newIndexes = new Uint32Array(_this.indexes.length);\n    newIndexes.set(_this.indexes);\n    for (var i = 0; i < _this.splitIndexes.length; i++) {\n      var split = _this.splitIndexes[i];\n      var index = _this.indexes[split.original];\n      for (var _i3 = 0, _Object$values = Object.values(newAttributes); _i3 < _Object$values.length; _i3++) {\n        var attribute = _Object$values[_i3];\n        for (var j = 0; j < attribute.itemSize; j++) {\n          attribute.array[(_this.indexes.length + i) * attribute.itemSize + j] = attribute.array[index * attribute.itemSize + j];\n        }\n      }\n      var _iterator4 = _createForOfIteratorHelper(split.indexes),\n        _step4;\n      try {\n        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n          var _j = _step4.value;\n          newIndexes[_j] = _this.indexes.length + i;\n        }\n      } catch (err) {\n        _iterator4.e(err);\n      } finally {\n        _iterator4.f();\n      }\n    }\n    geometry = new BufferGeometry();\n    geometry.setIndex(new BufferAttribute(newIndexes, 1));\n    for (var _i4 = 0, _Object$keys2 = Object.keys(newAttributes); _i4 < _Object$keys2.length; _i4++) {\n      var _name = _Object$keys2[_i4];\n      geometry.setAttribute(_name, newAttributes[_name]);\n    }\n    if (hadNormals) {\n      geometry.computeVertexNormals();\n      if (_this.oldNormals !== null) {\n        var changedNormals = new Array(_this.oldNormals.length / 3).fill(false);\n        var _iterator5 = _createForOfIteratorHelper(_this.splitIndexes),\n          _step5;\n        try {\n          for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n            var splitData = _step5.value;\n            changedNormals[splitData.original] = true;\n          }\n        } catch (err) {\n          _iterator5.e(err);\n        } finally {\n          _iterator5.f();\n        }\n        for (var _i5 = 0; _i5 < changedNormals.length; _i5++) {\n          if (changedNormals[_i5] === false) {\n            for (var _j2 = 0; _j2 < 3; _j2++) {\n              geometry.attributes.normal.array[3 * _i5 + _j2] = _this.oldNormals[3 * _i5 + _j2];\n            }\n          }\n        }\n      }\n    }\n    return geometry;\n  });\n});\nexport { EdgeSplitModifier };","map":{"version":3,"names":["EdgeSplitModifier","_createClass","_this","_classCallCheck","__publicField","Vector3","Float32Array","normals","indexes","length","i","index","A","set","positions","B","C","sub","normal","cross","normalize","j","x","y","z","pointToIndexMap","Array","push","cutOff","firstIndex","result","splitGroup","currentGroup","_iterator","_createForOfIteratorHelper","_step","s","n","done","value","dot","err","e","f","original","arguments","undefined","groupResults","_iterator2","_step2","edgeSplitToGroups","_i","_groupResults","groupResult","splitIndexes","edgeSplit","geometry","cutOffAngle","tryKeepNormals","hadNormals","attributes","clone","oldNormals","array","deleteAttribute","BufferGeometryUtils","mergeVertices","getAttribute","computeNormals","mapPositionsToIndexes","_iterator3","_step3","vertexIndexes","Math","cos","newAttributes","_i2","_Object$keys","Object","keys","name","oldAttribute","newArray","constructor","itemSize","BufferAttribute","normalized","newIndexes","Uint32Array","split","_i3","_Object$values","values","attribute","_iterator4","_step4","BufferGeometry","setIndex","_i4","_Object$keys2","setAttribute","computeVertexNormals","changedNormals","fill","_iterator5","_step5","splitData"],"sources":["C:\\Users\\Nayyu\\Desktop\\skibidai-public-build\\node_modules\\src\\modifiers\\EdgeSplitModifier.ts"],"sourcesContent":["import { BufferAttribute, BufferGeometry, Vector3 } from 'three'\nimport * as BufferGeometryUtils from '../utils/BufferGeometryUtils'\n\ninterface EdgeSplitToGroupsResult {\n  splitGroup: number[]\n  currentGroup: number[]\n}\n\ninterface SplitIndexes {\n  original: number\n  indexes: number[]\n}\n\nclass EdgeSplitModifier {\n  private A = new Vector3()\n  private B = new Vector3()\n  private C = new Vector3()\n\n  private positions: ArrayLike<number> = []\n  private normals: Float32Array = new Float32Array()\n  private indexes: ArrayLike<number> = []\n  private pointToIndexMap: number[][] = []\n  private splitIndexes: SplitIndexes[] = []\n  private oldNormals: ArrayLike<number> = []\n\n  constructor() {}\n\n  private computeNormals = (): void => {\n    this.normals = new Float32Array(this.indexes.length * 3)\n\n    for (let i = 0; i < this.indexes.length; i += 3) {\n      let index = this.indexes[i]\n\n      this.A.set(this.positions[3 * index], this.positions[3 * index + 1], this.positions[3 * index + 2])\n\n      index = this.indexes[i + 1]\n      this.B.set(this.positions[3 * index], this.positions[3 * index + 1], this.positions[3 * index + 2])\n\n      index = this.indexes[i + 2]\n      this.C.set(this.positions[3 * index], this.positions[3 * index + 1], this.positions[3 * index + 2])\n\n      this.C.sub(this.B)\n      this.A.sub(this.B)\n\n      const normal = this.C.cross(this.A).normalize()\n\n      for (let j = 0; j < 3; j++) {\n        this.normals[3 * (i + j)] = normal.x\n        this.normals[3 * (i + j) + 1] = normal.y\n        this.normals[3 * (i + j) + 2] = normal.z\n      }\n    }\n  }\n\n  private mapPositionsToIndexes = (): void => {\n    this.pointToIndexMap = Array(this.positions.length / 3)\n\n    for (let i = 0; i < this.indexes.length; i++) {\n      const index = this.indexes[i]\n\n      if (this.pointToIndexMap[index] == null) {\n        this.pointToIndexMap[index] = []\n      }\n\n      this.pointToIndexMap[index].push(i)\n    }\n  }\n\n  private edgeSplitToGroups = (indexes: number[], cutOff: number, firstIndex: number): EdgeSplitToGroupsResult => {\n    this.A.set(\n      this.normals[3 * firstIndex],\n      this.normals[3 * firstIndex + 1],\n      this.normals[3 * firstIndex + 2],\n    ).normalize()\n\n    const result: EdgeSplitToGroupsResult = {\n      splitGroup: [],\n      currentGroup: [firstIndex],\n    }\n\n    for (let j of indexes) {\n      if (j !== firstIndex) {\n        this.B.set(this.normals[3 * j], this.normals[3 * j + 1], this.normals[3 * j + 2]).normalize()\n\n        if (this.B.dot(this.A) < cutOff) {\n          result.splitGroup.push(j)\n        } else {\n          result.currentGroup.push(j)\n        }\n      }\n    }\n\n    return result\n  }\n\n  private edgeSplit = (indexes: number[], cutOff: number, original: number | null = null): void => {\n    if (indexes.length === 0) return\n\n    const groupResults: EdgeSplitToGroupsResult[] = []\n\n    for (let index of indexes) {\n      groupResults.push(this.edgeSplitToGroups(indexes, cutOff, index))\n    }\n\n    let result = groupResults[0]\n\n    for (let groupResult of groupResults) {\n      if (groupResult.currentGroup.length > result.currentGroup.length) {\n        result = groupResult\n      }\n    }\n\n    if (original != null) {\n      this.splitIndexes.push({\n        original,\n        indexes: result.currentGroup,\n      })\n    }\n\n    if (result.splitGroup.length) {\n      this.edgeSplit(result.splitGroup, cutOff, original || result.currentGroup[0])\n    }\n  }\n\n  public modify = (geometry: BufferGeometry, cutOffAngle: number, tryKeepNormals = true): BufferGeometry => {\n    let hadNormals = false\n\n    if (geometry.attributes.normal) {\n      hadNormals = true\n\n      geometry = geometry.clone()\n\n      if (tryKeepNormals === true && geometry.index !== null) {\n        this.oldNormals = geometry.attributes.normal.array\n      }\n\n      geometry.deleteAttribute('normal')\n    }\n\n    if (geometry.index == null) {\n      if (BufferGeometryUtils === undefined) {\n        throw 'THREE.EdgeSplitModifier relies on BufferGeometryUtils'\n      }\n\n      geometry = BufferGeometryUtils.mergeVertices(geometry)\n    }\n\n    this.indexes = (geometry.index as BufferAttribute).array\n    this.positions = geometry.getAttribute('position').array\n\n    this.computeNormals()\n    this.mapPositionsToIndexes()\n\n    this.splitIndexes = []\n\n    for (let vertexIndexes of this.pointToIndexMap) {\n      this.edgeSplit(vertexIndexes, Math.cos(cutOffAngle) - 0.001)\n    }\n\n    const newAttributes: {\n      [key: string]: BufferAttribute\n    } = {}\n    for (let name of Object.keys(geometry.attributes)) {\n      const oldAttribute = geometry.attributes[name]\n      // @ts-ignore\n      const newArray = new oldAttribute.array.constructor(\n        (this.indexes.length + this.splitIndexes.length) * oldAttribute.itemSize,\n      )\n\n      newArray.set(oldAttribute.array)\n      newAttributes[name] = new BufferAttribute(newArray, oldAttribute.itemSize, oldAttribute.normalized)\n    }\n\n    const newIndexes = new Uint32Array(this.indexes.length)\n    newIndexes.set(this.indexes)\n\n    for (let i = 0; i < this.splitIndexes.length; i++) {\n      const split = this.splitIndexes[i]\n      const index = this.indexes[split.original]\n\n      for (let attribute of Object.values(newAttributes)) {\n        for (let j = 0; j < attribute.itemSize; j++) {\n          // @ts-ignore ArrayLike can't be mutated, but this works – https://github.com/three-types/three-ts-types/issues/35\n          attribute.array[(this.indexes.length + i) * attribute.itemSize + j] =\n            attribute.array[index * attribute.itemSize + j]\n        }\n      }\n\n      for (let j of split.indexes) {\n        newIndexes[j] = this.indexes.length + i\n      }\n    }\n\n    geometry = new BufferGeometry()\n    geometry.setIndex(new BufferAttribute(newIndexes, 1))\n\n    for (let name of Object.keys(newAttributes)) {\n      geometry.setAttribute(name, newAttributes[name])\n    }\n\n    if (hadNormals) {\n      geometry.computeVertexNormals()\n\n      if (this.oldNormals !== null) {\n        const changedNormals = new Array(this.oldNormals.length / 3).fill(false)\n\n        for (let splitData of this.splitIndexes) changedNormals[splitData.original] = true\n\n        for (let i = 0; i < changedNormals.length; i++) {\n          if (changedNormals[i] === false) {\n            for (let j = 0; j < 3; j++) {\n              // @ts-ignore ArrayLike can't be mutated, but this works – https://github.com/three-types/three-ts-types/issues/35\n              geometry.attributes.normal.array[3 * i + j] = this.oldNormals[3 * i + j]\n            }\n          }\n        }\n      }\n    }\n\n    return geometry\n  }\n}\n\nexport { EdgeSplitModifier }\n"],"mappings":";;;;;;;;;;;;;;;;;;;IAaMA,iBAAA,gBAAAC,YAAA,CAYJ,SAAAD,kBAAA,EAAc;EAAA,IAAAE,KAAA;EAAAC,eAAA,OAAAH,iBAAA;EAXNI,aAAA,YAAI,IAAIC,OAAA;EACRD,aAAA,YAAI,IAAIC,OAAA;EACRD,aAAA,YAAI,IAAIC,OAAA;EAERD,aAAA,oBAA+B;EAC/BA,aAAA,kBAAwB,IAAIE,YAAA;EAC5BF,aAAA,kBAA6B;EAC7BA,aAAA,0BAA8B;EAC9BA,aAAA,uBAA+B;EAC/BA,aAAA,qBAAgC;EAIhCA,aAAA,yBAAiB,YAAY;IACnCF,KAAA,CAAKK,OAAA,GAAU,IAAID,YAAA,CAAaJ,KAAA,CAAKM,OAAA,CAAQC,MAAA,GAAS,CAAC;IAEvD,SAASC,CAAA,GAAI,GAAGA,CAAA,GAAIR,KAAA,CAAKM,OAAA,CAAQC,MAAA,EAAQC,CAAA,IAAK,GAAG;MAC3C,IAAAC,KAAA,GAAQT,KAAA,CAAKM,OAAA,CAAQE,CAAC;MAE1BR,KAAA,CAAKU,CAAA,CAAEC,GAAA,CAAIX,KAAA,CAAKY,SAAA,CAAU,IAAIH,KAAK,GAAGT,KAAA,CAAKY,SAAA,CAAU,IAAIH,KAAA,GAAQ,CAAC,GAAGT,KAAA,CAAKY,SAAA,CAAU,IAAIH,KAAA,GAAQ,CAAC,CAAC;MAE1FA,KAAA,GAAAT,KAAA,CAAKM,OAAA,CAAQE,CAAA,GAAI,CAAC;MAC1BR,KAAA,CAAKa,CAAA,CAAEF,GAAA,CAAIX,KAAA,CAAKY,SAAA,CAAU,IAAIH,KAAK,GAAGT,KAAA,CAAKY,SAAA,CAAU,IAAIH,KAAA,GAAQ,CAAC,GAAGT,KAAA,CAAKY,SAAA,CAAU,IAAIH,KAAA,GAAQ,CAAC,CAAC;MAE1FA,KAAA,GAAAT,KAAA,CAAKM,OAAA,CAAQE,CAAA,GAAI,CAAC;MAC1BR,KAAA,CAAKc,CAAA,CAAEH,GAAA,CAAIX,KAAA,CAAKY,SAAA,CAAU,IAAIH,KAAK,GAAGT,KAAA,CAAKY,SAAA,CAAU,IAAIH,KAAA,GAAQ,CAAC,GAAGT,KAAA,CAAKY,SAAA,CAAU,IAAIH,KAAA,GAAQ,CAAC,CAAC;MAE7FT,KAAA,CAAAc,CAAA,CAAEC,GAAA,CAAIf,KAAA,CAAKa,CAAC;MACZb,KAAA,CAAAU,CAAA,CAAEK,GAAA,CAAIf,KAAA,CAAKa,CAAC;MAEjB,IAAMG,MAAA,GAAShB,KAAA,CAAKc,CAAA,CAAEG,KAAA,CAAMjB,KAAA,CAAKU,CAAC,EAAEQ,SAAA;MAEpC,SAASC,CAAA,GAAI,GAAGA,CAAA,GAAI,GAAGA,CAAA,IAAK;QAC1BnB,KAAA,CAAKK,OAAA,CAAQ,KAAKG,CAAA,GAAIW,CAAA,CAAE,IAAIH,MAAA,CAAOI,CAAA;QACnCpB,KAAA,CAAKK,OAAA,CAAQ,KAAKG,CAAA,GAAIW,CAAA,IAAK,CAAC,IAAIH,MAAA,CAAOK,CAAA;QACvCrB,KAAA,CAAKK,OAAA,CAAQ,KAAKG,CAAA,GAAIW,CAAA,IAAK,CAAC,IAAIH,MAAA,CAAOM,CAAA;MACzC;IACF;EAAA;EAGMpB,aAAA,gCAAwB,YAAY;IAC1CF,KAAA,CAAKuB,eAAA,GAAkBC,KAAA,CAAMxB,KAAA,CAAKY,SAAA,CAAUL,MAAA,GAAS,CAAC;IAEtD,SAASC,CAAA,GAAI,GAAGA,CAAA,GAAIR,KAAA,CAAKM,OAAA,CAAQC,MAAA,EAAQC,CAAA,IAAK;MACtC,IAAAC,KAAA,GAAQT,KAAA,CAAKM,OAAA,CAAQE,CAAC;MAE5B,IAAIR,KAAA,CAAKuB,eAAA,CAAgBd,KAAK,KAAK,MAAM;QAClCT,KAAA,CAAAuB,eAAA,CAAgBd,KAAK,IAAI;MAChC;MAEAT,KAAA,CAAKuB,eAAA,CAAgBd,KAAK,EAAEgB,IAAA,CAAKjB,CAAC;IACpC;EAAA;EAGMN,aAAA,4BAAoB,UAACI,OAAA,EAAmBoB,MAAA,EAAgBC,UAAA,EAAgD;IAC9G3B,KAAA,CAAKU,CAAA,CAAEC,GAAA,CACLX,KAAA,CAAKK,OAAA,CAAQ,IAAIsB,UAAU,GAC3B3B,KAAA,CAAKK,OAAA,CAAQ,IAAIsB,UAAA,GAAa,CAAC,GAC/B3B,KAAA,CAAKK,OAAA,CAAQ,IAAIsB,UAAA,GAAa,CAAC,GAC/BT,SAAA,CAAU;IAEZ,IAAMU,MAAA,GAAkC;MACtCC,UAAA,EAAY,EAAC;MACbC,YAAA,EAAc,CAACH,UAAU;IAAA;IAAA,IAAAI,SAAA,GAAAC,0BAAA,CAGb1B,OAAA;MAAA2B,KAAA;IAAA;MAAd,KAAAF,SAAA,CAAAG,CAAA,MAAAD,KAAA,GAAAF,SAAA,CAAAI,CAAA,IAAAC,IAAA,GAAuB;QAAA,IAAdjB,CAAA,GAAAc,KAAA,CAAAI,KAAA;QACP,IAAIlB,CAAA,KAAMQ,UAAA,EAAY;UACf3B,KAAA,CAAAa,CAAA,CAAEF,GAAA,CAAIX,KAAA,CAAKK,OAAA,CAAQ,IAAIc,CAAC,GAAGnB,KAAA,CAAKK,OAAA,CAAQ,IAAIc,CAAA,GAAI,CAAC,GAAGnB,KAAA,CAAKK,OAAA,CAAQ,IAAIc,CAAA,GAAI,CAAC,CAAC,EAAED,SAAA;UAElF,IAAIlB,KAAA,CAAKa,CAAA,CAAEyB,GAAA,CAAItC,KAAA,CAAKU,CAAC,IAAIgB,MAAA,EAAQ;YACxBE,MAAA,CAAAC,UAAA,CAAWJ,IAAA,CAAKN,CAAC;UAAA,OACnB;YACES,MAAA,CAAAE,YAAA,CAAaL,IAAA,CAAKN,CAAC;UAC5B;QACF;MACF;IAAA,SAAAoB,GAAA;MAAAR,SAAA,CAAAS,CAAA,CAAAD,GAAA;IAAA;MAAAR,SAAA,CAAAU,CAAA;IAAA;IAEO,OAAAb,MAAA;EAAA;EAGD1B,aAAA,oBAAY,UAACI,OAAA,EAAmBoB,MAAA,EAAyD;IAAA,IAAzCgB,QAAA,GAAAC,SAAA,CAAApC,MAAA,QAAAoC,SAAA,QAAAC,SAAA,GAAAD,SAAA,MAA0B;IAChF,IAAIrC,OAAA,CAAQC,MAAA,KAAW,GAAG;IAE1B,IAAMsC,YAAA,GAA0C;IAAA,IAAAC,UAAA,GAAAd,0BAAA,CAE9B1B,OAAA;MAAAyC,MAAA;IAAA;MAAlB,KAAAD,UAAA,CAAAZ,CAAA,MAAAa,MAAA,GAAAD,UAAA,CAAAX,CAAA,IAAAC,IAAA,GAA2B;QAAA,IAAlB3B,KAAA,GAAAsC,MAAA,CAAAV,KAAA;QACPQ,YAAA,CAAapB,IAAA,CAAKzB,KAAA,CAAKgD,iBAAA,CAAkB1C,OAAA,EAASoB,MAAA,EAAQjB,KAAK,CAAC;MAClE;IAAA,SAAA8B,GAAA;MAAAO,UAAA,CAAAN,CAAA,CAAAD,GAAA;IAAA;MAAAO,UAAA,CAAAL,CAAA;IAAA;IAEI,IAAAb,MAAA,GAASiB,YAAA,CAAa,CAAC;IAE3B,SAAAI,EAAA,MAAAC,aAAA,GAAwBL,YAAA,EAAAI,EAAA,GAAAC,aAAA,CAAA3C,MAAA,EAAA0C,EAAA,IAAc;MAAtC,IAASE,WAAA,GAAAD,aAAA,CAAAD,EAAA;MACP,IAAIE,WAAA,CAAYrB,YAAA,CAAavB,MAAA,GAASqB,MAAA,CAAOE,YAAA,CAAavB,MAAA,EAAQ;QACvDqB,MAAA,GAAAuB,WAAA;MACX;IACF;IAEA,IAAIT,QAAA,IAAY,MAAM;MACpB1C,KAAA,CAAKoD,YAAA,CAAa3B,IAAA,CAAK;QACrBiB,QAAA,EAAAA,QAAA;QACApC,OAAA,EAASsB,MAAA,CAAOE;MAAA,CACjB;IACH;IAEI,IAAAF,MAAA,CAAOC,UAAA,CAAWtB,MAAA,EAAQ;MACvBP,KAAA,CAAAqD,SAAA,CAAUzB,MAAA,CAAOC,UAAA,EAAYH,MAAA,EAAQgB,QAAA,IAAYd,MAAA,CAAOE,YAAA,CAAa,CAAC,CAAC;IAC9E;EAAA;EAGK5B,aAAA,iBAAS,UAACoD,QAAA,EAA0BC,WAAA,EAA+D;IAAA,IAA1CC,cAAA,GAAAb,SAAA,CAAApC,MAAA,QAAAoC,SAAA,QAAAC,SAAA,GAAAD,SAAA,MAAiB;IAC/E,IAAIc,UAAA,GAAa;IAEb,IAAAH,QAAA,CAASI,UAAA,CAAW1C,MAAA,EAAQ;MACjByC,UAAA;MAEbH,QAAA,GAAWA,QAAA,CAASK,KAAA;MAEpB,IAAIH,cAAA,KAAmB,QAAQF,QAAA,CAAS7C,KAAA,KAAU,MAAM;QACjDT,KAAA,CAAA4D,UAAA,GAAaN,QAAA,CAASI,UAAA,CAAW1C,MAAA,CAAO6C,KAAA;MAC/C;MAEAP,QAAA,CAASQ,eAAA,CAAgB,QAAQ;IACnC;IAEI,IAAAR,QAAA,CAAS7C,KAAA,IAAS,MAAM;MAC1B,IAAIsD,mBAAA,KAAwB,QAAW;QAC/B;MACR;MAEWT,QAAA,GAAAU,aAAA,CAAkCV,QAAQ;IACvD;IAEKtD,KAAA,CAAAM,OAAA,GAAWgD,QAAA,CAAS7C,KAAA,CAA0BoD,KAAA;IACnD7D,KAAA,CAAKY,SAAA,GAAY0C,QAAA,CAASW,YAAA,CAAa,UAAU,EAAEJ,KAAA;IAEnD7D,KAAA,CAAKkE,cAAA,CAAe;IACpBlE,KAAA,CAAKmE,qBAAA,CAAsB;IAE3BnE,KAAA,CAAKoD,YAAA,GAAe;IAAA,IAAAgB,UAAA,GAAApC,0BAAA,CAEMhC,KAAA,CAAKuB,eAAA;MAAA8C,MAAA;IAAA;MAAtB,KAAAD,UAAA,CAAAlC,CAAA,MAAAmC,MAAA,GAAAD,UAAA,CAAAjC,CAAA,IAAAC,IAAA,GAAuC;QAAA,IAAvCkC,aAAA,GAAAD,MAAA,CAAAhC,KAAA;QACPrC,KAAA,CAAKqD,SAAA,CAAUiB,aAAA,EAAeC,IAAA,CAAKC,GAAA,CAAIjB,WAAW,IAAI,IAAK;MAC7D;IAAA,SAAAhB,GAAA;MAAA6B,UAAA,CAAA5B,CAAA,CAAAD,GAAA;IAAA;MAAA6B,UAAA,CAAA3B,CAAA;IAAA;IAEA,IAAMgC,aAAA,GAEF;IACJ,SAAAC,GAAA,MAAAC,YAAA,GAAiBC,MAAA,CAAOC,IAAA,CAAKvB,QAAA,CAASI,UAAU,GAAAgB,GAAA,GAAAC,YAAA,CAAApE,MAAA,EAAAmE,GAAA,IAAG;MAAnD,IAASI,IAAA,GAAAH,YAAA,CAAAD,GAAA;MACD,IAAAK,YAAA,GAAezB,QAAA,CAASI,UAAA,CAAWoB,IAAI;MAEvC,IAAAE,QAAA,GAAW,IAAID,YAAA,CAAalB,KAAA,CAAMoB,WAAA,EACrCjF,KAAA,CAAKM,OAAA,CAAQC,MAAA,GAASP,KAAA,CAAKoD,YAAA,CAAa7C,MAAA,IAAUwE,YAAA,CAAaG,QAAA;MAGzDF,QAAA,CAAArE,GAAA,CAAIoE,YAAA,CAAalB,KAAK;MACjBY,aAAA,CAAAK,IAAI,IAAI,IAAIK,eAAA,CAAgBH,QAAA,EAAUD,YAAA,CAAaG,QAAA,EAAUH,YAAA,CAAaK,UAAU;IACpG;IAEA,IAAMC,UAAA,GAAa,IAAIC,WAAA,CAAYtF,KAAA,CAAKM,OAAA,CAAQC,MAAM;IAC3C8E,UAAA,CAAA1E,GAAA,CAAIX,KAAA,CAAKM,OAAO;IAE3B,SAASE,CAAA,GAAI,GAAGA,CAAA,GAAIR,KAAA,CAAKoD,YAAA,CAAa7C,MAAA,EAAQC,CAAA,IAAK;MAC3C,IAAA+E,KAAA,GAAQvF,KAAA,CAAKoD,YAAA,CAAa5C,CAAC;MACjC,IAAMC,KAAA,GAAQT,KAAA,CAAKM,OAAA,CAAQiF,KAAA,CAAM7C,QAAQ;MAEzC,SAAA8C,GAAA,MAAAC,cAAA,GAAsBb,MAAA,CAAOc,MAAA,CAAOjB,aAAa,GAAAe,GAAA,GAAAC,cAAA,CAAAlF,MAAA,EAAAiF,GAAA,IAAG;QAApD,IAASG,SAAA,GAAAF,cAAA,CAAAD,GAAA;QACP,SAASrE,CAAA,GAAI,GAAGA,CAAA,GAAIwE,SAAA,CAAUT,QAAA,EAAU/D,CAAA,IAAK;UAE3CwE,SAAA,CAAU9B,KAAA,EAAO7D,KAAA,CAAKM,OAAA,CAAQC,MAAA,GAASC,CAAA,IAAKmF,SAAA,CAAUT,QAAA,GAAW/D,CAAC,IAChEwE,SAAA,CAAU9B,KAAA,CAAMpD,KAAA,GAAQkF,SAAA,CAAUT,QAAA,GAAW/D,CAAC;QAClD;MACF;MAAA,IAAAyE,UAAA,GAAA5D,0BAAA,CAEcuD,KAAA,CAAMjF,OAAA;QAAAuF,MAAA;MAAA;QAAX,KAAAD,UAAA,CAAA1D,CAAA,MAAA2D,MAAA,GAAAD,UAAA,CAAAzD,CAAA,IAAAC,IAAA,GAAoB;UAAA,IAApBjB,EAAA,GAAA0E,MAAA,CAAAxD,KAAA;UACPgD,UAAA,CAAWlE,EAAC,IAAInB,KAAA,CAAKM,OAAA,CAAQC,MAAA,GAASC,CAAA;QACxC;MAAA,SAAA+B,GAAA;QAAAqD,UAAA,CAAApD,CAAA,CAAAD,GAAA;MAAA;QAAAqD,UAAA,CAAAnD,CAAA;MAAA;IACF;IAEAa,QAAA,GAAW,IAAIwC,cAAA;IACfxC,QAAA,CAASyC,QAAA,CAAS,IAAIZ,eAAA,CAAgBE,UAAA,EAAY,CAAC,CAAC;IAEpD,SAAAW,GAAA,MAAAC,aAAA,GAAiBrB,MAAA,CAAOC,IAAA,CAAKJ,aAAa,GAAAuB,GAAA,GAAAC,aAAA,CAAA1F,MAAA,EAAAyF,GAAA,IAAG;MAA7C,IAASlB,KAAA,GAAAmB,aAAA,CAAAD,GAAA;MACP1C,QAAA,CAAS4C,YAAA,CAAapB,KAAA,EAAML,aAAA,CAAcK,KAAI,CAAC;IACjD;IAEA,IAAIrB,UAAA,EAAY;MACdH,QAAA,CAAS6C,oBAAA,CAAqB;MAE1B,IAAAnG,KAAA,CAAK4D,UAAA,KAAe,MAAM;QACtB,IAAAwC,cAAA,GAAiB,IAAI5E,KAAA,CAAMxB,KAAA,CAAK4D,UAAA,CAAWrD,MAAA,GAAS,CAAC,EAAE8F,IAAA,CAAK,KAAK;QAAA,IAAAC,UAAA,GAAAtE,0BAAA,CAEjDhC,KAAA,CAAKoD,YAAA;UAAAmD,MAAA;QAAA;UAA3B,KAAAD,UAAA,CAAApE,CAAA,MAAAqE,MAAA,GAAAD,UAAA,CAAAnE,CAAA,IAAAC,IAAA,GAAwD;YAAA,IAA/CoE,SAAA,GAAAD,MAAA,CAAAlE,KAAA;YAA+C+D,cAAA,CAAAI,SAAA,CAAU9D,QAAQ,IAAI;UAAA;QAAA,SAAAH,GAAA;UAAA+D,UAAA,CAAA9D,CAAA,CAAAD,GAAA;QAAA;UAAA+D,UAAA,CAAA7D,CAAA;QAAA;QAE9E,SAASjC,GAAA,GAAI,GAAGA,GAAA,GAAI4F,cAAA,CAAe7F,MAAA,EAAQC,GAAA,IAAK;UAC1C,IAAA4F,cAAA,CAAe5F,GAAC,MAAM,OAAO;YAC/B,SAASW,GAAA,GAAI,GAAGA,GAAA,GAAI,GAAGA,GAAA,IAAK;cAEjBmC,QAAA,CAAAI,UAAA,CAAW1C,MAAA,CAAO6C,KAAA,CAAM,IAAIrD,GAAA,GAAIW,GAAC,IAAInB,KAAA,CAAK4D,UAAA,CAAW,IAAIpD,GAAA,GAAIW,GAAC;YACzE;UACF;QACF;MACF;IACF;IAEO,OAAAmC,QAAA;EAAA;AAlMM"},"metadata":{},"sourceType":"module","externalDependencies":[]}