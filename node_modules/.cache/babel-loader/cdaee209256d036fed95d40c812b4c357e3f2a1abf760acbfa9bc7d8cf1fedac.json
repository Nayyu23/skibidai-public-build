{"ast":null,"code":"import _classCallCheck from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport { Scene, WebGLRenderTarget, FloatType, MeshPhongMaterial, MeshBasicMaterial, DoubleSide, PlaneGeometry, Mesh } from \"three\";\nimport potpack from \"potpack\";\nimport { UV1 } from \"../_polyfill/uv1.js\";\nvar ProgressiveLightMap = /*#__PURE__*/function () {\n  function ProgressiveLightMap(renderer) {\n    var _this = this;\n    var res = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1024;\n    _classCallCheck(this, ProgressiveLightMap);\n    this.renderer = renderer;\n    this.res = res;\n    this.lightMapContainers = [];\n    this.compiled = false;\n    this.scene = new Scene();\n    this.scene.background = null;\n    this.tinyTarget = new WebGLRenderTarget(1, 1);\n    this.buffer1Active = false;\n    this.firstUpdate = true;\n    this.warned = false;\n    var format = /(Android|iPad|iPhone|iPod)/g.test(navigator.userAgent) ? alfFloatType : FloatType;\n    this.progressiveLightMap1 = new WebGLRenderTarget(this.res, this.res, {\n      type: format\n    });\n    this.progressiveLightMap2 = new WebGLRenderTarget(this.res, this.res, {\n      type: format\n    });\n    this.uvMat = new MeshPhongMaterial();\n    this.uvMat.uniforms = {};\n    this.uvMat.onBeforeCompile = function (shader) {\n      shader.vertexShader = \"#define USE_LIGHTMAP\\n\" + shader.vertexShader.slice(0, -1) + \"\\tgl_Position = vec4((\".concat(UV1, \" - 0.5) * 2.0, 1.0, 1.0); }\");\n      var bodyStart = shader.fragmentShader.indexOf(\"void main() {\");\n      shader.fragmentShader = \"varying vec2 v\".concat(UV1 === \"uv1\" ? UV1 : \"Uv2\", \";\\n\") + shader.fragmentShader.slice(0, bodyStart) + \"\tuniform sampler2D previousShadowMap;\\n\tuniform float averagingWindow;\\n\" + shader.fragmentShader.slice(bodyStart - 1, -1) + \"\\nvec3 texelOld = texture2D(previousShadowMap, v\".concat(UV1 === \"uv1\" ? UV1 : \"Uv2\", \").rgb;\\n\\t\\t\\t\\tgl_FragColor.rgb = mix(texelOld, gl_FragColor.rgb, 1.0/averagingWindow);\\n\\t\\t\\t}\");\n      shader.uniforms.previousShadowMap = {\n        value: _this.progressiveLightMap1.texture\n      };\n      shader.uniforms.averagingWindow = {\n        value: 100\n      };\n      _this.uvMat.uniforms = shader.uniforms;\n      _this.uvMat.userData.shader = shader;\n      _this.compiled = true;\n    };\n  }\n  /**\n   * Sets these objects' materials' lightmaps and modifies their uv1's.\n   * @param {Object3D} objects An array of objects and lights to set up your lightmap.\n   */\n  _createClass(ProgressiveLightMap, [{\n    key: \"addObjectsToLightMap\",\n    value: function addObjectsToLightMap(objects) {\n      this.uv_boxes = [];\n      var padding = 3 / this.res;\n      for (var ob = 0; ob < objects.length; ob++) {\n        var object = objects[ob];\n        if (object.isLight) {\n          this.scene.attach(object);\n          continue;\n        }\n        if (!object.geometry.hasAttribute(\"uv\")) {\n          console.warn(\"All lightmap objects need UVs!\");\n          continue;\n        }\n        if (this.blurringPlane == null) {\n          this._initializeBlurPlane(this.res, this.progressiveLightMap1);\n        }\n        object.material.lightMap = this.progressiveLightMap2.texture;\n        object.material.dithering = true;\n        object.castShadow = true;\n        object.receiveShadow = true;\n        object.renderOrder = 1e3 + ob;\n        this.uv_boxes.push({\n          w: 1 + padding * 2,\n          h: 1 + padding * 2,\n          index: ob\n        });\n        this.lightMapContainers.push({\n          basicMat: object.material,\n          object: object\n        });\n        this.compiled = false;\n      }\n      var dimensions = potpack(this.uv_boxes);\n      this.uv_boxes.forEach(function (box) {\n        var uv1 = objects[box.index].geometry.getAttribute(\"uv\").clone();\n        for (var i = 0; i < uv1.array.length; i += uv1.itemSize) {\n          uv1.array[i] = (uv1.array[i] + box.x + padding) / dimensions.w;\n          uv1.array[i + 1] = (uv1.array[i + 1] + box.y + padding) / dimensions.h;\n        }\n        objects[box.index].geometry.setAttribute(UV1, uv1);\n        objects[box.index].geometry.getAttribute(UV1).needsUpdate = true;\n      });\n    }\n    /**\n     * This function renders each mesh one at a time into their respective surface maps\n     * @param {Camera} camera Standard Rendering Camera\n     * @param {number} blendWindow When >1, samples will accumulate over time.\n     * @param {boolean} blurEdges  Whether to fix UV Edges via blurring\n     */\n  }, {\n    key: \"update\",\n    value: function update(camera) {\n      var blendWindow = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 100;\n      var blurEdges = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n      if (this.blurringPlane == null) {\n        return;\n      }\n      var oldTarget = this.renderer.getRenderTarget();\n      this.blurringPlane.visible = blurEdges;\n      for (var l = 0; l < this.lightMapContainers.length; l++) {\n        this.lightMapContainers[l].object.oldScene = this.lightMapContainers[l].object.parent;\n        this.scene.attach(this.lightMapContainers[l].object);\n      }\n      if (this.firstUpdate) {\n        this.renderer.setRenderTarget(this.tinyTarget);\n        this.renderer.render(this.scene, camera);\n        this.firstUpdate = false;\n      }\n      for (var _l = 0; _l < this.lightMapContainers.length; _l++) {\n        this.uvMat.uniforms.averagingWindow = {\n          value: blendWindow\n        };\n        this.lightMapContainers[_l].object.material = this.uvMat;\n        this.lightMapContainers[_l].object.oldFrustumCulled = this.lightMapContainers[_l].object.frustumCulled;\n        this.lightMapContainers[_l].object.frustumCulled = false;\n      }\n      var activeMap = this.buffer1Active ? this.progressiveLightMap1 : this.progressiveLightMap2;\n      var inactiveMap = this.buffer1Active ? this.progressiveLightMap2 : this.progressiveLightMap1;\n      this.renderer.setRenderTarget(activeMap);\n      this.uvMat.uniforms.previousShadowMap = {\n        value: inactiveMap.texture\n      };\n      this.blurringPlane.material.uniforms.previousShadowMap = {\n        value: inactiveMap.texture\n      };\n      this.buffer1Active = !this.buffer1Active;\n      this.renderer.render(this.scene, camera);\n      for (var _l2 = 0; _l2 < this.lightMapContainers.length; _l2++) {\n        this.lightMapContainers[_l2].object.frustumCulled = this.lightMapContainers[_l2].object.oldFrustumCulled;\n        this.lightMapContainers[_l2].object.material = this.lightMapContainers[_l2].basicMat;\n        this.lightMapContainers[_l2].object.oldScene.attach(this.lightMapContainers[_l2].object);\n      }\n      this.renderer.setRenderTarget(oldTarget);\n    }\n    /** DEBUG\n     * Draw the lightmap in the main scene.  Call this after adding the objects to it.\n     * @param {boolean} visible Whether the debug plane should be visible\n     * @param {Vector3} position Where the debug plane should be drawn\n     */\n  }, {\n    key: \"showDebugLightmap\",\n    value: function showDebugLightmap(visible) {\n      var position = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : void 0;\n      if (this.lightMapContainers.length == 0) {\n        if (!this.warned) {\n          console.warn(\"Call this after adding the objects!\");\n          this.warned = true;\n        }\n        return;\n      }\n      if (this.labelMesh == null) {\n        this.labelMaterial = new MeshBasicMaterial({\n          map: this.progressiveLightMap1.texture,\n          side: DoubleSide\n        });\n        this.labelPlane = new PlaneGeometry(100, 100);\n        this.labelMesh = new Mesh(this.labelPlane, this.labelMaterial);\n        this.labelMesh.position.y = 250;\n        this.lightMapContainers[0].object.parent.add(this.labelMesh);\n      }\n      if (position != void 0) {\n        this.labelMesh.position.copy(position);\n      }\n      this.labelMesh.visible = visible;\n    }\n    /**\n     * INTERNAL Creates the Blurring Plane\n     * @param {number} res The square resolution of this object's lightMap.\n     * @param {WebGLRenderTexture} lightMap The lightmap to initialize the plane with.\n     */\n  }, {\n    key: \"_initializeBlurPlane\",\n    value: function _initializeBlurPlane(res) {\n      var _this2 = this;\n      var lightMap = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      var blurMaterial = new MeshBasicMaterial();\n      blurMaterial.uniforms = {\n        previousShadowMap: {\n          value: null\n        },\n        pixelOffset: {\n          value: 1 / res\n        },\n        polygonOffset: true,\n        polygonOffsetFactor: -1,\n        polygonOffsetUnits: 3\n      };\n      blurMaterial.onBeforeCompile = function (shader) {\n        shader.vertexShader = \"#define USE_UV\\n\" + shader.vertexShader.slice(0, -1) + \"\tgl_Position = vec4((uv - 0.5) * 2.0, 1.0, 1.0); }\";\n        var bodyStart = shader.fragmentShader.indexOf(\"void main() {\");\n        shader.fragmentShader = \"#define USE_UV\\n\" + shader.fragmentShader.slice(0, bodyStart) + \"\tuniform sampler2D previousShadowMap;\\n\tuniform float pixelOffset;\\n\" + shader.fragmentShader.slice(bodyStart - 1, -1) + \"\\tgl_FragColor.rgb = (\\n\\t\\t\\t  texture2D(previousShadowMap, vUv + vec2( pixelOffset,  0.0        )).rgb +\\n\\t\\t\\t  texture2D(previousShadowMap, vUv + vec2( 0.0        ,  pixelOffset)).rgb +\\n\\t\\t\\t  texture2D(previousShadowMap, vUv + vec2( 0.0        , -pixelOffset)).rgb +\\n\\t\\t\\t  texture2D(previousShadowMap, vUv + vec2(-pixelOffset,  0.0        )).rgb +\\n\\t\\t\\t  texture2D(previousShadowMap, vUv + vec2( pixelOffset,  pixelOffset)).rgb +\\n\\t\\t\\t  texture2D(previousShadowMap, vUv + vec2(-pixelOffset,  pixelOffset)).rgb +\\n\\t\\t\\t  texture2D(previousShadowMap, vUv + vec2( pixelOffset, -pixelOffset)).rgb +\\n\\t\\t\\t  texture2D(previousShadowMap, vUv + vec2(-pixelOffset, -pixelOffset)).rgb)/8.0;\\n\\t\\t}\";\n        shader.uniforms.previousShadowMap = {\n          value: lightMap.texture\n        };\n        shader.uniforms.pixelOffset = {\n          value: 0.5 / res\n        };\n        blurMaterial.uniforms = shader.uniforms;\n        blurMaterial.userData.shader = shader;\n        _this2.compiled = true;\n      };\n      this.blurringPlane = new Mesh(new PlaneGeometry(1, 1), blurMaterial);\n      this.blurringPlane.name = \"Blurring Plane\";\n      this.blurringPlane.frustumCulled = false;\n      this.blurringPlane.renderOrder = 0;\n      this.blurringPlane.material.depthWrite = false;\n      this.scene.add(this.blurringPlane);\n    }\n  }]);\n  return ProgressiveLightMap;\n}();\nexport { ProgressiveLightMap };","map":{"version":3,"names":["ProgressiveLightMap","renderer","_this","res","arguments","length","undefined","_classCallCheck","lightMapContainers","compiled","scene","Scene","background","tinyTarget","WebGLRenderTarget","buffer1Active","firstUpdate","warned","format","test","navigator","userAgent","alfFloatType","FloatType","progressiveLightMap1","type","progressiveLightMap2","uvMat","MeshPhongMaterial","uniforms","onBeforeCompile","shader","vertexShader","slice","concat","UV1","bodyStart","fragmentShader","indexOf","previousShadowMap","value","texture","averagingWindow","userData","_createClass","key","addObjectsToLightMap","objects","uv_boxes","padding","ob","object","isLight","attach","geometry","hasAttribute","console","warn","blurringPlane","_initializeBlurPlane","material","lightMap","dithering","castShadow","receiveShadow","renderOrder","push","w","h","index","basicMat","dimensions","potpack","forEach","box","uv1","getAttribute","clone","i","array","itemSize","x","y","setAttribute","needsUpdate","update","camera","blendWindow","blurEdges","oldTarget","getRenderTarget","visible","l","oldScene","parent","setRenderTarget","render","oldFrustumCulled","frustumCulled","activeMap","inactiveMap","showDebugLightmap","position","labelMesh","labelMaterial","MeshBasicMaterial","map","side","DoubleSide","labelPlane","PlaneGeometry","Mesh","add","copy","_this2","blurMaterial","pixelOffset","polygonOffset","polygonOffsetFactor","polygonOffsetUnits","name","depthWrite"],"sources":["C:\\Users\\Nayyu\\Desktop\\skibidai-public-build\\node_modules\\src\\misc\\ProgressiveLightmap.js"],"sourcesContent":["import {\n  Scene,\n  WebGLRenderTarget,\n  FloatType,\n  MeshBasicMaterial,\n  MeshPhongMaterial,\n  DoubleSide,\n  PlaneGeometry,\n  Mesh,\n} from 'three'\nimport potpack from 'potpack'\nimport { UV1 } from '../_polyfill/uv1'\n\n/**\n * Progressive Light Map Accumulator, by [zalo](https://github.com/zalo/)\n *\n * To use, simply construct a `ProgressiveLightMap` object,\n * `plmap.addObjectsToLightMap(object)` an array of semi-static\n * objects and lights to the class once, and then call\n * `plmap.update(camera)` every frame to begin accumulating\n * lighting samples.\n *\n * This should begin accumulating lightmaps which apply to\n * your objects, so you can start jittering lighting to achieve\n * the texture-space effect you're looking for.\n *\n * @param {WebGLRenderer} renderer A WebGL Rendering Context\n * @param {number} res The side-long dimension of you total lightmap\n */\nclass ProgressiveLightMap {\n  constructor(renderer, res = 1024) {\n    this.renderer = renderer\n    this.res = res\n    this.lightMapContainers = []\n    this.compiled = false\n    this.scene = new Scene()\n    this.scene.background = null\n    this.tinyTarget = new WebGLRenderTarget(1, 1)\n    this.buffer1Active = false\n    this.firstUpdate = true\n    this.warned = false\n\n    // Create the Progressive LightMap Texture\n    const format = /(Android|iPad|iPhone|iPod)/g.test(navigator.userAgent) ? alfFloatType : FloatType\n    this.progressiveLightMap1 = new WebGLRenderTarget(this.res, this.res, { type: format })\n    this.progressiveLightMap2 = new WebGLRenderTarget(this.res, this.res, { type: format })\n\n    // Inject some spicy new logic into a standard phong material\n    this.uvMat = new MeshPhongMaterial()\n    this.uvMat.uniforms = {}\n    this.uvMat.onBeforeCompile = (shader) => {\n      // Vertex Shader: Set Vertex Positions to the Unwrapped UV Positions\n      shader.vertexShader =\n        '#define USE_LIGHTMAP\\n' +\n        shader.vertexShader.slice(0, -1) +\n        `\tgl_Position = vec4((${UV1} - 0.5) * 2.0, 1.0, 1.0); }`\n\n      // Fragment Shader: Set Pixels to average in the Previous frame's Shadows\n      const bodyStart = shader.fragmentShader.indexOf('void main() {')\n      shader.fragmentShader =\n        `varying vec2 v${UV1 === 'uv1' ? UV1 : 'Uv2'};\\n` +\n        shader.fragmentShader.slice(0, bodyStart) +\n        '\tuniform sampler2D previousShadowMap;\\n\tuniform float averagingWindow;\\n' +\n        shader.fragmentShader.slice(bodyStart - 1, -1) +\n        `\\nvec3 texelOld = texture2D(previousShadowMap, v${UV1 === 'uv1' ? UV1 : 'Uv2'}).rgb;\n\t\t\t\tgl_FragColor.rgb = mix(texelOld, gl_FragColor.rgb, 1.0/averagingWindow);\n\t\t\t}`\n\n      // Set the Previous Frame's Texture Buffer and Averaging Window\n      shader.uniforms.previousShadowMap = { value: this.progressiveLightMap1.texture }\n      shader.uniforms.averagingWindow = { value: 100 }\n\n      this.uvMat.uniforms = shader.uniforms\n\n      // Set the new Shader to this\n      this.uvMat.userData.shader = shader\n\n      this.compiled = true\n    }\n  }\n\n  /**\n   * Sets these objects' materials' lightmaps and modifies their uv1's.\n   * @param {Object3D} objects An array of objects and lights to set up your lightmap.\n   */\n  addObjectsToLightMap(objects) {\n    // Prepare list of UV bounding boxes for packing later...\n    this.uv_boxes = []\n    const padding = 3 / this.res\n\n    for (let ob = 0; ob < objects.length; ob++) {\n      const object = objects[ob]\n\n      // If this object is a light, simply add it to the internal scene\n      if (object.isLight) {\n        this.scene.attach(object)\n        continue\n      }\n\n      if (!object.geometry.hasAttribute('uv')) {\n        console.warn('All lightmap objects need UVs!')\n        continue\n      }\n\n      if (this.blurringPlane == null) {\n        this._initializeBlurPlane(this.res, this.progressiveLightMap1)\n      }\n\n      // Apply the lightmap to the object\n      object.material.lightMap = this.progressiveLightMap2.texture\n      object.material.dithering = true\n      object.castShadow = true\n      object.receiveShadow = true\n      object.renderOrder = 1000 + ob\n\n      // Prepare UV boxes for potpack\n      // TODO: Size these by object surface area\n      this.uv_boxes.push({ w: 1 + padding * 2, h: 1 + padding * 2, index: ob })\n\n      this.lightMapContainers.push({ basicMat: object.material, object: object })\n\n      this.compiled = false\n    }\n\n    // Pack the objects' lightmap UVs into the same global space\n    const dimensions = potpack(this.uv_boxes)\n    this.uv_boxes.forEach((box) => {\n      const uv1 = objects[box.index].geometry.getAttribute('uv').clone()\n      for (let i = 0; i < uv1.array.length; i += uv1.itemSize) {\n        uv1.array[i] = (uv1.array[i] + box.x + padding) / dimensions.w\n        uv1.array[i + 1] = (uv1.array[i + 1] + box.y + padding) / dimensions.h\n      }\n\n      objects[box.index].geometry.setAttribute(UV1, uv1)\n      objects[box.index].geometry.getAttribute(UV1).needsUpdate = true\n    })\n  }\n\n  /**\n   * This function renders each mesh one at a time into their respective surface maps\n   * @param {Camera} camera Standard Rendering Camera\n   * @param {number} blendWindow When >1, samples will accumulate over time.\n   * @param {boolean} blurEdges  Whether to fix UV Edges via blurring\n   */\n  update(camera, blendWindow = 100, blurEdges = true) {\n    if (this.blurringPlane == null) {\n      return\n    }\n\n    // Store the original Render Target\n    const oldTarget = this.renderer.getRenderTarget()\n\n    // The blurring plane applies blur to the seams of the lightmap\n    this.blurringPlane.visible = blurEdges\n\n    // Steal the Object3D from the real world to our special dimension\n    for (let l = 0; l < this.lightMapContainers.length; l++) {\n      this.lightMapContainers[l].object.oldScene = this.lightMapContainers[l].object.parent\n      this.scene.attach(this.lightMapContainers[l].object)\n    }\n\n    // Render once normally to initialize everything\n    if (this.firstUpdate) {\n      this.renderer.setRenderTarget(this.tinyTarget) // Tiny for Speed\n      this.renderer.render(this.scene, camera)\n      this.firstUpdate = false\n    }\n\n    // Set each object's material to the UV Unwrapped Surface Mapping Version\n    for (let l = 0; l < this.lightMapContainers.length; l++) {\n      this.uvMat.uniforms.averagingWindow = { value: blendWindow }\n      this.lightMapContainers[l].object.material = this.uvMat\n      this.lightMapContainers[l].object.oldFrustumCulled = this.lightMapContainers[l].object.frustumCulled\n      this.lightMapContainers[l].object.frustumCulled = false\n    }\n\n    // Ping-pong two surface buffers for reading/writing\n    const activeMap = this.buffer1Active ? this.progressiveLightMap1 : this.progressiveLightMap2\n    const inactiveMap = this.buffer1Active ? this.progressiveLightMap2 : this.progressiveLightMap1\n\n    // Render the object's surface maps\n    this.renderer.setRenderTarget(activeMap)\n    this.uvMat.uniforms.previousShadowMap = { value: inactiveMap.texture }\n    this.blurringPlane.material.uniforms.previousShadowMap = { value: inactiveMap.texture }\n    this.buffer1Active = !this.buffer1Active\n    this.renderer.render(this.scene, camera)\n\n    // Restore the object's Real-time Material and add it back to the original world\n    for (let l = 0; l < this.lightMapContainers.length; l++) {\n      this.lightMapContainers[l].object.frustumCulled = this.lightMapContainers[l].object.oldFrustumCulled\n      this.lightMapContainers[l].object.material = this.lightMapContainers[l].basicMat\n      this.lightMapContainers[l].object.oldScene.attach(this.lightMapContainers[l].object)\n    }\n\n    // Restore the original Render Target\n    this.renderer.setRenderTarget(oldTarget)\n  }\n\n  /** DEBUG\n   * Draw the lightmap in the main scene.  Call this after adding the objects to it.\n   * @param {boolean} visible Whether the debug plane should be visible\n   * @param {Vector3} position Where the debug plane should be drawn\n   */\n  showDebugLightmap(visible, position = undefined) {\n    if (this.lightMapContainers.length == 0) {\n      if (!this.warned) {\n        console.warn('Call this after adding the objects!')\n        this.warned = true\n      }\n\n      return\n    }\n\n    if (this.labelMesh == null) {\n      this.labelMaterial = new MeshBasicMaterial({\n        map: this.progressiveLightMap1.texture,\n        side: DoubleSide,\n      })\n      this.labelPlane = new PlaneGeometry(100, 100)\n      this.labelMesh = new Mesh(this.labelPlane, this.labelMaterial)\n      this.labelMesh.position.y = 250\n      this.lightMapContainers[0].object.parent.add(this.labelMesh)\n    }\n\n    if (position != undefined) {\n      this.labelMesh.position.copy(position)\n    }\n\n    this.labelMesh.visible = visible\n  }\n\n  /**\n   * INTERNAL Creates the Blurring Plane\n   * @param {number} res The square resolution of this object's lightMap.\n   * @param {WebGLRenderTexture} lightMap The lightmap to initialize the plane with.\n   */\n  _initializeBlurPlane(res, lightMap = null) {\n    const blurMaterial = new MeshBasicMaterial()\n    blurMaterial.uniforms = {\n      previousShadowMap: { value: null },\n      pixelOffset: { value: 1.0 / res },\n      polygonOffset: true,\n      polygonOffsetFactor: -1,\n      polygonOffsetUnits: 3.0,\n    }\n    blurMaterial.onBeforeCompile = (shader) => {\n      // Vertex Shader: Set Vertex Positions to the Unwrapped UV Positions\n      shader.vertexShader =\n        '#define USE_UV\\n' + shader.vertexShader.slice(0, -1) + '\tgl_Position = vec4((uv - 0.5) * 2.0, 1.0, 1.0); }'\n\n      // Fragment Shader: Set Pixels to 9-tap box blur the current frame's Shadows\n      const bodyStart = shader.fragmentShader.indexOf('void main() {')\n      shader.fragmentShader =\n        '#define USE_UV\\n' +\n        shader.fragmentShader.slice(0, bodyStart) +\n        '\tuniform sampler2D previousShadowMap;\\n\tuniform float pixelOffset;\\n' +\n        shader.fragmentShader.slice(bodyStart - 1, -1) +\n        `\tgl_FragColor.rgb = (\n\t\t\t  texture2D(previousShadowMap, vUv + vec2( pixelOffset,  0.0        )).rgb +\n\t\t\t  texture2D(previousShadowMap, vUv + vec2( 0.0        ,  pixelOffset)).rgb +\n\t\t\t  texture2D(previousShadowMap, vUv + vec2( 0.0        , -pixelOffset)).rgb +\n\t\t\t  texture2D(previousShadowMap, vUv + vec2(-pixelOffset,  0.0        )).rgb +\n\t\t\t  texture2D(previousShadowMap, vUv + vec2( pixelOffset,  pixelOffset)).rgb +\n\t\t\t  texture2D(previousShadowMap, vUv + vec2(-pixelOffset,  pixelOffset)).rgb +\n\t\t\t  texture2D(previousShadowMap, vUv + vec2( pixelOffset, -pixelOffset)).rgb +\n\t\t\t  texture2D(previousShadowMap, vUv + vec2(-pixelOffset, -pixelOffset)).rgb)/8.0;\n\t\t}`\n\n      // Set the LightMap Accumulation Buffer\n      shader.uniforms.previousShadowMap = { value: lightMap.texture }\n      shader.uniforms.pixelOffset = { value: 0.5 / res }\n      blurMaterial.uniforms = shader.uniforms\n\n      // Set the new Shader to this\n      blurMaterial.userData.shader = shader\n\n      this.compiled = true\n    }\n\n    this.blurringPlane = new Mesh(new PlaneGeometry(1, 1), blurMaterial)\n    this.blurringPlane.name = 'Blurring Plane'\n    this.blurringPlane.frustumCulled = false\n    this.blurringPlane.renderOrder = 0\n    this.blurringPlane.material.depthWrite = false\n    this.scene.add(this.blurringPlane)\n  }\n}\n\nexport { ProgressiveLightMap }\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}