{"ast":null,"code":"import _classCallCheck from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _inherits from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport { Loader, FileLoader, LoaderUtils, SkinnedMesh, Skeleton, Bone, Vector3, Float32BufferAttribute, BufferGeometry, Uint16BufferAttribute, TextureLoader, Color, MultiplyOperation, AddOperation, MeshToonMaterial, NearestFilter, RepeatWrapping, AnimationClip, VectorKeyframeTrack, QuaternionKeyframeTrack, NumberKeyframeTrack, Quaternion, Euler, Interpolant, CustomBlending, SrcAlphaFactor, OneMinusSrcAlphaFactor, DstAlphaFactor, DoubleSide, FrontSide } from \"three\";\nimport { TGALoader } from \"./TGALoader.js\";\nimport { Parser } from \"../libs/mmdparser.js\";\nvar MMDLoader = /*#__PURE__*/function (_Loader) {\n  _inherits(MMDLoader, _Loader);\n  var _super = _createSuper(MMDLoader);\n  function MMDLoader(manager) {\n    var _this;\n    _classCallCheck(this, MMDLoader);\n    _this = _super.call(this, manager);\n    _this.loader = new FileLoader(_this.manager);\n    _this.parser = null;\n    _this.meshBuilder = new MeshBuilder(_this.manager);\n    _this.animationBuilder = new AnimationBuilder();\n    return _this;\n  }\n  /**\n   * @param {string} animationPath\n   * @return {MMDLoader}\n   */\n  _createClass(MMDLoader, [{\n    key: \"setAnimationPath\",\n    value: function setAnimationPath(animationPath) {\n      this.animationPath = animationPath;\n      return this;\n    }\n    // Load MMD assets as Three.js Object\n    /**\n     * Loads Model file (.pmd or .pmx) as a SkinnedMesh.\n     *\n     * @param {string} url - url to Model(.pmd or .pmx) file\n     * @param {function} onLoad\n     * @param {function} onProgress\n     * @param {function} onError\n     */\n  }, {\n    key: \"load\",\n    value: function load(url, onLoad, onProgress, onError) {\n      var builder = this.meshBuilder.setCrossOrigin(this.crossOrigin);\n      var resourcePath;\n      if (this.resourcePath !== \"\") {\n        resourcePath = this.resourcePath;\n      } else if (this.path !== \"\") {\n        resourcePath = this.path;\n      } else {\n        resourcePath = LoaderUtils.extractUrlBase(url);\n      }\n      var modelExtension = this._extractExtension(url).toLowerCase();\n      if (modelExtension !== \"pmd\" && modelExtension !== \"pmx\") {\n        if (onError) onError(new Error(\"THREE.MMDLoader: Unknown model file extension .\" + modelExtension + \".\"));\n        return;\n      }\n      this[modelExtension === \"pmd\" ? \"loadPMD\" : \"loadPMX\"](url, function (data) {\n        onLoad(builder.build(data, resourcePath, onProgress, onError));\n      }, onProgress, onError);\n    }\n    /**\n     * Loads Motion file(s) (.vmd) as a AnimationClip.\n     * If two or more files are specified, they'll be merged.\n     *\n     * @param {string|Array<string>} url - url(s) to animation(.vmd) file(s)\n     * @param {SkinnedMesh|THREE.Camera} object - tracks will be fitting to this object\n     * @param {function} onLoad\n     * @param {function} onProgress\n     * @param {function} onError\n     */\n  }, {\n    key: \"loadAnimation\",\n    value: function loadAnimation(url, object, onLoad, onProgress, onError) {\n      var builder = this.animationBuilder;\n      this.loadVMD(url, function (vmd) {\n        onLoad(object.isCamera ? builder.buildCameraAnimation(vmd) : builder.build(vmd, object));\n      }, onProgress, onError);\n    }\n    /**\n     * Loads mode file and motion file(s) as an object containing\n     * a SkinnedMesh and a AnimationClip.\n     * Tracks of AnimationClip are fitting to the model.\n     *\n     * @param {string} modelUrl - url to Model(.pmd or .pmx) file\n     * @param {string|Array{string}} vmdUrl - url(s) to animation(.vmd) file\n     * @param {function} onLoad\n     * @param {function} onProgress\n     * @param {function} onError\n     */\n  }, {\n    key: \"loadWithAnimation\",\n    value: function loadWithAnimation(modelUrl, vmdUrl, onLoad, onProgress, onError) {\n      var scope = this;\n      this.load(modelUrl, function (mesh) {\n        scope.loadAnimation(vmdUrl, mesh, function (animation) {\n          onLoad({\n            mesh: mesh,\n            animation: animation\n          });\n        }, onProgress, onError);\n      }, onProgress, onError);\n    }\n    // Load MMD assets as Object data parsed by MMDParser\n    /**\n     * Loads .pmd file as an Object.\n     *\n     * @param {string} url - url to .pmd file\n     * @param {function} onLoad\n     * @param {function} onProgress\n     * @param {function} onError\n     */\n  }, {\n    key: \"loadPMD\",\n    value: function loadPMD(url, onLoad, onProgress, onError) {\n      var parser = this._getParser();\n      this.loader.setMimeType(void 0).setPath(this.path).setResponseType(\"arraybuffer\").setRequestHeader(this.requestHeader).setWithCredentials(this.withCredentials).load(url, function (buffer) {\n        onLoad(parser.parsePmd(buffer, true));\n      }, onProgress, onError);\n    }\n    /**\n     * Loads .pmx file as an Object.\n     *\n     * @param {string} url - url to .pmx file\n     * @param {function} onLoad\n     * @param {function} onProgress\n     * @param {function} onError\n     */\n  }, {\n    key: \"loadPMX\",\n    value: function loadPMX(url, onLoad, onProgress, onError) {\n      var parser = this._getParser();\n      this.loader.setMimeType(void 0).setPath(this.path).setResponseType(\"arraybuffer\").setRequestHeader(this.requestHeader).setWithCredentials(this.withCredentials).load(url, function (buffer) {\n        onLoad(parser.parsePmx(buffer, true));\n      }, onProgress, onError);\n    }\n    /**\n     * Loads .vmd file as an Object. If two or more files are specified\n     * they'll be merged.\n     *\n     * @param {string|Array<string>} url - url(s) to .vmd file(s)\n     * @param {function} onLoad\n     * @param {function} onProgress\n     * @param {function} onError\n     */\n  }, {\n    key: \"loadVMD\",\n    value: function loadVMD(url, onLoad, onProgress, onError) {\n      var urls = Array.isArray(url) ? url : [url];\n      var vmds = [];\n      var vmdNum = urls.length;\n      var parser = this._getParser();\n      this.loader.setMimeType(void 0).setPath(this.animationPath).setResponseType(\"arraybuffer\").setRequestHeader(this.requestHeader).setWithCredentials(this.withCredentials);\n      for (var i = 0, il = urls.length; i < il; i++) {\n        this.loader.load(urls[i], function (buffer) {\n          vmds.push(parser.parseVmd(buffer, true));\n          if (vmds.length === vmdNum) onLoad(parser.mergeVmds(vmds));\n        }, onProgress, onError);\n      }\n    }\n    /**\n     * Loads .vpd file as an Object.\n     *\n     * @param {string} url - url to .vpd file\n     * @param {boolean} isUnicode\n     * @param {function} onLoad\n     * @param {function} onProgress\n     * @param {function} onError\n     */\n  }, {\n    key: \"loadVPD\",\n    value: function loadVPD(url, isUnicode, onLoad, onProgress, onError) {\n      var parser = this._getParser();\n      this.loader.setMimeType(isUnicode ? void 0 : \"text/plain; charset=shift_jis\").setPath(this.animationPath).setResponseType(\"text\").setRequestHeader(this.requestHeader).setWithCredentials(this.withCredentials).load(url, function (text) {\n        onLoad(parser.parseVpd(text, true));\n      }, onProgress, onError);\n    }\n    // private methods\n  }, {\n    key: \"_extractExtension\",\n    value: function _extractExtension(url) {\n      var index = url.lastIndexOf(\".\");\n      return index < 0 ? \"\" : url.slice(index + 1);\n    }\n  }, {\n    key: \"_getParser\",\n    value: function _getParser() {\n      if (this.parser === null) {\n        this.parser = new Parser();\n      }\n      return this.parser;\n    }\n  }]);\n  return MMDLoader;\n}(Loader);\nvar DEFAULT_TOON_TEXTURES = [\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAL0lEQVRYR+3QQREAAAzCsOFfNJPBJ1XQS9r2hsUAAQIECBAgQIAAAQIECBAgsBZ4MUx/ofm2I/kAAAAASUVORK5CYII=\", \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAN0lEQVRYR+3WQREAMBACsZ5/bWiiMvgEBTt5cW37hjsBBAgQIECAwFwgyfYPCCBAgAABAgTWAh8aBHZBl14e8wAAAABJRU5ErkJggg==\", \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAOUlEQVRYR+3WMREAMAwDsYY/yoDI7MLwIiP40+RJklfcCCBAgAABAgTqArfb/QMCCBAgQIAAgbbAB3z/e0F3js2cAAAAAElFTkSuQmCC\", \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAN0lEQVRYR+3WQREAMBACsZ5/B5ilMvgEBTt5cW37hjsBBAgQIECAwFwgyfYPCCBAgAABAgTWAh81dWyx0gFwKAAAAABJRU5ErkJggg==\", \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAOklEQVRYR+3WoREAMAwDsWb/UQtCy9wxTOQJ/oQ8SXKKGwEECBAgQIBAXeDt7f4BAQQIECBAgEBb4AOz8Hzx7WLY4wAAAABJRU5ErkJggg==\", \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAABPUlEQVRYR+1XwW7CMAy1+f9fZOMysSEOEweEOPRNdm3HbdOyIhAcklPrOs/PLy9RygBALxzcCDQFmgJNgaZAU6Ap0BR4PwX8gsRMVLssMRH5HcpzJEaWL7EVg9F1IHRlyqQohgVr4FGUlUcMJSjcUlDw0zvjeun70cLWmneoyf7NgBTQSniBTQQSuJAZsOnnaczjIMb5hCiuHKxokCrJfVnrctyZL0PkJAJe1HMil4nxeyi3Ypfn1kX51jpPvo/JeCNC4PhVdHdJw2XjBR8brF8PEIhNVn12AgP7uHsTBguBn53MUZCqv7Lp07Pn5k1Ro+uWmUNn7D+M57rtk7aG0Vo73xyF/fbFf0bPJjDXngnGocDTdFhygZjwUQrMNrDcmZlQT50VJ/g/UwNyHpu778+yW+/ksOz/BFo54P4AsUXMfRq7XWsAAAAASUVORK5CYII=\", \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAACMElEQVRYR+2Xv4pTQRTGf2dubhLdICiii2KnYKHVolhauKWPoGAnNr6BD6CvIVaihYuI2i1ia0BY0MZGRHQXjZj/mSPnnskfNWiWZUlzJ5k7M2cm833nO5Mziej2DWWJRUoCpQKlAntSQCqgw39/iUWAGmh37jrRnVsKlgpiqmkoGVABA7E57fvY+pJDdgKqF6HzFCSADkDq+F6AHABtQ+UMVE5D7zXod7fFNhTEckTbj5XQgHzNN+5tQvc5NG7C6BNkp6D3EmpXHDR+dQAjFLchW3VS9rlw3JBh+B7ys5Cf9z0GW1C/7P32AyBAOAz1q4jGliIH3YPuBnSfQX4OGreTIgEYQb/pBDtPnEQ4CivXYPAWBk13oHrB54yA9QuSn2H4AcKRpEILDt0BUzj+RLR1V5EqjD66NPRBVpLcQwjHoHYJOhsQv6U4mnzmrIXJCFr4LDwm/xBUoboG9XX4cc9VKdYoSA2yk5NQLJaKDUjTBoveG3Z2TElTxwjNK4M3LEZgUdDdruvcXzKBpStgp2NPiWi3ks9ZXxIoFVi+AvHLdc9TqtjL3/aYjpPlrzOcEnK62Szhimdd7xX232zFDTgtxezOu3WNMRLjiKgjtOhHVMd1loynVHvOgjuIIJMaELEqhJAV/RCSLbWTcfPFakFgFlALTRRvx+ok6Hlp/Q+v3fmx90bMyUzaEAhmM3KvHlXTL5DxnbGf/1M8RNNACLL5MNtPxP/mypJAqcDSFfgFhpYqWUzhTEAAAAAASUVORK5CYII=\", \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAL0lEQVRYR+3QQREAAAzCsOFfNJPBJ1XQS9r2hsUAAQIECBAgQIAAAQIECBAgsBZ4MUx/ofm2I/kAAAAASUVORK5CYII=\", \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAL0lEQVRYR+3QQREAAAzCsOFfNJPBJ1XQS9r2hsUAAQIECBAgQIAAAQIECBAgsBZ4MUx/ofm2I/kAAAAASUVORK5CYII=\", \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAL0lEQVRYR+3QQREAAAzCsOFfNJPBJ1XQS9r2hsUAAQIECBAgQIAAAQIECBAgsBZ4MUx/ofm2I/kAAAAASUVORK5CYII=\", \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAL0lEQVRYR+3QQREAAAzCsOFfNJPBJ1XQS9r2hsUAAQIECBAgQIAAAQIECBAgsBZ4MUx/ofm2I/kAAAAASUVORK5CYII=\"];\nvar MeshBuilder = /*#__PURE__*/function () {\n  function MeshBuilder(manager) {\n    _classCallCheck(this, MeshBuilder);\n    this.crossOrigin = \"anonymous\";\n    this.geometryBuilder = new GeometryBuilder();\n    this.materialBuilder = new MaterialBuilder(manager);\n  }\n  /**\n   * @param {string} crossOrigin\n   * @return {MeshBuilder}\n   */\n  _createClass(MeshBuilder, [{\n    key: \"setCrossOrigin\",\n    value: function setCrossOrigin(crossOrigin) {\n      this.crossOrigin = crossOrigin;\n      return this;\n    }\n    /**\n     * @param {Object} data - parsed PMD/PMX data\n     * @param {string} resourcePath\n     * @param {function} onProgress\n     * @param {function} onError\n     * @return {SkinnedMesh}\n     */\n  }, {\n    key: \"build\",\n    value: function build(data, resourcePath, onProgress, onError) {\n      var geometry = this.geometryBuilder.build(data);\n      var material = this.materialBuilder.setCrossOrigin(this.crossOrigin).setResourcePath(resourcePath).build(data, geometry, onProgress, onError);\n      var mesh = new SkinnedMesh(geometry, material);\n      var skeleton = new Skeleton(initBones(mesh));\n      mesh.bind(skeleton);\n      return mesh;\n    }\n  }]);\n  return MeshBuilder;\n}();\nfunction initBones(mesh) {\n  var geometry = mesh.geometry;\n  var bones = [];\n  if (geometry && geometry.bones !== void 0) {\n    for (var i = 0, il = geometry.bones.length; i < il; i++) {\n      var gbone = geometry.bones[i];\n      var bone = new Bone();\n      bones.push(bone);\n      bone.name = gbone.name;\n      bone.position.fromArray(gbone.pos);\n      bone.quaternion.fromArray(gbone.rotq);\n      if (gbone.scl !== void 0) bone.scale.fromArray(gbone.scl);\n    }\n    for (var _i = 0, _il = geometry.bones.length; _i < _il; _i++) {\n      var _gbone = geometry.bones[_i];\n      if (_gbone.parent !== -1 && _gbone.parent !== null && bones[_gbone.parent] !== void 0) {\n        bones[_gbone.parent].add(bones[_i]);\n      } else {\n        mesh.add(bones[_i]);\n      }\n    }\n  }\n  mesh.updateMatrixWorld(true);\n  return bones;\n}\nvar GeometryBuilder = /*#__PURE__*/function () {\n  function GeometryBuilder() {\n    _classCallCheck(this, GeometryBuilder);\n  }\n  _createClass(GeometryBuilder, [{\n    key: \"build\",\n    value:\n    /**\n     * @param {Object} data - parsed PMD/PMX data\n     * @return {BufferGeometry}\n     */\n    function build(data) {\n      var positions = [];\n      var uvs = [];\n      var normals = [];\n      var indices = [];\n      var groups = [];\n      var bones = [];\n      var skinIndices = [];\n      var skinWeights = [];\n      var morphTargets = [];\n      var morphPositions = [];\n      var iks = [];\n      var grants = [];\n      var rigidBodies = [];\n      var constraints = [];\n      var offset = 0;\n      var boneTypeTable = {};\n      for (var i = 0; i < data.metadata.vertexCount; i++) {\n        var v = data.vertices[i];\n        for (var j = 0, jl = v.position.length; j < jl; j++) {\n          positions.push(v.position[j]);\n        }\n        for (var _j = 0, _jl = v.normal.length; _j < _jl; _j++) {\n          normals.push(v.normal[_j]);\n        }\n        for (var _j2 = 0, _jl2 = v.uv.length; _j2 < _jl2; _j2++) {\n          uvs.push(v.uv[_j2]);\n        }\n        for (var _j3 = 0; _j3 < 4; _j3++) {\n          skinIndices.push(v.skinIndices.length - 1 >= _j3 ? v.skinIndices[_j3] : 0);\n        }\n        for (var _j4 = 0; _j4 < 4; _j4++) {\n          skinWeights.push(v.skinWeights.length - 1 >= _j4 ? v.skinWeights[_j4] : 0);\n        }\n      }\n      for (var _i2 = 0; _i2 < data.metadata.faceCount; _i2++) {\n        var face = data.faces[_i2];\n        for (var _j5 = 0, _jl3 = face.indices.length; _j5 < _jl3; _j5++) {\n          indices.push(face.indices[_j5]);\n        }\n      }\n      for (var _i3 = 0; _i3 < data.metadata.materialCount; _i3++) {\n        var material = data.materials[_i3];\n        groups.push({\n          offset: offset * 3,\n          count: material.faceCount * 3\n        });\n        offset += material.faceCount;\n      }\n      for (var _i4 = 0; _i4 < data.metadata.rigidBodyCount; _i4++) {\n        var body = data.rigidBodies[_i4];\n        var value = boneTypeTable[body.boneIndex];\n        value = value === void 0 ? body.type : Math.max(body.type, value);\n        boneTypeTable[body.boneIndex] = value;\n      }\n      for (var _i5 = 0; _i5 < data.metadata.boneCount; _i5++) {\n        var boneData = data.bones[_i5];\n        var bone = {\n          index: _i5,\n          transformationClass: boneData.transformationClass,\n          parent: boneData.parentIndex,\n          name: boneData.name,\n          pos: boneData.position.slice(0, 3),\n          rotq: [0, 0, 0, 1],\n          scl: [1, 1, 1],\n          rigidBodyType: boneTypeTable[_i5] !== void 0 ? boneTypeTable[_i5] : -1\n        };\n        if (bone.parent !== -1) {\n          bone.pos[0] -= data.bones[bone.parent].position[0];\n          bone.pos[1] -= data.bones[bone.parent].position[1];\n          bone.pos[2] -= data.bones[bone.parent].position[2];\n        }\n        bones.push(bone);\n      }\n      if (data.metadata.format === \"pmd\") {\n        for (var _i6 = 0; _i6 < data.metadata.ikCount; _i6++) {\n          var ik = data.iks[_i6];\n          var param = {\n            target: ik.target,\n            effector: ik.effector,\n            iteration: ik.iteration,\n            maxAngle: ik.maxAngle * 4,\n            links: []\n          };\n          for (var _j6 = 0, _jl4 = ik.links.length; _j6 < _jl4; _j6++) {\n            var link = {};\n            link.index = ik.links[_j6].index;\n            link.enabled = true;\n            if (data.bones[link.index].name.indexOf(\"ひざ\") >= 0) {\n              link.limitation = new Vector3(1, 0, 0);\n            }\n            param.links.push(link);\n          }\n          iks.push(param);\n        }\n      } else {\n        for (var _i7 = 0; _i7 < data.metadata.boneCount; _i7++) {\n          var _ik = data.bones[_i7].ik;\n          if (_ik === void 0) continue;\n          var _param = {\n            target: _i7,\n            effector: _ik.effector,\n            iteration: _ik.iteration,\n            maxAngle: _ik.maxAngle,\n            links: []\n          };\n          for (var _j7 = 0, _jl5 = _ik.links.length; _j7 < _jl5; _j7++) {\n            var _link = {};\n            _link.index = _ik.links[_j7].index;\n            _link.enabled = true;\n            if (_ik.links[_j7].angleLimitation === 1) {\n              var rotationMin = _ik.links[_j7].lowerLimitationAngle;\n              var rotationMax = _ik.links[_j7].upperLimitationAngle;\n              var tmp1 = -rotationMax[0];\n              var tmp2 = -rotationMax[1];\n              rotationMax[0] = -rotationMin[0];\n              rotationMax[1] = -rotationMin[1];\n              rotationMin[0] = tmp1;\n              rotationMin[1] = tmp2;\n              _link.rotationMin = new Vector3().fromArray(rotationMin);\n              _link.rotationMax = new Vector3().fromArray(rotationMax);\n            }\n            _param.links.push(_link);\n          }\n          iks.push(_param);\n          bones[_i7].ik = _param;\n        }\n      }\n      if (data.metadata.format === \"pmx\") {\n        var traverse = function traverse(entry) {\n          if (entry.param) {\n            grants.push(entry.param);\n            bones[entry.param.index].grant = entry.param;\n          }\n          entry.visited = true;\n          for (var _i8 = 0, il = entry.children.length; _i8 < il; _i8++) {\n            var child = entry.children[_i8];\n            if (!child.visited) traverse(child);\n          }\n        };\n        var grantEntryMap = {};\n        for (var _i9 = 0; _i9 < data.metadata.boneCount; _i9++) {\n          var _boneData = data.bones[_i9];\n          var grant = _boneData.grant;\n          if (grant === void 0) continue;\n          var _param2 = {\n            index: _i9,\n            parentIndex: grant.parentIndex,\n            ratio: grant.ratio,\n            isLocal: grant.isLocal,\n            affectRotation: grant.affectRotation,\n            affectPosition: grant.affectPosition,\n            transformationClass: _boneData.transformationClass\n          };\n          grantEntryMap[_i9] = {\n            parent: null,\n            children: [],\n            param: _param2,\n            visited: false\n          };\n        }\n        var rootEntry = {\n          parent: null,\n          children: [],\n          param: null,\n          visited: false\n        };\n        for (var boneIndex in grantEntryMap) {\n          var grantEntry = grantEntryMap[boneIndex];\n          var parentGrantEntry = grantEntryMap[grantEntry.parentIndex] || rootEntry;\n          grantEntry.parent = parentGrantEntry;\n          parentGrantEntry.children.push(grantEntry);\n        }\n        traverse(rootEntry);\n      }\n      function updateAttributes(attribute, morph, ratio) {\n        for (var _i10 = 0; _i10 < morph.elementCount; _i10++) {\n          var element = morph.elements[_i10];\n          var index = void 0;\n          if (data.metadata.format === \"pmd\") {\n            index = data.morphs[0].elements[element.index].index;\n          } else {\n            index = element.index;\n          }\n          attribute.array[index * 3 + 0] += element.position[0] * ratio;\n          attribute.array[index * 3 + 1] += element.position[1] * ratio;\n          attribute.array[index * 3 + 2] += element.position[2] * ratio;\n        }\n      }\n      for (var _i11 = 0; _i11 < data.metadata.morphCount; _i11++) {\n        var morph = data.morphs[_i11];\n        var params = {\n          name: morph.name\n        };\n        var attribute = new Float32BufferAttribute(data.metadata.vertexCount * 3, 3);\n        attribute.name = morph.name;\n        for (var _j8 = 0; _j8 < data.metadata.vertexCount * 3; _j8++) {\n          attribute.array[_j8] = positions[_j8];\n        }\n        if (data.metadata.format === \"pmd\") {\n          if (_i11 !== 0) {\n            updateAttributes(attribute, morph, 1);\n          }\n        } else {\n          if (morph.type === 0) {\n            for (var _j9 = 0; _j9 < morph.elementCount; _j9++) {\n              var morph2 = data.morphs[morph.elements[_j9].index];\n              var ratio = morph.elements[_j9].ratio;\n              if (morph2.type === 1) {\n                updateAttributes(attribute, morph2, ratio);\n              }\n            }\n          } else if (morph.type === 1) {\n            updateAttributes(attribute, morph, 1);\n          } else if (morph.type === 2) ;else if (morph.type === 3) ;else if (morph.type === 4) ;else if (morph.type === 5) ;else if (morph.type === 6) ;else if (morph.type === 7) ;else if (morph.type === 8) ;\n        }\n        morphTargets.push(params);\n        morphPositions.push(attribute);\n      }\n      for (var _i12 = 0; _i12 < data.metadata.rigidBodyCount; _i12++) {\n        var rigidBody = data.rigidBodies[_i12];\n        var _params = {};\n        for (var key in rigidBody) {\n          _params[key] = rigidBody[key];\n        }\n        if (data.metadata.format === \"pmx\") {\n          if (_params.boneIndex !== -1) {\n            var _bone = data.bones[_params.boneIndex];\n            _params.position[0] -= _bone.position[0];\n            _params.position[1] -= _bone.position[1];\n            _params.position[2] -= _bone.position[2];\n          }\n        }\n        rigidBodies.push(_params);\n      }\n      for (var _i13 = 0; _i13 < data.metadata.constraintCount; _i13++) {\n        var constraint = data.constraints[_i13];\n        var _params2 = {};\n        for (var _key in constraint) {\n          _params2[_key] = constraint[_key];\n        }\n        var bodyA = rigidBodies[_params2.rigidBodyIndex1];\n        var bodyB = rigidBodies[_params2.rigidBodyIndex2];\n        if (bodyA.type !== 0 && bodyB.type === 2) {\n          if (bodyA.boneIndex !== -1 && bodyB.boneIndex !== -1 && data.bones[bodyB.boneIndex].parentIndex === bodyA.boneIndex) {\n            bodyB.type = 1;\n          }\n        }\n        constraints.push(_params2);\n      }\n      var geometry = new BufferGeometry();\n      geometry.setAttribute(\"position\", new Float32BufferAttribute(positions, 3));\n      geometry.setAttribute(\"normal\", new Float32BufferAttribute(normals, 3));\n      geometry.setAttribute(\"uv\", new Float32BufferAttribute(uvs, 2));\n      geometry.setAttribute(\"skinIndex\", new Uint16BufferAttribute(skinIndices, 4));\n      geometry.setAttribute(\"skinWeight\", new Float32BufferAttribute(skinWeights, 4));\n      geometry.setIndex(indices);\n      for (var _i14 = 0, il = groups.length; _i14 < il; _i14++) {\n        geometry.addGroup(groups[_i14].offset, groups[_i14].count, _i14);\n      }\n      geometry.bones = bones;\n      geometry.morphTargets = morphTargets;\n      geometry.morphAttributes.position = morphPositions;\n      geometry.morphTargetsRelative = false;\n      geometry.userData.MMD = {\n        bones: bones,\n        iks: iks,\n        grants: grants,\n        rigidBodies: rigidBodies,\n        constraints: constraints,\n        format: data.metadata.format\n      };\n      geometry.computeBoundingSphere();\n      return geometry;\n    }\n  }]);\n  return GeometryBuilder;\n}();\nvar MaterialBuilder = /*#__PURE__*/function () {\n  function MaterialBuilder(manager) {\n    _classCallCheck(this, MaterialBuilder);\n    this.manager = manager;\n    this.textureLoader = new TextureLoader(this.manager);\n    this.tgaLoader = null;\n    this.crossOrigin = \"anonymous\";\n    this.resourcePath = void 0;\n  }\n  /**\n   * @param {string} crossOrigin\n   * @return {MaterialBuilder}\n   */\n  _createClass(MaterialBuilder, [{\n    key: \"setCrossOrigin\",\n    value: function setCrossOrigin(crossOrigin) {\n      this.crossOrigin = crossOrigin;\n      return this;\n    }\n    /**\n     * @param {string} resourcePath\n     * @return {MaterialBuilder}\n     */\n  }, {\n    key: \"setResourcePath\",\n    value: function setResourcePath(resourcePath) {\n      this.resourcePath = resourcePath;\n      return this;\n    }\n    /**\n     * @param {Object} data - parsed PMD/PMX data\n     * @param {BufferGeometry} geometry - some properties are dependend on geometry\n     * @param {function} onProgress\n     * @param {function} onError\n     * @return {Array<MeshToonMaterial>}\n     */\n  }, {\n    key: \"build\",\n    value: function build(data, geometry) {\n      var materials = [];\n      var textures = {};\n      this.textureLoader.setCrossOrigin(this.crossOrigin);\n      for (var i = 0; i < data.metadata.materialCount; i++) {\n        var material = data.materials[i];\n        var params = {\n          userData: {}\n        };\n        if (material.name !== void 0) params.name = material.name;\n        params.color = new Color().fromArray(material.diffuse);\n        params.opacity = material.diffuse[3];\n        params.emissive = new Color().fromArray(material.ambient);\n        params.transparent = params.opacity !== 1;\n        params.skinning = geometry.bones.length > 0 ? true : false;\n        params.morphTargets = geometry.morphTargets.length > 0 ? true : false;\n        params.fog = true;\n        params.blending = CustomBlending;\n        params.blendSrc = SrcAlphaFactor;\n        params.blendDst = OneMinusSrcAlphaFactor;\n        params.blendSrcAlpha = SrcAlphaFactor;\n        params.blendDstAlpha = DstAlphaFactor;\n        if (data.metadata.format === \"pmx\" && (material.flag & 1) === 1) {\n          params.side = DoubleSide;\n        } else {\n          params.side = params.opacity === 1 ? FrontSide : DoubleSide;\n        }\n        if (data.metadata.format === \"pmd\") {\n          if (material.fileName) {\n            var fileName = material.fileName;\n            var fileNames = fileName.split(\"*\");\n            params.map = this._loadTexture(fileNames[0], textures);\n            if (fileNames.length > 1) {\n              var extension = fileNames[1].slice(-4).toLowerCase();\n              params.envMap = this._loadTexture(fileNames[1], textures);\n              params.combine = extension === \".sph\" ? MultiplyOperation : AddOperation;\n            }\n          }\n          var toonFileName = material.toonIndex === -1 ? \"toon00.bmp\" : data.toonTextures[material.toonIndex].fileName;\n          params.gradientMap = this._loadTexture(toonFileName, textures, {\n            isToonTexture: true,\n            isDefaultToonTexture: this._isDefaultToonTexture(toonFileName)\n          });\n          params.userData.outlineParameters = {\n            thickness: material.edgeFlag === 1 ? 3e-3 : 0,\n            color: [0, 0, 0],\n            alpha: 1,\n            visible: material.edgeFlag === 1\n          };\n        } else {\n          if (material.textureIndex !== -1) {\n            params.map = this._loadTexture(data.textures[material.textureIndex], textures);\n          }\n          if (material.envTextureIndex !== -1 && (material.envFlag === 1 || material.envFlag == 2)) {\n            params.envMap = this._loadTexture(data.textures[material.envTextureIndex], textures);\n            params.combine = material.envFlag === 1 ? MultiplyOperation : AddOperation;\n          }\n          var _toonFileName = void 0,\n            isDefaultToon = void 0;\n          if (material.toonIndex === -1 || material.toonFlag !== 0) {\n            _toonFileName = \"toon\" + (\"0\" + (material.toonIndex + 1)).slice(-2) + \".bmp\";\n            isDefaultToon = true;\n          } else {\n            _toonFileName = data.textures[material.toonIndex];\n            isDefaultToon = false;\n          }\n          params.gradientMap = this._loadTexture(_toonFileName, textures, {\n            isToonTexture: true,\n            isDefaultToonTexture: isDefaultToon\n          });\n          params.userData.outlineParameters = {\n            thickness: material.edgeSize / 300,\n            // TODO: better calculation?\n            color: material.edgeColor.slice(0, 3),\n            alpha: material.edgeColor[3],\n            visible: (material.flag & 16) !== 0 && material.edgeSize > 0\n          };\n        }\n        if (params.map !== void 0) {\n          if (!params.transparent) {\n            this._checkImageTransparency(params.map, geometry, i);\n          }\n          params.emissive.multiplyScalar(0.2);\n        }\n        materials.push(new MeshToonMaterial(params));\n      }\n      if (data.metadata.format === \"pmx\") {\n        var checkAlphaMorph = function checkAlphaMorph(elements, materials2) {\n          for (var _i15 = 0, il = elements.length; _i15 < il; _i15++) {\n            var element = elements[_i15];\n            if (element.index === -1) continue;\n            var _material = materials2[element.index];\n            if (_material.opacity !== element.diffuse[3]) {\n              _material.transparent = true;\n            }\n          }\n        };\n        for (var _i16 = 0, il = data.morphs.length; _i16 < il; _i16++) {\n          var morph = data.morphs[_i16];\n          var elements = morph.elements;\n          if (morph.type === 0) {\n            for (var j = 0, jl = elements.length; j < jl; j++) {\n              var morph2 = data.morphs[elements[j].index];\n              if (morph2.type !== 8) continue;\n              checkAlphaMorph(morph2.elements, materials);\n            }\n          } else if (morph.type === 8) {\n            checkAlphaMorph(elements, materials);\n          }\n        }\n      }\n      return materials;\n    }\n    // private methods\n  }, {\n    key: \"_getTGALoader\",\n    value: function _getTGALoader() {\n      if (this.tgaLoader === null) {\n        if (TGALoader === void 0) {\n          throw new Error(\"THREE.MMDLoader: Import TGALoader\");\n        }\n        this.tgaLoader = new TGALoader(this.manager);\n      }\n      return this.tgaLoader;\n    }\n  }, {\n    key: \"_isDefaultToonTexture\",\n    value: function _isDefaultToonTexture(name) {\n      if (name.length !== 10) return false;\n      return /toon(10|0[0-9])\\.bmp/.test(name);\n    }\n  }, {\n    key: \"_loadTexture\",\n    value: function _loadTexture(filePath, textures, params, onProgress, onError) {\n      params = params || {};\n      var scope = this;\n      var fullPath;\n      if (params.isDefaultToonTexture === true) {\n        var index;\n        try {\n          index = parseInt(filePath.match(/toon([0-9]{2})\\.bmp$/)[1]);\n        } catch (e) {\n          console.warn(\"THREE.MMDLoader: \" + filePath + \" seems like a not right default texture path. Using toon00.bmp instead.\");\n          index = 0;\n        }\n        fullPath = DEFAULT_TOON_TEXTURES[index];\n      } else {\n        fullPath = this.resourcePath + filePath;\n      }\n      if (textures[fullPath] !== void 0) return textures[fullPath];\n      var loader = this.manager.getHandler(fullPath);\n      if (loader === null) {\n        loader = filePath.slice(-4).toLowerCase() === \".tga\" ? this._getTGALoader() : this.textureLoader;\n      }\n      var texture = loader.load(fullPath, function (t) {\n        if (params.isToonTexture === true) {\n          t.image = scope._getRotatedImage(t.image);\n          t.magFilter = NearestFilter;\n          t.minFilter = NearestFilter;\n        }\n        t.flipY = false;\n        t.wrapS = RepeatWrapping;\n        t.wrapT = RepeatWrapping;\n        for (var i = 0; i < texture.readyCallbacks.length; i++) {\n          texture.readyCallbacks[i](texture);\n        }\n        delete texture.readyCallbacks;\n      }, onProgress, onError);\n      texture.readyCallbacks = [];\n      textures[fullPath] = texture;\n      return texture;\n    }\n  }, {\n    key: \"_getRotatedImage\",\n    value: function _getRotatedImage(image) {\n      var canvas = document.createElement(\"canvas\");\n      var context = canvas.getContext(\"2d\");\n      var width = image.width;\n      var height = image.height;\n      canvas.width = width;\n      canvas.height = height;\n      context.clearRect(0, 0, width, height);\n      context.translate(width / 2, height / 2);\n      context.rotate(0.5 * Math.PI);\n      context.translate(-width / 2, -height / 2);\n      context.drawImage(image, 0, 0);\n      return context.getImageData(0, 0, width, height);\n    }\n    // Check if the partial image area used by the texture is transparent.\n  }, {\n    key: \"_checkImageTransparency\",\n    value: function _checkImageTransparency(map, geometry, groupIndex) {\n      map.readyCallbacks.push(function (texture) {\n        function createImageData(image) {\n          var canvas = document.createElement(\"canvas\");\n          canvas.width = image.width;\n          canvas.height = image.height;\n          var context = canvas.getContext(\"2d\");\n          context.drawImage(image, 0, 0);\n          return context.getImageData(0, 0, canvas.width, canvas.height);\n        }\n        function detectImageTransparency(image, uvs, indices) {\n          var width = image.width;\n          var height = image.height;\n          var data = image.data;\n          var threshold = 253;\n          if (data.length / (width * height) !== 4) return false;\n          for (var i = 0; i < indices.length; i += 3) {\n            var centerUV = {\n              x: 0,\n              y: 0\n            };\n            for (var j = 0; j < 3; j++) {\n              var index = indices[i * 3 + j];\n              var uv = {\n                x: uvs[index * 2 + 0],\n                y: uvs[index * 2 + 1]\n              };\n              if (getAlphaByUv(image, uv) < threshold) return true;\n              centerUV.x += uv.x;\n              centerUV.y += uv.y;\n            }\n            centerUV.x /= 3;\n            centerUV.y /= 3;\n            if (getAlphaByUv(image, centerUV) < threshold) return true;\n          }\n          return false;\n        }\n        function getAlphaByUv(image, uv) {\n          var width = image.width;\n          var height = image.height;\n          var x = Math.round(uv.x * width) % width;\n          var y = Math.round(uv.y * height) % height;\n          if (x < 0) x += width;\n          if (y < 0) y += height;\n          var index = y * width + x;\n          return image.data[index * 4 + 3];\n        }\n        var imageData = texture.image.data !== void 0 ? texture.image : createImageData(texture.image);\n        var group = geometry.groups[groupIndex];\n        if (detectImageTransparency(imageData, geometry.attributes.uv.array, geometry.index.array.slice(group.start, group.start + group.count))) {\n          map.transparent = true;\n        }\n      });\n    }\n  }]);\n  return MaterialBuilder;\n}();\nvar AnimationBuilder = /*#__PURE__*/function () {\n  function AnimationBuilder() {\n    _classCallCheck(this, AnimationBuilder);\n  }\n  _createClass(AnimationBuilder, [{\n    key: \"build\",\n    value:\n    /**\n     * @param {Object} vmd - parsed VMD data\n     * @param {SkinnedMesh} mesh - tracks will be fitting to mesh\n     * @return {AnimationClip}\n     */\n    function build(vmd, mesh) {\n      var tracks = this.buildSkeletalAnimation(vmd, mesh).tracks;\n      var tracks2 = this.buildMorphAnimation(vmd, mesh).tracks;\n      for (var i = 0, il = tracks2.length; i < il; i++) {\n        tracks.push(tracks2[i]);\n      }\n      return new AnimationClip(\"\", -1, tracks);\n    }\n    /**\n     * @param {Object} vmd - parsed VMD data\n     * @param {SkinnedMesh} mesh - tracks will be fitting to mesh\n     * @return {AnimationClip}\n     */\n  }, {\n    key: \"buildSkeletalAnimation\",\n    value: function buildSkeletalAnimation(vmd, mesh) {\n      function pushInterpolation(array, interpolation, index) {\n        array.push(interpolation[index + 0] / 127);\n        array.push(interpolation[index + 8] / 127);\n        array.push(interpolation[index + 4] / 127);\n        array.push(interpolation[index + 12] / 127);\n      }\n      var tracks = [];\n      var motions = {};\n      var bones = mesh.skeleton.bones;\n      var boneNameDictionary = {};\n      for (var i = 0, il = bones.length; i < il; i++) {\n        boneNameDictionary[bones[i].name] = true;\n      }\n      for (var _i17 = 0; _i17 < vmd.metadata.motionCount; _i17++) {\n        var motion = vmd.motions[_i17];\n        var boneName = motion.boneName;\n        if (boneNameDictionary[boneName] === void 0) continue;\n        motions[boneName] = motions[boneName] || [];\n        motions[boneName].push(motion);\n      }\n      for (var key in motions) {\n        var array = motions[key];\n        array.sort(function (a, b) {\n          return a.frameNum - b.frameNum;\n        });\n        var times = [];\n        var positions = [];\n        var rotations = [];\n        var pInterpolations = [];\n        var rInterpolations = [];\n        var basePosition = mesh.skeleton.getBoneByName(key).position.toArray();\n        for (var _i18 = 0, _il2 = array.length; _i18 < _il2; _i18++) {\n          var time = array[_i18].frameNum / 30;\n          var position = array[_i18].position;\n          var rotation = array[_i18].rotation;\n          var interpolation = array[_i18].interpolation;\n          times.push(time);\n          for (var j = 0; j < 3; j++) positions.push(basePosition[j] + position[j]);\n          for (var _j10 = 0; _j10 < 4; _j10++) rotations.push(rotation[_j10]);\n          for (var _j11 = 0; _j11 < 3; _j11++) pushInterpolation(pInterpolations, interpolation, _j11);\n          pushInterpolation(rInterpolations, interpolation, 3);\n        }\n        var targetName = \".bones[\" + key + \"]\";\n        tracks.push(this._createTrack(targetName + \".position\", VectorKeyframeTrack, times, positions, pInterpolations));\n        tracks.push(this._createTrack(targetName + \".quaternion\", QuaternionKeyframeTrack, times, rotations, rInterpolations));\n      }\n      return new AnimationClip(\"\", -1, tracks);\n    }\n    /**\n     * @param {Object} vmd - parsed VMD data\n     * @param {SkinnedMesh} mesh - tracks will be fitting to mesh\n     * @return {AnimationClip}\n     */\n  }, {\n    key: \"buildMorphAnimation\",\n    value: function buildMorphAnimation(vmd, mesh) {\n      var tracks = [];\n      var morphs = {};\n      var morphTargetDictionary = mesh.morphTargetDictionary;\n      for (var i = 0; i < vmd.metadata.morphCount; i++) {\n        var morph = vmd.morphs[i];\n        var morphName = morph.morphName;\n        if (morphTargetDictionary[morphName] === void 0) continue;\n        morphs[morphName] = morphs[morphName] || [];\n        morphs[morphName].push(morph);\n      }\n      for (var key in morphs) {\n        var array = morphs[key];\n        array.sort(function (a, b) {\n          return a.frameNum - b.frameNum;\n        });\n        var times = [];\n        var values = [];\n        for (var _i19 = 0, il = array.length; _i19 < il; _i19++) {\n          times.push(array[_i19].frameNum / 30);\n          values.push(array[_i19].weight);\n        }\n        tracks.push(new NumberKeyframeTrack(\".morphTargetInfluences[\" + morphTargetDictionary[key] + \"]\", times, values));\n      }\n      return new AnimationClip(\"\", -1, tracks);\n    }\n    /**\n     * @param {Object} vmd - parsed VMD data\n     * @return {AnimationClip}\n     */\n  }, {\n    key: \"buildCameraAnimation\",\n    value: function buildCameraAnimation(vmd) {\n      function pushVector3(array, vec) {\n        array.push(vec.x);\n        array.push(vec.y);\n        array.push(vec.z);\n      }\n      function pushQuaternion(array, q) {\n        array.push(q.x);\n        array.push(q.y);\n        array.push(q.z);\n        array.push(q.w);\n      }\n      function pushInterpolation(array, interpolation, index) {\n        array.push(interpolation[index * 4 + 0] / 127);\n        array.push(interpolation[index * 4 + 1] / 127);\n        array.push(interpolation[index * 4 + 2] / 127);\n        array.push(interpolation[index * 4 + 3] / 127);\n      }\n      var cameras = vmd.cameras === void 0 ? [] : vmd.cameras.slice();\n      cameras.sort(function (a, b) {\n        return a.frameNum - b.frameNum;\n      });\n      var times = [];\n      var centers = [];\n      var quaternions = [];\n      var positions = [];\n      var fovs = [];\n      var cInterpolations = [];\n      var qInterpolations = [];\n      var pInterpolations = [];\n      var fInterpolations = [];\n      var quaternion = new Quaternion();\n      var euler = new Euler();\n      var position = new Vector3();\n      var center = new Vector3();\n      for (var i = 0, il = cameras.length; i < il; i++) {\n        var motion = cameras[i];\n        var time = motion.frameNum / 30;\n        var pos = motion.position;\n        var rot = motion.rotation;\n        var distance = motion.distance;\n        var fov = motion.fov;\n        var interpolation = motion.interpolation;\n        times.push(time);\n        position.set(0, 0, -distance);\n        center.set(pos[0], pos[1], pos[2]);\n        euler.set(-rot[0], -rot[1], -rot[2]);\n        quaternion.setFromEuler(euler);\n        position.add(center);\n        position.applyQuaternion(quaternion);\n        pushVector3(centers, center);\n        pushQuaternion(quaternions, quaternion);\n        pushVector3(positions, position);\n        fovs.push(fov);\n        for (var j = 0; j < 3; j++) {\n          pushInterpolation(cInterpolations, interpolation, j);\n        }\n        pushInterpolation(qInterpolations, interpolation, 3);\n        for (var _j12 = 0; _j12 < 3; _j12++) {\n          pushInterpolation(pInterpolations, interpolation, 4);\n        }\n        pushInterpolation(fInterpolations, interpolation, 5);\n      }\n      var tracks = [];\n      tracks.push(this._createTrack(\"target.position\", VectorKeyframeTrack, times, centers, cInterpolations));\n      tracks.push(this._createTrack(\".quaternion\", QuaternionKeyframeTrack, times, quaternions, qInterpolations));\n      tracks.push(this._createTrack(\".position\", VectorKeyframeTrack, times, positions, pInterpolations));\n      tracks.push(this._createTrack(\".fov\", NumberKeyframeTrack, times, fovs, fInterpolations));\n      return new AnimationClip(\"\", -1, tracks);\n    }\n    // private method\n  }, {\n    key: \"_createTrack\",\n    value: function _createTrack(node, typedKeyframeTrack, times, values, interpolations) {\n      if (times.length > 2) {\n        times = times.slice();\n        values = values.slice();\n        interpolations = interpolations.slice();\n        var stride = values.length / times.length;\n        var interpolateStride = interpolations.length / times.length;\n        var index = 1;\n        for (var aheadIndex = 2, endIndex = times.length; aheadIndex < endIndex; aheadIndex++) {\n          for (var i = 0; i < stride; i++) {\n            if (values[index * stride + i] !== values[(index - 1) * stride + i] || values[index * stride + i] !== values[aheadIndex * stride + i]) {\n              index++;\n              break;\n            }\n          }\n          if (aheadIndex > index) {\n            times[index] = times[aheadIndex];\n            for (var _i20 = 0; _i20 < stride; _i20++) {\n              values[index * stride + _i20] = values[aheadIndex * stride + _i20];\n            }\n            for (var _i21 = 0; _i21 < interpolateStride; _i21++) {\n              interpolations[index * interpolateStride + _i21] = interpolations[aheadIndex * interpolateStride + _i21];\n            }\n          }\n        }\n        times.length = index + 1;\n        values.length = (index + 1) * stride;\n        interpolations.length = (index + 1) * interpolateStride;\n      }\n      var track = new typedKeyframeTrack(node, times, values);\n      track.createInterpolant = function InterpolantFactoryMethodCubicBezier(result) {\n        return new CubicBezierInterpolation(this.times, this.values, this.getValueSize(), result, new Float32Array(interpolations));\n      };\n      return track;\n    }\n  }]);\n  return AnimationBuilder;\n}();\nvar CubicBezierInterpolation = /*#__PURE__*/function (_Interpolant) {\n  _inherits(CubicBezierInterpolation, _Interpolant);\n  var _super2 = _createSuper(CubicBezierInterpolation);\n  function CubicBezierInterpolation(parameterPositions, sampleValues, sampleSize, resultBuffer, params) {\n    var _this2;\n    _classCallCheck(this, CubicBezierInterpolation);\n    _this2 = _super2.call(this, parameterPositions, sampleValues, sampleSize, resultBuffer);\n    _this2.interpolationParams = params;\n    return _this2;\n  }\n  _createClass(CubicBezierInterpolation, [{\n    key: \"interpolate_\",\n    value: function interpolate_(i1, t0, t, t1) {\n      var result = this.resultBuffer;\n      var values = this.sampleValues;\n      var stride = this.valueSize;\n      var params = this.interpolationParams;\n      var offset1 = i1 * stride;\n      var offset0 = offset1 - stride;\n      var weight1 = t1 - t0 < 1 / 30 * 1.5 ? 0 : (t - t0) / (t1 - t0);\n      if (stride === 4) {\n        var x1 = params[i1 * 4 + 0];\n        var x2 = params[i1 * 4 + 1];\n        var y1 = params[i1 * 4 + 2];\n        var y2 = params[i1 * 4 + 3];\n        var ratio = this._calculate(x1, x2, y1, y2, weight1);\n        Quaternion.slerpFlat(result, 0, values, offset0, values, offset1, ratio);\n      } else if (stride === 3) {\n        for (var i = 0; i !== stride; ++i) {\n          var _x = params[i1 * 12 + i * 4 + 0];\n          var _x2 = params[i1 * 12 + i * 4 + 1];\n          var _y = params[i1 * 12 + i * 4 + 2];\n          var _y2 = params[i1 * 12 + i * 4 + 3];\n          var _ratio = this._calculate(_x, _x2, _y, _y2, weight1);\n          result[i] = values[offset0 + i] * (1 - _ratio) + values[offset1 + i] * _ratio;\n        }\n      } else {\n        var _x3 = params[i1 * 4 + 0];\n        var _x4 = params[i1 * 4 + 1];\n        var _y3 = params[i1 * 4 + 2];\n        var _y4 = params[i1 * 4 + 3];\n        var _ratio2 = this._calculate(_x3, _x4, _y3, _y4, weight1);\n        result[0] = values[offset0] * (1 - _ratio2) + values[offset1] * _ratio2;\n      }\n      return result;\n    }\n  }, {\n    key: \"_calculate\",\n    value: function _calculate(x1, x2, y1, y2, x) {\n      var c = 0.5;\n      var t = c;\n      var s = 1 - t;\n      var loop = 15;\n      var eps = 1e-5;\n      var math = Math;\n      var sst3, stt3, ttt;\n      for (var i = 0; i < loop; i++) {\n        sst3 = 3 * s * s * t;\n        stt3 = 3 * s * t * t;\n        ttt = t * t * t;\n        var ft = sst3 * x1 + stt3 * x2 + ttt - x;\n        if (math.abs(ft) < eps) break;\n        c /= 2;\n        t += ft < 0 ? c : -c;\n        s = 1 - t;\n      }\n      return sst3 * y1 + stt3 * y2 + ttt;\n    }\n  }]);\n  return CubicBezierInterpolation;\n}(Interpolant);\nexport { MMDLoader };","map":{"version":3,"names":["MMDLoader","_Loader","_inherits","_super","_createSuper","manager","_this","_classCallCheck","call","loader","FileLoader","parser","meshBuilder","MeshBuilder","animationBuilder","AnimationBuilder","_createClass","key","value","setAnimationPath","animationPath","load","url","onLoad","onProgress","onError","builder","setCrossOrigin","crossOrigin","resourcePath","path","LoaderUtils","extractUrlBase","modelExtension","_extractExtension","toLowerCase","Error","data","build","loadAnimation","object","loadVMD","vmd","isCamera","buildCameraAnimation","loadWithAnimation","modelUrl","vmdUrl","scope","mesh","animation","loadPMD","_getParser","setMimeType","setPath","setResponseType","setRequestHeader","requestHeader","setWithCredentials","withCredentials","buffer","parsePmd","loadPMX","parsePmx","urls","Array","isArray","vmds","vmdNum","length","i","il","push","parseVmd","mergeVmds","loadVPD","isUnicode","text","parseVpd","index","lastIndexOf","slice","Parser","Loader","DEFAULT_TOON_TEXTURES","geometryBuilder","GeometryBuilder","materialBuilder","MaterialBuilder","geometry","material","setResourcePath","SkinnedMesh","skeleton","Skeleton","initBones","bind","bones","gbone","bone","Bone","name","position","fromArray","pos","quaternion","rotq","scl","scale","parent","add","updateMatrixWorld","positions","uvs","normals","indices","groups","skinIndices","skinWeights","morphTargets","morphPositions","iks","grants","rigidBodies","constraints","offset","boneTypeTable","metadata","vertexCount","v","vertices","j","jl","normal","uv","faceCount","face","faces","materialCount","materials","count","rigidBodyCount","body","boneIndex","type","Math","max","boneCount","boneData","transformationClass","parentIndex","rigidBodyType","format","ikCount","ik","param","target","effector","iteration","maxAngle","links","link","enabled","indexOf","limitation","Vector3","angleLimitation","rotationMin","lowerLimitationAngle","rotationMax","upperLimitationAngle","tmp1","tmp2","traverse","entry","grant","visited","children","child","grantEntryMap","ratio","isLocal","affectRotation","affectPosition","rootEntry","grantEntry","parentGrantEntry","updateAttributes","attribute","morph","elementCount","element","elements","morphs","array","morphCount","params","Float32BufferAttribute","morph2","rigidBody","constraintCount","constraint","bodyA","rigidBodyIndex1","bodyB","rigidBodyIndex2","BufferGeometry","setAttribute","Uint16BufferAttribute","setIndex","addGroup","morphAttributes","morphTargetsRelative","userData","MMD","computeBoundingSphere","textureLoader","TextureLoader","tgaLoader","textures","color","Color","diffuse","opacity","emissive","ambient","transparent","skinning","fog","blending","CustomBlending","blendSrc","SrcAlphaFactor","blendDst","OneMinusSrcAlphaFactor","blendSrcAlpha","blendDstAlpha","DstAlphaFactor","flag","side","DoubleSide","FrontSide","fileName","fileNames","split","map","_loadTexture","extension","envMap","combine","MultiplyOperation","AddOperation","toonFileName","toonIndex","toonTextures","gradientMap","isToonTexture","isDefaultToonTexture","_isDefaultToonTexture","outlineParameters","thickness","edgeFlag","alpha","visible","textureIndex","envTextureIndex","envFlag","isDefaultToon","toonFlag","edgeSize","edgeColor","_checkImageTransparency","multiplyScalar","MeshToonMaterial","checkAlphaMorph","materials2","_getTGALoader","TGALoader","test","filePath","fullPath","parseInt","match","e","console","warn","getHandler","texture","t","image","_getRotatedImage","magFilter","NearestFilter","minFilter","flipY","wrapS","RepeatWrapping","wrapT","readyCallbacks","canvas","document","createElement","context","getContext","width","height","clearRect","translate","rotate","PI","drawImage","getImageData","groupIndex","createImageData","detectImageTransparency","threshold","centerUV","x","y","getAlphaByUv","round","imageData","group","attributes","start","tracks","buildSkeletalAnimation","tracks2","buildMorphAnimation","AnimationClip","pushInterpolation","interpolation","motions","boneNameDictionary","motionCount","motion","boneName","sort","a","b","frameNum","times","rotations","pInterpolations","rInterpolations","basePosition","getBoneByName","toArray","time","rotation","targetName","_createTrack","VectorKeyframeTrack","QuaternionKeyframeTrack","morphTargetDictionary","morphName","values","weight","NumberKeyframeTrack","pushVector3","vec","z","pushQuaternion","q","w","cameras","centers","quaternions","fovs","cInterpolations","qInterpolations","fInterpolations","Quaternion","euler","Euler","center","rot","distance","fov","set","setFromEuler","applyQuaternion","node","typedKeyframeTrack","interpolations","stride","interpolateStride","aheadIndex","endIndex","track","createInterpolant","InterpolantFactoryMethodCubicBezier","result","CubicBezierInterpolation","getValueSize","Float32Array","_Interpolant","_super2","parameterPositions","sampleValues","sampleSize","resultBuffer","_this2","interpolationParams","interpolate_","i1","t0","t1","valueSize","offset1","offset0","weight1","x1","x2","y1","y2","_calculate","slerpFlat","c","s","loop","eps","math","sst3","stt3","ttt","ft","abs","Interpolant"],"sources":["C:\\Users\\Nayyu\\Desktop\\skibidai-public-build\\node_modules\\src\\loaders\\MMDLoader.js"],"sourcesContent":["import {\n  AddOperation,\n  AnimationClip,\n  Bone,\n  BufferGeometry,\n  Color,\n  CustomBlending,\n  DoubleSide,\n  DstAlphaFactor,\n  Euler,\n  FileLoader,\n  Float32BufferAttribute,\n  FrontSide,\n  Interpolant,\n  Loader,\n  LoaderUtils,\n  MeshToonMaterial,\n  MultiplyOperation,\n  NearestFilter,\n  NumberKeyframeTrack,\n  OneMinusSrcAlphaFactor,\n  Quaternion,\n  QuaternionKeyframeTrack,\n  RepeatWrapping,\n  Skeleton,\n  SkinnedMesh,\n  SrcAlphaFactor,\n  TextureLoader,\n  Uint16BufferAttribute,\n  Vector3,\n  VectorKeyframeTrack,\n} from 'three'\nimport { TGALoader } from '../loaders/TGALoader'\nimport { Parser } from '../libs/mmdparser'\n\n/**\n * Dependencies\n *  - mmd-parser https://github.com/takahirox/mmd-parser\n *  - TGALoader\n *  - OutlineEffect\n *\n * MMDLoader creates Three.js Objects from MMD resources as\n * PMD, PMX, VMD, and VPD files.\n *\n * PMD/PMX is a model data format, VMD is a motion data format\n * VPD is a posing data format used in MMD(Miku Miku Dance).\n *\n * MMD official site\n *  - https://sites.google.com/view/evpvp/\n *\n * PMD, VMD format (in Japanese)\n *  - http://blog.goo.ne.jp/torisu_tetosuki/e/209ad341d3ece2b1b4df24abf619d6e4\n *\n * PMX format\n *  - https://gist.github.com/felixjones/f8a06bd48f9da9a4539f\n *\n * TODO\n *  - light motion in vmd support.\n *  - SDEF support.\n *  - uv/material/bone morphing support.\n *  - more precise grant skinning support.\n *  - shadow support.\n */\n\n/**\n * @param {THREE.LoadingManager} manager\n */\nclass MMDLoader extends Loader {\n  constructor(manager) {\n    super(manager)\n\n    this.loader = new FileLoader(this.manager)\n\n    this.parser = null // lazy generation\n    this.meshBuilder = new MeshBuilder(this.manager)\n    this.animationBuilder = new AnimationBuilder()\n  }\n\n  /**\n   * @param {string} animationPath\n   * @return {MMDLoader}\n   */\n  setAnimationPath(animationPath) {\n    this.animationPath = animationPath\n    return this\n  }\n\n  // Load MMD assets as Three.js Object\n\n  /**\n   * Loads Model file (.pmd or .pmx) as a SkinnedMesh.\n   *\n   * @param {string} url - url to Model(.pmd or .pmx) file\n   * @param {function} onLoad\n   * @param {function} onProgress\n   * @param {function} onError\n   */\n  load(url, onLoad, onProgress, onError) {\n    const builder = this.meshBuilder.setCrossOrigin(this.crossOrigin)\n\n    // resource path\n\n    let resourcePath\n\n    if (this.resourcePath !== '') {\n      resourcePath = this.resourcePath\n    } else if (this.path !== '') {\n      resourcePath = this.path\n    } else {\n      resourcePath = LoaderUtils.extractUrlBase(url)\n    }\n\n    const modelExtension = this._extractExtension(url).toLowerCase()\n\n    // Should I detect by seeing header?\n    if (modelExtension !== 'pmd' && modelExtension !== 'pmx') {\n      if (onError) onError(new Error('THREE.MMDLoader: Unknown model file extension .' + modelExtension + '.'))\n\n      return\n    }\n\n    this[modelExtension === 'pmd' ? 'loadPMD' : 'loadPMX'](\n      url,\n      function (data) {\n        onLoad(builder.build(data, resourcePath, onProgress, onError))\n      },\n      onProgress,\n      onError,\n    )\n  }\n\n  /**\n   * Loads Motion file(s) (.vmd) as a AnimationClip.\n   * If two or more files are specified, they'll be merged.\n   *\n   * @param {string|Array<string>} url - url(s) to animation(.vmd) file(s)\n   * @param {SkinnedMesh|THREE.Camera} object - tracks will be fitting to this object\n   * @param {function} onLoad\n   * @param {function} onProgress\n   * @param {function} onError\n   */\n  loadAnimation(url, object, onLoad, onProgress, onError) {\n    const builder = this.animationBuilder\n\n    this.loadVMD(\n      url,\n      function (vmd) {\n        onLoad(object.isCamera ? builder.buildCameraAnimation(vmd) : builder.build(vmd, object))\n      },\n      onProgress,\n      onError,\n    )\n  }\n\n  /**\n   * Loads mode file and motion file(s) as an object containing\n   * a SkinnedMesh and a AnimationClip.\n   * Tracks of AnimationClip are fitting to the model.\n   *\n   * @param {string} modelUrl - url to Model(.pmd or .pmx) file\n   * @param {string|Array{string}} vmdUrl - url(s) to animation(.vmd) file\n   * @param {function} onLoad\n   * @param {function} onProgress\n   * @param {function} onError\n   */\n  loadWithAnimation(modelUrl, vmdUrl, onLoad, onProgress, onError) {\n    const scope = this\n\n    this.load(\n      modelUrl,\n      function (mesh) {\n        scope.loadAnimation(\n          vmdUrl,\n          mesh,\n          function (animation) {\n            onLoad({\n              mesh: mesh,\n              animation: animation,\n            })\n          },\n          onProgress,\n          onError,\n        )\n      },\n      onProgress,\n      onError,\n    )\n  }\n\n  // Load MMD assets as Object data parsed by MMDParser\n\n  /**\n   * Loads .pmd file as an Object.\n   *\n   * @param {string} url - url to .pmd file\n   * @param {function} onLoad\n   * @param {function} onProgress\n   * @param {function} onError\n   */\n  loadPMD(url, onLoad, onProgress, onError) {\n    const parser = this._getParser()\n\n    this.loader\n      .setMimeType(undefined)\n      .setPath(this.path)\n      .setResponseType('arraybuffer')\n      .setRequestHeader(this.requestHeader)\n      .setWithCredentials(this.withCredentials)\n      .load(\n        url,\n        function (buffer) {\n          onLoad(parser.parsePmd(buffer, true))\n        },\n        onProgress,\n        onError,\n      )\n  }\n\n  /**\n   * Loads .pmx file as an Object.\n   *\n   * @param {string} url - url to .pmx file\n   * @param {function} onLoad\n   * @param {function} onProgress\n   * @param {function} onError\n   */\n  loadPMX(url, onLoad, onProgress, onError) {\n    const parser = this._getParser()\n\n    this.loader\n      .setMimeType(undefined)\n      .setPath(this.path)\n      .setResponseType('arraybuffer')\n      .setRequestHeader(this.requestHeader)\n      .setWithCredentials(this.withCredentials)\n      .load(\n        url,\n        function (buffer) {\n          onLoad(parser.parsePmx(buffer, true))\n        },\n        onProgress,\n        onError,\n      )\n  }\n\n  /**\n   * Loads .vmd file as an Object. If two or more files are specified\n   * they'll be merged.\n   *\n   * @param {string|Array<string>} url - url(s) to .vmd file(s)\n   * @param {function} onLoad\n   * @param {function} onProgress\n   * @param {function} onError\n   */\n  loadVMD(url, onLoad, onProgress, onError) {\n    const urls = Array.isArray(url) ? url : [url]\n\n    const vmds = []\n    const vmdNum = urls.length\n\n    const parser = this._getParser()\n\n    this.loader\n      .setMimeType(undefined)\n      .setPath(this.animationPath)\n      .setResponseType('arraybuffer')\n      .setRequestHeader(this.requestHeader)\n      .setWithCredentials(this.withCredentials)\n\n    for (let i = 0, il = urls.length; i < il; i++) {\n      this.loader.load(\n        urls[i],\n        function (buffer) {\n          vmds.push(parser.parseVmd(buffer, true))\n\n          if (vmds.length === vmdNum) onLoad(parser.mergeVmds(vmds))\n        },\n        onProgress,\n        onError,\n      )\n    }\n  }\n\n  /**\n   * Loads .vpd file as an Object.\n   *\n   * @param {string} url - url to .vpd file\n   * @param {boolean} isUnicode\n   * @param {function} onLoad\n   * @param {function} onProgress\n   * @param {function} onError\n   */\n  loadVPD(url, isUnicode, onLoad, onProgress, onError) {\n    const parser = this._getParser()\n\n    this.loader\n      .setMimeType(isUnicode ? undefined : 'text/plain; charset=shift_jis')\n      .setPath(this.animationPath)\n      .setResponseType('text')\n      .setRequestHeader(this.requestHeader)\n      .setWithCredentials(this.withCredentials)\n      .load(\n        url,\n        function (text) {\n          onLoad(parser.parseVpd(text, true))\n        },\n        onProgress,\n        onError,\n      )\n  }\n\n  // private methods\n\n  _extractExtension(url) {\n    const index = url.lastIndexOf('.')\n    return index < 0 ? '' : url.slice(index + 1)\n  }\n\n  _getParser() {\n    if (this.parser === null) {\n      this.parser = new Parser()\n    }\n\n    return this.parser\n  }\n}\n\n// Utilities\n\n/*\n * base64 encoded defalut toon textures toon00.bmp - toon10.bmp.\n * We don't need to request external toon image files.\n * This idea is from http://www20.atpages.jp/katwat/three.js_r58/examples/mytest37/mmd.three.js\n */\nconst DEFAULT_TOON_TEXTURES = [\n  'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAL0lEQVRYR+3QQREAAAzCsOFfNJPBJ1XQS9r2hsUAAQIECBAgQIAAAQIECBAgsBZ4MUx/ofm2I/kAAAAASUVORK5CYII=',\n  'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAN0lEQVRYR+3WQREAMBACsZ5/bWiiMvgEBTt5cW37hjsBBAgQIECAwFwgyfYPCCBAgAABAgTWAh8aBHZBl14e8wAAAABJRU5ErkJggg==',\n  'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAOUlEQVRYR+3WMREAMAwDsYY/yoDI7MLwIiP40+RJklfcCCBAgAABAgTqArfb/QMCCBAgQIAAgbbAB3z/e0F3js2cAAAAAElFTkSuQmCC',\n  'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAN0lEQVRYR+3WQREAMBACsZ5/B5ilMvgEBTt5cW37hjsBBAgQIECAwFwgyfYPCCBAgAABAgTWAh81dWyx0gFwKAAAAABJRU5ErkJggg==',\n  'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAOklEQVRYR+3WoREAMAwDsWb/UQtCy9wxTOQJ/oQ8SXKKGwEECBAgQIBAXeDt7f4BAQQIECBAgEBb4AOz8Hzx7WLY4wAAAABJRU5ErkJggg==',\n  'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAABPUlEQVRYR+1XwW7CMAy1+f9fZOMysSEOEweEOPRNdm3HbdOyIhAcklPrOs/PLy9RygBALxzcCDQFmgJNgaZAU6Ap0BR4PwX8gsRMVLssMRH5HcpzJEaWL7EVg9F1IHRlyqQohgVr4FGUlUcMJSjcUlDw0zvjeun70cLWmneoyf7NgBTQSniBTQQSuJAZsOnnaczjIMb5hCiuHKxokCrJfVnrctyZL0PkJAJe1HMil4nxeyi3Ypfn1kX51jpPvo/JeCNC4PhVdHdJw2XjBR8brF8PEIhNVn12AgP7uHsTBguBn53MUZCqv7Lp07Pn5k1Ro+uWmUNn7D+M57rtk7aG0Vo73xyF/fbFf0bPJjDXngnGocDTdFhygZjwUQrMNrDcmZlQT50VJ/g/UwNyHpu778+yW+/ksOz/BFo54P4AsUXMfRq7XWsAAAAASUVORK5CYII=',\n  'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAACMElEQVRYR+2Xv4pTQRTGf2dubhLdICiii2KnYKHVolhauKWPoGAnNr6BD6CvIVaihYuI2i1ia0BY0MZGRHQXjZj/mSPnnskfNWiWZUlzJ5k7M2cm833nO5Mziej2DWWJRUoCpQKlAntSQCqgw39/iUWAGmh37jrRnVsKlgpiqmkoGVABA7E57fvY+pJDdgKqF6HzFCSADkDq+F6AHABtQ+UMVE5D7zXod7fFNhTEckTbj5XQgHzNN+5tQvc5NG7C6BNkp6D3EmpXHDR+dQAjFLchW3VS9rlw3JBh+B7ys5Cf9z0GW1C/7P32AyBAOAz1q4jGliIH3YPuBnSfQX4OGreTIgEYQb/pBDtPnEQ4CivXYPAWBk13oHrB54yA9QuSn2H4AcKRpEILDt0BUzj+RLR1V5EqjD66NPRBVpLcQwjHoHYJOhsQv6U4mnzmrIXJCFr4LDwm/xBUoboG9XX4cc9VKdYoSA2yk5NQLJaKDUjTBoveG3Z2TElTxwjNK4M3LEZgUdDdruvcXzKBpStgp2NPiWi3ks9ZXxIoFVi+AvHLdc9TqtjL3/aYjpPlrzOcEnK62Szhimdd7xX232zFDTgtxezOu3WNMRLjiKgjtOhHVMd1loynVHvOgjuIIJMaELEqhJAV/RCSLbWTcfPFakFgFlALTRRvx+ok6Hlp/Q+v3fmx90bMyUzaEAhmM3KvHlXTL5DxnbGf/1M8RNNACLL5MNtPxP/mypJAqcDSFfgFhpYqWUzhTEAAAAAASUVORK5CYII=',\n  'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAL0lEQVRYR+3QQREAAAzCsOFfNJPBJ1XQS9r2hsUAAQIECBAgQIAAAQIECBAgsBZ4MUx/ofm2I/kAAAAASUVORK5CYII=',\n  'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAL0lEQVRYR+3QQREAAAzCsOFfNJPBJ1XQS9r2hsUAAQIECBAgQIAAAQIECBAgsBZ4MUx/ofm2I/kAAAAASUVORK5CYII=',\n  'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAL0lEQVRYR+3QQREAAAzCsOFfNJPBJ1XQS9r2hsUAAQIECBAgQIAAAQIECBAgsBZ4MUx/ofm2I/kAAAAASUVORK5CYII=',\n  'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAL0lEQVRYR+3QQREAAAzCsOFfNJPBJ1XQS9r2hsUAAQIECBAgQIAAAQIECBAgsBZ4MUx/ofm2I/kAAAAASUVORK5CYII=',\n]\n\n// Builders. They build Three.js object from Object data parsed by MMDParser.\n\n/**\n * @param {THREE.LoadingManager} manager\n */\nclass MeshBuilder {\n  constructor(manager) {\n    this.crossOrigin = 'anonymous'\n    this.geometryBuilder = new GeometryBuilder()\n    this.materialBuilder = new MaterialBuilder(manager)\n  }\n\n  /**\n   * @param {string} crossOrigin\n   * @return {MeshBuilder}\n   */\n  setCrossOrigin(crossOrigin) {\n    this.crossOrigin = crossOrigin\n    return this\n  }\n\n  /**\n   * @param {Object} data - parsed PMD/PMX data\n   * @param {string} resourcePath\n   * @param {function} onProgress\n   * @param {function} onError\n   * @return {SkinnedMesh}\n   */\n  build(data, resourcePath, onProgress, onError) {\n    const geometry = this.geometryBuilder.build(data)\n    const material = this.materialBuilder\n      .setCrossOrigin(this.crossOrigin)\n      .setResourcePath(resourcePath)\n      .build(data, geometry, onProgress, onError)\n\n    const mesh = new SkinnedMesh(geometry, material)\n\n    const skeleton = new Skeleton(initBones(mesh))\n    mesh.bind(skeleton)\n\n    // console.log( mesh ); // for console debug\n\n    return mesh\n  }\n}\n\n// TODO: Try to remove this function\n\nfunction initBones(mesh) {\n  const geometry = mesh.geometry\n\n  const bones = []\n\n  if (geometry && geometry.bones !== undefined) {\n    // first, create array of 'Bone' objects from geometry data\n\n    for (let i = 0, il = geometry.bones.length; i < il; i++) {\n      const gbone = geometry.bones[i]\n\n      // create new 'Bone' object\n\n      const bone = new Bone()\n      bones.push(bone)\n\n      // apply values\n\n      bone.name = gbone.name\n      bone.position.fromArray(gbone.pos)\n      bone.quaternion.fromArray(gbone.rotq)\n      if (gbone.scl !== undefined) bone.scale.fromArray(gbone.scl)\n    }\n\n    // second, create bone hierarchy\n\n    for (let i = 0, il = geometry.bones.length; i < il; i++) {\n      const gbone = geometry.bones[i]\n\n      if (gbone.parent !== -1 && gbone.parent !== null && bones[gbone.parent] !== undefined) {\n        // subsequent bones in the hierarchy\n\n        bones[gbone.parent].add(bones[i])\n      } else {\n        // topmost bone, immediate child of the skinned mesh\n\n        mesh.add(bones[i])\n      }\n    }\n  }\n\n  // now the bones are part of the scene graph and children of the skinned mesh.\n  // let's update the corresponding matrices\n\n  mesh.updateMatrixWorld(true)\n\n  return bones\n}\n\n//\n\nclass GeometryBuilder {\n  /**\n   * @param {Object} data - parsed PMD/PMX data\n   * @return {BufferGeometry}\n   */\n  build(data) {\n    // for geometry\n    const positions = []\n    const uvs = []\n    const normals = []\n\n    const indices = []\n\n    const groups = []\n\n    const bones = []\n    const skinIndices = []\n    const skinWeights = []\n\n    const morphTargets = []\n    const morphPositions = []\n\n    const iks = []\n    const grants = []\n\n    const rigidBodies = []\n    const constraints = []\n\n    // for work\n    let offset = 0\n    const boneTypeTable = {}\n\n    // positions, normals, uvs, skinIndices, skinWeights\n\n    for (let i = 0; i < data.metadata.vertexCount; i++) {\n      const v = data.vertices[i]\n\n      for (let j = 0, jl = v.position.length; j < jl; j++) {\n        positions.push(v.position[j])\n      }\n\n      for (let j = 0, jl = v.normal.length; j < jl; j++) {\n        normals.push(v.normal[j])\n      }\n\n      for (let j = 0, jl = v.uv.length; j < jl; j++) {\n        uvs.push(v.uv[j])\n      }\n\n      for (let j = 0; j < 4; j++) {\n        skinIndices.push(v.skinIndices.length - 1 >= j ? v.skinIndices[j] : 0.0)\n      }\n\n      for (let j = 0; j < 4; j++) {\n        skinWeights.push(v.skinWeights.length - 1 >= j ? v.skinWeights[j] : 0.0)\n      }\n    }\n\n    // indices\n\n    for (let i = 0; i < data.metadata.faceCount; i++) {\n      const face = data.faces[i]\n\n      for (let j = 0, jl = face.indices.length; j < jl; j++) {\n        indices.push(face.indices[j])\n      }\n    }\n\n    // groups\n\n    for (let i = 0; i < data.metadata.materialCount; i++) {\n      const material = data.materials[i]\n\n      groups.push({\n        offset: offset * 3,\n        count: material.faceCount * 3,\n      })\n\n      offset += material.faceCount\n    }\n\n    // bones\n\n    for (let i = 0; i < data.metadata.rigidBodyCount; i++) {\n      const body = data.rigidBodies[i]\n      let value = boneTypeTable[body.boneIndex]\n\n      // keeps greater number if already value is set without any special reasons\n      value = value === undefined ? body.type : Math.max(body.type, value)\n\n      boneTypeTable[body.boneIndex] = value\n    }\n\n    for (let i = 0; i < data.metadata.boneCount; i++) {\n      const boneData = data.bones[i]\n\n      const bone = {\n        index: i,\n        transformationClass: boneData.transformationClass,\n        parent: boneData.parentIndex,\n        name: boneData.name,\n        pos: boneData.position.slice(0, 3),\n        rotq: [0, 0, 0, 1],\n        scl: [1, 1, 1],\n        rigidBodyType: boneTypeTable[i] !== undefined ? boneTypeTable[i] : -1,\n      }\n\n      if (bone.parent !== -1) {\n        bone.pos[0] -= data.bones[bone.parent].position[0]\n        bone.pos[1] -= data.bones[bone.parent].position[1]\n        bone.pos[2] -= data.bones[bone.parent].position[2]\n      }\n\n      bones.push(bone)\n    }\n\n    // iks\n\n    // TODO: remove duplicated codes between PMD and PMX\n    if (data.metadata.format === 'pmd') {\n      for (let i = 0; i < data.metadata.ikCount; i++) {\n        const ik = data.iks[i]\n\n        const param = {\n          target: ik.target,\n          effector: ik.effector,\n          iteration: ik.iteration,\n          maxAngle: ik.maxAngle * 4,\n          links: [],\n        }\n\n        for (let j = 0, jl = ik.links.length; j < jl; j++) {\n          const link = {}\n          link.index = ik.links[j].index\n          link.enabled = true\n\n          if (data.bones[link.index].name.indexOf('ひざ') >= 0) {\n            link.limitation = new Vector3(1.0, 0.0, 0.0)\n          }\n\n          param.links.push(link)\n        }\n\n        iks.push(param)\n      }\n    } else {\n      for (let i = 0; i < data.metadata.boneCount; i++) {\n        const ik = data.bones[i].ik\n\n        if (ik === undefined) continue\n\n        const param = {\n          target: i,\n          effector: ik.effector,\n          iteration: ik.iteration,\n          maxAngle: ik.maxAngle,\n          links: [],\n        }\n\n        for (let j = 0, jl = ik.links.length; j < jl; j++) {\n          const link = {}\n          link.index = ik.links[j].index\n          link.enabled = true\n\n          if (ik.links[j].angleLimitation === 1) {\n            // Revert if rotationMin/Max doesn't work well\n            // link.limitation = new Vector3( 1.0, 0.0, 0.0 );\n\n            const rotationMin = ik.links[j].lowerLimitationAngle\n            const rotationMax = ik.links[j].upperLimitationAngle\n\n            // Convert Left to Right coordinate by myself because\n            // MMDParser doesn't convert. It's a MMDParser's bug\n\n            const tmp1 = -rotationMax[0]\n            const tmp2 = -rotationMax[1]\n            rotationMax[0] = -rotationMin[0]\n            rotationMax[1] = -rotationMin[1]\n            rotationMin[0] = tmp1\n            rotationMin[1] = tmp2\n\n            link.rotationMin = new Vector3().fromArray(rotationMin)\n            link.rotationMax = new Vector3().fromArray(rotationMax)\n          }\n\n          param.links.push(link)\n        }\n\n        iks.push(param)\n\n        // Save the reference even from bone data for efficiently\n        // simulating PMX animation system\n        bones[i].ik = param\n      }\n    }\n\n    // grants\n\n    if (data.metadata.format === 'pmx') {\n      // bone index -> grant entry map\n      const grantEntryMap = {}\n\n      for (let i = 0; i < data.metadata.boneCount; i++) {\n        const boneData = data.bones[i]\n        const grant = boneData.grant\n\n        if (grant === undefined) continue\n\n        const param = {\n          index: i,\n          parentIndex: grant.parentIndex,\n          ratio: grant.ratio,\n          isLocal: grant.isLocal,\n          affectRotation: grant.affectRotation,\n          affectPosition: grant.affectPosition,\n          transformationClass: boneData.transformationClass,\n        }\n\n        grantEntryMap[i] = { parent: null, children: [], param: param, visited: false }\n      }\n\n      const rootEntry = { parent: null, children: [], param: null, visited: false }\n\n      // Build a tree representing grant hierarchy\n\n      for (const boneIndex in grantEntryMap) {\n        const grantEntry = grantEntryMap[boneIndex]\n        const parentGrantEntry = grantEntryMap[grantEntry.parentIndex] || rootEntry\n\n        grantEntry.parent = parentGrantEntry\n        parentGrantEntry.children.push(grantEntry)\n      }\n\n      // Sort grant parameters from parents to children because\n      // grant uses parent's transform that parent's grant is already applied\n      // so grant should be applied in order from parents to children\n\n      function traverse(entry) {\n        if (entry.param) {\n          grants.push(entry.param)\n\n          // Save the reference even from bone data for efficiently\n          // simulating PMX animation system\n          bones[entry.param.index].grant = entry.param\n        }\n\n        entry.visited = true\n\n        for (let i = 0, il = entry.children.length; i < il; i++) {\n          const child = entry.children[i]\n\n          // Cut off a loop if exists. (Is a grant loop invalid?)\n          if (!child.visited) traverse(child)\n        }\n      }\n\n      traverse(rootEntry)\n    }\n\n    // morph\n\n    function updateAttributes(attribute, morph, ratio) {\n      for (let i = 0; i < morph.elementCount; i++) {\n        const element = morph.elements[i]\n\n        let index\n\n        if (data.metadata.format === 'pmd') {\n          index = data.morphs[0].elements[element.index].index\n        } else {\n          index = element.index\n        }\n\n        attribute.array[index * 3 + 0] += element.position[0] * ratio\n        attribute.array[index * 3 + 1] += element.position[1] * ratio\n        attribute.array[index * 3 + 2] += element.position[2] * ratio\n      }\n    }\n\n    for (let i = 0; i < data.metadata.morphCount; i++) {\n      const morph = data.morphs[i]\n      const params = { name: morph.name }\n\n      const attribute = new Float32BufferAttribute(data.metadata.vertexCount * 3, 3)\n      attribute.name = morph.name\n\n      for (let j = 0; j < data.metadata.vertexCount * 3; j++) {\n        attribute.array[j] = positions[j]\n      }\n\n      if (data.metadata.format === 'pmd') {\n        if (i !== 0) {\n          updateAttributes(attribute, morph, 1.0)\n        }\n      } else {\n        if (morph.type === 0) {\n          // group\n\n          for (let j = 0; j < morph.elementCount; j++) {\n            const morph2 = data.morphs[morph.elements[j].index]\n            const ratio = morph.elements[j].ratio\n\n            if (morph2.type === 1) {\n              updateAttributes(attribute, morph2, ratio)\n            } else {\n              // TODO: implement\n            }\n          }\n        } else if (morph.type === 1) {\n          // vertex\n\n          updateAttributes(attribute, morph, 1.0)\n        } else if (morph.type === 2) {\n          // bone\n          // TODO: implement\n        } else if (morph.type === 3) {\n          // uv\n          // TODO: implement\n        } else if (morph.type === 4) {\n          // additional uv1\n          // TODO: implement\n        } else if (morph.type === 5) {\n          // additional uv2\n          // TODO: implement\n        } else if (morph.type === 6) {\n          // additional uv3\n          // TODO: implement\n        } else if (morph.type === 7) {\n          // additional uv4\n          // TODO: implement\n        } else if (morph.type === 8) {\n          // material\n          // TODO: implement\n        }\n      }\n\n      morphTargets.push(params)\n      morphPositions.push(attribute)\n    }\n\n    // rigid bodies from rigidBodies field.\n\n    for (let i = 0; i < data.metadata.rigidBodyCount; i++) {\n      const rigidBody = data.rigidBodies[i]\n      const params = {}\n\n      for (const key in rigidBody) {\n        params[key] = rigidBody[key]\n      }\n\n      /*\n       * RigidBody position parameter in PMX seems global position\n       * while the one in PMD seems offset from corresponding bone.\n       * So unify being offset.\n       */\n      if (data.metadata.format === 'pmx') {\n        if (params.boneIndex !== -1) {\n          const bone = data.bones[params.boneIndex]\n          params.position[0] -= bone.position[0]\n          params.position[1] -= bone.position[1]\n          params.position[2] -= bone.position[2]\n        }\n      }\n\n      rigidBodies.push(params)\n    }\n\n    // constraints from constraints field.\n\n    for (let i = 0; i < data.metadata.constraintCount; i++) {\n      const constraint = data.constraints[i]\n      const params = {}\n\n      for (const key in constraint) {\n        params[key] = constraint[key]\n      }\n\n      const bodyA = rigidBodies[params.rigidBodyIndex1]\n      const bodyB = rigidBodies[params.rigidBodyIndex2]\n\n      // Refer to http://www20.atpages.jp/katwat/wp/?p=4135\n      if (bodyA.type !== 0 && bodyB.type === 2) {\n        if (\n          bodyA.boneIndex !== -1 &&\n          bodyB.boneIndex !== -1 &&\n          data.bones[bodyB.boneIndex].parentIndex === bodyA.boneIndex\n        ) {\n          bodyB.type = 1\n        }\n      }\n\n      constraints.push(params)\n    }\n\n    // build BufferGeometry.\n\n    const geometry = new BufferGeometry()\n\n    geometry.setAttribute('position', new Float32BufferAttribute(positions, 3))\n    geometry.setAttribute('normal', new Float32BufferAttribute(normals, 3))\n    geometry.setAttribute('uv', new Float32BufferAttribute(uvs, 2))\n    geometry.setAttribute('skinIndex', new Uint16BufferAttribute(skinIndices, 4))\n    geometry.setAttribute('skinWeight', new Float32BufferAttribute(skinWeights, 4))\n    geometry.setIndex(indices)\n\n    for (let i = 0, il = groups.length; i < il; i++) {\n      geometry.addGroup(groups[i].offset, groups[i].count, i)\n    }\n\n    geometry.bones = bones\n\n    geometry.morphTargets = morphTargets\n    geometry.morphAttributes.position = morphPositions\n    geometry.morphTargetsRelative = false\n\n    geometry.userData.MMD = {\n      bones: bones,\n      iks: iks,\n      grants: grants,\n      rigidBodies: rigidBodies,\n      constraints: constraints,\n      format: data.metadata.format,\n    }\n\n    geometry.computeBoundingSphere()\n\n    return geometry\n  }\n}\n\n//\n\n/**\n * @param {THREE.LoadingManager} manager\n */\nclass MaterialBuilder {\n  constructor(manager) {\n    this.manager = manager\n\n    this.textureLoader = new TextureLoader(this.manager)\n    this.tgaLoader = null // lazy generation\n\n    this.crossOrigin = 'anonymous'\n    this.resourcePath = undefined\n  }\n\n  /**\n   * @param {string} crossOrigin\n   * @return {MaterialBuilder}\n   */\n  setCrossOrigin(crossOrigin) {\n    this.crossOrigin = crossOrigin\n    return this\n  }\n\n  /**\n   * @param {string} resourcePath\n   * @return {MaterialBuilder}\n   */\n  setResourcePath(resourcePath) {\n    this.resourcePath = resourcePath\n    return this\n  }\n\n  /**\n   * @param {Object} data - parsed PMD/PMX data\n   * @param {BufferGeometry} geometry - some properties are dependend on geometry\n   * @param {function} onProgress\n   * @param {function} onError\n   * @return {Array<MeshToonMaterial>}\n   */\n  build(data, geometry /*, onProgress, onError */) {\n    const materials = []\n\n    const textures = {}\n\n    this.textureLoader.setCrossOrigin(this.crossOrigin)\n\n    // materials\n\n    for (let i = 0; i < data.metadata.materialCount; i++) {\n      const material = data.materials[i]\n\n      const params = { userData: {} }\n\n      if (material.name !== undefined) params.name = material.name\n\n      /*\n       * Color\n       *\n       * MMD         MeshToonMaterial\n       * diffuse  -  color\n       * ambient  -  emissive * a\n       *               (a = 1.0 without map texture or 0.2 with map texture)\n       *\n       * MeshToonMaterial doesn't have ambient. Set it to emissive instead.\n       * It'll be too bright if material has map texture so using coef 0.2.\n       */\n      params.color = new Color().fromArray(material.diffuse)\n      params.opacity = material.diffuse[3]\n      params.emissive = new Color().fromArray(material.ambient)\n      params.transparent = params.opacity !== 1.0\n\n      //\n\n      params.skinning = geometry.bones.length > 0 ? true : false\n      params.morphTargets = geometry.morphTargets.length > 0 ? true : false\n      params.fog = true\n\n      // blend\n\n      params.blending = CustomBlending\n      params.blendSrc = SrcAlphaFactor\n      params.blendDst = OneMinusSrcAlphaFactor\n      params.blendSrcAlpha = SrcAlphaFactor\n      params.blendDstAlpha = DstAlphaFactor\n\n      // side\n\n      if (data.metadata.format === 'pmx' && (material.flag & 0x1) === 1) {\n        params.side = DoubleSide\n      } else {\n        params.side = params.opacity === 1.0 ? FrontSide : DoubleSide\n      }\n\n      if (data.metadata.format === 'pmd') {\n        // map, envMap\n\n        if (material.fileName) {\n          const fileName = material.fileName\n          const fileNames = fileName.split('*')\n\n          // fileNames[ 0 ]: mapFileName\n          // fileNames[ 1 ]: envMapFileName( optional )\n\n          params.map = this._loadTexture(fileNames[0], textures)\n\n          if (fileNames.length > 1) {\n            const extension = fileNames[1].slice(-4).toLowerCase()\n\n            params.envMap = this._loadTexture(fileNames[1], textures)\n\n            params.combine = extension === '.sph' ? MultiplyOperation : AddOperation\n          }\n        }\n\n        // gradientMap\n\n        const toonFileName = material.toonIndex === -1 ? 'toon00.bmp' : data.toonTextures[material.toonIndex].fileName\n\n        params.gradientMap = this._loadTexture(toonFileName, textures, {\n          isToonTexture: true,\n          isDefaultToonTexture: this._isDefaultToonTexture(toonFileName),\n        })\n\n        // parameters for OutlineEffect\n\n        params.userData.outlineParameters = {\n          thickness: material.edgeFlag === 1 ? 0.003 : 0.0,\n          color: [0, 0, 0],\n          alpha: 1.0,\n          visible: material.edgeFlag === 1,\n        }\n      } else {\n        // map\n\n        if (material.textureIndex !== -1) {\n          params.map = this._loadTexture(data.textures[material.textureIndex], textures)\n        }\n\n        // envMap TODO: support m.envFlag === 3\n\n        if (material.envTextureIndex !== -1 && (material.envFlag === 1 || material.envFlag == 2)) {\n          params.envMap = this._loadTexture(data.textures[material.envTextureIndex], textures)\n\n          params.combine = material.envFlag === 1 ? MultiplyOperation : AddOperation\n        }\n\n        // gradientMap\n\n        let toonFileName, isDefaultToon\n\n        if (material.toonIndex === -1 || material.toonFlag !== 0) {\n          toonFileName = 'toon' + ('0' + (material.toonIndex + 1)).slice(-2) + '.bmp'\n          isDefaultToon = true\n        } else {\n          toonFileName = data.textures[material.toonIndex]\n          isDefaultToon = false\n        }\n\n        params.gradientMap = this._loadTexture(toonFileName, textures, {\n          isToonTexture: true,\n          isDefaultToonTexture: isDefaultToon,\n        })\n\n        // parameters for OutlineEffect\n        params.userData.outlineParameters = {\n          thickness: material.edgeSize / 300, // TODO: better calculation?\n          color: material.edgeColor.slice(0, 3),\n          alpha: material.edgeColor[3],\n          visible: (material.flag & 0x10) !== 0 && material.edgeSize > 0.0,\n        }\n      }\n\n      if (params.map !== undefined) {\n        if (!params.transparent) {\n          this._checkImageTransparency(params.map, geometry, i)\n        }\n\n        params.emissive.multiplyScalar(0.2)\n      }\n\n      materials.push(new MeshToonMaterial(params))\n    }\n\n    if (data.metadata.format === 'pmx') {\n      // set transparent true if alpha morph is defined.\n\n      function checkAlphaMorph(elements, materials) {\n        for (let i = 0, il = elements.length; i < il; i++) {\n          const element = elements[i]\n\n          if (element.index === -1) continue\n\n          const material = materials[element.index]\n\n          if (material.opacity !== element.diffuse[3]) {\n            material.transparent = true\n          }\n        }\n      }\n\n      for (let i = 0, il = data.morphs.length; i < il; i++) {\n        const morph = data.morphs[i]\n        const elements = morph.elements\n\n        if (morph.type === 0) {\n          for (let j = 0, jl = elements.length; j < jl; j++) {\n            const morph2 = data.morphs[elements[j].index]\n\n            if (morph2.type !== 8) continue\n\n            checkAlphaMorph(morph2.elements, materials)\n          }\n        } else if (morph.type === 8) {\n          checkAlphaMorph(elements, materials)\n        }\n      }\n    }\n\n    return materials\n  }\n\n  // private methods\n\n  _getTGALoader() {\n    if (this.tgaLoader === null) {\n      if (TGALoader === undefined) {\n        throw new Error('THREE.MMDLoader: Import TGALoader')\n      }\n\n      this.tgaLoader = new TGALoader(this.manager)\n    }\n\n    return this.tgaLoader\n  }\n\n  _isDefaultToonTexture(name) {\n    if (name.length !== 10) return false\n\n    return /toon(10|0[0-9])\\.bmp/.test(name)\n  }\n\n  _loadTexture(filePath, textures, params, onProgress, onError) {\n    params = params || {}\n\n    const scope = this\n\n    let fullPath\n\n    if (params.isDefaultToonTexture === true) {\n      let index\n\n      try {\n        index = parseInt(filePath.match(/toon([0-9]{2})\\.bmp$/)[1])\n      } catch (e) {\n        console.warn(\n          'THREE.MMDLoader: ' +\n            filePath +\n            ' seems like a ' +\n            'not right default texture path. Using toon00.bmp instead.',\n        )\n\n        index = 0\n      }\n\n      fullPath = DEFAULT_TOON_TEXTURES[index]\n    } else {\n      fullPath = this.resourcePath + filePath\n    }\n\n    if (textures[fullPath] !== undefined) return textures[fullPath]\n\n    let loader = this.manager.getHandler(fullPath)\n\n    if (loader === null) {\n      loader = filePath.slice(-4).toLowerCase() === '.tga' ? this._getTGALoader() : this.textureLoader\n    }\n\n    const texture = loader.load(\n      fullPath,\n      function (t) {\n        // MMD toon texture is Axis-Y oriented\n        // but Three.js gradient map is Axis-X oriented.\n        // So here replaces the toon texture image with the rotated one.\n        if (params.isToonTexture === true) {\n          t.image = scope._getRotatedImage(t.image)\n\n          t.magFilter = NearestFilter\n          t.minFilter = NearestFilter\n        }\n\n        t.flipY = false\n        t.wrapS = RepeatWrapping\n        t.wrapT = RepeatWrapping\n\n        for (let i = 0; i < texture.readyCallbacks.length; i++) {\n          texture.readyCallbacks[i](texture)\n        }\n\n        delete texture.readyCallbacks\n      },\n      onProgress,\n      onError,\n    )\n\n    texture.readyCallbacks = []\n\n    textures[fullPath] = texture\n\n    return texture\n  }\n\n  _getRotatedImage(image) {\n    const canvas = document.createElement('canvas')\n    const context = canvas.getContext('2d')\n\n    const width = image.width\n    const height = image.height\n\n    canvas.width = width\n    canvas.height = height\n\n    context.clearRect(0, 0, width, height)\n    context.translate(width / 2.0, height / 2.0)\n    context.rotate(0.5 * Math.PI) // 90.0 * Math.PI / 180.0\n    context.translate(-width / 2.0, -height / 2.0)\n    context.drawImage(image, 0, 0)\n\n    return context.getImageData(0, 0, width, height)\n  }\n\n  // Check if the partial image area used by the texture is transparent.\n  _checkImageTransparency(map, geometry, groupIndex) {\n    map.readyCallbacks.push(function (texture) {\n      // Is there any efficient ways?\n      function createImageData(image) {\n        const canvas = document.createElement('canvas')\n        canvas.width = image.width\n        canvas.height = image.height\n\n        const context = canvas.getContext('2d')\n        context.drawImage(image, 0, 0)\n\n        return context.getImageData(0, 0, canvas.width, canvas.height)\n      }\n\n      function detectImageTransparency(image, uvs, indices) {\n        const width = image.width\n        const height = image.height\n        const data = image.data\n        const threshold = 253\n\n        if (data.length / (width * height) !== 4) return false\n\n        for (let i = 0; i < indices.length; i += 3) {\n          const centerUV = { x: 0.0, y: 0.0 }\n\n          for (let j = 0; j < 3; j++) {\n            const index = indices[i * 3 + j]\n            const uv = { x: uvs[index * 2 + 0], y: uvs[index * 2 + 1] }\n\n            if (getAlphaByUv(image, uv) < threshold) return true\n\n            centerUV.x += uv.x\n            centerUV.y += uv.y\n          }\n\n          centerUV.x /= 3\n          centerUV.y /= 3\n\n          if (getAlphaByUv(image, centerUV) < threshold) return true\n        }\n\n        return false\n      }\n\n      /*\n       * This method expects\n       *   texture.flipY = false\n       *   texture.wrapS = RepeatWrapping\n       *   texture.wrapT = RepeatWrapping\n       * TODO: more precise\n       */\n      function getAlphaByUv(image, uv) {\n        const width = image.width\n        const height = image.height\n\n        let x = Math.round(uv.x * width) % width\n        let y = Math.round(uv.y * height) % height\n\n        if (x < 0) x += width\n        if (y < 0) y += height\n\n        const index = y * width + x\n\n        return image.data[index * 4 + 3]\n      }\n\n      const imageData = texture.image.data !== undefined ? texture.image : createImageData(texture.image)\n\n      const group = geometry.groups[groupIndex]\n\n      if (\n        detectImageTransparency(\n          imageData,\n          geometry.attributes.uv.array,\n          geometry.index.array.slice(group.start, group.start + group.count),\n        )\n      ) {\n        map.transparent = true\n      }\n    })\n  }\n}\n\n//\n\nclass AnimationBuilder {\n  /**\n   * @param {Object} vmd - parsed VMD data\n   * @param {SkinnedMesh} mesh - tracks will be fitting to mesh\n   * @return {AnimationClip}\n   */\n  build(vmd, mesh) {\n    // combine skeletal and morph animations\n\n    const tracks = this.buildSkeletalAnimation(vmd, mesh).tracks\n    const tracks2 = this.buildMorphAnimation(vmd, mesh).tracks\n\n    for (let i = 0, il = tracks2.length; i < il; i++) {\n      tracks.push(tracks2[i])\n    }\n\n    return new AnimationClip('', -1, tracks)\n  }\n\n  /**\n   * @param {Object} vmd - parsed VMD data\n   * @param {SkinnedMesh} mesh - tracks will be fitting to mesh\n   * @return {AnimationClip}\n   */\n  buildSkeletalAnimation(vmd, mesh) {\n    function pushInterpolation(array, interpolation, index) {\n      array.push(interpolation[index + 0] / 127) // x1\n      array.push(interpolation[index + 8] / 127) // x2\n      array.push(interpolation[index + 4] / 127) // y1\n      array.push(interpolation[index + 12] / 127) // y2\n    }\n\n    const tracks = []\n\n    const motions = {}\n    const bones = mesh.skeleton.bones\n    const boneNameDictionary = {}\n\n    for (let i = 0, il = bones.length; i < il; i++) {\n      boneNameDictionary[bones[i].name] = true\n    }\n\n    for (let i = 0; i < vmd.metadata.motionCount; i++) {\n      const motion = vmd.motions[i]\n      const boneName = motion.boneName\n\n      if (boneNameDictionary[boneName] === undefined) continue\n\n      motions[boneName] = motions[boneName] || []\n      motions[boneName].push(motion)\n    }\n\n    for (const key in motions) {\n      const array = motions[key]\n\n      array.sort(function (a, b) {\n        return a.frameNum - b.frameNum\n      })\n\n      const times = []\n      const positions = []\n      const rotations = []\n      const pInterpolations = []\n      const rInterpolations = []\n\n      const basePosition = mesh.skeleton.getBoneByName(key).position.toArray()\n\n      for (let i = 0, il = array.length; i < il; i++) {\n        const time = array[i].frameNum / 30\n        const position = array[i].position\n        const rotation = array[i].rotation\n        const interpolation = array[i].interpolation\n\n        times.push(time)\n\n        for (let j = 0; j < 3; j++) positions.push(basePosition[j] + position[j])\n        for (let j = 0; j < 4; j++) rotations.push(rotation[j])\n        for (let j = 0; j < 3; j++) pushInterpolation(pInterpolations, interpolation, j)\n\n        pushInterpolation(rInterpolations, interpolation, 3)\n      }\n\n      const targetName = '.bones[' + key + ']'\n\n      tracks.push(this._createTrack(targetName + '.position', VectorKeyframeTrack, times, positions, pInterpolations))\n      tracks.push(\n        this._createTrack(targetName + '.quaternion', QuaternionKeyframeTrack, times, rotations, rInterpolations),\n      )\n    }\n\n    return new AnimationClip('', -1, tracks)\n  }\n\n  /**\n   * @param {Object} vmd - parsed VMD data\n   * @param {SkinnedMesh} mesh - tracks will be fitting to mesh\n   * @return {AnimationClip}\n   */\n  buildMorphAnimation(vmd, mesh) {\n    const tracks = []\n\n    const morphs = {}\n    const morphTargetDictionary = mesh.morphTargetDictionary\n\n    for (let i = 0; i < vmd.metadata.morphCount; i++) {\n      const morph = vmd.morphs[i]\n      const morphName = morph.morphName\n\n      if (morphTargetDictionary[morphName] === undefined) continue\n\n      morphs[morphName] = morphs[morphName] || []\n      morphs[morphName].push(morph)\n    }\n\n    for (const key in morphs) {\n      const array = morphs[key]\n\n      array.sort(function (a, b) {\n        return a.frameNum - b.frameNum\n      })\n\n      const times = []\n      const values = []\n\n      for (let i = 0, il = array.length; i < il; i++) {\n        times.push(array[i].frameNum / 30)\n        values.push(array[i].weight)\n      }\n\n      tracks.push(new NumberKeyframeTrack('.morphTargetInfluences[' + morphTargetDictionary[key] + ']', times, values))\n    }\n\n    return new AnimationClip('', -1, tracks)\n  }\n\n  /**\n   * @param {Object} vmd - parsed VMD data\n   * @return {AnimationClip}\n   */\n  buildCameraAnimation(vmd) {\n    function pushVector3(array, vec) {\n      array.push(vec.x)\n      array.push(vec.y)\n      array.push(vec.z)\n    }\n\n    function pushQuaternion(array, q) {\n      array.push(q.x)\n      array.push(q.y)\n      array.push(q.z)\n      array.push(q.w)\n    }\n\n    function pushInterpolation(array, interpolation, index) {\n      array.push(interpolation[index * 4 + 0] / 127) // x1\n      array.push(interpolation[index * 4 + 1] / 127) // x2\n      array.push(interpolation[index * 4 + 2] / 127) // y1\n      array.push(interpolation[index * 4 + 3] / 127) // y2\n    }\n\n    const cameras = vmd.cameras === undefined ? [] : vmd.cameras.slice()\n\n    cameras.sort(function (a, b) {\n      return a.frameNum - b.frameNum\n    })\n\n    const times = []\n    const centers = []\n    const quaternions = []\n    const positions = []\n    const fovs = []\n\n    const cInterpolations = []\n    const qInterpolations = []\n    const pInterpolations = []\n    const fInterpolations = []\n\n    const quaternion = new Quaternion()\n    const euler = new Euler()\n    const position = new Vector3()\n    const center = new Vector3()\n\n    for (let i = 0, il = cameras.length; i < il; i++) {\n      const motion = cameras[i]\n\n      const time = motion.frameNum / 30\n      const pos = motion.position\n      const rot = motion.rotation\n      const distance = motion.distance\n      const fov = motion.fov\n      const interpolation = motion.interpolation\n\n      times.push(time)\n\n      position.set(0, 0, -distance)\n      center.set(pos[0], pos[1], pos[2])\n\n      euler.set(-rot[0], -rot[1], -rot[2])\n      quaternion.setFromEuler(euler)\n\n      position.add(center)\n      position.applyQuaternion(quaternion)\n\n      pushVector3(centers, center)\n      pushQuaternion(quaternions, quaternion)\n      pushVector3(positions, position)\n\n      fovs.push(fov)\n\n      for (let j = 0; j < 3; j++) {\n        pushInterpolation(cInterpolations, interpolation, j)\n      }\n\n      pushInterpolation(qInterpolations, interpolation, 3)\n\n      // use the same parameter for x, y, z axis.\n      for (let j = 0; j < 3; j++) {\n        pushInterpolation(pInterpolations, interpolation, 4)\n      }\n\n      pushInterpolation(fInterpolations, interpolation, 5)\n    }\n\n    const tracks = []\n\n    // I expect an object whose name 'target' exists under THREE.Camera\n    tracks.push(this._createTrack('target.position', VectorKeyframeTrack, times, centers, cInterpolations))\n\n    tracks.push(this._createTrack('.quaternion', QuaternionKeyframeTrack, times, quaternions, qInterpolations))\n    tracks.push(this._createTrack('.position', VectorKeyframeTrack, times, positions, pInterpolations))\n    tracks.push(this._createTrack('.fov', NumberKeyframeTrack, times, fovs, fInterpolations))\n\n    return new AnimationClip('', -1, tracks)\n  }\n\n  // private method\n\n  _createTrack(node, typedKeyframeTrack, times, values, interpolations) {\n    /*\n     * optimizes here not to let KeyframeTrackPrototype optimize\n     * because KeyframeTrackPrototype optimizes times and values but\n     * doesn't optimize interpolations.\n     */\n    if (times.length > 2) {\n      times = times.slice()\n      values = values.slice()\n      interpolations = interpolations.slice()\n\n      const stride = values.length / times.length\n      const interpolateStride = interpolations.length / times.length\n\n      let index = 1\n\n      for (let aheadIndex = 2, endIndex = times.length; aheadIndex < endIndex; aheadIndex++) {\n        for (let i = 0; i < stride; i++) {\n          if (\n            values[index * stride + i] !== values[(index - 1) * stride + i] ||\n            values[index * stride + i] !== values[aheadIndex * stride + i]\n          ) {\n            index++\n            break\n          }\n        }\n\n        if (aheadIndex > index) {\n          times[index] = times[aheadIndex]\n\n          for (let i = 0; i < stride; i++) {\n            values[index * stride + i] = values[aheadIndex * stride + i]\n          }\n\n          for (let i = 0; i < interpolateStride; i++) {\n            interpolations[index * interpolateStride + i] = interpolations[aheadIndex * interpolateStride + i]\n          }\n        }\n      }\n\n      times.length = index + 1\n      values.length = (index + 1) * stride\n      interpolations.length = (index + 1) * interpolateStride\n    }\n\n    const track = new typedKeyframeTrack(node, times, values)\n\n    track.createInterpolant = function InterpolantFactoryMethodCubicBezier(result) {\n      return new CubicBezierInterpolation(\n        this.times,\n        this.values,\n        this.getValueSize(),\n        result,\n        new Float32Array(interpolations),\n      )\n    }\n\n    return track\n  }\n}\n\n// interpolation\n\nclass CubicBezierInterpolation extends Interpolant {\n  constructor(parameterPositions, sampleValues, sampleSize, resultBuffer, params) {\n    super(parameterPositions, sampleValues, sampleSize, resultBuffer)\n\n    this.interpolationParams = params\n  }\n\n  interpolate_(i1, t0, t, t1) {\n    const result = this.resultBuffer\n    const values = this.sampleValues\n    const stride = this.valueSize\n    const params = this.interpolationParams\n\n    const offset1 = i1 * stride\n    const offset0 = offset1 - stride\n\n    // No interpolation if next key frame is in one frame in 30fps.\n    // This is from MMD animation spec.\n    // '1.5' is for precision loss. times are Float32 in Three.js Animation system.\n    const weight1 = t1 - t0 < (1 / 30) * 1.5 ? 0.0 : (t - t0) / (t1 - t0)\n\n    if (stride === 4) {\n      // Quaternion\n\n      const x1 = params[i1 * 4 + 0]\n      const x2 = params[i1 * 4 + 1]\n      const y1 = params[i1 * 4 + 2]\n      const y2 = params[i1 * 4 + 3]\n\n      const ratio = this._calculate(x1, x2, y1, y2, weight1)\n\n      Quaternion.slerpFlat(result, 0, values, offset0, values, offset1, ratio)\n    } else if (stride === 3) {\n      // Vector3\n\n      for (let i = 0; i !== stride; ++i) {\n        const x1 = params[i1 * 12 + i * 4 + 0]\n        const x2 = params[i1 * 12 + i * 4 + 1]\n        const y1 = params[i1 * 12 + i * 4 + 2]\n        const y2 = params[i1 * 12 + i * 4 + 3]\n\n        const ratio = this._calculate(x1, x2, y1, y2, weight1)\n\n        result[i] = values[offset0 + i] * (1 - ratio) + values[offset1 + i] * ratio\n      }\n    } else {\n      // Number\n\n      const x1 = params[i1 * 4 + 0]\n      const x2 = params[i1 * 4 + 1]\n      const y1 = params[i1 * 4 + 2]\n      const y2 = params[i1 * 4 + 3]\n\n      const ratio = this._calculate(x1, x2, y1, y2, weight1)\n\n      result[0] = values[offset0] * (1 - ratio) + values[offset1] * ratio\n    }\n\n    return result\n  }\n\n  _calculate(x1, x2, y1, y2, x) {\n    /*\n     * Cubic Bezier curves\n     *   https://en.wikipedia.org/wiki/B%C3%A9zier_curve#Cubic_B.C3.A9zier_curves\n     *\n     * B(t) = ( 1 - t ) ^ 3 * P0\n     *      + 3 * ( 1 - t ) ^ 2 * t * P1\n     *      + 3 * ( 1 - t ) * t^2 * P2\n     *      + t ^ 3 * P3\n     *      ( 0 <= t <= 1 )\n     *\n     * MMD uses Cubic Bezier curves for bone and camera animation interpolation.\n     *   http://d.hatena.ne.jp/edvakf/20111016/1318716097\n     *\n     *    x = ( 1 - t ) ^ 3 * x0\n     *      + 3 * ( 1 - t ) ^ 2 * t * x1\n     *      + 3 * ( 1 - t ) * t^2 * x2\n     *      + t ^ 3 * x3\n     *    y = ( 1 - t ) ^ 3 * y0\n     *      + 3 * ( 1 - t ) ^ 2 * t * y1\n     *      + 3 * ( 1 - t ) * t^2 * y2\n     *      + t ^ 3 * y3\n     *      ( x0 = 0, y0 = 0 )\n     *      ( x3 = 1, y3 = 1 )\n     *      ( 0 <= t, x1, x2, y1, y2 <= 1 )\n     *\n     * Here solves this equation with Bisection method,\n     *   https://en.wikipedia.org/wiki/Bisection_method\n     * gets t, and then calculate y.\n     *\n     * f(t) = 3 * ( 1 - t ) ^ 2 * t * x1\n     *      + 3 * ( 1 - t ) * t^2 * x2\n     *      + t ^ 3 - x = 0\n     *\n     * (Another option: Newton's method\n     *    https://en.wikipedia.org/wiki/Newton%27s_method)\n     */\n\n    let c = 0.5\n    let t = c\n    let s = 1.0 - t\n    const loop = 15\n    const eps = 1e-5\n    const math = Math\n\n    let sst3, stt3, ttt\n\n    for (let i = 0; i < loop; i++) {\n      sst3 = 3.0 * s * s * t\n      stt3 = 3.0 * s * t * t\n      ttt = t * t * t\n\n      const ft = sst3 * x1 + stt3 * x2 + ttt - x\n\n      if (math.abs(ft) < eps) break\n\n      c /= 2.0\n\n      t += ft < 0 ? c : -c\n      s = 1.0 - t\n    }\n\n    return sst3 * y1 + stt3 * y2 + ttt\n  }\n}\n\nexport { MMDLoader }\n"],"mappings":";;;;;;;IAmEMA,SAAA,0BAAAC,OAAA;EAAAC,SAAA,CAAAF,SAAA,EAAAC,OAAA;EAAA,IAAAE,MAAA,GAAAC,YAAA,CAAAJ,SAAA;EACJ,SAAAA,UAAYK,OAAA,EAAS;IAAA,IAAAC,KAAA;IAAAC,eAAA,OAAAP,SAAA;IACnBM,KAAA,GAAAH,MAAA,CAAAK,IAAA,OAAMH,OAAO;IAEbC,KAAA,CAAKG,MAAA,GAAS,IAAIC,UAAA,CAAWJ,KAAA,CAAKD,OAAO;IAEzCC,KAAA,CAAKK,MAAA,GAAS;IACdL,KAAA,CAAKM,WAAA,GAAc,IAAIC,WAAA,CAAYP,KAAA,CAAKD,OAAO;IAC/CC,KAAA,CAAKQ,gBAAA,GAAmB,IAAIC,gBAAA,CAAkB;IAAA,OAAAT,KAAA;EAC/C;EAAA;AAAA;AAAA;AAAA;EAAAU,YAAA,CAAAhB,SAAA;IAAAiB,GAAA;IAAAC,KAAA,EAMD,SAAAC,iBAAiBC,aAAA,EAAe;MAC9B,KAAKA,aAAA,GAAgBA,aAAA;MACrB,OAAO;IACR;IAAA;IAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;EAAA;IAAAH,GAAA;IAAAC,KAAA,EAYD,SAAAG,KAAKC,GAAA,EAAKC,MAAA,EAAQC,UAAA,EAAYC,OAAA,EAAS;MACrC,IAAMC,OAAA,GAAU,KAAKd,WAAA,CAAYe,cAAA,CAAe,KAAKC,WAAW;MAIhE,IAAIC,YAAA;MAEJ,IAAI,KAAKA,YAAA,KAAiB,IAAI;QAC5BA,YAAA,GAAe,KAAKA,YAAA;MAC1B,WAAe,KAAKC,IAAA,KAAS,IAAI;QAC3BD,YAAA,GAAe,KAAKC,IAAA;MAC1B,OAAW;QACLD,YAAA,GAAeE,WAAA,CAAYC,cAAA,CAAeV,GAAG;MAC9C;MAED,IAAMW,cAAA,GAAiB,KAAKC,iBAAA,CAAkBZ,GAAG,EAAEa,WAAA,CAAa;MAGhE,IAAIF,cAAA,KAAmB,SAASA,cAAA,KAAmB,OAAO;QACxD,IAAIR,OAAA,EAASA,OAAA,CAAQ,IAAIW,KAAA,CAAM,oDAAoDH,cAAA,GAAiB,GAAG,CAAC;QAExG;MACD;MAED,KAAKA,cAAA,KAAmB,QAAQ,YAAY,SAAS,EACnDX,GAAA,EACA,UAAUe,IAAA,EAAM;QACdd,MAAA,CAAOG,OAAA,CAAQY,KAAA,CAAMD,IAAA,EAAMR,YAAA,EAAcL,UAAA,EAAYC,OAAO,CAAC;MAC9D,GACDD,UAAA,EACAC,OACD;IACF;IAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;EAAA;IAAAR,GAAA;IAAAC,KAAA,EAYD,SAAAqB,cAAcjB,GAAA,EAAKkB,MAAA,EAAQjB,MAAA,EAAQC,UAAA,EAAYC,OAAA,EAAS;MACtD,IAAMC,OAAA,GAAU,KAAKZ,gBAAA;MAErB,KAAK2B,OAAA,CACHnB,GAAA,EACA,UAAUoB,GAAA,EAAK;QACbnB,MAAA,CAAOiB,MAAA,CAAOG,QAAA,GAAWjB,OAAA,CAAQkB,oBAAA,CAAqBF,GAAG,IAAIhB,OAAA,CAAQY,KAAA,CAAMI,GAAA,EAAKF,MAAM,CAAC;MACxF,GACDhB,UAAA,EACAC,OACD;IACF;IAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;EAAA;IAAAR,GAAA;IAAAC,KAAA,EAaD,SAAA2B,kBAAkBC,QAAA,EAAUC,MAAA,EAAQxB,MAAA,EAAQC,UAAA,EAAYC,OAAA,EAAS;MAC/D,IAAMuB,KAAA,GAAQ;MAEd,KAAK3B,IAAA,CACHyB,QAAA,EACA,UAAUG,IAAA,EAAM;QACdD,KAAA,CAAMT,aAAA,CACJQ,MAAA,EACAE,IAAA,EACA,UAAUC,SAAA,EAAW;UACnB3B,MAAA,CAAO;YACL0B,IAAA,EAAAA,IAAA;YACAC,SAAA,EAAAA;UACd,CAAa;QACF,GACD1B,UAAA,EACAC,OACD;MACF,GACDD,UAAA,EACAC,OACD;IACF;IAAA;IAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;EAAA;IAAAR,GAAA;IAAAC,KAAA,EAYD,SAAAiC,QAAQ7B,GAAA,EAAKC,MAAA,EAAQC,UAAA,EAAYC,OAAA,EAAS;MACxC,IAAMd,MAAA,GAAS,KAAKyC,UAAA,CAAY;MAEhC,KAAK3C,MAAA,CACF4C,WAAA,CAAY,MAAS,EACrBC,OAAA,CAAQ,KAAKxB,IAAI,EACjByB,eAAA,CAAgB,aAAa,EAC7BC,gBAAA,CAAiB,KAAKC,aAAa,EACnCC,kBAAA,CAAmB,KAAKC,eAAe,EACvCtC,IAAA,CACCC,GAAA,EACA,UAAUsC,MAAA,EAAQ;QAChBrC,MAAA,CAAOZ,MAAA,CAAOkD,QAAA,CAASD,MAAA,EAAQ,IAAI,CAAC;MACrC,GACDpC,UAAA,EACAC,OACD;IACJ;IAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;EAAA;IAAAR,GAAA;IAAAC,KAAA,EAUD,SAAA4C,QAAQxC,GAAA,EAAKC,MAAA,EAAQC,UAAA,EAAYC,OAAA,EAAS;MACxC,IAAMd,MAAA,GAAS,KAAKyC,UAAA,CAAY;MAEhC,KAAK3C,MAAA,CACF4C,WAAA,CAAY,MAAS,EACrBC,OAAA,CAAQ,KAAKxB,IAAI,EACjByB,eAAA,CAAgB,aAAa,EAC7BC,gBAAA,CAAiB,KAAKC,aAAa,EACnCC,kBAAA,CAAmB,KAAKC,eAAe,EACvCtC,IAAA,CACCC,GAAA,EACA,UAAUsC,MAAA,EAAQ;QAChBrC,MAAA,CAAOZ,MAAA,CAAOoD,QAAA,CAASH,MAAA,EAAQ,IAAI,CAAC;MACrC,GACDpC,UAAA,EACAC,OACD;IACJ;IAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;EAAA;IAAAR,GAAA;IAAAC,KAAA,EAWD,SAAAuB,QAAQnB,GAAA,EAAKC,MAAA,EAAQC,UAAA,EAAYC,OAAA,EAAS;MACxC,IAAMuC,IAAA,GAAOC,KAAA,CAAMC,OAAA,CAAQ5C,GAAG,IAAIA,GAAA,GAAM,CAACA,GAAG;MAE5C,IAAM6C,IAAA,GAAO,EAAE;MACf,IAAMC,MAAA,GAASJ,IAAA,CAAKK,MAAA;MAEpB,IAAM1D,MAAA,GAAS,KAAKyC,UAAA,CAAY;MAEhC,KAAK3C,MAAA,CACF4C,WAAA,CAAY,MAAS,EACrBC,OAAA,CAAQ,KAAKlC,aAAa,EAC1BmC,eAAA,CAAgB,aAAa,EAC7BC,gBAAA,CAAiB,KAAKC,aAAa,EACnCC,kBAAA,CAAmB,KAAKC,eAAe;MAE1C,SAASW,CAAA,GAAI,GAAGC,EAAA,GAAKP,IAAA,CAAKK,MAAA,EAAQC,CAAA,GAAIC,EAAA,EAAID,CAAA,IAAK;QAC7C,KAAK7D,MAAA,CAAOY,IAAA,CACV2C,IAAA,CAAKM,CAAC,GACN,UAAUV,MAAA,EAAQ;UAChBO,IAAA,CAAKK,IAAA,CAAK7D,MAAA,CAAO8D,QAAA,CAASb,MAAA,EAAQ,IAAI,CAAC;UAEvC,IAAIO,IAAA,CAAKE,MAAA,KAAWD,MAAA,EAAQ7C,MAAA,CAAOZ,MAAA,CAAO+D,SAAA,CAAUP,IAAI,CAAC;QAC1D,GACD3C,UAAA,EACAC,OACD;MACF;IACF;IAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;EAAA;IAAAR,GAAA;IAAAC,KAAA,EAWD,SAAAyD,QAAQrD,GAAA,EAAKsD,SAAA,EAAWrD,MAAA,EAAQC,UAAA,EAAYC,OAAA,EAAS;MACnD,IAAMd,MAAA,GAAS,KAAKyC,UAAA,CAAY;MAEhC,KAAK3C,MAAA,CACF4C,WAAA,CAAYuB,SAAA,GAAY,SAAY,+BAA+B,EACnEtB,OAAA,CAAQ,KAAKlC,aAAa,EAC1BmC,eAAA,CAAgB,MAAM,EACtBC,gBAAA,CAAiB,KAAKC,aAAa,EACnCC,kBAAA,CAAmB,KAAKC,eAAe,EACvCtC,IAAA,CACCC,GAAA,EACA,UAAUuD,IAAA,EAAM;QACdtD,MAAA,CAAOZ,MAAA,CAAOmE,QAAA,CAASD,IAAA,EAAM,IAAI,CAAC;MACnC,GACDrD,UAAA,EACAC,OACD;IACJ;IAAA;EAAA;IAAAR,GAAA;IAAAC,KAAA,EAID,SAAAgB,kBAAkBZ,GAAA,EAAK;MACrB,IAAMyD,KAAA,GAAQzD,GAAA,CAAI0D,WAAA,CAAY,GAAG;MACjC,OAAOD,KAAA,GAAQ,IAAI,KAAKzD,GAAA,CAAI2D,KAAA,CAAMF,KAAA,GAAQ,CAAC;IAC5C;EAAA;IAAA9D,GAAA;IAAAC,KAAA,EAED,SAAAkC,WAAA,EAAa;MACX,IAAI,KAAKzC,MAAA,KAAW,MAAM;QACxB,KAAKA,MAAA,GAAS,IAAIuE,MAAA,CAAQ;MAC3B;MAED,OAAO,KAAKvE,MAAA;IACb;EAAA;EAAA,OAAAX,SAAA;AAAA,EAjQqBmF,MAAA;AA2QxB,IAAMC,qBAAA,GAAwB,CAC5B,sKACA,kLACA,kLACA,kLACA,sLACA,8gBACA,k1BACA,sKACA,sKACA,sKACA,qKACF;AAAA,IAOMvE,WAAA;EACJ,SAAAA,YAAYR,OAAA,EAAS;IAAAE,eAAA,OAAAM,WAAA;IACnB,KAAKe,WAAA,GAAc;IACnB,KAAKyD,eAAA,GAAkB,IAAIC,eAAA,CAAiB;IAC5C,KAAKC,eAAA,GAAkB,IAAIC,eAAA,CAAgBnF,OAAO;EACnD;EAAA;AAAA;AAAA;AAAA;EAAAW,YAAA,CAAAH,WAAA;IAAAI,GAAA;IAAAC,KAAA,EAMD,SAAAS,eAAeC,WAAA,EAAa;MAC1B,KAAKA,WAAA,GAAcA,WAAA;MACnB,OAAO;IACR;IAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;EAAA;IAAAX,GAAA;IAAAC,KAAA,EASD,SAAAoB,MAAMD,IAAA,EAAMR,YAAA,EAAcL,UAAA,EAAYC,OAAA,EAAS;MAC7C,IAAMgE,QAAA,GAAW,KAAKJ,eAAA,CAAgB/C,KAAA,CAAMD,IAAI;MAChD,IAAMqD,QAAA,GAAW,KAAKH,eAAA,CACnB5D,cAAA,CAAe,KAAKC,WAAW,EAC/B+D,eAAA,CAAgB9D,YAAY,EAC5BS,KAAA,CAAMD,IAAA,EAAMoD,QAAA,EAAUjE,UAAA,EAAYC,OAAO;MAE5C,IAAMwB,IAAA,GAAO,IAAI2C,WAAA,CAAYH,QAAA,EAAUC,QAAQ;MAE/C,IAAMG,QAAA,GAAW,IAAIC,QAAA,CAASC,SAAA,CAAU9C,IAAI,CAAC;MAC7CA,IAAA,CAAK+C,IAAA,CAAKH,QAAQ;MAIlB,OAAO5C,IAAA;IACR;EAAA;EAAA,OAAApC,WAAA;AAAA;AAKH,SAASkF,UAAU9C,IAAA,EAAM;EACvB,IAAMwC,QAAA,GAAWxC,IAAA,CAAKwC,QAAA;EAEtB,IAAMQ,KAAA,GAAQ,EAAE;EAEhB,IAAIR,QAAA,IAAYA,QAAA,CAASQ,KAAA,KAAU,QAAW;IAG5C,SAAS3B,CAAA,GAAI,GAAGC,EAAA,GAAKkB,QAAA,CAASQ,KAAA,CAAM5B,MAAA,EAAQC,CAAA,GAAIC,EAAA,EAAID,CAAA,IAAK;MACvD,IAAM4B,KAAA,GAAQT,QAAA,CAASQ,KAAA,CAAM3B,CAAC;MAI9B,IAAM6B,IAAA,GAAO,IAAIC,IAAA,CAAM;MACvBH,KAAA,CAAMzB,IAAA,CAAK2B,IAAI;MAIfA,IAAA,CAAKE,IAAA,GAAOH,KAAA,CAAMG,IAAA;MAClBF,IAAA,CAAKG,QAAA,CAASC,SAAA,CAAUL,KAAA,CAAMM,GAAG;MACjCL,IAAA,CAAKM,UAAA,CAAWF,SAAA,CAAUL,KAAA,CAAMQ,IAAI;MACpC,IAAIR,KAAA,CAAMS,GAAA,KAAQ,QAAWR,IAAA,CAAKS,KAAA,CAAML,SAAA,CAAUL,KAAA,CAAMS,GAAG;IAC5D;IAID,SAASrC,EAAA,GAAI,GAAGC,GAAA,GAAKkB,QAAA,CAASQ,KAAA,CAAM5B,MAAA,EAAQC,EAAA,GAAIC,GAAA,EAAID,EAAA,IAAK;MACvD,IAAM4B,MAAA,GAAQT,QAAA,CAASQ,KAAA,CAAM3B,EAAC;MAE9B,IAAI4B,MAAA,CAAMW,MAAA,KAAW,MAAMX,MAAA,CAAMW,MAAA,KAAW,QAAQZ,KAAA,CAAMC,MAAA,CAAMW,MAAM,MAAM,QAAW;QAGrFZ,KAAA,CAAMC,MAAA,CAAMW,MAAM,EAAEC,GAAA,CAAIb,KAAA,CAAM3B,EAAC,CAAC;MACxC,OAAa;QAGLrB,IAAA,CAAK6D,GAAA,CAAIb,KAAA,CAAM3B,EAAC,CAAC;MAClB;IACF;EACF;EAKDrB,IAAA,CAAK8D,iBAAA,CAAkB,IAAI;EAE3B,OAAOd,KAAA;AACT;AAAA,IAIMX,eAAA;EAAA,SAAAA,gBAAA;IAAA/E,eAAA,OAAA+E,eAAA;EAAA;EAAAtE,YAAA,CAAAsE,eAAA;IAAArE,GAAA;IAAAC,KAAA;IAAgB;AAAA;AAAA;AAAA;IAKpB,SAAAoB,MAAMD,IAAA,EAAM;MAEV,IAAM2E,SAAA,GAAY,EAAE;MACpB,IAAMC,GAAA,GAAM,EAAE;MACd,IAAMC,OAAA,GAAU,EAAE;MAElB,IAAMC,OAAA,GAAU,EAAE;MAElB,IAAMC,MAAA,GAAS,EAAE;MAEjB,IAAMnB,KAAA,GAAQ,EAAE;MAChB,IAAMoB,WAAA,GAAc,EAAE;MACtB,IAAMC,WAAA,GAAc,EAAE;MAEtB,IAAMC,YAAA,GAAe,EAAE;MACvB,IAAMC,cAAA,GAAiB,EAAE;MAEzB,IAAMC,GAAA,GAAM,EAAE;MACd,IAAMC,MAAA,GAAS,EAAE;MAEjB,IAAMC,WAAA,GAAc,EAAE;MACtB,IAAMC,WAAA,GAAc,EAAE;MAGtB,IAAIC,MAAA,GAAS;MACb,IAAMC,aAAA,GAAgB,CAAE;MAIxB,SAASxD,CAAA,GAAI,GAAGA,CAAA,GAAIjC,IAAA,CAAK0F,QAAA,CAASC,WAAA,EAAa1D,CAAA,IAAK;QAClD,IAAM2D,CAAA,GAAI5F,IAAA,CAAK6F,QAAA,CAAS5D,CAAC;QAEzB,SAAS6D,CAAA,GAAI,GAAGC,EAAA,GAAKH,CAAA,CAAE3B,QAAA,CAASjC,MAAA,EAAQ8D,CAAA,GAAIC,EAAA,EAAID,CAAA,IAAK;UACnDnB,SAAA,CAAUxC,IAAA,CAAKyD,CAAA,CAAE3B,QAAA,CAAS6B,CAAC,CAAC;QAC7B;QAED,SAASA,EAAA,GAAI,GAAGC,GAAA,GAAKH,CAAA,CAAEI,MAAA,CAAOhE,MAAA,EAAQ8D,EAAA,GAAIC,GAAA,EAAID,EAAA,IAAK;UACjDjB,OAAA,CAAQ1C,IAAA,CAAKyD,CAAA,CAAEI,MAAA,CAAOF,EAAC,CAAC;QACzB;QAED,SAASA,GAAA,GAAI,GAAGC,IAAA,GAAKH,CAAA,CAAEK,EAAA,CAAGjE,MAAA,EAAQ8D,GAAA,GAAIC,IAAA,EAAID,GAAA,IAAK;UAC7ClB,GAAA,CAAIzC,IAAA,CAAKyD,CAAA,CAAEK,EAAA,CAAGH,GAAC,CAAC;QACjB;QAED,SAASA,GAAA,GAAI,GAAGA,GAAA,GAAI,GAAGA,GAAA,IAAK;UAC1Bd,WAAA,CAAY7C,IAAA,CAAKyD,CAAA,CAAEZ,WAAA,CAAYhD,MAAA,GAAS,KAAK8D,GAAA,GAAIF,CAAA,CAAEZ,WAAA,CAAYc,GAAC,IAAI,CAAG;QACxE;QAED,SAASA,GAAA,GAAI,GAAGA,GAAA,GAAI,GAAGA,GAAA,IAAK;UAC1Bb,WAAA,CAAY9C,IAAA,CAAKyD,CAAA,CAAEX,WAAA,CAAYjD,MAAA,GAAS,KAAK8D,GAAA,GAAIF,CAAA,CAAEX,WAAA,CAAYa,GAAC,IAAI,CAAG;QACxE;MACF;MAID,SAAS7D,GAAA,GAAI,GAAGA,GAAA,GAAIjC,IAAA,CAAK0F,QAAA,CAASQ,SAAA,EAAWjE,GAAA,IAAK;QAChD,IAAMkE,IAAA,GAAOnG,IAAA,CAAKoG,KAAA,CAAMnE,GAAC;QAEzB,SAAS6D,GAAA,GAAI,GAAGC,IAAA,GAAKI,IAAA,CAAKrB,OAAA,CAAQ9C,MAAA,EAAQ8D,GAAA,GAAIC,IAAA,EAAID,GAAA,IAAK;UACrDhB,OAAA,CAAQ3C,IAAA,CAAKgE,IAAA,CAAKrB,OAAA,CAAQgB,GAAC,CAAC;QAC7B;MACF;MAID,SAAS7D,GAAA,GAAI,GAAGA,GAAA,GAAIjC,IAAA,CAAK0F,QAAA,CAASW,aAAA,EAAepE,GAAA,IAAK;QACpD,IAAMoB,QAAA,GAAWrD,IAAA,CAAKsG,SAAA,CAAUrE,GAAC;QAEjC8C,MAAA,CAAO5C,IAAA,CAAK;UACVqD,MAAA,EAAQA,MAAA,GAAS;UACjBe,KAAA,EAAOlD,QAAA,CAAS6C,SAAA,GAAY;QACpC,CAAO;QAEDV,MAAA,IAAUnC,QAAA,CAAS6C,SAAA;MACpB;MAID,SAASjE,GAAA,GAAI,GAAGA,GAAA,GAAIjC,IAAA,CAAK0F,QAAA,CAASc,cAAA,EAAgBvE,GAAA,IAAK;QACrD,IAAMwE,IAAA,GAAOzG,IAAA,CAAKsF,WAAA,CAAYrD,GAAC;QAC/B,IAAIpD,KAAA,GAAQ4G,aAAA,CAAcgB,IAAA,CAAKC,SAAS;QAGxC7H,KAAA,GAAQA,KAAA,KAAU,SAAY4H,IAAA,CAAKE,IAAA,GAAOC,IAAA,CAAKC,GAAA,CAAIJ,IAAA,CAAKE,IAAA,EAAM9H,KAAK;QAEnE4G,aAAA,CAAcgB,IAAA,CAAKC,SAAS,IAAI7H,KAAA;MACjC;MAED,SAASoD,GAAA,GAAI,GAAGA,GAAA,GAAIjC,IAAA,CAAK0F,QAAA,CAASoB,SAAA,EAAW7E,GAAA,IAAK;QAChD,IAAM8E,QAAA,GAAW/G,IAAA,CAAK4D,KAAA,CAAM3B,GAAC;QAE7B,IAAM6B,IAAA,GAAO;UACXpB,KAAA,EAAOT,GAAA;UACP+E,mBAAA,EAAqBD,QAAA,CAASC,mBAAA;UAC9BxC,MAAA,EAAQuC,QAAA,CAASE,WAAA;UACjBjD,IAAA,EAAM+C,QAAA,CAAS/C,IAAA;UACfG,GAAA,EAAK4C,QAAA,CAAS9C,QAAA,CAASrB,KAAA,CAAM,GAAG,CAAC;UACjCyB,IAAA,EAAM,CAAC,GAAG,GAAG,GAAG,CAAC;UACjBC,GAAA,EAAK,CAAC,GAAG,GAAG,CAAC;UACb4C,aAAA,EAAezB,aAAA,CAAcxD,GAAC,MAAM,SAAYwD,aAAA,CAAcxD,GAAC,IAAI;QACpE;QAED,IAAI6B,IAAA,CAAKU,MAAA,KAAW,IAAI;UACtBV,IAAA,CAAKK,GAAA,CAAI,CAAC,KAAKnE,IAAA,CAAK4D,KAAA,CAAME,IAAA,CAAKU,MAAM,EAAEP,QAAA,CAAS,CAAC;UACjDH,IAAA,CAAKK,GAAA,CAAI,CAAC,KAAKnE,IAAA,CAAK4D,KAAA,CAAME,IAAA,CAAKU,MAAM,EAAEP,QAAA,CAAS,CAAC;UACjDH,IAAA,CAAKK,GAAA,CAAI,CAAC,KAAKnE,IAAA,CAAK4D,KAAA,CAAME,IAAA,CAAKU,MAAM,EAAEP,QAAA,CAAS,CAAC;QAClD;QAEDL,KAAA,CAAMzB,IAAA,CAAK2B,IAAI;MAChB;MAKD,IAAI9D,IAAA,CAAK0F,QAAA,CAASyB,MAAA,KAAW,OAAO;QAClC,SAASlF,GAAA,GAAI,GAAGA,GAAA,GAAIjC,IAAA,CAAK0F,QAAA,CAAS0B,OAAA,EAASnF,GAAA,IAAK;UAC9C,IAAMoF,EAAA,GAAKrH,IAAA,CAAKoF,GAAA,CAAInD,GAAC;UAErB,IAAMqF,KAAA,GAAQ;YACZC,MAAA,EAAQF,EAAA,CAAGE,MAAA;YACXC,QAAA,EAAUH,EAAA,CAAGG,QAAA;YACbC,SAAA,EAAWJ,EAAA,CAAGI,SAAA;YACdC,QAAA,EAAUL,EAAA,CAAGK,QAAA,GAAW;YACxBC,KAAA,EAAO;UACR;UAED,SAAS7B,GAAA,GAAI,GAAGC,IAAA,GAAKsB,EAAA,CAAGM,KAAA,CAAM3F,MAAA,EAAQ8D,GAAA,GAAIC,IAAA,EAAID,GAAA,IAAK;YACjD,IAAM8B,IAAA,GAAO,CAAE;YACfA,IAAA,CAAKlF,KAAA,GAAQ2E,EAAA,CAAGM,KAAA,CAAM7B,GAAC,EAAEpD,KAAA;YACzBkF,IAAA,CAAKC,OAAA,GAAU;YAEf,IAAI7H,IAAA,CAAK4D,KAAA,CAAMgE,IAAA,CAAKlF,KAAK,EAAEsB,IAAA,CAAK8D,OAAA,CAAQ,IAAI,KAAK,GAAG;cAClDF,IAAA,CAAKG,UAAA,GAAa,IAAIC,OAAA,CAAQ,GAAK,GAAK,CAAG;YAC5C;YAEDV,KAAA,CAAMK,KAAA,CAAMxF,IAAA,CAAKyF,IAAI;UACtB;UAEDxC,GAAA,CAAIjD,IAAA,CAAKmF,KAAK;QACf;MACP,OAAW;QACL,SAASrF,GAAA,GAAI,GAAGA,GAAA,GAAIjC,IAAA,CAAK0F,QAAA,CAASoB,SAAA,EAAW7E,GAAA,IAAK;UAChD,IAAMoF,GAAA,GAAKrH,IAAA,CAAK4D,KAAA,CAAM3B,GAAC,EAAEoF,EAAA;UAEzB,IAAIA,GAAA,KAAO,QAAW;UAEtB,IAAMC,MAAA,GAAQ;YACZC,MAAA,EAAQtF,GAAA;YACRuF,QAAA,EAAUH,GAAA,CAAGG,QAAA;YACbC,SAAA,EAAWJ,GAAA,CAAGI,SAAA;YACdC,QAAA,EAAUL,GAAA,CAAGK,QAAA;YACbC,KAAA,EAAO;UACR;UAED,SAAS7B,GAAA,GAAI,GAAGC,IAAA,GAAKsB,GAAA,CAAGM,KAAA,CAAM3F,MAAA,EAAQ8D,GAAA,GAAIC,IAAA,EAAID,GAAA,IAAK;YACjD,IAAM8B,KAAA,GAAO,CAAE;YACfA,KAAA,CAAKlF,KAAA,GAAQ2E,GAAA,CAAGM,KAAA,CAAM7B,GAAC,EAAEpD,KAAA;YACzBkF,KAAA,CAAKC,OAAA,GAAU;YAEf,IAAIR,GAAA,CAAGM,KAAA,CAAM7B,GAAC,EAAEmC,eAAA,KAAoB,GAAG;cAIrC,IAAMC,WAAA,GAAcb,GAAA,CAAGM,KAAA,CAAM7B,GAAC,EAAEqC,oBAAA;cAChC,IAAMC,WAAA,GAAcf,GAAA,CAAGM,KAAA,CAAM7B,GAAC,EAAEuC,oBAAA;cAKhC,IAAMC,IAAA,GAAO,CAACF,WAAA,CAAY,CAAC;cAC3B,IAAMG,IAAA,GAAO,CAACH,WAAA,CAAY,CAAC;cAC3BA,WAAA,CAAY,CAAC,IAAI,CAACF,WAAA,CAAY,CAAC;cAC/BE,WAAA,CAAY,CAAC,IAAI,CAACF,WAAA,CAAY,CAAC;cAC/BA,WAAA,CAAY,CAAC,IAAII,IAAA;cACjBJ,WAAA,CAAY,CAAC,IAAIK,IAAA;cAEjBX,KAAA,CAAKM,WAAA,GAAc,IAAIF,OAAA,CAAO,EAAG9D,SAAA,CAAUgE,WAAW;cACtDN,KAAA,CAAKQ,WAAA,GAAc,IAAIJ,OAAA,CAAO,EAAG9D,SAAA,CAAUkE,WAAW;YACvD;YAEDd,MAAA,CAAMK,KAAA,CAAMxF,IAAA,CAAKyF,KAAI;UACtB;UAEDxC,GAAA,CAAIjD,IAAA,CAAKmF,MAAK;UAId1D,KAAA,CAAM3B,GAAC,EAAEoF,EAAA,GAAKC,MAAA;QACf;MACF;MAID,IAAItH,IAAA,CAAK0F,QAAA,CAASyB,MAAA,KAAW,OAAO;QAuClC,IAASqB,QAAA,GAAT,SAASA,SAASC,KAAA,EAAO;UACvB,IAAIA,KAAA,CAAMnB,KAAA,EAAO;YACfjC,MAAA,CAAOlD,IAAA,CAAKsG,KAAA,CAAMnB,KAAK;YAIvB1D,KAAA,CAAM6E,KAAA,CAAMnB,KAAA,CAAM5E,KAAK,EAAEgG,KAAA,GAAQD,KAAA,CAAMnB,KAAA;UACxC;UAEDmB,KAAA,CAAME,OAAA,GAAU;UAEhB,SAAS1G,GAAA,GAAI,GAAGC,EAAA,GAAKuG,KAAA,CAAMG,QAAA,CAAS5G,MAAA,EAAQC,GAAA,GAAIC,EAAA,EAAID,GAAA,IAAK;YACvD,IAAM4G,KAAA,GAAQJ,KAAA,CAAMG,QAAA,CAAS3G,GAAC;YAG9B,IAAI,CAAC4G,KAAA,CAAMF,OAAA,EAASH,QAAA,CAASK,KAAK;UACnC;QACF;QAtDD,IAAMC,aAAA,GAAgB,CAAE;QAExB,SAAS7G,GAAA,GAAI,GAAGA,GAAA,GAAIjC,IAAA,CAAK0F,QAAA,CAASoB,SAAA,EAAW7E,GAAA,IAAK;UAChD,IAAM8E,SAAA,GAAW/G,IAAA,CAAK4D,KAAA,CAAM3B,GAAC;UAC7B,IAAMyG,KAAA,GAAQ3B,SAAA,CAAS2B,KAAA;UAEvB,IAAIA,KAAA,KAAU,QAAW;UAEzB,IAAMpB,OAAA,GAAQ;YACZ5E,KAAA,EAAOT,GAAA;YACPgF,WAAA,EAAayB,KAAA,CAAMzB,WAAA;YACnB8B,KAAA,EAAOL,KAAA,CAAMK,KAAA;YACbC,OAAA,EAASN,KAAA,CAAMM,OAAA;YACfC,cAAA,EAAgBP,KAAA,CAAMO,cAAA;YACtBC,cAAA,EAAgBR,KAAA,CAAMQ,cAAA;YACtBlC,mBAAA,EAAqBD,SAAA,CAASC;UAC/B;UAED8B,aAAA,CAAc7G,GAAC,IAAI;YAAEuC,MAAA,EAAQ;YAAMoE,QAAA,EAAU;YAAItB,KAAA,EAAAA,OAAA;YAAcqB,OAAA,EAAS;UAAO;QAChF;QAED,IAAMQ,SAAA,GAAY;UAAE3E,MAAA,EAAQ;UAAMoE,QAAA,EAAU,EAAE;UAAEtB,KAAA,EAAO;UAAMqB,OAAA,EAAS;QAAO;QAI7E,SAAWjC,SAAA,IAAaoC,aAAA,EAAe;UACrC,IAAMM,UAAA,GAAaN,aAAA,CAAcpC,SAAS;UAC1C,IAAM2C,gBAAA,GAAmBP,aAAA,CAAcM,UAAA,CAAWnC,WAAW,KAAKkC,SAAA;UAElEC,UAAA,CAAW5E,MAAA,GAAS6E,gBAAA;UACpBA,gBAAA,CAAiBT,QAAA,CAASzG,IAAA,CAAKiH,UAAU;QAC1C;QAyBDZ,QAAA,CAASW,SAAS;MACnB;MAID,SAASG,iBAAiBC,SAAA,EAAWC,KAAA,EAAOT,KAAA,EAAO;QACjD,SAAS9G,IAAA,GAAI,GAAGA,IAAA,GAAIuH,KAAA,CAAMC,YAAA,EAAcxH,IAAA,IAAK;UAC3C,IAAMyH,OAAA,GAAUF,KAAA,CAAMG,QAAA,CAAS1H,IAAC;UAEhC,IAAIS,KAAA;UAEJ,IAAI1C,IAAA,CAAK0F,QAAA,CAASyB,MAAA,KAAW,OAAO;YAClCzE,KAAA,GAAQ1C,IAAA,CAAK4J,MAAA,CAAO,CAAC,EAAED,QAAA,CAASD,OAAA,CAAQhH,KAAK,EAAEA,KAAA;UACzD,OAAe;YACLA,KAAA,GAAQgH,OAAA,CAAQhH,KAAA;UACjB;UAED6G,SAAA,CAAUM,KAAA,CAAMnH,KAAA,GAAQ,IAAI,CAAC,KAAKgH,OAAA,CAAQzF,QAAA,CAAS,CAAC,IAAI8E,KAAA;UACxDQ,SAAA,CAAUM,KAAA,CAAMnH,KAAA,GAAQ,IAAI,CAAC,KAAKgH,OAAA,CAAQzF,QAAA,CAAS,CAAC,IAAI8E,KAAA;UACxDQ,SAAA,CAAUM,KAAA,CAAMnH,KAAA,GAAQ,IAAI,CAAC,KAAKgH,OAAA,CAAQzF,QAAA,CAAS,CAAC,IAAI8E,KAAA;QACzD;MACF;MAED,SAAS9G,IAAA,GAAI,GAAGA,IAAA,GAAIjC,IAAA,CAAK0F,QAAA,CAASoE,UAAA,EAAY7H,IAAA,IAAK;QACjD,IAAMuH,KAAA,GAAQxJ,IAAA,CAAK4J,MAAA,CAAO3H,IAAC;QAC3B,IAAM8H,MAAA,GAAS;UAAE/F,IAAA,EAAMwF,KAAA,CAAMxF;QAAM;QAEnC,IAAMuF,SAAA,GAAY,IAAIS,sBAAA,CAAuBhK,IAAA,CAAK0F,QAAA,CAASC,WAAA,GAAc,GAAG,CAAC;QAC7E4D,SAAA,CAAUvF,IAAA,GAAOwF,KAAA,CAAMxF,IAAA;QAEvB,SAAS8B,GAAA,GAAI,GAAGA,GAAA,GAAI9F,IAAA,CAAK0F,QAAA,CAASC,WAAA,GAAc,GAAGG,GAAA,IAAK;UACtDyD,SAAA,CAAUM,KAAA,CAAM/D,GAAC,IAAInB,SAAA,CAAUmB,GAAC;QACjC;QAED,IAAI9F,IAAA,CAAK0F,QAAA,CAASyB,MAAA,KAAW,OAAO;UAClC,IAAIlF,IAAA,KAAM,GAAG;YACXqH,gBAAA,CAAiBC,SAAA,EAAWC,KAAA,EAAO,CAAG;UACvC;QACT,OAAa;UACL,IAAIA,KAAA,CAAM7C,IAAA,KAAS,GAAG;YAGpB,SAASb,GAAA,GAAI,GAAGA,GAAA,GAAI0D,KAAA,CAAMC,YAAA,EAAc3D,GAAA,IAAK;cAC3C,IAAMmE,MAAA,GAASjK,IAAA,CAAK4J,MAAA,CAAOJ,KAAA,CAAMG,QAAA,CAAS7D,GAAC,EAAEpD,KAAK;cAClD,IAAMqG,KAAA,GAAQS,KAAA,CAAMG,QAAA,CAAS7D,GAAC,EAAEiD,KAAA;cAEhC,IAAIkB,MAAA,CAAOtD,IAAA,KAAS,GAAG;gBACrB2C,gBAAA,CAAiBC,SAAA,EAAWU,MAAA,EAAQlB,KAAK;cAG1C;YACF;UACX,WAAmBS,KAAA,CAAM7C,IAAA,KAAS,GAAG;YAG3B2C,gBAAA,CAAiBC,SAAA,EAAWC,KAAA,EAAO,CAAG;UAChD,WAAmBA,KAAA,CAAM7C,IAAA,KAAS,GAAG,UAGlB6C,KAAA,CAAM7C,IAAA,KAAS,GAAG,UAGlB6C,KAAA,CAAM7C,IAAA,KAAS,GAAG,UAGlB6C,KAAA,CAAM7C,IAAA,KAAS,GAAG,UAGlB6C,KAAA,CAAM7C,IAAA,KAAS,GAAG,UAGlB6C,KAAA,CAAM7C,IAAA,KAAS,GAAG,UAGlB6C,KAAA,CAAM7C,IAAA,KAAS,GAAG;QAI9B;QAEDzB,YAAA,CAAa/C,IAAA,CAAK4H,MAAM;QACxB5E,cAAA,CAAehD,IAAA,CAAKoH,SAAS;MAC9B;MAID,SAAStH,IAAA,GAAI,GAAGA,IAAA,GAAIjC,IAAA,CAAK0F,QAAA,CAASc,cAAA,EAAgBvE,IAAA,IAAK;QACrD,IAAMiI,SAAA,GAAYlK,IAAA,CAAKsF,WAAA,CAAYrD,IAAC;QACpC,IAAM8H,OAAA,GAAS,CAAE;QAEjB,SAAWnL,GAAA,IAAOsL,SAAA,EAAW;UAC3BH,OAAA,CAAOnL,GAAG,IAAIsL,SAAA,CAAUtL,GAAG;QAC5B;QAOD,IAAIoB,IAAA,CAAK0F,QAAA,CAASyB,MAAA,KAAW,OAAO;UAClC,IAAI4C,OAAA,CAAOrD,SAAA,KAAc,IAAI;YAC3B,IAAM5C,KAAA,GAAO9D,IAAA,CAAK4D,KAAA,CAAMmG,OAAA,CAAOrD,SAAS;YACxCqD,OAAA,CAAO9F,QAAA,CAAS,CAAC,KAAKH,KAAA,CAAKG,QAAA,CAAS,CAAC;YACrC8F,OAAA,CAAO9F,QAAA,CAAS,CAAC,KAAKH,KAAA,CAAKG,QAAA,CAAS,CAAC;YACrC8F,OAAA,CAAO9F,QAAA,CAAS,CAAC,KAAKH,KAAA,CAAKG,QAAA,CAAS,CAAC;UACtC;QACF;QAEDqB,WAAA,CAAYnD,IAAA,CAAK4H,OAAM;MACxB;MAID,SAAS9H,IAAA,GAAI,GAAGA,IAAA,GAAIjC,IAAA,CAAK0F,QAAA,CAASyE,eAAA,EAAiBlI,IAAA,IAAK;QACtD,IAAMmI,UAAA,GAAapK,IAAA,CAAKuF,WAAA,CAAYtD,IAAC;QACrC,IAAM8H,QAAA,GAAS,CAAE;QAEjB,SAAWnL,IAAA,IAAOwL,UAAA,EAAY;UAC5BL,QAAA,CAAOnL,IAAG,IAAIwL,UAAA,CAAWxL,IAAG;QAC7B;QAED,IAAMyL,KAAA,GAAQ/E,WAAA,CAAYyE,QAAA,CAAOO,eAAe;QAChD,IAAMC,KAAA,GAAQjF,WAAA,CAAYyE,QAAA,CAAOS,eAAe;QAGhD,IAAIH,KAAA,CAAM1D,IAAA,KAAS,KAAK4D,KAAA,CAAM5D,IAAA,KAAS,GAAG;UACxC,IACE0D,KAAA,CAAM3D,SAAA,KAAc,MACpB6D,KAAA,CAAM7D,SAAA,KAAc,MACpB1G,IAAA,CAAK4D,KAAA,CAAM2G,KAAA,CAAM7D,SAAS,EAAEO,WAAA,KAAgBoD,KAAA,CAAM3D,SAAA,EAClD;YACA6D,KAAA,CAAM5D,IAAA,GAAO;UACd;QACF;QAEDpB,WAAA,CAAYpD,IAAA,CAAK4H,QAAM;MACxB;MAID,IAAM3G,QAAA,GAAW,IAAIqH,cAAA,CAAgB;MAErCrH,QAAA,CAASsH,YAAA,CAAa,YAAY,IAAIV,sBAAA,CAAuBrF,SAAA,EAAW,CAAC,CAAC;MAC1EvB,QAAA,CAASsH,YAAA,CAAa,UAAU,IAAIV,sBAAA,CAAuBnF,OAAA,EAAS,CAAC,CAAC;MACtEzB,QAAA,CAASsH,YAAA,CAAa,MAAM,IAAIV,sBAAA,CAAuBpF,GAAA,EAAK,CAAC,CAAC;MAC9DxB,QAAA,CAASsH,YAAA,CAAa,aAAa,IAAIC,qBAAA,CAAsB3F,WAAA,EAAa,CAAC,CAAC;MAC5E5B,QAAA,CAASsH,YAAA,CAAa,cAAc,IAAIV,sBAAA,CAAuB/E,WAAA,EAAa,CAAC,CAAC;MAC9E7B,QAAA,CAASwH,QAAA,CAAS9F,OAAO;MAEzB,SAAS7C,IAAA,GAAI,GAAGC,EAAA,GAAK6C,MAAA,CAAO/C,MAAA,EAAQC,IAAA,GAAIC,EAAA,EAAID,IAAA,IAAK;QAC/CmB,QAAA,CAASyH,QAAA,CAAS9F,MAAA,CAAO9C,IAAC,EAAEuD,MAAA,EAAQT,MAAA,CAAO9C,IAAC,EAAEsE,KAAA,EAAOtE,IAAC;MACvD;MAEDmB,QAAA,CAASQ,KAAA,GAAQA,KAAA;MAEjBR,QAAA,CAAS8B,YAAA,GAAeA,YAAA;MACxB9B,QAAA,CAAS0H,eAAA,CAAgB7G,QAAA,GAAWkB,cAAA;MACpC/B,QAAA,CAAS2H,oBAAA,GAAuB;MAEhC3H,QAAA,CAAS4H,QAAA,CAASC,GAAA,GAAM;QACtBrH,KAAA,EAAAA,KAAA;QACAwB,GAAA,EAAAA,GAAA;QACAC,MAAA,EAAAA,MAAA;QACAC,WAAA,EAAAA,WAAA;QACAC,WAAA,EAAAA,WAAA;QACA4B,MAAA,EAAQnH,IAAA,CAAK0F,QAAA,CAASyB;MACvB;MAED/D,QAAA,CAAS8H,qBAAA,CAAuB;MAEhC,OAAO9H,QAAA;IACR;EAAA;EAAA,OAAAH,eAAA;AAAA;AAAA,IAQGE,eAAA;EACJ,SAAAA,gBAAYnF,OAAA,EAAS;IAAAE,eAAA,OAAAiF,eAAA;IACnB,KAAKnF,OAAA,GAAUA,OAAA;IAEf,KAAKmN,aAAA,GAAgB,IAAIC,aAAA,CAAc,KAAKpN,OAAO;IACnD,KAAKqN,SAAA,GAAY;IAEjB,KAAK9L,WAAA,GAAc;IACnB,KAAKC,YAAA,GAAe;EACrB;EAAA;AAAA;AAAA;AAAA;EAAAb,YAAA,CAAAwE,eAAA;IAAAvE,GAAA;IAAAC,KAAA,EAMD,SAAAS,eAAeC,WAAA,EAAa;MAC1B,KAAKA,WAAA,GAAcA,WAAA;MACnB,OAAO;IACR;IAAA;AAAA;AAAA;AAAA;EAAA;IAAAX,GAAA;IAAAC,KAAA,EAMD,SAAAyE,gBAAgB9D,YAAA,EAAc;MAC5B,KAAKA,YAAA,GAAeA,YAAA;MACpB,OAAO;IACR;IAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;EAAA;IAAAZ,GAAA;IAAAC,KAAA,EASD,SAAAoB,MAAMD,IAAA,EAAMoD,QAAA,EAAqC;MAC/C,IAAMkD,SAAA,GAAY,EAAE;MAEpB,IAAMgF,QAAA,GAAW,CAAE;MAEnB,KAAKH,aAAA,CAAc7L,cAAA,CAAe,KAAKC,WAAW;MAIlD,SAAS0C,CAAA,GAAI,GAAGA,CAAA,GAAIjC,IAAA,CAAK0F,QAAA,CAASW,aAAA,EAAepE,CAAA,IAAK;QACpD,IAAMoB,QAAA,GAAWrD,IAAA,CAAKsG,SAAA,CAAUrE,CAAC;QAEjC,IAAM8H,MAAA,GAAS;UAAEiB,QAAA,EAAU;QAAI;QAE/B,IAAI3H,QAAA,CAASW,IAAA,KAAS,QAAW+F,MAAA,CAAO/F,IAAA,GAAOX,QAAA,CAASW,IAAA;QAaxD+F,MAAA,CAAOwB,KAAA,GAAQ,IAAIC,KAAA,CAAO,EAACtH,SAAA,CAAUb,QAAA,CAASoI,OAAO;QACrD1B,MAAA,CAAO2B,OAAA,GAAUrI,QAAA,CAASoI,OAAA,CAAQ,CAAC;QACnC1B,MAAA,CAAO4B,QAAA,GAAW,IAAIH,KAAA,CAAO,EAACtH,SAAA,CAAUb,QAAA,CAASuI,OAAO;QACxD7B,MAAA,CAAO8B,WAAA,GAAc9B,MAAA,CAAO2B,OAAA,KAAY;QAIxC3B,MAAA,CAAO+B,QAAA,GAAW1I,QAAA,CAASQ,KAAA,CAAM5B,MAAA,GAAS,IAAI,OAAO;QACrD+H,MAAA,CAAO7E,YAAA,GAAe9B,QAAA,CAAS8B,YAAA,CAAalD,MAAA,GAAS,IAAI,OAAO;QAChE+H,MAAA,CAAOgC,GAAA,GAAM;QAIbhC,MAAA,CAAOiC,QAAA,GAAWC,cAAA;QAClBlC,MAAA,CAAOmC,QAAA,GAAWC,cAAA;QAClBpC,MAAA,CAAOqC,QAAA,GAAWC,sBAAA;QAClBtC,MAAA,CAAOuC,aAAA,GAAgBH,cAAA;QACvBpC,MAAA,CAAOwC,aAAA,GAAgBC,cAAA;QAIvB,IAAIxM,IAAA,CAAK0F,QAAA,CAASyB,MAAA,KAAW,UAAU9D,QAAA,CAASoJ,IAAA,GAAO,OAAS,GAAG;UACjE1C,MAAA,CAAO2C,IAAA,GAAOC,UAAA;QACtB,OAAa;UACL5C,MAAA,CAAO2C,IAAA,GAAO3C,MAAA,CAAO2B,OAAA,KAAY,IAAMkB,SAAA,GAAYD,UAAA;QACpD;QAED,IAAI3M,IAAA,CAAK0F,QAAA,CAASyB,MAAA,KAAW,OAAO;UAGlC,IAAI9D,QAAA,CAASwJ,QAAA,EAAU;YACrB,IAAMA,QAAA,GAAWxJ,QAAA,CAASwJ,QAAA;YAC1B,IAAMC,SAAA,GAAYD,QAAA,CAASE,KAAA,CAAM,GAAG;YAKpChD,MAAA,CAAOiD,GAAA,GAAM,KAAKC,YAAA,CAAaH,SAAA,CAAU,CAAC,GAAGxB,QAAQ;YAErD,IAAIwB,SAAA,CAAU9K,MAAA,GAAS,GAAG;cACxB,IAAMkL,SAAA,GAAYJ,SAAA,CAAU,CAAC,EAAElK,KAAA,CAAM,EAAE,EAAE9C,WAAA,CAAa;cAEtDiK,MAAA,CAAOoD,MAAA,GAAS,KAAKF,YAAA,CAAaH,SAAA,CAAU,CAAC,GAAGxB,QAAQ;cAExDvB,MAAA,CAAOqD,OAAA,GAAUF,SAAA,KAAc,SAASG,iBAAA,GAAoBC,YAAA;YAC7D;UACF;UAID,IAAMC,YAAA,GAAelK,QAAA,CAASmK,SAAA,KAAc,KAAK,eAAexN,IAAA,CAAKyN,YAAA,CAAapK,QAAA,CAASmK,SAAS,EAAEX,QAAA;UAEtG9C,MAAA,CAAO2D,WAAA,GAAc,KAAKT,YAAA,CAAaM,YAAA,EAAcjC,QAAA,EAAU;YAC7DqC,aAAA,EAAe;YACfC,oBAAA,EAAsB,KAAKC,qBAAA,CAAsBN,YAAY;UACvE,CAAS;UAIDxD,MAAA,CAAOiB,QAAA,CAAS8C,iBAAA,GAAoB;YAClCC,SAAA,EAAW1K,QAAA,CAAS2K,QAAA,KAAa,IAAI,OAAQ;YAC7CzC,KAAA,EAAO,CAAC,GAAG,GAAG,CAAC;YACf0C,KAAA,EAAO;YACPC,OAAA,EAAS7K,QAAA,CAAS2K,QAAA,KAAa;UAChC;QACT,OAAa;UAGL,IAAI3K,QAAA,CAAS8K,YAAA,KAAiB,IAAI;YAChCpE,MAAA,CAAOiD,GAAA,GAAM,KAAKC,YAAA,CAAajN,IAAA,CAAKsL,QAAA,CAASjI,QAAA,CAAS8K,YAAY,GAAG7C,QAAQ;UAC9E;UAID,IAAIjI,QAAA,CAAS+K,eAAA,KAAoB,OAAO/K,QAAA,CAASgL,OAAA,KAAY,KAAKhL,QAAA,CAASgL,OAAA,IAAW,IAAI;YACxFtE,MAAA,CAAOoD,MAAA,GAAS,KAAKF,YAAA,CAAajN,IAAA,CAAKsL,QAAA,CAASjI,QAAA,CAAS+K,eAAe,GAAG9C,QAAQ;YAEnFvB,MAAA,CAAOqD,OAAA,GAAU/J,QAAA,CAASgL,OAAA,KAAY,IAAIhB,iBAAA,GAAoBC,YAAA;UAC/D;UAID,IAAIC,aAAA;YAAce,aAAA;UAElB,IAAIjL,QAAA,CAASmK,SAAA,KAAc,MAAMnK,QAAA,CAASkL,QAAA,KAAa,GAAG;YACxDhB,aAAA,GAAe,UAAU,OAAOlK,QAAA,CAASmK,SAAA,GAAY,IAAI5K,KAAA,CAAM,EAAE,IAAI;YACrE0L,aAAA,GAAgB;UAC1B,OAAe;YACLf,aAAA,GAAevN,IAAA,CAAKsL,QAAA,CAASjI,QAAA,CAASmK,SAAS;YAC/Cc,aAAA,GAAgB;UACjB;UAEDvE,MAAA,CAAO2D,WAAA,GAAc,KAAKT,YAAA,CAAaM,aAAA,EAAcjC,QAAA,EAAU;YAC7DqC,aAAA,EAAe;YACfC,oBAAA,EAAsBU;UAChC,CAAS;UAGDvE,MAAA,CAAOiB,QAAA,CAAS8C,iBAAA,GAAoB;YAClCC,SAAA,EAAW1K,QAAA,CAASmL,QAAA,GAAW;YAAA;YAC/BjD,KAAA,EAAOlI,QAAA,CAASoL,SAAA,CAAU7L,KAAA,CAAM,GAAG,CAAC;YACpCqL,KAAA,EAAO5K,QAAA,CAASoL,SAAA,CAAU,CAAC;YAC3BP,OAAA,GAAU7K,QAAA,CAASoJ,IAAA,GAAO,QAAU,KAAKpJ,QAAA,CAASmL,QAAA,GAAW;UAC9D;QACF;QAED,IAAIzE,MAAA,CAAOiD,GAAA,KAAQ,QAAW;UAC5B,IAAI,CAACjD,MAAA,CAAO8B,WAAA,EAAa;YACvB,KAAK6C,uBAAA,CAAwB3E,MAAA,CAAOiD,GAAA,EAAK5J,QAAA,EAAUnB,CAAC;UACrD;UAED8H,MAAA,CAAO4B,QAAA,CAASgD,cAAA,CAAe,GAAG;QACnC;QAEDrI,SAAA,CAAUnE,IAAA,CAAK,IAAIyM,gBAAA,CAAiB7E,MAAM,CAAC;MAC5C;MAED,IAAI/J,IAAA,CAAK0F,QAAA,CAASyB,MAAA,KAAW,OAAO;QAGlC,IAAS0H,eAAA,GAAT,SAASA,gBAAgBlF,QAAA,EAAUmF,UAAA,EAAW;UAC5C,SAAS7M,IAAA,GAAI,GAAGC,EAAA,GAAKyH,QAAA,CAAS3H,MAAA,EAAQC,IAAA,GAAIC,EAAA,EAAID,IAAA,IAAK;YACjD,IAAMyH,OAAA,GAAUC,QAAA,CAAS1H,IAAC;YAE1B,IAAIyH,OAAA,CAAQhH,KAAA,KAAU,IAAI;YAE1B,IAAMW,SAAA,GAAWyL,UAAA,CAAUpF,OAAA,CAAQhH,KAAK;YAExC,IAAIW,SAAA,CAASqI,OAAA,KAAYhC,OAAA,CAAQ+B,OAAA,CAAQ,CAAC,GAAG;cAC3CpI,SAAA,CAASwI,WAAA,GAAc;YACxB;UACF;QACF;QAED,SAAS5J,IAAA,GAAI,GAAGC,EAAA,GAAKlC,IAAA,CAAK4J,MAAA,CAAO5H,MAAA,EAAQC,IAAA,GAAIC,EAAA,EAAID,IAAA,IAAK;UACpD,IAAMuH,KAAA,GAAQxJ,IAAA,CAAK4J,MAAA,CAAO3H,IAAC;UAC3B,IAAM0H,QAAA,GAAWH,KAAA,CAAMG,QAAA;UAEvB,IAAIH,KAAA,CAAM7C,IAAA,KAAS,GAAG;YACpB,SAASb,CAAA,GAAI,GAAGC,EAAA,GAAK4D,QAAA,CAAS3H,MAAA,EAAQ8D,CAAA,GAAIC,EAAA,EAAID,CAAA,IAAK;cACjD,IAAMmE,MAAA,GAASjK,IAAA,CAAK4J,MAAA,CAAOD,QAAA,CAAS7D,CAAC,EAAEpD,KAAK;cAE5C,IAAIuH,MAAA,CAAOtD,IAAA,KAAS,GAAG;cAEvBkI,eAAA,CAAgB5E,MAAA,CAAON,QAAA,EAAUrD,SAAS;YAC3C;UACX,WAAmBkD,KAAA,CAAM7C,IAAA,KAAS,GAAG;YAC3BkI,eAAA,CAAgBlF,QAAA,EAAUrD,SAAS;UACpC;QACF;MACF;MAED,OAAOA,SAAA;IACR;IAAA;EAAA;IAAA1H,GAAA;IAAAC,KAAA,EAID,SAAAkQ,cAAA,EAAgB;MACd,IAAI,KAAK1D,SAAA,KAAc,MAAM;QAC3B,IAAI2D,SAAA,KAAc,QAAW;UAC3B,MAAM,IAAIjP,KAAA,CAAM,mCAAmC;QACpD;QAED,KAAKsL,SAAA,GAAY,IAAI2D,SAAA,CAAU,KAAKhR,OAAO;MAC5C;MAED,OAAO,KAAKqN,SAAA;IACb;EAAA;IAAAzM,GAAA;IAAAC,KAAA,EAED,SAAAgP,sBAAsB7J,IAAA,EAAM;MAC1B,IAAIA,IAAA,CAAKhC,MAAA,KAAW,IAAI,OAAO;MAE/B,OAAO,uBAAuBiN,IAAA,CAAKjL,IAAI;IACxC;EAAA;IAAApF,GAAA;IAAAC,KAAA,EAED,SAAAoO,aAAaiC,QAAA,EAAU5D,QAAA,EAAUvB,MAAA,EAAQ5K,UAAA,EAAYC,OAAA,EAAS;MAC5D2K,MAAA,GAASA,MAAA,IAAU,CAAE;MAErB,IAAMpJ,KAAA,GAAQ;MAEd,IAAIwO,QAAA;MAEJ,IAAIpF,MAAA,CAAO6D,oBAAA,KAAyB,MAAM;QACxC,IAAIlL,KAAA;QAEJ,IAAI;UACFA,KAAA,GAAQ0M,QAAA,CAASF,QAAA,CAASG,KAAA,CAAM,sBAAsB,EAAE,CAAC,CAAC;QAC3D,SAAQC,CAAA,EAAP;UACAC,OAAA,CAAQC,IAAA,CACN,sBACEN,QAAA,GACA,yEAEH;UAEDxM,KAAA,GAAQ;QACT;QAEDyM,QAAA,GAAWpM,qBAAA,CAAsBL,KAAK;MAC5C,OAAW;QACLyM,QAAA,GAAW,KAAK3P,YAAA,GAAe0P,QAAA;MAChC;MAED,IAAI5D,QAAA,CAAS6D,QAAQ,MAAM,QAAW,OAAO7D,QAAA,CAAS6D,QAAQ;MAE9D,IAAI/Q,MAAA,GAAS,KAAKJ,OAAA,CAAQyR,UAAA,CAAWN,QAAQ;MAE7C,IAAI/Q,MAAA,KAAW,MAAM;QACnBA,MAAA,GAAS8Q,QAAA,CAAStM,KAAA,CAAM,EAAE,EAAE9C,WAAA,OAAkB,SAAS,KAAKiP,aAAA,CAAe,IAAG,KAAK5D,aAAA;MACpF;MAED,IAAMuE,OAAA,GAAUtR,MAAA,CAAOY,IAAA,CACrBmQ,QAAA,EACA,UAAUQ,CAAA,EAAG;QAIX,IAAI5F,MAAA,CAAO4D,aAAA,KAAkB,MAAM;UACjCgC,CAAA,CAAEC,KAAA,GAAQjP,KAAA,CAAMkP,gBAAA,CAAiBF,CAAA,CAAEC,KAAK;UAExCD,CAAA,CAAEG,SAAA,GAAYC,aAAA;UACdJ,CAAA,CAAEK,SAAA,GAAYD,aAAA;QACf;QAEDJ,CAAA,CAAEM,KAAA,GAAQ;QACVN,CAAA,CAAEO,KAAA,GAAQC,cAAA;QACVR,CAAA,CAAES,KAAA,GAAQD,cAAA;QAEV,SAASlO,CAAA,GAAI,GAAGA,CAAA,GAAIyN,OAAA,CAAQW,cAAA,CAAerO,MAAA,EAAQC,CAAA,IAAK;UACtDyN,OAAA,CAAQW,cAAA,CAAepO,CAAC,EAAEyN,OAAO;QAClC;QAED,OAAOA,OAAA,CAAQW,cAAA;MAChB,GACDlR,UAAA,EACAC,OACD;MAEDsQ,OAAA,CAAQW,cAAA,GAAiB,EAAE;MAE3B/E,QAAA,CAAS6D,QAAQ,IAAIO,OAAA;MAErB,OAAOA,OAAA;IACR;EAAA;IAAA9Q,GAAA;IAAAC,KAAA,EAED,SAAAgR,iBAAiBD,KAAA,EAAO;MACtB,IAAMU,MAAA,GAASC,QAAA,CAASC,aAAA,CAAc,QAAQ;MAC9C,IAAMC,OAAA,GAAUH,MAAA,CAAOI,UAAA,CAAW,IAAI;MAEtC,IAAMC,KAAA,GAAQf,KAAA,CAAMe,KAAA;MACpB,IAAMC,MAAA,GAAShB,KAAA,CAAMgB,MAAA;MAErBN,MAAA,CAAOK,KAAA,GAAQA,KAAA;MACfL,MAAA,CAAOM,MAAA,GAASA,MAAA;MAEhBH,OAAA,CAAQI,SAAA,CAAU,GAAG,GAAGF,KAAA,EAAOC,MAAM;MACrCH,OAAA,CAAQK,SAAA,CAAUH,KAAA,GAAQ,GAAKC,MAAA,GAAS,CAAG;MAC3CH,OAAA,CAAQM,MAAA,CAAO,MAAMnK,IAAA,CAAKoK,EAAE;MAC5BP,OAAA,CAAQK,SAAA,CAAU,CAACH,KAAA,GAAQ,GAAK,CAACC,MAAA,GAAS,CAAG;MAC7CH,OAAA,CAAQQ,SAAA,CAAUrB,KAAA,EAAO,GAAG,CAAC;MAE7B,OAAOa,OAAA,CAAQS,YAAA,CAAa,GAAG,GAAGP,KAAA,EAAOC,MAAM;IAChD;IAAA;EAAA;IAAAhS,GAAA;IAAAC,KAAA,EAGD,SAAA6P,wBAAwB1B,GAAA,EAAK5J,QAAA,EAAU+N,UAAA,EAAY;MACjDnE,GAAA,CAAIqD,cAAA,CAAelO,IAAA,CAAK,UAAUuN,OAAA,EAAS;QAEzC,SAAS0B,gBAAgBxB,KAAA,EAAO;UAC9B,IAAMU,MAAA,GAASC,QAAA,CAASC,aAAA,CAAc,QAAQ;UAC9CF,MAAA,CAAOK,KAAA,GAAQf,KAAA,CAAMe,KAAA;UACrBL,MAAA,CAAOM,MAAA,GAAShB,KAAA,CAAMgB,MAAA;UAEtB,IAAMH,OAAA,GAAUH,MAAA,CAAOI,UAAA,CAAW,IAAI;UACtCD,OAAA,CAAQQ,SAAA,CAAUrB,KAAA,EAAO,GAAG,CAAC;UAE7B,OAAOa,OAAA,CAAQS,YAAA,CAAa,GAAG,GAAGZ,MAAA,CAAOK,KAAA,EAAOL,MAAA,CAAOM,MAAM;QAC9D;QAED,SAASS,wBAAwBzB,KAAA,EAAOhL,GAAA,EAAKE,OAAA,EAAS;UACpD,IAAM6L,KAAA,GAAQf,KAAA,CAAMe,KAAA;UACpB,IAAMC,MAAA,GAAShB,KAAA,CAAMgB,MAAA;UACrB,IAAM5Q,IAAA,GAAO4P,KAAA,CAAM5P,IAAA;UACnB,IAAMsR,SAAA,GAAY;UAElB,IAAItR,IAAA,CAAKgC,MAAA,IAAU2O,KAAA,GAAQC,MAAA,MAAY,GAAG,OAAO;UAEjD,SAAS3O,CAAA,GAAI,GAAGA,CAAA,GAAI6C,OAAA,CAAQ9C,MAAA,EAAQC,CAAA,IAAK,GAAG;YAC1C,IAAMsP,QAAA,GAAW;cAAEC,CAAA,EAAG;cAAKC,CAAA,EAAG;YAAK;YAEnC,SAAS3L,CAAA,GAAI,GAAGA,CAAA,GAAI,GAAGA,CAAA,IAAK;cAC1B,IAAMpD,KAAA,GAAQoC,OAAA,CAAQ7C,CAAA,GAAI,IAAI6D,CAAC;cAC/B,IAAMG,EAAA,GAAK;gBAAEuL,CAAA,EAAG5M,GAAA,CAAIlC,KAAA,GAAQ,IAAI,CAAC;gBAAG+O,CAAA,EAAG7M,GAAA,CAAIlC,KAAA,GAAQ,IAAI,CAAC;cAAG;cAE3D,IAAIgP,YAAA,CAAa9B,KAAA,EAAO3J,EAAE,IAAIqL,SAAA,EAAW,OAAO;cAEhDC,QAAA,CAASC,CAAA,IAAKvL,EAAA,CAAGuL,CAAA;cACjBD,QAAA,CAASE,CAAA,IAAKxL,EAAA,CAAGwL,CAAA;YAClB;YAEDF,QAAA,CAASC,CAAA,IAAK;YACdD,QAAA,CAASE,CAAA,IAAK;YAEd,IAAIC,YAAA,CAAa9B,KAAA,EAAO2B,QAAQ,IAAID,SAAA,EAAW,OAAO;UACvD;UAED,OAAO;QACR;QASD,SAASI,aAAa9B,KAAA,EAAO3J,EAAA,EAAI;UAC/B,IAAM0K,KAAA,GAAQf,KAAA,CAAMe,KAAA;UACpB,IAAMC,MAAA,GAAShB,KAAA,CAAMgB,MAAA;UAErB,IAAIY,CAAA,GAAI5K,IAAA,CAAK+K,KAAA,CAAM1L,EAAA,CAAGuL,CAAA,GAAIb,KAAK,IAAIA,KAAA;UACnC,IAAIc,CAAA,GAAI7K,IAAA,CAAK+K,KAAA,CAAM1L,EAAA,CAAGwL,CAAA,GAAIb,MAAM,IAAIA,MAAA;UAEpC,IAAIY,CAAA,GAAI,GAAGA,CAAA,IAAKb,KAAA;UAChB,IAAIc,CAAA,GAAI,GAAGA,CAAA,IAAKb,MAAA;UAEhB,IAAMlO,KAAA,GAAQ+O,CAAA,GAAId,KAAA,GAAQa,CAAA;UAE1B,OAAO5B,KAAA,CAAM5P,IAAA,CAAK0C,KAAA,GAAQ,IAAI,CAAC;QAChC;QAED,IAAMkP,SAAA,GAAYlC,OAAA,CAAQE,KAAA,CAAM5P,IAAA,KAAS,SAAY0P,OAAA,CAAQE,KAAA,GAAQwB,eAAA,CAAgB1B,OAAA,CAAQE,KAAK;QAElG,IAAMiC,KAAA,GAAQzO,QAAA,CAAS2B,MAAA,CAAOoM,UAAU;QAExC,IACEE,uBAAA,CACEO,SAAA,EACAxO,QAAA,CAAS0O,UAAA,CAAW7L,EAAA,CAAG4D,KAAA,EACvBzG,QAAA,CAASV,KAAA,CAAMmH,KAAA,CAAMjH,KAAA,CAAMiP,KAAA,CAAME,KAAA,EAAOF,KAAA,CAAME,KAAA,GAAQF,KAAA,CAAMtL,KAAK,CAClE,GACD;UACAyG,GAAA,CAAInB,WAAA,GAAc;QACnB;MACP,CAAK;IACF;EAAA;EAAA,OAAA1I,eAAA;AAAA;AAAA,IAKGzE,gBAAA;EAAA,SAAAA,iBAAA;IAAAR,eAAA,OAAAQ,gBAAA;EAAA;EAAAC,YAAA,CAAAD,gBAAA;IAAAE,GAAA;IAAAC,KAAA;IAAiB;AAAA;AAAA;AAAA;AAAA;IAMrB,SAAAoB,MAAMI,GAAA,EAAKO,IAAA,EAAM;MAGf,IAAMoR,MAAA,GAAS,KAAKC,sBAAA,CAAuB5R,GAAA,EAAKO,IAAI,EAAEoR,MAAA;MACtD,IAAME,OAAA,GAAU,KAAKC,mBAAA,CAAoB9R,GAAA,EAAKO,IAAI,EAAEoR,MAAA;MAEpD,SAAS/P,CAAA,GAAI,GAAGC,EAAA,GAAKgQ,OAAA,CAAQlQ,MAAA,EAAQC,CAAA,GAAIC,EAAA,EAAID,CAAA,IAAK;QAChD+P,MAAA,CAAO7P,IAAA,CAAK+P,OAAA,CAAQjQ,CAAC,CAAC;MACvB;MAED,OAAO,IAAImQ,aAAA,CAAc,IAAI,IAAIJ,MAAM;IACxC;IAAA;AAAA;AAAA;AAAA;AAAA;EAAA;IAAApT,GAAA;IAAAC,KAAA,EAOD,SAAAoT,uBAAuB5R,GAAA,EAAKO,IAAA,EAAM;MAChC,SAASyR,kBAAkBxI,KAAA,EAAOyI,aAAA,EAAe5P,KAAA,EAAO;QACtDmH,KAAA,CAAM1H,IAAA,CAAKmQ,aAAA,CAAc5P,KAAA,GAAQ,CAAC,IAAI,GAAG;QACzCmH,KAAA,CAAM1H,IAAA,CAAKmQ,aAAA,CAAc5P,KAAA,GAAQ,CAAC,IAAI,GAAG;QACzCmH,KAAA,CAAM1H,IAAA,CAAKmQ,aAAA,CAAc5P,KAAA,GAAQ,CAAC,IAAI,GAAG;QACzCmH,KAAA,CAAM1H,IAAA,CAAKmQ,aAAA,CAAc5P,KAAA,GAAQ,EAAE,IAAI,GAAG;MAC3C;MAED,IAAMsP,MAAA,GAAS,EAAE;MAEjB,IAAMO,OAAA,GAAU,CAAE;MAClB,IAAM3O,KAAA,GAAQhD,IAAA,CAAK4C,QAAA,CAASI,KAAA;MAC5B,IAAM4O,kBAAA,GAAqB,CAAE;MAE7B,SAASvQ,CAAA,GAAI,GAAGC,EAAA,GAAK0B,KAAA,CAAM5B,MAAA,EAAQC,CAAA,GAAIC,EAAA,EAAID,CAAA,IAAK;QAC9CuQ,kBAAA,CAAmB5O,KAAA,CAAM3B,CAAC,EAAE+B,IAAI,IAAI;MACrC;MAED,SAAS/B,IAAA,GAAI,GAAGA,IAAA,GAAI5B,GAAA,CAAIqF,QAAA,CAAS+M,WAAA,EAAaxQ,IAAA,IAAK;QACjD,IAAMyQ,MAAA,GAASrS,GAAA,CAAIkS,OAAA,CAAQtQ,IAAC;QAC5B,IAAM0Q,QAAA,GAAWD,MAAA,CAAOC,QAAA;QAExB,IAAIH,kBAAA,CAAmBG,QAAQ,MAAM,QAAW;QAEhDJ,OAAA,CAAQI,QAAQ,IAAIJ,OAAA,CAAQI,QAAQ,KAAK,EAAE;QAC3CJ,OAAA,CAAQI,QAAQ,EAAExQ,IAAA,CAAKuQ,MAAM;MAC9B;MAED,SAAW9T,GAAA,IAAO2T,OAAA,EAAS;QACzB,IAAM1I,KAAA,GAAQ0I,OAAA,CAAQ3T,GAAG;QAEzBiL,KAAA,CAAM+I,IAAA,CAAK,UAAUC,CAAA,EAAGC,CAAA,EAAG;UACzB,OAAOD,CAAA,CAAEE,QAAA,GAAWD,CAAA,CAAEC,QAAA;QAC9B,CAAO;QAED,IAAMC,KAAA,GAAQ,EAAE;QAChB,IAAMrO,SAAA,GAAY,EAAE;QACpB,IAAMsO,SAAA,GAAY,EAAE;QACpB,IAAMC,eAAA,GAAkB,EAAE;QAC1B,IAAMC,eAAA,GAAkB,EAAE;QAE1B,IAAMC,YAAA,GAAexS,IAAA,CAAK4C,QAAA,CAAS6P,aAAA,CAAczU,GAAG,EAAEqF,QAAA,CAASqP,OAAA,CAAS;QAExE,SAASrR,IAAA,GAAI,GAAGC,IAAA,GAAK2H,KAAA,CAAM7H,MAAA,EAAQC,IAAA,GAAIC,IAAA,EAAID,IAAA,IAAK;UAC9C,IAAMsR,IAAA,GAAO1J,KAAA,CAAM5H,IAAC,EAAE8Q,QAAA,GAAW;UACjC,IAAM9O,QAAA,GAAW4F,KAAA,CAAM5H,IAAC,EAAEgC,QAAA;UAC1B,IAAMuP,QAAA,GAAW3J,KAAA,CAAM5H,IAAC,EAAEuR,QAAA;UAC1B,IAAMlB,aAAA,GAAgBzI,KAAA,CAAM5H,IAAC,EAAEqQ,aAAA;UAE/BU,KAAA,CAAM7Q,IAAA,CAAKoR,IAAI;UAEf,SAASzN,CAAA,GAAI,GAAGA,CAAA,GAAI,GAAGA,CAAA,IAAKnB,SAAA,CAAUxC,IAAA,CAAKiR,YAAA,CAAatN,CAAC,IAAI7B,QAAA,CAAS6B,CAAC,CAAC;UACxE,SAASA,IAAA,GAAI,GAAGA,IAAA,GAAI,GAAGA,IAAA,IAAKmN,SAAA,CAAU9Q,IAAA,CAAKqR,QAAA,CAAS1N,IAAC,CAAC;UACtD,SAASA,IAAA,GAAI,GAAGA,IAAA,GAAI,GAAGA,IAAA,IAAKuM,iBAAA,CAAkBa,eAAA,EAAiBZ,aAAA,EAAexM,IAAC;UAE/EuM,iBAAA,CAAkBc,eAAA,EAAiBb,aAAA,EAAe,CAAC;QACpD;QAED,IAAMmB,UAAA,GAAa,YAAY7U,GAAA,GAAM;QAErCoT,MAAA,CAAO7P,IAAA,CAAK,KAAKuR,YAAA,CAAaD,UAAA,GAAa,aAAaE,mBAAA,EAAqBX,KAAA,EAAOrO,SAAA,EAAWuO,eAAe,CAAC;QAC/GlB,MAAA,CAAO7P,IAAA,CACL,KAAKuR,YAAA,CAAaD,UAAA,GAAa,eAAeG,uBAAA,EAAyBZ,KAAA,EAAOC,SAAA,EAAWE,eAAe,CACzG;MACF;MAED,OAAO,IAAIf,aAAA,CAAc,IAAI,IAAIJ,MAAM;IACxC;IAAA;AAAA;AAAA;AAAA;AAAA;EAAA;IAAApT,GAAA;IAAAC,KAAA,EAOD,SAAAsT,oBAAoB9R,GAAA,EAAKO,IAAA,EAAM;MAC7B,IAAMoR,MAAA,GAAS,EAAE;MAEjB,IAAMpI,MAAA,GAAS,CAAE;MACjB,IAAMiK,qBAAA,GAAwBjT,IAAA,CAAKiT,qBAAA;MAEnC,SAAS5R,CAAA,GAAI,GAAGA,CAAA,GAAI5B,GAAA,CAAIqF,QAAA,CAASoE,UAAA,EAAY7H,CAAA,IAAK;QAChD,IAAMuH,KAAA,GAAQnJ,GAAA,CAAIuJ,MAAA,CAAO3H,CAAC;QAC1B,IAAM6R,SAAA,GAAYtK,KAAA,CAAMsK,SAAA;QAExB,IAAID,qBAAA,CAAsBC,SAAS,MAAM,QAAW;QAEpDlK,MAAA,CAAOkK,SAAS,IAAIlK,MAAA,CAAOkK,SAAS,KAAK,EAAE;QAC3ClK,MAAA,CAAOkK,SAAS,EAAE3R,IAAA,CAAKqH,KAAK;MAC7B;MAED,SAAW5K,GAAA,IAAOgL,MAAA,EAAQ;QACxB,IAAMC,KAAA,GAAQD,MAAA,CAAOhL,GAAG;QAExBiL,KAAA,CAAM+I,IAAA,CAAK,UAAUC,CAAA,EAAGC,CAAA,EAAG;UACzB,OAAOD,CAAA,CAAEE,QAAA,GAAWD,CAAA,CAAEC,QAAA;QAC9B,CAAO;QAED,IAAMC,KAAA,GAAQ,EAAE;QAChB,IAAMe,MAAA,GAAS,EAAE;QAEjB,SAAS9R,IAAA,GAAI,GAAGC,EAAA,GAAK2H,KAAA,CAAM7H,MAAA,EAAQC,IAAA,GAAIC,EAAA,EAAID,IAAA,IAAK;UAC9C+Q,KAAA,CAAM7Q,IAAA,CAAK0H,KAAA,CAAM5H,IAAC,EAAE8Q,QAAA,GAAW,EAAE;UACjCgB,MAAA,CAAO5R,IAAA,CAAK0H,KAAA,CAAM5H,IAAC,EAAE+R,MAAM;QAC5B;QAEDhC,MAAA,CAAO7P,IAAA,CAAK,IAAI8R,mBAAA,CAAoB,4BAA4BJ,qBAAA,CAAsBjV,GAAG,IAAI,KAAKoU,KAAA,EAAOe,MAAM,CAAC;MACjH;MAED,OAAO,IAAI3B,aAAA,CAAc,IAAI,IAAIJ,MAAM;IACxC;IAAA;AAAA;AAAA;AAAA;EAAA;IAAApT,GAAA;IAAAC,KAAA,EAMD,SAAA0B,qBAAqBF,GAAA,EAAK;MACxB,SAAS6T,YAAYrK,KAAA,EAAOsK,GAAA,EAAK;QAC/BtK,KAAA,CAAM1H,IAAA,CAAKgS,GAAA,CAAI3C,CAAC;QAChB3H,KAAA,CAAM1H,IAAA,CAAKgS,GAAA,CAAI1C,CAAC;QAChB5H,KAAA,CAAM1H,IAAA,CAAKgS,GAAA,CAAIC,CAAC;MACjB;MAED,SAASC,eAAexK,KAAA,EAAOyK,CAAA,EAAG;QAChCzK,KAAA,CAAM1H,IAAA,CAAKmS,CAAA,CAAE9C,CAAC;QACd3H,KAAA,CAAM1H,IAAA,CAAKmS,CAAA,CAAE7C,CAAC;QACd5H,KAAA,CAAM1H,IAAA,CAAKmS,CAAA,CAAEF,CAAC;QACdvK,KAAA,CAAM1H,IAAA,CAAKmS,CAAA,CAAEC,CAAC;MACf;MAED,SAASlC,kBAAkBxI,KAAA,EAAOyI,aAAA,EAAe5P,KAAA,EAAO;QACtDmH,KAAA,CAAM1H,IAAA,CAAKmQ,aAAA,CAAc5P,KAAA,GAAQ,IAAI,CAAC,IAAI,GAAG;QAC7CmH,KAAA,CAAM1H,IAAA,CAAKmQ,aAAA,CAAc5P,KAAA,GAAQ,IAAI,CAAC,IAAI,GAAG;QAC7CmH,KAAA,CAAM1H,IAAA,CAAKmQ,aAAA,CAAc5P,KAAA,GAAQ,IAAI,CAAC,IAAI,GAAG;QAC7CmH,KAAA,CAAM1H,IAAA,CAAKmQ,aAAA,CAAc5P,KAAA,GAAQ,IAAI,CAAC,IAAI,GAAG;MAC9C;MAED,IAAM8R,OAAA,GAAUnU,GAAA,CAAImU,OAAA,KAAY,SAAY,KAAKnU,GAAA,CAAImU,OAAA,CAAQ5R,KAAA,CAAO;MAEpE4R,OAAA,CAAQ5B,IAAA,CAAK,UAAUC,CAAA,EAAGC,CAAA,EAAG;QAC3B,OAAOD,CAAA,CAAEE,QAAA,GAAWD,CAAA,CAAEC,QAAA;MAC5B,CAAK;MAED,IAAMC,KAAA,GAAQ,EAAE;MAChB,IAAMyB,OAAA,GAAU,EAAE;MAClB,IAAMC,WAAA,GAAc,EAAE;MACtB,IAAM/P,SAAA,GAAY,EAAE;MACpB,IAAMgQ,IAAA,GAAO,EAAE;MAEf,IAAMC,eAAA,GAAkB,EAAE;MAC1B,IAAMC,eAAA,GAAkB,EAAE;MAC1B,IAAM3B,eAAA,GAAkB,EAAE;MAC1B,IAAM4B,eAAA,GAAkB,EAAE;MAE1B,IAAM1Q,UAAA,GAAa,IAAI2Q,UAAA,CAAY;MACnC,IAAMC,KAAA,GAAQ,IAAIC,KAAA,CAAO;MACzB,IAAMhR,QAAA,GAAW,IAAI+D,OAAA,CAAS;MAC9B,IAAMkN,MAAA,GAAS,IAAIlN,OAAA,CAAS;MAE5B,SAAS/F,CAAA,GAAI,GAAGC,EAAA,GAAKsS,OAAA,CAAQxS,MAAA,EAAQC,CAAA,GAAIC,EAAA,EAAID,CAAA,IAAK;QAChD,IAAMyQ,MAAA,GAAS8B,OAAA,CAAQvS,CAAC;QAExB,IAAMsR,IAAA,GAAOb,MAAA,CAAOK,QAAA,GAAW;QAC/B,IAAM5O,GAAA,GAAMuO,MAAA,CAAOzO,QAAA;QACnB,IAAMkR,GAAA,GAAMzC,MAAA,CAAOc,QAAA;QACnB,IAAM4B,QAAA,GAAW1C,MAAA,CAAO0C,QAAA;QACxB,IAAMC,GAAA,GAAM3C,MAAA,CAAO2C,GAAA;QACnB,IAAM/C,aAAA,GAAgBI,MAAA,CAAOJ,aAAA;QAE7BU,KAAA,CAAM7Q,IAAA,CAAKoR,IAAI;QAEftP,QAAA,CAASqR,GAAA,CAAI,GAAG,GAAG,CAACF,QAAQ;QAC5BF,MAAA,CAAOI,GAAA,CAAInR,GAAA,CAAI,CAAC,GAAGA,GAAA,CAAI,CAAC,GAAGA,GAAA,CAAI,CAAC,CAAC;QAEjC6Q,KAAA,CAAMM,GAAA,CAAI,CAACH,GAAA,CAAI,CAAC,GAAG,CAACA,GAAA,CAAI,CAAC,GAAG,CAACA,GAAA,CAAI,CAAC,CAAC;QACnC/Q,UAAA,CAAWmR,YAAA,CAAaP,KAAK;QAE7B/Q,QAAA,CAASQ,GAAA,CAAIyQ,MAAM;QACnBjR,QAAA,CAASuR,eAAA,CAAgBpR,UAAU;QAEnC8P,WAAA,CAAYO,OAAA,EAASS,MAAM;QAC3Bb,cAAA,CAAeK,WAAA,EAAatQ,UAAU;QACtC8P,WAAA,CAAYvP,SAAA,EAAWV,QAAQ;QAE/B0Q,IAAA,CAAKxS,IAAA,CAAKkT,GAAG;QAEb,SAASvP,CAAA,GAAI,GAAGA,CAAA,GAAI,GAAGA,CAAA,IAAK;UAC1BuM,iBAAA,CAAkBuC,eAAA,EAAiBtC,aAAA,EAAexM,CAAC;QACpD;QAEDuM,iBAAA,CAAkBwC,eAAA,EAAiBvC,aAAA,EAAe,CAAC;QAGnD,SAASxM,IAAA,GAAI,GAAGA,IAAA,GAAI,GAAGA,IAAA,IAAK;UAC1BuM,iBAAA,CAAkBa,eAAA,EAAiBZ,aAAA,EAAe,CAAC;QACpD;QAEDD,iBAAA,CAAkByC,eAAA,EAAiBxC,aAAA,EAAe,CAAC;MACpD;MAED,IAAMN,MAAA,GAAS,EAAE;MAGjBA,MAAA,CAAO7P,IAAA,CAAK,KAAKuR,YAAA,CAAa,mBAAmBC,mBAAA,EAAqBX,KAAA,EAAOyB,OAAA,EAASG,eAAe,CAAC;MAEtG5C,MAAA,CAAO7P,IAAA,CAAK,KAAKuR,YAAA,CAAa,eAAeE,uBAAA,EAAyBZ,KAAA,EAAO0B,WAAA,EAAaG,eAAe,CAAC;MAC1G7C,MAAA,CAAO7P,IAAA,CAAK,KAAKuR,YAAA,CAAa,aAAaC,mBAAA,EAAqBX,KAAA,EAAOrO,SAAA,EAAWuO,eAAe,CAAC;MAClGlB,MAAA,CAAO7P,IAAA,CAAK,KAAKuR,YAAA,CAAa,QAAQO,mBAAA,EAAqBjB,KAAA,EAAO2B,IAAA,EAAMG,eAAe,CAAC;MAExF,OAAO,IAAI1C,aAAA,CAAc,IAAI,IAAIJ,MAAM;IACxC;IAAA;EAAA;IAAApT,GAAA;IAAAC,KAAA,EAID,SAAA6U,aAAa+B,IAAA,EAAMC,kBAAA,EAAoB1C,KAAA,EAAOe,MAAA,EAAQ4B,cAAA,EAAgB;MAMpE,IAAI3C,KAAA,CAAMhR,MAAA,GAAS,GAAG;QACpBgR,KAAA,GAAQA,KAAA,CAAMpQ,KAAA,CAAO;QACrBmR,MAAA,GAASA,MAAA,CAAOnR,KAAA,CAAO;QACvB+S,cAAA,GAAiBA,cAAA,CAAe/S,KAAA,CAAO;QAEvC,IAAMgT,MAAA,GAAS7B,MAAA,CAAO/R,MAAA,GAASgR,KAAA,CAAMhR,MAAA;QACrC,IAAM6T,iBAAA,GAAoBF,cAAA,CAAe3T,MAAA,GAASgR,KAAA,CAAMhR,MAAA;QAExD,IAAIU,KAAA,GAAQ;QAEZ,SAASoT,UAAA,GAAa,GAAGC,QAAA,GAAW/C,KAAA,CAAMhR,MAAA,EAAQ8T,UAAA,GAAaC,QAAA,EAAUD,UAAA,IAAc;UACrF,SAAS7T,CAAA,GAAI,GAAGA,CAAA,GAAI2T,MAAA,EAAQ3T,CAAA,IAAK;YAC/B,IACE8R,MAAA,CAAOrR,KAAA,GAAQkT,MAAA,GAAS3T,CAAC,MAAM8R,MAAA,EAAQrR,KAAA,GAAQ,KAAKkT,MAAA,GAAS3T,CAAC,KAC9D8R,MAAA,CAAOrR,KAAA,GAAQkT,MAAA,GAAS3T,CAAC,MAAM8R,MAAA,CAAO+B,UAAA,GAAaF,MAAA,GAAS3T,CAAC,GAC7D;cACAS,KAAA;cACA;YACD;UACF;UAED,IAAIoT,UAAA,GAAapT,KAAA,EAAO;YACtBsQ,KAAA,CAAMtQ,KAAK,IAAIsQ,KAAA,CAAM8C,UAAU;YAE/B,SAAS7T,IAAA,GAAI,GAAGA,IAAA,GAAI2T,MAAA,EAAQ3T,IAAA,IAAK;cAC/B8R,MAAA,CAAOrR,KAAA,GAAQkT,MAAA,GAAS3T,IAAC,IAAI8R,MAAA,CAAO+B,UAAA,GAAaF,MAAA,GAAS3T,IAAC;YAC5D;YAED,SAASA,IAAA,GAAI,GAAGA,IAAA,GAAI4T,iBAAA,EAAmB5T,IAAA,IAAK;cAC1C0T,cAAA,CAAejT,KAAA,GAAQmT,iBAAA,GAAoB5T,IAAC,IAAI0T,cAAA,CAAeG,UAAA,GAAaD,iBAAA,GAAoB5T,IAAC;YAClG;UACF;QACF;QAED+Q,KAAA,CAAMhR,MAAA,GAASU,KAAA,GAAQ;QACvBqR,MAAA,CAAO/R,MAAA,IAAUU,KAAA,GAAQ,KAAKkT,MAAA;QAC9BD,cAAA,CAAe3T,MAAA,IAAUU,KAAA,GAAQ,KAAKmT,iBAAA;MACvC;MAED,IAAMG,KAAA,GAAQ,IAAIN,kBAAA,CAAmBD,IAAA,EAAMzC,KAAA,EAAOe,MAAM;MAExDiC,KAAA,CAAMC,iBAAA,GAAoB,SAASC,oCAAoCC,MAAA,EAAQ;QAC7E,OAAO,IAAIC,wBAAA,CACT,KAAKpD,KAAA,EACL,KAAKe,MAAA,EACL,KAAKsC,YAAA,CAAc,GACnBF,MAAA,EACA,IAAIG,YAAA,CAAaX,cAAc,CAChC;MACF;MAED,OAAOK,KAAA;IACR;EAAA;EAAA,OAAAtX,gBAAA;AAAA;AAAA,IAKG0X,wBAAA,0BAAAG,YAAA;EAAA1Y,SAAA,CAAAuY,wBAAA,EAAAG,YAAA;EAAA,IAAAC,OAAA,GAAAzY,YAAA,CAAAqY,wBAAA;EACJ,SAAAA,yBAAYK,kBAAA,EAAoBC,YAAA,EAAcC,UAAA,EAAYC,YAAA,EAAc7M,MAAA,EAAQ;IAAA,IAAA8M,MAAA;IAAA3Y,eAAA,OAAAkY,wBAAA;IAC9ES,MAAA,GAAAL,OAAA,CAAArY,IAAA,OAAMsY,kBAAA,EAAoBC,YAAA,EAAcC,UAAA,EAAYC,YAAY;IAEhEC,MAAA,CAAKC,mBAAA,GAAsB/M,MAAA;IAAA,OAAA8M,MAAA;EAC5B;EAAAlY,YAAA,CAAAyX,wBAAA;IAAAxX,GAAA;IAAAC,KAAA,EAED,SAAAkY,aAAaC,EAAA,EAAIC,EAAA,EAAItH,CAAA,EAAGuH,EAAA,EAAI;MAC1B,IAAMf,MAAA,GAAS,KAAKS,YAAA;MACpB,IAAM7C,MAAA,GAAS,KAAK2C,YAAA;MACpB,IAAMd,MAAA,GAAS,KAAKuB,SAAA;MACpB,IAAMpN,MAAA,GAAS,KAAK+M,mBAAA;MAEpB,IAAMM,OAAA,GAAUJ,EAAA,GAAKpB,MAAA;MACrB,IAAMyB,OAAA,GAAUD,OAAA,GAAUxB,MAAA;MAK1B,IAAM0B,OAAA,GAAUJ,EAAA,GAAKD,EAAA,GAAM,IAAI,KAAM,MAAM,KAAOtH,CAAA,GAAIsH,EAAA,KAAOC,EAAA,GAAKD,EAAA;MAElE,IAAIrB,MAAA,KAAW,GAAG;QAGhB,IAAM2B,EAAA,GAAKxN,MAAA,CAAOiN,EAAA,GAAK,IAAI,CAAC;QAC5B,IAAMQ,EAAA,GAAKzN,MAAA,CAAOiN,EAAA,GAAK,IAAI,CAAC;QAC5B,IAAMS,EAAA,GAAK1N,MAAA,CAAOiN,EAAA,GAAK,IAAI,CAAC;QAC5B,IAAMU,EAAA,GAAK3N,MAAA,CAAOiN,EAAA,GAAK,IAAI,CAAC;QAE5B,IAAMjO,KAAA,GAAQ,KAAK4O,UAAA,CAAWJ,EAAA,EAAIC,EAAA,EAAIC,EAAA,EAAIC,EAAA,EAAIJ,OAAO;QAErDvC,UAAA,CAAW6C,SAAA,CAAUzB,MAAA,EAAQ,GAAGpC,MAAA,EAAQsD,OAAA,EAAStD,MAAA,EAAQqD,OAAA,EAASrO,KAAK;MAC7E,WAAe6M,MAAA,KAAW,GAAG;QAGvB,SAAS3T,CAAA,GAAI,GAAGA,CAAA,KAAM2T,MAAA,EAAQ,EAAE3T,CAAA,EAAG;UACjC,IAAMsV,EAAA,GAAKxN,MAAA,CAAOiN,EAAA,GAAK,KAAK/U,CAAA,GAAI,IAAI,CAAC;UACrC,IAAMuV,GAAA,GAAKzN,MAAA,CAAOiN,EAAA,GAAK,KAAK/U,CAAA,GAAI,IAAI,CAAC;UACrC,IAAMwV,EAAA,GAAK1N,MAAA,CAAOiN,EAAA,GAAK,KAAK/U,CAAA,GAAI,IAAI,CAAC;UACrC,IAAMyV,GAAA,GAAK3N,MAAA,CAAOiN,EAAA,GAAK,KAAK/U,CAAA,GAAI,IAAI,CAAC;UAErC,IAAM8G,MAAA,GAAQ,KAAK4O,UAAA,CAAWJ,EAAA,EAAIC,GAAA,EAAIC,EAAA,EAAIC,GAAA,EAAIJ,OAAO;UAErDnB,MAAA,CAAOlU,CAAC,IAAI8R,MAAA,CAAOsD,OAAA,GAAUpV,CAAC,KAAK,IAAI8G,MAAA,IAASgL,MAAA,CAAOqD,OAAA,GAAUnV,CAAC,IAAI8G,MAAA;QACvE;MACP,OAAW;QAGL,IAAMwO,GAAA,GAAKxN,MAAA,CAAOiN,EAAA,GAAK,IAAI,CAAC;QAC5B,IAAMQ,GAAA,GAAKzN,MAAA,CAAOiN,EAAA,GAAK,IAAI,CAAC;QAC5B,IAAMS,GAAA,GAAK1N,MAAA,CAAOiN,EAAA,GAAK,IAAI,CAAC;QAC5B,IAAMU,GAAA,GAAK3N,MAAA,CAAOiN,EAAA,GAAK,IAAI,CAAC;QAE5B,IAAMjO,OAAA,GAAQ,KAAK4O,UAAA,CAAWJ,GAAA,EAAIC,GAAA,EAAIC,GAAA,EAAIC,GAAA,EAAIJ,OAAO;QAErDnB,MAAA,CAAO,CAAC,IAAIpC,MAAA,CAAOsD,OAAO,KAAK,IAAItO,OAAA,IAASgL,MAAA,CAAOqD,OAAO,IAAIrO,OAAA;MAC/D;MAED,OAAOoN,MAAA;IACR;EAAA;IAAAvX,GAAA;IAAAC,KAAA,EAED,SAAA8Y,WAAWJ,EAAA,EAAIC,EAAA,EAAIC,EAAA,EAAIC,EAAA,EAAIlG,CAAA,EAAG;MAsC5B,IAAIqG,CAAA,GAAI;MACR,IAAIlI,CAAA,GAAIkI,CAAA;MACR,IAAIC,CAAA,GAAI,IAAMnI,CAAA;MACd,IAAMoI,IAAA,GAAO;MACb,IAAMC,GAAA,GAAM;MACZ,IAAMC,IAAA,GAAOrR,IAAA;MAEb,IAAIsR,IAAA,EAAMC,IAAA,EAAMC,GAAA;MAEhB,SAASnW,CAAA,GAAI,GAAGA,CAAA,GAAI8V,IAAA,EAAM9V,CAAA,IAAK;QAC7BiW,IAAA,GAAO,IAAMJ,CAAA,GAAIA,CAAA,GAAInI,CAAA;QACrBwI,IAAA,GAAO,IAAML,CAAA,GAAInI,CAAA,GAAIA,CAAA;QACrByI,GAAA,GAAMzI,CAAA,GAAIA,CAAA,GAAIA,CAAA;QAEd,IAAM0I,EAAA,GAAKH,IAAA,GAAOX,EAAA,GAAKY,IAAA,GAAOX,EAAA,GAAKY,GAAA,GAAM5G,CAAA;QAEzC,IAAIyG,IAAA,CAAKK,GAAA,CAAID,EAAE,IAAIL,GAAA,EAAK;QAExBH,CAAA,IAAK;QAELlI,CAAA,IAAK0I,EAAA,GAAK,IAAIR,CAAA,GAAI,CAACA,CAAA;QACnBC,CAAA,GAAI,IAAMnI,CAAA;MACX;MAED,OAAOuI,IAAA,GAAOT,EAAA,GAAKU,IAAA,GAAOT,EAAA,GAAKU,GAAA;IAChC;EAAA;EAAA,OAAAhC,wBAAA;AAAA,EA5HoCmC,WAAA"},"metadata":{},"sourceType":"module","externalDependencies":[]}