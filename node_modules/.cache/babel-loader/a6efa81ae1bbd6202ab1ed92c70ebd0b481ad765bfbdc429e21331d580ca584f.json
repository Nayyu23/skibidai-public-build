{"ast":null,"code":"import _classCallCheck from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport { Texture, LinearFilter, ClampToEdgeWrapping, MeshBasicMaterial, DoubleSide, Mesh, PlaneGeometry } from \"three\";\nvar VolumeSlice = /*#__PURE__*/function () {\n  function VolumeSlice(volume, index, axis) {\n    _classCallCheck(this, VolumeSlice);\n    var slice = this;\n    this.volume = volume;\n    index = index || 0;\n    Object.defineProperty(this, \"index\", {\n      get: function get() {\n        return index;\n      },\n      set: function set(value) {\n        index = value;\n        slice.geometryNeedsUpdate = true;\n        return index;\n      }\n    });\n    this.axis = axis || \"z\";\n    this.canvas = document.createElement(\"canvas\");\n    this.canvasBuffer = document.createElement(\"canvas\");\n    this.updateGeometry();\n    var canvasMap = new Texture(this.canvas);\n    canvasMap.minFilter = LinearFilter;\n    canvasMap.wrapS = canvasMap.wrapT = ClampToEdgeWrapping;\n    if (\"colorSpace\" in canvasMap) canvasMap.colorSpace = \"srgb\";else canvasMap.encoding = 3001;\n    var material = new MeshBasicMaterial({\n      map: canvasMap,\n      side: DoubleSide,\n      transparent: true\n    });\n    this.mesh = new Mesh(this.geometry, material);\n    this.mesh.matrixAutoUpdate = false;\n    this.geometryNeedsUpdate = true;\n    this.repaint();\n  }\n  /**\n   * @member {Function} repaint Refresh the texture and the geometry if geometryNeedsUpdate is set to true\n   * @memberof VolumeSlice\n   */\n  _createClass(VolumeSlice, [{\n    key: \"repaint\",\n    value: function repaint() {\n      if (this.geometryNeedsUpdate) {\n        this.updateGeometry();\n      }\n      var iLength = this.iLength,\n        jLength = this.jLength,\n        sliceAccess = this.sliceAccess,\n        volume = this.volume,\n        canvas = this.canvasBuffer,\n        ctx = this.ctxBuffer;\n      var imgData = ctx.getImageData(0, 0, iLength, jLength);\n      var data = imgData.data;\n      var volumeData = volume.data;\n      var upperThreshold = volume.upperThreshold;\n      var lowerThreshold = volume.lowerThreshold;\n      var windowLow = volume.windowLow;\n      var windowHigh = volume.windowHigh;\n      var pixelCount = 0;\n      if (volume.dataType === \"label\") {\n        for (var j = 0; j < jLength; j++) {\n          for (var i = 0; i < iLength; i++) {\n            var label = volumeData[sliceAccess(i, j)];\n            label = label >= this.colorMap.length ? label % this.colorMap.length + 1 : label;\n            var color = this.colorMap[label];\n            data[4 * pixelCount] = color >> 24 & 255;\n            data[4 * pixelCount + 1] = color >> 16 & 255;\n            data[4 * pixelCount + 2] = color >> 8 & 255;\n            data[4 * pixelCount + 3] = color & 255;\n            pixelCount++;\n          }\n        }\n      } else {\n        for (var _j = 0; _j < jLength; _j++) {\n          for (var _i = 0; _i < iLength; _i++) {\n            var value = volumeData[sliceAccess(_i, _j)];\n            var alpha = 255;\n            alpha = upperThreshold >= value ? lowerThreshold <= value ? alpha : 0 : 0;\n            value = Math.floor(255 * (value - windowLow) / (windowHigh - windowLow));\n            value = value > 255 ? 255 : value < 0 ? 0 : value | 0;\n            data[4 * pixelCount] = value;\n            data[4 * pixelCount + 1] = value;\n            data[4 * pixelCount + 2] = value;\n            data[4 * pixelCount + 3] = alpha;\n            pixelCount++;\n          }\n        }\n      }\n      ctx.putImageData(imgData, 0, 0);\n      this.ctx.drawImage(canvas, 0, 0, iLength, jLength, 0, 0, this.canvas.width, this.canvas.height);\n      this.mesh.material.map.needsUpdate = true;\n    }\n    /**\n     * @member {Function} Refresh the geometry according to axis and index\n     * @see Volume.extractPerpendicularPlane\n     * @memberof VolumeSlice\n     */\n  }, {\n    key: \"updateGeometry\",\n    value: function updateGeometry() {\n      var extracted = this.volume.extractPerpendicularPlane(this.axis, this.index);\n      this.sliceAccess = extracted.sliceAccess;\n      this.jLength = extracted.jLength;\n      this.iLength = extracted.iLength;\n      this.matrix = extracted.matrix;\n      this.canvas.width = extracted.planeWidth;\n      this.canvas.height = extracted.planeHeight;\n      this.canvasBuffer.width = this.iLength;\n      this.canvasBuffer.height = this.jLength;\n      this.ctx = this.canvas.getContext(\"2d\");\n      this.ctxBuffer = this.canvasBuffer.getContext(\"2d\");\n      if (this.geometry) this.geometry.dispose();\n      this.geometry = new PlaneGeometry(extracted.planeWidth, extracted.planeHeight);\n      if (this.mesh) {\n        this.mesh.geometry = this.geometry;\n        this.mesh.matrix.identity();\n        this.mesh.applyMatrix4(this.matrix);\n      }\n      this.geometryNeedsUpdate = false;\n    }\n  }]);\n  return VolumeSlice;\n}();\nexport { VolumeSlice };","map":{"version":3,"names":["VolumeSlice","volume","index","axis","_classCallCheck","slice","Object","defineProperty","get","set","value","geometryNeedsUpdate","canvas","document","createElement","canvasBuffer","updateGeometry","canvasMap","Texture","minFilter","LinearFilter","wrapS","wrapT","ClampToEdgeWrapping","colorSpace","encoding","material","MeshBasicMaterial","map","side","DoubleSide","transparent","mesh","Mesh","geometry","matrixAutoUpdate","repaint","_createClass","key","iLength","jLength","sliceAccess","ctx","ctxBuffer","imgData","getImageData","data","volumeData","upperThreshold","lowerThreshold","windowLow","windowHigh","pixelCount","dataType","j","i","label","colorMap","length","color","alpha","Math","floor","putImageData","drawImage","width","height","needsUpdate","extracted","extractPerpendicularPlane","matrix","planeWidth","planeHeight","getContext","dispose","PlaneGeometry","identity","applyMatrix4"],"sources":["C:\\Users\\Nayyu\\Desktop\\skibidai-public-build\\node_modules\\src\\misc\\VolumeSlice.js"],"sourcesContent":["import { ClampToEdgeWrapping, DoubleSide, LinearFilter, Mesh, MeshBasicMaterial, PlaneGeometry, Texture } from 'three'\n\n/**\n * This class has been made to hold a slice of a volume data\n * @class\n * @param   {Volume} volume    The associated volume\n * @param   {number}       [index=0] The index of the slice\n * @param   {string}       [axis='z']      For now only 'x', 'y' or 'z' but later it will change to a normal vector\n * @see Volume\n */\nclass VolumeSlice {\n  constructor(volume, index, axis) {\n    const slice = this\n    /**\n     * @member {Volume} volume The associated volume\n     */\n    this.volume = volume\n    /**\n     * @member {Number} index The index of the slice, if changed, will automatically call updateGeometry at the next repaint\n     */\n    index = index || 0\n    Object.defineProperty(this, 'index', {\n      get: function () {\n        return index\n      },\n      set: function (value) {\n        index = value\n        slice.geometryNeedsUpdate = true\n        return index\n      },\n    })\n    /**\n     * @member {String} axis The normal axis\n     */\n    this.axis = axis || 'z'\n\n    /**\n     * @member {HTMLCanvasElement} canvas The final canvas used for the texture\n     */\n    /**\n     * @member {CanvasRenderingContext2D} ctx Context of the canvas\n     */\n    this.canvas = document.createElement('canvas')\n    /**\n     * @member {HTMLCanvasElement} canvasBuffer The intermediary canvas used to paint the data\n     */\n    /**\n     * @member {CanvasRenderingContext2D} ctxBuffer Context of the canvas buffer\n     */\n    this.canvasBuffer = document.createElement('canvas')\n    this.updateGeometry()\n\n    const canvasMap = new Texture(this.canvas)\n    canvasMap.minFilter = LinearFilter\n    canvasMap.wrapS = canvasMap.wrapT = ClampToEdgeWrapping\n    if ('colorSpace' in canvasMap) canvasMap.colorSpace = 'srgb'\n    else canvasMap.encoding = 3001 // sRGBEncoding\n    const material = new MeshBasicMaterial({ map: canvasMap, side: DoubleSide, transparent: true })\n    /**\n     * @member {Mesh} mesh The mesh ready to get used in the scene\n     */\n    this.mesh = new Mesh(this.geometry, material)\n    this.mesh.matrixAutoUpdate = false\n    /**\n     * @member {Boolean} geometryNeedsUpdate If set to true, updateGeometry will be triggered at the next repaint\n     */\n    this.geometryNeedsUpdate = true\n    this.repaint()\n\n    /**\n     * @member {Number} iLength Width of slice in the original coordinate system, corresponds to the width of the buffer canvas\n     */\n\n    /**\n     * @member {Number} jLength Height of slice in the original coordinate system, corresponds to the height of the buffer canvas\n     */\n\n    /**\n     * @member {Function} sliceAccess Function that allow the slice to access right data\n     * @see Volume.extractPerpendicularPlane\n     * @param {Number} i The first coordinate\n     * @param {Number} j The second coordinate\n     * @returns {Number} the index corresponding to the voxel in volume.data of the given position in the slice\n     */\n  }\n\n  /**\n   * @member {Function} repaint Refresh the texture and the geometry if geometryNeedsUpdate is set to true\n   * @memberof VolumeSlice\n   */\n  repaint() {\n    if (this.geometryNeedsUpdate) {\n      this.updateGeometry()\n    }\n\n    const iLength = this.iLength,\n      jLength = this.jLength,\n      sliceAccess = this.sliceAccess,\n      volume = this.volume,\n      canvas = this.canvasBuffer,\n      ctx = this.ctxBuffer\n\n    // get the imageData and pixel array from the canvas\n    const imgData = ctx.getImageData(0, 0, iLength, jLength)\n    const data = imgData.data\n    const volumeData = volume.data\n    const upperThreshold = volume.upperThreshold\n    const lowerThreshold = volume.lowerThreshold\n    const windowLow = volume.windowLow\n    const windowHigh = volume.windowHigh\n\n    // manipulate some pixel elements\n    let pixelCount = 0\n\n    if (volume.dataType === 'label') {\n      //this part is currently useless but will be used when colortables will be handled\n      for (let j = 0; j < jLength; j++) {\n        for (let i = 0; i < iLength; i++) {\n          let label = volumeData[sliceAccess(i, j)]\n          label = label >= this.colorMap.length ? (label % this.colorMap.length) + 1 : label\n          const color = this.colorMap[label]\n          data[4 * pixelCount] = (color >> 24) & 0xff\n          data[4 * pixelCount + 1] = (color >> 16) & 0xff\n          data[4 * pixelCount + 2] = (color >> 8) & 0xff\n          data[4 * pixelCount + 3] = color & 0xff\n          pixelCount++\n        }\n      }\n    } else {\n      for (let j = 0; j < jLength; j++) {\n        for (let i = 0; i < iLength; i++) {\n          let value = volumeData[sliceAccess(i, j)]\n          let alpha = 0xff\n          //apply threshold\n          alpha = upperThreshold >= value ? (lowerThreshold <= value ? alpha : 0) : 0\n          //apply window level\n          value = Math.floor((255 * (value - windowLow)) / (windowHigh - windowLow))\n          value = value > 255 ? 255 : value < 0 ? 0 : value | 0\n\n          data[4 * pixelCount] = value\n          data[4 * pixelCount + 1] = value\n          data[4 * pixelCount + 2] = value\n          data[4 * pixelCount + 3] = alpha\n          pixelCount++\n        }\n      }\n    }\n\n    ctx.putImageData(imgData, 0, 0)\n    this.ctx.drawImage(canvas, 0, 0, iLength, jLength, 0, 0, this.canvas.width, this.canvas.height)\n\n    this.mesh.material.map.needsUpdate = true\n  }\n\n  /**\n   * @member {Function} Refresh the geometry according to axis and index\n   * @see Volume.extractPerpendicularPlane\n   * @memberof VolumeSlice\n   */\n  updateGeometry() {\n    const extracted = this.volume.extractPerpendicularPlane(this.axis, this.index)\n    this.sliceAccess = extracted.sliceAccess\n    this.jLength = extracted.jLength\n    this.iLength = extracted.iLength\n    this.matrix = extracted.matrix\n\n    this.canvas.width = extracted.planeWidth\n    this.canvas.height = extracted.planeHeight\n    this.canvasBuffer.width = this.iLength\n    this.canvasBuffer.height = this.jLength\n    this.ctx = this.canvas.getContext('2d')\n    this.ctxBuffer = this.canvasBuffer.getContext('2d')\n\n    if (this.geometry) this.geometry.dispose() // dispose existing geometry\n\n    this.geometry = new PlaneGeometry(extracted.planeWidth, extracted.planeHeight)\n\n    if (this.mesh) {\n      this.mesh.geometry = this.geometry\n      //reset mesh matrix\n      this.mesh.matrix.identity()\n      this.mesh.applyMatrix4(this.matrix)\n    }\n\n    this.geometryNeedsUpdate = false\n  }\n}\n\nexport { VolumeSlice }\n"],"mappings":";;;IAUMA,WAAA;EACJ,SAAAA,YAAYC,MAAA,EAAQC,KAAA,EAAOC,IAAA,EAAM;IAAAC,eAAA,OAAAJ,WAAA;IAC/B,IAAMK,KAAA,GAAQ;IAId,KAAKJ,MAAA,GAASA,MAAA;IAIdC,KAAA,GAAQA,KAAA,IAAS;IACjBI,MAAA,CAAOC,cAAA,CAAe,MAAM,SAAS;MACnCC,GAAA,EAAK,SAAAA,IAAA,EAAY;QACf,OAAON,KAAA;MACR;MACDO,GAAA,EAAK,SAAAA,IAAUC,KAAA,EAAO;QACpBR,KAAA,GAAQQ,KAAA;QACRL,KAAA,CAAMM,mBAAA,GAAsB;QAC5B,OAAOT,KAAA;MACR;IACP,CAAK;IAID,KAAKC,IAAA,GAAOA,IAAA,IAAQ;IAQpB,KAAKS,MAAA,GAASC,QAAA,CAASC,aAAA,CAAc,QAAQ;IAO7C,KAAKC,YAAA,GAAeF,QAAA,CAASC,aAAA,CAAc,QAAQ;IACnD,KAAKE,cAAA,CAAgB;IAErB,IAAMC,SAAA,GAAY,IAAIC,OAAA,CAAQ,KAAKN,MAAM;IACzCK,SAAA,CAAUE,SAAA,GAAYC,YAAA;IACtBH,SAAA,CAAUI,KAAA,GAAQJ,SAAA,CAAUK,KAAA,GAAQC,mBAAA;IACpC,IAAI,gBAAgBN,SAAA,EAAWA,SAAA,CAAUO,UAAA,GAAa,YACjDP,SAAA,CAAUQ,QAAA,GAAW;IAC1B,IAAMC,QAAA,GAAW,IAAIC,iBAAA,CAAkB;MAAEC,GAAA,EAAKX,SAAA;MAAWY,IAAA,EAAMC,UAAA;MAAYC,WAAA,EAAa;IAAA,CAAM;IAI9F,KAAKC,IAAA,GAAO,IAAIC,IAAA,CAAK,KAAKC,QAAA,EAAUR,QAAQ;IAC5C,KAAKM,IAAA,CAAKG,gBAAA,GAAmB;IAI7B,KAAKxB,mBAAA,GAAsB;IAC3B,KAAKyB,OAAA,CAAS;EAiBf;EAAA;AAAA;AAAA;AAAA;EAAAC,YAAA,CAAArC,WAAA;IAAAsC,GAAA;IAAA5B,KAAA,EAMD,SAAA0B,QAAA,EAAU;MACR,IAAI,KAAKzB,mBAAA,EAAqB;QAC5B,KAAKK,cAAA,CAAgB;MACtB;MAED,IAAMuB,OAAA,GAAU,KAAKA,OAAA;QACnBC,OAAA,GAAU,KAAKA,OAAA;QACfC,WAAA,GAAc,KAAKA,WAAA;QACnBxC,MAAA,GAAS,KAAKA,MAAA;QACdW,MAAA,GAAS,KAAKG,YAAA;QACd2B,GAAA,GAAM,KAAKC,SAAA;MAGb,IAAMC,OAAA,GAAUF,GAAA,CAAIG,YAAA,CAAa,GAAG,GAAGN,OAAA,EAASC,OAAO;MACvD,IAAMM,IAAA,GAAOF,OAAA,CAAQE,IAAA;MACrB,IAAMC,UAAA,GAAa9C,MAAA,CAAO6C,IAAA;MAC1B,IAAME,cAAA,GAAiB/C,MAAA,CAAO+C,cAAA;MAC9B,IAAMC,cAAA,GAAiBhD,MAAA,CAAOgD,cAAA;MAC9B,IAAMC,SAAA,GAAYjD,MAAA,CAAOiD,SAAA;MACzB,IAAMC,UAAA,GAAalD,MAAA,CAAOkD,UAAA;MAG1B,IAAIC,UAAA,GAAa;MAEjB,IAAInD,MAAA,CAAOoD,QAAA,KAAa,SAAS;QAE/B,SAASC,CAAA,GAAI,GAAGA,CAAA,GAAId,OAAA,EAASc,CAAA,IAAK;UAChC,SAASC,CAAA,GAAI,GAAGA,CAAA,GAAIhB,OAAA,EAASgB,CAAA,IAAK;YAChC,IAAIC,KAAA,GAAQT,UAAA,CAAWN,WAAA,CAAYc,CAAA,EAAGD,CAAC,CAAC;YACxCE,KAAA,GAAQA,KAAA,IAAS,KAAKC,QAAA,CAASC,MAAA,GAAUF,KAAA,GAAQ,KAAKC,QAAA,CAASC,MAAA,GAAU,IAAIF,KAAA;YAC7E,IAAMG,KAAA,GAAQ,KAAKF,QAAA,CAASD,KAAK;YACjCV,IAAA,CAAK,IAAIM,UAAU,IAAKO,KAAA,IAAS,KAAM;YACvCb,IAAA,CAAK,IAAIM,UAAA,GAAa,CAAC,IAAKO,KAAA,IAAS,KAAM;YAC3Cb,IAAA,CAAK,IAAIM,UAAA,GAAa,CAAC,IAAKO,KAAA,IAAS,IAAK;YAC1Cb,IAAA,CAAK,IAAIM,UAAA,GAAa,CAAC,IAAIO,KAAA,GAAQ;YACnCP,UAAA;UACD;QACF;MACP,OAAW;QACL,SAASE,EAAA,GAAI,GAAGA,EAAA,GAAId,OAAA,EAASc,EAAA,IAAK;UAChC,SAASC,EAAA,GAAI,GAAGA,EAAA,GAAIhB,OAAA,EAASgB,EAAA,IAAK;YAChC,IAAI7C,KAAA,GAAQqC,UAAA,CAAWN,WAAA,CAAYc,EAAA,EAAGD,EAAC,CAAC;YACxC,IAAIM,KAAA,GAAQ;YAEZA,KAAA,GAAQZ,cAAA,IAAkBtC,KAAA,GAASuC,cAAA,IAAkBvC,KAAA,GAAQkD,KAAA,GAAQ,IAAK;YAE1ElD,KAAA,GAAQmD,IAAA,CAAKC,KAAA,CAAO,OAAOpD,KAAA,GAAQwC,SAAA,KAAeC,UAAA,GAAaD,SAAA,CAAU;YACzExC,KAAA,GAAQA,KAAA,GAAQ,MAAM,MAAMA,KAAA,GAAQ,IAAI,IAAIA,KAAA,GAAQ;YAEpDoC,IAAA,CAAK,IAAIM,UAAU,IAAI1C,KAAA;YACvBoC,IAAA,CAAK,IAAIM,UAAA,GAAa,CAAC,IAAI1C,KAAA;YAC3BoC,IAAA,CAAK,IAAIM,UAAA,GAAa,CAAC,IAAI1C,KAAA;YAC3BoC,IAAA,CAAK,IAAIM,UAAA,GAAa,CAAC,IAAIQ,KAAA;YAC3BR,UAAA;UACD;QACF;MACF;MAEDV,GAAA,CAAIqB,YAAA,CAAanB,OAAA,EAAS,GAAG,CAAC;MAC9B,KAAKF,GAAA,CAAIsB,SAAA,CAAUpD,MAAA,EAAQ,GAAG,GAAG2B,OAAA,EAASC,OAAA,EAAS,GAAG,GAAG,KAAK5B,MAAA,CAAOqD,KAAA,EAAO,KAAKrD,MAAA,CAAOsD,MAAM;MAE9F,KAAKlC,IAAA,CAAKN,QAAA,CAASE,GAAA,CAAIuC,WAAA,GAAc;IACtC;IAAA;AAAA;AAAA;AAAA;AAAA;EAAA;IAAA7B,GAAA;IAAA5B,KAAA,EAOD,SAAAM,eAAA,EAAiB;MACf,IAAMoD,SAAA,GAAY,KAAKnE,MAAA,CAAOoE,yBAAA,CAA0B,KAAKlE,IAAA,EAAM,KAAKD,KAAK;MAC7E,KAAKuC,WAAA,GAAc2B,SAAA,CAAU3B,WAAA;MAC7B,KAAKD,OAAA,GAAU4B,SAAA,CAAU5B,OAAA;MACzB,KAAKD,OAAA,GAAU6B,SAAA,CAAU7B,OAAA;MACzB,KAAK+B,MAAA,GAASF,SAAA,CAAUE,MAAA;MAExB,KAAK1D,MAAA,CAAOqD,KAAA,GAAQG,SAAA,CAAUG,UAAA;MAC9B,KAAK3D,MAAA,CAAOsD,MAAA,GAASE,SAAA,CAAUI,WAAA;MAC/B,KAAKzD,YAAA,CAAakD,KAAA,GAAQ,KAAK1B,OAAA;MAC/B,KAAKxB,YAAA,CAAamD,MAAA,GAAS,KAAK1B,OAAA;MAChC,KAAKE,GAAA,GAAM,KAAK9B,MAAA,CAAO6D,UAAA,CAAW,IAAI;MACtC,KAAK9B,SAAA,GAAY,KAAK5B,YAAA,CAAa0D,UAAA,CAAW,IAAI;MAElD,IAAI,KAAKvC,QAAA,EAAU,KAAKA,QAAA,CAASwC,OAAA,CAAS;MAE1C,KAAKxC,QAAA,GAAW,IAAIyC,aAAA,CAAcP,SAAA,CAAUG,UAAA,EAAYH,SAAA,CAAUI,WAAW;MAE7E,IAAI,KAAKxC,IAAA,EAAM;QACb,KAAKA,IAAA,CAAKE,QAAA,GAAW,KAAKA,QAAA;QAE1B,KAAKF,IAAA,CAAKsC,MAAA,CAAOM,QAAA,CAAU;QAC3B,KAAK5C,IAAA,CAAK6C,YAAA,CAAa,KAAKP,MAAM;MACnC;MAED,KAAK3D,mBAAA,GAAsB;IAC5B;EAAA;EAAA,OAAAX,WAAA;AAAA"},"metadata":{},"sourceType":"module","externalDependencies":[]}