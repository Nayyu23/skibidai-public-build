{"ast":null,"code":"import _classCallCheck from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _inherits from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport _defineProperty from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport { Vector4, Vector3, Matrix4, Line3, Box3, Sphere, Mesh, InstancedInterleavedBuffer, InterleavedBufferAttribute, MathUtils } from \"three\";\nimport { LineSegmentsGeometry } from \"./LineSegmentsGeometry.js\";\nimport { LineMaterial } from \"./LineMaterial.js\";\nimport { UV1 } from \"../_polyfill/uv1.js\";\nvar _viewport = new Vector4();\nvar _start = new Vector3();\nvar _end = new Vector3();\nvar _start4 = new Vector4();\nvar _end4 = new Vector4();\nvar _ssOrigin = new Vector4();\nvar _ssOrigin3 = new Vector3();\nvar _mvMatrix = new Matrix4();\nvar _line = new Line3();\nvar _closestPoint = new Vector3();\nvar _box = new Box3();\nvar _sphere = new Sphere();\nvar _clipToWorldVector = new Vector4();\nvar _ray, _lineWidth;\nfunction getWorldSpaceHalfWidth(camera, distance, resolution) {\n  _clipToWorldVector.set(0, 0, -distance, 1).applyMatrix4(camera.projectionMatrix);\n  _clipToWorldVector.multiplyScalar(1 / _clipToWorldVector.w);\n  _clipToWorldVector.x = _lineWidth / resolution.width;\n  _clipToWorldVector.y = _lineWidth / resolution.height;\n  _clipToWorldVector.applyMatrix4(camera.projectionMatrixInverse);\n  _clipToWorldVector.multiplyScalar(1 / _clipToWorldVector.w);\n  return Math.abs(Math.max(_clipToWorldVector.x, _clipToWorldVector.y));\n}\nfunction raycastWorldUnits(lineSegments, intersects) {\n  var matrixWorld = lineSegments.matrixWorld;\n  var geometry = lineSegments.geometry;\n  var instanceStart = geometry.attributes.instanceStart;\n  var instanceEnd = geometry.attributes.instanceEnd;\n  var segmentCount = Math.min(geometry.instanceCount, instanceStart.count);\n  for (var i = 0, l = segmentCount; i < l; i++) {\n    _line.start.fromBufferAttribute(instanceStart, i);\n    _line.end.fromBufferAttribute(instanceEnd, i);\n    _line.applyMatrix4(matrixWorld);\n    var pointOnLine = new Vector3();\n    var point = new Vector3();\n    _ray.distanceSqToSegment(_line.start, _line.end, point, pointOnLine);\n    var isInside = point.distanceTo(pointOnLine) < _lineWidth * 0.5;\n    if (isInside) {\n      intersects.push(_defineProperty({\n        point: point,\n        pointOnLine: pointOnLine,\n        distance: _ray.origin.distanceTo(point),\n        object: lineSegments,\n        face: null,\n        faceIndex: i,\n        uv: null\n      }, UV1, null));\n    }\n  }\n}\nfunction raycastScreenSpace(lineSegments, camera, intersects) {\n  var projectionMatrix = camera.projectionMatrix;\n  var material = lineSegments.material;\n  var resolution = material.resolution;\n  var matrixWorld = lineSegments.matrixWorld;\n  var geometry = lineSegments.geometry;\n  var instanceStart = geometry.attributes.instanceStart;\n  var instanceEnd = geometry.attributes.instanceEnd;\n  var segmentCount = Math.min(geometry.instanceCount, instanceStart.count);\n  var near = -camera.near;\n  _ray.at(1, _ssOrigin);\n  _ssOrigin.w = 1;\n  _ssOrigin.applyMatrix4(camera.matrixWorldInverse);\n  _ssOrigin.applyMatrix4(projectionMatrix);\n  _ssOrigin.multiplyScalar(1 / _ssOrigin.w);\n  _ssOrigin.x *= resolution.x / 2;\n  _ssOrigin.y *= resolution.y / 2;\n  _ssOrigin.z = 0;\n  _ssOrigin3.copy(_ssOrigin);\n  _mvMatrix.multiplyMatrices(camera.matrixWorldInverse, matrixWorld);\n  for (var i = 0, l = segmentCount; i < l; i++) {\n    _start4.fromBufferAttribute(instanceStart, i);\n    _end4.fromBufferAttribute(instanceEnd, i);\n    _start4.w = 1;\n    _end4.w = 1;\n    _start4.applyMatrix4(_mvMatrix);\n    _end4.applyMatrix4(_mvMatrix);\n    var isBehindCameraNear = _start4.z > near && _end4.z > near;\n    if (isBehindCameraNear) {\n      continue;\n    }\n    if (_start4.z > near) {\n      var deltaDist = _start4.z - _end4.z;\n      var t = (_start4.z - near) / deltaDist;\n      _start4.lerp(_end4, t);\n    } else if (_end4.z > near) {\n      var _deltaDist = _end4.z - _start4.z;\n      var _t = (_end4.z - near) / _deltaDist;\n      _end4.lerp(_start4, _t);\n    }\n    _start4.applyMatrix4(projectionMatrix);\n    _end4.applyMatrix4(projectionMatrix);\n    _start4.multiplyScalar(1 / _start4.w);\n    _end4.multiplyScalar(1 / _end4.w);\n    _start4.x *= resolution.x / 2;\n    _start4.y *= resolution.y / 2;\n    _end4.x *= resolution.x / 2;\n    _end4.y *= resolution.y / 2;\n    _line.start.copy(_start4);\n    _line.start.z = 0;\n    _line.end.copy(_end4);\n    _line.end.z = 0;\n    var param = _line.closestPointToPointParameter(_ssOrigin3, true);\n    _line.at(param, _closestPoint);\n    var zPos = MathUtils.lerp(_start4.z, _end4.z, param);\n    var isInClipSpace = zPos >= -1 && zPos <= 1;\n    var isInside = _ssOrigin3.distanceTo(_closestPoint) < _lineWidth * 0.5;\n    if (isInClipSpace && isInside) {\n      _line.start.fromBufferAttribute(instanceStart, i);\n      _line.end.fromBufferAttribute(instanceEnd, i);\n      _line.start.applyMatrix4(matrixWorld);\n      _line.end.applyMatrix4(matrixWorld);\n      var pointOnLine = new Vector3();\n      var point = new Vector3();\n      _ray.distanceSqToSegment(_line.start, _line.end, point, pointOnLine);\n      intersects.push(_defineProperty({\n        point: point,\n        pointOnLine: pointOnLine,\n        distance: _ray.origin.distanceTo(point),\n        object: lineSegments,\n        face: null,\n        faceIndex: i,\n        uv: null\n      }, UV1, null));\n    }\n  }\n}\nvar LineSegments2 = /*#__PURE__*/function (_Mesh) {\n  _inherits(LineSegments2, _Mesh);\n  var _super = _createSuper(LineSegments2);\n  function LineSegments2() {\n    var _this;\n    var geometry = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new LineSegmentsGeometry();\n    var material = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new LineMaterial({\n      color: Math.random() * 16777215\n    });\n    _classCallCheck(this, LineSegments2);\n    _this = _super.call(this, geometry, material);\n    _this.isLineSegments2 = true;\n    _this.type = \"LineSegments2\";\n    return _this;\n  }\n  // for backwards-compatibility, but could be a method of LineSegmentsGeometry...\n  _createClass(LineSegments2, [{\n    key: \"computeLineDistances\",\n    value: function computeLineDistances() {\n      var geometry = this.geometry;\n      var instanceStart = geometry.attributes.instanceStart;\n      var instanceEnd = geometry.attributes.instanceEnd;\n      var lineDistances = new Float32Array(2 * instanceStart.count);\n      for (var i = 0, j = 0, l = instanceStart.count; i < l; i++, j += 2) {\n        _start.fromBufferAttribute(instanceStart, i);\n        _end.fromBufferAttribute(instanceEnd, i);\n        lineDistances[j] = j === 0 ? 0 : lineDistances[j - 1];\n        lineDistances[j + 1] = lineDistances[j] + _start.distanceTo(_end);\n      }\n      var instanceDistanceBuffer = new InstancedInterleavedBuffer(lineDistances, 2, 1);\n      geometry.setAttribute(\"instanceDistanceStart\", new InterleavedBufferAttribute(instanceDistanceBuffer, 1, 0));\n      geometry.setAttribute(\"instanceDistanceEnd\", new InterleavedBufferAttribute(instanceDistanceBuffer, 1, 1));\n      return this;\n    }\n  }, {\n    key: \"raycast\",\n    value: function raycast(raycaster, intersects) {\n      var worldUnits = this.material.worldUnits;\n      var camera = raycaster.camera;\n      if (camera === null && !worldUnits) {\n        console.error('LineSegments2: \"Raycaster.camera\" needs to be set in order to raycast against LineSegments2 while worldUnits is set to false.');\n      }\n      var threshold = raycaster.params.Line2 !== void 0 ? raycaster.params.Line2.threshold || 0 : 0;\n      _ray = raycaster.ray;\n      var matrixWorld = this.matrixWorld;\n      var geometry = this.geometry;\n      var material = this.material;\n      _lineWidth = material.linewidth + threshold;\n      if (geometry.boundingSphere === null) {\n        geometry.computeBoundingSphere();\n      }\n      _sphere.copy(geometry.boundingSphere).applyMatrix4(matrixWorld);\n      var sphereMargin;\n      if (worldUnits) {\n        sphereMargin = _lineWidth * 0.5;\n      } else {\n        var distanceToSphere = Math.max(camera.near, _sphere.distanceToPoint(_ray.origin));\n        sphereMargin = getWorldSpaceHalfWidth(camera, distanceToSphere, material.resolution);\n      }\n      _sphere.radius += sphereMargin;\n      if (_ray.intersectsSphere(_sphere) === false) {\n        return;\n      }\n      if (geometry.boundingBox === null) {\n        geometry.computeBoundingBox();\n      }\n      _box.copy(geometry.boundingBox).applyMatrix4(matrixWorld);\n      var boxMargin;\n      if (worldUnits) {\n        boxMargin = _lineWidth * 0.5;\n      } else {\n        var distanceToBox = Math.max(camera.near, _box.distanceToPoint(_ray.origin));\n        boxMargin = getWorldSpaceHalfWidth(camera, distanceToBox, material.resolution);\n      }\n      _box.expandByScalar(boxMargin);\n      if (_ray.intersectsBox(_box) === false) {\n        return;\n      }\n      if (worldUnits) {\n        raycastWorldUnits(this, intersects);\n      } else {\n        raycastScreenSpace(this, camera, intersects);\n      }\n    }\n  }, {\n    key: \"onBeforeRender\",\n    value: function onBeforeRender(renderer) {\n      var uniforms = this.material.uniforms;\n      if (uniforms && uniforms.resolution) {\n        renderer.getViewport(_viewport);\n        this.material.uniforms.resolution.value.set(_viewport.z, _viewport.w);\n      }\n    }\n  }]);\n  return LineSegments2;\n}(Mesh);\nexport { LineSegments2 };","map":{"version":3,"names":["_viewport","Vector4","_start","Vector3","_end","_start4","_end4","_ssOrigin","_ssOrigin3","_mvMatrix","Matrix4","_line","Line3","_closestPoint","_box","Box3","_sphere","Sphere","_clipToWorldVector","_ray","_lineWidth","getWorldSpaceHalfWidth","camera","distance","resolution","set","applyMatrix4","projectionMatrix","multiplyScalar","w","x","width","y","height","projectionMatrixInverse","Math","abs","max","raycastWorldUnits","lineSegments","intersects","matrixWorld","geometry","instanceStart","attributes","instanceEnd","segmentCount","min","instanceCount","count","i","l","start","fromBufferAttribute","end","pointOnLine","point","distanceSqToSegment","isInside","distanceTo","push","_defineProperty","origin","object","face","faceIndex","uv","UV1","raycastScreenSpace","material","near","at","matrixWorldInverse","z","copy","multiplyMatrices","isBehindCameraNear","deltaDist","t","lerp","param","closestPointToPointParameter","zPos","MathUtils","isInClipSpace","LineSegments2","_Mesh","_inherits","_super","_createSuper","_this","arguments","length","undefined","LineSegmentsGeometry","LineMaterial","color","random","_classCallCheck","call","isLineSegments2","type","_createClass","key","value","computeLineDistances","lineDistances","Float32Array","j","instanceDistanceBuffer","InstancedInterleavedBuffer","setAttribute","InterleavedBufferAttribute","raycast","raycaster","worldUnits","console","error","threshold","params","Line2","ray","linewidth","boundingSphere","computeBoundingSphere","sphereMargin","distanceToSphere","distanceToPoint","radius","intersectsSphere","boundingBox","computeBoundingBox","boxMargin","distanceToBox","expandByScalar","intersectsBox","onBeforeRender","renderer","uniforms","getViewport","Mesh"],"sources":["C:\\Users\\Nayyu\\Desktop\\skibidai-public-build\\node_modules\\src\\lines\\LineSegments2.js"],"sourcesContent":["import {\n  Box3,\n  InstancedInterleavedBuffer,\n  InterleavedBufferAttribute,\n  Line3,\n  MathUtils,\n  Matrix4,\n  Mesh,\n  Sphere,\n  Vector3,\n  Vector4,\n} from 'three'\nimport { LineSegmentsGeometry } from '../lines/LineSegmentsGeometry'\nimport { LineMaterial } from '../lines/LineMaterial'\nimport { UV1 } from '../_polyfill/uv1'\n\nconst _viewport = new Vector4();\n\nconst _start = new Vector3()\nconst _end = new Vector3()\n\nconst _start4 = new Vector4()\nconst _end4 = new Vector4()\n\nconst _ssOrigin = new Vector4()\nconst _ssOrigin3 = new Vector3()\nconst _mvMatrix = new Matrix4()\nconst _line = new Line3()\nconst _closestPoint = new Vector3()\n\nconst _box = new Box3()\nconst _sphere = new Sphere()\nconst _clipToWorldVector = new Vector4()\n\nlet _ray, _lineWidth\n\n// Returns the margin required to expand by in world space given the distance from the camera,\n// line width, resolution, and camera projection\nfunction getWorldSpaceHalfWidth(camera, distance, resolution) {\n  // transform into clip space, adjust the x and y values by the pixel width offset, then\n  // transform back into world space to get world offset. Note clip space is [-1, 1] so full\n  // width does not need to be halved.\n  _clipToWorldVector.set(0, 0, -distance, 1.0).applyMatrix4(camera.projectionMatrix)\n  _clipToWorldVector.multiplyScalar(1.0 / _clipToWorldVector.w)\n  _clipToWorldVector.x = _lineWidth / resolution.width\n  _clipToWorldVector.y = _lineWidth / resolution.height\n  _clipToWorldVector.applyMatrix4(camera.projectionMatrixInverse)\n  _clipToWorldVector.multiplyScalar(1.0 / _clipToWorldVector.w)\n\n  return Math.abs(Math.max(_clipToWorldVector.x, _clipToWorldVector.y))\n}\n\nfunction raycastWorldUnits(lineSegments, intersects) {\n\n  const matrixWorld = lineSegments.matrixWorld;\n  const geometry = lineSegments.geometry;\n  const instanceStart = geometry.attributes.instanceStart;\n  const instanceEnd = geometry.attributes.instanceEnd;\n  const segmentCount = Math.min(geometry.instanceCount, instanceStart.count);\n\n  for (let i = 0, l = segmentCount; i < l; i++) {\n    _line.start.fromBufferAttribute(instanceStart, i)\n    _line.end.fromBufferAttribute(instanceEnd, i)\n\n    _line.applyMatrix4(matrixWorld);\n\n    const pointOnLine = new Vector3()\n    const point = new Vector3()\n\n    _ray.distanceSqToSegment(_line.start, _line.end, point, pointOnLine)\n    const isInside = point.distanceTo(pointOnLine) < _lineWidth * 0.5\n\n    if (isInside) {\n      intersects.push({\n        point,\n        pointOnLine,\n        distance: _ray.origin.distanceTo(point),\n        object: lineSegments,\n        face: null,\n        faceIndex: i,\n        uv: null,\n        [UV1]: null,\n      })\n    }\n  }\n}\n\nfunction raycastScreenSpace(lineSegments, camera, intersects) {\n  const projectionMatrix = camera.projectionMatrix\n  const material = lineSegments.material\n  const resolution = material.resolution\n  const matrixWorld = lineSegments.matrixWorld\n\n  const geometry = lineSegments.geometry\n  const instanceStart = geometry.attributes.instanceStart\n  const instanceEnd = geometry.attributes.instanceEnd\n  const segmentCount = Math.min(geometry.instanceCount, instanceStart.count);\n\n  const near = -camera.near\n\n  //\n\n  // pick a point 1 unit out along the ray to avoid the ray origin\n  // sitting at the camera origin which will cause \"w\" to be 0 when\n  // applying the projection matrix.\n  _ray.at(1, _ssOrigin)\n\n  // ndc space [ - 1.0, 1.0 ]\n  _ssOrigin.w = 1\n  _ssOrigin.applyMatrix4(camera.matrixWorldInverse)\n  _ssOrigin.applyMatrix4(projectionMatrix)\n  _ssOrigin.multiplyScalar(1 / _ssOrigin.w)\n\n  // screen space\n  _ssOrigin.x *= resolution.x / 2\n  _ssOrigin.y *= resolution.y / 2\n  _ssOrigin.z = 0\n\n  _ssOrigin3.copy(_ssOrigin)\n\n  _mvMatrix.multiplyMatrices(camera.matrixWorldInverse, matrixWorld)\n\n  for (let i = 0, l = segmentCount; i < l; i++) {\n    _start4.fromBufferAttribute(instanceStart, i)\n    _end4.fromBufferAttribute(instanceEnd, i)\n\n    _start4.w = 1\n    _end4.w = 1\n\n    // camera space\n    _start4.applyMatrix4(_mvMatrix)\n    _end4.applyMatrix4(_mvMatrix)\n\n    // skip the segment if it's entirely behind the camera\n    const isBehindCameraNear = _start4.z > near && _end4.z > near\n    if (isBehindCameraNear) {\n      continue\n    }\n\n    // trim the segment if it extends behind camera near\n    if (_start4.z > near) {\n      const deltaDist = _start4.z - _end4.z\n      const t = (_start4.z - near) / deltaDist\n      _start4.lerp(_end4, t)\n    } else if (_end4.z > near) {\n      const deltaDist = _end4.z - _start4.z\n      const t = (_end4.z - near) / deltaDist\n      _end4.lerp(_start4, t)\n    }\n\n    // clip space\n    _start4.applyMatrix4(projectionMatrix)\n    _end4.applyMatrix4(projectionMatrix)\n\n    // ndc space [ - 1.0, 1.0 ]\n    _start4.multiplyScalar(1 / _start4.w)\n    _end4.multiplyScalar(1 / _end4.w)\n\n    // screen space\n    _start4.x *= resolution.x / 2\n    _start4.y *= resolution.y / 2\n\n    _end4.x *= resolution.x / 2\n    _end4.y *= resolution.y / 2\n\n    // create 2d segment\n    _line.start.copy(_start4)\n    _line.start.z = 0\n\n    _line.end.copy(_end4)\n    _line.end.z = 0\n\n    // get closest point on ray to segment\n    const param = _line.closestPointToPointParameter(_ssOrigin3, true)\n    _line.at(param, _closestPoint)\n\n    // check if the intersection point is within clip space\n    const zPos = MathUtils.lerp(_start4.z, _end4.z, param)\n    const isInClipSpace = zPos >= -1 && zPos <= 1\n\n    const isInside = _ssOrigin3.distanceTo(_closestPoint) < _lineWidth * 0.5\n\n    if (isInClipSpace && isInside) {\n      _line.start.fromBufferAttribute(instanceStart, i)\n      _line.end.fromBufferAttribute(instanceEnd, i)\n\n      _line.start.applyMatrix4(matrixWorld)\n      _line.end.applyMatrix4(matrixWorld)\n\n      const pointOnLine = new Vector3()\n      const point = new Vector3()\n\n      _ray.distanceSqToSegment(_line.start, _line.end, point, pointOnLine)\n\n      intersects.push({\n        point: point,\n        pointOnLine: pointOnLine,\n        distance: _ray.origin.distanceTo(point),\n        object: lineSegments,\n        face: null,\n        faceIndex: i,\n        uv: null,\n        [UV1]: null,\n      })\n    }\n  }\n}\n\nclass LineSegments2 extends Mesh {\n  constructor(geometry = new LineSegmentsGeometry(), material = new LineMaterial({ color: Math.random() * 0xffffff })) {\n    super(geometry, material)\n\n    this.isLineSegments2 = true\n\n    this.type = 'LineSegments2'\n  }\n\n  // for backwards-compatibility, but could be a method of LineSegmentsGeometry...\n\n  computeLineDistances() {\n    const geometry = this.geometry\n\n    const instanceStart = geometry.attributes.instanceStart\n    const instanceEnd = geometry.attributes.instanceEnd\n    const lineDistances = new Float32Array(2 * instanceStart.count)\n\n    for (let i = 0, j = 0, l = instanceStart.count; i < l; i++, j += 2) {\n      _start.fromBufferAttribute(instanceStart, i)\n      _end.fromBufferAttribute(instanceEnd, i)\n\n      lineDistances[j] = j === 0 ? 0 : lineDistances[j - 1]\n      lineDistances[j + 1] = lineDistances[j] + _start.distanceTo(_end)\n    }\n\n    const instanceDistanceBuffer = new InstancedInterleavedBuffer(lineDistances, 2, 1) // d0, d1\n\n    geometry.setAttribute('instanceDistanceStart', new InterleavedBufferAttribute(instanceDistanceBuffer, 1, 0)) // d0\n    geometry.setAttribute('instanceDistanceEnd', new InterleavedBufferAttribute(instanceDistanceBuffer, 1, 1)) // d1\n\n    return this\n  }\n\n  raycast(raycaster, intersects) {\n    const worldUnits = this.material.worldUnits\n    const camera = raycaster.camera\n\n    if (camera === null && !worldUnits) {\n      console.error(\n        'LineSegments2: \"Raycaster.camera\" needs to be set in order to raycast against LineSegments2 while worldUnits is set to false.',\n      )\n    }\n\n    const threshold = raycaster.params.Line2 !== undefined ? raycaster.params.Line2.threshold || 0 : 0\n\n    _ray = raycaster.ray\n\n    const matrixWorld = this.matrixWorld\n    const geometry = this.geometry\n    const material = this.material\n\n    _lineWidth = material.linewidth + threshold\n\n    // check if we intersect the sphere bounds\n    if (geometry.boundingSphere === null) {\n      geometry.computeBoundingSphere()\n    }\n\n    _sphere.copy(geometry.boundingSphere).applyMatrix4(matrixWorld)\n\n    // increase the sphere bounds by the worst case line screen space width\n    let sphereMargin\n    if (worldUnits) {\n      sphereMargin = _lineWidth * 0.5\n    } else {\n      const distanceToSphere = Math.max(camera.near, _sphere.distanceToPoint(_ray.origin))\n      sphereMargin = getWorldSpaceHalfWidth(camera, distanceToSphere, material.resolution)\n    }\n\n    _sphere.radius += sphereMargin\n\n    if (_ray.intersectsSphere(_sphere) === false) {\n      return\n    }\n\n    // check if we intersect the box bounds\n    if (geometry.boundingBox === null) {\n      geometry.computeBoundingBox()\n    }\n\n    _box.copy(geometry.boundingBox).applyMatrix4(matrixWorld)\n\n    // increase the box bounds by the worst case line width\n    let boxMargin\n    if (worldUnits) {\n      boxMargin = _lineWidth * 0.5\n    } else {\n      const distanceToBox = Math.max(camera.near, _box.distanceToPoint(_ray.origin))\n      boxMargin = getWorldSpaceHalfWidth(camera, distanceToBox, material.resolution)\n    }\n\n    _box.expandByScalar(boxMargin)\n\n    if (_ray.intersectsBox(_box) === false) {\n      return\n    }\n\n    if (worldUnits) {\n      raycastWorldUnits(this, intersects)\n    } else {\n      raycastScreenSpace(this, camera, intersects)\n    }\n  }\n\n  onBeforeRender(renderer) {\n\n    const uniforms = this.material.uniforms;\n\n    if (uniforms && uniforms.resolution) {\n\n      renderer.getViewport(_viewport);\n      this.material.uniforms.resolution.value.set(_viewport.z, _viewport.w);\n\n    }\n\n  }\n}\n\nexport { LineSegments2 }\n"],"mappings":";;;;;;;;;AAgBA,IAAMA,SAAA,GAAY,IAAIC,OAAA;AAEtB,IAAMC,MAAA,GAAS,IAAIC,OAAA,CAAS;AAC5B,IAAMC,IAAA,GAAO,IAAID,OAAA,CAAS;AAE1B,IAAME,OAAA,GAAU,IAAIJ,OAAA,CAAS;AAC7B,IAAMK,KAAA,GAAQ,IAAIL,OAAA,CAAS;AAE3B,IAAMM,SAAA,GAAY,IAAIN,OAAA,CAAS;AAC/B,IAAMO,UAAA,GAAa,IAAIL,OAAA,CAAS;AAChC,IAAMM,SAAA,GAAY,IAAIC,OAAA,CAAS;AAC/B,IAAMC,KAAA,GAAQ,IAAIC,KAAA,CAAO;AACzB,IAAMC,aAAA,GAAgB,IAAIV,OAAA,CAAS;AAEnC,IAAMW,IAAA,GAAO,IAAIC,IAAA,CAAM;AACvB,IAAMC,OAAA,GAAU,IAAIC,MAAA,CAAQ;AAC5B,IAAMC,kBAAA,GAAqB,IAAIjB,OAAA,CAAS;AAExC,IAAIkB,IAAA,EAAMC,UAAA;AAIV,SAASC,uBAAuBC,MAAA,EAAQC,QAAA,EAAUC,UAAA,EAAY;EAI5DN,kBAAA,CAAmBO,GAAA,CAAI,GAAG,GAAG,CAACF,QAAA,EAAU,CAAG,EAAEG,YAAA,CAAaJ,MAAA,CAAOK,gBAAgB;EACjFT,kBAAA,CAAmBU,cAAA,CAAe,IAAMV,kBAAA,CAAmBW,CAAC;EAC5DX,kBAAA,CAAmBY,CAAA,GAAIV,UAAA,GAAaI,UAAA,CAAWO,KAAA;EAC/Cb,kBAAA,CAAmBc,CAAA,GAAIZ,UAAA,GAAaI,UAAA,CAAWS,MAAA;EAC/Cf,kBAAA,CAAmBQ,YAAA,CAAaJ,MAAA,CAAOY,uBAAuB;EAC9DhB,kBAAA,CAAmBU,cAAA,CAAe,IAAMV,kBAAA,CAAmBW,CAAC;EAE5D,OAAOM,IAAA,CAAKC,GAAA,CAAID,IAAA,CAAKE,GAAA,CAAInB,kBAAA,CAAmBY,CAAA,EAAGZ,kBAAA,CAAmBc,CAAC,CAAC;AACtE;AAEA,SAASM,kBAAkBC,YAAA,EAAcC,UAAA,EAAY;EAEnD,IAAMC,WAAA,GAAcF,YAAA,CAAaE,WAAA;EACjC,IAAMC,QAAA,GAAWH,YAAA,CAAaG,QAAA;EAC9B,IAAMC,aAAA,GAAgBD,QAAA,CAASE,UAAA,CAAWD,aAAA;EAC1C,IAAME,WAAA,GAAcH,QAAA,CAASE,UAAA,CAAWC,WAAA;EACxC,IAAMC,YAAA,GAAeX,IAAA,CAAKY,GAAA,CAAIL,QAAA,CAASM,aAAA,EAAeL,aAAA,CAAcM,KAAK;EAEzE,SAASC,CAAA,GAAI,GAAGC,CAAA,GAAIL,YAAA,EAAcI,CAAA,GAAIC,CAAA,EAAGD,CAAA,IAAK;IAC5CvC,KAAA,CAAMyC,KAAA,CAAMC,mBAAA,CAAoBV,aAAA,EAAeO,CAAC;IAChDvC,KAAA,CAAM2C,GAAA,CAAID,mBAAA,CAAoBR,WAAA,EAAaK,CAAC;IAE5CvC,KAAA,CAAMe,YAAA,CAAae,WAAW;IAE9B,IAAMc,WAAA,GAAc,IAAIpD,OAAA,CAAS;IACjC,IAAMqD,KAAA,GAAQ,IAAIrD,OAAA,CAAS;IAE3BgB,IAAA,CAAKsC,mBAAA,CAAoB9C,KAAA,CAAMyC,KAAA,EAAOzC,KAAA,CAAM2C,GAAA,EAAKE,KAAA,EAAOD,WAAW;IACnE,IAAMG,QAAA,GAAWF,KAAA,CAAMG,UAAA,CAAWJ,WAAW,IAAInC,UAAA,GAAa;IAE9D,IAAIsC,QAAA,EAAU;MACZlB,UAAA,CAAWoB,IAAA,CAAAC,eAAA;QACTL,KAAA,EAAAA,KAAA;QACAD,WAAA,EAAAA,WAAA;QACAhC,QAAA,EAAUJ,IAAA,CAAK2C,MAAA,CAAOH,UAAA,CAAWH,KAAK;QACtCO,MAAA,EAAQxB,YAAA;QACRyB,IAAA,EAAM;QACNC,SAAA,EAAWf,CAAA;QACXgB,EAAA,EAAI;MAAA,GACHC,GAAG,EAAG,KACR;IACF;EACF;AACH;AAEA,SAASC,mBAAmB7B,YAAA,EAAcjB,MAAA,EAAQkB,UAAA,EAAY;EAC5D,IAAMb,gBAAA,GAAmBL,MAAA,CAAOK,gBAAA;EAChC,IAAM0C,QAAA,GAAW9B,YAAA,CAAa8B,QAAA;EAC9B,IAAM7C,UAAA,GAAa6C,QAAA,CAAS7C,UAAA;EAC5B,IAAMiB,WAAA,GAAcF,YAAA,CAAaE,WAAA;EAEjC,IAAMC,QAAA,GAAWH,YAAA,CAAaG,QAAA;EAC9B,IAAMC,aAAA,GAAgBD,QAAA,CAASE,UAAA,CAAWD,aAAA;EAC1C,IAAME,WAAA,GAAcH,QAAA,CAASE,UAAA,CAAWC,WAAA;EACxC,IAAMC,YAAA,GAAeX,IAAA,CAAKY,GAAA,CAAIL,QAAA,CAASM,aAAA,EAAeL,aAAA,CAAcM,KAAK;EAEzE,IAAMqB,IAAA,GAAO,CAAChD,MAAA,CAAOgD,IAAA;EAOrBnD,IAAA,CAAKoD,EAAA,CAAG,GAAGhE,SAAS;EAGpBA,SAAA,CAAUsB,CAAA,GAAI;EACdtB,SAAA,CAAUmB,YAAA,CAAaJ,MAAA,CAAOkD,kBAAkB;EAChDjE,SAAA,CAAUmB,YAAA,CAAaC,gBAAgB;EACvCpB,SAAA,CAAUqB,cAAA,CAAe,IAAIrB,SAAA,CAAUsB,CAAC;EAGxCtB,SAAA,CAAUuB,CAAA,IAAKN,UAAA,CAAWM,CAAA,GAAI;EAC9BvB,SAAA,CAAUyB,CAAA,IAAKR,UAAA,CAAWQ,CAAA,GAAI;EAC9BzB,SAAA,CAAUkE,CAAA,GAAI;EAEdjE,UAAA,CAAWkE,IAAA,CAAKnE,SAAS;EAEzBE,SAAA,CAAUkE,gBAAA,CAAiBrD,MAAA,CAAOkD,kBAAA,EAAoB/B,WAAW;EAEjE,SAASS,CAAA,GAAI,GAAGC,CAAA,GAAIL,YAAA,EAAcI,CAAA,GAAIC,CAAA,EAAGD,CAAA,IAAK;IAC5C7C,OAAA,CAAQgD,mBAAA,CAAoBV,aAAA,EAAeO,CAAC;IAC5C5C,KAAA,CAAM+C,mBAAA,CAAoBR,WAAA,EAAaK,CAAC;IAExC7C,OAAA,CAAQwB,CAAA,GAAI;IACZvB,KAAA,CAAMuB,CAAA,GAAI;IAGVxB,OAAA,CAAQqB,YAAA,CAAajB,SAAS;IAC9BH,KAAA,CAAMoB,YAAA,CAAajB,SAAS;IAG5B,IAAMmE,kBAAA,GAAqBvE,OAAA,CAAQoE,CAAA,GAAIH,IAAA,IAAQhE,KAAA,CAAMmE,CAAA,GAAIH,IAAA;IACzD,IAAIM,kBAAA,EAAoB;MACtB;IACD;IAGD,IAAIvE,OAAA,CAAQoE,CAAA,GAAIH,IAAA,EAAM;MACpB,IAAMO,SAAA,GAAYxE,OAAA,CAAQoE,CAAA,GAAInE,KAAA,CAAMmE,CAAA;MACpC,IAAMK,CAAA,IAAKzE,OAAA,CAAQoE,CAAA,GAAIH,IAAA,IAAQO,SAAA;MAC/BxE,OAAA,CAAQ0E,IAAA,CAAKzE,KAAA,EAAOwE,CAAC;IAC3B,WAAexE,KAAA,CAAMmE,CAAA,GAAIH,IAAA,EAAM;MACzB,IAAMO,UAAA,GAAYvE,KAAA,CAAMmE,CAAA,GAAIpE,OAAA,CAAQoE,CAAA;MACpC,IAAMK,EAAA,IAAKxE,KAAA,CAAMmE,CAAA,GAAIH,IAAA,IAAQO,UAAA;MAC7BvE,KAAA,CAAMyE,IAAA,CAAK1E,OAAA,EAASyE,EAAC;IACtB;IAGDzE,OAAA,CAAQqB,YAAA,CAAaC,gBAAgB;IACrCrB,KAAA,CAAMoB,YAAA,CAAaC,gBAAgB;IAGnCtB,OAAA,CAAQuB,cAAA,CAAe,IAAIvB,OAAA,CAAQwB,CAAC;IACpCvB,KAAA,CAAMsB,cAAA,CAAe,IAAItB,KAAA,CAAMuB,CAAC;IAGhCxB,OAAA,CAAQyB,CAAA,IAAKN,UAAA,CAAWM,CAAA,GAAI;IAC5BzB,OAAA,CAAQ2B,CAAA,IAAKR,UAAA,CAAWQ,CAAA,GAAI;IAE5B1B,KAAA,CAAMwB,CAAA,IAAKN,UAAA,CAAWM,CAAA,GAAI;IAC1BxB,KAAA,CAAM0B,CAAA,IAAKR,UAAA,CAAWQ,CAAA,GAAI;IAG1BrB,KAAA,CAAMyC,KAAA,CAAMsB,IAAA,CAAKrE,OAAO;IACxBM,KAAA,CAAMyC,KAAA,CAAMqB,CAAA,GAAI;IAEhB9D,KAAA,CAAM2C,GAAA,CAAIoB,IAAA,CAAKpE,KAAK;IACpBK,KAAA,CAAM2C,GAAA,CAAImB,CAAA,GAAI;IAGd,IAAMO,KAAA,GAAQrE,KAAA,CAAMsE,4BAAA,CAA6BzE,UAAA,EAAY,IAAI;IACjEG,KAAA,CAAM4D,EAAA,CAAGS,KAAA,EAAOnE,aAAa;IAG7B,IAAMqE,IAAA,GAAOC,SAAA,CAAUJ,IAAA,CAAK1E,OAAA,CAAQoE,CAAA,EAAGnE,KAAA,CAAMmE,CAAA,EAAGO,KAAK;IACrD,IAAMI,aAAA,GAAgBF,IAAA,IAAQ,MAAMA,IAAA,IAAQ;IAE5C,IAAMxB,QAAA,GAAWlD,UAAA,CAAWmD,UAAA,CAAW9C,aAAa,IAAIO,UAAA,GAAa;IAErE,IAAIgE,aAAA,IAAiB1B,QAAA,EAAU;MAC7B/C,KAAA,CAAMyC,KAAA,CAAMC,mBAAA,CAAoBV,aAAA,EAAeO,CAAC;MAChDvC,KAAA,CAAM2C,GAAA,CAAID,mBAAA,CAAoBR,WAAA,EAAaK,CAAC;MAE5CvC,KAAA,CAAMyC,KAAA,CAAM1B,YAAA,CAAae,WAAW;MACpC9B,KAAA,CAAM2C,GAAA,CAAI5B,YAAA,CAAae,WAAW;MAElC,IAAMc,WAAA,GAAc,IAAIpD,OAAA,CAAS;MACjC,IAAMqD,KAAA,GAAQ,IAAIrD,OAAA,CAAS;MAE3BgB,IAAA,CAAKsC,mBAAA,CAAoB9C,KAAA,CAAMyC,KAAA,EAAOzC,KAAA,CAAM2C,GAAA,EAAKE,KAAA,EAAOD,WAAW;MAEnEf,UAAA,CAAWoB,IAAA,CAAAC,eAAA;QACTL,KAAA,EAAAA,KAAA;QACAD,WAAA,EAAAA,WAAA;QACAhC,QAAA,EAAUJ,IAAA,CAAK2C,MAAA,CAAOH,UAAA,CAAWH,KAAK;QACtCO,MAAA,EAAQxB,YAAA;QACRyB,IAAA,EAAM;QACNC,SAAA,EAAWf,CAAA;QACXgB,EAAA,EAAI;MAAA,GACHC,GAAG,EAAG,KACR;IACF;EACF;AACH;AAAA,IAEMkB,aAAA,0BAAAC,KAAA;EAAAC,SAAA,CAAAF,aAAA,EAAAC,KAAA;EAAA,IAAAE,MAAA,GAAAC,YAAA,CAAAJ,aAAA;EACJ,SAAAA,cAAA,EAAqH;IAAA,IAAAK,KAAA;IAAA,IAAzGhD,QAAA,GAAAiD,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAW,IAAIG,oBAAA,CAAsB;IAAA,IAAEzB,QAAA,GAAAsB,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAW,IAAII,YAAA,CAAa;MAAEC,KAAA,EAAO7D,IAAA,CAAK8D,MAAA,KAAW;IAAU;IAAAC,eAAA,OAAAb,aAAA;IAChHK,KAAA,GAAAF,MAAA,CAAAW,IAAA,OAAMzD,QAAA,EAAU2B,QAAQ;IAExBqB,KAAA,CAAKU,eAAA,GAAkB;IAEvBV,KAAA,CAAKW,IAAA,GAAO;IAAA,OAAAX,KAAA;EACb;EAAA;EAAAY,YAAA,CAAAjB,aAAA;IAAAkB,GAAA;IAAAC,KAAA,EAID,SAAAC,qBAAA,EAAuB;MACrB,IAAM/D,QAAA,GAAW,KAAKA,QAAA;MAEtB,IAAMC,aAAA,GAAgBD,QAAA,CAASE,UAAA,CAAWD,aAAA;MAC1C,IAAME,WAAA,GAAcH,QAAA,CAASE,UAAA,CAAWC,WAAA;MACxC,IAAM6D,aAAA,GAAgB,IAAIC,YAAA,CAAa,IAAIhE,aAAA,CAAcM,KAAK;MAE9D,SAASC,CAAA,GAAI,GAAG0D,CAAA,GAAI,GAAGzD,CAAA,GAAIR,aAAA,CAAcM,KAAA,EAAOC,CAAA,GAAIC,CAAA,EAAGD,CAAA,IAAK0D,CAAA,IAAK,GAAG;QAClE1G,MAAA,CAAOmD,mBAAA,CAAoBV,aAAA,EAAeO,CAAC;QAC3C9C,IAAA,CAAKiD,mBAAA,CAAoBR,WAAA,EAAaK,CAAC;QAEvCwD,aAAA,CAAcE,CAAC,IAAIA,CAAA,KAAM,IAAI,IAAIF,aAAA,CAAcE,CAAA,GAAI,CAAC;QACpDF,aAAA,CAAcE,CAAA,GAAI,CAAC,IAAIF,aAAA,CAAcE,CAAC,IAAI1G,MAAA,CAAOyD,UAAA,CAAWvD,IAAI;MACjE;MAED,IAAMyG,sBAAA,GAAyB,IAAIC,0BAAA,CAA2BJ,aAAA,EAAe,GAAG,CAAC;MAEjFhE,QAAA,CAASqE,YAAA,CAAa,yBAAyB,IAAIC,0BAAA,CAA2BH,sBAAA,EAAwB,GAAG,CAAC,CAAC;MAC3GnE,QAAA,CAASqE,YAAA,CAAa,uBAAuB,IAAIC,0BAAA,CAA2BH,sBAAA,EAAwB,GAAG,CAAC,CAAC;MAEzG,OAAO;IACR;EAAA;IAAAN,GAAA;IAAAC,KAAA,EAED,SAAAS,QAAQC,SAAA,EAAW1E,UAAA,EAAY;MAC7B,IAAM2E,UAAA,GAAa,KAAK9C,QAAA,CAAS8C,UAAA;MACjC,IAAM7F,MAAA,GAAS4F,SAAA,CAAU5F,MAAA;MAEzB,IAAIA,MAAA,KAAW,QAAQ,CAAC6F,UAAA,EAAY;QAClCC,OAAA,CAAQC,KAAA,CACN,+HACD;MACF;MAED,IAAMC,SAAA,GAAYJ,SAAA,CAAUK,MAAA,CAAOC,KAAA,KAAU,SAAYN,SAAA,CAAUK,MAAA,CAAOC,KAAA,CAAMF,SAAA,IAAa,IAAI;MAEjGnG,IAAA,GAAO+F,SAAA,CAAUO,GAAA;MAEjB,IAAMhF,WAAA,GAAc,KAAKA,WAAA;MACzB,IAAMC,QAAA,GAAW,KAAKA,QAAA;MACtB,IAAM2B,QAAA,GAAW,KAAKA,QAAA;MAEtBjD,UAAA,GAAaiD,QAAA,CAASqD,SAAA,GAAYJ,SAAA;MAGlC,IAAI5E,QAAA,CAASiF,cAAA,KAAmB,MAAM;QACpCjF,QAAA,CAASkF,qBAAA,CAAuB;MACjC;MAED5G,OAAA,CAAQ0D,IAAA,CAAKhC,QAAA,CAASiF,cAAc,EAAEjG,YAAA,CAAae,WAAW;MAG9D,IAAIoF,YAAA;MACJ,IAAIV,UAAA,EAAY;QACdU,YAAA,GAAezG,UAAA,GAAa;MAClC,OAAW;QACL,IAAM0G,gBAAA,GAAmB3F,IAAA,CAAKE,GAAA,CAAIf,MAAA,CAAOgD,IAAA,EAAMtD,OAAA,CAAQ+G,eAAA,CAAgB5G,IAAA,CAAK2C,MAAM,CAAC;QACnF+D,YAAA,GAAexG,sBAAA,CAAuBC,MAAA,EAAQwG,gBAAA,EAAkBzD,QAAA,CAAS7C,UAAU;MACpF;MAEDR,OAAA,CAAQgH,MAAA,IAAUH,YAAA;MAElB,IAAI1G,IAAA,CAAK8G,gBAAA,CAAiBjH,OAAO,MAAM,OAAO;QAC5C;MACD;MAGD,IAAI0B,QAAA,CAASwF,WAAA,KAAgB,MAAM;QACjCxF,QAAA,CAASyF,kBAAA,CAAoB;MAC9B;MAEDrH,IAAA,CAAK4D,IAAA,CAAKhC,QAAA,CAASwF,WAAW,EAAExG,YAAA,CAAae,WAAW;MAGxD,IAAI2F,SAAA;MACJ,IAAIjB,UAAA,EAAY;QACdiB,SAAA,GAAYhH,UAAA,GAAa;MAC/B,OAAW;QACL,IAAMiH,aAAA,GAAgBlG,IAAA,CAAKE,GAAA,CAAIf,MAAA,CAAOgD,IAAA,EAAMxD,IAAA,CAAKiH,eAAA,CAAgB5G,IAAA,CAAK2C,MAAM,CAAC;QAC7EsE,SAAA,GAAY/G,sBAAA,CAAuBC,MAAA,EAAQ+G,aAAA,EAAehE,QAAA,CAAS7C,UAAU;MAC9E;MAEDV,IAAA,CAAKwH,cAAA,CAAeF,SAAS;MAE7B,IAAIjH,IAAA,CAAKoH,aAAA,CAAczH,IAAI,MAAM,OAAO;QACtC;MACD;MAED,IAAIqG,UAAA,EAAY;QACd7E,iBAAA,CAAkB,MAAME,UAAU;MACxC,OAAW;QACL4B,kBAAA,CAAmB,MAAM9C,MAAA,EAAQkB,UAAU;MAC5C;IACF;EAAA;IAAA+D,GAAA;IAAAC,KAAA,EAED,SAAAgC,eAAeC,QAAA,EAAU;MAEvB,IAAMC,QAAA,GAAW,KAAKrE,QAAA,CAASqE,QAAA;MAE/B,IAAIA,QAAA,IAAYA,QAAA,CAASlH,UAAA,EAAY;QAEnCiH,QAAA,CAASE,WAAA,CAAY3I,SAAS;QAC9B,KAAKqE,QAAA,CAASqE,QAAA,CAASlH,UAAA,CAAWgF,KAAA,CAAM/E,GAAA,CAAIzB,SAAA,CAAUyE,CAAA,EAAGzE,SAAA,CAAU6B,CAAC;MAErE;IAEF;EAAA;EAAA,OAAAwD,aAAA;AAAA,EApHyBuD,IAAA"},"metadata":{},"sourceType":"module","externalDependencies":[]}