{"ast":null,"code":"import _classCallCheck from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = function __defNormalProp(obj, key, value) {\n  return key in obj ? __defProp(obj, key, {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: value\n  }) : obj[key] = value;\n};\nvar __publicField = function __publicField(obj, key, value) {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nimport { Vector3, BufferGeometry, Float32BufferAttribute } from \"three\";\nimport { mergeVertices } from \"../utils/BufferGeometryUtils.js\";\nvar cb = new Vector3();\nvar ab = new Vector3();\nfunction pushIfUnique(array, object) {\n  if (array.indexOf(object) === -1) array.push(object);\n}\nfunction removeFromArray(array, object) {\n  var k = array.indexOf(object);\n  if (k > -1) array.splice(k, 1);\n}\nvar Vertex = /*#__PURE__*/function () {\n  function Vertex(v, id) {\n    _classCallCheck(this, Vertex);\n    __publicField(this, \"position\");\n    __publicField(this, \"id\");\n    __publicField(this, \"faces\");\n    __publicField(this, \"neighbors\");\n    __publicField(this, \"collapseCost\");\n    __publicField(this, \"collapseNeighbor\");\n    __publicField(this, \"minCost\", 0);\n    __publicField(this, \"totalCost\", 0);\n    __publicField(this, \"costCount\", 0);\n    this.position = v;\n    this.id = id;\n    this.faces = [];\n    this.neighbors = [];\n    this.collapseCost = 0;\n    this.collapseNeighbor = null;\n  }\n  _createClass(Vertex, [{\n    key: \"addUniqueNeighbor\",\n    value: function addUniqueNeighbor(vertex) {\n      pushIfUnique(this.neighbors, vertex);\n    }\n  }, {\n    key: \"removeIfNonNeighbor\",\n    value: function removeIfNonNeighbor(n) {\n      var neighbors = this.neighbors;\n      var faces = this.faces;\n      var offset = neighbors.indexOf(n);\n      if (offset === -1) return;\n      for (var i = 0; i < faces.length; i++) {\n        if (faces[i].hasVertex(n)) return;\n      }\n      neighbors.splice(offset, 1);\n    }\n  }]);\n  return Vertex;\n}();\nvar Triangle = /*#__PURE__*/function () {\n  function Triangle(v1, v2, v3, a, b, c) {\n    _classCallCheck(this, Triangle);\n    __publicField(this, \"a\");\n    __publicField(this, \"b\");\n    __publicField(this, \"c\");\n    __publicField(this, \"v1\");\n    __publicField(this, \"v2\");\n    __publicField(this, \"v3\");\n    __publicField(this, \"normal\", new Vector3());\n    this.a = a;\n    this.b = b;\n    this.c = c;\n    this.v1 = v1;\n    this.v2 = v2;\n    this.v3 = v3;\n    this.computeNormal();\n    v1.faces.push(this);\n    v1.addUniqueNeighbor(v2);\n    v1.addUniqueNeighbor(v3);\n    v2.faces.push(this);\n    v2.addUniqueNeighbor(v1);\n    v2.addUniqueNeighbor(v3);\n    v3.faces.push(this);\n    v3.addUniqueNeighbor(v1);\n    v3.addUniqueNeighbor(v2);\n  }\n  _createClass(Triangle, [{\n    key: \"computeNormal\",\n    value: function computeNormal() {\n      var vA = this.v1.position;\n      var vB = this.v2.position;\n      var vC = this.v3.position;\n      cb.subVectors(vC, vB);\n      ab.subVectors(vA, vB);\n      cb.cross(ab).normalize();\n      this.normal.copy(cb);\n    }\n  }, {\n    key: \"hasVertex\",\n    value: function hasVertex(v) {\n      return v === this.v1 || v === this.v2 || v === this.v3;\n    }\n  }, {\n    key: \"replaceVertex\",\n    value: function replaceVertex(oldv, newv) {\n      if (oldv === this.v1) this.v1 = newv;else if (oldv === this.v2) this.v2 = newv;else if (oldv === this.v3) this.v3 = newv;\n      removeFromArray(oldv.faces, this);\n      newv.faces.push(this);\n      oldv.removeIfNonNeighbor(this.v1);\n      this.v1.removeIfNonNeighbor(oldv);\n      oldv.removeIfNonNeighbor(this.v2);\n      this.v2.removeIfNonNeighbor(oldv);\n      oldv.removeIfNonNeighbor(this.v3);\n      this.v3.removeIfNonNeighbor(oldv);\n      this.v1.addUniqueNeighbor(this.v2);\n      this.v1.addUniqueNeighbor(this.v3);\n      this.v2.addUniqueNeighbor(this.v1);\n      this.v2.addUniqueNeighbor(this.v3);\n      this.v3.addUniqueNeighbor(this.v1);\n      this.v3.addUniqueNeighbor(this.v2);\n      this.computeNormal();\n    }\n  }]);\n  return Triangle;\n}();\nvar SimplifyModifier = /*#__PURE__*/function () {\n  function SimplifyModifier() {\n    var _this = this;\n    _classCallCheck(this, SimplifyModifier);\n    __publicField(this, \"computeEdgeCollapseCost\", function (u, v) {\n      var edgelength = v.position.distanceTo(u.position);\n      var curvature = 0;\n      var sideFaces = [];\n      var i,\n        il = u.faces.length,\n        face,\n        sideFace;\n      for (i = 0; i < il; i++) {\n        face = u.faces[i];\n        if (face.hasVertex(v)) {\n          sideFaces.push(face);\n        }\n      }\n      for (i = 0; i < il; i++) {\n        var minCurvature = 1;\n        face = u.faces[i];\n        for (var j = 0; j < sideFaces.length; j++) {\n          sideFace = sideFaces[j];\n          var dotProd = face.normal.dot(sideFace.normal);\n          minCurvature = Math.min(minCurvature, (1.001 - dotProd) / 2);\n        }\n        curvature = Math.max(curvature, minCurvature);\n      }\n      var borders = 0;\n      if (sideFaces.length < 2) {\n        curvature = 1;\n      }\n      var amt = edgelength * curvature + borders;\n      return amt;\n    });\n    __publicField(this, \"computeEdgeCostAtVertex\", function (v) {\n      if (v.neighbors.length === 0) {\n        v.collapseNeighbor = null;\n        v.collapseCost = -0.01;\n        return;\n      }\n      v.collapseCost = 1e5;\n      v.collapseNeighbor = null;\n      for (var i = 0; i < v.neighbors.length; i++) {\n        var collapseCost = _this.computeEdgeCollapseCost(v, v.neighbors[i]);\n        if (!v.collapseNeighbor) {\n          v.collapseNeighbor = v.neighbors[i];\n          v.collapseCost = collapseCost;\n          v.minCost = collapseCost;\n          v.totalCost = 0;\n          v.costCount = 0;\n        }\n        v.costCount++;\n        v.totalCost += collapseCost;\n        if (collapseCost < v.minCost) {\n          v.collapseNeighbor = v.neighbors[i];\n          v.minCost = collapseCost;\n        }\n      }\n      v.collapseCost = v.totalCost / v.costCount;\n    });\n    __publicField(this, \"removeFace\", function (f, faces) {\n      removeFromArray(faces, f);\n      if (f.v1) removeFromArray(f.v1.faces, f);\n      if (f.v2) removeFromArray(f.v2.faces, f);\n      if (f.v3) removeFromArray(f.v3.faces, f);\n      var vs = [f.v1, f.v2, f.v3];\n      var v1, v2;\n      for (var i = 0; i < 3; i++) {\n        v1 = vs[i];\n        v2 = vs[(i + 1) % 3];\n        if (!v1 || !v2) continue;\n        v1.removeIfNonNeighbor(v2);\n        v2.removeIfNonNeighbor(v1);\n      }\n    });\n    __publicField(this, \"collapse\", function (vertices, faces, u, v) {\n      if (!v) {\n        _this.removeVertex(u, vertices);\n        return;\n      }\n      var i;\n      var tmpVertices = [];\n      for (i = 0; i < u.neighbors.length; i++) {\n        tmpVertices.push(u.neighbors[i]);\n      }\n      for (i = u.faces.length - 1; i >= 0; i--) {\n        if (u.faces[i].hasVertex(v)) {\n          _this.removeFace(u.faces[i], faces);\n        }\n      }\n      for (i = u.faces.length - 1; i >= 0; i--) {\n        u.faces[i].replaceVertex(u, v);\n      }\n      _this.removeVertex(u, vertices);\n      for (i = 0; i < tmpVertices.length; i++) {\n        _this.computeEdgeCostAtVertex(tmpVertices[i]);\n      }\n    });\n    __publicField(this, \"minimumCostEdge\", function (vertices) {\n      var least = vertices[0];\n      for (var i = 0; i < vertices.length; i++) {\n        if (vertices[i].collapseCost < least.collapseCost) {\n          least = vertices[i];\n        }\n      }\n      return least;\n    });\n    __publicField(this, \"modify\", function (geometry, count) {\n      geometry = geometry.clone();\n      var attributes = geometry.attributes;\n      for (var name in attributes) {\n        if (name !== \"position\") geometry.deleteAttribute(name);\n      }\n      geometry = mergeVertices(geometry);\n      var vertices = [];\n      var faces = [];\n      var positionAttribute = geometry.getAttribute(\"position\");\n      for (var i = 0; i < positionAttribute.count; i++) {\n        var v = new Vector3().fromBufferAttribute(positionAttribute, i);\n        var vertex = new Vertex(v, i);\n        vertices.push(vertex);\n      }\n      var geomIndex = geometry.getIndex();\n      if (geomIndex !== null) {\n        for (var _i = 0; _i < geomIndex.count; _i += 3) {\n          var a = geomIndex.getX(_i);\n          var b = geomIndex.getX(_i + 1);\n          var c = geomIndex.getX(_i + 2);\n          var triangle = new Triangle(vertices[a], vertices[b], vertices[c], a, b, c);\n          faces.push(triangle);\n        }\n      } else {\n        for (var _i2 = 0; _i2 < positionAttribute.count; _i2 += 3) {\n          var _a = _i2;\n          var _b = _i2 + 1;\n          var _c = _i2 + 2;\n          var _triangle = new Triangle(vertices[_a], vertices[_b], vertices[_c], _a, _b, _c);\n          faces.push(_triangle);\n        }\n      }\n      for (var _i3 = 0, il = vertices.length; _i3 < il; _i3++) {\n        _this.computeEdgeCostAtVertex(vertices[_i3]);\n      }\n      var nextVertex;\n      var z = count;\n      while (z--) {\n        nextVertex = _this.minimumCostEdge(vertices);\n        if (!nextVertex) {\n          console.log(\"THREE.SimplifyModifier: No next vertex\");\n          break;\n        } else {\n          _this.collapse(vertices, faces, nextVertex, nextVertex.collapseNeighbor);\n        }\n      }\n      var simplifiedGeometry = new BufferGeometry();\n      var position = [];\n      var index = [];\n      for (var _i4 = 0; _i4 < vertices.length; _i4++) {\n        var _vertex = vertices[_i4].position;\n        position.push(_vertex.x, _vertex.y, _vertex.z);\n      }\n      for (var _i5 = 0; _i5 < faces.length; _i5++) {\n        var face = faces[_i5];\n        var _a2 = vertices.indexOf(face.v1);\n        var _b2 = vertices.indexOf(face.v2);\n        var _c2 = vertices.indexOf(face.v3);\n        index.push(_a2, _b2, _c2);\n      }\n      simplifiedGeometry.setAttribute(\"position\", new Float32BufferAttribute(position, 3));\n      simplifiedGeometry.setIndex(index);\n      return simplifiedGeometry;\n    });\n  }\n  _createClass(SimplifyModifier, [{\n    key: \"removeVertex\",\n    value: function removeVertex(v, vertices) {\n      console.assert(v.faces.length === 0);\n      while (v.neighbors.length) {\n        var n = v.neighbors.pop();\n        removeFromArray(n.neighbors, v);\n      }\n      removeFromArray(vertices, v);\n    }\n  }]);\n  return SimplifyModifier;\n}();\nexport { SimplifyModifier };","map":{"version":3,"names":["cb","Vector3","ab","pushIfUnique","array","object","indexOf","push","removeFromArray","k","splice","Vertex","v","id","_classCallCheck","__publicField","position","faces","neighbors","collapseCost","collapseNeighbor","_createClass","key","value","addUniqueNeighbor","vertex","removeIfNonNeighbor","n","offset","i","length","hasVertex","Triangle","v1","v2","v3","a","b","c","computeNormal","vA","vB","vC","subVectors","cross","normalize","normal","copy","replaceVertex","oldv","newv","SimplifyModifier","_this","u","edgelength","distanceTo","curvature","sideFaces","il","face","sideFace","minCurvature","j","dotProd","dot","Math","min","max","borders","amt","computeEdgeCollapseCost","minCost","totalCost","costCount","f","vs","vertices","removeVertex","tmpVertices","removeFace","computeEdgeCostAtVertex","least","geometry","count","clone","attributes","name","deleteAttribute","mergeVertices","positionAttribute","getAttribute","fromBufferAttribute","geomIndex","getIndex","getX","triangle","nextVertex","z","minimumCostEdge","console","log","collapse","simplifiedGeometry","BufferGeometry","index","x","y","setAttribute","Float32BufferAttribute","setIndex","assert","pop"],"sources":["C:\\Users\\Nayyu\\Desktop\\skibidai-public-build\\node_modules\\src\\modifiers\\SimplifyModifier.ts"],"sourcesContent":["import { BufferGeometry, Float32BufferAttribute, Vector3 } from 'three'\nimport * as BufferGeometryUtils from '../utils/BufferGeometryUtils'\n\nconst cb = new Vector3()\nconst ab = new Vector3()\n\nfunction pushIfUnique<TItem>(array: TItem[], object: TItem): void {\n  if (array.indexOf(object) === -1) array.push(object)\n}\n\nfunction removeFromArray<TItem>(array: TItem[], object: TItem): void {\n  const k = array.indexOf(object)\n  if (k > -1) array.splice(k, 1)\n}\n\nclass Vertex {\n  public position: Vector3\n  private id: number\n\n  public faces: Triangle[]\n  public neighbors: Vertex[]\n\n  public collapseCost: number\n  public collapseNeighbor: null | Vertex\n\n  public minCost: number = 0\n  public totalCost: number = 0\n  public costCount: number = 0\n\n  constructor(v: Vector3, id: number) {\n    this.position = v\n    this.id = id // old index id\n\n    this.faces = [] // faces vertex is connected\n    this.neighbors = [] // neighbouring vertices aka \"adjacentVertices\"\n\n    // these will be computed in computeEdgeCostAtVertex()\n    this.collapseCost = 0 // cost of collapsing this vertex, the less the better. aka objdist\n    this.collapseNeighbor = null // best candinate for collapsing\n  }\n\n  public addUniqueNeighbor(vertex: Vertex): void {\n    pushIfUnique(this.neighbors, vertex)\n  }\n\n  public removeIfNonNeighbor(n: Vertex): void {\n    const neighbors = this.neighbors\n    const faces = this.faces\n\n    const offset = neighbors.indexOf(n)\n    if (offset === -1) return\n    for (let i = 0; i < faces.length; i++) {\n      if (faces[i].hasVertex(n)) return\n    }\n\n    neighbors.splice(offset, 1)\n  }\n}\n\n// we use a triangle class to represent structure of face slightly differently\nclass Triangle {\n  private a: number\n  private b: number\n  private c: Number\n\n  public v1: Vertex\n  public v2: Vertex\n  public v3: Vertex\n\n  public normal = new Vector3()\n\n  constructor(v1: Vertex, v2: Vertex, v3: Vertex, a: number, b: number, c: number) {\n    this.a = a\n    this.b = b\n    this.c = c\n\n    this.v1 = v1\n    this.v2 = v2\n    this.v3 = v3\n\n    this.computeNormal()\n\n    v1.faces.push(this)\n    v1.addUniqueNeighbor(v2)\n    v1.addUniqueNeighbor(v3)\n\n    v2.faces.push(this)\n    v2.addUniqueNeighbor(v1)\n    v2.addUniqueNeighbor(v3)\n\n    v3.faces.push(this)\n    v3.addUniqueNeighbor(v1)\n    v3.addUniqueNeighbor(v2)\n  }\n\n  private computeNormal(): void {\n    const vA = this.v1.position\n    const vB = this.v2.position\n    const vC = this.v3.position\n\n    cb.subVectors(vC, vB)\n    ab.subVectors(vA, vB)\n    cb.cross(ab).normalize()\n\n    this.normal.copy(cb)\n  }\n\n  public hasVertex(v: Vertex): boolean {\n    return v === this.v1 || v === this.v2 || v === this.v3\n  }\n\n  public replaceVertex(oldv: Vertex, newv: Vertex): void {\n    if (oldv === this.v1) this.v1 = newv\n    else if (oldv === this.v2) this.v2 = newv\n    else if (oldv === this.v3) this.v3 = newv\n\n    removeFromArray(oldv.faces, this)\n    newv.faces.push(this)\n\n    oldv.removeIfNonNeighbor(this.v1)\n    this.v1.removeIfNonNeighbor(oldv)\n\n    oldv.removeIfNonNeighbor(this.v2)\n    this.v2.removeIfNonNeighbor(oldv)\n\n    oldv.removeIfNonNeighbor(this.v3)\n    this.v3.removeIfNonNeighbor(oldv)\n\n    this.v1.addUniqueNeighbor(this.v2)\n    this.v1.addUniqueNeighbor(this.v3)\n\n    this.v2.addUniqueNeighbor(this.v1)\n    this.v2.addUniqueNeighbor(this.v3)\n\n    this.v3.addUniqueNeighbor(this.v1)\n    this.v3.addUniqueNeighbor(this.v2)\n\n    this.computeNormal()\n  }\n}\n\n/**\n *\tSimplification Geometry Modifier\n *    - based on code and technique\n *\t  - by Stan Melax in 1998\n *\t  - Progressive Mesh type Polygon Reduction Algorithm\n *    - http://www.melax.com/polychop/\n */\n\nclass SimplifyModifier {\n  constructor() {}\n\n  private computeEdgeCollapseCost = (u: Vertex, v: Vertex): number => {\n    // if we collapse edge uv by moving u to v then how\n    // much different will the model change, i.e. the \"error\".\n\n    const edgelength = v.position.distanceTo(u.position)\n    let curvature = 0\n\n    const sideFaces = []\n    let i,\n      il = u.faces.length,\n      face,\n      sideFace\n\n    // find the \"sides\" triangles that are on the edge uv\n    for (i = 0; i < il; i++) {\n      face = u.faces[i]\n\n      if (face.hasVertex(v)) {\n        sideFaces.push(face)\n      }\n    }\n\n    // use the triangle facing most away from the sides\n    // to determine our curvature term\n    for (i = 0; i < il; i++) {\n      let minCurvature = 1\n      face = u.faces[i]\n\n      for (let j = 0; j < sideFaces.length; j++) {\n        sideFace = sideFaces[j]\n        // use dot product of face normals.\n        const dotProd = face.normal.dot(sideFace.normal)\n        minCurvature = Math.min(minCurvature, (1.001 - dotProd) / 2)\n      }\n\n      curvature = Math.max(curvature, minCurvature)\n    }\n\n    // crude approach in attempt to preserve borders\n    // though it seems not to be totally correct\n    const borders = 0\n    if (sideFaces.length < 2) {\n      // we add some arbitrary cost for borders,\n      // borders += 10;\n      curvature = 1\n    }\n\n    const amt = edgelength * curvature + borders\n\n    return amt\n  }\n\n  private removeVertex(v: Vertex, vertices: Vertex[]): void {\n    console.assert(v.faces.length === 0)\n\n    while (v.neighbors.length) {\n      const n = v.neighbors.pop() as Vertex\n      removeFromArray(n.neighbors, v)\n    }\n\n    removeFromArray(vertices, v)\n  }\n\n  private computeEdgeCostAtVertex = (v: Vertex): void => {\n    // compute the edge collapse cost for all edges that start\n    // from vertex v.  Since we are only interested in reducing\n    // the object by selecting the min cost edge at each step, we\n    // only cache the cost of the least cost edge at this vertex\n    // (in member variable collapse) as well as the value of the\n    // cost (in member variable collapseCost).\n\n    if (v.neighbors.length === 0) {\n      // collapse if no neighbors.\n      v.collapseNeighbor = null\n      v.collapseCost = -0.01\n\n      return\n    }\n\n    v.collapseCost = 100000\n    v.collapseNeighbor = null\n\n    // search all neighboring edges for \"least cost\" edge\n    for (let i = 0; i < v.neighbors.length; i++) {\n      const collapseCost = this.computeEdgeCollapseCost(v, v.neighbors[i])\n\n      if (!v.collapseNeighbor) {\n        v.collapseNeighbor = v.neighbors[i]\n        v.collapseCost = collapseCost\n        v.minCost = collapseCost\n        v.totalCost = 0\n        v.costCount = 0\n      }\n\n      v.costCount++\n      v.totalCost += collapseCost\n\n      if (collapseCost < v.minCost) {\n        v.collapseNeighbor = v.neighbors[i]\n        v.minCost = collapseCost\n      }\n    }\n\n    // we average the cost of collapsing at this vertex\n    v.collapseCost = v.totalCost / v.costCount\n    // v.collapseCost = v.minCost;\n  }\n\n  private removeFace = (f: Triangle, faces: Triangle[]): void => {\n    removeFromArray(faces, f)\n\n    if (f.v1) removeFromArray(f.v1.faces, f)\n    if (f.v2) removeFromArray(f.v2.faces, f)\n    if (f.v3) removeFromArray(f.v3.faces, f)\n\n    // TODO optimize this!\n    const vs = [f.v1, f.v2, f.v3]\n    let v1, v2\n\n    for (let i = 0; i < 3; i++) {\n      v1 = vs[i]\n      v2 = vs[(i + 1) % 3]\n\n      if (!v1 || !v2) continue\n\n      v1.removeIfNonNeighbor(v2)\n      v2.removeIfNonNeighbor(v1)\n    }\n  }\n\n  private collapse = (vertices: Vertex[], faces: Triangle[], u: Vertex, v: Vertex): void => {\n    // u and v are pointers to vertices of an edge\n\n    // Collapse the edge uv by moving vertex u onto v\n\n    if (!v) {\n      // u is a vertex all by itself so just delete it..\n      this.removeVertex(u, vertices)\n      return\n    }\n\n    let i\n    const tmpVertices = []\n\n    for (i = 0; i < u.neighbors.length; i++) {\n      tmpVertices.push(u.neighbors[i])\n    }\n\n    // delete triangles on edge uv:\n    for (i = u.faces.length - 1; i >= 0; i--) {\n      if (u.faces[i].hasVertex(v)) {\n        this.removeFace(u.faces[i], faces)\n      }\n    }\n\n    // update remaining triangles to have v instead of u\n    for (i = u.faces.length - 1; i >= 0; i--) {\n      u.faces[i].replaceVertex(u, v)\n    }\n\n    this.removeVertex(u, vertices)\n\n    // recompute the edge collapse costs in neighborhood\n    for (i = 0; i < tmpVertices.length; i++) {\n      this.computeEdgeCostAtVertex(tmpVertices[i])\n    }\n  }\n\n  private minimumCostEdge = (vertices: Vertex[]): Vertex => {\n    // O(n * n) approach. TODO optimize this\n\n    let least = vertices[0]\n\n    for (let i = 0; i < vertices.length; i++) {\n      if (vertices[i].collapseCost < least.collapseCost) {\n        least = vertices[i]\n      }\n    }\n\n    return least\n  }\n\n  public modify = (geometry: BufferGeometry, count: number): BufferGeometry => {\n    geometry = geometry.clone()\n    const attributes = geometry.attributes\n\n    // this modifier can only process indexed and non-indexed geomtries with a position attribute\n\n    for (let name in attributes) {\n      if (name !== 'position') geometry.deleteAttribute(name)\n    }\n\n    geometry = BufferGeometryUtils.mergeVertices(geometry)\n\n    //\n    // put data of original geometry in different data structures\n    //\n\n    const vertices = []\n    const faces = []\n\n    // add vertices\n\n    const positionAttribute = geometry.getAttribute('position')\n\n    for (let i = 0; i < positionAttribute.count; i++) {\n      const v = new Vector3().fromBufferAttribute(positionAttribute, i)\n\n      const vertex = new Vertex(v, i)\n      vertices.push(vertex)\n    }\n\n    // add faces\n\n    const geomIndex = geometry.getIndex()\n\n    if (geomIndex !== null) {\n      for (let i = 0; i < geomIndex.count; i += 3) {\n        const a = geomIndex.getX(i)\n        const b = geomIndex.getX(i + 1)\n        const c = geomIndex.getX(i + 2)\n\n        const triangle = new Triangle(vertices[a], vertices[b], vertices[c], a, b, c)\n        faces.push(triangle)\n      }\n    } else {\n      for (let i = 0; i < positionAttribute.count; i += 3) {\n        const a = i\n        const b = i + 1\n        const c = i + 2\n\n        const triangle = new Triangle(vertices[a], vertices[b], vertices[c], a, b, c)\n        faces.push(triangle)\n      }\n    }\n\n    // compute all edge collapse costs\n\n    for (let i = 0, il = vertices.length; i < il; i++) {\n      this.computeEdgeCostAtVertex(vertices[i])\n    }\n\n    let nextVertex\n\n    let z = count\n\n    while (z--) {\n      nextVertex = this.minimumCostEdge(vertices)\n\n      if (!nextVertex) {\n        console.log('THREE.SimplifyModifier: No next vertex')\n        break\n      } else {\n        this.collapse(vertices, faces, nextVertex, nextVertex.collapseNeighbor as Vertex)\n      }\n    }\n\n    //\n\n    const simplifiedGeometry = new BufferGeometry()\n    const position = []\n    let index = []\n\n    //\n\n    for (let i = 0; i < vertices.length; i++) {\n      const vertex = vertices[i].position\n      position.push(vertex.x, vertex.y, vertex.z)\n    }\n\n    //\n\n    for (let i = 0; i < faces.length; i++) {\n      const face = faces[i]\n\n      const a = vertices.indexOf(face.v1)\n      const b = vertices.indexOf(face.v2)\n      const c = vertices.indexOf(face.v3)\n\n      index.push(a, b, c)\n    }\n\n    //\n\n    simplifiedGeometry.setAttribute('position', new Float32BufferAttribute(position, 3))\n    simplifiedGeometry.setIndex(index)\n\n    return simplifiedGeometry\n  }\n}\n\nexport { SimplifyModifier }\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}