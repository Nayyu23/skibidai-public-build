{"ast":null,"code":"import _slicedToArray from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _regeneratorRuntime from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _createForOfIteratorHelper from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _wrapNativeSuper from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/wrapNativeSuper.js\";\nimport _objectSpread from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _classCallCheck from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _inherits from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\n/**\n * @monogrid/gainmap-js v3.0.5\n * With ❤️, by MONOGRID <rnd@monogrid.com>\n */\n\nimport { Q as QuadRenderer } from './QuadRenderer-6HrRQdJM.js';\nimport { ShaderMaterial, Vector3, NoBlending, SRGBColorSpace, LinearSRGBColorSpace, HalfFloatType, Loader, LoadingManager, Texture, UVMapping, ClampToEdgeWrapping, LinearFilter, LinearMipMapLinearFilter, RGBAFormat, UnsignedByteType, FileLoader } from 'three';\nvar vertexShader = /* glsl */\"\\nvarying vec2 vUv;\\n\\nvoid main() {\\n  vUv = uv;\\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\\n}\\n\";\nvar fragmentShader = /* glsl */\"\\n// min half float value\\n#define HALF_FLOAT_MIN vec3( -65504, -65504, -65504 )\\n// max half float value\\n#define HALF_FLOAT_MAX vec3( 65504, 65504, 65504 )\\n\\nuniform sampler2D sdr;\\nuniform sampler2D gainMap;\\nuniform vec3 gamma;\\nuniform vec3 offsetHdr;\\nuniform vec3 offsetSdr;\\nuniform vec3 gainMapMin;\\nuniform vec3 gainMapMax;\\nuniform float weightFactor;\\n\\nvarying vec2 vUv;\\n\\nvoid main() {\\n  vec3 rgb = texture2D( sdr, vUv ).rgb;\\n  vec3 recovery = texture2D( gainMap, vUv ).rgb;\\n  vec3 logRecovery = pow( recovery, gamma );\\n  vec3 logBoost = gainMapMin * ( 1.0 - logRecovery ) + gainMapMax * logRecovery;\\n  vec3 hdrColor = (rgb + offsetSdr) * exp2( logBoost * weightFactor ) - offsetHdr;\\n  vec3 clampedHdrColor = max( HALF_FLOAT_MIN, min( HALF_FLOAT_MAX, hdrColor ));\\n  gl_FragColor = vec4( clampedHdrColor , 1.0 );\\n}\\n\";\n/**\n * A Material which is able to decode the Gainmap into a full HDR Representation\n *\n * @category Materials\n * @group Materials\n */\nvar GainMapDecoderMaterial = /*#__PURE__*/function (_ShaderMaterial) {\n  _inherits(GainMapDecoderMaterial, _ShaderMaterial);\n  var _super = _createSuper(GainMapDecoderMaterial);\n  /**\n   *\n   * @param params\n   */\n  function GainMapDecoderMaterial(_ref) {\n    var _this;\n    var gamma = _ref.gamma,\n      offsetHdr = _ref.offsetHdr,\n      offsetSdr = _ref.offsetSdr,\n      gainMapMin = _ref.gainMapMin,\n      gainMapMax = _ref.gainMapMax,\n      maxDisplayBoost = _ref.maxDisplayBoost,\n      hdrCapacityMin = _ref.hdrCapacityMin,\n      hdrCapacityMax = _ref.hdrCapacityMax,\n      sdr = _ref.sdr,\n      gainMap = _ref.gainMap;\n    _classCallCheck(this, GainMapDecoderMaterial);\n    _this = _super.call(this, {\n      name: 'GainMapDecoderMaterial',\n      vertexShader: vertexShader,\n      fragmentShader: fragmentShader,\n      uniforms: {\n        sdr: {\n          value: sdr\n        },\n        gainMap: {\n          value: gainMap\n        },\n        gamma: {\n          value: new Vector3(1.0 / gamma[0], 1.0 / gamma[1], 1.0 / gamma[2])\n        },\n        offsetHdr: {\n          value: new Vector3().fromArray(offsetHdr)\n        },\n        offsetSdr: {\n          value: new Vector3().fromArray(offsetSdr)\n        },\n        gainMapMin: {\n          value: new Vector3().fromArray(gainMapMin)\n        },\n        gainMapMax: {\n          value: new Vector3().fromArray(gainMapMax)\n        },\n        weightFactor: {\n          value: (Math.log2(maxDisplayBoost) - hdrCapacityMin) / (hdrCapacityMax - hdrCapacityMin)\n        }\n      },\n      blending: NoBlending,\n      depthTest: false,\n      depthWrite: false\n    });\n    _this._maxDisplayBoost = maxDisplayBoost;\n    _this._hdrCapacityMin = hdrCapacityMin;\n    _this._hdrCapacityMax = hdrCapacityMax;\n    _this.needsUpdate = true;\n    _this.uniformsNeedUpdate = true;\n    return _this;\n  }\n  _createClass(GainMapDecoderMaterial, [{\n    key: \"sdr\",\n    get: function get() {\n      return this.uniforms.sdr.value;\n    },\n    set: function set(value) {\n      this.uniforms.sdr.value = value;\n    }\n  }, {\n    key: \"gainMap\",\n    get: function get() {\n      return this.uniforms.gainMap.value;\n    },\n    set: function set(value) {\n      this.uniforms.gainMap.value = value;\n    }\n    /**\n     * @see {@link GainMapMetadata.offsetHdr}\n     */\n  }, {\n    key: \"offsetHdr\",\n    get: function get() {\n      return this.uniforms.offsetHdr.value.toArray();\n    },\n    set: function set(value) {\n      this.uniforms.offsetHdr.value.fromArray(value);\n    }\n    /**\n     * @see {@link GainMapMetadata.offsetSdr}\n     */\n  }, {\n    key: \"offsetSdr\",\n    get: function get() {\n      return this.uniforms.offsetSdr.value.toArray();\n    },\n    set: function set(value) {\n      this.uniforms.offsetSdr.value.fromArray(value);\n    }\n    /**\n     * @see {@link GainMapMetadata.gainMapMin}\n     */\n  }, {\n    key: \"gainMapMin\",\n    get: function get() {\n      return this.uniforms.gainMapMin.value.toArray();\n    },\n    set: function set(value) {\n      this.uniforms.gainMapMin.value.fromArray(value);\n    }\n    /**\n     * @see {@link GainMapMetadata.gainMapMax}\n     */\n  }, {\n    key: \"gainMapMax\",\n    get: function get() {\n      return this.uniforms.gainMapMax.value.toArray();\n    },\n    set: function set(value) {\n      this.uniforms.gainMapMax.value.fromArray(value);\n    }\n    /**\n     * @see {@link GainMapMetadata.gamma}\n     */\n  }, {\n    key: \"gamma\",\n    get: function get() {\n      var g = this.uniforms.gamma.value;\n      return [1 / g.x, 1 / g.y, 1 / g.z];\n    },\n    set: function set(value) {\n      var g = this.uniforms.gamma.value;\n      g.x = 1.0 / value[0];\n      g.y = 1.0 / value[1];\n      g.z = 1.0 / value[2];\n    }\n    /**\n     * @see {@link GainMapMetadata.hdrCapacityMin}\n     * @remarks Logarithmic space\n     */\n  }, {\n    key: \"hdrCapacityMin\",\n    get: function get() {\n      return this._hdrCapacityMin;\n    },\n    set: function set(value) {\n      this._hdrCapacityMin = value;\n      this.calculateWeight();\n    }\n    /**\n     * @see {@link GainMapMetadata.hdrCapacityMin}\n     * @remarks Logarithmic space\n     */\n  }, {\n    key: \"hdrCapacityMax\",\n    get: function get() {\n      return this._hdrCapacityMax;\n    },\n    set: function set(value) {\n      this._hdrCapacityMax = value;\n      this.calculateWeight();\n    }\n    /**\n     * @see {@link GainmapDecodingParameters.maxDisplayBoost}\n     * @remarks Non Logarithmic space\n     */\n  }, {\n    key: \"maxDisplayBoost\",\n    get: function get() {\n      return this._maxDisplayBoost;\n    },\n    set: function set(value) {\n      this._maxDisplayBoost = Math.max(1, Math.min(65504, value));\n      this.calculateWeight();\n    }\n  }, {\n    key: \"calculateWeight\",\n    value: function calculateWeight() {\n      var val = (Math.log2(this._maxDisplayBoost) - this._hdrCapacityMin) / (this._hdrCapacityMax - this._hdrCapacityMin);\n      this.uniforms.weightFactor.value = Math.max(0, Math.min(1, val));\n    }\n  }]);\n  return GainMapDecoderMaterial;\n}(ShaderMaterial);\n/**\n * Decodes a gain map using a WebGLRenderTarget\n *\n * @category Decoding Functions\n * @group Decoding Functions\n * @example\n * import { decode } from '@monogrid/gainmap-js'\n * import {\n *   Mesh,\n *   MeshBasicMaterial,\n *   PerspectiveCamera,\n *   PlaneGeometry,\n *   Scene,\n *   TextureLoader,\n *   WebGLRenderer\n * } from 'three'\n *\n * const renderer = new WebGLRenderer()\n *\n * const textureLoader = new TextureLoader()\n *\n * // load SDR Representation\n * const sdr = await textureLoader.loadAsync('sdr.jpg')\n * // load Gain map recovery image\n * const gainMap = await textureLoader.loadAsync('gainmap.jpg')\n * // load metadata\n * const metadata = await (await fetch('metadata.json')).json()\n *\n * const result = await decode({\n *   sdr,\n *   gainMap,\n *   // this allows to use `result.renderTarget.texture` directly\n *   renderer,\n *   // this will restore the full HDR range\n *   maxDisplayBoost: Math.pow(2, metadata.hdrCapacityMax),\n *   ...metadata\n * })\n *\n * const scene = new Scene()\n * // `result` can be used to populate a Texture\n * const mesh = new Mesh(\n *   new PlaneGeometry(),\n *   new MeshBasicMaterial({ map: result.renderTarget.texture })\n * )\n * scene.add(mesh)\n * renderer.render(scene, new PerspectiveCamera())\n *\n * // result must be manually disposed\n * // when you are done using it\n * result.dispose()\n *\n * @param params\n * @returns\n * @throws {Error} if the WebGLRenderer fails to render the gain map\n */\nvar decode = function decode(params) {\n  var sdr = params.sdr,\n    gainMap = params.gainMap,\n    renderer = params.renderer;\n  if (sdr.colorSpace !== SRGBColorSpace) {\n    console.warn('SDR Colorspace needs to be *SRGBColorSpace*, setting it automatically');\n    sdr.colorSpace = SRGBColorSpace;\n  }\n  sdr.needsUpdate = true;\n  if (gainMap.colorSpace !== LinearSRGBColorSpace) {\n    console.warn('Gainmap Colorspace needs to be *LinearSRGBColorSpace*, setting it automatically');\n    gainMap.colorSpace = LinearSRGBColorSpace;\n  }\n  gainMap.needsUpdate = true;\n  var material = new GainMapDecoderMaterial(_objectSpread(_objectSpread({}, params), {}, {\n    sdr: sdr,\n    gainMap: gainMap\n  }));\n  var quadRenderer = new QuadRenderer({\n    // TODO: three types are generic, eslint complains here, see how we can solve\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-member-access\n    width: sdr.image.width,\n    // TODO: three types are generic, eslint complains here, see how we can solve\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-member-access\n    height: sdr.image.height,\n    type: HalfFloatType,\n    colorSpace: LinearSRGBColorSpace,\n    material: material,\n    renderer: renderer,\n    renderTargetOptions: params.renderTargetOptions\n  });\n  try {\n    quadRenderer.render();\n  } catch (e) {\n    quadRenderer.disposeOnDemandRenderer();\n    throw e;\n  }\n  return quadRenderer;\n};\nvar GainMapNotFoundError = /*#__PURE__*/function (_Error) {\n  _inherits(GainMapNotFoundError, _Error);\n  var _super2 = _createSuper(GainMapNotFoundError);\n  function GainMapNotFoundError() {\n    _classCallCheck(this, GainMapNotFoundError);\n    return _super2.apply(this, arguments);\n  }\n  return _createClass(GainMapNotFoundError);\n}( /*#__PURE__*/_wrapNativeSuper(Error));\nvar XMPMetadataNotFoundError = /*#__PURE__*/function (_Error2) {\n  _inherits(XMPMetadataNotFoundError, _Error2);\n  var _super3 = _createSuper(XMPMetadataNotFoundError);\n  function XMPMetadataNotFoundError() {\n    _classCallCheck(this, XMPMetadataNotFoundError);\n    return _super3.apply(this, arguments);\n  }\n  return _createClass(XMPMetadataNotFoundError);\n}( /*#__PURE__*/_wrapNativeSuper(Error));\nvar getAttribute = function getAttribute(description, name, defaultValue) {\n  var _a;\n  var returnValue;\n  var parsedValue = (_a = description.attributes.getNamedItem(name)) === null || _a === void 0 ? void 0 : _a.nodeValue;\n  if (!parsedValue) {\n    var node = description.getElementsByTagName(name)[0];\n    if (node) {\n      var values = node.getElementsByTagName('rdf:li');\n      if (values.length === 3) {\n        returnValue = Array.from(values).map(function (v) {\n          return v.innerHTML;\n        });\n      } else {\n        throw new Error(\"Gainmap metadata contains an array of items for \".concat(name, \" but its length is not 3\"));\n      }\n    } else {\n      if (defaultValue) return defaultValue;else throw new Error(\"Can't find \".concat(name, \" in gainmap metadata\"));\n    }\n  } else {\n    returnValue = parsedValue;\n  }\n  return returnValue;\n};\n/**\n *\n * @param input\n * @returns\n */\nvar extractXMP = function extractXMP(input) {\n  var _a, _b;\n  var str;\n  // support node test environment\n  if (typeof TextDecoder !== 'undefined') str = new TextDecoder().decode(input);else str = input.toString();\n  var start = str.indexOf('<x:xmpmeta');\n  var parser = new DOMParser();\n  while (start !== -1) {\n    var end = str.indexOf('x:xmpmeta>', start);\n    str.slice(start, end + 10);\n    var xmpBlock = str.slice(start, end + 10);\n    try {\n      var xmlDocument = parser.parseFromString(xmpBlock, 'text/xml');\n      var description = xmlDocument.getElementsByTagName('rdf:Description')[0];\n      var gainMapMin = getAttribute(description, 'hdrgm:GainMapMin', '0');\n      var gainMapMax = getAttribute(description, 'hdrgm:GainMapMax');\n      var gamma = getAttribute(description, 'hdrgm:Gamma', '1');\n      var offsetSDR = getAttribute(description, 'hdrgm:OffsetSDR', '0.015625');\n      var offsetHDR = getAttribute(description, 'hdrgm:OffsetHDR', '0.015625');\n      var hdrCapacityMin = (_a = description.attributes.getNamedItem('hdrgm:HDRCapacityMin')) === null || _a === void 0 ? void 0 : _a.nodeValue;\n      if (!hdrCapacityMin) hdrCapacityMin = '0';\n      var hdrCapacityMax = (_b = description.attributes.getNamedItem('hdrgm:HDRCapacityMax')) === null || _b === void 0 ? void 0 : _b.nodeValue;\n      if (!hdrCapacityMax) throw new Error('Incomplete gainmap metadata');\n      return {\n        gainMapMin: Array.isArray(gainMapMin) ? gainMapMin.map(function (v) {\n          return parseFloat(v);\n        }) : [parseFloat(gainMapMin), parseFloat(gainMapMin), parseFloat(gainMapMin)],\n        gainMapMax: Array.isArray(gainMapMax) ? gainMapMax.map(function (v) {\n          return parseFloat(v);\n        }) : [parseFloat(gainMapMax), parseFloat(gainMapMax), parseFloat(gainMapMax)],\n        gamma: Array.isArray(gamma) ? gamma.map(function (v) {\n          return parseFloat(v);\n        }) : [parseFloat(gamma), parseFloat(gamma), parseFloat(gamma)],\n        offsetSdr: Array.isArray(offsetSDR) ? offsetSDR.map(function (v) {\n          return parseFloat(v);\n        }) : [parseFloat(offsetSDR), parseFloat(offsetSDR), parseFloat(offsetSDR)],\n        offsetHdr: Array.isArray(offsetHDR) ? offsetHDR.map(function (v) {\n          return parseFloat(v);\n        }) : [parseFloat(offsetHDR), parseFloat(offsetHDR), parseFloat(offsetHDR)],\n        hdrCapacityMin: parseFloat(hdrCapacityMin),\n        hdrCapacityMax: parseFloat(hdrCapacityMax)\n      };\n    } catch (e) {}\n    start = str.indexOf('<x:xmpmeta', end);\n  }\n};\n\n/**\n * MPF Extractor (Multi Picture Format Extractor)\n * By Henrik S Nilsson 2019\n *\n * Extracts images stored in images based on the MPF format (found here: https://www.cipa.jp/e/std/std-sec.html\n * under \"CIPA DC-007-Translation-2021 Multi-Picture Format\"\n *\n * Overly commented, and without intention of being complete or production ready.\n * Created to extract depth maps from iPhone images, and to learn about image metadata.\n * Kudos to: Phil Harvey (exiftool), Jaume Sanchez (android-lens-blur-depth-extractor)\n */\nvar MPFExtractor = /*#__PURE__*/function () {\n  function MPFExtractor(options) {\n    _classCallCheck(this, MPFExtractor);\n    this.options = {\n      debug: options && options.debug !== undefined ? options.debug : false,\n      extractFII: options && options.extractFII !== undefined ? options.extractFII : true,\n      extractNonFII: options && options.extractNonFII !== undefined ? options.extractNonFII : true\n    };\n  }\n  _createClass(MPFExtractor, [{\n    key: \"extract\",\n    value: function extract(imageArrayBuffer) {\n      var _this2 = this;\n      return new Promise(function (resolve, reject) {\n        var debug = _this2.options.debug;\n        var dataView = new DataView(imageArrayBuffer.buffer);\n        // If you're executing this line on a big endian machine, it'll be reversed.\n        // bigEnd further down though, refers to the endianness of the image itself.\n        if (dataView.getUint16(0) !== 0xffd8) {\n          reject(new Error('Not a valid jpeg'));\n          return;\n        }\n        var length = dataView.byteLength;\n        var offset = 2;\n        var loops = 0;\n        var marker; // APP# marker\n        while (offset < length) {\n          if (++loops > 250) {\n            reject(new Error(\"Found no marker after \".concat(loops, \" loops \\uD83D\\uDE35\")));\n            return;\n          }\n          if (dataView.getUint8(offset) !== 0xff) {\n            reject(new Error(\"Not a valid marker at offset 0x\".concat(offset.toString(16), \", found: 0x\").concat(dataView.getUint8(offset).toString(16))));\n            return;\n          }\n          marker = dataView.getUint8(offset + 1);\n          if (debug) console.log(\"Marker: \".concat(marker.toString(16)));\n          if (marker === 0xe2) {\n            if (debug) console.log('Found APP2 marker (0xffe2)');\n            // Works for iPhone 8 Plus, X, and XSMax. Or any photos of MPF format.\n            // Great way to visualize image information in html is using Exiftool. E.g.:\n            // ./exiftool.exe -htmldump -wantTrailer photo.jpg > photo.html\n            var formatPt = offset + 4;\n            /*\n             *  Structure of the MP Format Identifier\n             *\n             *  Offset Addr.  | Code (Hex)  | Description\n             *  +00             ff            Marker Prefix      <-- offset\n             *  +01             e2            APP2\n             *  +02             #n            APP2 Field Length\n             *  +03             #n            APP2 Field Length\n             *  +04             4d            'M'                <-- formatPt\n             *  +05             50            'P'\n             *  +06             46            'F'\n             *  +07             00            NULL\n             *                                                   <-- tiffOffset\n             */\n            if (dataView.getUint32(formatPt) === 0x4d504600) {\n              // Found MPF tag, so we start dig out sub images\n              var tiffOffset = formatPt + 4;\n              var bigEnd = void 0; // Endianness from TIFF header\n              // Test for TIFF validity and endianness\n              // 0x4949 and 0x4D4D ('II' and 'MM') marks Little Endian and Big Endian\n              if (dataView.getUint16(tiffOffset) === 0x4949) {\n                bigEnd = false;\n              } else if (dataView.getUint16(tiffOffset) === 0x4d4d) {\n                bigEnd = true;\n              } else {\n                reject(new Error('No valid endianness marker found in TIFF header'));\n                return;\n              }\n              if (dataView.getUint16(tiffOffset + 2, !bigEnd) !== 0x002a) {\n                reject(new Error('Not valid TIFF data! (no 0x002A marker)'));\n                return;\n              }\n              // 32 bit number stating the offset from the start of the 8 Byte MP Header\n              // to MP Index IFD Least possible value is thus 8 (means 0 offset)\n              var firstIFDOffset = dataView.getUint32(tiffOffset + 4, !bigEnd);\n              if (firstIFDOffset < 0x00000008) {\n                reject(new Error('Not valid TIFF data! (First offset less than 8)'));\n                return;\n              }\n              // Move ahead to MP Index IFD\n              // Assume we're at the first IFD, so firstIFDOffset points to\n              // MP Index IFD and not MP Attributes IFD. (If we try extract from a sub image,\n              // we fail silently here due to this assumption)\n              // Count (2 Byte) | MP Index Fields a.k.a. MP Entries (count * 12 Byte) | Offset of Next IFD (4 Byte)\n              var dirStart = tiffOffset + firstIFDOffset; // Start of IFD (Image File Directory)\n              var count = dataView.getUint16(dirStart, !bigEnd); // Count of MPEntries (2 Byte)\n              // Extract info from MPEntries (starting after Count)\n              var entriesStart = dirStart + 2;\n              var numberOfImages = 0;\n              for (var i = entriesStart; i < entriesStart + 12 * count; i += 12) {\n                // Each entry is 12 Bytes long\n                // Check MP Index IFD tags, here we only take tag 0xb001 = Number of images\n                if (dataView.getUint16(i, !bigEnd) === 0xb001) {\n                  // stored in Last 4 bytes of its 12 Byte entry.\n                  numberOfImages = dataView.getUint32(i + 8, !bigEnd);\n                }\n              }\n              var nextIFDOffsetLen = 4; // 4 Byte offset field that appears after MP Index IFD tags\n              var MPImageListValPt = dirStart + 2 + count * 12 + nextIFDOffsetLen;\n              var images = [];\n              for (var _i = MPImageListValPt; _i < MPImageListValPt + numberOfImages * 16; _i += 16) {\n                var image = {\n                  MPType: dataView.getUint32(_i, !bigEnd),\n                  size: dataView.getUint32(_i + 4, !bigEnd),\n                  // This offset is specified relative to the address of the MP Endian\n                  // field in the MP Header, unless the image is a First Individual Image,\n                  // in which case the value of the offset shall be NULL (0x00000000).\n                  dataOffset: dataView.getUint32(_i + 8, !bigEnd),\n                  dependantImages: dataView.getUint32(_i + 12, !bigEnd),\n                  start: -1,\n                  end: -1,\n                  isFII: false\n                };\n                if (!image.dataOffset) {\n                  // dataOffset is 0x00000000 for First Individual Image\n                  image.start = 0;\n                  image.isFII = true;\n                } else {\n                  image.start = tiffOffset + image.dataOffset;\n                  image.isFII = false;\n                }\n                image.end = image.start + image.size;\n                images.push(image);\n              }\n              if (_this2.options.extractNonFII && images.length) {\n                var bufferBlob = new Blob([dataView]);\n                var imgs = [];\n                var _iterator = _createForOfIteratorHelper(images),\n                  _step;\n                try {\n                  for (_iterator.s(); !(_step = _iterator.n()).done;) {\n                    var _image = _step.value;\n                    if (_image.isFII && !_this2.options.extractFII) {\n                      continue; // Skip FII\n                    }\n\n                    var imageBlob = bufferBlob.slice(_image.start, _image.end + 1, 'image/jpeg');\n                    // we don't need this\n                    // const imageUrl = URL.createObjectURL(imageBlob)\n                    // image.img = document.createElement('img')\n                    // image.img.src = imageUrl\n                    imgs.push(imageBlob);\n                  }\n                } catch (err) {\n                  _iterator.e(err);\n                } finally {\n                  _iterator.f();\n                }\n                resolve(imgs);\n              }\n            }\n          }\n          offset += 2 + dataView.getUint16(offset + 2);\n        }\n      });\n    }\n  }]);\n  return MPFExtractor;\n}();\n/**\n * Extracts XMP Metadata and the gain map recovery image\n * from a single JPEG file.\n *\n * @category Decoding Functions\n * @group Decoding Functions\n * @param jpegFile an `Uint8Array` containing and encoded JPEG file\n * @returns an sdr `Uint8Array` compressed in JPEG, a gainMap `Uint8Array` compressed in JPEG and the XMP parsed XMP metadata\n * @throws Error if XMP Metadata is not found\n * @throws Error if Gain map image is not found\n * @example\n * import { FileLoader } from 'three'\n * import { extractGainmapFromJPEG } from '@monogrid/gainmap-js'\n *\n * const jpegFile = await new FileLoader()\n *  .setResponseType('arraybuffer')\n *  .loadAsync('image.jpg')\n *\n * const { sdr, gainMap, metadata } = extractGainmapFromJPEG(jpegFile)\n */\nvar extractGainmapFromJPEG = /*#__PURE__*/function () {\n  var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(jpegFile) {\n    var metadata, mpfExtractor, images;\n    return _regeneratorRuntime().wrap(function _callee$(_context) {\n      while (1) switch (_context.prev = _context.next) {\n        case 0:\n          metadata = extractXMP(jpegFile);\n          if (metadata) {\n            _context.next = 3;\n            break;\n          }\n          throw new XMPMetadataNotFoundError('Gain map XMP metadata not found');\n        case 3:\n          mpfExtractor = new MPFExtractor({\n            extractFII: true,\n            extractNonFII: true\n          });\n          _context.next = 6;\n          return mpfExtractor.extract(jpegFile);\n        case 6:\n          images = _context.sent;\n          if (!(images.length !== 2)) {\n            _context.next = 9;\n            break;\n          }\n          throw new GainMapNotFoundError('Gain map recovery image not found');\n        case 9:\n          _context.t0 = Uint8Array;\n          _context.next = 12;\n          return images[0].arrayBuffer();\n        case 12:\n          _context.t1 = _context.sent;\n          _context.t2 = new _context.t0(_context.t1);\n          _context.t3 = Uint8Array;\n          _context.next = 17;\n          return images[1].arrayBuffer();\n        case 17:\n          _context.t4 = _context.sent;\n          _context.t5 = new _context.t3(_context.t4);\n          _context.t6 = metadata;\n          return _context.abrupt(\"return\", {\n            sdr: _context.t2,\n            gainMap: _context.t5,\n            metadata: _context.t6\n          });\n        case 21:\n        case \"end\":\n          return _context.stop();\n      }\n    }, _callee);\n  }));\n  return function extractGainmapFromJPEG(_x) {\n    return _ref2.apply(this, arguments);\n  };\n}();\n\n/**\n * private function, async get image from blob\n *\n * @param blob\n * @returns\n */\nvar getHTMLImageFromBlob = function getHTMLImageFromBlob(blob) {\n  return new Promise(function (resolve, reject) {\n    var img = document.createElement('img');\n    img.onload = function () {\n      resolve(img);\n    };\n    img.onerror = function (e) {\n      reject(e);\n    };\n    img.src = URL.createObjectURL(blob);\n  });\n};\nvar LoaderBase = /*#__PURE__*/function (_Loader) {\n  _inherits(LoaderBase, _Loader);\n  var _super4 = _createSuper(LoaderBase);\n  /**\n   *\n   * @param renderer\n   * @param manager\n   */\n  function LoaderBase(renderer, manager) {\n    var _this3;\n    _classCallCheck(this, LoaderBase);\n    _this3 = _super4.call(this, manager);\n    if (renderer) _this3._renderer = renderer;\n    _this3._internalLoadingManager = new LoadingManager();\n    return _this3;\n  }\n  /**\n   * Specify the renderer to use when rendering the gain map\n   *\n   * @param renderer\n   * @returns\n   */\n  _createClass(LoaderBase, [{\n    key: \"setRenderer\",\n    value: function setRenderer(renderer) {\n      this._renderer = renderer;\n      return this;\n    }\n    /**\n     * Specify the renderTarget options to use when rendering the gain map\n     *\n     * @param options\n     * @returns\n     */\n  }, {\n    key: \"setRenderTargetOptions\",\n    value: function setRenderTargetOptions(options) {\n      this._renderTargetOptions = options;\n      return this;\n    }\n    /**\n     * @private\n     * @returns\n     */\n  }, {\n    key: \"prepareQuadRenderer\",\n    value: function prepareQuadRenderer() {\n      if (!this._renderer) console.warn('WARNING: An existing WebGL Renderer was not passed to this Loader constructor or in setRenderer, the result of this Loader will need to be converted to a Data Texture with toDataTexture() before you can use it in your renderer.');\n      // temporary values\n      var material = new GainMapDecoderMaterial({\n        gainMapMax: [1, 1, 1],\n        gainMapMin: [0, 0, 0],\n        gamma: [1, 1, 1],\n        offsetHdr: [1, 1, 1],\n        offsetSdr: [1, 1, 1],\n        hdrCapacityMax: 1,\n        hdrCapacityMin: 0,\n        maxDisplayBoost: 1,\n        gainMap: new Texture(),\n        sdr: new Texture()\n      });\n      return new QuadRenderer({\n        width: 16,\n        height: 16,\n        type: HalfFloatType,\n        colorSpace: LinearSRGBColorSpace,\n        material: material,\n        renderer: this._renderer,\n        renderTargetOptions: this._renderTargetOptions\n      });\n    }\n    /**\n    * @private\n    * @param quadRenderer\n    * @param metadata\n    * @param sdrBuffer\n    * @param gainMapBuffer\n    */\n  }, {\n    key: \"render\",\n    value: function () {\n      var _render = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(quadRenderer, metadata, sdrBuffer, gainMapBuffer) {\n        var gainMapBlob, sdrBlob, sdrImage, gainMapImage, needsFlip, res, _res, gainMap, sdr;\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) switch (_context2.prev = _context2.next) {\n            case 0:\n              // this is optional, will render a black gain-map if not present\n              gainMapBlob = gainMapBuffer ? new Blob([gainMapBuffer], {\n                type: 'image/jpeg'\n              }) : undefined;\n              sdrBlob = new Blob([sdrBuffer], {\n                type: 'image/jpeg'\n              });\n              needsFlip = false;\n              if (!(typeof createImageBitmap === 'undefined')) {\n                _context2.next = 12;\n                break;\n              }\n              _context2.next = 6;\n              return Promise.all([gainMapBlob ? getHTMLImageFromBlob(gainMapBlob) : Promise.resolve(undefined), getHTMLImageFromBlob(sdrBlob)]);\n            case 6:\n              res = _context2.sent;\n              gainMapImage = res[0];\n              sdrImage = res[1];\n              needsFlip = true;\n              _context2.next = 17;\n              break;\n            case 12:\n              _context2.next = 14;\n              return Promise.all([gainMapBlob ? createImageBitmap(gainMapBlob, {\n                imageOrientation: 'flipY'\n              }) : Promise.resolve(undefined), createImageBitmap(sdrBlob, {\n                imageOrientation: 'flipY'\n              })]);\n            case 14:\n              _res = _context2.sent;\n              gainMapImage = _res[0];\n              sdrImage = _res[1];\n            case 17:\n              gainMap = new Texture(gainMapImage || new ImageData(2, 2), UVMapping, ClampToEdgeWrapping, ClampToEdgeWrapping, LinearFilter, LinearMipMapLinearFilter, RGBAFormat, UnsignedByteType, 1, LinearSRGBColorSpace);\n              gainMap.flipY = needsFlip;\n              gainMap.needsUpdate = true;\n              sdr = new Texture(sdrImage, UVMapping, ClampToEdgeWrapping, ClampToEdgeWrapping, LinearFilter, LinearMipMapLinearFilter, RGBAFormat, UnsignedByteType, 1, SRGBColorSpace);\n              sdr.flipY = needsFlip;\n              sdr.needsUpdate = true;\n              quadRenderer.width = sdrImage.width;\n              quadRenderer.height = sdrImage.height;\n              quadRenderer.material.gainMap = gainMap;\n              quadRenderer.material.sdr = sdr;\n              quadRenderer.material.gainMapMin = metadata.gainMapMin;\n              quadRenderer.material.gainMapMax = metadata.gainMapMax;\n              quadRenderer.material.offsetHdr = metadata.offsetHdr;\n              quadRenderer.material.offsetSdr = metadata.offsetSdr;\n              quadRenderer.material.gamma = metadata.gamma;\n              quadRenderer.material.hdrCapacityMin = metadata.hdrCapacityMin;\n              quadRenderer.material.hdrCapacityMax = metadata.hdrCapacityMax;\n              quadRenderer.material.maxDisplayBoost = Math.pow(2, metadata.hdrCapacityMax);\n              quadRenderer.material.needsUpdate = true;\n              quadRenderer.render();\n            case 37:\n            case \"end\":\n              return _context2.stop();\n          }\n        }, _callee2);\n      }));\n      function render(_x2, _x3, _x4, _x5) {\n        return _render.apply(this, arguments);\n      }\n      return render;\n    }()\n  }]);\n  return LoaderBase;\n}(Loader);\n/**\n * A Three.js Loader for the gain map format.\n *\n * @category Loaders\n * @group Loaders\n *\n * @example\n * import { GainMapLoader } from '@monogrid/gainmap-js'\n * import {\n *   EquirectangularReflectionMapping,\n *   LinearFilter,\n *   Mesh,\n *   MeshBasicMaterial,\n *   PerspectiveCamera,\n *   PlaneGeometry,\n *   Scene,\n *   WebGLRenderer\n * } from 'three'\n *\n * const renderer = new WebGLRenderer()\n *\n * const loader = new GainMapLoader(renderer)\n *\n * const result = await loader.loadAsync(['sdr.jpeg', 'gainmap.jpeg', 'metadata.json'])\n * // `result` can be used to populate a Texture\n *\n * const scene = new Scene()\n * const mesh = new Mesh(\n *   new PlaneGeometry(),\n *   new MeshBasicMaterial({ map: result.renderTarget.texture })\n * )\n * scene.add(mesh)\n * renderer.render(scene, new PerspectiveCamera())\n *\n * // Starting from three.js r159\n * // `result.renderTarget.texture` can\n * // also be used as Equirectangular scene background\n * //\n * // it was previously needed to convert it\n * // to a DataTexture with `result.toDataTexture()`\n * scene.background = result.renderTarget.texture\n * scene.background.mapping = EquirectangularReflectionMapping\n *\n * // result must be manually disposed\n * // when you are done using it\n * result.dispose()\n *\n */\nvar GainMapLoader = /*#__PURE__*/function (_LoaderBase) {\n  _inherits(GainMapLoader, _LoaderBase);\n  var _super5 = _createSuper(GainMapLoader);\n  function GainMapLoader() {\n    _classCallCheck(this, GainMapLoader);\n    return _super5.apply(this, arguments);\n  }\n  _createClass(GainMapLoader, [{\n    key: \"load\",\n    value:\n    /**\n     * Loads a gainmap using separate data\n     * * sdr image\n     * * gain map image\n     * * metadata json\n     *\n     * useful for webp gain maps\n     *\n     * @param urls An array in the form of [sdr.jpg, gainmap.jpg, metadata.json]\n     * @param onLoad Load complete callback, will receive the result\n     * @param onProgress Progress callback, will receive a {@link ProgressEvent}\n     * @param onError Error callback\n     * @returns\n     */\n    function load(_ref3, onLoad, onProgress, onError) {\n      var _this4 = this;\n      var _ref4 = _slicedToArray(_ref3, 3),\n        sdrUrl = _ref4[0],\n        gainMapUrl = _ref4[1],\n        metadataUrl = _ref4[2];\n      var quadRenderer = this.prepareQuadRenderer();\n      var sdr;\n      var gainMap;\n      var metadata;\n      var loadCheck = /*#__PURE__*/function () {\n        var _ref5 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {\n          return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n            while (1) switch (_context3.prev = _context3.next) {\n              case 0:\n                if (!(sdr && gainMap && metadata)) {\n                  _context3.next = 19;\n                  break;\n                }\n                _context3.prev = 1;\n                _context3.next = 4;\n                return _this4.render(quadRenderer, metadata, sdr, gainMap);\n              case 4:\n                _context3.next = 14;\n                break;\n              case 6:\n                _context3.prev = 6;\n                _context3.t0 = _context3[\"catch\"](1);\n                _this4.manager.itemError(sdrUrl);\n                _this4.manager.itemError(gainMapUrl);\n                _this4.manager.itemError(metadataUrl);\n                if (typeof onError === 'function') onError(_context3.t0);\n                quadRenderer.disposeOnDemandRenderer();\n                return _context3.abrupt(\"return\");\n              case 14:\n                if (typeof onLoad === 'function') onLoad(quadRenderer);\n                _this4.manager.itemEnd(sdrUrl);\n                _this4.manager.itemEnd(gainMapUrl);\n                _this4.manager.itemEnd(metadataUrl);\n                quadRenderer.disposeOnDemandRenderer();\n              case 19:\n              case \"end\":\n                return _context3.stop();\n            }\n          }, _callee3, null, [[1, 6]]);\n        }));\n        return function loadCheck() {\n          return _ref5.apply(this, arguments);\n        };\n      }();\n      var sdrLengthComputable = true;\n      var sdrTotal = 0;\n      var sdrLoaded = 0;\n      var gainMapLengthComputable = true;\n      var gainMapTotal = 0;\n      var gainMapLoaded = 0;\n      var metadataLengthComputable = true;\n      var metadataTotal = 0;\n      var metadataLoaded = 0;\n      var progressHandler = function progressHandler() {\n        if (typeof onProgress === 'function') {\n          var total = sdrTotal + gainMapTotal + metadataTotal;\n          var loaded = sdrLoaded + gainMapLoaded + metadataLoaded;\n          var lengthComputable = sdrLengthComputable && gainMapLengthComputable && metadataLengthComputable;\n          onProgress(new ProgressEvent('progress', {\n            lengthComputable: lengthComputable,\n            loaded: loaded,\n            total: total\n          }));\n        }\n      };\n      this.manager.itemStart(sdrUrl);\n      this.manager.itemStart(gainMapUrl);\n      this.manager.itemStart(metadataUrl);\n      var sdrLoader = new FileLoader(this._internalLoadingManager);\n      sdrLoader.setResponseType('arraybuffer');\n      sdrLoader.setRequestHeader(this.requestHeader);\n      sdrLoader.setPath(this.path);\n      sdrLoader.setWithCredentials(this.withCredentials);\n      sdrLoader.load(sdrUrl, /*#__PURE__*/function () {\n        var _ref6 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(buffer) {\n          return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n            while (1) switch (_context4.prev = _context4.next) {\n              case 0:\n                if (!(typeof buffer === 'string')) {\n                  _context4.next = 2;\n                  break;\n                }\n                throw new Error('Invalid sdr buffer');\n              case 2:\n                sdr = buffer;\n                _context4.next = 5;\n                return loadCheck();\n              case 5:\n              case \"end\":\n                return _context4.stop();\n            }\n          }, _callee4);\n        }));\n        return function (_x6) {\n          return _ref6.apply(this, arguments);\n        };\n      }(), function (e) {\n        sdrLengthComputable = e.lengthComputable;\n        sdrLoaded = e.loaded;\n        sdrTotal = e.total;\n        progressHandler();\n      }, function (error) {\n        _this4.manager.itemError(sdrUrl);\n        if (typeof onError === 'function') onError(error);\n      });\n      var gainMapLoader = new FileLoader(this._internalLoadingManager);\n      gainMapLoader.setResponseType('arraybuffer');\n      gainMapLoader.setRequestHeader(this.requestHeader);\n      gainMapLoader.setPath(this.path);\n      gainMapLoader.setWithCredentials(this.withCredentials);\n      gainMapLoader.load(gainMapUrl, /*#__PURE__*/function () {\n        var _ref7 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(buffer) {\n          return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n            while (1) switch (_context5.prev = _context5.next) {\n              case 0:\n                if (!(typeof buffer === 'string')) {\n                  _context5.next = 2;\n                  break;\n                }\n                throw new Error('Invalid gainmap buffer');\n              case 2:\n                gainMap = buffer;\n                _context5.next = 5;\n                return loadCheck();\n              case 5:\n              case \"end\":\n                return _context5.stop();\n            }\n          }, _callee5);\n        }));\n        return function (_x7) {\n          return _ref7.apply(this, arguments);\n        };\n      }(), function (e) {\n        gainMapLengthComputable = e.lengthComputable;\n        gainMapLoaded = e.loaded;\n        gainMapTotal = e.total;\n        progressHandler();\n      }, function (error) {\n        _this4.manager.itemError(gainMapUrl);\n        if (typeof onError === 'function') onError(error);\n      });\n      var metadataLoader = new FileLoader(this._internalLoadingManager);\n      // metadataLoader.setResponseType('json')\n      metadataLoader.setRequestHeader(this.requestHeader);\n      metadataLoader.setPath(this.path);\n      metadataLoader.setWithCredentials(this.withCredentials);\n      metadataLoader.load(metadataUrl, /*#__PURE__*/function () {\n        var _ref8 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(json) {\n          return _regeneratorRuntime().wrap(function _callee6$(_context6) {\n            while (1) switch (_context6.prev = _context6.next) {\n              case 0:\n                if (!(typeof json !== 'string')) {\n                  _context6.next = 2;\n                  break;\n                }\n                throw new Error('Invalid metadata string');\n              case 2:\n                // TODO: implement check on JSON file and remove this eslint disable\n                // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n                metadata = JSON.parse(json);\n                _context6.next = 5;\n                return loadCheck();\n              case 5:\n              case \"end\":\n                return _context6.stop();\n            }\n          }, _callee6);\n        }));\n        return function (_x8) {\n          return _ref8.apply(this, arguments);\n        };\n      }(), function (e) {\n        metadataLengthComputable = e.lengthComputable;\n        metadataLoaded = e.loaded;\n        metadataTotal = e.total;\n        progressHandler();\n      }, function (error) {\n        _this4.manager.itemError(metadataUrl);\n        if (typeof onError === 'function') onError(error);\n      });\n      return quadRenderer;\n    }\n  }]);\n  return GainMapLoader;\n}(LoaderBase);\n/**\n * A Three.js Loader for a JPEG with embedded gainmap metadata.\n *\n * @category Loaders\n * @group Loaders\n *\n * @example\n * import { HDRJPGLoader } from '@monogrid/gainmap-js'\n * import {\n *   EquirectangularReflectionMapping,\n *   LinearFilter,\n *   Mesh,\n *   MeshBasicMaterial,\n *   PerspectiveCamera,\n *   PlaneGeometry,\n *   Scene,\n *   WebGLRenderer\n * } from 'three'\n *\n * const renderer = new WebGLRenderer()\n *\n * const loader = new HDRJPGLoader(renderer)\n *\n * const result = await loader.loadAsync('gainmap.jpeg')\n * // `result` can be used to populate a Texture\n *\n * const scene = new Scene()\n * const mesh = new Mesh(\n *   new PlaneGeometry(),\n *   new MeshBasicMaterial({ map: result.renderTarget.texture })\n * )\n * scene.add(mesh)\n * renderer.render(scene, new PerspectiveCamera())\n *\n * // Starting from three.js r159\n * // `result.renderTarget.texture` can\n * // also be used as Equirectangular scene background\n * //\n * // it was previously needed to convert it\n * // to a DataTexture with `result.toDataTexture()`\n * scene.background = result.renderTarget.texture\n * scene.background.mapping = EquirectangularReflectionMapping\n *\n * // result must be manually disposed\n * // when you are done using it\n * result.dispose()\n *\n */\nvar HDRJPGLoader = /*#__PURE__*/function (_LoaderBase2) {\n  _inherits(HDRJPGLoader, _LoaderBase2);\n  var _super6 = _createSuper(HDRJPGLoader);\n  function HDRJPGLoader() {\n    _classCallCheck(this, HDRJPGLoader);\n    return _super6.apply(this, arguments);\n  }\n  _createClass(HDRJPGLoader, [{\n    key: \"load\",\n    value:\n    /**\n     * Loads a JPEG containing gain map metadata\n     * Renders a normal SDR image if gainmap data is not found\n     *\n     * @param url An array in the form of [sdr.jpg, gainmap.jpg, metadata.json]\n     * @param onLoad Load complete callback, will receive the result\n     * @param onProgress Progress callback, will receive a {@link ProgressEvent}\n     * @param onError Error callback\n     * @returns\n     */\n    function load(url, onLoad, onProgress, onError) {\n      var _this5 = this;\n      var quadRenderer = this.prepareQuadRenderer();\n      var loader = new FileLoader(this._internalLoadingManager);\n      loader.setResponseType('arraybuffer');\n      loader.setRequestHeader(this.requestHeader);\n      loader.setPath(this.path);\n      loader.setWithCredentials(this.withCredentials);\n      this.manager.itemStart(url);\n      loader.load(url, /*#__PURE__*/function () {\n        var _ref9 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7(jpeg) {\n          var jpegBuffer, sdrJPEG, gainMapJPEG, metadata, extractionResult;\n          return _regeneratorRuntime().wrap(function _callee7$(_context7) {\n            while (1) switch (_context7.prev = _context7.next) {\n              case 0:\n                if (!(typeof jpeg === 'string')) {\n                  _context7.next = 2;\n                  break;\n                }\n                throw new Error('Invalid buffer, received [string], was expecting [ArrayBuffer]');\n              case 2:\n                jpegBuffer = new Uint8Array(jpeg);\n                _context7.prev = 3;\n                _context7.next = 6;\n                return extractGainmapFromJPEG(jpegBuffer);\n              case 6:\n                extractionResult = _context7.sent;\n                // gain map is successfully reconstructed\n                sdrJPEG = extractionResult.sdr;\n                gainMapJPEG = extractionResult.gainMap;\n                metadata = extractionResult.metadata;\n                _context7.next = 21;\n                break;\n              case 12:\n                _context7.prev = 12;\n                _context7.t0 = _context7[\"catch\"](3);\n                if (!(_context7.t0 instanceof XMPMetadataNotFoundError || _context7.t0 instanceof GainMapNotFoundError)) {\n                  _context7.next = 20;\n                  break;\n                }\n                console.warn(\"Failure to reconstruct an HDR image from \".concat(url, \": Gain map metadata not found in the file, HDRJPGLoader will render the SDR jpeg\"));\n                metadata = {\n                  gainMapMin: [0, 0, 0],\n                  gainMapMax: [1, 1, 1],\n                  gamma: [1, 1, 1],\n                  hdrCapacityMin: 0,\n                  hdrCapacityMax: 1,\n                  offsetHdr: [0, 0, 0],\n                  offsetSdr: [0, 0, 0]\n                };\n                sdrJPEG = jpegBuffer;\n                _context7.next = 21;\n                break;\n              case 20:\n                throw _context7.t0;\n              case 21:\n                _context7.prev = 21;\n                _context7.next = 24;\n                return _this5.render(quadRenderer, metadata, sdrJPEG, gainMapJPEG);\n              case 24:\n                _context7.next = 32;\n                break;\n              case 26:\n                _context7.prev = 26;\n                _context7.t1 = _context7[\"catch\"](21);\n                _this5.manager.itemError(url);\n                if (typeof onError === 'function') onError(_context7.t1);\n                quadRenderer.disposeOnDemandRenderer();\n                return _context7.abrupt(\"return\");\n              case 32:\n                if (typeof onLoad === 'function') onLoad(quadRenderer);\n                _this5.manager.itemEnd(url);\n                quadRenderer.disposeOnDemandRenderer();\n              case 35:\n              case \"end\":\n                return _context7.stop();\n            }\n          }, _callee7, null, [[3, 12], [21, 26]]);\n        }));\n        return function (_x9) {\n          return _ref9.apply(this, arguments);\n        };\n      }(), onProgress, function (error) {\n        _this5.manager.itemError(url);\n        if (typeof onError === 'function') onError(error);\n      });\n      return quadRenderer;\n    }\n  }]);\n  return HDRJPGLoader;\n}(LoaderBase);\nexport { GainMapDecoderMaterial, GainMapLoader, HDRJPGLoader, HDRJPGLoader as JPEGRLoader, MPFExtractor, QuadRenderer, decode, extractGainmapFromJPEG, extractXMP };","map":{"version":3,"names":["Q","QuadRenderer","ShaderMaterial","Vector3","NoBlending","SRGBColorSpace","LinearSRGBColorSpace","HalfFloatType","Loader","LoadingManager","Texture","UVMapping","ClampToEdgeWrapping","LinearFilter","LinearMipMapLinearFilter","RGBAFormat","UnsignedByteType","FileLoader","vertexShader","fragmentShader","GainMapDecoderMaterial","_ShaderMaterial","_inherits","_super","_createSuper","_ref","_this","gamma","offsetHdr","offsetSdr","gainMapMin","gainMapMax","maxDisplayBoost","hdrCapacityMin","hdrCapacityMax","sdr","gainMap","_classCallCheck","call","name","uniforms","value","fromArray","weightFactor","Math","log2","blending","depthTest","depthWrite","_maxDisplayBoost","_hdrCapacityMin","_hdrCapacityMax","needsUpdate","uniformsNeedUpdate","_createClass","key","get","set","toArray","g","x","y","z","calculateWeight","max","min","val","decode","params","renderer","colorSpace","console","warn","material","_objectSpread","quadRenderer","width","image","height","type","renderTargetOptions","render","e","disposeOnDemandRenderer","GainMapNotFoundError","_Error","_super2","apply","arguments","_wrapNativeSuper","Error","XMPMetadataNotFoundError","_Error2","_super3","getAttribute","description","defaultValue","_a","returnValue","parsedValue","attributes","getNamedItem","nodeValue","node","getElementsByTagName","values","length","Array","from","map","v","innerHTML","concat","extractXMP","input","_b","str","TextDecoder","toString","start","indexOf","parser","DOMParser","end","slice","xmpBlock","xmlDocument","parseFromString","offsetSDR","offsetHDR","isArray","parseFloat","MPFExtractor","options","debug","undefined","extractFII","extractNonFII","extract","imageArrayBuffer","_this2","Promise","resolve","reject","dataView","DataView","buffer","getUint16","byteLength","offset","loops","marker","getUint8","log","formatPt","getUint32","tiffOffset","bigEnd","firstIFDOffset","dirStart","count","entriesStart","numberOfImages","i","nextIFDOffsetLen","MPImageListValPt","images","MPType","size","dataOffset","dependantImages","isFII","push","bufferBlob","Blob","imgs","_iterator","_createForOfIteratorHelper","_step","s","n","done","imageBlob","err","f","extractGainmapFromJPEG","_ref2","_asyncToGenerator","_regeneratorRuntime","mark","_callee","jpegFile","metadata","mpfExtractor","wrap","_callee$","_context","prev","next","sent","t0","Uint8Array","arrayBuffer","t1","t2","t3","t4","t5","t6","abrupt","stop","_x","getHTMLImageFromBlob","blob","img","document","createElement","onload","onerror","src","URL","createObjectURL","LoaderBase","_Loader","_super4","manager","_this3","_renderer","_internalLoadingManager","setRenderer","setRenderTargetOptions","_renderTargetOptions","prepareQuadRenderer","_render","_callee2","sdrBuffer","gainMapBuffer","gainMapBlob","sdrBlob","sdrImage","gainMapImage","needsFlip","res","_res","_callee2$","_context2","createImageBitmap","all","imageOrientation","ImageData","flipY","pow","_x2","_x3","_x4","_x5","GainMapLoader","_LoaderBase","_super5","load","_ref3","onLoad","onProgress","onError","_this4","_ref4","_slicedToArray","sdrUrl","gainMapUrl","metadataUrl","loadCheck","_ref5","_callee3","_callee3$","_context3","itemError","itemEnd","sdrLengthComputable","sdrTotal","sdrLoaded","gainMapLengthComputable","gainMapTotal","gainMapLoaded","metadataLengthComputable","metadataTotal","metadataLoaded","progressHandler","total","loaded","lengthComputable","ProgressEvent","itemStart","sdrLoader","setResponseType","setRequestHeader","requestHeader","setPath","path","setWithCredentials","withCredentials","_ref6","_callee4","_callee4$","_context4","_x6","error","gainMapLoader","_ref7","_callee5","_callee5$","_context5","_x7","metadataLoader","_ref8","_callee6","json","_callee6$","_context6","JSON","parse","_x8","HDRJPGLoader","_LoaderBase2","_super6","url","_this5","loader","_ref9","_callee7","jpeg","jpegBuffer","sdrJPEG","gainMapJPEG","extractionResult","_callee7$","_context7","_x9","JPEGRLoader"],"sources":["C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@monogrid/gainmap-js/dist/decode.js"],"sourcesContent":["/**\n * @monogrid/gainmap-js v3.0.5\n * With ❤️, by MONOGRID <rnd@monogrid.com>\n */\n\nimport { Q as QuadRenderer } from './QuadRenderer-6HrRQdJM.js';\nimport { ShaderMaterial, Vector3, NoBlending, SRGBColorSpace, LinearSRGBColorSpace, HalfFloatType, Loader, LoadingManager, Texture, UVMapping, ClampToEdgeWrapping, LinearFilter, LinearMipMapLinearFilter, RGBAFormat, UnsignedByteType, FileLoader } from 'three';\n\nconst vertexShader = /* glsl */ `\nvarying vec2 vUv;\n\nvoid main() {\n  vUv = uv;\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n`;\nconst fragmentShader = /* glsl */ `\n// min half float value\n#define HALF_FLOAT_MIN vec3( -65504, -65504, -65504 )\n// max half float value\n#define HALF_FLOAT_MAX vec3( 65504, 65504, 65504 )\n\nuniform sampler2D sdr;\nuniform sampler2D gainMap;\nuniform vec3 gamma;\nuniform vec3 offsetHdr;\nuniform vec3 offsetSdr;\nuniform vec3 gainMapMin;\nuniform vec3 gainMapMax;\nuniform float weightFactor;\n\nvarying vec2 vUv;\n\nvoid main() {\n  vec3 rgb = texture2D( sdr, vUv ).rgb;\n  vec3 recovery = texture2D( gainMap, vUv ).rgb;\n  vec3 logRecovery = pow( recovery, gamma );\n  vec3 logBoost = gainMapMin * ( 1.0 - logRecovery ) + gainMapMax * logRecovery;\n  vec3 hdrColor = (rgb + offsetSdr) * exp2( logBoost * weightFactor ) - offsetHdr;\n  vec3 clampedHdrColor = max( HALF_FLOAT_MIN, min( HALF_FLOAT_MAX, hdrColor ));\n  gl_FragColor = vec4( clampedHdrColor , 1.0 );\n}\n`;\n/**\n * A Material which is able to decode the Gainmap into a full HDR Representation\n *\n * @category Materials\n * @group Materials\n */\nclass GainMapDecoderMaterial extends ShaderMaterial {\n    /**\n     *\n     * @param params\n     */\n    constructor({ gamma, offsetHdr, offsetSdr, gainMapMin, gainMapMax, maxDisplayBoost, hdrCapacityMin, hdrCapacityMax, sdr, gainMap }) {\n        super({\n            name: 'GainMapDecoderMaterial',\n            vertexShader,\n            fragmentShader,\n            uniforms: {\n                sdr: { value: sdr },\n                gainMap: { value: gainMap },\n                gamma: { value: new Vector3(1.0 / gamma[0], 1.0 / gamma[1], 1.0 / gamma[2]) },\n                offsetHdr: { value: new Vector3().fromArray(offsetHdr) },\n                offsetSdr: { value: new Vector3().fromArray(offsetSdr) },\n                gainMapMin: { value: new Vector3().fromArray(gainMapMin) },\n                gainMapMax: { value: new Vector3().fromArray(gainMapMax) },\n                weightFactor: {\n                    value: (Math.log2(maxDisplayBoost) - hdrCapacityMin) / (hdrCapacityMax - hdrCapacityMin)\n                }\n            },\n            blending: NoBlending,\n            depthTest: false,\n            depthWrite: false\n        });\n        this._maxDisplayBoost = maxDisplayBoost;\n        this._hdrCapacityMin = hdrCapacityMin;\n        this._hdrCapacityMax = hdrCapacityMax;\n        this.needsUpdate = true;\n        this.uniformsNeedUpdate = true;\n    }\n    get sdr() { return this.uniforms.sdr.value; }\n    set sdr(value) { this.uniforms.sdr.value = value; }\n    get gainMap() { return this.uniforms.gainMap.value; }\n    set gainMap(value) { this.uniforms.gainMap.value = value; }\n    /**\n     * @see {@link GainMapMetadata.offsetHdr}\n     */\n    get offsetHdr() { return this.uniforms.offsetHdr.value.toArray(); }\n    set offsetHdr(value) { this.uniforms.offsetHdr.value.fromArray(value); }\n    /**\n     * @see {@link GainMapMetadata.offsetSdr}\n     */\n    get offsetSdr() { return this.uniforms.offsetSdr.value.toArray(); }\n    set offsetSdr(value) { this.uniforms.offsetSdr.value.fromArray(value); }\n    /**\n     * @see {@link GainMapMetadata.gainMapMin}\n     */\n    get gainMapMin() { return this.uniforms.gainMapMin.value.toArray(); }\n    set gainMapMin(value) { this.uniforms.gainMapMin.value.fromArray(value); }\n    /**\n     * @see {@link GainMapMetadata.gainMapMax}\n     */\n    get gainMapMax() { return this.uniforms.gainMapMax.value.toArray(); }\n    set gainMapMax(value) { this.uniforms.gainMapMax.value.fromArray(value); }\n    /**\n     * @see {@link GainMapMetadata.gamma}\n     */\n    get gamma() {\n        const g = this.uniforms.gamma.value;\n        return [1 / g.x, 1 / g.y, 1 / g.z];\n    }\n    set gamma(value) {\n        const g = this.uniforms.gamma.value;\n        g.x = 1.0 / value[0];\n        g.y = 1.0 / value[1];\n        g.z = 1.0 / value[2];\n    }\n    /**\n     * @see {@link GainMapMetadata.hdrCapacityMin}\n     * @remarks Logarithmic space\n     */\n    get hdrCapacityMin() { return this._hdrCapacityMin; }\n    set hdrCapacityMin(value) {\n        this._hdrCapacityMin = value;\n        this.calculateWeight();\n    }\n    /**\n     * @see {@link GainMapMetadata.hdrCapacityMin}\n     * @remarks Logarithmic space\n     */\n    get hdrCapacityMax() { return this._hdrCapacityMax; }\n    set hdrCapacityMax(value) {\n        this._hdrCapacityMax = value;\n        this.calculateWeight();\n    }\n    /**\n     * @see {@link GainmapDecodingParameters.maxDisplayBoost}\n     * @remarks Non Logarithmic space\n     */\n    get maxDisplayBoost() { return this._maxDisplayBoost; }\n    set maxDisplayBoost(value) {\n        this._maxDisplayBoost = Math.max(1, Math.min(65504, value));\n        this.calculateWeight();\n    }\n    calculateWeight() {\n        const val = (Math.log2(this._maxDisplayBoost) - this._hdrCapacityMin) / (this._hdrCapacityMax - this._hdrCapacityMin);\n        this.uniforms.weightFactor.value = Math.max(0, Math.min(1, val));\n    }\n}\n\n/**\n * Decodes a gain map using a WebGLRenderTarget\n *\n * @category Decoding Functions\n * @group Decoding Functions\n * @example\n * import { decode } from '@monogrid/gainmap-js'\n * import {\n *   Mesh,\n *   MeshBasicMaterial,\n *   PerspectiveCamera,\n *   PlaneGeometry,\n *   Scene,\n *   TextureLoader,\n *   WebGLRenderer\n * } from 'three'\n *\n * const renderer = new WebGLRenderer()\n *\n * const textureLoader = new TextureLoader()\n *\n * // load SDR Representation\n * const sdr = await textureLoader.loadAsync('sdr.jpg')\n * // load Gain map recovery image\n * const gainMap = await textureLoader.loadAsync('gainmap.jpg')\n * // load metadata\n * const metadata = await (await fetch('metadata.json')).json()\n *\n * const result = await decode({\n *   sdr,\n *   gainMap,\n *   // this allows to use `result.renderTarget.texture` directly\n *   renderer,\n *   // this will restore the full HDR range\n *   maxDisplayBoost: Math.pow(2, metadata.hdrCapacityMax),\n *   ...metadata\n * })\n *\n * const scene = new Scene()\n * // `result` can be used to populate a Texture\n * const mesh = new Mesh(\n *   new PlaneGeometry(),\n *   new MeshBasicMaterial({ map: result.renderTarget.texture })\n * )\n * scene.add(mesh)\n * renderer.render(scene, new PerspectiveCamera())\n *\n * // result must be manually disposed\n * // when you are done using it\n * result.dispose()\n *\n * @param params\n * @returns\n * @throws {Error} if the WebGLRenderer fails to render the gain map\n */\nconst decode = (params) => {\n    const { sdr, gainMap, renderer } = params;\n    if (sdr.colorSpace !== SRGBColorSpace) {\n        console.warn('SDR Colorspace needs to be *SRGBColorSpace*, setting it automatically');\n        sdr.colorSpace = SRGBColorSpace;\n    }\n    sdr.needsUpdate = true;\n    if (gainMap.colorSpace !== LinearSRGBColorSpace) {\n        console.warn('Gainmap Colorspace needs to be *LinearSRGBColorSpace*, setting it automatically');\n        gainMap.colorSpace = LinearSRGBColorSpace;\n    }\n    gainMap.needsUpdate = true;\n    const material = new GainMapDecoderMaterial({\n        ...params,\n        sdr,\n        gainMap\n    });\n    const quadRenderer = new QuadRenderer({\n        // TODO: three types are generic, eslint complains here, see how we can solve\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-member-access\n        width: sdr.image.width,\n        // TODO: three types are generic, eslint complains here, see how we can solve\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-member-access\n        height: sdr.image.height,\n        type: HalfFloatType,\n        colorSpace: LinearSRGBColorSpace,\n        material,\n        renderer,\n        renderTargetOptions: params.renderTargetOptions\n    });\n    try {\n        quadRenderer.render();\n    }\n    catch (e) {\n        quadRenderer.disposeOnDemandRenderer();\n        throw e;\n    }\n    return quadRenderer;\n};\n\nclass GainMapNotFoundError extends Error {\n}\n\nclass XMPMetadataNotFoundError extends Error {\n}\n\nconst getAttribute = (description, name, defaultValue) => {\n    var _a;\n    let returnValue;\n    const parsedValue = (_a = description.attributes.getNamedItem(name)) === null || _a === void 0 ? void 0 : _a.nodeValue;\n    if (!parsedValue) {\n        const node = description.getElementsByTagName(name)[0];\n        if (node) {\n            const values = node.getElementsByTagName('rdf:li');\n            if (values.length === 3) {\n                returnValue = Array.from(values).map(v => v.innerHTML);\n            }\n            else {\n                throw new Error(`Gainmap metadata contains an array of items for ${name} but its length is not 3`);\n            }\n        }\n        else {\n            if (defaultValue)\n                return defaultValue;\n            else\n                throw new Error(`Can't find ${name} in gainmap metadata`);\n        }\n    }\n    else {\n        returnValue = parsedValue;\n    }\n    return returnValue;\n};\n/**\n *\n * @param input\n * @returns\n */\nconst extractXMP = (input) => {\n    var _a, _b;\n    let str;\n    // support node test environment\n    if (typeof TextDecoder !== 'undefined')\n        str = new TextDecoder().decode(input);\n    else\n        str = input.toString();\n    let start = str.indexOf('<x:xmpmeta');\n    const parser = new DOMParser();\n    while (start !== -1) {\n        const end = str.indexOf('x:xmpmeta>', start);\n        str.slice(start, end + 10);\n        const xmpBlock = str.slice(start, end + 10);\n        try {\n            const xmlDocument = parser.parseFromString(xmpBlock, 'text/xml');\n            const description = xmlDocument.getElementsByTagName('rdf:Description')[0];\n            const gainMapMin = getAttribute(description, 'hdrgm:GainMapMin', '0');\n            const gainMapMax = getAttribute(description, 'hdrgm:GainMapMax');\n            const gamma = getAttribute(description, 'hdrgm:Gamma', '1');\n            const offsetSDR = getAttribute(description, 'hdrgm:OffsetSDR', '0.015625');\n            const offsetHDR = getAttribute(description, 'hdrgm:OffsetHDR', '0.015625');\n            let hdrCapacityMin = (_a = description.attributes.getNamedItem('hdrgm:HDRCapacityMin')) === null || _a === void 0 ? void 0 : _a.nodeValue;\n            if (!hdrCapacityMin)\n                hdrCapacityMin = '0';\n            const hdrCapacityMax = (_b = description.attributes.getNamedItem('hdrgm:HDRCapacityMax')) === null || _b === void 0 ? void 0 : _b.nodeValue;\n            if (!hdrCapacityMax)\n                throw new Error('Incomplete gainmap metadata');\n            return {\n                gainMapMin: Array.isArray(gainMapMin) ? gainMapMin.map(v => parseFloat(v)) : [parseFloat(gainMapMin), parseFloat(gainMapMin), parseFloat(gainMapMin)],\n                gainMapMax: Array.isArray(gainMapMax) ? gainMapMax.map(v => parseFloat(v)) : [parseFloat(gainMapMax), parseFloat(gainMapMax), parseFloat(gainMapMax)],\n                gamma: Array.isArray(gamma) ? gamma.map(v => parseFloat(v)) : [parseFloat(gamma), parseFloat(gamma), parseFloat(gamma)],\n                offsetSdr: Array.isArray(offsetSDR) ? offsetSDR.map(v => parseFloat(v)) : [parseFloat(offsetSDR), parseFloat(offsetSDR), parseFloat(offsetSDR)],\n                offsetHdr: Array.isArray(offsetHDR) ? offsetHDR.map(v => parseFloat(v)) : [parseFloat(offsetHDR), parseFloat(offsetHDR), parseFloat(offsetHDR)],\n                hdrCapacityMin: parseFloat(hdrCapacityMin),\n                hdrCapacityMax: parseFloat(hdrCapacityMax)\n            };\n        }\n        catch (e) {\n        }\n        start = str.indexOf('<x:xmpmeta', end);\n    }\n};\n\n/**\n * MPF Extractor (Multi Picture Format Extractor)\n * By Henrik S Nilsson 2019\n *\n * Extracts images stored in images based on the MPF format (found here: https://www.cipa.jp/e/std/std-sec.html\n * under \"CIPA DC-007-Translation-2021 Multi-Picture Format\"\n *\n * Overly commented, and without intention of being complete or production ready.\n * Created to extract depth maps from iPhone images, and to learn about image metadata.\n * Kudos to: Phil Harvey (exiftool), Jaume Sanchez (android-lens-blur-depth-extractor)\n */\nclass MPFExtractor {\n    constructor(options) {\n        this.options = {\n            debug: options && options.debug !== undefined ? options.debug : false,\n            extractFII: options && options.extractFII !== undefined ? options.extractFII : true,\n            extractNonFII: options && options.extractNonFII !== undefined ? options.extractNonFII : true\n        };\n    }\n    extract(imageArrayBuffer) {\n        return new Promise((resolve, reject) => {\n            const debug = this.options.debug;\n            const dataView = new DataView(imageArrayBuffer.buffer);\n            // If you're executing this line on a big endian machine, it'll be reversed.\n            // bigEnd further down though, refers to the endianness of the image itself.\n            if (dataView.getUint16(0) !== 0xffd8) {\n                reject(new Error('Not a valid jpeg'));\n                return;\n            }\n            const length = dataView.byteLength;\n            let offset = 2;\n            let loops = 0;\n            let marker; // APP# marker\n            while (offset < length) {\n                if (++loops > 250) {\n                    reject(new Error(`Found no marker after ${loops} loops 😵`));\n                    return;\n                }\n                if (dataView.getUint8(offset) !== 0xff) {\n                    reject(new Error(`Not a valid marker at offset 0x${offset.toString(16)}, found: 0x${dataView.getUint8(offset).toString(16)}`));\n                    return;\n                }\n                marker = dataView.getUint8(offset + 1);\n                if (debug)\n                    console.log(`Marker: ${marker.toString(16)}`);\n                if (marker === 0xe2) {\n                    if (debug)\n                        console.log('Found APP2 marker (0xffe2)');\n                    // Works for iPhone 8 Plus, X, and XSMax. Or any photos of MPF format.\n                    // Great way to visualize image information in html is using Exiftool. E.g.:\n                    // ./exiftool.exe -htmldump -wantTrailer photo.jpg > photo.html\n                    const formatPt = offset + 4;\n                    /*\n                     *  Structure of the MP Format Identifier\n                     *\n                     *  Offset Addr.  | Code (Hex)  | Description\n                     *  +00             ff            Marker Prefix      <-- offset\n                     *  +01             e2            APP2\n                     *  +02             #n            APP2 Field Length\n                     *  +03             #n            APP2 Field Length\n                     *  +04             4d            'M'                <-- formatPt\n                     *  +05             50            'P'\n                     *  +06             46            'F'\n                     *  +07             00            NULL\n                     *                                                   <-- tiffOffset\n                     */\n                    if (dataView.getUint32(formatPt) === 0x4d504600) {\n                        // Found MPF tag, so we start dig out sub images\n                        const tiffOffset = formatPt + 4;\n                        let bigEnd; // Endianness from TIFF header\n                        // Test for TIFF validity and endianness\n                        // 0x4949 and 0x4D4D ('II' and 'MM') marks Little Endian and Big Endian\n                        if (dataView.getUint16(tiffOffset) === 0x4949) {\n                            bigEnd = false;\n                        }\n                        else if (dataView.getUint16(tiffOffset) === 0x4d4d) {\n                            bigEnd = true;\n                        }\n                        else {\n                            reject(new Error('No valid endianness marker found in TIFF header'));\n                            return;\n                        }\n                        if (dataView.getUint16(tiffOffset + 2, !bigEnd) !== 0x002a) {\n                            reject(new Error('Not valid TIFF data! (no 0x002A marker)'));\n                            return;\n                        }\n                        // 32 bit number stating the offset from the start of the 8 Byte MP Header\n                        // to MP Index IFD Least possible value is thus 8 (means 0 offset)\n                        const firstIFDOffset = dataView.getUint32(tiffOffset + 4, !bigEnd);\n                        if (firstIFDOffset < 0x00000008) {\n                            reject(new Error('Not valid TIFF data! (First offset less than 8)'));\n                            return;\n                        }\n                        // Move ahead to MP Index IFD\n                        // Assume we're at the first IFD, so firstIFDOffset points to\n                        // MP Index IFD and not MP Attributes IFD. (If we try extract from a sub image,\n                        // we fail silently here due to this assumption)\n                        // Count (2 Byte) | MP Index Fields a.k.a. MP Entries (count * 12 Byte) | Offset of Next IFD (4 Byte)\n                        const dirStart = tiffOffset + firstIFDOffset; // Start of IFD (Image File Directory)\n                        const count = dataView.getUint16(dirStart, !bigEnd); // Count of MPEntries (2 Byte)\n                        // Extract info from MPEntries (starting after Count)\n                        const entriesStart = dirStart + 2;\n                        let numberOfImages = 0;\n                        for (let i = entriesStart; i < entriesStart + 12 * count; i += 12) {\n                            // Each entry is 12 Bytes long\n                            // Check MP Index IFD tags, here we only take tag 0xb001 = Number of images\n                            if (dataView.getUint16(i, !bigEnd) === 0xb001) {\n                                // stored in Last 4 bytes of its 12 Byte entry.\n                                numberOfImages = dataView.getUint32(i + 8, !bigEnd);\n                            }\n                        }\n                        const nextIFDOffsetLen = 4; // 4 Byte offset field that appears after MP Index IFD tags\n                        const MPImageListValPt = dirStart + 2 + count * 12 + nextIFDOffsetLen;\n                        const images = [];\n                        for (let i = MPImageListValPt; i < MPImageListValPt + numberOfImages * 16; i += 16) {\n                            const image = {\n                                MPType: dataView.getUint32(i, !bigEnd),\n                                size: dataView.getUint32(i + 4, !bigEnd),\n                                // This offset is specified relative to the address of the MP Endian\n                                // field in the MP Header, unless the image is a First Individual Image,\n                                // in which case the value of the offset shall be NULL (0x00000000).\n                                dataOffset: dataView.getUint32(i + 8, !bigEnd),\n                                dependantImages: dataView.getUint32(i + 12, !bigEnd),\n                                start: -1,\n                                end: -1,\n                                isFII: false\n                            };\n                            if (!image.dataOffset) {\n                                // dataOffset is 0x00000000 for First Individual Image\n                                image.start = 0;\n                                image.isFII = true;\n                            }\n                            else {\n                                image.start = tiffOffset + image.dataOffset;\n                                image.isFII = false;\n                            }\n                            image.end = image.start + image.size;\n                            images.push(image);\n                        }\n                        if (this.options.extractNonFII && images.length) {\n                            const bufferBlob = new Blob([dataView]);\n                            const imgs = [];\n                            for (const image of images) {\n                                if (image.isFII && !this.options.extractFII) {\n                                    continue; // Skip FII\n                                }\n                                const imageBlob = bufferBlob.slice(image.start, image.end + 1, 'image/jpeg');\n                                // we don't need this\n                                // const imageUrl = URL.createObjectURL(imageBlob)\n                                // image.img = document.createElement('img')\n                                // image.img.src = imageUrl\n                                imgs.push(imageBlob);\n                            }\n                            resolve(imgs);\n                        }\n                    }\n                }\n                offset += 2 + dataView.getUint16(offset + 2);\n            }\n        });\n    }\n}\n\n/**\n * Extracts XMP Metadata and the gain map recovery image\n * from a single JPEG file.\n *\n * @category Decoding Functions\n * @group Decoding Functions\n * @param jpegFile an `Uint8Array` containing and encoded JPEG file\n * @returns an sdr `Uint8Array` compressed in JPEG, a gainMap `Uint8Array` compressed in JPEG and the XMP parsed XMP metadata\n * @throws Error if XMP Metadata is not found\n * @throws Error if Gain map image is not found\n * @example\n * import { FileLoader } from 'three'\n * import { extractGainmapFromJPEG } from '@monogrid/gainmap-js'\n *\n * const jpegFile = await new FileLoader()\n *  .setResponseType('arraybuffer')\n *  .loadAsync('image.jpg')\n *\n * const { sdr, gainMap, metadata } = extractGainmapFromJPEG(jpegFile)\n */\nconst extractGainmapFromJPEG = async (jpegFile) => {\n    const metadata = extractXMP(jpegFile);\n    if (!metadata)\n        throw new XMPMetadataNotFoundError('Gain map XMP metadata not found');\n    const mpfExtractor = new MPFExtractor({ extractFII: true, extractNonFII: true });\n    const images = await mpfExtractor.extract(jpegFile);\n    if (images.length !== 2)\n        throw new GainMapNotFoundError('Gain map recovery image not found');\n    return {\n        sdr: new Uint8Array(await images[0].arrayBuffer()),\n        gainMap: new Uint8Array(await images[1].arrayBuffer()),\n        metadata\n    };\n};\n\n/**\n * private function, async get image from blob\n *\n * @param blob\n * @returns\n */\nconst getHTMLImageFromBlob = (blob) => {\n    return new Promise((resolve, reject) => {\n        const img = document.createElement('img');\n        img.onload = () => { resolve(img); };\n        img.onerror = (e) => { reject(e); };\n        img.src = URL.createObjectURL(blob);\n    });\n};\n\nclass LoaderBase extends Loader {\n    /**\n     *\n     * @param renderer\n     * @param manager\n     */\n    constructor(renderer, manager) {\n        super(manager);\n        if (renderer)\n            this._renderer = renderer;\n        this._internalLoadingManager = new LoadingManager();\n    }\n    /**\n     * Specify the renderer to use when rendering the gain map\n     *\n     * @param renderer\n     * @returns\n     */\n    setRenderer(renderer) {\n        this._renderer = renderer;\n        return this;\n    }\n    /**\n     * Specify the renderTarget options to use when rendering the gain map\n     *\n     * @param options\n     * @returns\n     */\n    setRenderTargetOptions(options) {\n        this._renderTargetOptions = options;\n        return this;\n    }\n    /**\n     * @private\n     * @returns\n     */\n    prepareQuadRenderer() {\n        if (!this._renderer)\n            console.warn('WARNING: An existing WebGL Renderer was not passed to this Loader constructor or in setRenderer, the result of this Loader will need to be converted to a Data Texture with toDataTexture() before you can use it in your renderer.');\n        // temporary values\n        const material = new GainMapDecoderMaterial({\n            gainMapMax: [1, 1, 1],\n            gainMapMin: [0, 0, 0],\n            gamma: [1, 1, 1],\n            offsetHdr: [1, 1, 1],\n            offsetSdr: [1, 1, 1],\n            hdrCapacityMax: 1,\n            hdrCapacityMin: 0,\n            maxDisplayBoost: 1,\n            gainMap: new Texture(),\n            sdr: new Texture()\n        });\n        return new QuadRenderer({\n            width: 16,\n            height: 16,\n            type: HalfFloatType,\n            colorSpace: LinearSRGBColorSpace,\n            material,\n            renderer: this._renderer,\n            renderTargetOptions: this._renderTargetOptions\n        });\n    }\n    /**\n   * @private\n   * @param quadRenderer\n   * @param metadata\n   * @param sdrBuffer\n   * @param gainMapBuffer\n   */\n    async render(quadRenderer, metadata, sdrBuffer, gainMapBuffer) {\n        // this is optional, will render a black gain-map if not present\n        const gainMapBlob = gainMapBuffer ? new Blob([gainMapBuffer], { type: 'image/jpeg' }) : undefined;\n        const sdrBlob = new Blob([sdrBuffer], { type: 'image/jpeg' });\n        let sdrImage;\n        let gainMapImage;\n        let needsFlip = false;\n        if (typeof createImageBitmap === 'undefined') {\n            const res = await Promise.all([\n                gainMapBlob ? getHTMLImageFromBlob(gainMapBlob) : Promise.resolve(undefined),\n                getHTMLImageFromBlob(sdrBlob)\n            ]);\n            gainMapImage = res[0];\n            sdrImage = res[1];\n            needsFlip = true;\n        }\n        else {\n            const res = await Promise.all([\n                gainMapBlob ? createImageBitmap(gainMapBlob, { imageOrientation: 'flipY' }) : Promise.resolve(undefined),\n                createImageBitmap(sdrBlob, { imageOrientation: 'flipY' })\n            ]);\n            gainMapImage = res[0];\n            sdrImage = res[1];\n        }\n        const gainMap = new Texture(gainMapImage || new ImageData(2, 2), UVMapping, ClampToEdgeWrapping, ClampToEdgeWrapping, LinearFilter, LinearMipMapLinearFilter, RGBAFormat, UnsignedByteType, 1, LinearSRGBColorSpace);\n        gainMap.flipY = needsFlip;\n        gainMap.needsUpdate = true;\n        const sdr = new Texture(sdrImage, UVMapping, ClampToEdgeWrapping, ClampToEdgeWrapping, LinearFilter, LinearMipMapLinearFilter, RGBAFormat, UnsignedByteType, 1, SRGBColorSpace);\n        sdr.flipY = needsFlip;\n        sdr.needsUpdate = true;\n        quadRenderer.width = sdrImage.width;\n        quadRenderer.height = sdrImage.height;\n        quadRenderer.material.gainMap = gainMap;\n        quadRenderer.material.sdr = sdr;\n        quadRenderer.material.gainMapMin = metadata.gainMapMin;\n        quadRenderer.material.gainMapMax = metadata.gainMapMax;\n        quadRenderer.material.offsetHdr = metadata.offsetHdr;\n        quadRenderer.material.offsetSdr = metadata.offsetSdr;\n        quadRenderer.material.gamma = metadata.gamma;\n        quadRenderer.material.hdrCapacityMin = metadata.hdrCapacityMin;\n        quadRenderer.material.hdrCapacityMax = metadata.hdrCapacityMax;\n        quadRenderer.material.maxDisplayBoost = Math.pow(2, metadata.hdrCapacityMax);\n        quadRenderer.material.needsUpdate = true;\n        quadRenderer.render();\n    }\n}\n\n/**\n * A Three.js Loader for the gain map format.\n *\n * @category Loaders\n * @group Loaders\n *\n * @example\n * import { GainMapLoader } from '@monogrid/gainmap-js'\n * import {\n *   EquirectangularReflectionMapping,\n *   LinearFilter,\n *   Mesh,\n *   MeshBasicMaterial,\n *   PerspectiveCamera,\n *   PlaneGeometry,\n *   Scene,\n *   WebGLRenderer\n * } from 'three'\n *\n * const renderer = new WebGLRenderer()\n *\n * const loader = new GainMapLoader(renderer)\n *\n * const result = await loader.loadAsync(['sdr.jpeg', 'gainmap.jpeg', 'metadata.json'])\n * // `result` can be used to populate a Texture\n *\n * const scene = new Scene()\n * const mesh = new Mesh(\n *   new PlaneGeometry(),\n *   new MeshBasicMaterial({ map: result.renderTarget.texture })\n * )\n * scene.add(mesh)\n * renderer.render(scene, new PerspectiveCamera())\n *\n * // Starting from three.js r159\n * // `result.renderTarget.texture` can\n * // also be used as Equirectangular scene background\n * //\n * // it was previously needed to convert it\n * // to a DataTexture with `result.toDataTexture()`\n * scene.background = result.renderTarget.texture\n * scene.background.mapping = EquirectangularReflectionMapping\n *\n * // result must be manually disposed\n * // when you are done using it\n * result.dispose()\n *\n */\nclass GainMapLoader extends LoaderBase {\n    /**\n     * Loads a gainmap using separate data\n     * * sdr image\n     * * gain map image\n     * * metadata json\n     *\n     * useful for webp gain maps\n     *\n     * @param urls An array in the form of [sdr.jpg, gainmap.jpg, metadata.json]\n     * @param onLoad Load complete callback, will receive the result\n     * @param onProgress Progress callback, will receive a {@link ProgressEvent}\n     * @param onError Error callback\n     * @returns\n     */\n    load([sdrUrl, gainMapUrl, metadataUrl], onLoad, onProgress, onError) {\n        const quadRenderer = this.prepareQuadRenderer();\n        let sdr;\n        let gainMap;\n        let metadata;\n        const loadCheck = async () => {\n            if (sdr && gainMap && metadata) {\n                // solves #16\n                try {\n                    await this.render(quadRenderer, metadata, sdr, gainMap);\n                }\n                catch (error) {\n                    this.manager.itemError(sdrUrl);\n                    this.manager.itemError(gainMapUrl);\n                    this.manager.itemError(metadataUrl);\n                    if (typeof onError === 'function')\n                        onError(error);\n                    quadRenderer.disposeOnDemandRenderer();\n                    return;\n                }\n                if (typeof onLoad === 'function')\n                    onLoad(quadRenderer);\n                this.manager.itemEnd(sdrUrl);\n                this.manager.itemEnd(gainMapUrl);\n                this.manager.itemEnd(metadataUrl);\n                quadRenderer.disposeOnDemandRenderer();\n            }\n        };\n        let sdrLengthComputable = true;\n        let sdrTotal = 0;\n        let sdrLoaded = 0;\n        let gainMapLengthComputable = true;\n        let gainMapTotal = 0;\n        let gainMapLoaded = 0;\n        let metadataLengthComputable = true;\n        let metadataTotal = 0;\n        let metadataLoaded = 0;\n        const progressHandler = () => {\n            if (typeof onProgress === 'function') {\n                const total = sdrTotal + gainMapTotal + metadataTotal;\n                const loaded = sdrLoaded + gainMapLoaded + metadataLoaded;\n                const lengthComputable = sdrLengthComputable && gainMapLengthComputable && metadataLengthComputable;\n                onProgress(new ProgressEvent('progress', { lengthComputable, loaded, total }));\n            }\n        };\n        this.manager.itemStart(sdrUrl);\n        this.manager.itemStart(gainMapUrl);\n        this.manager.itemStart(metadataUrl);\n        const sdrLoader = new FileLoader(this._internalLoadingManager);\n        sdrLoader.setResponseType('arraybuffer');\n        sdrLoader.setRequestHeader(this.requestHeader);\n        sdrLoader.setPath(this.path);\n        sdrLoader.setWithCredentials(this.withCredentials);\n        sdrLoader.load(sdrUrl, async (buffer) => {\n            /* istanbul ignore if\n             this condition exists only because of three.js types + strict mode\n            */\n            if (typeof buffer === 'string')\n                throw new Error('Invalid sdr buffer');\n            sdr = buffer;\n            await loadCheck();\n        }, (e) => {\n            sdrLengthComputable = e.lengthComputable;\n            sdrLoaded = e.loaded;\n            sdrTotal = e.total;\n            progressHandler();\n        }, (error) => {\n            this.manager.itemError(sdrUrl);\n            if (typeof onError === 'function')\n                onError(error);\n        });\n        const gainMapLoader = new FileLoader(this._internalLoadingManager);\n        gainMapLoader.setResponseType('arraybuffer');\n        gainMapLoader.setRequestHeader(this.requestHeader);\n        gainMapLoader.setPath(this.path);\n        gainMapLoader.setWithCredentials(this.withCredentials);\n        gainMapLoader.load(gainMapUrl, async (buffer) => {\n            /* istanbul ignore if\n             this condition exists only because of three.js types + strict mode\n            */\n            if (typeof buffer === 'string')\n                throw new Error('Invalid gainmap buffer');\n            gainMap = buffer;\n            await loadCheck();\n        }, (e) => {\n            gainMapLengthComputable = e.lengthComputable;\n            gainMapLoaded = e.loaded;\n            gainMapTotal = e.total;\n            progressHandler();\n        }, (error) => {\n            this.manager.itemError(gainMapUrl);\n            if (typeof onError === 'function')\n                onError(error);\n        });\n        const metadataLoader = new FileLoader(this._internalLoadingManager);\n        // metadataLoader.setResponseType('json')\n        metadataLoader.setRequestHeader(this.requestHeader);\n        metadataLoader.setPath(this.path);\n        metadataLoader.setWithCredentials(this.withCredentials);\n        metadataLoader.load(metadataUrl, async (json) => {\n            /* istanbul ignore if\n             this condition exists only because of three.js types + strict mode\n            */\n            if (typeof json !== 'string')\n                throw new Error('Invalid metadata string');\n            // TODO: implement check on JSON file and remove this eslint disable\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n            metadata = JSON.parse(json);\n            await loadCheck();\n        }, (e) => {\n            metadataLengthComputable = e.lengthComputable;\n            metadataLoaded = e.loaded;\n            metadataTotal = e.total;\n            progressHandler();\n        }, (error) => {\n            this.manager.itemError(metadataUrl);\n            if (typeof onError === 'function')\n                onError(error);\n        });\n        return quadRenderer;\n    }\n}\n\n/**\n * A Three.js Loader for a JPEG with embedded gainmap metadata.\n *\n * @category Loaders\n * @group Loaders\n *\n * @example\n * import { HDRJPGLoader } from '@monogrid/gainmap-js'\n * import {\n *   EquirectangularReflectionMapping,\n *   LinearFilter,\n *   Mesh,\n *   MeshBasicMaterial,\n *   PerspectiveCamera,\n *   PlaneGeometry,\n *   Scene,\n *   WebGLRenderer\n * } from 'three'\n *\n * const renderer = new WebGLRenderer()\n *\n * const loader = new HDRJPGLoader(renderer)\n *\n * const result = await loader.loadAsync('gainmap.jpeg')\n * // `result` can be used to populate a Texture\n *\n * const scene = new Scene()\n * const mesh = new Mesh(\n *   new PlaneGeometry(),\n *   new MeshBasicMaterial({ map: result.renderTarget.texture })\n * )\n * scene.add(mesh)\n * renderer.render(scene, new PerspectiveCamera())\n *\n * // Starting from three.js r159\n * // `result.renderTarget.texture` can\n * // also be used as Equirectangular scene background\n * //\n * // it was previously needed to convert it\n * // to a DataTexture with `result.toDataTexture()`\n * scene.background = result.renderTarget.texture\n * scene.background.mapping = EquirectangularReflectionMapping\n *\n * // result must be manually disposed\n * // when you are done using it\n * result.dispose()\n *\n */\nclass HDRJPGLoader extends LoaderBase {\n    /**\n     * Loads a JPEG containing gain map metadata\n     * Renders a normal SDR image if gainmap data is not found\n     *\n     * @param url An array in the form of [sdr.jpg, gainmap.jpg, metadata.json]\n     * @param onLoad Load complete callback, will receive the result\n     * @param onProgress Progress callback, will receive a {@link ProgressEvent}\n     * @param onError Error callback\n     * @returns\n     */\n    load(url, onLoad, onProgress, onError) {\n        const quadRenderer = this.prepareQuadRenderer();\n        const loader = new FileLoader(this._internalLoadingManager);\n        loader.setResponseType('arraybuffer');\n        loader.setRequestHeader(this.requestHeader);\n        loader.setPath(this.path);\n        loader.setWithCredentials(this.withCredentials);\n        this.manager.itemStart(url);\n        loader.load(url, async (jpeg) => {\n            /* istanbul ignore if\n             this condition exists only because of three.js types + strict mode\n            */\n            if (typeof jpeg === 'string')\n                throw new Error('Invalid buffer, received [string], was expecting [ArrayBuffer]');\n            const jpegBuffer = new Uint8Array(jpeg);\n            let sdrJPEG;\n            let gainMapJPEG;\n            let metadata;\n            try {\n                const extractionResult = await extractGainmapFromJPEG(jpegBuffer);\n                // gain map is successfully reconstructed\n                sdrJPEG = extractionResult.sdr;\n                gainMapJPEG = extractionResult.gainMap;\n                metadata = extractionResult.metadata;\n            }\n            catch (e) {\n                // render the SDR version if this is not a gainmap\n                if (e instanceof XMPMetadataNotFoundError || e instanceof GainMapNotFoundError) {\n                    console.warn(`Failure to reconstruct an HDR image from ${url}: Gain map metadata not found in the file, HDRJPGLoader will render the SDR jpeg`);\n                    metadata = {\n                        gainMapMin: [0, 0, 0],\n                        gainMapMax: [1, 1, 1],\n                        gamma: [1, 1, 1],\n                        hdrCapacityMin: 0,\n                        hdrCapacityMax: 1,\n                        offsetHdr: [0, 0, 0],\n                        offsetSdr: [0, 0, 0]\n                    };\n                    sdrJPEG = jpegBuffer;\n                }\n                else {\n                    throw e;\n                }\n            }\n            // solves #16\n            try {\n                await this.render(quadRenderer, metadata, sdrJPEG, gainMapJPEG);\n            }\n            catch (error) {\n                this.manager.itemError(url);\n                if (typeof onError === 'function')\n                    onError(error);\n                quadRenderer.disposeOnDemandRenderer();\n                return;\n            }\n            if (typeof onLoad === 'function')\n                onLoad(quadRenderer);\n            this.manager.itemEnd(url);\n            quadRenderer.disposeOnDemandRenderer();\n        }, onProgress, (error) => {\n            this.manager.itemError(url);\n            if (typeof onError === 'function')\n                onError(error);\n        });\n        return quadRenderer;\n    }\n}\n\nexport { GainMapDecoderMaterial, GainMapLoader, HDRJPGLoader, HDRJPGLoader as JPEGRLoader, MPFExtractor, QuadRenderer, decode, extractGainmapFromJPEG, extractXMP };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}