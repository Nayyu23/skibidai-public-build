{"ast":null,"code":"import _classCallCheck from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _inherits from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport { Loader, FileLoader, Group, MeshPhongMaterial, Float32BufferAttribute, Color, BufferGeometry, Mesh } from \"three\";\nimport { unzipSync } from \"fflate\";\nimport { decodeText } from \"../_polyfill/LoaderUtils.js\";\nvar AMFLoader = /*#__PURE__*/function (_Loader) {\n  _inherits(AMFLoader, _Loader);\n  var _super = _createSuper(AMFLoader);\n  function AMFLoader(manager) {\n    _classCallCheck(this, AMFLoader);\n    return _super.call(this, manager);\n  }\n  _createClass(AMFLoader, [{\n    key: \"load\",\n    value: function load(url, onLoad, onProgress, onError) {\n      var scope = this;\n      var loader = new FileLoader(scope.manager);\n      loader.setPath(scope.path);\n      loader.setResponseType(\"arraybuffer\");\n      loader.setRequestHeader(scope.requestHeader);\n      loader.setWithCredentials(scope.withCredentials);\n      loader.load(url, function (text) {\n        try {\n          onLoad(scope.parse(text));\n        } catch (e) {\n          if (onError) {\n            onError(e);\n          } else {\n            console.error(e);\n          }\n          scope.manager.itemError(url);\n        }\n      }, onProgress, onError);\n    }\n  }, {\n    key: \"parse\",\n    value: function parse(data) {\n      function loadDocument(data2) {\n        var view = new DataView(data2);\n        var magic = String.fromCharCode(view.getUint8(0), view.getUint8(1));\n        if (magic === \"PK\") {\n          var zip = null;\n          var file = null;\n          console.log(\"THREE.AMFLoader: Loading Zip\");\n          try {\n            zip = unzipSync(new Uint8Array(data2));\n          } catch (e) {\n            if (e instanceof ReferenceError) {\n              console.log(\"THREE.AMFLoader: fflate missing and file is compressed.\");\n              return null;\n            }\n          }\n          for (file in zip) {\n            if (file.toLowerCase().substr(-4) === \".amf\") {\n              break;\n            }\n          }\n          console.log(\"THREE.AMFLoader: Trying to load file asset: \" + file);\n          view = new DataView(zip[file].buffer);\n        }\n        var fileText = decodeText(view);\n        var xmlData2 = new DOMParser().parseFromString(fileText, \"application/xml\");\n        if (xmlData2.documentElement.nodeName.toLowerCase() !== \"amf\") {\n          console.log(\"THREE.AMFLoader: Error loading AMF - no AMF document found.\");\n          return null;\n        }\n        return xmlData2;\n      }\n      function loadDocumentScale(node) {\n        var scale = 1;\n        var unit = \"millimeter\";\n        if (node.documentElement.attributes.unit !== void 0) {\n          unit = node.documentElement.attributes.unit.value.toLowerCase();\n        }\n        var scaleUnits = {\n          millimeter: 1,\n          inch: 25.4,\n          feet: 304.8,\n          meter: 1e3,\n          micron: 1e-3\n        };\n        if (scaleUnits[unit] !== void 0) {\n          scale = scaleUnits[unit];\n        }\n        console.log(\"THREE.AMFLoader: Unit scale: \" + scale);\n        return scale;\n      }\n      function loadMaterials(node) {\n        var matName = \"AMF Material\";\n        var matId = node.attributes.id.textContent;\n        var color = {\n          r: 1,\n          g: 1,\n          b: 1,\n          a: 1\n        };\n        var loadedMaterial = null;\n        for (var i2 = 0; i2 < node.childNodes.length; i2++) {\n          var matChildEl = node.childNodes[i2];\n          if (matChildEl.nodeName === \"metadata\" && matChildEl.attributes.type !== void 0) {\n            if (matChildEl.attributes.type.value === \"name\") {\n              matName = matChildEl.textContent;\n            }\n          } else if (matChildEl.nodeName === \"color\") {\n            color = loadColor(matChildEl);\n          }\n        }\n        loadedMaterial = new MeshPhongMaterial({\n          flatShading: true,\n          color: new Color(color.r, color.g, color.b),\n          name: matName\n        });\n        if (color.a !== 1) {\n          loadedMaterial.transparent = true;\n          loadedMaterial.opacity = color.a;\n        }\n        return {\n          id: matId,\n          material: loadedMaterial\n        };\n      }\n      function loadColor(node) {\n        var color = {\n          r: 1,\n          g: 1,\n          b: 1,\n          a: 1\n        };\n        for (var i2 = 0; i2 < node.childNodes.length; i2++) {\n          var matColor = node.childNodes[i2];\n          if (matColor.nodeName === \"r\") {\n            color.r = matColor.textContent;\n          } else if (matColor.nodeName === \"g\") {\n            color.g = matColor.textContent;\n          } else if (matColor.nodeName === \"b\") {\n            color.b = matColor.textContent;\n          } else if (matColor.nodeName === \"a\") {\n            color.a = matColor.textContent;\n          }\n        }\n        return color;\n      }\n      function loadMeshVolume(node) {\n        var volume = {\n          name: \"\",\n          triangles: [],\n          materialid: null\n        };\n        var currVolumeNode = node.firstElementChild;\n        if (node.attributes.materialid !== void 0) {\n          volume.materialId = node.attributes.materialid.nodeValue;\n        }\n        while (currVolumeNode) {\n          if (currVolumeNode.nodeName === \"metadata\") {\n            if (currVolumeNode.attributes.type !== void 0) {\n              if (currVolumeNode.attributes.type.value === \"name\") {\n                volume.name = currVolumeNode.textContent;\n              }\n            }\n          } else if (currVolumeNode.nodeName === \"triangle\") {\n            var v1 = currVolumeNode.getElementsByTagName(\"v1\")[0].textContent;\n            var v2 = currVolumeNode.getElementsByTagName(\"v2\")[0].textContent;\n            var v3 = currVolumeNode.getElementsByTagName(\"v3\")[0].textContent;\n            volume.triangles.push(v1, v2, v3);\n          }\n          currVolumeNode = currVolumeNode.nextElementSibling;\n        }\n        return volume;\n      }\n      function loadMeshVertices(node) {\n        var vertArray = [];\n        var normalArray = [];\n        var currVerticesNode = node.firstElementChild;\n        while (currVerticesNode) {\n          if (currVerticesNode.nodeName === \"vertex\") {\n            var vNode = currVerticesNode.firstElementChild;\n            while (vNode) {\n              if (vNode.nodeName === \"coordinates\") {\n                var x = vNode.getElementsByTagName(\"x\")[0].textContent;\n                var y = vNode.getElementsByTagName(\"y\")[0].textContent;\n                var z = vNode.getElementsByTagName(\"z\")[0].textContent;\n                vertArray.push(x, y, z);\n              } else if (vNode.nodeName === \"normal\") {\n                var nx = vNode.getElementsByTagName(\"nx\")[0].textContent;\n                var ny = vNode.getElementsByTagName(\"ny\")[0].textContent;\n                var nz = vNode.getElementsByTagName(\"nz\")[0].textContent;\n                normalArray.push(nx, ny, nz);\n              }\n              vNode = vNode.nextElementSibling;\n            }\n          }\n          currVerticesNode = currVerticesNode.nextElementSibling;\n        }\n        return {\n          vertices: vertArray,\n          normals: normalArray\n        };\n      }\n      function loadObject(node) {\n        var objId = node.attributes.id.textContent;\n        var loadedObject = {\n          name: \"amfobject\",\n          meshes: []\n        };\n        var currColor = null;\n        var currObjNode = node.firstElementChild;\n        while (currObjNode) {\n          if (currObjNode.nodeName === \"metadata\") {\n            if (currObjNode.attributes.type !== void 0) {\n              if (currObjNode.attributes.type.value === \"name\") {\n                loadedObject.name = currObjNode.textContent;\n              }\n            }\n          } else if (currObjNode.nodeName === \"color\") {\n            currColor = loadColor(currObjNode);\n          } else if (currObjNode.nodeName === \"mesh\") {\n            var currMeshNode = currObjNode.firstElementChild;\n            var mesh = {\n              vertices: [],\n              normals: [],\n              volumes: [],\n              color: currColor\n            };\n            while (currMeshNode) {\n              if (currMeshNode.nodeName === \"vertices\") {\n                var loadedVertices = loadMeshVertices(currMeshNode);\n                mesh.normals = mesh.normals.concat(loadedVertices.normals);\n                mesh.vertices = mesh.vertices.concat(loadedVertices.vertices);\n              } else if (currMeshNode.nodeName === \"volume\") {\n                mesh.volumes.push(loadMeshVolume(currMeshNode));\n              }\n              currMeshNode = currMeshNode.nextElementSibling;\n            }\n            loadedObject.meshes.push(mesh);\n          }\n          currObjNode = currObjNode.nextElementSibling;\n        }\n        return {\n          id: objId,\n          obj: loadedObject\n        };\n      }\n      var xmlData = loadDocument(data);\n      var amfName = \"\";\n      var amfAuthor = \"\";\n      var amfScale = loadDocumentScale(xmlData);\n      var amfMaterials = {};\n      var amfObjects = {};\n      var childNodes = xmlData.documentElement.childNodes;\n      var i, j;\n      for (i = 0; i < childNodes.length; i++) {\n        var child = childNodes[i];\n        if (child.nodeName === \"metadata\") {\n          if (child.attributes.type !== void 0) {\n            if (child.attributes.type.value === \"name\") {\n              amfName = child.textContent;\n            } else if (child.attributes.type.value === \"author\") {\n              amfAuthor = child.textContent;\n            }\n          }\n        } else if (child.nodeName === \"material\") {\n          var loadedMaterial = loadMaterials(child);\n          amfMaterials[loadedMaterial.id] = loadedMaterial.material;\n        } else if (child.nodeName === \"object\") {\n          var loadedObject = loadObject(child);\n          amfObjects[loadedObject.id] = loadedObject.obj;\n        }\n      }\n      var sceneObject = new Group();\n      var defaultMaterial = new MeshPhongMaterial({\n        color: 11184895,\n        flatShading: true\n      });\n      sceneObject.name = amfName;\n      sceneObject.userData.author = amfAuthor;\n      sceneObject.userData.loader = \"AMF\";\n      for (var id in amfObjects) {\n        var part = amfObjects[id];\n        var meshes = part.meshes;\n        var newObject = new Group();\n        newObject.name = part.name || \"\";\n        for (i = 0; i < meshes.length; i++) {\n          var objDefaultMaterial = defaultMaterial;\n          var mesh = meshes[i];\n          var vertices = new Float32BufferAttribute(mesh.vertices, 3);\n          var normals = null;\n          if (mesh.normals.length) {\n            normals = new Float32BufferAttribute(mesh.normals, 3);\n          }\n          if (mesh.color) {\n            var color = mesh.color;\n            objDefaultMaterial = defaultMaterial.clone();\n            objDefaultMaterial.color = new Color(color.r, color.g, color.b);\n            if (color.a !== 1) {\n              objDefaultMaterial.transparent = true;\n              objDefaultMaterial.opacity = color.a;\n            }\n          }\n          var volumes = mesh.volumes;\n          for (j = 0; j < volumes.length; j++) {\n            var volume = volumes[j];\n            var newGeometry = new BufferGeometry();\n            var material = objDefaultMaterial;\n            newGeometry.setIndex(volume.triangles);\n            newGeometry.setAttribute(\"position\", vertices.clone());\n            if (normals) {\n              newGeometry.setAttribute(\"normal\", normals.clone());\n            }\n            if (amfMaterials[volume.materialId] !== void 0) {\n              material = amfMaterials[volume.materialId];\n            }\n            newGeometry.scale(amfScale, amfScale, amfScale);\n            newObject.add(new Mesh(newGeometry, material.clone()));\n          }\n        }\n        sceneObject.add(newObject);\n      }\n      return sceneObject;\n    }\n  }]);\n  return AMFLoader;\n}(Loader);\nexport { AMFLoader };","map":{"version":3,"names":["AMFLoader","_Loader","_inherits","_super","_createSuper","manager","_classCallCheck","call","_createClass","key","value","load","url","onLoad","onProgress","onError","scope","loader","FileLoader","setPath","path","setResponseType","setRequestHeader","requestHeader","setWithCredentials","withCredentials","text","parse","e","console","error","itemError","data","loadDocument","data2","view","DataView","magic","String","fromCharCode","getUint8","zip","file","log","unzipSync","Uint8Array","ReferenceError","toLowerCase","substr","buffer","fileText","decodeText","xmlData2","DOMParser","parseFromString","documentElement","nodeName","loadDocumentScale","node","scale","unit","attributes","scaleUnits","millimeter","inch","feet","meter","micron","loadMaterials","matName","matId","id","textContent","color","r","g","b","a","loadedMaterial","i2","childNodes","length","matChildEl","type","loadColor","MeshPhongMaterial","flatShading","Color","name","transparent","opacity","material","matColor","loadMeshVolume","volume","triangles","materialid","currVolumeNode","firstElementChild","materialId","nodeValue","v1","getElementsByTagName","v2","v3","push","nextElementSibling","loadMeshVertices","vertArray","normalArray","currVerticesNode","vNode","x","y","z","nx","ny","nz","vertices","normals","loadObject","objId","loadedObject","meshes","currColor","currObjNode","currMeshNode","mesh","volumes","loadedVertices","concat","obj","xmlData","amfName","amfAuthor","amfScale","amfMaterials","amfObjects","i","j","child","sceneObject","Group","defaultMaterial","userData","author","part","newObject","objDefaultMaterial","Float32BufferAttribute","clone","newGeometry","BufferGeometry","setIndex","setAttribute","add","Mesh","Loader"],"sources":["C:\\Users\\Nayyu\\Desktop\\skibidai-public-build\\node_modules\\src\\loaders\\AMFLoader.js"],"sourcesContent":["import {\n  BufferGeometry,\n  Color,\n  FileLoader,\n  Float32BufferAttribute,\n  Group,\n  Loader,\n  LoaderUtils,\n  Mesh,\n  MeshPhongMaterial,\n} from 'three'\nimport { unzipSync } from 'fflate'\nimport { decodeText } from '../_polyfill/LoaderUtils'\n\n/**\n * Description: Early release of an AMF Loader following the pattern of the\n * example loaders in the three.js project.\n *\n * Usage:\n *\tconst loader = new AMFLoader();\n *\tloader.load('/path/to/project.amf', function(objecttree) {\n *\t\tscene.add(objecttree);\n *\t});\n *\n * Materials now supported, material colors supported\n * Zip support, requires fflate\n * No constellation support (yet)!\n *\n */\n\nclass AMFLoader extends Loader {\n  constructor(manager) {\n    super(manager)\n  }\n\n  load(url, onLoad, onProgress, onError) {\n    const scope = this\n\n    const loader = new FileLoader(scope.manager)\n    loader.setPath(scope.path)\n    loader.setResponseType('arraybuffer')\n    loader.setRequestHeader(scope.requestHeader)\n    loader.setWithCredentials(scope.withCredentials)\n    loader.load(\n      url,\n      function (text) {\n        try {\n          onLoad(scope.parse(text))\n        } catch (e) {\n          if (onError) {\n            onError(e)\n          } else {\n            console.error(e)\n          }\n\n          scope.manager.itemError(url)\n        }\n      },\n      onProgress,\n      onError,\n    )\n  }\n\n  parse(data) {\n    function loadDocument(data) {\n      let view = new DataView(data)\n      const magic = String.fromCharCode(view.getUint8(0), view.getUint8(1))\n\n      if (magic === 'PK') {\n        let zip = null\n        let file = null\n\n        console.log('THREE.AMFLoader: Loading Zip')\n\n        try {\n          zip = unzipSync(new Uint8Array(data))\n        } catch (e) {\n          if (e instanceof ReferenceError) {\n            console.log('THREE.AMFLoader: fflate missing and file is compressed.')\n            return null\n          }\n        }\n\n        for (file in zip) {\n          if (file.toLowerCase().substr(-4) === '.amf') {\n            break\n          }\n        }\n\n        console.log('THREE.AMFLoader: Trying to load file asset: ' + file)\n        view = new DataView(zip[file].buffer)\n      }\n\n      const fileText = decodeText(view)\n      const xmlData = new DOMParser().parseFromString(fileText, 'application/xml')\n\n      if (xmlData.documentElement.nodeName.toLowerCase() !== 'amf') {\n        console.log('THREE.AMFLoader: Error loading AMF - no AMF document found.')\n        return null\n      }\n\n      return xmlData\n    }\n\n    function loadDocumentScale(node) {\n      let scale = 1.0\n      let unit = 'millimeter'\n\n      if (node.documentElement.attributes.unit !== undefined) {\n        unit = node.documentElement.attributes.unit.value.toLowerCase()\n      }\n\n      const scaleUnits = {\n        millimeter: 1.0,\n        inch: 25.4,\n        feet: 304.8,\n        meter: 1000.0,\n        micron: 0.001,\n      }\n\n      if (scaleUnits[unit] !== undefined) {\n        scale = scaleUnits[unit]\n      }\n\n      console.log('THREE.AMFLoader: Unit scale: ' + scale)\n      return scale\n    }\n\n    function loadMaterials(node) {\n      let matName = 'AMF Material'\n      const matId = node.attributes.id.textContent\n      let color = { r: 1.0, g: 1.0, b: 1.0, a: 1.0 }\n\n      let loadedMaterial = null\n\n      for (let i = 0; i < node.childNodes.length; i++) {\n        const matChildEl = node.childNodes[i]\n\n        if (matChildEl.nodeName === 'metadata' && matChildEl.attributes.type !== undefined) {\n          if (matChildEl.attributes.type.value === 'name') {\n            matName = matChildEl.textContent\n          }\n        } else if (matChildEl.nodeName === 'color') {\n          color = loadColor(matChildEl)\n        }\n      }\n\n      loadedMaterial = new MeshPhongMaterial({\n        flatShading: true,\n        color: new Color(color.r, color.g, color.b),\n        name: matName,\n      })\n\n      if (color.a !== 1.0) {\n        loadedMaterial.transparent = true\n        loadedMaterial.opacity = color.a\n      }\n\n      return { id: matId, material: loadedMaterial }\n    }\n\n    function loadColor(node) {\n      const color = { r: 1.0, g: 1.0, b: 1.0, a: 1.0 }\n\n      for (let i = 0; i < node.childNodes.length; i++) {\n        const matColor = node.childNodes[i]\n\n        if (matColor.nodeName === 'r') {\n          color.r = matColor.textContent\n        } else if (matColor.nodeName === 'g') {\n          color.g = matColor.textContent\n        } else if (matColor.nodeName === 'b') {\n          color.b = matColor.textContent\n        } else if (matColor.nodeName === 'a') {\n          color.a = matColor.textContent\n        }\n      }\n\n      return color\n    }\n\n    function loadMeshVolume(node) {\n      const volume = { name: '', triangles: [], materialid: null }\n\n      let currVolumeNode = node.firstElementChild\n\n      if (node.attributes.materialid !== undefined) {\n        volume.materialId = node.attributes.materialid.nodeValue\n      }\n\n      while (currVolumeNode) {\n        if (currVolumeNode.nodeName === 'metadata') {\n          if (currVolumeNode.attributes.type !== undefined) {\n            if (currVolumeNode.attributes.type.value === 'name') {\n              volume.name = currVolumeNode.textContent\n            }\n          }\n        } else if (currVolumeNode.nodeName === 'triangle') {\n          const v1 = currVolumeNode.getElementsByTagName('v1')[0].textContent\n          const v2 = currVolumeNode.getElementsByTagName('v2')[0].textContent\n          const v3 = currVolumeNode.getElementsByTagName('v3')[0].textContent\n\n          volume.triangles.push(v1, v2, v3)\n        }\n\n        currVolumeNode = currVolumeNode.nextElementSibling\n      }\n\n      return volume\n    }\n\n    function loadMeshVertices(node) {\n      const vertArray = []\n      const normalArray = []\n      let currVerticesNode = node.firstElementChild\n\n      while (currVerticesNode) {\n        if (currVerticesNode.nodeName === 'vertex') {\n          let vNode = currVerticesNode.firstElementChild\n\n          while (vNode) {\n            if (vNode.nodeName === 'coordinates') {\n              const x = vNode.getElementsByTagName('x')[0].textContent\n              const y = vNode.getElementsByTagName('y')[0].textContent\n              const z = vNode.getElementsByTagName('z')[0].textContent\n\n              vertArray.push(x, y, z)\n            } else if (vNode.nodeName === 'normal') {\n              const nx = vNode.getElementsByTagName('nx')[0].textContent\n              const ny = vNode.getElementsByTagName('ny')[0].textContent\n              const nz = vNode.getElementsByTagName('nz')[0].textContent\n\n              normalArray.push(nx, ny, nz)\n            }\n\n            vNode = vNode.nextElementSibling\n          }\n        }\n\n        currVerticesNode = currVerticesNode.nextElementSibling\n      }\n\n      return { vertices: vertArray, normals: normalArray }\n    }\n\n    function loadObject(node) {\n      const objId = node.attributes.id.textContent\n      const loadedObject = { name: 'amfobject', meshes: [] }\n      let currColor = null\n      let currObjNode = node.firstElementChild\n\n      while (currObjNode) {\n        if (currObjNode.nodeName === 'metadata') {\n          if (currObjNode.attributes.type !== undefined) {\n            if (currObjNode.attributes.type.value === 'name') {\n              loadedObject.name = currObjNode.textContent\n            }\n          }\n        } else if (currObjNode.nodeName === 'color') {\n          currColor = loadColor(currObjNode)\n        } else if (currObjNode.nodeName === 'mesh') {\n          let currMeshNode = currObjNode.firstElementChild\n          const mesh = { vertices: [], normals: [], volumes: [], color: currColor }\n\n          while (currMeshNode) {\n            if (currMeshNode.nodeName === 'vertices') {\n              const loadedVertices = loadMeshVertices(currMeshNode)\n\n              mesh.normals = mesh.normals.concat(loadedVertices.normals)\n              mesh.vertices = mesh.vertices.concat(loadedVertices.vertices)\n            } else if (currMeshNode.nodeName === 'volume') {\n              mesh.volumes.push(loadMeshVolume(currMeshNode))\n            }\n\n            currMeshNode = currMeshNode.nextElementSibling\n          }\n\n          loadedObject.meshes.push(mesh)\n        }\n\n        currObjNode = currObjNode.nextElementSibling\n      }\n\n      return { id: objId, obj: loadedObject }\n    }\n\n    const xmlData = loadDocument(data)\n    let amfName = ''\n    let amfAuthor = ''\n    const amfScale = loadDocumentScale(xmlData)\n    const amfMaterials = {}\n    const amfObjects = {}\n    const childNodes = xmlData.documentElement.childNodes\n\n    let i, j\n\n    for (i = 0; i < childNodes.length; i++) {\n      const child = childNodes[i]\n\n      if (child.nodeName === 'metadata') {\n        if (child.attributes.type !== undefined) {\n          if (child.attributes.type.value === 'name') {\n            amfName = child.textContent\n          } else if (child.attributes.type.value === 'author') {\n            amfAuthor = child.textContent\n          }\n        }\n      } else if (child.nodeName === 'material') {\n        const loadedMaterial = loadMaterials(child)\n\n        amfMaterials[loadedMaterial.id] = loadedMaterial.material\n      } else if (child.nodeName === 'object') {\n        const loadedObject = loadObject(child)\n\n        amfObjects[loadedObject.id] = loadedObject.obj\n      }\n    }\n\n    const sceneObject = new Group()\n    const defaultMaterial = new MeshPhongMaterial({ color: 0xaaaaff, flatShading: true })\n\n    sceneObject.name = amfName\n    sceneObject.userData.author = amfAuthor\n    sceneObject.userData.loader = 'AMF'\n\n    for (const id in amfObjects) {\n      const part = amfObjects[id]\n      const meshes = part.meshes\n      const newObject = new Group()\n      newObject.name = part.name || ''\n\n      for (i = 0; i < meshes.length; i++) {\n        let objDefaultMaterial = defaultMaterial\n        const mesh = meshes[i]\n        const vertices = new Float32BufferAttribute(mesh.vertices, 3)\n        let normals = null\n\n        if (mesh.normals.length) {\n          normals = new Float32BufferAttribute(mesh.normals, 3)\n        }\n\n        if (mesh.color) {\n          const color = mesh.color\n\n          objDefaultMaterial = defaultMaterial.clone()\n          objDefaultMaterial.color = new Color(color.r, color.g, color.b)\n\n          if (color.a !== 1.0) {\n            objDefaultMaterial.transparent = true\n            objDefaultMaterial.opacity = color.a\n          }\n        }\n\n        const volumes = mesh.volumes\n\n        for (j = 0; j < volumes.length; j++) {\n          const volume = volumes[j]\n          const newGeometry = new BufferGeometry()\n          let material = objDefaultMaterial\n\n          newGeometry.setIndex(volume.triangles)\n          newGeometry.setAttribute('position', vertices.clone())\n\n          if (normals) {\n            newGeometry.setAttribute('normal', normals.clone())\n          }\n\n          if (amfMaterials[volume.materialId] !== undefined) {\n            material = amfMaterials[volume.materialId]\n          }\n\n          newGeometry.scale(amfScale, amfScale, amfScale)\n          newObject.add(new Mesh(newGeometry, material.clone()))\n        }\n      }\n\n      sceneObject.add(newObject)\n    }\n\n    return sceneObject\n  }\n}\n\nexport { AMFLoader }\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}