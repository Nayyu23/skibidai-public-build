{"ast":null,"code":"import _slicedToArray from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _objectSpread from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _classCallCheck from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _inherits from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = function __defNormalProp(obj, key, value) {\n  return key in obj ? __defProp(obj, key, {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: value\n  }) : obj[key] = value;\n};\nvar __publicField = function __publicField(obj, key, value) {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nimport { Loader, RGBAFormat, RGBA_ASTC_4x4_Format, RGBA_BPTC_Format, RGBA_ETC2_EAC_Format, RGBA_PVRTC_4BPPV1_Format, RGBA_S3TC_DXT5_Format, RGB_ETC1_Format, RGB_ETC2_Format, RGB_PVRTC_4BPPV1_Format, RGB_S3TC_DXT1_Format, FileLoader, CompressedTexture, UnsignedByteType, LinearFilter, LinearMipmapLinearFilter } from \"three\";\nvar _taskCache = /* @__PURE__ */new WeakMap();\nvar _BasisTextureLoader = /*#__PURE__*/function (_Loader) {\n  _inherits(_BasisTextureLoader, _Loader);\n  var _super = _createSuper(_BasisTextureLoader);\n  function _BasisTextureLoader(manager) {\n    var _this;\n    _classCallCheck(this, _BasisTextureLoader);\n    _this = _super.call(this, manager);\n    _this.transcoderPath = \"\";\n    _this.transcoderBinary = null;\n    _this.transcoderPending = null;\n    _this.workerLimit = 4;\n    _this.workerPool = [];\n    _this.workerNextTaskID = 1;\n    _this.workerSourceURL = \"\";\n    _this.workerConfig = null;\n    return _this;\n  }\n  _createClass(_BasisTextureLoader, [{\n    key: \"setTranscoderPath\",\n    value: function setTranscoderPath(path) {\n      this.transcoderPath = path;\n      return this;\n    }\n  }, {\n    key: \"setWorkerLimit\",\n    value: function setWorkerLimit(workerLimit) {\n      this.workerLimit = workerLimit;\n      return this;\n    }\n  }, {\n    key: \"detectSupport\",\n    value: function detectSupport(renderer) {\n      this.workerConfig = {\n        astcSupported: renderer.extensions.has(\"WEBGL_compressed_texture_astc\"),\n        etc1Supported: renderer.extensions.has(\"WEBGL_compressed_texture_etc1\"),\n        etc2Supported: renderer.extensions.has(\"WEBGL_compressed_texture_etc\"),\n        dxtSupported: renderer.extensions.has(\"WEBGL_compressed_texture_s3tc\"),\n        bptcSupported: renderer.extensions.has(\"EXT_texture_compression_bptc\"),\n        pvrtcSupported: renderer.extensions.has(\"WEBGL_compressed_texture_pvrtc\") || renderer.extensions.has(\"WEBKIT_WEBGL_compressed_texture_pvrtc\")\n      };\n      return this;\n    }\n  }, {\n    key: \"load\",\n    value: function load(url, onLoad, onProgress, onError) {\n      var _this2 = this;\n      var loader = new FileLoader(this.manager);\n      loader.setResponseType(\"arraybuffer\");\n      loader.setWithCredentials(this.withCredentials);\n      var texture = new CompressedTexture();\n      loader.load(url, function (buffer) {\n        if (_taskCache.has(buffer)) {\n          var cachedTask = _taskCache.get(buffer);\n          return cachedTask.promise.then(onLoad).catch(onError);\n        }\n        _this2._createTexture([buffer]).then(function (_texture) {\n          texture.copy(_texture);\n          texture.needsUpdate = true;\n          if (onLoad) onLoad(texture);\n        }).catch(onError);\n      }, onProgress, onError);\n      return texture;\n    }\n    /** Low-level transcoding API, exposed for use by KTX2Loader. */\n  }, {\n    key: \"parseInternalAsync\",\n    value: function parseInternalAsync(options) {\n      var levels = options.levels;\n      var buffers = /* @__PURE__ */new Set();\n      for (var i = 0; i < levels.length; i++) {\n        buffers.add(levels[i].data.buffer);\n      }\n      return this._createTexture(Array.from(buffers), _objectSpread(_objectSpread({}, options), {}, {\n        lowLevel: true\n      }));\n    }\n    /**\n     * @param {ArrayBuffer[]} buffers\n     * @param {object?} config\n     * @return {Promise<CompressedTexture>}\n     */\n  }, {\n    key: \"_createTexture\",\n    value: function _createTexture(buffers) {\n      var _this3 = this;\n      var config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var worker;\n      var taskID;\n      var taskConfig = config;\n      var taskCost = 0;\n      for (var i = 0; i < buffers.length; i++) {\n        taskCost += buffers[i].byteLength;\n      }\n      var texturePending = this._allocateWorker(taskCost).then(function (_worker) {\n        worker = _worker;\n        taskID = _this3.workerNextTaskID++;\n        return new Promise(function (resolve, reject) {\n          worker._callbacks[taskID] = {\n            resolve: resolve,\n            reject: reject\n          };\n          worker.postMessage({\n            type: \"transcode\",\n            id: taskID,\n            buffers: buffers,\n            taskConfig: taskConfig\n          }, buffers);\n        });\n      }).then(function (message) {\n        var mipmaps = message.mipmaps,\n          width = message.width,\n          height = message.height,\n          format = message.format;\n        var texture = new CompressedTexture(mipmaps, width, height, format, UnsignedByteType);\n        texture.minFilter = mipmaps.length === 1 ? LinearFilter : LinearMipmapLinearFilter;\n        texture.magFilter = LinearFilter;\n        texture.generateMipmaps = false;\n        texture.needsUpdate = true;\n        return texture;\n      });\n      texturePending.catch(function () {\n        return true;\n      }).then(function () {\n        if (worker && taskID) {\n          worker._taskLoad -= taskCost;\n          delete worker._callbacks[taskID];\n        }\n      });\n      _taskCache.set(buffers[0], {\n        promise: texturePending\n      });\n      return texturePending;\n    }\n  }, {\n    key: \"_initTranscoder\",\n    value: function _initTranscoder() {\n      var _this4 = this;\n      if (!this.transcoderPending) {\n        var jsLoader = new FileLoader(this.manager);\n        jsLoader.setPath(this.transcoderPath);\n        jsLoader.setWithCredentials(this.withCredentials);\n        var jsContent = new Promise(function (resolve, reject) {\n          jsLoader.load(\"basis_transcoder.js\", resolve, void 0, reject);\n        });\n        var binaryLoader = new FileLoader(this.manager);\n        binaryLoader.setPath(this.transcoderPath);\n        binaryLoader.setResponseType(\"arraybuffer\");\n        binaryLoader.setWithCredentials(this.withCredentials);\n        var binaryContent = new Promise(function (resolve, reject) {\n          binaryLoader.load(\"basis_transcoder.wasm\", resolve, void 0, reject);\n        });\n        this.transcoderPending = Promise.all([jsContent, binaryContent]).then(function (_ref) {\n          var _ref2 = _slicedToArray(_ref, 2),\n            jsContent2 = _ref2[0],\n            binaryContent2 = _ref2[1];\n          var fn = _BasisTextureLoader.BasisWorker.toString();\n          var body = [\"/* constants */\", \"let _EngineFormat = \" + JSON.stringify(_BasisTextureLoader.EngineFormat), \"let _TranscoderFormat = \" + JSON.stringify(_BasisTextureLoader.TranscoderFormat), \"let _BasisFormat = \" + JSON.stringify(_BasisTextureLoader.BasisFormat), \"/* basis_transcoder.js */\", jsContent2, \"/* worker */\", fn.substring(fn.indexOf(\"{\") + 1, fn.lastIndexOf(\"}\"))].join(\"\\n\");\n          _this4.workerSourceURL = URL.createObjectURL(new Blob([body]));\n          _this4.transcoderBinary = binaryContent2;\n        });\n      }\n      return this.transcoderPending;\n    }\n  }, {\n    key: \"_allocateWorker\",\n    value: function _allocateWorker(taskCost) {\n      var _this5 = this;\n      return this._initTranscoder().then(function () {\n        if (_this5.workerPool.length < _this5.workerLimit) {\n          var worker2 = new Worker(_this5.workerSourceURL);\n          worker2._callbacks = {};\n          worker2._taskLoad = 0;\n          worker2.postMessage({\n            type: \"init\",\n            config: _this5.workerConfig,\n            transcoderBinary: _this5.transcoderBinary\n          });\n          worker2.onmessage = function (e) {\n            var message = e.data;\n            switch (message.type) {\n              case \"transcode\":\n                worker2._callbacks[message.id].resolve(message);\n                break;\n              case \"error\":\n                worker2._callbacks[message.id].reject(message);\n                break;\n              default:\n                console.error('THREE.BasisTextureLoader: Unexpected message, \"' + message.type + '\"');\n            }\n          };\n          _this5.workerPool.push(worker2);\n        } else {\n          _this5.workerPool.sort(function (a, b) {\n            return a._taskLoad > b._taskLoad ? -1 : 1;\n          });\n        }\n        var worker = _this5.workerPool[_this5.workerPool.length - 1];\n        worker._taskLoad += taskCost;\n        return worker;\n      });\n    }\n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      for (var i = 0; i < this.workerPool.length; i++) {\n        this.workerPool[i].terminate();\n      }\n      this.workerPool.length = 0;\n      return this;\n    }\n  }]);\n  return _BasisTextureLoader;\n}(Loader);\nvar BasisTextureLoader = _BasisTextureLoader;\n/* CONSTANTS */\n__publicField(BasisTextureLoader, \"BasisFormat\", {\n  ETC1S: 0,\n  UASTC_4x4: 1\n});\n__publicField(BasisTextureLoader, \"TranscoderFormat\", {\n  ETC1: 0,\n  ETC2: 1,\n  BC1: 2,\n  BC3: 3,\n  BC4: 4,\n  BC5: 5,\n  BC7_M6_OPAQUE_ONLY: 6,\n  BC7_M5: 7,\n  PVRTC1_4_RGB: 8,\n  PVRTC1_4_RGBA: 9,\n  ASTC_4x4: 10,\n  ATC_RGB: 11,\n  ATC_RGBA_INTERPOLATED_ALPHA: 12,\n  RGBA32: 13,\n  RGB565: 14,\n  BGR565: 15,\n  RGBA4444: 16\n});\n__publicField(BasisTextureLoader, \"EngineFormat\", {\n  RGBAFormat: RGBAFormat,\n  RGBA_ASTC_4x4_Format: RGBA_ASTC_4x4_Format,\n  RGBA_BPTC_Format: RGBA_BPTC_Format,\n  RGBA_ETC2_EAC_Format: RGBA_ETC2_EAC_Format,\n  RGBA_PVRTC_4BPPV1_Format: RGBA_PVRTC_4BPPV1_Format,\n  RGBA_S3TC_DXT5_Format: RGBA_S3TC_DXT5_Format,\n  RGB_ETC1_Format: RGB_ETC1_Format,\n  RGB_ETC2_Format: RGB_ETC2_Format,\n  RGB_PVRTC_4BPPV1_Format: RGB_PVRTC_4BPPV1_Format,\n  RGB_S3TC_DXT1_Format: RGB_S3TC_DXT1_Format\n});\n/* WEB WORKER */\n__publicField(BasisTextureLoader, \"BasisWorker\", function () {\n  var config;\n  var transcoderPending;\n  var BasisModule;\n  var EngineFormat = _EngineFormat;\n  var TranscoderFormat = _TranscoderFormat;\n  var BasisFormat = _BasisFormat;\n  onmessage = function onmessage(e) {\n    var message = e.data;\n    switch (message.type) {\n      case \"init\":\n        config = message.config;\n        init(message.transcoderBinary);\n        break;\n      case \"transcode\":\n        transcoderPending.then(function () {\n          try {\n            var _ref3 = message.taskConfig.lowLevel ? transcodeLowLevel(message.taskConfig) : transcode(message.buffers[0]),\n              width = _ref3.width,\n              height = _ref3.height,\n              hasAlpha = _ref3.hasAlpha,\n              mipmaps = _ref3.mipmaps,\n              format = _ref3.format;\n            var buffers = [];\n            for (var i = 0; i < mipmaps.length; ++i) {\n              buffers.push(mipmaps[i].data.buffer);\n            }\n            self.postMessage({\n              type: \"transcode\",\n              id: message.id,\n              width: width,\n              height: height,\n              hasAlpha: hasAlpha,\n              mipmaps: mipmaps,\n              format: format\n            }, buffers);\n          } catch (error) {\n            console.error(error);\n            self.postMessage({\n              type: \"error\",\n              id: message.id,\n              error: error.message\n            });\n          }\n        });\n        break;\n    }\n  };\n  function init(wasmBinary) {\n    transcoderPending = new Promise(function (resolve) {\n      BasisModule = {\n        wasmBinary: wasmBinary,\n        onRuntimeInitialized: resolve\n      };\n      BASIS(BasisModule);\n    }).then(function () {\n      BasisModule.initializeBasis();\n    });\n  }\n  function transcodeLowLevel(taskConfig) {\n    var basisFormat = taskConfig.basisFormat,\n      width = taskConfig.width,\n      height = taskConfig.height,\n      hasAlpha = taskConfig.hasAlpha;\n    var _getTranscoderFormat = getTranscoderFormat(basisFormat, width, height, hasAlpha),\n      transcoderFormat = _getTranscoderFormat.transcoderFormat,\n      engineFormat = _getTranscoderFormat.engineFormat;\n    var blockByteLength = BasisModule.getBytesPerBlockOrPixel(transcoderFormat);\n    assert(BasisModule.isFormatSupported(transcoderFormat), \"THREE.BasisTextureLoader: Unsupported format.\");\n    var mipmaps = [];\n    if (basisFormat === BasisFormat.ETC1S) {\n      var transcoder = new BasisModule.LowLevelETC1SImageTranscoder();\n      var _taskConfig$globalDat = taskConfig.globalData,\n        endpointCount = _taskConfig$globalDat.endpointCount,\n        endpointsData = _taskConfig$globalDat.endpointsData,\n        selectorCount = _taskConfig$globalDat.selectorCount,\n        selectorsData = _taskConfig$globalDat.selectorsData,\n        tablesData = _taskConfig$globalDat.tablesData;\n      try {\n        var ok;\n        ok = transcoder.decodePalettes(endpointCount, endpointsData, selectorCount, selectorsData);\n        assert(ok, \"THREE.BasisTextureLoader: decodePalettes() failed.\");\n        ok = transcoder.decodeTables(tablesData);\n        assert(ok, \"THREE.BasisTextureLoader: decodeTables() failed.\");\n        for (var i = 0; i < taskConfig.levels.length; i++) {\n          var level = taskConfig.levels[i];\n          var imageDesc = taskConfig.globalData.imageDescs[i];\n          var dstByteLength = getTranscodedImageByteLength(transcoderFormat, level.width, level.height);\n          var dst = new Uint8Array(dstByteLength);\n          ok = transcoder.transcodeImage(transcoderFormat, dst, dstByteLength / blockByteLength, level.data, getWidthInBlocks(transcoderFormat, level.width), getHeightInBlocks(transcoderFormat, level.height), level.width, level.height, level.index, imageDesc.rgbSliceByteOffset, imageDesc.rgbSliceByteLength, imageDesc.alphaSliceByteOffset, imageDesc.alphaSliceByteLength, imageDesc.imageFlags, hasAlpha, false, 0, 0);\n          assert(ok, \"THREE.BasisTextureLoader: transcodeImage() failed for level \" + level.index + \".\");\n          mipmaps.push({\n            data: dst,\n            width: level.width,\n            height: level.height\n          });\n        }\n      } finally {\n        transcoder.delete();\n      }\n    } else {\n      for (var _i = 0; _i < taskConfig.levels.length; _i++) {\n        var _level = taskConfig.levels[_i];\n        var _dstByteLength = getTranscodedImageByteLength(transcoderFormat, _level.width, _level.height);\n        var _dst = new Uint8Array(_dstByteLength);\n        var _ok = BasisModule.transcodeUASTCImage(transcoderFormat, _dst, _dstByteLength / blockByteLength, _level.data, getWidthInBlocks(transcoderFormat, _level.width), getHeightInBlocks(transcoderFormat, _level.height), _level.width, _level.height, _level.index, 0, _level.data.byteLength, 0, hasAlpha, false, 0, 0, -1, -1);\n        assert(_ok, \"THREE.BasisTextureLoader: transcodeUASTCImage() failed for level \" + _level.index + \".\");\n        mipmaps.push({\n          data: _dst,\n          width: _level.width,\n          height: _level.height\n        });\n      }\n    }\n    return {\n      width: width,\n      height: height,\n      hasAlpha: hasAlpha,\n      mipmaps: mipmaps,\n      format: engineFormat\n    };\n  }\n  function transcode(buffer) {\n    var basisFile = new BasisModule.BasisFile(new Uint8Array(buffer));\n    var basisFormat = basisFile.isUASTC() ? BasisFormat.UASTC_4x4 : BasisFormat.ETC1S;\n    var width = basisFile.getImageWidth(0, 0);\n    var height = basisFile.getImageHeight(0, 0);\n    var levels = basisFile.getNumLevels(0);\n    var hasAlpha = basisFile.getHasAlpha();\n    function cleanup() {\n      basisFile.close();\n      basisFile.delete();\n    }\n    var _getTranscoderFormat2 = getTranscoderFormat(basisFormat, width, height, hasAlpha),\n      transcoderFormat = _getTranscoderFormat2.transcoderFormat,\n      engineFormat = _getTranscoderFormat2.engineFormat;\n    if (!width || !height || !levels) {\n      cleanup();\n      throw new Error(\"THREE.BasisTextureLoader:\tInvalid texture\");\n    }\n    if (!basisFile.startTranscoding()) {\n      cleanup();\n      throw new Error(\"THREE.BasisTextureLoader: .startTranscoding failed\");\n    }\n    var mipmaps = [];\n    for (var mip = 0; mip < levels; mip++) {\n      var mipWidth = basisFile.getImageWidth(0, mip);\n      var mipHeight = basisFile.getImageHeight(0, mip);\n      var dst = new Uint8Array(basisFile.getImageTranscodedSizeInBytes(0, mip, transcoderFormat));\n      var status = basisFile.transcodeImage(dst, 0, mip, transcoderFormat, 0, hasAlpha);\n      if (!status) {\n        cleanup();\n        throw new Error(\"THREE.BasisTextureLoader: .transcodeImage failed.\");\n      }\n      mipmaps.push({\n        data: dst,\n        width: mipWidth,\n        height: mipHeight\n      });\n    }\n    cleanup();\n    return {\n      width: width,\n      height: height,\n      hasAlpha: hasAlpha,\n      mipmaps: mipmaps,\n      format: engineFormat\n    };\n  }\n  var FORMAT_OPTIONS = [{\n    if: \"astcSupported\",\n    basisFormat: [BasisFormat.UASTC_4x4],\n    transcoderFormat: [TranscoderFormat.ASTC_4x4, TranscoderFormat.ASTC_4x4],\n    engineFormat: [EngineFormat.RGBA_ASTC_4x4_Format, EngineFormat.RGBA_ASTC_4x4_Format],\n    priorityETC1S: Infinity,\n    priorityUASTC: 1,\n    needsPowerOfTwo: false\n  }, {\n    if: \"bptcSupported\",\n    basisFormat: [BasisFormat.ETC1S, BasisFormat.UASTC_4x4],\n    transcoderFormat: [TranscoderFormat.BC7_M5, TranscoderFormat.BC7_M5],\n    engineFormat: [EngineFormat.RGBA_BPTC_Format, EngineFormat.RGBA_BPTC_Format],\n    priorityETC1S: 3,\n    priorityUASTC: 2,\n    needsPowerOfTwo: false\n  }, {\n    if: \"dxtSupported\",\n    basisFormat: [BasisFormat.ETC1S, BasisFormat.UASTC_4x4],\n    transcoderFormat: [TranscoderFormat.BC1, TranscoderFormat.BC3],\n    engineFormat: [EngineFormat.RGB_S3TC_DXT1_Format, EngineFormat.RGBA_S3TC_DXT5_Format],\n    priorityETC1S: 4,\n    priorityUASTC: 5,\n    needsPowerOfTwo: false\n  }, {\n    if: \"etc2Supported\",\n    basisFormat: [BasisFormat.ETC1S, BasisFormat.UASTC_4x4],\n    transcoderFormat: [TranscoderFormat.ETC1, TranscoderFormat.ETC2],\n    engineFormat: [EngineFormat.RGB_ETC2_Format, EngineFormat.RGBA_ETC2_EAC_Format],\n    priorityETC1S: 1,\n    priorityUASTC: 3,\n    needsPowerOfTwo: false\n  }, {\n    if: \"etc1Supported\",\n    basisFormat: [BasisFormat.ETC1S, BasisFormat.UASTC_4x4],\n    transcoderFormat: [TranscoderFormat.ETC1, TranscoderFormat.ETC1],\n    engineFormat: [EngineFormat.RGB_ETC1_Format, EngineFormat.RGB_ETC1_Format],\n    priorityETC1S: 2,\n    priorityUASTC: 4,\n    needsPowerOfTwo: false\n  }, {\n    if: \"pvrtcSupported\",\n    basisFormat: [BasisFormat.ETC1S, BasisFormat.UASTC_4x4],\n    transcoderFormat: [TranscoderFormat.PVRTC1_4_RGB, TranscoderFormat.PVRTC1_4_RGBA],\n    engineFormat: [EngineFormat.RGB_PVRTC_4BPPV1_Format, EngineFormat.RGBA_PVRTC_4BPPV1_Format],\n    priorityETC1S: 5,\n    priorityUASTC: 6,\n    needsPowerOfTwo: true\n  }];\n  var ETC1S_OPTIONS = FORMAT_OPTIONS.sort(function (a, b) {\n    return a.priorityETC1S - b.priorityETC1S;\n  });\n  var UASTC_OPTIONS = FORMAT_OPTIONS.sort(function (a, b) {\n    return a.priorityUASTC - b.priorityUASTC;\n  });\n  function getTranscoderFormat(basisFormat, width, height, hasAlpha) {\n    var transcoderFormat;\n    var engineFormat;\n    var options = basisFormat === BasisFormat.ETC1S ? ETC1S_OPTIONS : UASTC_OPTIONS;\n    for (var i = 0; i < options.length; i++) {\n      var opt = options[i];\n      if (!config[opt.if]) continue;\n      if (!opt.basisFormat.includes(basisFormat)) continue;\n      if (opt.needsPowerOfTwo && !(isPowerOfTwo(width) && isPowerOfTwo(height))) continue;\n      transcoderFormat = opt.transcoderFormat[hasAlpha ? 1 : 0];\n      engineFormat = opt.engineFormat[hasAlpha ? 1 : 0];\n      return {\n        transcoderFormat: transcoderFormat,\n        engineFormat: engineFormat\n      };\n    }\n    console.warn(\"THREE.BasisTextureLoader: No suitable compressed texture format found. Decoding to RGBA32.\");\n    transcoderFormat = TranscoderFormat.RGBA32;\n    engineFormat = EngineFormat.RGBAFormat;\n    return {\n      transcoderFormat: transcoderFormat,\n      engineFormat: engineFormat\n    };\n  }\n  function assert(ok, message) {\n    if (!ok) throw new Error(message);\n  }\n  function getWidthInBlocks(transcoderFormat, width) {\n    return Math.ceil(width / BasisModule.getFormatBlockWidth(transcoderFormat));\n  }\n  function getHeightInBlocks(transcoderFormat, height) {\n    return Math.ceil(height / BasisModule.getFormatBlockHeight(transcoderFormat));\n  }\n  function getTranscodedImageByteLength(transcoderFormat, width, height) {\n    var blockByteLength = BasisModule.getBytesPerBlockOrPixel(transcoderFormat);\n    if (BasisModule.formatIsUncompressed(transcoderFormat)) {\n      return width * height * blockByteLength;\n    }\n    if (transcoderFormat === TranscoderFormat.PVRTC1_4_RGB || transcoderFormat === TranscoderFormat.PVRTC1_4_RGBA) {\n      var paddedWidth = width + 3 & ~3;\n      var paddedHeight = height + 3 & ~3;\n      return (Math.max(8, paddedWidth) * Math.max(8, paddedHeight) * 4 + 7) / 8;\n    }\n    return getWidthInBlocks(transcoderFormat, width) * getHeightInBlocks(transcoderFormat, height) * blockByteLength;\n  }\n  function isPowerOfTwo(value) {\n    if (value <= 2) return true;\n    return (value & value - 1) === 0 && value !== 0;\n  }\n});\nexport { BasisTextureLoader };","map":{"version":3,"names":["_taskCache","WeakMap","_BasisTextureLoader","_Loader","_inherits","_super","_createSuper","manager","_this","_classCallCheck","call","transcoderPath","transcoderBinary","transcoderPending","workerLimit","workerPool","workerNextTaskID","workerSourceURL","workerConfig","_createClass","key","value","setTranscoderPath","path","setWorkerLimit","detectSupport","renderer","astcSupported","extensions","has","etc1Supported","etc2Supported","dxtSupported","bptcSupported","pvrtcSupported","load","url","onLoad","onProgress","onError","_this2","loader","FileLoader","setResponseType","setWithCredentials","withCredentials","texture","CompressedTexture","buffer","cachedTask","get","promise","then","catch","_createTexture","_texture","copy","needsUpdate","parseInternalAsync","options","levels","buffers","Set","i","length","add","data","Array","from","_objectSpread","lowLevel","_this3","config","arguments","undefined","worker","taskID","taskConfig","taskCost","byteLength","texturePending","_allocateWorker","_worker","Promise","resolve","reject","_callbacks","postMessage","type","id","message","mipmaps","width","height","format","UnsignedByteType","minFilter","LinearFilter","LinearMipmapLinearFilter","magFilter","generateMipmaps","_taskLoad","set","_initTranscoder","_this4","jsLoader","setPath","jsContent","binaryLoader","binaryContent","all","_ref","_ref2","_slicedToArray","jsContent2","binaryContent2","fn","BasisWorker","toString","body","JSON","stringify","EngineFormat","TranscoderFormat","BasisFormat","substring","indexOf","lastIndexOf","join","URL","createObjectURL","Blob","_this5","worker2","Worker","onmessage","e","console","error","push","sort","a","b","dispose","terminate","Loader","BasisTextureLoader","__publicField","ETC1S","UASTC_4x4","ETC1","ETC2","BC1","BC3","BC4","BC5","BC7_M6_OPAQUE_ONLY","BC7_M5","PVRTC1_4_RGB","PVRTC1_4_RGBA","ASTC_4x4","ATC_RGB","ATC_RGBA_INTERPOLATED_ALPHA","RGBA32","RGB565","BGR565","RGBA4444","RGBAFormat","RGBA_ASTC_4x4_Format","RGBA_BPTC_Format","RGBA_ETC2_EAC_Format","RGBA_PVRTC_4BPPV1_Format","RGBA_S3TC_DXT5_Format","RGB_ETC1_Format","RGB_ETC2_Format","RGB_PVRTC_4BPPV1_Format","RGB_S3TC_DXT1_Format","BasisModule","_EngineFormat","_TranscoderFormat","_BasisFormat","init","_ref3","transcodeLowLevel","transcode","hasAlpha","self","wasmBinary","onRuntimeInitialized","BASIS","initializeBasis","basisFormat","_getTranscoderFormat","getTranscoderFormat","transcoderFormat","engineFormat","blockByteLength","getBytesPerBlockOrPixel","assert","isFormatSupported","transcoder","LowLevelETC1SImageTranscoder","_taskConfig$globalDat","globalData","endpointCount","endpointsData","selectorCount","selectorsData","tablesData","ok","decodePalettes","decodeTables","level","imageDesc","imageDescs","dstByteLength","getTranscodedImageByteLength","dst","Uint8Array","transcodeImage","getWidthInBlocks","getHeightInBlocks","index","rgbSliceByteOffset","rgbSliceByteLength","alphaSliceByteOffset","alphaSliceByteLength","imageFlags","delete","transcodeUASTCImage","basisFile","BasisFile","isUASTC","getImageWidth","getImageHeight","getNumLevels","getHasAlpha","cleanup","close","_getTranscoderFormat2","Error","startTranscoding","mip","mipWidth","mipHeight","getImageTranscodedSizeInBytes","status","FORMAT_OPTIONS","if","priorityETC1S","Infinity","priorityUASTC","needsPowerOfTwo","ETC1S_OPTIONS","UASTC_OPTIONS","opt","includes","isPowerOfTwo","warn","Math","ceil","getFormatBlockWidth","getFormatBlockHeight","formatIsUncompressed","paddedWidth","paddedHeight","max"],"sources":["C:\\Users\\Nayyu\\Desktop\\skibidai-public-build\\node_modules\\src\\loaders\\BasisTextureLoader.js"],"sourcesContent":["import {\n  CompressedTexture,\n  FileLoader,\n  LinearFilter,\n  LinearMipmapLinearFilter,\n  Loader,\n  RGBAFormat,\n  RGBA_ASTC_4x4_Format,\n  RGBA_BPTC_Format,\n  RGBA_ETC2_EAC_Format,\n  RGBA_PVRTC_4BPPV1_Format,\n  RGBA_S3TC_DXT5_Format,\n  RGB_ETC1_Format,\n  RGB_ETC2_Format,\n  RGB_PVRTC_4BPPV1_Format,\n  RGB_S3TC_DXT1_Format,\n  UnsignedByteType,\n} from 'three'\n\n/**\n * Loader for Basis Universal GPU Texture Codec.\n *\n * Basis Universal is a \"supercompressed\" GPU texture and texture video\n * compression system that outputs a highly compressed intermediate file format\n * (.basis) that can be quickly transcoded to a wide variety of GPU texture\n * compression formats.\n *\n * This loader parallelizes the transcoding process across a configurable number\n * of web workers, before transferring the transcoded compressed texture back\n * to the main thread.\n */\n\nconst _taskCache = new WeakMap()\n\nclass BasisTextureLoader extends Loader {\n  /* CONSTANTS */\n\n  static BasisFormat = {\n    ETC1S: 0,\n    UASTC_4x4: 1,\n  }\n\n  static TranscoderFormat = {\n    ETC1: 0,\n    ETC2: 1,\n    BC1: 2,\n    BC3: 3,\n    BC4: 4,\n    BC5: 5,\n    BC7_M6_OPAQUE_ONLY: 6,\n    BC7_M5: 7,\n    PVRTC1_4_RGB: 8,\n    PVRTC1_4_RGBA: 9,\n    ASTC_4x4: 10,\n    ATC_RGB: 11,\n    ATC_RGBA_INTERPOLATED_ALPHA: 12,\n    RGBA32: 13,\n    RGB565: 14,\n    BGR565: 15,\n    RGBA4444: 16,\n  }\n\n  static EngineFormat = {\n    RGBAFormat: RGBAFormat,\n    RGBA_ASTC_4x4_Format: RGBA_ASTC_4x4_Format,\n    RGBA_BPTC_Format: RGBA_BPTC_Format,\n    RGBA_ETC2_EAC_Format: RGBA_ETC2_EAC_Format,\n    RGBA_PVRTC_4BPPV1_Format: RGBA_PVRTC_4BPPV1_Format,\n    RGBA_S3TC_DXT5_Format: RGBA_S3TC_DXT5_Format,\n    RGB_ETC1_Format: RGB_ETC1_Format,\n    RGB_ETC2_Format: RGB_ETC2_Format,\n    RGB_PVRTC_4BPPV1_Format: RGB_PVRTC_4BPPV1_Format,\n    RGB_S3TC_DXT1_Format: RGB_S3TC_DXT1_Format,\n  }\n\n  /* WEB WORKER */\n\n  static BasisWorker = function () {\n    let config\n    let transcoderPending\n    let BasisModule\n\n    const EngineFormat = _EngineFormat\n    const TranscoderFormat = _TranscoderFormat\n    const BasisFormat = _BasisFormat\n\n    onmessage = function (e) {\n      const message = e.data\n\n      switch (message.type) {\n        case 'init':\n          config = message.config\n          init(message.transcoderBinary)\n          break\n\n        case 'transcode':\n          transcoderPending.then(() => {\n            try {\n              const { width, height, hasAlpha, mipmaps, format } = message.taskConfig.lowLevel\n                ? transcodeLowLevel(message.taskConfig)\n                : transcode(message.buffers[0])\n\n              const buffers = []\n\n              for (let i = 0; i < mipmaps.length; ++i) {\n                buffers.push(mipmaps[i].data.buffer)\n              }\n\n              self.postMessage({ type: 'transcode', id: message.id, width, height, hasAlpha, mipmaps, format }, buffers)\n            } catch (error) {\n              console.error(error)\n\n              self.postMessage({ type: 'error', id: message.id, error: error.message })\n            }\n          })\n          break\n      }\n    }\n\n    function init(wasmBinary) {\n      transcoderPending = new Promise((resolve) => {\n        BasisModule = { wasmBinary, onRuntimeInitialized: resolve }\n        BASIS(BasisModule)\n      }).then(() => {\n        BasisModule.initializeBasis()\n      })\n    }\n\n    function transcodeLowLevel(taskConfig) {\n      const { basisFormat, width, height, hasAlpha } = taskConfig\n\n      const { transcoderFormat, engineFormat } = getTranscoderFormat(basisFormat, width, height, hasAlpha)\n\n      const blockByteLength = BasisModule.getBytesPerBlockOrPixel(transcoderFormat)\n\n      assert(BasisModule.isFormatSupported(transcoderFormat), 'THREE.BasisTextureLoader: Unsupported format.')\n\n      const mipmaps = []\n\n      if (basisFormat === BasisFormat.ETC1S) {\n        const transcoder = new BasisModule.LowLevelETC1SImageTranscoder()\n\n        const { endpointCount, endpointsData, selectorCount, selectorsData, tablesData } = taskConfig.globalData\n\n        try {\n          let ok\n\n          ok = transcoder.decodePalettes(endpointCount, endpointsData, selectorCount, selectorsData)\n\n          assert(ok, 'THREE.BasisTextureLoader: decodePalettes() failed.')\n\n          ok = transcoder.decodeTables(tablesData)\n\n          assert(ok, 'THREE.BasisTextureLoader: decodeTables() failed.')\n\n          for (let i = 0; i < taskConfig.levels.length; i++) {\n            const level = taskConfig.levels[i]\n            const imageDesc = taskConfig.globalData.imageDescs[i]\n\n            const dstByteLength = getTranscodedImageByteLength(transcoderFormat, level.width, level.height)\n            const dst = new Uint8Array(dstByteLength)\n\n            ok = transcoder.transcodeImage(\n              transcoderFormat,\n              dst,\n              dstByteLength / blockByteLength,\n              level.data,\n              getWidthInBlocks(transcoderFormat, level.width),\n              getHeightInBlocks(transcoderFormat, level.height),\n              level.width,\n              level.height,\n              level.index,\n              imageDesc.rgbSliceByteOffset,\n              imageDesc.rgbSliceByteLength,\n              imageDesc.alphaSliceByteOffset,\n              imageDesc.alphaSliceByteLength,\n              imageDesc.imageFlags,\n              hasAlpha,\n              false,\n              0,\n              0,\n            )\n\n            assert(ok, 'THREE.BasisTextureLoader: transcodeImage() failed for level ' + level.index + '.')\n\n            mipmaps.push({ data: dst, width: level.width, height: level.height })\n          }\n        } finally {\n          transcoder.delete()\n        }\n      } else {\n        for (let i = 0; i < taskConfig.levels.length; i++) {\n          const level = taskConfig.levels[i]\n\n          const dstByteLength = getTranscodedImageByteLength(transcoderFormat, level.width, level.height)\n          const dst = new Uint8Array(dstByteLength)\n\n          const ok = BasisModule.transcodeUASTCImage(\n            transcoderFormat,\n            dst,\n            dstByteLength / blockByteLength,\n            level.data,\n            getWidthInBlocks(transcoderFormat, level.width),\n            getHeightInBlocks(transcoderFormat, level.height),\n            level.width,\n            level.height,\n            level.index,\n            0,\n            level.data.byteLength,\n            0,\n            hasAlpha,\n            false,\n            0,\n            0,\n            -1,\n            -1,\n          )\n\n          assert(ok, 'THREE.BasisTextureLoader: transcodeUASTCImage() failed for level ' + level.index + '.')\n\n          mipmaps.push({ data: dst, width: level.width, height: level.height })\n        }\n      }\n\n      return { width, height, hasAlpha, mipmaps, format: engineFormat }\n    }\n\n    function transcode(buffer) {\n      const basisFile = new BasisModule.BasisFile(new Uint8Array(buffer))\n\n      const basisFormat = basisFile.isUASTC() ? BasisFormat.UASTC_4x4 : BasisFormat.ETC1S\n      const width = basisFile.getImageWidth(0, 0)\n      const height = basisFile.getImageHeight(0, 0)\n      const levels = basisFile.getNumLevels(0)\n      const hasAlpha = basisFile.getHasAlpha()\n\n      function cleanup() {\n        basisFile.close()\n        basisFile.delete()\n      }\n\n      const { transcoderFormat, engineFormat } = getTranscoderFormat(basisFormat, width, height, hasAlpha)\n\n      if (!width || !height || !levels) {\n        cleanup()\n        throw new Error('THREE.BasisTextureLoader:\tInvalid texture')\n      }\n\n      if (!basisFile.startTranscoding()) {\n        cleanup()\n        throw new Error('THREE.BasisTextureLoader: .startTranscoding failed')\n      }\n\n      const mipmaps = []\n\n      for (let mip = 0; mip < levels; mip++) {\n        const mipWidth = basisFile.getImageWidth(0, mip)\n        const mipHeight = basisFile.getImageHeight(0, mip)\n        const dst = new Uint8Array(basisFile.getImageTranscodedSizeInBytes(0, mip, transcoderFormat))\n\n        const status = basisFile.transcodeImage(dst, 0, mip, transcoderFormat, 0, hasAlpha)\n\n        if (!status) {\n          cleanup()\n          throw new Error('THREE.BasisTextureLoader: .transcodeImage failed.')\n        }\n\n        mipmaps.push({ data: dst, width: mipWidth, height: mipHeight })\n      }\n\n      cleanup()\n\n      return { width, height, hasAlpha, mipmaps, format: engineFormat }\n    }\n\n    //\n\n    // Optimal choice of a transcoder target format depends on the Basis format (ETC1S or UASTC),\n    // device capabilities, and texture dimensions. The list below ranks the formats separately\n    // for ETC1S and UASTC.\n    //\n    // In some cases, transcoding UASTC to RGBA32 might be preferred for higher quality (at\n    // significant memory cost) compared to ETC1/2, BC1/3, and PVRTC. The transcoder currently\n    // chooses RGBA32 only as a last resort and does not expose that option to the caller.\n    const FORMAT_OPTIONS = [\n      {\n        if: 'astcSupported',\n        basisFormat: [BasisFormat.UASTC_4x4],\n        transcoderFormat: [TranscoderFormat.ASTC_4x4, TranscoderFormat.ASTC_4x4],\n        engineFormat: [EngineFormat.RGBA_ASTC_4x4_Format, EngineFormat.RGBA_ASTC_4x4_Format],\n        priorityETC1S: Infinity,\n        priorityUASTC: 1,\n        needsPowerOfTwo: false,\n      },\n      {\n        if: 'bptcSupported',\n        basisFormat: [BasisFormat.ETC1S, BasisFormat.UASTC_4x4],\n        transcoderFormat: [TranscoderFormat.BC7_M5, TranscoderFormat.BC7_M5],\n        engineFormat: [EngineFormat.RGBA_BPTC_Format, EngineFormat.RGBA_BPTC_Format],\n        priorityETC1S: 3,\n        priorityUASTC: 2,\n        needsPowerOfTwo: false,\n      },\n      {\n        if: 'dxtSupported',\n        basisFormat: [BasisFormat.ETC1S, BasisFormat.UASTC_4x4],\n        transcoderFormat: [TranscoderFormat.BC1, TranscoderFormat.BC3],\n        engineFormat: [EngineFormat.RGB_S3TC_DXT1_Format, EngineFormat.RGBA_S3TC_DXT5_Format],\n        priorityETC1S: 4,\n        priorityUASTC: 5,\n        needsPowerOfTwo: false,\n      },\n      {\n        if: 'etc2Supported',\n        basisFormat: [BasisFormat.ETC1S, BasisFormat.UASTC_4x4],\n        transcoderFormat: [TranscoderFormat.ETC1, TranscoderFormat.ETC2],\n        engineFormat: [EngineFormat.RGB_ETC2_Format, EngineFormat.RGBA_ETC2_EAC_Format],\n        priorityETC1S: 1,\n        priorityUASTC: 3,\n        needsPowerOfTwo: false,\n      },\n      {\n        if: 'etc1Supported',\n        basisFormat: [BasisFormat.ETC1S, BasisFormat.UASTC_4x4],\n        transcoderFormat: [TranscoderFormat.ETC1, TranscoderFormat.ETC1],\n        engineFormat: [EngineFormat.RGB_ETC1_Format, EngineFormat.RGB_ETC1_Format],\n        priorityETC1S: 2,\n        priorityUASTC: 4,\n        needsPowerOfTwo: false,\n      },\n      {\n        if: 'pvrtcSupported',\n        basisFormat: [BasisFormat.ETC1S, BasisFormat.UASTC_4x4],\n        transcoderFormat: [TranscoderFormat.PVRTC1_4_RGB, TranscoderFormat.PVRTC1_4_RGBA],\n        engineFormat: [EngineFormat.RGB_PVRTC_4BPPV1_Format, EngineFormat.RGBA_PVRTC_4BPPV1_Format],\n        priorityETC1S: 5,\n        priorityUASTC: 6,\n        needsPowerOfTwo: true,\n      },\n    ]\n\n    const ETC1S_OPTIONS = FORMAT_OPTIONS.sort(function (a, b) {\n      return a.priorityETC1S - b.priorityETC1S\n    })\n    const UASTC_OPTIONS = FORMAT_OPTIONS.sort(function (a, b) {\n      return a.priorityUASTC - b.priorityUASTC\n    })\n\n    function getTranscoderFormat(basisFormat, width, height, hasAlpha) {\n      let transcoderFormat\n      let engineFormat\n\n      const options = basisFormat === BasisFormat.ETC1S ? ETC1S_OPTIONS : UASTC_OPTIONS\n\n      for (let i = 0; i < options.length; i++) {\n        const opt = options[i]\n\n        if (!config[opt.if]) continue\n        if (!opt.basisFormat.includes(basisFormat)) continue\n        if (opt.needsPowerOfTwo && !(isPowerOfTwo(width) && isPowerOfTwo(height))) continue\n\n        transcoderFormat = opt.transcoderFormat[hasAlpha ? 1 : 0]\n        engineFormat = opt.engineFormat[hasAlpha ? 1 : 0]\n\n        return { transcoderFormat, engineFormat }\n      }\n\n      console.warn('THREE.BasisTextureLoader: No suitable compressed texture format found. Decoding to RGBA32.')\n\n      transcoderFormat = TranscoderFormat.RGBA32\n      engineFormat = EngineFormat.RGBAFormat\n\n      return { transcoderFormat, engineFormat }\n    }\n\n    function assert(ok, message) {\n      if (!ok) throw new Error(message)\n    }\n\n    function getWidthInBlocks(transcoderFormat, width) {\n      return Math.ceil(width / BasisModule.getFormatBlockWidth(transcoderFormat))\n    }\n\n    function getHeightInBlocks(transcoderFormat, height) {\n      return Math.ceil(height / BasisModule.getFormatBlockHeight(transcoderFormat))\n    }\n\n    function getTranscodedImageByteLength(transcoderFormat, width, height) {\n      const blockByteLength = BasisModule.getBytesPerBlockOrPixel(transcoderFormat)\n\n      if (BasisModule.formatIsUncompressed(transcoderFormat)) {\n        return width * height * blockByteLength\n      }\n\n      if (transcoderFormat === TranscoderFormat.PVRTC1_4_RGB || transcoderFormat === TranscoderFormat.PVRTC1_4_RGBA) {\n        // GL requires extra padding for very small textures:\n        // https://www.khronos.org/registry/OpenGL/extensions/IMG/IMG_texture_compression_pvrtc.txt\n        const paddedWidth = (width + 3) & ~3\n        const paddedHeight = (height + 3) & ~3\n\n        return (Math.max(8, paddedWidth) * Math.max(8, paddedHeight) * 4 + 7) / 8\n      }\n\n      return getWidthInBlocks(transcoderFormat, width) * getHeightInBlocks(transcoderFormat, height) * blockByteLength\n    }\n\n    function isPowerOfTwo(value) {\n      if (value <= 2) return true\n\n      return (value & (value - 1)) === 0 && value !== 0\n    }\n  }\n\n  constructor(manager) {\n    super(manager)\n\n    this.transcoderPath = ''\n    this.transcoderBinary = null\n    this.transcoderPending = null\n\n    this.workerLimit = 4\n    this.workerPool = []\n    this.workerNextTaskID = 1\n    this.workerSourceURL = ''\n    this.workerConfig = null\n  }\n\n  setTranscoderPath(path) {\n    this.transcoderPath = path\n\n    return this\n  }\n\n  setWorkerLimit(workerLimit) {\n    this.workerLimit = workerLimit\n\n    return this\n  }\n\n  detectSupport(renderer) {\n    this.workerConfig = {\n      astcSupported: renderer.extensions.has('WEBGL_compressed_texture_astc'),\n      etc1Supported: renderer.extensions.has('WEBGL_compressed_texture_etc1'),\n      etc2Supported: renderer.extensions.has('WEBGL_compressed_texture_etc'),\n      dxtSupported: renderer.extensions.has('WEBGL_compressed_texture_s3tc'),\n      bptcSupported: renderer.extensions.has('EXT_texture_compression_bptc'),\n      pvrtcSupported:\n        renderer.extensions.has('WEBGL_compressed_texture_pvrtc') ||\n        renderer.extensions.has('WEBKIT_WEBGL_compressed_texture_pvrtc'),\n    }\n\n    return this\n  }\n\n  load(url, onLoad, onProgress, onError) {\n    const loader = new FileLoader(this.manager)\n\n    loader.setResponseType('arraybuffer')\n    loader.setWithCredentials(this.withCredentials)\n\n    const texture = new CompressedTexture()\n\n    loader.load(\n      url,\n      (buffer) => {\n        // Check for an existing task using this buffer. A transferred buffer cannot be transferred\n        // again from this thread.\n        if (_taskCache.has(buffer)) {\n          const cachedTask = _taskCache.get(buffer)\n\n          return cachedTask.promise.then(onLoad).catch(onError)\n        }\n\n        this._createTexture([buffer])\n          .then(function (_texture) {\n            texture.copy(_texture)\n            texture.needsUpdate = true\n\n            if (onLoad) onLoad(texture)\n          })\n          .catch(onError)\n      },\n      onProgress,\n      onError,\n    )\n\n    return texture\n  }\n\n  /** Low-level transcoding API, exposed for use by KTX2Loader. */\n  parseInternalAsync(options) {\n    const { levels } = options\n\n    const buffers = new Set()\n\n    for (let i = 0; i < levels.length; i++) {\n      buffers.add(levels[i].data.buffer)\n    }\n\n    return this._createTexture(Array.from(buffers), { ...options, lowLevel: true })\n  }\n\n  /**\n   * @param {ArrayBuffer[]} buffers\n   * @param {object?} config\n   * @return {Promise<CompressedTexture>}\n   */\n  _createTexture(buffers, config = {}) {\n    let worker\n    let taskID\n\n    const taskConfig = config\n    let taskCost = 0\n\n    for (let i = 0; i < buffers.length; i++) {\n      taskCost += buffers[i].byteLength\n    }\n\n    const texturePending = this._allocateWorker(taskCost)\n      .then((_worker) => {\n        worker = _worker\n        taskID = this.workerNextTaskID++\n\n        return new Promise((resolve, reject) => {\n          worker._callbacks[taskID] = { resolve, reject }\n\n          worker.postMessage({ type: 'transcode', id: taskID, buffers: buffers, taskConfig: taskConfig }, buffers)\n        })\n      })\n      .then((message) => {\n        const { mipmaps, width, height, format } = message\n\n        const texture = new CompressedTexture(mipmaps, width, height, format, UnsignedByteType)\n        texture.minFilter = mipmaps.length === 1 ? LinearFilter : LinearMipmapLinearFilter\n        texture.magFilter = LinearFilter\n        texture.generateMipmaps = false\n        texture.needsUpdate = true\n\n        return texture\n      })\n\n    // Note: replaced '.finally()' with '.catch().then()' block - iOS 11 support (#19416)\n    texturePending\n      .catch(() => true)\n      .then(() => {\n        if (worker && taskID) {\n          worker._taskLoad -= taskCost\n          delete worker._callbacks[taskID]\n        }\n      })\n\n    // Cache the task result.\n    _taskCache.set(buffers[0], { promise: texturePending })\n\n    return texturePending\n  }\n\n  _initTranscoder() {\n    if (!this.transcoderPending) {\n      // Load transcoder wrapper.\n      const jsLoader = new FileLoader(this.manager)\n      jsLoader.setPath(this.transcoderPath)\n      jsLoader.setWithCredentials(this.withCredentials)\n      const jsContent = new Promise((resolve, reject) => {\n        jsLoader.load('basis_transcoder.js', resolve, undefined, reject)\n      })\n\n      // Load transcoder WASM binary.\n      const binaryLoader = new FileLoader(this.manager)\n      binaryLoader.setPath(this.transcoderPath)\n      binaryLoader.setResponseType('arraybuffer')\n      binaryLoader.setWithCredentials(this.withCredentials)\n      const binaryContent = new Promise((resolve, reject) => {\n        binaryLoader.load('basis_transcoder.wasm', resolve, undefined, reject)\n      })\n\n      this.transcoderPending = Promise.all([jsContent, binaryContent]).then(([jsContent, binaryContent]) => {\n        const fn = BasisTextureLoader.BasisWorker.toString()\n\n        const body = [\n          '/* constants */',\n          'let _EngineFormat = ' + JSON.stringify(BasisTextureLoader.EngineFormat),\n          'let _TranscoderFormat = ' + JSON.stringify(BasisTextureLoader.TranscoderFormat),\n          'let _BasisFormat = ' + JSON.stringify(BasisTextureLoader.BasisFormat),\n          '/* basis_transcoder.js */',\n          jsContent,\n          '/* worker */',\n          fn.substring(fn.indexOf('{') + 1, fn.lastIndexOf('}')),\n        ].join('\\n')\n\n        this.workerSourceURL = URL.createObjectURL(new Blob([body]))\n        this.transcoderBinary = binaryContent\n      })\n    }\n\n    return this.transcoderPending\n  }\n\n  _allocateWorker(taskCost) {\n    return this._initTranscoder().then(() => {\n      if (this.workerPool.length < this.workerLimit) {\n        const worker = new Worker(this.workerSourceURL)\n\n        worker._callbacks = {}\n        worker._taskLoad = 0\n\n        worker.postMessage({\n          type: 'init',\n          config: this.workerConfig,\n          transcoderBinary: this.transcoderBinary,\n        })\n\n        worker.onmessage = function (e) {\n          const message = e.data\n\n          switch (message.type) {\n            case 'transcode':\n              worker._callbacks[message.id].resolve(message)\n              break\n\n            case 'error':\n              worker._callbacks[message.id].reject(message)\n              break\n\n            default:\n              console.error('THREE.BasisTextureLoader: Unexpected message, \"' + message.type + '\"')\n          }\n        }\n\n        this.workerPool.push(worker)\n      } else {\n        this.workerPool.sort(function (a, b) {\n          return a._taskLoad > b._taskLoad ? -1 : 1\n        })\n      }\n\n      const worker = this.workerPool[this.workerPool.length - 1]\n\n      worker._taskLoad += taskCost\n\n      return worker\n    })\n  }\n\n  dispose() {\n    for (let i = 0; i < this.workerPool.length; i++) {\n      this.workerPool[i].terminate()\n    }\n\n    this.workerPool.length = 0\n\n    return this\n  }\n}\n\nexport { BasisTextureLoader }\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}