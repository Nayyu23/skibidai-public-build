{"ast":null,"code":"import _classCallCheck from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = function __defNormalProp(obj, key, value) {\n  return key in obj ? __defProp(obj, key, {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: value\n  }) : obj[key] = value;\n};\nvar __publicField = function __publicField(obj, key, value) {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nimport { Vector3, Color, Vector2, Mesh, Line, Points, Matrix3, BufferAttribute } from \"three\";\nvar OBJExporter = /*#__PURE__*/function () {\n  function OBJExporter() {\n    _classCallCheck(this, OBJExporter);\n    __publicField(this, \"output\");\n    __publicField(this, \"indexVertex\");\n    __publicField(this, \"indexVertexUvs\");\n    __publicField(this, \"indexNormals\");\n    __publicField(this, \"vertex\");\n    __publicField(this, \"color\");\n    __publicField(this, \"normal\");\n    __publicField(this, \"uv\");\n    __publicField(this, \"face\");\n    this.output = \"\";\n    this.indexVertex = 0;\n    this.indexVertexUvs = 0;\n    this.indexNormals = 0;\n    this.vertex = new Vector3();\n    this.color = new Color();\n    this.normal = new Vector3();\n    this.uv = new Vector2();\n    this.face = [];\n  }\n  _createClass(OBJExporter, [{\n    key: \"parse\",\n    value: function parse(object) {\n      var _this = this;\n      object.traverse(function (child) {\n        if (child instanceof Mesh && child.isMesh) {\n          _this.parseMesh(child);\n        }\n        if (child instanceof Line && child.isLine) {\n          _this.parseLine(child);\n        }\n        if (child instanceof Points && child.isPoints) {\n          _this.parsePoints(child);\n        }\n      });\n      return this.output;\n    }\n  }, {\n    key: \"parseMesh\",\n    value: function parseMesh(mesh) {\n      var nbVertex = 0;\n      var nbNormals = 0;\n      var nbVertexUvs = 0;\n      var geometry = mesh.geometry;\n      var normalMatrixWorld = new Matrix3();\n      if (!geometry.isBufferGeometry) {\n        throw new Error(\"THREE.OBJExporter: Geometry is not of type THREE.BufferGeometry.\");\n      }\n      var vertices = geometry.getAttribute(\"position\");\n      var normals = geometry.getAttribute(\"normal\");\n      var uvs = geometry.getAttribute(\"uv\");\n      var indices = geometry.getIndex();\n      this.output += \"o \".concat(mesh.name, \"\\n\");\n      if (mesh.material && !Array.isArray(mesh.material) && mesh.material.name) {\n        this.output += \"usemtl \".concat(mesh.material.name, \"\\n\");\n      }\n      if (vertices !== void 0) {\n        for (var i = 0, l = vertices.count; i < l; i++, nbVertex++) {\n          this.vertex.x = vertices.getX(i);\n          this.vertex.y = vertices.getY(i);\n          this.vertex.z = vertices.getZ(i);\n          this.vertex.applyMatrix4(mesh.matrixWorld);\n          this.output += \"v \".concat(this.vertex.x, \" \").concat(this.vertex.y, \" \").concat(this.vertex.z, \"\\n\");\n        }\n      }\n      if (uvs !== void 0) {\n        for (var _i = 0, _l = uvs.count; _i < _l; _i++, nbVertexUvs++) {\n          this.uv.x = uvs.getX(_i);\n          this.uv.y = uvs.getY(_i);\n          this.output += \"vt \".concat(this.uv.x, \" \").concat(this.uv.y, \"\\n\");\n        }\n      }\n      if (normals !== void 0) {\n        normalMatrixWorld.getNormalMatrix(mesh.matrixWorld);\n        for (var _i2 = 0, _l2 = normals.count; _i2 < _l2; _i2++, nbNormals++) {\n          this.normal.x = normals.getX(_i2);\n          this.normal.y = normals.getY(_i2);\n          this.normal.z = normals.getZ(_i2);\n          this.normal.applyMatrix3(normalMatrixWorld).normalize();\n          this.output += \"vn \".concat(this.normal.x, \" \").concat(this.normal.y, \" \").concat(this.normal.z, \"\\n\");\n        }\n      }\n      if (indices !== null) {\n        for (var _i3 = 0, _l3 = indices.count; _i3 < _l3; _i3 += 3) {\n          for (var m = 0; m < 3; m++) {\n            var j = indices.getX(_i3 + m) + 1;\n            this.face[m] = this.indexVertex + j + (normals || uvs ? \"/\".concat(uvs ? this.indexVertexUvs + j : \"\").concat(normals ? \"/\".concat(this.indexNormals + j) : \"\") : \"\");\n          }\n          this.output += \"f \".concat(this.face.join(\" \"), \"\\n\");\n        }\n      } else {\n        for (var _i4 = 0, _l4 = vertices.count; _i4 < _l4; _i4 += 3) {\n          for (var _m = 0; _m < 3; _m++) {\n            var _j = _i4 + _m + 1;\n            this.face[_m] = this.indexVertex + _j + (normals || uvs ? \"/\".concat(uvs ? this.indexVertexUvs + _j : \"\").concat(normals ? \"/\".concat(this.indexNormals + _j) : \"\") : \"\");\n          }\n          this.output += \"f \".concat(this.face.join(\" \"), \"\\n\");\n        }\n      }\n      this.indexVertex += nbVertex;\n      this.indexVertexUvs += nbVertexUvs;\n      this.indexNormals += nbNormals;\n    }\n  }, {\n    key: \"parseLine\",\n    value: function parseLine(line) {\n      var nbVertex = 0;\n      var geometry = line.geometry;\n      var type = line.type;\n      if (geometry.isBufferGeometry) {\n        throw new Error(\"THREE.OBJExporter: Geometry is not of type THREE.BufferGeometry.\");\n      }\n      var vertices = geometry.getAttribute(\"position\");\n      this.output += \"o \".concat(line.name, \"\\n\");\n      if (vertices !== void 0) {\n        for (var i = 0, l = vertices.count; i < l; i++, nbVertex++) {\n          this.vertex.x = vertices.getX(i);\n          this.vertex.y = vertices.getY(i);\n          this.vertex.z = vertices.getZ(i);\n          this.vertex.applyMatrix4(line.matrixWorld);\n          this.output += \"v \".concat(this.vertex.x, \" \").concat(this.vertex.y, \" \").concat(this.vertex.z, \"\\n\");\n        }\n      }\n      if (type === \"Line\") {\n        this.output += \"l \";\n        for (var j = 1, _l5 = vertices.count; j <= _l5; j++) {\n          this.output += \"\".concat(this.indexVertex + j, \" \");\n        }\n        this.output += \"\\n\";\n      }\n      if (type === \"LineSegments\") {\n        for (var _j2 = 1, k = _j2 + 1, _l6 = vertices.count; _j2 < _l6; _j2 += 2, k = _j2 + 1) {\n          this.output += \"l \".concat(this.indexVertex + _j2, \" \").concat(this.indexVertex + k, \"\\n\");\n        }\n      }\n      this.indexVertex += nbVertex;\n    }\n  }, {\n    key: \"parsePoints\",\n    value: function parsePoints(points) {\n      var nbVertex = 0;\n      var geometry = points.geometry;\n      if (!geometry.isBufferGeometry) {\n        throw new Error(\"THREE.OBJExporter: Geometry is not of type THREE.BufferGeometry.\");\n      }\n      var vertices = geometry.getAttribute(\"position\");\n      var colors = geometry.getAttribute(\"color\");\n      this.output += \"o \".concat(points.name, \"\\n\");\n      if (vertices !== void 0) {\n        for (var i = 0, l = vertices.count; i < l; i++, nbVertex++) {\n          this.vertex.fromBufferAttribute(vertices, i);\n          this.vertex.applyMatrix4(points.matrixWorld);\n          this.output += \"v \".concat(this.vertex.x, \" \").concat(this.vertex.y, \" \").concat(this.vertex.z);\n          if (colors !== void 0 && colors instanceof BufferAttribute) {\n            this.color.fromBufferAttribute(colors, i);\n            this.output += \" \".concat(this.color.r, \" \").concat(this.color.g, \" \").concat(this.color.b);\n          }\n          this.output += \"\\n\";\n        }\n      }\n      this.output += \"p \";\n      for (var j = 1, _l7 = vertices.count; j <= _l7; j++) {\n        this.output += \"\".concat(this.indexVertex + j, \" \");\n      }\n      this.output += \"\\n\";\n      this.indexVertex += nbVertex;\n    }\n  }]);\n  return OBJExporter;\n}();\nexport { OBJExporter };","map":{"version":3,"names":["OBJExporter","_classCallCheck","__publicField","output","indexVertex","indexVertexUvs","indexNormals","vertex","Vector3","color","Color","normal","uv","Vector2","face","_createClass","key","value","parse","object","_this","traverse","child","Mesh","isMesh","parseMesh","Line","isLine","parseLine","Points","isPoints","parsePoints","mesh","nbVertex","nbNormals","nbVertexUvs","geometry","normalMatrixWorld","Matrix3","isBufferGeometry","Error","vertices","getAttribute","normals","uvs","indices","getIndex","concat","name","material","Array","isArray","i","l","count","x","getX","y","getY","z","getZ","applyMatrix4","matrixWorld","getNormalMatrix","applyMatrix3","normalize","m","j","join","line","type","k","points","colors","fromBufferAttribute","BufferAttribute","r","g","b"],"sources":["C:\\Users\\Nayyu\\Desktop\\skibidai-public-build\\node_modules\\src\\exporters\\OBJExporter.ts"],"sourcesContent":["import { BufferAttribute, Color, Line, Matrix3, Mesh, Object3D, Points, Vector2, Vector3 } from 'three'\n\nclass OBJExporter {\n  private output\n\n  private indexVertex\n  private indexVertexUvs\n  private indexNormals\n\n  private vertex\n  private color\n  private normal\n  private uv\n\n  private face: string[]\n\n  constructor() {\n    this.output = ''\n\n    this.indexVertex = 0\n    this.indexVertexUvs = 0\n    this.indexNormals = 0\n\n    this.vertex = new Vector3()\n    this.color = new Color()\n    this.normal = new Vector3()\n    this.uv = new Vector2()\n\n    this.face = []\n  }\n\n  public parse(object: Object3D): string {\n    object.traverse((child) => {\n      if (child instanceof Mesh && child.isMesh) {\n        this.parseMesh(child)\n      }\n\n      if (child instanceof Line && child.isLine) {\n        this.parseLine(child)\n      }\n\n      if (child instanceof Points && child.isPoints) {\n        this.parsePoints(child)\n      }\n    })\n\n    return this.output\n  }\n\n  private parseMesh(mesh: Mesh): void {\n    let nbVertex = 0\n    let nbNormals = 0\n    let nbVertexUvs = 0\n\n    const geometry = mesh.geometry\n\n    const normalMatrixWorld = new Matrix3()\n\n    if (!geometry.isBufferGeometry) {\n      throw new Error('THREE.OBJExporter: Geometry is not of type THREE.BufferGeometry.')\n    }\n\n    // shortcuts\n    const vertices = geometry.getAttribute('position')\n    const normals = geometry.getAttribute('normal')\n    const uvs = geometry.getAttribute('uv')\n    const indices = geometry.getIndex()\n\n    // name of the mesh object\n    this.output += `o ${mesh.name}\\n`\n\n    // name of the mesh material\n    if (mesh.material && !Array.isArray(mesh.material) && mesh.material.name) {\n      this.output += `usemtl ${mesh.material.name}\\n`\n    }\n\n    // vertices\n\n    if (vertices !== undefined) {\n      for (let i = 0, l = vertices.count; i < l; i++, nbVertex++) {\n        this.vertex.x = vertices.getX(i)\n        this.vertex.y = vertices.getY(i)\n        this.vertex.z = vertices.getZ(i)\n\n        // transform the vertex to world space\n        this.vertex.applyMatrix4(mesh.matrixWorld)\n\n        // transform the vertex to export format\n        this.output += `v ${this.vertex.x} ${this.vertex.y} ${this.vertex.z}\\n`\n      }\n    }\n\n    // uvs\n\n    if (uvs !== undefined) {\n      for (let i = 0, l = uvs.count; i < l; i++, nbVertexUvs++) {\n        this.uv.x = uvs.getX(i)\n        this.uv.y = uvs.getY(i)\n\n        // transform the uv to export format\n        this.output += `vt ${this.uv.x} ${this.uv.y}\\n`\n      }\n    }\n\n    // normals\n\n    if (normals !== undefined) {\n      normalMatrixWorld.getNormalMatrix(mesh.matrixWorld)\n\n      for (let i = 0, l = normals.count; i < l; i++, nbNormals++) {\n        this.normal.x = normals.getX(i)\n        this.normal.y = normals.getY(i)\n        this.normal.z = normals.getZ(i)\n\n        // transform the normal to world space\n        this.normal.applyMatrix3(normalMatrixWorld).normalize()\n\n        // transform the normal to export format\n        this.output += `vn ${this.normal.x} ${this.normal.y} ${this.normal.z}\\n`\n      }\n    }\n\n    // faces\n\n    if (indices !== null) {\n      for (let i = 0, l = indices.count; i < l; i += 3) {\n        for (let m = 0; m < 3; m++) {\n          const j = indices.getX(i + m) + 1\n\n          this.face[m] =\n            this.indexVertex +\n            j +\n            (normals || uvs\n              ? `/${uvs ? this.indexVertexUvs + j : ''}${normals ? `/${this.indexNormals + j}` : ''}`\n              : '')\n        }\n\n        // transform the face to export format\n        this.output += `f ${this.face.join(' ')}\\n`\n      }\n    } else {\n      for (let i = 0, l = vertices.count; i < l; i += 3) {\n        for (let m = 0; m < 3; m++) {\n          const j = i + m + 1\n\n          this.face[m] =\n            this.indexVertex +\n            j +\n            (normals || uvs\n              ? `/${uvs ? this.indexVertexUvs + j : ''}${normals ? `/${this.indexNormals + j}` : ''}`\n              : '')\n        }\n\n        // transform the face to export format\n        this.output += `f ${this.face.join(' ')}\\n`\n      }\n    }\n\n    // update index\n    this.indexVertex += nbVertex\n    this.indexVertexUvs += nbVertexUvs\n    this.indexNormals += nbNormals\n  }\n\n  private parseLine(line: Line): void {\n    let nbVertex = 0\n\n    const geometry = line.geometry\n    const type = line.type\n\n    if (geometry.isBufferGeometry) {\n      throw new Error('THREE.OBJExporter: Geometry is not of type THREE.BufferGeometry.')\n    }\n\n    // shortcuts\n    const vertices = geometry.getAttribute('position')\n\n    // name of the line object\n    this.output += `o ${line.name}\\n`\n\n    if (vertices !== undefined) {\n      for (let i = 0, l = vertices.count; i < l; i++, nbVertex++) {\n        this.vertex.x = vertices.getX(i)\n        this.vertex.y = vertices.getY(i)\n        this.vertex.z = vertices.getZ(i)\n\n        // transform the vertex to world space\n        this.vertex.applyMatrix4(line.matrixWorld)\n\n        // transform the vertex to export format\n        this.output += `v ${this.vertex.x} ${this.vertex.y} ${this.vertex.z}\\n`\n      }\n    }\n\n    if (type === 'Line') {\n      this.output += 'l '\n\n      for (let j = 1, l = vertices.count; j <= l; j++) {\n        this.output += `${this.indexVertex + j} `\n      }\n\n      this.output += '\\n'\n    }\n\n    if (type === 'LineSegments') {\n      for (let j = 1, k = j + 1, l = vertices.count; j < l; j += 2, k = j + 1) {\n        this.output += `l ${this.indexVertex + j} ${this.indexVertex + k}\\n`\n      }\n    }\n\n    // update index\n    this.indexVertex += nbVertex\n  }\n\n  private parsePoints(points: Points): void {\n    let nbVertex = 0\n\n    const geometry = points.geometry\n\n    if (!geometry.isBufferGeometry) {\n      throw new Error('THREE.OBJExporter: Geometry is not of type THREE.BufferGeometry.')\n    }\n\n    const vertices = geometry.getAttribute('position')\n    const colors = geometry.getAttribute('color')\n\n    this.output += `o ${points.name}\\n`\n\n    if (vertices !== undefined) {\n      for (let i = 0, l = vertices.count; i < l; i++, nbVertex++) {\n        this.vertex.fromBufferAttribute(vertices, i)\n        this.vertex.applyMatrix4(points.matrixWorld)\n\n        this.output += `v ${this.vertex.x} ${this.vertex.y} ${this.vertex.z}`\n\n        if (colors !== undefined && colors instanceof BufferAttribute) {\n          this.color.fromBufferAttribute(colors, i)\n\n          this.output += ` ${this.color.r} ${this.color.g} ${this.color.b}`\n        }\n\n        this.output += '\\n'\n      }\n    }\n\n    this.output += 'p '\n\n    for (let j = 1, l = vertices.count; j <= l; j++) {\n      this.output += `${this.indexVertex + j} `\n    }\n\n    this.output += '\\n'\n\n    // update index\n    this.indexVertex += nbVertex\n  }\n}\n\nexport { OBJExporter }\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}