{"ast":null,"code":"import _classCallCheck from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport { Triangle, Vector3 } from \"three\";\nvar _face = new Triangle();\nvar _color = new Vector3();\nvar MeshSurfaceSampler = /*#__PURE__*/function () {\n  function MeshSurfaceSampler(mesh) {\n    _classCallCheck(this, MeshSurfaceSampler);\n    var geometry = mesh.geometry;\n    if (geometry.index) {\n      console.warn(\"THREE.MeshSurfaceSampler: Converting geometry to non-indexed BufferGeometry.\");\n      geometry = geometry.toNonIndexed();\n    }\n    this.geometry = geometry;\n    this.randomFunction = Math.random;\n    this.positionAttribute = this.geometry.getAttribute(\"position\");\n    this.colorAttribute = this.geometry.getAttribute(\"color\");\n    this.weightAttribute = null;\n    this.distribution = null;\n  }\n  _createClass(MeshSurfaceSampler, [{\n    key: \"setWeightAttribute\",\n    value: function setWeightAttribute(name) {\n      this.weightAttribute = name ? this.geometry.getAttribute(name) : null;\n      return this;\n    }\n  }, {\n    key: \"build\",\n    value: function build() {\n      var positionAttribute = this.positionAttribute;\n      var weightAttribute = this.weightAttribute;\n      var faceWeights = new Float32Array(positionAttribute.count / 3);\n      for (var i = 0; i < positionAttribute.count; i += 3) {\n        var faceWeight = 1;\n        if (weightAttribute) {\n          faceWeight = weightAttribute.getX(i) + weightAttribute.getX(i + 1) + weightAttribute.getX(i + 2);\n        }\n        _face.a.fromBufferAttribute(positionAttribute, i);\n        _face.b.fromBufferAttribute(positionAttribute, i + 1);\n        _face.c.fromBufferAttribute(positionAttribute, i + 2);\n        faceWeight *= _face.getArea();\n        faceWeights[i / 3] = faceWeight;\n      }\n      this.distribution = new Float32Array(positionAttribute.count / 3);\n      var cumulativeTotal = 0;\n      for (var _i = 0; _i < faceWeights.length; _i++) {\n        cumulativeTotal += faceWeights[_i];\n        this.distribution[_i] = cumulativeTotal;\n      }\n      return this;\n    }\n  }, {\n    key: \"setRandomGenerator\",\n    value: function setRandomGenerator(randomFunction) {\n      this.randomFunction = randomFunction;\n      return this;\n    }\n  }, {\n    key: \"sample\",\n    value: function sample(targetPosition, targetNormal, targetColor) {\n      var faceIndex = this.sampleFaceIndex();\n      return this.sampleFace(faceIndex, targetPosition, targetNormal, targetColor);\n    }\n  }, {\n    key: \"sampleFaceIndex\",\n    value: function sampleFaceIndex() {\n      var cumulativeTotal = this.distribution[this.distribution.length - 1];\n      return this.binarySearch(this.randomFunction() * cumulativeTotal);\n    }\n  }, {\n    key: \"binarySearch\",\n    value: function binarySearch(x) {\n      var dist = this.distribution;\n      var start = 0;\n      var end = dist.length - 1;\n      var index = -1;\n      while (start <= end) {\n        var mid = Math.ceil((start + end) / 2);\n        if (mid === 0 || dist[mid - 1] <= x && dist[mid] > x) {\n          index = mid;\n          break;\n        } else if (x < dist[mid]) {\n          end = mid - 1;\n        } else {\n          start = mid + 1;\n        }\n      }\n      return index;\n    }\n  }, {\n    key: \"sampleFace\",\n    value: function sampleFace(faceIndex, targetPosition, targetNormal, targetColor) {\n      var u = this.randomFunction();\n      var v = this.randomFunction();\n      if (u + v > 1) {\n        u = 1 - u;\n        v = 1 - v;\n      }\n      _face.a.fromBufferAttribute(this.positionAttribute, faceIndex * 3);\n      _face.b.fromBufferAttribute(this.positionAttribute, faceIndex * 3 + 1);\n      _face.c.fromBufferAttribute(this.positionAttribute, faceIndex * 3 + 2);\n      targetPosition.set(0, 0, 0).addScaledVector(_face.a, u).addScaledVector(_face.b, v).addScaledVector(_face.c, 1 - (u + v));\n      if (targetNormal !== void 0) {\n        _face.getNormal(targetNormal);\n      }\n      if (targetColor !== void 0 && this.colorAttribute !== void 0) {\n        _face.a.fromBufferAttribute(this.colorAttribute, faceIndex * 3);\n        _face.b.fromBufferAttribute(this.colorAttribute, faceIndex * 3 + 1);\n        _face.c.fromBufferAttribute(this.colorAttribute, faceIndex * 3 + 2);\n        _color.set(0, 0, 0).addScaledVector(_face.a, u).addScaledVector(_face.b, v).addScaledVector(_face.c, 1 - (u + v));\n        targetColor.r = _color.x;\n        targetColor.g = _color.y;\n        targetColor.b = _color.z;\n      }\n      return this;\n    }\n  }]);\n  return MeshSurfaceSampler;\n}();\nexport { MeshSurfaceSampler };","map":{"version":3,"names":["_face","Triangle","_color","Vector3","MeshSurfaceSampler","mesh","_classCallCheck","geometry","index","console","warn","toNonIndexed","randomFunction","Math","random","positionAttribute","getAttribute","colorAttribute","weightAttribute","distribution","_createClass","key","value","setWeightAttribute","name","build","faceWeights","Float32Array","count","i","faceWeight","getX","a","fromBufferAttribute","b","c","getArea","cumulativeTotal","length","setRandomGenerator","sample","targetPosition","targetNormal","targetColor","faceIndex","sampleFaceIndex","sampleFace","binarySearch","x","dist","start","end","mid","ceil","u","v","set","addScaledVector","getNormal","r","g","y","z"],"sources":["C:\\Users\\Nayyu\\Desktop\\skibidai-public-build\\node_modules\\src\\math\\MeshSurfaceSampler.js"],"sourcesContent":["import { Triangle, Vector3 } from 'three'\n\n/**\n * Utility class for sampling weighted random points on the surface of a mesh.\n *\n * Building the sampler is a one-time O(n) operation. Once built, any number of\n * random samples may be selected in O(logn) time. Memory usage is O(n).\n *\n * References:\n * - http://www.joesfer.com/?p=84\n * - https://stackoverflow.com/a/4322940/1314762\n */\n\nconst _face = new Triangle()\nconst _color = new Vector3()\n\nclass MeshSurfaceSampler {\n  constructor(mesh) {\n    let geometry = mesh.geometry\n\n    if (geometry.index) {\n      console.warn('THREE.MeshSurfaceSampler: Converting geometry to non-indexed BufferGeometry.')\n\n      geometry = geometry.toNonIndexed()\n    }\n\n    this.geometry = geometry\n    this.randomFunction = Math.random\n\n    this.positionAttribute = this.geometry.getAttribute('position')\n    this.colorAttribute = this.geometry.getAttribute('color')\n    this.weightAttribute = null\n\n    this.distribution = null\n  }\n\n  setWeightAttribute(name) {\n    this.weightAttribute = name ? this.geometry.getAttribute(name) : null\n\n    return this\n  }\n\n  build() {\n    const positionAttribute = this.positionAttribute\n    const weightAttribute = this.weightAttribute\n\n    const faceWeights = new Float32Array(positionAttribute.count / 3)\n\n    // Accumulate weights for each mesh face.\n\n    for (let i = 0; i < positionAttribute.count; i += 3) {\n      let faceWeight = 1\n\n      if (weightAttribute) {\n        faceWeight = weightAttribute.getX(i) + weightAttribute.getX(i + 1) + weightAttribute.getX(i + 2)\n      }\n\n      _face.a.fromBufferAttribute(positionAttribute, i)\n      _face.b.fromBufferAttribute(positionAttribute, i + 1)\n      _face.c.fromBufferAttribute(positionAttribute, i + 2)\n      faceWeight *= _face.getArea()\n\n      faceWeights[i / 3] = faceWeight\n    }\n\n    // Store cumulative total face weights in an array, where weight index\n    // corresponds to face index.\n\n    this.distribution = new Float32Array(positionAttribute.count / 3)\n\n    let cumulativeTotal = 0\n\n    for (let i = 0; i < faceWeights.length; i++) {\n      cumulativeTotal += faceWeights[i]\n\n      this.distribution[i] = cumulativeTotal\n    }\n\n    return this\n  }\n\n  setRandomGenerator(randomFunction) {\n    this.randomFunction = randomFunction\n    return this\n  }\n\n  sample(targetPosition, targetNormal, targetColor) {\n    const faceIndex = this.sampleFaceIndex()\n    return this.sampleFace(faceIndex, targetPosition, targetNormal, targetColor)\n  }\n\n  sampleFaceIndex() {\n    const cumulativeTotal = this.distribution[this.distribution.length - 1]\n    return this.binarySearch(this.randomFunction() * cumulativeTotal)\n  }\n\n  binarySearch(x) {\n    const dist = this.distribution\n    let start = 0\n    let end = dist.length - 1\n\n    let index = -1\n\n    while (start <= end) {\n      const mid = Math.ceil((start + end) / 2)\n\n      if (mid === 0 || (dist[mid - 1] <= x && dist[mid] > x)) {\n        index = mid\n\n        break\n      } else if (x < dist[mid]) {\n        end = mid - 1\n      } else {\n        start = mid + 1\n      }\n    }\n\n    return index\n  }\n\n  sampleFace(faceIndex, targetPosition, targetNormal, targetColor) {\n    let u = this.randomFunction()\n    let v = this.randomFunction()\n\n    if (u + v > 1) {\n      u = 1 - u\n      v = 1 - v\n    }\n\n    _face.a.fromBufferAttribute(this.positionAttribute, faceIndex * 3)\n    _face.b.fromBufferAttribute(this.positionAttribute, faceIndex * 3 + 1)\n    _face.c.fromBufferAttribute(this.positionAttribute, faceIndex * 3 + 2)\n\n    targetPosition\n      .set(0, 0, 0)\n      .addScaledVector(_face.a, u)\n      .addScaledVector(_face.b, v)\n      .addScaledVector(_face.c, 1 - (u + v))\n\n    if (targetNormal !== undefined) {\n      _face.getNormal(targetNormal)\n    }\n\n    if (targetColor !== undefined && this.colorAttribute !== undefined) {\n      _face.a.fromBufferAttribute(this.colorAttribute, faceIndex * 3)\n      _face.b.fromBufferAttribute(this.colorAttribute, faceIndex * 3 + 1)\n      _face.c.fromBufferAttribute(this.colorAttribute, faceIndex * 3 + 2)\n\n      _color\n        .set(0, 0, 0)\n        .addScaledVector(_face.a, u)\n        .addScaledVector(_face.b, v)\n        .addScaledVector(_face.c, 1 - (u + v))\n\n      targetColor.r = _color.x\n      targetColor.g = _color.y\n      targetColor.b = _color.z\n    }\n\n    return this\n  }\n}\n\nexport { MeshSurfaceSampler }\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}