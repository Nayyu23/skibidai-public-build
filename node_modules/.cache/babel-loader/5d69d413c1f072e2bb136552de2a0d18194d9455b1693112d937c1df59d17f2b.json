{"ast":null,"code":"import _objectSpread from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _get from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/get.js\";\nimport _getPrototypeOf from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js\";\nimport _classCallCheck from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _assertThisInitialized from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js\";\nimport _inherits from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = function __defNormalProp(obj, key, value) {\n  return key in obj ? __defProp(obj, key, {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: value\n  }) : obj[key] = value;\n};\nvar __publicField = function __publicField(obj, key, value) {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nimport * as THREE from \"three\";\nfunction memcpy(src, srcOffset, dst, dstOffset, length) {\n  var i;\n  src = src.subarray || src.slice ? src : src.buffer;\n  dst = dst.subarray || dst.slice ? dst : dst.buffer;\n  src = srcOffset ? src.subarray ? src.subarray(srcOffset, length && srcOffset + length) : src.slice(srcOffset, length && srcOffset + length) : src;\n  if (dst.set) {\n    dst.set(src, dstOffset);\n  } else {\n    for (i = 0; i < src.length; i++) dst[i + dstOffset] = src[i];\n  }\n  return dst;\n}\nfunction convertPoints(points) {\n  if (points instanceof Float32Array) return points;\n  if (points instanceof THREE.BufferGeometry) return points.getAttribute(\"position\").array;\n  return points.map(function (p) {\n    var isArray = Array.isArray(p);\n    return p instanceof THREE.Vector3 ? [p.x, p.y, p.z] : p instanceof THREE.Vector2 ? [p.x, p.y, 0] : isArray && p.length === 3 ? [p[0], p[1], p[2]] : isArray && p.length === 2 ? [p[0], p[1], 0] : p;\n  }).flat();\n}\nvar MeshLineGeometry = /*#__PURE__*/function (_THREE$BufferGeometry) {\n  _inherits(MeshLineGeometry, _THREE$BufferGeometry);\n  var _super = _createSuper(MeshLineGeometry);\n  function MeshLineGeometry() {\n    var _this;\n    _classCallCheck(this, MeshLineGeometry);\n    _this = _super.call(this);\n    __publicField(_assertThisInitialized(_this), \"type\", \"MeshLine\");\n    __publicField(_assertThisInitialized(_this), \"isMeshLine\", true);\n    __publicField(_assertThisInitialized(_this), \"positions\", []);\n    __publicField(_assertThisInitialized(_this), \"previous\", []);\n    __publicField(_assertThisInitialized(_this), \"next\", []);\n    __publicField(_assertThisInitialized(_this), \"side\", []);\n    __publicField(_assertThisInitialized(_this), \"width\", []);\n    __publicField(_assertThisInitialized(_this), \"indices_array\", []);\n    __publicField(_assertThisInitialized(_this), \"uvs\", []);\n    __publicField(_assertThisInitialized(_this), \"counters\", []);\n    __publicField(_assertThisInitialized(_this), \"widthCallback\", null);\n    __publicField(_assertThisInitialized(_this), \"_attributes\");\n    __publicField(_assertThisInitialized(_this), \"_points\", []);\n    __publicField(_assertThisInitialized(_this), \"points\");\n    __publicField(_assertThisInitialized(_this), \"matrixWorld\", new THREE.Matrix4());\n    Object.defineProperties(_assertThisInitialized(_this), {\n      points: {\n        enumerable: true,\n        get: function get() {\n          return this._points;\n        },\n        set: function set(value) {\n          this.setPoints(value, this.widthCallback);\n        }\n      }\n    });\n    return _this;\n  }\n  _createClass(MeshLineGeometry, [{\n    key: \"setMatrixWorld\",\n    value: function setMatrixWorld(matrixWorld) {\n      this.matrixWorld = matrixWorld;\n    }\n  }, {\n    key: \"setPoints\",\n    value: function setPoints(points, wcb) {\n      points = convertPoints(points);\n      this._points = points;\n      this.widthCallback = wcb != null ? wcb : null;\n      this.positions = [];\n      this.counters = [];\n      if (points.length && points[0] instanceof THREE.Vector3) {\n        for (var j = 0; j < points.length; j++) {\n          var p = points[j];\n          var c = j / (points.length - 1);\n          this.positions.push(p.x, p.y, p.z);\n          this.positions.push(p.x, p.y, p.z);\n          this.counters.push(c);\n          this.counters.push(c);\n        }\n      } else {\n        for (var _j = 0; _j < points.length; _j += 3) {\n          var _c = _j / (points.length - 1);\n          this.positions.push(points[_j], points[_j + 1], points[_j + 2]);\n          this.positions.push(points[_j], points[_j + 1], points[_j + 2]);\n          this.counters.push(_c);\n          this.counters.push(_c);\n        }\n      }\n      this.process();\n    }\n  }, {\n    key: \"compareV3\",\n    value: function compareV3(a, b) {\n      var aa = a * 6;\n      var ab = b * 6;\n      return this.positions[aa] === this.positions[ab] && this.positions[aa + 1] === this.positions[ab + 1] && this.positions[aa + 2] === this.positions[ab + 2];\n    }\n  }, {\n    key: \"copyV3\",\n    value: function copyV3(a) {\n      var aa = a * 6;\n      return [this.positions[aa], this.positions[aa + 1], this.positions[aa + 2]];\n    }\n  }, {\n    key: \"process\",\n    value: function process() {\n      var l = this.positions.length / 6;\n      this.previous = [];\n      this.next = [];\n      this.side = [];\n      this.width = [];\n      this.indices_array = [];\n      this.uvs = [];\n      var w;\n      var v;\n      if (this.compareV3(0, l - 1)) {\n        v = this.copyV3(l - 2);\n      } else {\n        v = this.copyV3(0);\n      }\n      this.previous.push(v[0], v[1], v[2]);\n      this.previous.push(v[0], v[1], v[2]);\n      for (var j = 0; j < l; j++) {\n        this.side.push(1);\n        this.side.push(-1);\n        if (this.widthCallback) w = this.widthCallback(j / (l - 1));else w = 1;\n        this.width.push(w);\n        this.width.push(w);\n        this.uvs.push(j / (l - 1), 0);\n        this.uvs.push(j / (l - 1), 1);\n        if (j < l - 1) {\n          v = this.copyV3(j);\n          this.previous.push(v[0], v[1], v[2]);\n          this.previous.push(v[0], v[1], v[2]);\n          var n = j * 2;\n          this.indices_array.push(n, n + 1, n + 2);\n          this.indices_array.push(n + 2, n + 1, n + 3);\n        }\n        if (j > 0) {\n          v = this.copyV3(j);\n          this.next.push(v[0], v[1], v[2]);\n          this.next.push(v[0], v[1], v[2]);\n        }\n      }\n      if (this.compareV3(l - 1, 0)) {\n        v = this.copyV3(1);\n      } else {\n        v = this.copyV3(l - 1);\n      }\n      this.next.push(v[0], v[1], v[2]);\n      this.next.push(v[0], v[1], v[2]);\n      if (!this._attributes || this._attributes.position.count !== this.counters.length) {\n        this._attributes = {\n          position: new THREE.BufferAttribute(new Float32Array(this.positions), 3),\n          previous: new THREE.BufferAttribute(new Float32Array(this.previous), 3),\n          next: new THREE.BufferAttribute(new Float32Array(this.next), 3),\n          side: new THREE.BufferAttribute(new Float32Array(this.side), 1),\n          width: new THREE.BufferAttribute(new Float32Array(this.width), 1),\n          uv: new THREE.BufferAttribute(new Float32Array(this.uvs), 2),\n          index: new THREE.BufferAttribute(new Uint16Array(this.indices_array), 1),\n          counters: new THREE.BufferAttribute(new Float32Array(this.counters), 1)\n        };\n      } else {\n        this._attributes.position.copyArray(new Float32Array(this.positions));\n        this._attributes.position.needsUpdate = true;\n        this._attributes.previous.copyArray(new Float32Array(this.previous));\n        this._attributes.previous.needsUpdate = true;\n        this._attributes.next.copyArray(new Float32Array(this.next));\n        this._attributes.next.needsUpdate = true;\n        this._attributes.side.copyArray(new Float32Array(this.side));\n        this._attributes.side.needsUpdate = true;\n        this._attributes.width.copyArray(new Float32Array(this.width));\n        this._attributes.width.needsUpdate = true;\n        this._attributes.uv.copyArray(new Float32Array(this.uvs));\n        this._attributes.uv.needsUpdate = true;\n        this._attributes.index.copyArray(new Uint16Array(this.indices_array));\n        this._attributes.index.needsUpdate = true;\n      }\n      this.setAttribute(\"position\", this._attributes.position);\n      this.setAttribute(\"previous\", this._attributes.previous);\n      this.setAttribute(\"next\", this._attributes.next);\n      this.setAttribute(\"side\", this._attributes.side);\n      this.setAttribute(\"width\", this._attributes.width);\n      this.setAttribute(\"uv\", this._attributes.uv);\n      this.setAttribute(\"counters\", this._attributes.counters);\n      this.setAttribute(\"position\", this._attributes.position);\n      this.setAttribute(\"previous\", this._attributes.previous);\n      this.setAttribute(\"next\", this._attributes.next);\n      this.setAttribute(\"side\", this._attributes.side);\n      this.setAttribute(\"width\", this._attributes.width);\n      this.setAttribute(\"uv\", this._attributes.uv);\n      this.setAttribute(\"counters\", this._attributes.counters);\n      this.setIndex(this._attributes.index);\n      this.computeBoundingSphere();\n      this.computeBoundingBox();\n    }\n  }, {\n    key: \"advance\",\n    value: function advance(_ref) {\n      var x = _ref.x,\n        y = _ref.y,\n        z = _ref.z;\n      var positions = this._attributes.position.array;\n      var previous = this._attributes.previous.array;\n      var next = this._attributes.next.array;\n      var l = positions.length;\n      memcpy(positions, 0, previous, 0, l);\n      memcpy(positions, 6, positions, 0, l - 6);\n      positions[l - 6] = x;\n      positions[l - 5] = y;\n      positions[l - 4] = z;\n      positions[l - 3] = x;\n      positions[l - 2] = y;\n      positions[l - 1] = z;\n      memcpy(positions, 6, next, 0, l - 6);\n      next[l - 6] = x;\n      next[l - 5] = y;\n      next[l - 4] = z;\n      next[l - 3] = x;\n      next[l - 2] = y;\n      next[l - 1] = z;\n      this._attributes.position.needsUpdate = true;\n      this._attributes.previous.needsUpdate = true;\n      this._attributes.next.needsUpdate = true;\n    }\n  }]);\n  return MeshLineGeometry;\n}(THREE.BufferGeometry);\nvar vertexShader = \"\\n  #include <common>\\n  #include <logdepthbuf_pars_vertex>\\n  #include <fog_pars_vertex>\\n  #include <clipping_planes_pars_vertex>\\n\\n  attribute vec3 previous;\\n  attribute vec3 next;\\n  attribute float side;\\n  attribute float width;\\n  attribute float counters;\\n  \\n  uniform vec2 resolution;\\n  uniform float lineWidth;\\n  uniform vec3 color;\\n  uniform float opacity;\\n  uniform float sizeAttenuation;\\n  \\n  varying vec2 vUV;\\n  varying vec4 vColor;\\n  varying float vCounters;\\n  \\n  vec2 fix(vec4 i, float aspect) {\\n    vec2 res = i.xy / i.w;\\n    res.x *= aspect;\\n    return res;\\n  }\\n  \\n  void main() {\\n    float aspect = resolution.x / resolution.y;\\n    vColor = vec4(color, opacity);\\n    vUV = uv;\\n    vCounters = counters;\\n  \\n    mat4 m = projectionMatrix * modelViewMatrix;\\n    vec4 finalPosition = m * vec4(position, 1.0) * aspect;\\n    vec4 prevPos = m * vec4(previous, 1.0);\\n    vec4 nextPos = m * vec4(next, 1.0);\\n  \\n    vec2 currentP = fix(finalPosition, aspect);\\n    vec2 prevP = fix(prevPos, aspect);\\n    vec2 nextP = fix(nextPos, aspect);\\n  \\n    float w = lineWidth * width;\\n  \\n    vec2 dir;\\n    if (nextP == currentP) dir = normalize(currentP - prevP);\\n    else if (prevP == currentP) dir = normalize(nextP - currentP);\\n    else {\\n      vec2 dir1 = normalize(currentP - prevP);\\n      vec2 dir2 = normalize(nextP - currentP);\\n      dir = normalize(dir1 + dir2);\\n  \\n      vec2 perp = vec2(-dir1.y, dir1.x);\\n      vec2 miter = vec2(-dir.y, dir.x);\\n      //w = clamp(w / dot(miter, perp), 0., 4. * lineWidth * width);\\n    }\\n  \\n    //vec2 normal = (cross(vec3(dir, 0.), vec3(0., 0., 1.))).xy;\\n    vec4 normal = vec4(-dir.y, dir.x, 0., 1.);\\n    normal.xy *= .5 * w;\\n    //normal *= projectionMatrix;\\n    if (sizeAttenuation == 0.) {\\n      normal.xy *= finalPosition.w;\\n      normal.xy /= (vec4(resolution, 0., 1.) * projectionMatrix).xy * aspect;\\n    }\\n  \\n    finalPosition.xy += normal.xy * side;\\n    gl_Position = finalPosition;\\n    #include <logdepthbuf_vertex>\\n    #include <fog_vertex>\\n    vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\\n    #include <clipping_planes_vertex>\\n    #include <fog_vertex>\\n  }\\n\";\nvar version = /* @__PURE__ */function () {\n  return parseInt(THREE.REVISION.replace(/\\D+/g, \"\"));\n}();\nvar colorspace_fragment = version >= 154 ? \"colorspace_fragment\" : \"encodings_fragment\";\nvar fragmentShader = \"\\n  #include <fog_pars_fragment>\\n  #include <logdepthbuf_pars_fragment>\\n  #include <clipping_planes_pars_fragment>\\n  \\n  uniform sampler2D map;\\n  uniform sampler2D alphaMap;\\n  uniform float useGradient;\\n  uniform float useMap;\\n  uniform float useAlphaMap;\\n  uniform float useDash;\\n  uniform float dashArray;\\n  uniform float dashOffset;\\n  uniform float dashRatio;\\n  uniform float visibility;\\n  uniform float alphaTest;\\n  uniform vec2 repeat;\\n  uniform vec3 gradient[2];\\n  \\n  varying vec2 vUV;\\n  varying vec4 vColor;\\n  varying float vCounters;\\n  \\n  void main() {\\n    #include <logdepthbuf_fragment>\\n    vec4 diffuseColor = vColor;\\n    if (useGradient == 1.) diffuseColor = vec4(mix(gradient[0], gradient[1], vCounters), 1.0);\\n    if (useMap == 1.) diffuseColor *= texture2D(map, vUV * repeat);\\n    if (useAlphaMap == 1.) diffuseColor.a *= texture2D(alphaMap, vUV * repeat).a;\\n    if (diffuseColor.a < alphaTest) discard;\\n    if (useDash == 1.) diffuseColor.a *= ceil(mod(vCounters + dashOffset, dashArray) - (dashArray * dashRatio));\\n    diffuseColor.a *= step(vCounters, visibility);\\n    #include <clipping_planes_fragment>\\n    gl_FragColor = diffuseColor;     \\n    #include <fog_fragment>\\n    #include <tonemapping_fragment>\\n    #include <\".concat(colorspace_fragment, \">\\n  }\\n\");\nvar MeshLineMaterial = /*#__PURE__*/function (_THREE$ShaderMaterial) {\n  _inherits(MeshLineMaterial, _THREE$ShaderMaterial);\n  var _super2 = _createSuper(MeshLineMaterial);\n  function MeshLineMaterial(parameters) {\n    var _this2;\n    _classCallCheck(this, MeshLineMaterial);\n    _this2 = _super2.call(this, {\n      uniforms: _objectSpread(_objectSpread({}, THREE.UniformsLib.fog), {}, {\n        lineWidth: {\n          value: 1\n        },\n        map: {\n          value: null\n        },\n        useMap: {\n          value: 0\n        },\n        alphaMap: {\n          value: null\n        },\n        useAlphaMap: {\n          value: 0\n        },\n        color: {\n          value: new THREE.Color(16777215)\n        },\n        gradient: {\n          value: [new THREE.Color(16711680), new THREE.Color(65280)]\n        },\n        opacity: {\n          value: 1\n        },\n        resolution: {\n          value: new THREE.Vector2(1, 1)\n        },\n        sizeAttenuation: {\n          value: 1\n        },\n        dashArray: {\n          value: 0\n        },\n        dashOffset: {\n          value: 0\n        },\n        dashRatio: {\n          value: 0.5\n        },\n        useDash: {\n          value: 0\n        },\n        useGradient: {\n          value: 0\n        },\n        visibility: {\n          value: 1\n        },\n        alphaTest: {\n          value: 0\n        },\n        repeat: {\n          value: new THREE.Vector2(1, 1)\n        }\n      }),\n      vertexShader: vertexShader,\n      fragmentShader: fragmentShader\n    });\n    __publicField(_assertThisInitialized(_this2), \"lineWidth\");\n    __publicField(_assertThisInitialized(_this2), \"map\");\n    __publicField(_assertThisInitialized(_this2), \"useMap\");\n    __publicField(_assertThisInitialized(_this2), \"alphaMap\");\n    __publicField(_assertThisInitialized(_this2), \"useAlphaMap\");\n    __publicField(_assertThisInitialized(_this2), \"color\");\n    __publicField(_assertThisInitialized(_this2), \"gradient\");\n    __publicField(_assertThisInitialized(_this2), \"resolution\");\n    __publicField(_assertThisInitialized(_this2), \"sizeAttenuation\");\n    __publicField(_assertThisInitialized(_this2), \"dashArray\");\n    __publicField(_assertThisInitialized(_this2), \"dashOffset\");\n    __publicField(_assertThisInitialized(_this2), \"dashRatio\");\n    __publicField(_assertThisInitialized(_this2), \"useDash\");\n    __publicField(_assertThisInitialized(_this2), \"useGradient\");\n    __publicField(_assertThisInitialized(_this2), \"visibility\");\n    __publicField(_assertThisInitialized(_this2), \"repeat\");\n    _this2.type = \"MeshLineMaterial\";\n    Object.defineProperties(_assertThisInitialized(_this2), {\n      lineWidth: {\n        enumerable: true,\n        get: function get() {\n          return this.uniforms.lineWidth.value;\n        },\n        set: function set(value) {\n          this.uniforms.lineWidth.value = value;\n        }\n      },\n      map: {\n        enumerable: true,\n        get: function get() {\n          return this.uniforms.map.value;\n        },\n        set: function set(value) {\n          this.uniforms.map.value = value;\n        }\n      },\n      useMap: {\n        enumerable: true,\n        get: function get() {\n          return this.uniforms.useMap.value;\n        },\n        set: function set(value) {\n          this.uniforms.useMap.value = value;\n        }\n      },\n      alphaMap: {\n        enumerable: true,\n        get: function get() {\n          return this.uniforms.alphaMap.value;\n        },\n        set: function set(value) {\n          this.uniforms.alphaMap.value = value;\n        }\n      },\n      useAlphaMap: {\n        enumerable: true,\n        get: function get() {\n          return this.uniforms.useAlphaMap.value;\n        },\n        set: function set(value) {\n          this.uniforms.useAlphaMap.value = value;\n        }\n      },\n      color: {\n        enumerable: true,\n        get: function get() {\n          return this.uniforms.color.value;\n        },\n        set: function set(value) {\n          this.uniforms.color.value = value;\n        }\n      },\n      gradient: {\n        enumerable: true,\n        get: function get() {\n          return this.uniforms.gradient.value;\n        },\n        set: function set(value) {\n          this.uniforms.gradient.value = value;\n        }\n      },\n      opacity: {\n        enumerable: true,\n        get: function get() {\n          return this.uniforms.opacity.value;\n        },\n        set: function set(value) {\n          this.uniforms.opacity.value = value;\n        }\n      },\n      resolution: {\n        enumerable: true,\n        get: function get() {\n          return this.uniforms.resolution.value;\n        },\n        set: function set(value) {\n          this.uniforms.resolution.value.copy(value);\n        }\n      },\n      sizeAttenuation: {\n        enumerable: true,\n        get: function get() {\n          return this.uniforms.sizeAttenuation.value;\n        },\n        set: function set(value) {\n          this.uniforms.sizeAttenuation.value = value;\n        }\n      },\n      dashArray: {\n        enumerable: true,\n        get: function get() {\n          return this.uniforms.dashArray.value;\n        },\n        set: function set(value) {\n          this.uniforms.dashArray.value = value;\n          this.useDash = value !== 0 ? 1 : 0;\n        }\n      },\n      dashOffset: {\n        enumerable: true,\n        get: function get() {\n          return this.uniforms.dashOffset.value;\n        },\n        set: function set(value) {\n          this.uniforms.dashOffset.value = value;\n        }\n      },\n      dashRatio: {\n        enumerable: true,\n        get: function get() {\n          return this.uniforms.dashRatio.value;\n        },\n        set: function set(value) {\n          this.uniforms.dashRatio.value = value;\n        }\n      },\n      useDash: {\n        enumerable: true,\n        get: function get() {\n          return this.uniforms.useDash.value;\n        },\n        set: function set(value) {\n          this.uniforms.useDash.value = value;\n        }\n      },\n      useGradient: {\n        enumerable: true,\n        get: function get() {\n          return this.uniforms.useGradient.value;\n        },\n        set: function set(value) {\n          this.uniforms.useGradient.value = value;\n        }\n      },\n      visibility: {\n        enumerable: true,\n        get: function get() {\n          return this.uniforms.visibility.value;\n        },\n        set: function set(value) {\n          this.uniforms.visibility.value = value;\n        }\n      },\n      alphaTest: {\n        enumerable: true,\n        get: function get() {\n          return this.uniforms.alphaTest.value;\n        },\n        set: function set(value) {\n          this.uniforms.alphaTest.value = value;\n        }\n      },\n      repeat: {\n        enumerable: true,\n        get: function get() {\n          return this.uniforms.repeat.value;\n        },\n        set: function set(value) {\n          this.uniforms.repeat.value.copy(value);\n        }\n      }\n    });\n    _this2.setValues(parameters);\n    return _this2;\n  }\n  _createClass(MeshLineMaterial, [{\n    key: \"copy\",\n    value: function copy(source) {\n      _get(_getPrototypeOf(MeshLineMaterial.prototype), \"copy\", this).call(this, source);\n      this.lineWidth = source.lineWidth;\n      this.map = source.map;\n      this.useMap = source.useMap;\n      this.alphaMap = source.alphaMap;\n      this.useAlphaMap = source.useAlphaMap;\n      this.color.copy(source.color);\n      this.gradient = source.gradient;\n      this.opacity = source.opacity;\n      this.resolution.copy(source.resolution);\n      this.sizeAttenuation = source.sizeAttenuation;\n      this.dashArray = source.dashArray;\n      this.dashOffset = source.dashOffset;\n      this.dashRatio = source.dashRatio;\n      this.useDash = source.useDash;\n      this.useGradient = source.useGradient;\n      this.visibility = source.visibility;\n      this.alphaTest = source.alphaTest;\n      this.repeat.copy(source.repeat);\n      return this;\n    }\n  }]);\n  return MeshLineMaterial;\n}(THREE.ShaderMaterial);\nfunction raycast(raycaster, intersects) {\n  var inverseMatrix = new THREE.Matrix4();\n  var ray = new THREE.Ray();\n  var sphere = new THREE.Sphere();\n  var interRay = new THREE.Vector3();\n  var geometry = this.geometry;\n  sphere.copy(geometry.boundingSphere);\n  sphere.applyMatrix4(this.matrixWorld);\n  if (!raycaster.ray.intersectSphere(sphere, interRay)) return;\n  inverseMatrix.copy(this.matrixWorld).invert();\n  ray.copy(raycaster.ray).applyMatrix4(inverseMatrix);\n  var vStart = new THREE.Vector3();\n  var vEnd = new THREE.Vector3();\n  var interSegment = new THREE.Vector3();\n  var step = this instanceof THREE.LineSegments ? 2 : 1;\n  var index = geometry.index;\n  var attributes = geometry.attributes;\n  if (index !== null) {\n    var indices = index.array;\n    var positions = attributes.position.array;\n    var widths = attributes.width.array;\n    for (var i = 0, l = indices.length - 1; i < l; i += step) {\n      var a = indices[i];\n      var b = indices[i + 1];\n      vStart.fromArray(positions, a * 3);\n      vEnd.fromArray(positions, b * 3);\n      var width = widths[Math.floor(i / 3)] != void 0 ? widths[Math.floor(i / 3)] : 1;\n      var precision = raycaster.params.Line.threshold + this.material.lineWidth * width / 2;\n      var precisionSq = precision * precision;\n      var distSq = ray.distanceSqToSegment(vStart, vEnd, interRay, interSegment);\n      if (distSq > precisionSq) continue;\n      interRay.applyMatrix4(this.matrixWorld);\n      var distance = raycaster.ray.origin.distanceTo(interRay);\n      if (distance < raycaster.near || distance > raycaster.far) continue;\n      intersects.push({\n        distance: distance,\n        point: interSegment.clone().applyMatrix4(this.matrixWorld),\n        index: i,\n        face: null,\n        faceIndex: void 0,\n        object: this\n      });\n      i = l;\n    }\n  }\n}\nexport { MeshLineGeometry, MeshLineMaterial, raycast };","map":{"version":3,"names":["__defProp","Object","defineProperty","__defNormalProp","obj","key","value","enumerable","configurable","writable","__publicField","THREE","memcpy","src","srcOffset","dst","dstOffset","length","i","subarray","slice","buffer","set","convertPoints","points","Float32Array","BufferGeometry","getAttribute","array","map","p","isArray","Array","Vector3","x","y","z","Vector2","flat","MeshLineGeometry","_THREE$BufferGeometry","_inherits","_super","_createSuper","_this","_classCallCheck","call","_assertThisInitialized","Matrix4","defineProperties","get","_points","setPoints","widthCallback","_createClass","setMatrixWorld","matrixWorld","wcb","positions","counters","j","c","push","process","compareV3","a","b","aa","ab","copyV3","l","previous","next","side","width","indices_array","uvs","w","v","n","_attributes","position","count","BufferAttribute","uv","index","Uint16Array","copyArray","needsUpdate","setAttribute","setIndex","computeBoundingSphere","computeBoundingBox","advance","_ref","vertexShader","version","parseInt","REVISION","replace","colorspace_fragment","fragmentShader","concat","MeshLineMaterial","_THREE$ShaderMaterial","_super2","parameters","_this2","uniforms","_objectSpread","UniformsLib","fog","lineWidth","useMap","alphaMap","useAlphaMap","color","Color","gradient","opacity","resolution","sizeAttenuation","dashArray","dashOffset","dashRatio","useDash","useGradient","visibility","alphaTest","repeat","type","copy","setValues","source","_get","_getPrototypeOf","prototype","ShaderMaterial","raycast","raycaster","intersects","inverseMatrix","ray","Ray","sphere","Sphere","interRay","geometry","boundingSphere","applyMatrix4","intersectSphere","invert","vStart","vEnd","interSegment","step","LineSegments","attributes","indices","widths","fromArray","Math","floor","precision","params","Line","threshold","material","precisionSq","distSq","distanceSqToSegment","distance","origin","distanceTo","near","far","point","clone","face","faceIndex","object"],"sources":["C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/meshline/dist/index.js"],"sourcesContent":["var __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nimport * as THREE from \"three\";\nfunction memcpy(src, srcOffset, dst, dstOffset, length) {\n  let i;\n  src = src.subarray || src.slice ? src : src.buffer;\n  dst = dst.subarray || dst.slice ? dst : dst.buffer;\n  src = srcOffset ? src.subarray ? src.subarray(srcOffset, length && srcOffset + length) : src.slice(srcOffset, length && srcOffset + length) : src;\n  if (dst.set) {\n    dst.set(src, dstOffset);\n  } else {\n    for (i = 0; i < src.length; i++)\n      dst[i + dstOffset] = src[i];\n  }\n  return dst;\n}\nfunction convertPoints(points) {\n  if (points instanceof Float32Array)\n    return points;\n  if (points instanceof THREE.BufferGeometry)\n    return points.getAttribute(\"position\").array;\n  return points.map((p) => {\n    const isArray = Array.isArray(p);\n    return p instanceof THREE.Vector3 ? [p.x, p.y, p.z] : p instanceof THREE.Vector2 ? [p.x, p.y, 0] : isArray && p.length === 3 ? [p[0], p[1], p[2]] : isArray && p.length === 2 ? [p[0], p[1], 0] : p;\n  }).flat();\n}\nclass MeshLineGeometry extends THREE.BufferGeometry {\n  constructor() {\n    super();\n    __publicField(this, \"type\", \"MeshLine\");\n    __publicField(this, \"isMeshLine\", true);\n    __publicField(this, \"positions\", []);\n    __publicField(this, \"previous\", []);\n    __publicField(this, \"next\", []);\n    __publicField(this, \"side\", []);\n    __publicField(this, \"width\", []);\n    __publicField(this, \"indices_array\", []);\n    __publicField(this, \"uvs\", []);\n    __publicField(this, \"counters\", []);\n    __publicField(this, \"widthCallback\", null);\n    __publicField(this, \"_attributes\");\n    __publicField(this, \"_points\", []);\n    __publicField(this, \"points\");\n    __publicField(this, \"matrixWorld\", new THREE.Matrix4());\n    Object.defineProperties(this, {\n      points: {\n        enumerable: true,\n        get() {\n          return this._points;\n        },\n        set(value) {\n          this.setPoints(value, this.widthCallback);\n        }\n      }\n    });\n  }\n  setMatrixWorld(matrixWorld) {\n    this.matrixWorld = matrixWorld;\n  }\n  setPoints(points, wcb) {\n    points = convertPoints(points);\n    this._points = points;\n    this.widthCallback = wcb != null ? wcb : null;\n    this.positions = [];\n    this.counters = [];\n    if (points.length && points[0] instanceof THREE.Vector3) {\n      for (let j = 0; j < points.length; j++) {\n        const p = points[j];\n        const c = j / (points.length - 1);\n        this.positions.push(p.x, p.y, p.z);\n        this.positions.push(p.x, p.y, p.z);\n        this.counters.push(c);\n        this.counters.push(c);\n      }\n    } else {\n      for (let j = 0; j < points.length; j += 3) {\n        const c = j / (points.length - 1);\n        this.positions.push(points[j], points[j + 1], points[j + 2]);\n        this.positions.push(points[j], points[j + 1], points[j + 2]);\n        this.counters.push(c);\n        this.counters.push(c);\n      }\n    }\n    this.process();\n  }\n  compareV3(a, b) {\n    const aa = a * 6;\n    const ab = b * 6;\n    return this.positions[aa] === this.positions[ab] && this.positions[aa + 1] === this.positions[ab + 1] && this.positions[aa + 2] === this.positions[ab + 2];\n  }\n  copyV3(a) {\n    const aa = a * 6;\n    return [this.positions[aa], this.positions[aa + 1], this.positions[aa + 2]];\n  }\n  process() {\n    const l = this.positions.length / 6;\n    this.previous = [];\n    this.next = [];\n    this.side = [];\n    this.width = [];\n    this.indices_array = [];\n    this.uvs = [];\n    let w;\n    let v;\n    if (this.compareV3(0, l - 1)) {\n      v = this.copyV3(l - 2);\n    } else {\n      v = this.copyV3(0);\n    }\n    this.previous.push(v[0], v[1], v[2]);\n    this.previous.push(v[0], v[1], v[2]);\n    for (let j = 0; j < l; j++) {\n      this.side.push(1);\n      this.side.push(-1);\n      if (this.widthCallback)\n        w = this.widthCallback(j / (l - 1));\n      else\n        w = 1;\n      this.width.push(w);\n      this.width.push(w);\n      this.uvs.push(j / (l - 1), 0);\n      this.uvs.push(j / (l - 1), 1);\n      if (j < l - 1) {\n        v = this.copyV3(j);\n        this.previous.push(v[0], v[1], v[2]);\n        this.previous.push(v[0], v[1], v[2]);\n        const n = j * 2;\n        this.indices_array.push(n, n + 1, n + 2);\n        this.indices_array.push(n + 2, n + 1, n + 3);\n      }\n      if (j > 0) {\n        v = this.copyV3(j);\n        this.next.push(v[0], v[1], v[2]);\n        this.next.push(v[0], v[1], v[2]);\n      }\n    }\n    if (this.compareV3(l - 1, 0)) {\n      v = this.copyV3(1);\n    } else {\n      v = this.copyV3(l - 1);\n    }\n    this.next.push(v[0], v[1], v[2]);\n    this.next.push(v[0], v[1], v[2]);\n    if (!this._attributes || this._attributes.position.count !== this.counters.length) {\n      this._attributes = {\n        position: new THREE.BufferAttribute(new Float32Array(this.positions), 3),\n        previous: new THREE.BufferAttribute(new Float32Array(this.previous), 3),\n        next: new THREE.BufferAttribute(new Float32Array(this.next), 3),\n        side: new THREE.BufferAttribute(new Float32Array(this.side), 1),\n        width: new THREE.BufferAttribute(new Float32Array(this.width), 1),\n        uv: new THREE.BufferAttribute(new Float32Array(this.uvs), 2),\n        index: new THREE.BufferAttribute(new Uint16Array(this.indices_array), 1),\n        counters: new THREE.BufferAttribute(new Float32Array(this.counters), 1)\n      };\n    } else {\n      this._attributes.position.copyArray(new Float32Array(this.positions));\n      this._attributes.position.needsUpdate = true;\n      this._attributes.previous.copyArray(new Float32Array(this.previous));\n      this._attributes.previous.needsUpdate = true;\n      this._attributes.next.copyArray(new Float32Array(this.next));\n      this._attributes.next.needsUpdate = true;\n      this._attributes.side.copyArray(new Float32Array(this.side));\n      this._attributes.side.needsUpdate = true;\n      this._attributes.width.copyArray(new Float32Array(this.width));\n      this._attributes.width.needsUpdate = true;\n      this._attributes.uv.copyArray(new Float32Array(this.uvs));\n      this._attributes.uv.needsUpdate = true;\n      this._attributes.index.copyArray(new Uint16Array(this.indices_array));\n      this._attributes.index.needsUpdate = true;\n    }\n    this.setAttribute(\"position\", this._attributes.position);\n    this.setAttribute(\"previous\", this._attributes.previous);\n    this.setAttribute(\"next\", this._attributes.next);\n    this.setAttribute(\"side\", this._attributes.side);\n    this.setAttribute(\"width\", this._attributes.width);\n    this.setAttribute(\"uv\", this._attributes.uv);\n    this.setAttribute(\"counters\", this._attributes.counters);\n    this.setAttribute(\"position\", this._attributes.position);\n    this.setAttribute(\"previous\", this._attributes.previous);\n    this.setAttribute(\"next\", this._attributes.next);\n    this.setAttribute(\"side\", this._attributes.side);\n    this.setAttribute(\"width\", this._attributes.width);\n    this.setAttribute(\"uv\", this._attributes.uv);\n    this.setAttribute(\"counters\", this._attributes.counters);\n    this.setIndex(this._attributes.index);\n    this.computeBoundingSphere();\n    this.computeBoundingBox();\n  }\n  advance({ x, y, z }) {\n    const positions = this._attributes.position.array;\n    const previous = this._attributes.previous.array;\n    const next = this._attributes.next.array;\n    const l = positions.length;\n    memcpy(positions, 0, previous, 0, l);\n    memcpy(positions, 6, positions, 0, l - 6);\n    positions[l - 6] = x;\n    positions[l - 5] = y;\n    positions[l - 4] = z;\n    positions[l - 3] = x;\n    positions[l - 2] = y;\n    positions[l - 1] = z;\n    memcpy(positions, 6, next, 0, l - 6);\n    next[l - 6] = x;\n    next[l - 5] = y;\n    next[l - 4] = z;\n    next[l - 3] = x;\n    next[l - 2] = y;\n    next[l - 1] = z;\n    this._attributes.position.needsUpdate = true;\n    this._attributes.previous.needsUpdate = true;\n    this._attributes.next.needsUpdate = true;\n  }\n}\nconst vertexShader = `\n  #include <common>\n  #include <logdepthbuf_pars_vertex>\n  #include <fog_pars_vertex>\n  #include <clipping_planes_pars_vertex>\n\n  attribute vec3 previous;\n  attribute vec3 next;\n  attribute float side;\n  attribute float width;\n  attribute float counters;\n  \n  uniform vec2 resolution;\n  uniform float lineWidth;\n  uniform vec3 color;\n  uniform float opacity;\n  uniform float sizeAttenuation;\n  \n  varying vec2 vUV;\n  varying vec4 vColor;\n  varying float vCounters;\n  \n  vec2 fix(vec4 i, float aspect) {\n    vec2 res = i.xy / i.w;\n    res.x *= aspect;\n    return res;\n  }\n  \n  void main() {\n    float aspect = resolution.x / resolution.y;\n    vColor = vec4(color, opacity);\n    vUV = uv;\n    vCounters = counters;\n  \n    mat4 m = projectionMatrix * modelViewMatrix;\n    vec4 finalPosition = m * vec4(position, 1.0) * aspect;\n    vec4 prevPos = m * vec4(previous, 1.0);\n    vec4 nextPos = m * vec4(next, 1.0);\n  \n    vec2 currentP = fix(finalPosition, aspect);\n    vec2 prevP = fix(prevPos, aspect);\n    vec2 nextP = fix(nextPos, aspect);\n  \n    float w = lineWidth * width;\n  \n    vec2 dir;\n    if (nextP == currentP) dir = normalize(currentP - prevP);\n    else if (prevP == currentP) dir = normalize(nextP - currentP);\n    else {\n      vec2 dir1 = normalize(currentP - prevP);\n      vec2 dir2 = normalize(nextP - currentP);\n      dir = normalize(dir1 + dir2);\n  \n      vec2 perp = vec2(-dir1.y, dir1.x);\n      vec2 miter = vec2(-dir.y, dir.x);\n      //w = clamp(w / dot(miter, perp), 0., 4. * lineWidth * width);\n    }\n  \n    //vec2 normal = (cross(vec3(dir, 0.), vec3(0., 0., 1.))).xy;\n    vec4 normal = vec4(-dir.y, dir.x, 0., 1.);\n    normal.xy *= .5 * w;\n    //normal *= projectionMatrix;\n    if (sizeAttenuation == 0.) {\n      normal.xy *= finalPosition.w;\n      normal.xy /= (vec4(resolution, 0., 1.) * projectionMatrix).xy * aspect;\n    }\n  \n    finalPosition.xy += normal.xy * side;\n    gl_Position = finalPosition;\n    #include <logdepthbuf_vertex>\n    #include <fog_vertex>\n    vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n    #include <clipping_planes_vertex>\n    #include <fog_vertex>\n  }\n`;\nconst version = /* @__PURE__ */ (() => parseInt(THREE.REVISION.replace(/\\D+/g, \"\")))();\nconst colorspace_fragment = version >= 154 ? \"colorspace_fragment\" : \"encodings_fragment\";\nconst fragmentShader = `\n  #include <fog_pars_fragment>\n  #include <logdepthbuf_pars_fragment>\n  #include <clipping_planes_pars_fragment>\n  \n  uniform sampler2D map;\n  uniform sampler2D alphaMap;\n  uniform float useGradient;\n  uniform float useMap;\n  uniform float useAlphaMap;\n  uniform float useDash;\n  uniform float dashArray;\n  uniform float dashOffset;\n  uniform float dashRatio;\n  uniform float visibility;\n  uniform float alphaTest;\n  uniform vec2 repeat;\n  uniform vec3 gradient[2];\n  \n  varying vec2 vUV;\n  varying vec4 vColor;\n  varying float vCounters;\n  \n  void main() {\n    #include <logdepthbuf_fragment>\n    vec4 diffuseColor = vColor;\n    if (useGradient == 1.) diffuseColor = vec4(mix(gradient[0], gradient[1], vCounters), 1.0);\n    if (useMap == 1.) diffuseColor *= texture2D(map, vUV * repeat);\n    if (useAlphaMap == 1.) diffuseColor.a *= texture2D(alphaMap, vUV * repeat).a;\n    if (diffuseColor.a < alphaTest) discard;\n    if (useDash == 1.) diffuseColor.a *= ceil(mod(vCounters + dashOffset, dashArray) - (dashArray * dashRatio));\n    diffuseColor.a *= step(vCounters, visibility);\n    #include <clipping_planes_fragment>\n    gl_FragColor = diffuseColor;     \n    #include <fog_fragment>\n    #include <tonemapping_fragment>\n    #include <${colorspace_fragment}>\n  }\n`;\nclass MeshLineMaterial extends THREE.ShaderMaterial {\n  constructor(parameters) {\n    super({\n      uniforms: {\n        ...THREE.UniformsLib.fog,\n        lineWidth: { value: 1 },\n        map: { value: null },\n        useMap: { value: 0 },\n        alphaMap: { value: null },\n        useAlphaMap: { value: 0 },\n        color: { value: new THREE.Color(16777215) },\n        gradient: { value: [new THREE.Color(16711680), new THREE.Color(65280)] },\n        opacity: { value: 1 },\n        resolution: { value: new THREE.Vector2(1, 1) },\n        sizeAttenuation: { value: 1 },\n        dashArray: { value: 0 },\n        dashOffset: { value: 0 },\n        dashRatio: { value: 0.5 },\n        useDash: { value: 0 },\n        useGradient: { value: 0 },\n        visibility: { value: 1 },\n        alphaTest: { value: 0 },\n        repeat: { value: new THREE.Vector2(1, 1) }\n      },\n      vertexShader,\n      fragmentShader\n    });\n    __publicField(this, \"lineWidth\");\n    __publicField(this, \"map\");\n    __publicField(this, \"useMap\");\n    __publicField(this, \"alphaMap\");\n    __publicField(this, \"useAlphaMap\");\n    __publicField(this, \"color\");\n    __publicField(this, \"gradient\");\n    __publicField(this, \"resolution\");\n    __publicField(this, \"sizeAttenuation\");\n    __publicField(this, \"dashArray\");\n    __publicField(this, \"dashOffset\");\n    __publicField(this, \"dashRatio\");\n    __publicField(this, \"useDash\");\n    __publicField(this, \"useGradient\");\n    __publicField(this, \"visibility\");\n    __publicField(this, \"repeat\");\n    this.type = \"MeshLineMaterial\";\n    Object.defineProperties(this, {\n      lineWidth: {\n        enumerable: true,\n        get() {\n          return this.uniforms.lineWidth.value;\n        },\n        set(value) {\n          this.uniforms.lineWidth.value = value;\n        }\n      },\n      map: {\n        enumerable: true,\n        get() {\n          return this.uniforms.map.value;\n        },\n        set(value) {\n          this.uniforms.map.value = value;\n        }\n      },\n      useMap: {\n        enumerable: true,\n        get() {\n          return this.uniforms.useMap.value;\n        },\n        set(value) {\n          this.uniforms.useMap.value = value;\n        }\n      },\n      alphaMap: {\n        enumerable: true,\n        get() {\n          return this.uniforms.alphaMap.value;\n        },\n        set(value) {\n          this.uniforms.alphaMap.value = value;\n        }\n      },\n      useAlphaMap: {\n        enumerable: true,\n        get() {\n          return this.uniforms.useAlphaMap.value;\n        },\n        set(value) {\n          this.uniforms.useAlphaMap.value = value;\n        }\n      },\n      color: {\n        enumerable: true,\n        get() {\n          return this.uniforms.color.value;\n        },\n        set(value) {\n          this.uniforms.color.value = value;\n        }\n      },\n      gradient: {\n        enumerable: true,\n        get() {\n          return this.uniforms.gradient.value;\n        },\n        set(value) {\n          this.uniforms.gradient.value = value;\n        }\n      },\n      opacity: {\n        enumerable: true,\n        get() {\n          return this.uniforms.opacity.value;\n        },\n        set(value) {\n          this.uniforms.opacity.value = value;\n        }\n      },\n      resolution: {\n        enumerable: true,\n        get() {\n          return this.uniforms.resolution.value;\n        },\n        set(value) {\n          this.uniforms.resolution.value.copy(value);\n        }\n      },\n      sizeAttenuation: {\n        enumerable: true,\n        get() {\n          return this.uniforms.sizeAttenuation.value;\n        },\n        set(value) {\n          this.uniforms.sizeAttenuation.value = value;\n        }\n      },\n      dashArray: {\n        enumerable: true,\n        get() {\n          return this.uniforms.dashArray.value;\n        },\n        set(value) {\n          this.uniforms.dashArray.value = value;\n          this.useDash = value !== 0 ? 1 : 0;\n        }\n      },\n      dashOffset: {\n        enumerable: true,\n        get() {\n          return this.uniforms.dashOffset.value;\n        },\n        set(value) {\n          this.uniforms.dashOffset.value = value;\n        }\n      },\n      dashRatio: {\n        enumerable: true,\n        get() {\n          return this.uniforms.dashRatio.value;\n        },\n        set(value) {\n          this.uniforms.dashRatio.value = value;\n        }\n      },\n      useDash: {\n        enumerable: true,\n        get() {\n          return this.uniforms.useDash.value;\n        },\n        set(value) {\n          this.uniforms.useDash.value = value;\n        }\n      },\n      useGradient: {\n        enumerable: true,\n        get() {\n          return this.uniforms.useGradient.value;\n        },\n        set(value) {\n          this.uniforms.useGradient.value = value;\n        }\n      },\n      visibility: {\n        enumerable: true,\n        get() {\n          return this.uniforms.visibility.value;\n        },\n        set(value) {\n          this.uniforms.visibility.value = value;\n        }\n      },\n      alphaTest: {\n        enumerable: true,\n        get() {\n          return this.uniforms.alphaTest.value;\n        },\n        set(value) {\n          this.uniforms.alphaTest.value = value;\n        }\n      },\n      repeat: {\n        enumerable: true,\n        get() {\n          return this.uniforms.repeat.value;\n        },\n        set(value) {\n          this.uniforms.repeat.value.copy(value);\n        }\n      }\n    });\n    this.setValues(parameters);\n  }\n  copy(source) {\n    super.copy(source);\n    this.lineWidth = source.lineWidth;\n    this.map = source.map;\n    this.useMap = source.useMap;\n    this.alphaMap = source.alphaMap;\n    this.useAlphaMap = source.useAlphaMap;\n    this.color.copy(source.color);\n    this.gradient = source.gradient;\n    this.opacity = source.opacity;\n    this.resolution.copy(source.resolution);\n    this.sizeAttenuation = source.sizeAttenuation;\n    this.dashArray = source.dashArray;\n    this.dashOffset = source.dashOffset;\n    this.dashRatio = source.dashRatio;\n    this.useDash = source.useDash;\n    this.useGradient = source.useGradient;\n    this.visibility = source.visibility;\n    this.alphaTest = source.alphaTest;\n    this.repeat.copy(source.repeat);\n    return this;\n  }\n}\nfunction raycast(raycaster, intersects) {\n  const inverseMatrix = new THREE.Matrix4();\n  const ray = new THREE.Ray();\n  const sphere = new THREE.Sphere();\n  const interRay = new THREE.Vector3();\n  const geometry = this.geometry;\n  sphere.copy(geometry.boundingSphere);\n  sphere.applyMatrix4(this.matrixWorld);\n  if (!raycaster.ray.intersectSphere(sphere, interRay))\n    return;\n  inverseMatrix.copy(this.matrixWorld).invert();\n  ray.copy(raycaster.ray).applyMatrix4(inverseMatrix);\n  const vStart = new THREE.Vector3();\n  const vEnd = new THREE.Vector3();\n  const interSegment = new THREE.Vector3();\n  const step = this instanceof THREE.LineSegments ? 2 : 1;\n  const index = geometry.index;\n  const attributes = geometry.attributes;\n  if (index !== null) {\n    const indices = index.array;\n    const positions = attributes.position.array;\n    const widths = attributes.width.array;\n    for (let i = 0, l = indices.length - 1; i < l; i += step) {\n      const a = indices[i];\n      const b = indices[i + 1];\n      vStart.fromArray(positions, a * 3);\n      vEnd.fromArray(positions, b * 3);\n      const width = widths[Math.floor(i / 3)] != void 0 ? widths[Math.floor(i / 3)] : 1;\n      const precision = raycaster.params.Line.threshold + this.material.lineWidth * width / 2;\n      const precisionSq = precision * precision;\n      const distSq = ray.distanceSqToSegment(vStart, vEnd, interRay, interSegment);\n      if (distSq > precisionSq)\n        continue;\n      interRay.applyMatrix4(this.matrixWorld);\n      const distance = raycaster.ray.origin.distanceTo(interRay);\n      if (distance < raycaster.near || distance > raycaster.far)\n        continue;\n      intersects.push({\n        distance,\n        point: interSegment.clone().applyMatrix4(this.matrixWorld),\n        index: i,\n        face: null,\n        faceIndex: void 0,\n        object: this\n      });\n      i = l;\n    }\n  }\n}\nexport {\n  MeshLineGeometry,\n  MeshLineMaterial,\n  raycast\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}