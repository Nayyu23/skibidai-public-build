{"ast":null,"code":"import _createForOfIteratorHelper from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _classCallCheck from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _assertThisInitialized from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js\";\nimport _inherits from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = function __defNormalProp(obj, key, value) {\n  return key in obj ? __defProp(obj, key, {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: value\n  }) : obj[key] = value;\n};\nvar __publicField = function __publicField(obj, key, value) {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nimport { Matrix4, EventDispatcher, Vector2, Vector3, Quaternion, Group, EllipseCurve, BufferGeometry, PerspectiveCamera, MathUtils, OrthographicCamera, Box3, Sphere, GridHelper, LineBasicMaterial, Line, Raycaster } from \"three\";\nvar STATE = {\n  IDLE: Symbol(),\n  ROTATE: Symbol(),\n  PAN: Symbol(),\n  SCALE: Symbol(),\n  FOV: Symbol(),\n  FOCUS: Symbol(),\n  ZROTATE: Symbol(),\n  TOUCH_MULTI: Symbol(),\n  ANIMATION_FOCUS: Symbol(),\n  ANIMATION_ROTATE: Symbol()\n};\nvar INPUT = {\n  NONE: Symbol(),\n  ONE_FINGER: Symbol(),\n  ONE_FINGER_SWITCHED: Symbol(),\n  TWO_FINGER: Symbol(),\n  MULT_FINGER: Symbol(),\n  CURSOR: Symbol()\n};\nvar _center = {\n  x: 0,\n  y: 0\n};\nvar _transformation = {\n  camera: new Matrix4(),\n  gizmos: new Matrix4()\n};\nvar _changeEvent = {\n  type: \"change\"\n};\nvar _startEvent = {\n  type: \"start\"\n};\nvar _endEvent = {\n  type: \"end\"\n};\nvar ArcballControls = /*#__PURE__*/function (_EventDispatcher) {\n  _inherits(ArcballControls, _EventDispatcher);\n  var _super = _createSuper(ArcballControls);\n  function ArcballControls(camera) {\n    var _this;\n    var domElement = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    var scene = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n    _classCallCheck(this, ArcballControls);\n    _this = _super.call(this);\n    __publicField(_assertThisInitialized(_this), \"camera\");\n    __publicField(_assertThisInitialized(_this), \"domElement\");\n    __publicField(_assertThisInitialized(_this), \"scene\");\n    __publicField(_assertThisInitialized(_this), \"mouseActions\");\n    __publicField(_assertThisInitialized(_this), \"_mouseOp\");\n    __publicField(_assertThisInitialized(_this), \"_v2_1\");\n    __publicField(_assertThisInitialized(_this), \"_v3_1\");\n    __publicField(_assertThisInitialized(_this), \"_v3_2\");\n    __publicField(_assertThisInitialized(_this), \"_m4_1\");\n    __publicField(_assertThisInitialized(_this), \"_m4_2\");\n    __publicField(_assertThisInitialized(_this), \"_quat\");\n    __publicField(_assertThisInitialized(_this), \"_translationMatrix\");\n    __publicField(_assertThisInitialized(_this), \"_rotationMatrix\");\n    __publicField(_assertThisInitialized(_this), \"_scaleMatrix\");\n    __publicField(_assertThisInitialized(_this), \"_rotationAxis\");\n    __publicField(_assertThisInitialized(_this), \"_cameraMatrixState\");\n    __publicField(_assertThisInitialized(_this), \"_cameraProjectionState\");\n    __publicField(_assertThisInitialized(_this), \"_fovState\");\n    __publicField(_assertThisInitialized(_this), \"_upState\");\n    __publicField(_assertThisInitialized(_this), \"_zoomState\");\n    __publicField(_assertThisInitialized(_this), \"_nearPos\");\n    __publicField(_assertThisInitialized(_this), \"_farPos\");\n    __publicField(_assertThisInitialized(_this), \"_gizmoMatrixState\");\n    __publicField(_assertThisInitialized(_this), \"_up0\");\n    __publicField(_assertThisInitialized(_this), \"_zoom0\");\n    __publicField(_assertThisInitialized(_this), \"_fov0\");\n    __publicField(_assertThisInitialized(_this), \"_initialNear\");\n    __publicField(_assertThisInitialized(_this), \"_nearPos0\");\n    __publicField(_assertThisInitialized(_this), \"_initialFar\");\n    __publicField(_assertThisInitialized(_this), \"_farPos0\");\n    __publicField(_assertThisInitialized(_this), \"_cameraMatrixState0\");\n    __publicField(_assertThisInitialized(_this), \"_gizmoMatrixState0\");\n    __publicField(_assertThisInitialized(_this), \"_button\");\n    __publicField(_assertThisInitialized(_this), \"_touchStart\");\n    __publicField(_assertThisInitialized(_this), \"_touchCurrent\");\n    __publicField(_assertThisInitialized(_this), \"_input\");\n    __publicField(_assertThisInitialized(_this), \"_switchSensibility\");\n    __publicField(_assertThisInitialized(_this), \"_startFingerDistance\");\n    __publicField(_assertThisInitialized(_this), \"_currentFingerDistance\");\n    __publicField(_assertThisInitialized(_this), \"_startFingerRotation\");\n    __publicField(_assertThisInitialized(_this), \"_currentFingerRotation\");\n    __publicField(_assertThisInitialized(_this), \"_devPxRatio\");\n    __publicField(_assertThisInitialized(_this), \"_downValid\");\n    __publicField(_assertThisInitialized(_this), \"_nclicks\");\n    __publicField(_assertThisInitialized(_this), \"_downEvents\");\n    __publicField(_assertThisInitialized(_this), \"_clickStart\");\n    __publicField(_assertThisInitialized(_this), \"_maxDownTime\");\n    __publicField(_assertThisInitialized(_this), \"_maxInterval\");\n    __publicField(_assertThisInitialized(_this), \"_posThreshold\");\n    __publicField(_assertThisInitialized(_this), \"_movementThreshold\");\n    __publicField(_assertThisInitialized(_this), \"_currentCursorPosition\");\n    __publicField(_assertThisInitialized(_this), \"_startCursorPosition\");\n    __publicField(_assertThisInitialized(_this), \"_grid\");\n    __publicField(_assertThisInitialized(_this), \"_gridPosition\");\n    __publicField(_assertThisInitialized(_this), \"_gizmos\");\n    __publicField(_assertThisInitialized(_this), \"_curvePts\");\n    __publicField(_assertThisInitialized(_this), \"_timeStart\");\n    __publicField(_assertThisInitialized(_this), \"_animationId\");\n    __publicField(_assertThisInitialized(_this), \"focusAnimationTime\");\n    __publicField(_assertThisInitialized(_this), \"_timePrev\");\n    __publicField(_assertThisInitialized(_this), \"_timeCurrent\");\n    __publicField(_assertThisInitialized(_this), \"_anglePrev\");\n    __publicField(_assertThisInitialized(_this), \"_angleCurrent\");\n    __publicField(_assertThisInitialized(_this), \"_cursorPosPrev\");\n    __publicField(_assertThisInitialized(_this), \"_cursorPosCurr\");\n    __publicField(_assertThisInitialized(_this), \"_wPrev\");\n    __publicField(_assertThisInitialized(_this), \"_wCurr\");\n    __publicField(_assertThisInitialized(_this), \"adjustNearFar\");\n    __publicField(_assertThisInitialized(_this), \"scaleFactor\");\n    __publicField(_assertThisInitialized(_this), \"dampingFactor\");\n    __publicField(_assertThisInitialized(_this), \"wMax\");\n    __publicField(_assertThisInitialized(_this), \"enableAnimations\");\n    __publicField(_assertThisInitialized(_this), \"enableGrid\");\n    __publicField(_assertThisInitialized(_this), \"cursorZoom\");\n    __publicField(_assertThisInitialized(_this), \"minFov\");\n    __publicField(_assertThisInitialized(_this), \"maxFov\");\n    __publicField(_assertThisInitialized(_this), \"enabled\");\n    __publicField(_assertThisInitialized(_this), \"enablePan\");\n    __publicField(_assertThisInitialized(_this), \"enableRotate\");\n    __publicField(_assertThisInitialized(_this), \"enableZoom\");\n    __publicField(_assertThisInitialized(_this), \"minDistance\");\n    __publicField(_assertThisInitialized(_this), \"maxDistance\");\n    __publicField(_assertThisInitialized(_this), \"minZoom\");\n    __publicField(_assertThisInitialized(_this), \"maxZoom\");\n    __publicField(_assertThisInitialized(_this), \"target\");\n    __publicField(_assertThisInitialized(_this), \"_currentTarget\");\n    __publicField(_assertThisInitialized(_this), \"_tbRadius\");\n    __publicField(_assertThisInitialized(_this), \"_state\");\n    //listeners\n    __publicField(_assertThisInitialized(_this), \"onWindowResize\", function () {\n      var scale = (_this._gizmos.scale.x + _this._gizmos.scale.y + _this._gizmos.scale.z) / 3;\n      if (_this.camera) {\n        var tbRadius = _this.calculateTbRadius(_this.camera);\n        if (tbRadius !== void 0) {\n          _this._tbRadius = tbRadius;\n        }\n      }\n      var newRadius = _this._tbRadius / scale;\n      var curve = new EllipseCurve(0, 0, newRadius, newRadius);\n      var points = curve.getPoints(_this._curvePts);\n      var curveGeometry = new BufferGeometry().setFromPoints(points);\n      for (var gizmo in _this._gizmos.children) {\n        var child = _this._gizmos.children[gizmo];\n        child.geometry = curveGeometry;\n      }\n      _this.dispatchEvent(_changeEvent);\n    });\n    __publicField(_assertThisInitialized(_this), \"onContextMenu\", function (event) {\n      if (!_this.enabled) {\n        return;\n      }\n      for (var i = 0; i < _this.mouseActions.length; i++) {\n        if (_this.mouseActions[i].mouse == 2) {\n          event.preventDefault();\n          break;\n        }\n      }\n    });\n    __publicField(_assertThisInitialized(_this), \"onPointerCancel\", function () {\n      _this._touchStart.splice(0, _this._touchStart.length);\n      _this._touchCurrent.splice(0, _this._touchCurrent.length);\n      _this._input = INPUT.NONE;\n    });\n    __publicField(_assertThisInitialized(_this), \"onPointerDown\", function (event) {\n      if (event.button == 0 && event.isPrimary) {\n        _this._downValid = true;\n        _this._downEvents.push(event);\n      } else {\n        _this._downValid = false;\n      }\n      if (event.pointerType == \"touch\" && _this._input != INPUT.CURSOR) {\n        _this._touchStart.push(event);\n        _this._touchCurrent.push(event);\n        switch (_this._input) {\n          case INPUT.NONE:\n            _this._input = INPUT.ONE_FINGER;\n            _this.onSinglePanStart(event, \"ROTATE\");\n            window.addEventListener(\"pointermove\", _this.onPointerMove);\n            window.addEventListener(\"pointerup\", _this.onPointerUp);\n            break;\n          case INPUT.ONE_FINGER:\n          case INPUT.ONE_FINGER_SWITCHED:\n            _this._input = INPUT.TWO_FINGER;\n            _this.onRotateStart();\n            _this.onPinchStart();\n            _this.onDoublePanStart();\n            break;\n          case INPUT.TWO_FINGER:\n            _this._input = INPUT.MULT_FINGER;\n            _this.onTriplePanStart();\n            break;\n        }\n      } else if (event.pointerType != \"touch\" && _this._input == INPUT.NONE) {\n        var modifier = null;\n        if (event.ctrlKey || event.metaKey) {\n          modifier = \"CTRL\";\n        } else if (event.shiftKey) {\n          modifier = \"SHIFT\";\n        }\n        _this._mouseOp = _this.getOpFromAction(event.button, modifier);\n        if (_this._mouseOp) {\n          window.addEventListener(\"pointermove\", _this.onPointerMove);\n          window.addEventListener(\"pointerup\", _this.onPointerUp);\n          _this._input = INPUT.CURSOR;\n          _this._button = event.button;\n          _this.onSinglePanStart(event, _this._mouseOp);\n        }\n      }\n    });\n    __publicField(_assertThisInitialized(_this), \"onPointerMove\", function (event) {\n      if (event.pointerType == \"touch\" && _this._input != INPUT.CURSOR) {\n        switch (_this._input) {\n          case INPUT.ONE_FINGER:\n            _this.updateTouchEvent(event);\n            _this.onSinglePanMove(event, STATE.ROTATE);\n            break;\n          case INPUT.ONE_FINGER_SWITCHED:\n            var movement = _this.calculatePointersDistance(_this._touchCurrent[0], event) * _this._devPxRatio;\n            if (movement >= _this._switchSensibility) {\n              _this._input = INPUT.ONE_FINGER;\n              _this.updateTouchEvent(event);\n              _this.onSinglePanStart(event, \"ROTATE\");\n              break;\n            }\n            break;\n          case INPUT.TWO_FINGER:\n            _this.updateTouchEvent(event);\n            _this.onRotateMove();\n            _this.onPinchMove();\n            _this.onDoublePanMove();\n            break;\n          case INPUT.MULT_FINGER:\n            _this.updateTouchEvent(event);\n            _this.onTriplePanMove();\n            break;\n        }\n      } else if (event.pointerType != \"touch\" && _this._input == INPUT.CURSOR) {\n        var modifier = null;\n        if (event.ctrlKey || event.metaKey) {\n          modifier = \"CTRL\";\n        } else if (event.shiftKey) {\n          modifier = \"SHIFT\";\n        }\n        var mouseOpState = _this.getOpStateFromAction(_this._button, modifier);\n        if (mouseOpState) {\n          _this.onSinglePanMove(event, mouseOpState);\n        }\n      }\n      if (_this._downValid) {\n        var _movement = _this.calculatePointersDistance(_this._downEvents[_this._downEvents.length - 1], event) * _this._devPxRatio;\n        if (_movement > _this._movementThreshold) {\n          _this._downValid = false;\n        }\n      }\n    });\n    __publicField(_assertThisInitialized(_this), \"onPointerUp\", function (event) {\n      if (event.pointerType == \"touch\" && _this._input != INPUT.CURSOR) {\n        var nTouch = _this._touchCurrent.length;\n        for (var i = 0; i < nTouch; i++) {\n          if (_this._touchCurrent[i].pointerId == event.pointerId) {\n            _this._touchCurrent.splice(i, 1);\n            _this._touchStart.splice(i, 1);\n            break;\n          }\n        }\n        switch (_this._input) {\n          case INPUT.ONE_FINGER:\n          case INPUT.ONE_FINGER_SWITCHED:\n            window.removeEventListener(\"pointermove\", _this.onPointerMove);\n            window.removeEventListener(\"pointerup\", _this.onPointerUp);\n            _this._input = INPUT.NONE;\n            _this.onSinglePanEnd();\n            break;\n          case INPUT.TWO_FINGER:\n            _this.onDoublePanEnd();\n            _this.onPinchEnd();\n            _this.onRotateEnd();\n            _this._input = INPUT.ONE_FINGER_SWITCHED;\n            break;\n          case INPUT.MULT_FINGER:\n            if (_this._touchCurrent.length == 0) {\n              window.removeEventListener(\"pointermove\", _this.onPointerMove);\n              window.removeEventListener(\"pointerup\", _this.onPointerUp);\n              _this._input = INPUT.NONE;\n              _this.onTriplePanEnd();\n            }\n            break;\n        }\n      } else if (event.pointerType != \"touch\" && _this._input == INPUT.CURSOR) {\n        window.removeEventListener(\"pointermove\", _this.onPointerMove);\n        window.removeEventListener(\"pointerup\", _this.onPointerUp);\n        _this._input = INPUT.NONE;\n        _this.onSinglePanEnd();\n        _this._button = -1;\n      }\n      if (event.isPrimary) {\n        if (_this._downValid) {\n          var downTime = event.timeStamp - _this._downEvents[_this._downEvents.length - 1].timeStamp;\n          if (downTime <= _this._maxDownTime) {\n            if (_this._nclicks == 0) {\n              _this._nclicks = 1;\n              _this._clickStart = performance.now();\n            } else {\n              var clickInterval = event.timeStamp - _this._clickStart;\n              var movement = _this.calculatePointersDistance(_this._downEvents[1], _this._downEvents[0]) * _this._devPxRatio;\n              if (clickInterval <= _this._maxInterval && movement <= _this._posThreshold) {\n                _this._nclicks = 0;\n                _this._downEvents.splice(0, _this._downEvents.length);\n                _this.onDoubleTap(event);\n              } else {\n                _this._nclicks = 1;\n                _this._downEvents.shift();\n                _this._clickStart = performance.now();\n              }\n            }\n          } else {\n            _this._downValid = false;\n            _this._nclicks = 0;\n            _this._downEvents.splice(0, _this._downEvents.length);\n          }\n        } else {\n          _this._nclicks = 0;\n          _this._downEvents.splice(0, _this._downEvents.length);\n        }\n      }\n    });\n    __publicField(_assertThisInitialized(_this), \"onWheel\", function (event) {\n      var _a, _b;\n      if (_this.enabled && _this.enableZoom && _this.domElement) {\n        var modifier = null;\n        if (event.ctrlKey || event.metaKey) {\n          modifier = \"CTRL\";\n        } else if (event.shiftKey) {\n          modifier = \"SHIFT\";\n        }\n        var mouseOp = _this.getOpFromAction(\"WHEEL\", modifier);\n        if (mouseOp) {\n          event.preventDefault();\n          _this.dispatchEvent(_startEvent);\n          var notchDeltaY = 125;\n          var sgn = event.deltaY / notchDeltaY;\n          var size = 1;\n          if (sgn > 0) {\n            size = 1 / _this.scaleFactor;\n          } else if (sgn < 0) {\n            size = _this.scaleFactor;\n          }\n          switch (mouseOp) {\n            case \"ZOOM\":\n              _this.updateTbState(STATE.SCALE, true);\n              if (sgn > 0) {\n                size = 1 / Math.pow(_this.scaleFactor, sgn);\n              } else if (sgn < 0) {\n                size = Math.pow(_this.scaleFactor, -sgn);\n              }\n              if (_this.cursorZoom && _this.enablePan) {\n                var scalePoint;\n                if (_this.camera instanceof OrthographicCamera) {\n                  scalePoint = (_a = _this.unprojectOnTbPlane(_this.camera, event.clientX, event.clientY, _this.domElement)) == null ? void 0 : _a.applyQuaternion(_this.camera.quaternion).multiplyScalar(1 / _this.camera.zoom).add(_this._gizmos.position);\n                }\n                if (_this.camera instanceof PerspectiveCamera) {\n                  scalePoint = (_b = _this.unprojectOnTbPlane(_this.camera, event.clientX, event.clientY, _this.domElement)) == null ? void 0 : _b.applyQuaternion(_this.camera.quaternion).add(_this._gizmos.position);\n                }\n                if (scalePoint !== void 0) _this.applyTransformMatrix(_this.applyScale(size, scalePoint));\n              } else {\n                _this.applyTransformMatrix(_this.applyScale(size, _this._gizmos.position));\n              }\n              if (_this._grid) {\n                _this.disposeGrid();\n                _this.drawGrid();\n              }\n              _this.updateTbState(STATE.IDLE, false);\n              _this.dispatchEvent(_changeEvent);\n              _this.dispatchEvent(_endEvent);\n              break;\n            case \"FOV\":\n              if (_this.camera instanceof PerspectiveCamera) {\n                _this.updateTbState(STATE.FOV, true);\n                if (event.deltaX != 0) {\n                  sgn = event.deltaX / notchDeltaY;\n                  size = 1;\n                  if (sgn > 0) {\n                    size = 1 / Math.pow(_this.scaleFactor, sgn);\n                  } else if (sgn < 0) {\n                    size = Math.pow(_this.scaleFactor, -sgn);\n                  }\n                }\n                _this._v3_1.setFromMatrixPosition(_this._cameraMatrixState);\n                var x = _this._v3_1.distanceTo(_this._gizmos.position);\n                var xNew = x / size;\n                xNew = MathUtils.clamp(xNew, _this.minDistance, _this.maxDistance);\n                var y = x * Math.tan(MathUtils.DEG2RAD * _this.camera.fov * 0.5);\n                var newFov = MathUtils.RAD2DEG * (Math.atan(y / xNew) * 2);\n                if (newFov > _this.maxFov) {\n                  newFov = _this.maxFov;\n                } else if (newFov < _this.minFov) {\n                  newFov = _this.minFov;\n                }\n                var newDistance = y / Math.tan(MathUtils.DEG2RAD * (newFov / 2));\n                size = x / newDistance;\n                _this.setFov(newFov);\n                _this.applyTransformMatrix(_this.applyScale(size, _this._gizmos.position, false));\n              }\n              if (_this._grid) {\n                _this.disposeGrid();\n                _this.drawGrid();\n              }\n              _this.updateTbState(STATE.IDLE, false);\n              _this.dispatchEvent(_changeEvent);\n              _this.dispatchEvent(_endEvent);\n              break;\n          }\n        }\n      }\n    });\n    __publicField(_assertThisInitialized(_this), \"onSinglePanStart\", function (event, operation) {\n      if (_this.enabled && _this.domElement) {\n        _this.dispatchEvent(_startEvent);\n        _this.setCenter(event.clientX, event.clientY);\n        switch (operation) {\n          case \"PAN\":\n            if (!_this.enablePan) return;\n            if (_this._animationId != -1) {\n              cancelAnimationFrame(_this._animationId);\n              _this._animationId = -1;\n              _this._timeStart = -1;\n              _this.activateGizmos(false);\n              _this.dispatchEvent(_changeEvent);\n            }\n            if (_this.camera) {\n              _this.updateTbState(STATE.PAN, true);\n              var rayDir = _this.unprojectOnTbPlane(_this.camera, _center.x, _center.y, _this.domElement);\n              if (rayDir !== void 0) {\n                _this._startCursorPosition.copy(rayDir);\n              }\n              if (_this.enableGrid) {\n                _this.drawGrid();\n                _this.dispatchEvent(_changeEvent);\n              }\n            }\n            break;\n          case \"ROTATE\":\n            if (!_this.enableRotate) return;\n            if (_this._animationId != -1) {\n              cancelAnimationFrame(_this._animationId);\n              _this._animationId = -1;\n              _this._timeStart = -1;\n            }\n            if (_this.camera) {\n              _this.updateTbState(STATE.ROTATE, true);\n              var _rayDir = _this.unprojectOnTbSurface(_this.camera, _center.x, _center.y, _this.domElement, _this._tbRadius);\n              if (_rayDir !== void 0) {\n                _this._startCursorPosition.copy(_rayDir);\n              }\n              _this.activateGizmos(true);\n              if (_this.enableAnimations) {\n                _this._timePrev = _this._timeCurrent = performance.now();\n                _this._angleCurrent = _this._anglePrev = 0;\n                _this._cursorPosPrev.copy(_this._startCursorPosition);\n                _this._cursorPosCurr.copy(_this._cursorPosPrev);\n                _this._wCurr = 0;\n                _this._wPrev = _this._wCurr;\n              }\n            }\n            _this.dispatchEvent(_changeEvent);\n            break;\n          case \"FOV\":\n            if (!_this.enableZoom) return;\n            if (_this.camera instanceof PerspectiveCamera) {\n              if (_this._animationId != -1) {\n                cancelAnimationFrame(_this._animationId);\n                _this._animationId = -1;\n                _this._timeStart = -1;\n                _this.activateGizmos(false);\n                _this.dispatchEvent(_changeEvent);\n              }\n              _this.updateTbState(STATE.FOV, true);\n              _this._startCursorPosition.setY(_this.getCursorNDC(_center.x, _center.y, _this.domElement).y * 0.5);\n              _this._currentCursorPosition.copy(_this._startCursorPosition);\n            }\n            break;\n          case \"ZOOM\":\n            if (!_this.enableZoom) return;\n            if (_this._animationId != -1) {\n              cancelAnimationFrame(_this._animationId);\n              _this._animationId = -1;\n              _this._timeStart = -1;\n              _this.activateGizmos(false);\n              _this.dispatchEvent(_changeEvent);\n            }\n            _this.updateTbState(STATE.SCALE, true);\n            _this._startCursorPosition.setY(_this.getCursorNDC(_center.x, _center.y, _this.domElement).y * 0.5);\n            _this._currentCursorPosition.copy(_this._startCursorPosition);\n            break;\n        }\n      }\n    });\n    __publicField(_assertThisInitialized(_this), \"onSinglePanMove\", function (event, opState) {\n      if (_this.enabled && _this.domElement) {\n        var restart = opState != _this._state;\n        _this.setCenter(event.clientX, event.clientY);\n        switch (opState) {\n          case STATE.PAN:\n            if (_this.enablePan && _this.camera) {\n              if (restart) {\n                _this.dispatchEvent(_endEvent);\n                _this.dispatchEvent(_startEvent);\n                _this.updateTbState(opState, true);\n                var rayDir = _this.unprojectOnTbPlane(_this.camera, _center.x, _center.y, _this.domElement);\n                if (rayDir !== void 0) {\n                  _this._startCursorPosition.copy(rayDir);\n                }\n                if (_this.enableGrid) {\n                  _this.drawGrid();\n                }\n                _this.activateGizmos(false);\n              } else {\n                var _rayDir2 = _this.unprojectOnTbPlane(_this.camera, _center.x, _center.y, _this.domElement);\n                if (_rayDir2 !== void 0) {\n                  _this._currentCursorPosition.copy(_rayDir2);\n                }\n                _this.applyTransformMatrix(_this.pan(_this._startCursorPosition, _this._currentCursorPosition));\n              }\n            }\n            break;\n          case STATE.ROTATE:\n            if (_this.enableRotate && _this.camera) {\n              if (restart) {\n                _this.dispatchEvent(_endEvent);\n                _this.dispatchEvent(_startEvent);\n                _this.updateTbState(opState, true);\n                var _rayDir3 = _this.unprojectOnTbSurface(_this.camera, _center.x, _center.y, _this.domElement, _this._tbRadius);\n                if (_rayDir3 !== void 0) {\n                  _this._startCursorPosition.copy(_rayDir3);\n                }\n                if (_this.enableGrid) {\n                  _this.disposeGrid();\n                }\n                _this.activateGizmos(true);\n              } else {\n                var _rayDir4 = _this.unprojectOnTbSurface(_this.camera, _center.x, _center.y, _this.domElement, _this._tbRadius);\n                if (_rayDir4 !== void 0) {\n                  _this._currentCursorPosition.copy(_rayDir4);\n                }\n                var distance = _this._startCursorPosition.distanceTo(_this._currentCursorPosition);\n                var angle = _this._startCursorPosition.angleTo(_this._currentCursorPosition);\n                var amount = Math.max(distance / _this._tbRadius, angle);\n                _this.applyTransformMatrix(_this.rotate(_this.calculateRotationAxis(_this._startCursorPosition, _this._currentCursorPosition), amount));\n                if (_this.enableAnimations) {\n                  _this._timePrev = _this._timeCurrent;\n                  _this._timeCurrent = performance.now();\n                  _this._anglePrev = _this._angleCurrent;\n                  _this._angleCurrent = amount;\n                  _this._cursorPosPrev.copy(_this._cursorPosCurr);\n                  _this._cursorPosCurr.copy(_this._currentCursorPosition);\n                  _this._wPrev = _this._wCurr;\n                  _this._wCurr = _this.calculateAngularSpeed(_this._anglePrev, _this._angleCurrent, _this._timePrev, _this._timeCurrent);\n                }\n              }\n            }\n            break;\n          case STATE.SCALE:\n            if (_this.enableZoom) {\n              if (restart) {\n                _this.dispatchEvent(_endEvent);\n                _this.dispatchEvent(_startEvent);\n                _this.updateTbState(opState, true);\n                _this._startCursorPosition.setY(_this.getCursorNDC(_center.x, _center.y, _this.domElement).y * 0.5);\n                _this._currentCursorPosition.copy(_this._startCursorPosition);\n                if (_this.enableGrid) {\n                  _this.disposeGrid();\n                }\n                _this.activateGizmos(false);\n              } else {\n                var screenNotches = 8;\n                _this._currentCursorPosition.setY(_this.getCursorNDC(_center.x, _center.y, _this.domElement).y * 0.5);\n                var movement = _this._currentCursorPosition.y - _this._startCursorPosition.y;\n                var size = 1;\n                if (movement < 0) {\n                  size = 1 / Math.pow(_this.scaleFactor, -movement * screenNotches);\n                } else if (movement > 0) {\n                  size = Math.pow(_this.scaleFactor, movement * screenNotches);\n                }\n                _this.applyTransformMatrix(_this.applyScale(size, _this._gizmos.position));\n              }\n            }\n            break;\n          case STATE.FOV:\n            if (_this.enableZoom && _this.camera instanceof PerspectiveCamera) {\n              if (restart) {\n                _this.dispatchEvent(_endEvent);\n                _this.dispatchEvent(_startEvent);\n                _this.updateTbState(opState, true);\n                _this._startCursorPosition.setY(_this.getCursorNDC(_center.x, _center.y, _this.domElement).y * 0.5);\n                _this._currentCursorPosition.copy(_this._startCursorPosition);\n                if (_this.enableGrid) {\n                  _this.disposeGrid();\n                }\n                _this.activateGizmos(false);\n              } else {\n                var _screenNotches = 8;\n                _this._currentCursorPosition.setY(_this.getCursorNDC(_center.x, _center.y, _this.domElement).y * 0.5);\n                var _movement2 = _this._currentCursorPosition.y - _this._startCursorPosition.y;\n                var _size = 1;\n                if (_movement2 < 0) {\n                  _size = 1 / Math.pow(_this.scaleFactor, -_movement2 * _screenNotches);\n                } else if (_movement2 > 0) {\n                  _size = Math.pow(_this.scaleFactor, _movement2 * _screenNotches);\n                }\n                _this._v3_1.setFromMatrixPosition(_this._cameraMatrixState);\n                var x = _this._v3_1.distanceTo(_this._gizmos.position);\n                var xNew = x / _size;\n                xNew = MathUtils.clamp(xNew, _this.minDistance, _this.maxDistance);\n                var y = x * Math.tan(MathUtils.DEG2RAD * _this._fovState * 0.5);\n                var newFov = MathUtils.RAD2DEG * (Math.atan(y / xNew) * 2);\n                newFov = MathUtils.clamp(newFov, _this.minFov, _this.maxFov);\n                var newDistance = y / Math.tan(MathUtils.DEG2RAD * (newFov / 2));\n                _size = x / newDistance;\n                _this._v3_2.setFromMatrixPosition(_this._gizmoMatrixState);\n                _this.setFov(newFov);\n                _this.applyTransformMatrix(_this.applyScale(_size, _this._v3_2, false));\n                var direction = _this._gizmos.position.clone().sub(_this.camera.position).normalize().multiplyScalar(newDistance / x);\n                _this._m4_1.makeTranslation(direction.x, direction.y, direction.z);\n              }\n            }\n            break;\n        }\n        _this.dispatchEvent(_changeEvent);\n      }\n    });\n    __publicField(_assertThisInitialized(_this), \"onSinglePanEnd\", function () {\n      if (_this._state == STATE.ROTATE) {\n        if (!_this.enableRotate) {\n          return;\n        }\n        if (_this.enableAnimations) {\n          var deltaTime = performance.now() - _this._timeCurrent;\n          if (deltaTime < 120) {\n            var w = Math.abs((_this._wPrev + _this._wCurr) / 2);\n            var self = _assertThisInitialized(_this);\n            _this._animationId = window.requestAnimationFrame(function (t) {\n              self.updateTbState(STATE.ANIMATION_ROTATE, true);\n              var rotationAxis = self.calculateRotationAxis(self._cursorPosPrev, self._cursorPosCurr);\n              self.onRotationAnim(t, rotationAxis, Math.min(w, self.wMax));\n            });\n          } else {\n            _this.updateTbState(STATE.IDLE, false);\n            _this.activateGizmos(false);\n            _this.dispatchEvent(_changeEvent);\n          }\n        } else {\n          _this.updateTbState(STATE.IDLE, false);\n          _this.activateGizmos(false);\n          _this.dispatchEvent(_changeEvent);\n        }\n      } else if (_this._state == STATE.PAN || _this._state == STATE.IDLE) {\n        _this.updateTbState(STATE.IDLE, false);\n        if (_this.enableGrid) {\n          _this.disposeGrid();\n        }\n        _this.activateGizmos(false);\n        _this.dispatchEvent(_changeEvent);\n      }\n      _this.dispatchEvent(_endEvent);\n    });\n    __publicField(_assertThisInitialized(_this), \"onDoubleTap\", function (event) {\n      if (_this.enabled && _this.enablePan && _this.scene && _this.camera && _this.domElement) {\n        _this.dispatchEvent(_startEvent);\n        _this.setCenter(event.clientX, event.clientY);\n        var hitP = _this.unprojectOnObj(_this.getCursorNDC(_center.x, _center.y, _this.domElement), _this.camera);\n        if (hitP && _this.enableAnimations) {\n          var self = _assertThisInitialized(_this);\n          if (_this._animationId != -1) {\n            window.cancelAnimationFrame(_this._animationId);\n          }\n          _this._timeStart = -1;\n          _this._animationId = window.requestAnimationFrame(function (t) {\n            self.updateTbState(STATE.ANIMATION_FOCUS, true);\n            self.onFocusAnim(t, hitP, self._cameraMatrixState, self._gizmoMatrixState);\n          });\n        } else if (hitP && !_this.enableAnimations) {\n          _this.updateTbState(STATE.FOCUS, true);\n          _this.focus(hitP, _this.scaleFactor);\n          _this.updateTbState(STATE.IDLE, false);\n          _this.dispatchEvent(_changeEvent);\n        }\n      }\n      _this.dispatchEvent(_endEvent);\n    });\n    __publicField(_assertThisInitialized(_this), \"onDoublePanStart\", function () {\n      if (_this.enabled && _this.enablePan && _this.camera && _this.domElement) {\n        _this.dispatchEvent(_startEvent);\n        _this.updateTbState(STATE.PAN, true);\n        _this.setCenter((_this._touchCurrent[0].clientX + _this._touchCurrent[1].clientX) / 2, (_this._touchCurrent[0].clientY + _this._touchCurrent[1].clientY) / 2);\n        var rayDir = _this.unprojectOnTbPlane(_this.camera, _center.x, _center.y, _this.domElement, true);\n        if (rayDir !== void 0) {\n          _this._startCursorPosition.copy(rayDir);\n        }\n        _this._currentCursorPosition.copy(_this._startCursorPosition);\n        _this.activateGizmos(false);\n      }\n    });\n    __publicField(_assertThisInitialized(_this), \"onDoublePanMove\", function () {\n      if (_this.enabled && _this.enablePan && _this.camera && _this.domElement) {\n        _this.setCenter((_this._touchCurrent[0].clientX + _this._touchCurrent[1].clientX) / 2, (_this._touchCurrent[0].clientY + _this._touchCurrent[1].clientY) / 2);\n        if (_this._state != STATE.PAN) {\n          _this.updateTbState(STATE.PAN, true);\n          _this._startCursorPosition.copy(_this._currentCursorPosition);\n        }\n        var rayDir = _this.unprojectOnTbPlane(_this.camera, _center.x, _center.y, _this.domElement, true);\n        if (rayDir !== void 0) _this._currentCursorPosition.copy(rayDir);\n        _this.applyTransformMatrix(_this.pan(_this._startCursorPosition, _this._currentCursorPosition, true));\n        _this.dispatchEvent(_changeEvent);\n      }\n    });\n    __publicField(_assertThisInitialized(_this), \"onDoublePanEnd\", function () {\n      _this.updateTbState(STATE.IDLE, false);\n      _this.dispatchEvent(_endEvent);\n    });\n    __publicField(_assertThisInitialized(_this), \"onRotateStart\", function () {\n      var _a;\n      if (_this.enabled && _this.enableRotate) {\n        _this.dispatchEvent(_startEvent);\n        _this.updateTbState(STATE.ZROTATE, true);\n        _this._startFingerRotation = _this.getAngle(_this._touchCurrent[1], _this._touchCurrent[0]) + _this.getAngle(_this._touchStart[1], _this._touchStart[0]);\n        _this._currentFingerRotation = _this._startFingerRotation;\n        (_a = _this.camera) == null ? void 0 : _a.getWorldDirection(_this._rotationAxis);\n        if (!_this.enablePan && !_this.enableZoom) {\n          _this.activateGizmos(true);\n        }\n      }\n    });\n    __publicField(_assertThisInitialized(_this), \"onRotateMove\", function () {\n      var _a;\n      if (_this.enabled && _this.enableRotate && _this.camera && _this.domElement) {\n        _this.setCenter((_this._touchCurrent[0].clientX + _this._touchCurrent[1].clientX) / 2, (_this._touchCurrent[0].clientY + _this._touchCurrent[1].clientY) / 2);\n        var rotationPoint;\n        if (_this._state != STATE.ZROTATE) {\n          _this.updateTbState(STATE.ZROTATE, true);\n          _this._startFingerRotation = _this._currentFingerRotation;\n        }\n        _this._currentFingerRotation = _this.getAngle(_this._touchCurrent[1], _this._touchCurrent[0]) + _this.getAngle(_this._touchStart[1], _this._touchStart[0]);\n        if (!_this.enablePan) {\n          rotationPoint = new Vector3().setFromMatrixPosition(_this._gizmoMatrixState);\n        } else if (_this.camera) {\n          _this._v3_2.setFromMatrixPosition(_this._gizmoMatrixState);\n          rotationPoint = (_a = _this.unprojectOnTbPlane(_this.camera, _center.x, _center.y, _this.domElement)) == null ? void 0 : _a.applyQuaternion(_this.camera.quaternion).multiplyScalar(1 / _this.camera.zoom).add(_this._v3_2);\n        }\n        var amount = MathUtils.DEG2RAD * (_this._startFingerRotation - _this._currentFingerRotation);\n        if (rotationPoint !== void 0) {\n          _this.applyTransformMatrix(_this.zRotate(rotationPoint, amount));\n        }\n        _this.dispatchEvent(_changeEvent);\n      }\n    });\n    __publicField(_assertThisInitialized(_this), \"onRotateEnd\", function () {\n      _this.updateTbState(STATE.IDLE, false);\n      _this.activateGizmos(false);\n      _this.dispatchEvent(_endEvent);\n    });\n    __publicField(_assertThisInitialized(_this), \"onPinchStart\", function () {\n      if (_this.enabled && _this.enableZoom) {\n        _this.dispatchEvent(_startEvent);\n        _this.updateTbState(STATE.SCALE, true);\n        _this._startFingerDistance = _this.calculatePointersDistance(_this._touchCurrent[0], _this._touchCurrent[1]);\n        _this._currentFingerDistance = _this._startFingerDistance;\n        _this.activateGizmos(false);\n      }\n    });\n    __publicField(_assertThisInitialized(_this), \"onPinchMove\", function () {\n      var _a, _b;\n      if (_this.enabled && _this.enableZoom && _this.domElement) {\n        _this.setCenter((_this._touchCurrent[0].clientX + _this._touchCurrent[1].clientX) / 2, (_this._touchCurrent[0].clientY + _this._touchCurrent[1].clientY) / 2);\n        var minDistance = 12;\n        if (_this._state != STATE.SCALE) {\n          _this._startFingerDistance = _this._currentFingerDistance;\n          _this.updateTbState(STATE.SCALE, true);\n        }\n        _this._currentFingerDistance = Math.max(_this.calculatePointersDistance(_this._touchCurrent[0], _this._touchCurrent[1]), minDistance * _this._devPxRatio);\n        var amount = _this._currentFingerDistance / _this._startFingerDistance;\n        var scalePoint;\n        if (!_this.enablePan) {\n          scalePoint = _this._gizmos.position;\n        } else {\n          if (_this.camera instanceof OrthographicCamera) {\n            scalePoint = (_a = _this.unprojectOnTbPlane(_this.camera, _center.x, _center.y, _this.domElement)) == null ? void 0 : _a.applyQuaternion(_this.camera.quaternion).multiplyScalar(1 / _this.camera.zoom).add(_this._gizmos.position);\n          } else if (_this.camera instanceof PerspectiveCamera) {\n            scalePoint = (_b = _this.unprojectOnTbPlane(_this.camera, _center.x, _center.y, _this.domElement)) == null ? void 0 : _b.applyQuaternion(_this.camera.quaternion).add(_this._gizmos.position);\n          }\n        }\n        if (scalePoint !== void 0) {\n          _this.applyTransformMatrix(_this.applyScale(amount, scalePoint));\n        }\n        _this.dispatchEvent(_changeEvent);\n      }\n    });\n    __publicField(_assertThisInitialized(_this), \"onPinchEnd\", function () {\n      _this.updateTbState(STATE.IDLE, false);\n      _this.dispatchEvent(_endEvent);\n    });\n    __publicField(_assertThisInitialized(_this), \"onTriplePanStart\", function () {\n      if (_this.enabled && _this.enableZoom && _this.domElement) {\n        _this.dispatchEvent(_startEvent);\n        _this.updateTbState(STATE.SCALE, true);\n        var clientX = 0;\n        var clientY = 0;\n        var nFingers = _this._touchCurrent.length;\n        for (var i = 0; i < nFingers; i++) {\n          clientX += _this._touchCurrent[i].clientX;\n          clientY += _this._touchCurrent[i].clientY;\n        }\n        _this.setCenter(clientX / nFingers, clientY / nFingers);\n        _this._startCursorPosition.setY(_this.getCursorNDC(_center.x, _center.y, _this.domElement).y * 0.5);\n        _this._currentCursorPosition.copy(_this._startCursorPosition);\n      }\n    });\n    __publicField(_assertThisInitialized(_this), \"onTriplePanMove\", function () {\n      if (_this.enabled && _this.enableZoom && _this.camera && _this.domElement) {\n        var clientX = 0;\n        var clientY = 0;\n        var nFingers = _this._touchCurrent.length;\n        for (var i = 0; i < nFingers; i++) {\n          clientX += _this._touchCurrent[i].clientX;\n          clientY += _this._touchCurrent[i].clientY;\n        }\n        _this.setCenter(clientX / nFingers, clientY / nFingers);\n        var screenNotches = 8;\n        _this._currentCursorPosition.setY(_this.getCursorNDC(_center.x, _center.y, _this.domElement).y * 0.5);\n        var movement = _this._currentCursorPosition.y - _this._startCursorPosition.y;\n        var size = 1;\n        if (movement < 0) {\n          size = 1 / Math.pow(_this.scaleFactor, -movement * screenNotches);\n        } else if (movement > 0) {\n          size = Math.pow(_this.scaleFactor, movement * screenNotches);\n        }\n        _this._v3_1.setFromMatrixPosition(_this._cameraMatrixState);\n        var x = _this._v3_1.distanceTo(_this._gizmos.position);\n        var xNew = x / size;\n        xNew = MathUtils.clamp(xNew, _this.minDistance, _this.maxDistance);\n        var y = x * Math.tan(MathUtils.DEG2RAD * _this._fovState * 0.5);\n        var newFov = MathUtils.RAD2DEG * (Math.atan(y / xNew) * 2);\n        newFov = MathUtils.clamp(newFov, _this.minFov, _this.maxFov);\n        var newDistance = y / Math.tan(MathUtils.DEG2RAD * (newFov / 2));\n        size = x / newDistance;\n        _this._v3_2.setFromMatrixPosition(_this._gizmoMatrixState);\n        _this.setFov(newFov);\n        _this.applyTransformMatrix(_this.applyScale(size, _this._v3_2, false));\n        var direction = _this._gizmos.position.clone().sub(_this.camera.position).normalize().multiplyScalar(newDistance / x);\n        _this._m4_1.makeTranslation(direction.x, direction.y, direction.z);\n        _this.dispatchEvent(_changeEvent);\n      }\n    });\n    __publicField(_assertThisInitialized(_this), \"onTriplePanEnd\", function () {\n      _this.updateTbState(STATE.IDLE, false);\n      _this.dispatchEvent(_endEvent);\n    });\n    /**\n     * Set _center's x/y coordinates\n     * @param {Number} clientX\n     * @param {Number} clientY\n     */\n    __publicField(_assertThisInitialized(_this), \"setCenter\", function (clientX, clientY) {\n      _center.x = clientX;\n      _center.y = clientY;\n    });\n    /**\n     * Set default mouse actions\n     */\n    __publicField(_assertThisInitialized(_this), \"initializeMouseActions\", function () {\n      _this.setMouseAction(\"PAN\", 0, \"CTRL\");\n      _this.setMouseAction(\"PAN\", 2);\n      _this.setMouseAction(\"ROTATE\", 0);\n      _this.setMouseAction(\"ZOOM\", \"WHEEL\");\n      _this.setMouseAction(\"ZOOM\", 1);\n      _this.setMouseAction(\"FOV\", \"WHEEL\", \"SHIFT\");\n      _this.setMouseAction(\"FOV\", 1, \"SHIFT\");\n    });\n    /**\n     * Set a new mouse action by specifying the operation to be performed and a mouse/key combination. In case of conflict, replaces the existing one\n     * @param {String} operation The operation to be performed ('PAN', 'ROTATE', 'ZOOM', 'FOV)\n     * @param {*} mouse A mouse button (0, 1, 2) or 'WHEEL' for wheel notches\n     * @param {*} key The keyboard modifier ('CTRL', 'SHIFT') or null if key is not needed\n     * @returns {Boolean} True if the mouse action has been successfully added, false otherwise\n     */\n    __publicField(_assertThisInitialized(_this), \"setMouseAction\", function (operation, mouse) {\n      var key = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n      var operationInput = [\"PAN\", \"ROTATE\", \"ZOOM\", \"FOV\"];\n      var mouseInput = [0, 1, 2, \"WHEEL\"];\n      var keyInput = [\"CTRL\", \"SHIFT\", null];\n      var state;\n      if (!operationInput.includes(operation) || !mouseInput.includes(mouse) || !keyInput.includes(key)) {\n        return false;\n      }\n      if (mouse == \"WHEEL\") {\n        if (operation != \"ZOOM\" && operation != \"FOV\") {\n          return false;\n        }\n      }\n      switch (operation) {\n        case \"PAN\":\n          state = STATE.PAN;\n          break;\n        case \"ROTATE\":\n          state = STATE.ROTATE;\n          break;\n        case \"ZOOM\":\n          state = STATE.SCALE;\n          break;\n        case \"FOV\":\n          state = STATE.FOV;\n          break;\n      }\n      var action = {\n        operation: operation,\n        mouse: mouse,\n        key: key,\n        state: state\n      };\n      for (var i = 0; i < _this.mouseActions.length; i++) {\n        if (_this.mouseActions[i].mouse == action.mouse && _this.mouseActions[i].key == action.key) {\n          _this.mouseActions.splice(i, 1, action);\n          return true;\n        }\n      }\n      _this.mouseActions.push(action);\n      return true;\n    });\n    /**\n     * Return the operation associated to a mouse/keyboard combination\n     * @param {*} mouse A mouse button (0, 1, 2) or 'WHEEL' for wheel notches\n     * @param {*} key The keyboard modifier ('CTRL', 'SHIFT') or null if key is not needed\n     * @returns The operation if it has been found, null otherwise\n     */\n    __publicField(_assertThisInitialized(_this), \"getOpFromAction\", function (mouse, key) {\n      var action;\n      for (var i = 0; i < _this.mouseActions.length; i++) {\n        action = _this.mouseActions[i];\n        if (action.mouse == mouse && action.key == key) {\n          return action.operation;\n        }\n      }\n      if (key) {\n        for (var _i = 0; _i < _this.mouseActions.length; _i++) {\n          action = _this.mouseActions[_i];\n          if (action.mouse == mouse && action.key == null) {\n            return action.operation;\n          }\n        }\n      }\n      return null;\n    });\n    /**\n     * Get the operation associated to mouse and key combination and returns the corresponding FSA state\n     * @param {Number} mouse Mouse button\n     * @param {String} key Keyboard modifier\n     * @returns The FSA state obtained from the operation associated to mouse/keyboard combination\n     */\n    __publicField(_assertThisInitialized(_this), \"getOpStateFromAction\", function (mouse, key) {\n      var action;\n      for (var i = 0; i < _this.mouseActions.length; i++) {\n        action = _this.mouseActions[i];\n        if (action.mouse == mouse && action.key == key) {\n          return action.state;\n        }\n      }\n      if (key) {\n        for (var _i2 = 0; _i2 < _this.mouseActions.length; _i2++) {\n          action = _this.mouseActions[_i2];\n          if (action.mouse == mouse && action.key == null) {\n            return action.state;\n          }\n        }\n      }\n      return null;\n    });\n    /**\n     * Calculate the angle between two pointers\n     * @param {PointerEvent} p1\n     * @param {PointerEvent} p2\n     * @returns {Number} The angle between two pointers in degrees\n     */\n    __publicField(_assertThisInitialized(_this), \"getAngle\", function (p1, p2) {\n      return Math.atan2(p2.clientY - p1.clientY, p2.clientX - p1.clientX) * 180 / Math.PI;\n    });\n    /**\n     * Update a PointerEvent inside current pointerevents array\n     * @param {PointerEvent} event\n     */\n    __publicField(_assertThisInitialized(_this), \"updateTouchEvent\", function (event) {\n      for (var i = 0; i < _this._touchCurrent.length; i++) {\n        if (_this._touchCurrent[i].pointerId == event.pointerId) {\n          _this._touchCurrent.splice(i, 1, event);\n          break;\n        }\n      }\n    });\n    /**\n     * Calculate the angular speed\n     * @param {Number} p0 Position at t0\n     * @param {Number} p1 Position at t1\n     * @param {Number} t0 Initial time in milliseconds\n     * @param {Number} t1 Ending time in milliseconds\n     */\n    __publicField(_assertThisInitialized(_this), \"calculateAngularSpeed\", function (p0, p1, t0, t1) {\n      var s = p1 - p0;\n      var t = (t1 - t0) / 1e3;\n      if (t == 0) {\n        return 0;\n      }\n      return s / t;\n    });\n    /**\n     * Calculate the distance between two pointers\n     * @param {PointerEvent} p0 The first pointer\n     * @param {PointerEvent} p1 The second pointer\n     * @returns {number} The distance between the two pointers\n     */\n    __publicField(_assertThisInitialized(_this), \"calculatePointersDistance\", function (p0, p1) {\n      return Math.sqrt(Math.pow(p1.clientX - p0.clientX, 2) + Math.pow(p1.clientY - p0.clientY, 2));\n    });\n    /**\n     * Calculate the rotation axis as the vector perpendicular between two vectors\n     * @param {Vector3} vec1 The first vector\n     * @param {Vector3} vec2 The second vector\n     * @returns {Vector3} The normalized rotation axis\n     */\n    __publicField(_assertThisInitialized(_this), \"calculateRotationAxis\", function (vec1, vec2) {\n      _this._rotationMatrix.extractRotation(_this._cameraMatrixState);\n      _this._quat.setFromRotationMatrix(_this._rotationMatrix);\n      _this._rotationAxis.crossVectors(vec1, vec2).applyQuaternion(_this._quat);\n      return _this._rotationAxis.normalize().clone();\n    });\n    /**\n     * Calculate the trackball radius so that gizmo's diamater will be 2/3 of the minimum side of the camera frustum\n     * @param {Camera} camera\n     * @returns {Number} The trackball radius\n     */\n    __publicField(_assertThisInitialized(_this), \"calculateTbRadius\", function (camera) {\n      var factor = 0.67;\n      var distance = camera.position.distanceTo(_this._gizmos.position);\n      if (camera instanceof PerspectiveCamera) {\n        var halfFovV = MathUtils.DEG2RAD * camera.fov * 0.5;\n        var halfFovH = Math.atan(camera.aspect * Math.tan(halfFovV));\n        return Math.tan(Math.min(halfFovV, halfFovH)) * distance * factor;\n      } else if (camera instanceof OrthographicCamera) {\n        return Math.min(camera.top, camera.right) * factor;\n      }\n    });\n    /**\n     * Focus operation consist of positioning the point of interest in front of the camera and a slightly zoom in\n     * @param {Vector3} point The point of interest\n     * @param {Number} size Scale factor\n     * @param {Number} amount Amount of operation to be completed (used for focus animations, default is complete full operation)\n     */\n    __publicField(_assertThisInitialized(_this), \"focus\", function (point, size) {\n      var amount = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n      if (_this.camera) {\n        var focusPoint = point.clone();\n        focusPoint.sub(_this._gizmos.position).multiplyScalar(amount);\n        _this._translationMatrix.makeTranslation(focusPoint.x, focusPoint.y, focusPoint.z);\n        var gizmoStateTemp = _this._gizmoMatrixState.clone();\n        _this._gizmoMatrixState.premultiply(_this._translationMatrix);\n        _this._gizmoMatrixState.decompose(_this._gizmos.position, _this._gizmos.quaternion, _this._gizmos.scale);\n        var cameraStateTemp = _this._cameraMatrixState.clone();\n        _this._cameraMatrixState.premultiply(_this._translationMatrix);\n        _this._cameraMatrixState.decompose(_this.camera.position, _this.camera.quaternion, _this.camera.scale);\n        if (_this.enableZoom) {\n          _this.applyTransformMatrix(_this.applyScale(size, _this._gizmos.position));\n        }\n        _this._gizmoMatrixState.copy(gizmoStateTemp);\n        _this._cameraMatrixState.copy(cameraStateTemp);\n      }\n    });\n    /**\n     * Draw a grid and add it to the scene\n     */\n    __publicField(_assertThisInitialized(_this), \"drawGrid\", function () {\n      if (_this.scene) {\n        var color = 8947848;\n        var multiplier = 3;\n        var size, divisions, maxLength, tick;\n        if (_this.camera instanceof OrthographicCamera) {\n          var width = _this.camera.right - _this.camera.left;\n          var height = _this.camera.bottom - _this.camera.top;\n          maxLength = Math.max(width, height);\n          tick = maxLength / 20;\n          size = maxLength / _this.camera.zoom * multiplier;\n          divisions = size / tick * _this.camera.zoom;\n        } else if (_this.camera instanceof PerspectiveCamera) {\n          var distance = _this.camera.position.distanceTo(_this._gizmos.position);\n          var halfFovV = MathUtils.DEG2RAD * _this.camera.fov * 0.5;\n          var halfFovH = Math.atan(_this.camera.aspect * Math.tan(halfFovV));\n          maxLength = Math.tan(Math.max(halfFovV, halfFovH)) * distance * 2;\n          tick = maxLength / 20;\n          size = maxLength * multiplier;\n          divisions = size / tick;\n        }\n        if (_this._grid == null && _this.camera) {\n          _this._grid = new GridHelper(size, divisions, color, color);\n          _this._grid.position.copy(_this._gizmos.position);\n          _this._gridPosition.copy(_this._grid.position);\n          _this._grid.quaternion.copy(_this.camera.quaternion);\n          _this._grid.rotateX(Math.PI * 0.5);\n          _this.scene.add(_this._grid);\n        }\n      }\n    });\n    __publicField(_assertThisInitialized(_this), \"connect\", function (domElement) {\n      if (domElement === document) {\n        console.error('THREE.ArcballControls: \"document\" should not be used as the target \"domElement\". Please use \"renderer.domElement\" instead.');\n      }\n      _this.domElement = domElement;\n      _this.domElement.style.touchAction = \"none\";\n      _this.domElement.addEventListener(\"contextmenu\", _this.onContextMenu);\n      _this.domElement.addEventListener(\"pointerdown\", _this.onPointerDown);\n      _this.domElement.addEventListener(\"pointercancel\", _this.onPointerCancel);\n      _this.domElement.addEventListener(\"wheel\", _this.onWheel);\n    });\n    /**\n     * Remove all listeners, stop animations and clean scene\n     */\n    __publicField(_assertThisInitialized(_this), \"dispose\", function () {\n      var _a, _b, _c, _d, _e;\n      if (_this._animationId != -1) {\n        window.cancelAnimationFrame(_this._animationId);\n      }\n      (_a = _this.domElement) == null ? void 0 : _a.removeEventListener(\"pointerdown\", _this.onPointerDown);\n      (_b = _this.domElement) == null ? void 0 : _b.removeEventListener(\"pointercancel\", _this.onPointerCancel);\n      (_c = _this.domElement) == null ? void 0 : _c.removeEventListener(\"wheel\", _this.onWheel);\n      (_d = _this.domElement) == null ? void 0 : _d.removeEventListener(\"contextmenu\", _this.onContextMenu);\n      window.removeEventListener(\"pointermove\", _this.onPointerMove);\n      window.removeEventListener(\"pointerup\", _this.onPointerUp);\n      window.removeEventListener(\"resize\", _this.onWindowResize);\n      (_e = _this.scene) == null ? void 0 : _e.remove(_this._gizmos);\n      _this.disposeGrid();\n    });\n    /**\n     * remove the grid from the scene\n     */\n    __publicField(_assertThisInitialized(_this), \"disposeGrid\", function () {\n      if (_this._grid && _this.scene) {\n        _this.scene.remove(_this._grid);\n        _this._grid = null;\n      }\n    });\n    /**\n     * Compute the easing out cubic function for ease out effect in animation\n     * @param {Number} t The absolute progress of the animation in the bound of 0 (beginning of the) and 1 (ending of animation)\n     * @returns {Number} Result of easing out cubic at time t\n     */\n    __publicField(_assertThisInitialized(_this), \"easeOutCubic\", function (t) {\n      return 1 - Math.pow(1 - t, 3);\n    });\n    /**\n     * Make rotation gizmos more or less visible\n     * @param {Boolean} isActive If true, make gizmos more visible\n     */\n    __publicField(_assertThisInitialized(_this), \"activateGizmos\", function (isActive) {\n      var _iterator = _createForOfIteratorHelper(_this._gizmos.children),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var gizmo = _step.value;\n          gizmo.material.setValues({\n            opacity: isActive ? 1 : 0.6\n          });\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    });\n    /**\n     * Calculate the cursor position in NDC\n     * @param {number} x Cursor horizontal coordinate within the canvas\n     * @param {number} y Cursor vertical coordinate within the canvas\n     * @param {HTMLElement} canvas The canvas where the renderer draws its output\n     * @returns {Vector2} Cursor normalized position inside the canvas\n     */\n    __publicField(_assertThisInitialized(_this), \"getCursorNDC\", function (cursorX, cursorY, canvas) {\n      var canvasRect = canvas.getBoundingClientRect();\n      _this._v2_1.setX((cursorX - canvasRect.left) / canvasRect.width * 2 - 1);\n      _this._v2_1.setY((canvasRect.bottom - cursorY) / canvasRect.height * 2 - 1);\n      return _this._v2_1.clone();\n    });\n    /**\n     * Calculate the cursor position inside the canvas x/y coordinates with the origin being in the center of the canvas\n     * @param {Number} x Cursor horizontal coordinate within the canvas\n     * @param {Number} y Cursor vertical coordinate within the canvas\n     * @param {HTMLElement} canvas The canvas where the renderer draws its output\n     * @returns {Vector2} Cursor position inside the canvas\n     */\n    __publicField(_assertThisInitialized(_this), \"getCursorPosition\", function (cursorX, cursorY, canvas) {\n      _this._v2_1.copy(_this.getCursorNDC(cursorX, cursorY, canvas));\n      if (_this.camera instanceof OrthographicCamera) {\n        _this._v2_1.x *= (_this.camera.right - _this.camera.left) * 0.5;\n        _this._v2_1.y *= (_this.camera.top - _this.camera.bottom) * 0.5;\n      }\n      return _this._v2_1.clone();\n    });\n    /**\n     * Set the camera to be controlled\n     * @param {Camera} camera The virtual camera to be controlled\n     */\n    __publicField(_assertThisInitialized(_this), \"setCamera\", function (camera) {\n      if (camera) {\n        camera.lookAt(_this.target);\n        camera.updateMatrix();\n        if (camera instanceof PerspectiveCamera) {\n          _this._fov0 = camera.fov;\n          _this._fovState = camera.fov;\n        }\n        _this._cameraMatrixState0.copy(camera.matrix);\n        _this._cameraMatrixState.copy(_this._cameraMatrixState0);\n        _this._cameraProjectionState.copy(camera.projectionMatrix);\n        _this._zoom0 = camera.zoom;\n        _this._zoomState = _this._zoom0;\n        _this._initialNear = camera.near;\n        _this._nearPos0 = camera.position.distanceTo(_this.target) - camera.near;\n        _this._nearPos = _this._initialNear;\n        _this._initialFar = camera.far;\n        _this._farPos0 = camera.position.distanceTo(_this.target) - camera.far;\n        _this._farPos = _this._initialFar;\n        _this._up0.copy(camera.up);\n        _this._upState.copy(camera.up);\n        _this.camera = camera;\n        _this.camera.updateProjectionMatrix();\n        var tbRadius = _this.calculateTbRadius(camera);\n        if (tbRadius !== void 0) {\n          _this._tbRadius = tbRadius;\n        }\n        _this.makeGizmos(_this.target, _this._tbRadius);\n      }\n    });\n    /**\n     * Creates the rotation gizmos matching trackball center and radius\n     * @param {Vector3} tbCenter The trackball center\n     * @param {number} tbRadius The trackball radius\n     */\n    __publicField(_assertThisInitialized(_this), \"makeGizmos\", function (tbCenter, tbRadius) {\n      var curve = new EllipseCurve(0, 0, tbRadius, tbRadius);\n      var points = curve.getPoints(_this._curvePts);\n      var curveGeometry = new BufferGeometry().setFromPoints(points);\n      var curveMaterialX = new LineBasicMaterial({\n        color: 16744576,\n        fog: false,\n        transparent: true,\n        opacity: 0.6\n      });\n      var curveMaterialY = new LineBasicMaterial({\n        color: 8454016,\n        fog: false,\n        transparent: true,\n        opacity: 0.6\n      });\n      var curveMaterialZ = new LineBasicMaterial({\n        color: 8421631,\n        fog: false,\n        transparent: true,\n        opacity: 0.6\n      });\n      var gizmoX = new Line(curveGeometry, curveMaterialX);\n      var gizmoY = new Line(curveGeometry, curveMaterialY);\n      var gizmoZ = new Line(curveGeometry, curveMaterialZ);\n      var rotation = Math.PI * 0.5;\n      gizmoX.rotation.x = rotation;\n      gizmoY.rotation.y = rotation;\n      _this._gizmoMatrixState0.identity().setPosition(tbCenter);\n      _this._gizmoMatrixState.copy(_this._gizmoMatrixState0);\n      if (_this.camera && _this.camera.zoom != 1) {\n        var size = 1 / _this.camera.zoom;\n        _this._scaleMatrix.makeScale(size, size, size);\n        _this._translationMatrix.makeTranslation(-tbCenter.x, -tbCenter.y, -tbCenter.z);\n        _this._gizmoMatrixState.premultiply(_this._translationMatrix).premultiply(_this._scaleMatrix);\n        _this._translationMatrix.makeTranslation(tbCenter.x, tbCenter.y, tbCenter.z);\n        _this._gizmoMatrixState.premultiply(_this._translationMatrix);\n      }\n      _this._gizmoMatrixState.decompose(_this._gizmos.position, _this._gizmos.quaternion, _this._gizmos.scale);\n      _this._gizmos.clear();\n      _this._gizmos.add(gizmoX);\n      _this._gizmos.add(gizmoY);\n      _this._gizmos.add(gizmoZ);\n    });\n    /**\n     * Perform animation for focus operation\n     * @param {Number} time Instant in which this function is called as performance.now()\n     * @param {Vector3} point Point of interest for focus operation\n     * @param {Matrix4} cameraMatrix Camera matrix\n     * @param {Matrix4} gizmoMatrix Gizmos matrix\n     */\n    __publicField(_assertThisInitialized(_this), \"onFocusAnim\", function (time, point, cameraMatrix, gizmoMatrix) {\n      if (_this._timeStart == -1) {\n        _this._timeStart = time;\n      }\n      if (_this._state == STATE.ANIMATION_FOCUS) {\n        var deltaTime = time - _this._timeStart;\n        var animTime = deltaTime / _this.focusAnimationTime;\n        _this._gizmoMatrixState.copy(gizmoMatrix);\n        if (animTime >= 1) {\n          _this._gizmoMatrixState.decompose(_this._gizmos.position, _this._gizmos.quaternion, _this._gizmos.scale);\n          _this.focus(point, _this.scaleFactor);\n          _this._timeStart = -1;\n          _this.updateTbState(STATE.IDLE, false);\n          _this.activateGizmos(false);\n          _this.dispatchEvent(_changeEvent);\n        } else {\n          var amount = _this.easeOutCubic(animTime);\n          var size = 1 - amount + _this.scaleFactor * amount;\n          _this._gizmoMatrixState.decompose(_this._gizmos.position, _this._gizmos.quaternion, _this._gizmos.scale);\n          _this.focus(point, size, amount);\n          _this.dispatchEvent(_changeEvent);\n          var self = _assertThisInitialized(_this);\n          _this._animationId = window.requestAnimationFrame(function (t) {\n            self.onFocusAnim(t, point, cameraMatrix, gizmoMatrix.clone());\n          });\n        }\n      } else {\n        _this._animationId = -1;\n        _this._timeStart = -1;\n      }\n    });\n    /**\n     * Perform animation for rotation operation\n     * @param {Number} time Instant in which this function is called as performance.now()\n     * @param {Vector3} rotationAxis Rotation axis\n     * @param {number} w0 Initial angular velocity\n     */\n    __publicField(_assertThisInitialized(_this), \"onRotationAnim\", function (time, rotationAxis, w0) {\n      if (_this._timeStart == -1) {\n        _this._anglePrev = 0;\n        _this._angleCurrent = 0;\n        _this._timeStart = time;\n      }\n      if (_this._state == STATE.ANIMATION_ROTATE) {\n        var deltaTime = (time - _this._timeStart) / 1e3;\n        var w = w0 + -_this.dampingFactor * deltaTime;\n        if (w > 0) {\n          _this._angleCurrent = 0.5 * -_this.dampingFactor * Math.pow(deltaTime, 2) + w0 * deltaTime + 0;\n          _this.applyTransformMatrix(_this.rotate(rotationAxis, _this._angleCurrent));\n          _this.dispatchEvent(_changeEvent);\n          var self = _assertThisInitialized(_this);\n          _this._animationId = window.requestAnimationFrame(function (t) {\n            self.onRotationAnim(t, rotationAxis, w0);\n          });\n        } else {\n          _this._animationId = -1;\n          _this._timeStart = -1;\n          _this.updateTbState(STATE.IDLE, false);\n          _this.activateGizmos(false);\n          _this.dispatchEvent(_changeEvent);\n        }\n      } else {\n        _this._animationId = -1;\n        _this._timeStart = -1;\n        if (_this._state != STATE.ROTATE) {\n          _this.activateGizmos(false);\n          _this.dispatchEvent(_changeEvent);\n        }\n      }\n    });\n    /**\n     * Perform pan operation moving camera between two points\n     * @param {Vector3} p0 Initial point\n     * @param {Vector3} p1 Ending point\n     * @param {Boolean} adjust If movement should be adjusted considering camera distance (Perspective only)\n     */\n    __publicField(_assertThisInitialized(_this), \"pan\", function (p0, p1) {\n      var adjust = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      if (_this.camera) {\n        var movement = p0.clone().sub(p1);\n        if (_this.camera instanceof OrthographicCamera) {\n          movement.multiplyScalar(1 / _this.camera.zoom);\n        }\n        if (_this.camera instanceof PerspectiveCamera && adjust) {\n          _this._v3_1.setFromMatrixPosition(_this._cameraMatrixState0);\n          _this._v3_2.setFromMatrixPosition(_this._gizmoMatrixState0);\n          var distanceFactor = _this._v3_1.distanceTo(_this._v3_2) / _this.camera.position.distanceTo(_this._gizmos.position);\n          movement.multiplyScalar(1 / distanceFactor);\n        }\n        _this._v3_1.set(movement.x, movement.y, 0).applyQuaternion(_this.camera.quaternion);\n        _this._m4_1.makeTranslation(_this._v3_1.x, _this._v3_1.y, _this._v3_1.z);\n        _this.setTransformationMatrices(_this._m4_1, _this._m4_1);\n      }\n      return _transformation;\n    });\n    /**\n     * Reset trackball\n     */\n    __publicField(_assertThisInitialized(_this), \"reset\", function () {\n      if (_this.camera) {\n        _this.camera.zoom = _this._zoom0;\n        if (_this.camera instanceof PerspectiveCamera) {\n          _this.camera.fov = _this._fov0;\n        }\n        _this.camera.near = _this._nearPos;\n        _this.camera.far = _this._farPos;\n        _this._cameraMatrixState.copy(_this._cameraMatrixState0);\n        _this._cameraMatrixState.decompose(_this.camera.position, _this.camera.quaternion, _this.camera.scale);\n        _this.camera.up.copy(_this._up0);\n        _this.camera.updateMatrix();\n        _this.camera.updateProjectionMatrix();\n        _this._gizmoMatrixState.copy(_this._gizmoMatrixState0);\n        _this._gizmoMatrixState0.decompose(_this._gizmos.position, _this._gizmos.quaternion, _this._gizmos.scale);\n        _this._gizmos.updateMatrix();\n        var tbRadius = _this.calculateTbRadius(_this.camera);\n        if (tbRadius !== void 0) {\n          _this._tbRadius = tbRadius;\n        }\n        _this.makeGizmos(_this._gizmos.position, _this._tbRadius);\n        _this.camera.lookAt(_this._gizmos.position);\n        _this.updateTbState(STATE.IDLE, false);\n        _this.dispatchEvent(_changeEvent);\n      }\n    });\n    /**\n     * Rotate the camera around an axis passing by trackball's center\n     * @param {Vector3} axis Rotation axis\n     * @param {number} angle Angle in radians\n     * @returns {Object} Object with 'camera' field containing transformation matrix resulting from the operation to be applied to the camera\n     */\n    __publicField(_assertThisInitialized(_this), \"rotate\", function (axis, angle) {\n      var point = _this._gizmos.position;\n      _this._translationMatrix.makeTranslation(-point.x, -point.y, -point.z);\n      _this._rotationMatrix.makeRotationAxis(axis, -angle);\n      _this._m4_1.makeTranslation(point.x, point.y, point.z);\n      _this._m4_1.multiply(_this._rotationMatrix);\n      _this._m4_1.multiply(_this._translationMatrix);\n      _this.setTransformationMatrices(_this._m4_1);\n      return _transformation;\n    });\n    __publicField(_assertThisInitialized(_this), \"copyState\", function () {\n      if (_this.camera) {\n        var state = JSON.stringify(_this.camera instanceof OrthographicCamera ? {\n          arcballState: {\n            cameraFar: _this.camera.far,\n            cameraMatrix: _this.camera.matrix,\n            cameraNear: _this.camera.near,\n            cameraUp: _this.camera.up,\n            cameraZoom: _this.camera.zoom,\n            gizmoMatrix: _this._gizmos.matrix\n          }\n        } : {\n          arcballState: {\n            cameraFar: _this.camera.far,\n            cameraFov: _this.camera.fov,\n            cameraMatrix: _this.camera.matrix,\n            cameraNear: _this.camera.near,\n            cameraUp: _this.camera.up,\n            cameraZoom: _this.camera.zoom,\n            gizmoMatrix: _this._gizmos.matrix\n          }\n        });\n        navigator.clipboard.writeText(state);\n      }\n    });\n    __publicField(_assertThisInitialized(_this), \"pasteState\", function () {\n      var self = _assertThisInitialized(_this);\n      navigator.clipboard.readText().then(function resolved(value) {\n        self.setStateFromJSON(value);\n      });\n    });\n    /**\n     * Save the current state of the control. This can later be recovered with .reset\n     */\n    __publicField(_assertThisInitialized(_this), \"saveState\", function () {\n      if (!_this.camera) return;\n      _this._cameraMatrixState0.copy(_this.camera.matrix);\n      _this._gizmoMatrixState0.copy(_this._gizmos.matrix);\n      _this._nearPos = _this.camera.near;\n      _this._farPos = _this.camera.far;\n      _this._zoom0 = _this.camera.zoom;\n      _this._up0.copy(_this.camera.up);\n      if (_this.camera instanceof PerspectiveCamera) {\n        _this._fov0 = _this.camera.fov;\n      }\n    });\n    /**\n     * Perform uniform scale operation around a given point\n     * @param {Number} size Scale factor\n     * @param {Vector3} point Point around which scale\n     * @param {Boolean} scaleGizmos If gizmos should be scaled (Perspective only)\n     * @returns {Object} Object with 'camera' and 'gizmo' fields containing transformation matrices resulting from the operation to be applied to the camera and gizmos\n     */\n    __publicField(_assertThisInitialized(_this), \"applyScale\", function (size, point) {\n      var scaleGizmos = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n      if (!_this.camera) return;\n      var scalePoint = point.clone();\n      var sizeInverse = 1 / size;\n      if (_this.camera instanceof OrthographicCamera) {\n        _this.camera.zoom = _this._zoomState;\n        _this.camera.zoom *= size;\n        if (_this.camera.zoom > _this.maxZoom) {\n          _this.camera.zoom = _this.maxZoom;\n          sizeInverse = _this._zoomState / _this.maxZoom;\n        } else if (_this.camera.zoom < _this.minZoom) {\n          _this.camera.zoom = _this.minZoom;\n          sizeInverse = _this._zoomState / _this.minZoom;\n        }\n        _this.camera.updateProjectionMatrix();\n        _this._v3_1.setFromMatrixPosition(_this._gizmoMatrixState);\n        _this._scaleMatrix.makeScale(sizeInverse, sizeInverse, sizeInverse);\n        _this._translationMatrix.makeTranslation(-_this._v3_1.x, -_this._v3_1.y, -_this._v3_1.z);\n        _this._m4_2.makeTranslation(_this._v3_1.x, _this._v3_1.y, _this._v3_1.z).multiply(_this._scaleMatrix);\n        _this._m4_2.multiply(_this._translationMatrix);\n        scalePoint.sub(_this._v3_1);\n        var amount = scalePoint.clone().multiplyScalar(sizeInverse);\n        scalePoint.sub(amount);\n        _this._m4_1.makeTranslation(scalePoint.x, scalePoint.y, scalePoint.z);\n        _this._m4_2.premultiply(_this._m4_1);\n        _this.setTransformationMatrices(_this._m4_1, _this._m4_2);\n        return _transformation;\n      }\n      if (_this.camera instanceof PerspectiveCamera) {\n        _this._v3_1.setFromMatrixPosition(_this._cameraMatrixState);\n        _this._v3_2.setFromMatrixPosition(_this._gizmoMatrixState);\n        var distance = _this._v3_1.distanceTo(scalePoint);\n        var _amount = distance - distance * sizeInverse;\n        var newDistance = distance - _amount;\n        if (newDistance < _this.minDistance) {\n          sizeInverse = _this.minDistance / distance;\n          _amount = distance - distance * sizeInverse;\n        } else if (newDistance > _this.maxDistance) {\n          sizeInverse = _this.maxDistance / distance;\n          _amount = distance - distance * sizeInverse;\n        }\n        var direction = scalePoint.clone().sub(_this._v3_1).normalize().multiplyScalar(_amount);\n        _this._m4_1.makeTranslation(direction.x, direction.y, direction.z);\n        if (scaleGizmos) {\n          var pos = _this._v3_2;\n          distance = pos.distanceTo(scalePoint);\n          _amount = distance - distance * sizeInverse;\n          direction = scalePoint.clone().sub(_this._v3_2).normalize().multiplyScalar(_amount);\n          _this._translationMatrix.makeTranslation(pos.x, pos.y, pos.z);\n          _this._scaleMatrix.makeScale(sizeInverse, sizeInverse, sizeInverse);\n          _this._m4_2.makeTranslation(direction.x, direction.y, direction.z).multiply(_this._translationMatrix);\n          _this._m4_2.multiply(_this._scaleMatrix);\n          _this._translationMatrix.makeTranslation(-pos.x, -pos.y, -pos.z);\n          _this._m4_2.multiply(_this._translationMatrix);\n          _this.setTransformationMatrices(_this._m4_1, _this._m4_2);\n        } else {\n          _this.setTransformationMatrices(_this._m4_1);\n        }\n        return _transformation;\n      }\n    });\n    /**\n     * Set camera fov\n     * @param {Number} value fov to be setted\n     */\n    __publicField(_assertThisInitialized(_this), \"setFov\", function (value) {\n      if (_this.camera instanceof PerspectiveCamera) {\n        _this.camera.fov = MathUtils.clamp(value, _this.minFov, _this.maxFov);\n        _this.camera.updateProjectionMatrix();\n      }\n    });\n    /**\n     * Set the trackball's center point\n     * @param {Number} x X coordinate\n     * @param {Number} y Y coordinate\n     * @param {Number} z Z coordinate\n     */\n    __publicField(_assertThisInitialized(_this), \"setTarget\", function (x, y, z) {\n      if (_this.camera) {\n        _this.target.set(x, y, z);\n        _this._gizmos.position.set(x, y, z);\n        var tbRadius = _this.calculateTbRadius(_this.camera);\n        if (tbRadius !== void 0) {\n          _this._tbRadius = tbRadius;\n        }\n        _this.makeGizmos(_this.target, _this._tbRadius);\n        _this.camera.lookAt(_this.target);\n      }\n    });\n    /**\n     * Rotate camera around its direction axis passing by a given point by a given angle\n     * @param {Vector3} point The point where the rotation axis is passing trough\n     * @param {Number} angle Angle in radians\n     * @returns The computed transormation matix\n     */\n    __publicField(_assertThisInitialized(_this), \"zRotate\", function (point, angle) {\n      _this._rotationMatrix.makeRotationAxis(_this._rotationAxis, angle);\n      _this._translationMatrix.makeTranslation(-point.x, -point.y, -point.z);\n      _this._m4_1.makeTranslation(point.x, point.y, point.z);\n      _this._m4_1.multiply(_this._rotationMatrix);\n      _this._m4_1.multiply(_this._translationMatrix);\n      _this._v3_1.setFromMatrixPosition(_this._gizmoMatrixState).sub(point);\n      _this._v3_2.copy(_this._v3_1).applyAxisAngle(_this._rotationAxis, angle);\n      _this._v3_2.sub(_this._v3_1);\n      _this._m4_2.makeTranslation(_this._v3_2.x, _this._v3_2.y, _this._v3_2.z);\n      _this.setTransformationMatrices(_this._m4_1, _this._m4_2);\n      return _transformation;\n    });\n    /**\n     * Unproject the cursor on the 3D object surface\n     * @param {Vector2} cursor Cursor coordinates in NDC\n     * @param {Camera} camera Virtual camera\n     * @returns {Vector3} The point of intersection with the model, if exist, null otherwise\n     */\n    __publicField(_assertThisInitialized(_this), \"unprojectOnObj\", function (cursor, camera) {\n      if (!_this.scene) return null;\n      var raycaster = new Raycaster();\n      raycaster.near = camera.near;\n      raycaster.far = camera.far;\n      raycaster.setFromCamera(cursor, camera);\n      var intersect = raycaster.intersectObjects(_this.scene.children, true);\n      for (var i = 0; i < intersect.length; i++) {\n        if (intersect[i].object.uuid != _this._gizmos.uuid && intersect[i].face) {\n          return intersect[i].point.clone();\n        }\n      }\n      return null;\n    });\n    /**\n     * Unproject the cursor on the trackball surface\n     * @param {Camera} camera The virtual camera\n     * @param {Number} cursorX Cursor horizontal coordinate on screen\n     * @param {Number} cursorY Cursor vertical coordinate on screen\n     * @param {HTMLElement} canvas The canvas where the renderer draws its output\n     * @param {number} tbRadius The trackball radius\n     * @returns {Vector3} The unprojected point on the trackball surface\n     */\n    __publicField(_assertThisInitialized(_this), \"unprojectOnTbSurface\", function (camera, cursorX, cursorY, canvas, tbRadius) {\n      if (camera instanceof OrthographicCamera) {\n        _this._v2_1.copy(_this.getCursorPosition(cursorX, cursorY, canvas));\n        _this._v3_1.set(_this._v2_1.x, _this._v2_1.y, 0);\n        var x2 = Math.pow(_this._v2_1.x, 2);\n        var y2 = Math.pow(_this._v2_1.y, 2);\n        var r2 = Math.pow(_this._tbRadius, 2);\n        if (x2 + y2 <= r2 * 0.5) {\n          _this._v3_1.setZ(Math.sqrt(r2 - (x2 + y2)));\n        } else {\n          _this._v3_1.setZ(r2 * 0.5 / Math.sqrt(x2 + y2));\n        }\n        return _this._v3_1;\n      }\n      if (camera instanceof PerspectiveCamera) {\n        _this._v2_1.copy(_this.getCursorNDC(cursorX, cursorY, canvas));\n        _this._v3_1.set(_this._v2_1.x, _this._v2_1.y, -1);\n        _this._v3_1.applyMatrix4(camera.projectionMatrixInverse);\n        var rayDir = _this._v3_1.clone().normalize();\n        var cameraGizmoDistance = camera.position.distanceTo(_this._gizmos.position);\n        var radius2 = Math.pow(tbRadius, 2);\n        var h = _this._v3_1.z;\n        var l = Math.sqrt(Math.pow(_this._v3_1.x, 2) + Math.pow(_this._v3_1.y, 2));\n        if (l == 0) {\n          rayDir.set(_this._v3_1.x, _this._v3_1.y, tbRadius);\n          return rayDir;\n        }\n        var m = h / l;\n        var q = cameraGizmoDistance;\n        var a = Math.pow(m, 2) + 1;\n        var b = 2 * m * q;\n        var c = Math.pow(q, 2) - radius2;\n        var delta = Math.pow(b, 2) - 4 * a * c;\n        if (delta >= 0) {\n          _this._v2_1.setX((-b - Math.sqrt(delta)) / (2 * a));\n          _this._v2_1.setY(m * _this._v2_1.x + q);\n          var angle = MathUtils.RAD2DEG * _this._v2_1.angle();\n          if (angle >= 45) {\n            var rayLength2 = Math.sqrt(Math.pow(_this._v2_1.x, 2) + Math.pow(cameraGizmoDistance - _this._v2_1.y, 2));\n            rayDir.multiplyScalar(rayLength2);\n            rayDir.z += cameraGizmoDistance;\n            return rayDir;\n          }\n        }\n        a = m;\n        b = q;\n        c = -radius2 * 0.5;\n        delta = Math.pow(b, 2) - 4 * a * c;\n        _this._v2_1.setX((-b - Math.sqrt(delta)) / (2 * a));\n        _this._v2_1.setY(m * _this._v2_1.x + q);\n        var rayLength = Math.sqrt(Math.pow(_this._v2_1.x, 2) + Math.pow(cameraGizmoDistance - _this._v2_1.y, 2));\n        rayDir.multiplyScalar(rayLength);\n        rayDir.z += cameraGizmoDistance;\n        return rayDir;\n      }\n    });\n    /**\n     * Unproject the cursor on the plane passing through the center of the trackball orthogonal to the camera\n     * @param {Camera} camera The virtual camera\n     * @param {Number} cursorX Cursor horizontal coordinate on screen\n     * @param {Number} cursorY Cursor vertical coordinate on screen\n     * @param {HTMLElement} canvas The canvas where the renderer draws its output\n     * @param {Boolean} initialDistance If initial distance between camera and gizmos should be used for calculations instead of current (Perspective only)\n     * @returns {Vector3} The unprojected point on the trackball plane\n     */\n    __publicField(_assertThisInitialized(_this), \"unprojectOnTbPlane\", function (camera, cursorX, cursorY, canvas) {\n      var initialDistance = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n      if (camera instanceof OrthographicCamera) {\n        _this._v2_1.copy(_this.getCursorPosition(cursorX, cursorY, canvas));\n        _this._v3_1.set(_this._v2_1.x, _this._v2_1.y, 0);\n        return _this._v3_1.clone();\n      }\n      if (camera instanceof PerspectiveCamera) {\n        _this._v2_1.copy(_this.getCursorNDC(cursorX, cursorY, canvas));\n        _this._v3_1.set(_this._v2_1.x, _this._v2_1.y, -1);\n        _this._v3_1.applyMatrix4(camera.projectionMatrixInverse);\n        var rayDir = _this._v3_1.clone().normalize();\n        var h = _this._v3_1.z;\n        var l = Math.sqrt(Math.pow(_this._v3_1.x, 2) + Math.pow(_this._v3_1.y, 2));\n        var cameraGizmoDistance;\n        if (initialDistance) {\n          cameraGizmoDistance = _this._v3_1.setFromMatrixPosition(_this._cameraMatrixState0).distanceTo(_this._v3_2.setFromMatrixPosition(_this._gizmoMatrixState0));\n        } else {\n          cameraGizmoDistance = camera.position.distanceTo(_this._gizmos.position);\n        }\n        if (l == 0) {\n          rayDir.set(0, 0, 0);\n          return rayDir;\n        }\n        var m = h / l;\n        var q = cameraGizmoDistance;\n        var x = -q / m;\n        var rayLength = Math.sqrt(Math.pow(q, 2) + Math.pow(x, 2));\n        rayDir.multiplyScalar(rayLength);\n        rayDir.z = 0;\n        return rayDir;\n      }\n    });\n    /**\n     * Update camera and gizmos state\n     */\n    __publicField(_assertThisInitialized(_this), \"updateMatrixState\", function () {\n      if (!_this.camera) return;\n      _this._cameraMatrixState.copy(_this.camera.matrix);\n      _this._gizmoMatrixState.copy(_this._gizmos.matrix);\n      if (_this.camera instanceof OrthographicCamera) {\n        _this._cameraProjectionState.copy(_this.camera.projectionMatrix);\n        _this.camera.updateProjectionMatrix();\n        _this._zoomState = _this.camera.zoom;\n      }\n      if (_this.camera instanceof PerspectiveCamera) {\n        _this._fovState = _this.camera.fov;\n      }\n    });\n    /**\n     * Update the trackball FSA\n     * @param {STATE} newState New state of the FSA\n     * @param {Boolean} updateMatrices If matriices state should be updated\n     */\n    __publicField(_assertThisInitialized(_this), \"updateTbState\", function (newState, updateMatrices) {\n      _this._state = newState;\n      if (updateMatrices) {\n        _this.updateMatrixState();\n      }\n    });\n    __publicField(_assertThisInitialized(_this), \"update\", function () {\n      var EPS = 1e-6;\n      if (!_this.target.equals(_this._currentTarget) && _this.camera) {\n        _this._gizmos.position.set(_this.target.x, _this.target.y, _this.target.z);\n        var tbRadius = _this.calculateTbRadius(_this.camera);\n        if (tbRadius !== void 0) {\n          _this._tbRadius = tbRadius;\n        }\n        _this.makeGizmos(_this.target, _this._tbRadius);\n        _this._currentTarget.copy(_this.target);\n      }\n      if (!_this.camera) return;\n      if (_this.camera instanceof OrthographicCamera) {\n        if (_this.camera.zoom > _this.maxZoom || _this.camera.zoom < _this.minZoom) {\n          var newZoom = MathUtils.clamp(_this.camera.zoom, _this.minZoom, _this.maxZoom);\n          _this.applyTransformMatrix(_this.applyScale(newZoom / _this.camera.zoom, _this._gizmos.position, true));\n        }\n      }\n      if (_this.camera instanceof PerspectiveCamera) {\n        var distance = _this.camera.position.distanceTo(_this._gizmos.position);\n        if (distance > _this.maxDistance + EPS || distance < _this.minDistance - EPS) {\n          var newDistance = MathUtils.clamp(distance, _this.minDistance, _this.maxDistance);\n          _this.applyTransformMatrix(_this.applyScale(newDistance / distance, _this._gizmos.position));\n          _this.updateMatrixState();\n        }\n        if (_this.camera.fov < _this.minFov || _this.camera.fov > _this.maxFov) {\n          _this.camera.fov = MathUtils.clamp(_this.camera.fov, _this.minFov, _this.maxFov);\n          _this.camera.updateProjectionMatrix();\n        }\n        var oldRadius = _this._tbRadius;\n        var _tbRadius = _this.calculateTbRadius(_this.camera);\n        if (_tbRadius !== void 0) {\n          _this._tbRadius = _tbRadius;\n        }\n        if (oldRadius < _this._tbRadius - EPS || oldRadius > _this._tbRadius + EPS) {\n          var scale = (_this._gizmos.scale.x + _this._gizmos.scale.y + _this._gizmos.scale.z) / 3;\n          var newRadius = _this._tbRadius / scale;\n          var curve = new EllipseCurve(0, 0, newRadius, newRadius);\n          var points = curve.getPoints(_this._curvePts);\n          var curveGeometry = new BufferGeometry().setFromPoints(points);\n          for (var gizmo in _this._gizmos.children) {\n            var child = _this._gizmos.children[gizmo];\n            child.geometry = curveGeometry;\n          }\n        }\n      }\n      _this.camera.lookAt(_this._gizmos.position);\n    });\n    __publicField(_assertThisInitialized(_this), \"setStateFromJSON\", function (json) {\n      var state = JSON.parse(json);\n      if (state.arcballState && _this.camera) {\n        _this._cameraMatrixState.fromArray(state.arcballState.cameraMatrix.elements);\n        _this._cameraMatrixState.decompose(_this.camera.position, _this.camera.quaternion, _this.camera.scale);\n        _this.camera.up.copy(state.arcballState.cameraUp);\n        _this.camera.near = state.arcballState.cameraNear;\n        _this.camera.far = state.arcballState.cameraFar;\n        _this.camera.zoom = state.arcballState.cameraZoom;\n        if (_this.camera instanceof PerspectiveCamera) {\n          _this.camera.fov = state.arcballState.cameraFov;\n        }\n        _this._gizmoMatrixState.fromArray(state.arcballState.gizmoMatrix.elements);\n        _this._gizmoMatrixState.decompose(_this._gizmos.position, _this._gizmos.quaternion, _this._gizmos.scale);\n        _this.camera.updateMatrix();\n        _this.camera.updateProjectionMatrix();\n        _this._gizmos.updateMatrix();\n        var tbRadius = _this.calculateTbRadius(_this.camera);\n        if (tbRadius !== void 0) {\n          _this._tbRadius = tbRadius;\n        }\n        var gizmoTmp = new Matrix4().copy(_this._gizmoMatrixState0);\n        _this.makeGizmos(_this._gizmos.position, _this._tbRadius);\n        _this._gizmoMatrixState0.copy(gizmoTmp);\n        _this.camera.lookAt(_this._gizmos.position);\n        _this.updateTbState(STATE.IDLE, false);\n        _this.dispatchEvent(_changeEvent);\n      }\n    });\n    _this.camera = null;\n    _this.domElement = domElement;\n    _this.scene = scene;\n    _this.mouseActions = [];\n    _this._mouseOp = null;\n    _this._v2_1 = new Vector2();\n    _this._v3_1 = new Vector3();\n    _this._v3_2 = new Vector3();\n    _this._m4_1 = new Matrix4();\n    _this._m4_2 = new Matrix4();\n    _this._quat = new Quaternion();\n    _this._translationMatrix = new Matrix4();\n    _this._rotationMatrix = new Matrix4();\n    _this._scaleMatrix = new Matrix4();\n    _this._rotationAxis = new Vector3();\n    _this._cameraMatrixState = new Matrix4();\n    _this._cameraProjectionState = new Matrix4();\n    _this._fovState = 1;\n    _this._upState = new Vector3();\n    _this._zoomState = 1;\n    _this._nearPos = 0;\n    _this._farPos = 0;\n    _this._gizmoMatrixState = new Matrix4();\n    _this._up0 = new Vector3();\n    _this._zoom0 = 1;\n    _this._fov0 = 0;\n    _this._initialNear = 0;\n    _this._nearPos0 = 0;\n    _this._initialFar = 0;\n    _this._farPos0 = 0;\n    _this._cameraMatrixState0 = new Matrix4();\n    _this._gizmoMatrixState0 = new Matrix4();\n    _this._button = -1;\n    _this._touchStart = [];\n    _this._touchCurrent = [];\n    _this._input = INPUT.NONE;\n    _this._switchSensibility = 32;\n    _this._startFingerDistance = 0;\n    _this._currentFingerDistance = 0;\n    _this._startFingerRotation = 0;\n    _this._currentFingerRotation = 0;\n    _this._devPxRatio = 0;\n    _this._downValid = true;\n    _this._nclicks = 0;\n    _this._downEvents = [];\n    _this._clickStart = 0;\n    _this._maxDownTime = 250;\n    _this._maxInterval = 300;\n    _this._posThreshold = 24;\n    _this._movementThreshold = 24;\n    _this._currentCursorPosition = new Vector3();\n    _this._startCursorPosition = new Vector3();\n    _this._grid = null;\n    _this._gridPosition = new Vector3();\n    _this._gizmos = new Group();\n    _this._curvePts = 128;\n    _this._timeStart = -1;\n    _this._animationId = -1;\n    _this.focusAnimationTime = 500;\n    _this._timePrev = 0;\n    _this._timeCurrent = 0;\n    _this._anglePrev = 0;\n    _this._angleCurrent = 0;\n    _this._cursorPosPrev = new Vector3();\n    _this._cursorPosCurr = new Vector3();\n    _this._wPrev = 0;\n    _this._wCurr = 0;\n    _this.adjustNearFar = false;\n    _this.scaleFactor = 1.1;\n    _this.dampingFactor = 25;\n    _this.wMax = 20;\n    _this.enableAnimations = true;\n    _this.enableGrid = false;\n    _this.cursorZoom = false;\n    _this.minFov = 5;\n    _this.maxFov = 90;\n    _this.enabled = true;\n    _this.enablePan = true;\n    _this.enableRotate = true;\n    _this.enableZoom = true;\n    _this.minDistance = 0;\n    _this.maxDistance = Infinity;\n    _this.minZoom = 0;\n    _this.maxZoom = Infinity;\n    _this.target = new Vector3(0, 0, 0);\n    _this._currentTarget = new Vector3(0, 0, 0);\n    _this._tbRadius = 1;\n    _this._state = STATE.IDLE;\n    _this.setCamera(camera);\n    if (_this.scene) {\n      _this.scene.add(_this._gizmos);\n    }\n    _this._devPxRatio = window.devicePixelRatio;\n    _this.initializeMouseActions();\n    if (_this.domElement) _this.connect(_this.domElement);\n    window.addEventListener(\"resize\", _this.onWindowResize);\n    return _this;\n  }\n  /**\n   * Apply a transformation matrix, to the camera and gizmos\n   * @param {Object} transformation Object containing matrices to apply to camera and gizmos\n   */\n  _createClass(ArcballControls, [{\n    key: \"applyTransformMatrix\",\n    value: function applyTransformMatrix(transformation) {\n      if ((transformation == null ? void 0 : transformation.camera) && this.camera) {\n        this._m4_1.copy(this._cameraMatrixState).premultiply(transformation.camera);\n        this._m4_1.decompose(this.camera.position, this.camera.quaternion, this.camera.scale);\n        this.camera.updateMatrix();\n        if (this._state == STATE.ROTATE || this._state == STATE.ZROTATE || this._state == STATE.ANIMATION_ROTATE) {\n          this.camera.up.copy(this._upState).applyQuaternion(this.camera.quaternion);\n        }\n      }\n      if (transformation == null ? void 0 : transformation.gizmos) {\n        this._m4_1.copy(this._gizmoMatrixState).premultiply(transformation.gizmos);\n        this._m4_1.decompose(this._gizmos.position, this._gizmos.quaternion, this._gizmos.scale);\n        this._gizmos.updateMatrix();\n      }\n      if ((this._state == STATE.SCALE || this._state == STATE.FOCUS || this._state == STATE.ANIMATION_FOCUS) && this.camera) {\n        var tbRadius = this.calculateTbRadius(this.camera);\n        if (tbRadius !== void 0) {\n          this._tbRadius = tbRadius;\n        }\n        if (this.adjustNearFar) {\n          var cameraDistance = this.camera.position.distanceTo(this._gizmos.position);\n          var bb = new Box3();\n          bb.setFromObject(this._gizmos);\n          var sphere = new Sphere();\n          bb.getBoundingSphere(sphere);\n          var adjustedNearPosition = Math.max(this._nearPos0, sphere.radius + sphere.center.length());\n          var regularNearPosition = cameraDistance - this._initialNear;\n          var minNearPos = Math.min(adjustedNearPosition, regularNearPosition);\n          this.camera.near = cameraDistance - minNearPos;\n          var adjustedFarPosition = Math.min(this._farPos0, -sphere.radius + sphere.center.length());\n          var regularFarPosition = cameraDistance - this._initialFar;\n          var minFarPos = Math.min(adjustedFarPosition, regularFarPosition);\n          this.camera.far = cameraDistance - minFarPos;\n          this.camera.updateProjectionMatrix();\n        } else {\n          var update = false;\n          if (this.camera.near != this._initialNear) {\n            this.camera.near = this._initialNear;\n            update = true;\n          }\n          if (this.camera.far != this._initialFar) {\n            this.camera.far = this._initialFar;\n            update = true;\n          }\n          if (update) {\n            this.camera.updateProjectionMatrix();\n          }\n        }\n      }\n    }\n    /**\n     * Set gizmos visibility\n     * @param {Boolean} value Value of gizmos visibility\n     */\n  }, {\n    key: \"setGizmosVisible\",\n    value: function setGizmosVisible(value) {\n      this._gizmos.visible = value;\n      this.dispatchEvent(_changeEvent);\n    }\n    /**\n     * Set values in transformation object\n     * @param {Matrix4} camera Transformation to be applied to the camera\n     * @param {Matrix4} gizmos Transformation to be applied to gizmos\n     */\n  }, {\n    key: \"setTransformationMatrices\",\n    value: function setTransformationMatrices() {\n      var camera = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n      var gizmos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      if (camera) {\n        if (_transformation.camera) {\n          _transformation.camera.copy(camera);\n        } else {\n          _transformation.camera = camera.clone();\n        }\n      } else {\n        _transformation.camera = null;\n      }\n      if (gizmos) {\n        if (_transformation.gizmos) {\n          _transformation.gizmos.copy(gizmos);\n        } else {\n          _transformation.gizmos = gizmos.clone();\n        }\n      } else {\n        _transformation.gizmos = null;\n      }\n    }\n  }]);\n  return ArcballControls;\n}(EventDispatcher);\nexport { ArcballControls };","map":{"version":3,"names":["STATE","IDLE","Symbol","ROTATE","PAN","SCALE","FOV","FOCUS","ZROTATE","TOUCH_MULTI","ANIMATION_FOCUS","ANIMATION_ROTATE","INPUT","NONE","ONE_FINGER","ONE_FINGER_SWITCHED","TWO_FINGER","MULT_FINGER","CURSOR","_center","x","y","_transformation","camera","Matrix4","gizmos","_changeEvent","type","_startEvent","_endEvent","ArcballControls","_EventDispatcher","_inherits","_super","_createSuper","_this","domElement","arguments","length","undefined","scene","_classCallCheck","call","__publicField","_assertThisInitialized","scale","_gizmos","z","tbRadius","calculateTbRadius","_tbRadius","newRadius","curve","EllipseCurve","points","getPoints","_curvePts","curveGeometry","BufferGeometry","setFromPoints","gizmo","children","child","geometry","dispatchEvent","event","enabled","i","mouseActions","mouse","preventDefault","_touchStart","splice","_touchCurrent","_input","button","isPrimary","_downValid","_downEvents","push","pointerType","onSinglePanStart","window","addEventListener","onPointerMove","onPointerUp","onRotateStart","onPinchStart","onDoublePanStart","onTriplePanStart","modifier","ctrlKey","metaKey","shiftKey","_mouseOp","getOpFromAction","_button","updateTouchEvent","onSinglePanMove","movement","calculatePointersDistance","_devPxRatio","_switchSensibility","onRotateMove","onPinchMove","onDoublePanMove","onTriplePanMove","mouseOpState","getOpStateFromAction","_movementThreshold","nTouch","pointerId","removeEventListener","onSinglePanEnd","onDoublePanEnd","onPinchEnd","onRotateEnd","onTriplePanEnd","downTime","timeStamp","_maxDownTime","_nclicks","_clickStart","performance","now","clickInterval","_maxInterval","_posThreshold","onDoubleTap","shift","enableZoom","mouseOp","notchDeltaY","sgn","deltaY","size","scaleFactor","updateTbState","Math","pow","cursorZoom","enablePan","scalePoint","OrthographicCamera","_a","unprojectOnTbPlane","clientX","clientY","applyQuaternion","quaternion","multiplyScalar","zoom","add","position","PerspectiveCamera","_b","applyTransformMatrix","applyScale","_grid","disposeGrid","drawGrid","deltaX","_v3_1","setFromMatrixPosition","_cameraMatrixState","distanceTo","xNew","MathUtils","clamp","minDistance","maxDistance","tan","DEG2RAD","fov","newFov","RAD2DEG","atan","maxFov","minFov","newDistance","setFov","operation","setCenter","_animationId","cancelAnimationFrame","_timeStart","activateGizmos","rayDir","_startCursorPosition","copy","enableGrid","enableRotate","unprojectOnTbSurface","enableAnimations","_timePrev","_timeCurrent","_angleCurrent","_anglePrev","_cursorPosPrev","_cursorPosCurr","_wCurr","_wPrev","setY","getCursorNDC","_currentCursorPosition","opState","restart","_state","pan","distance","angle","angleTo","amount","max","rotate","calculateRotationAxis","calculateAngularSpeed","screenNotches","_fovState","_v3_2","_gizmoMatrixState","direction","clone","sub","normalize","_m4_1","makeTranslation","deltaTime","w","abs","self","requestAnimationFrame","t","rotationAxis","onRotationAnim","min","wMax","hitP","unprojectOnObj","onFocusAnim","focus","_startFingerRotation","getAngle","_currentFingerRotation","getWorldDirection","_rotationAxis","rotationPoint","Vector3","zRotate","_startFingerDistance","_currentFingerDistance","nFingers","setMouseAction","key","operationInput","mouseInput","keyInput","state","includes","action","p1","p2","atan2","PI","p0","t0","t1","s","sqrt","vec1","vec2","_rotationMatrix","extractRotation","_quat","setFromRotationMatrix","crossVectors","factor","halfFovV","halfFovH","aspect","top","right","point","focusPoint","_translationMatrix","gizmoStateTemp","premultiply","decompose","cameraStateTemp","color","multiplier","divisions","maxLength","tick","width","left","height","bottom","GridHelper","_gridPosition","rotateX","document","console","error","style","touchAction","onContextMenu","onPointerDown","onPointerCancel","onWheel","_c","_d","onWindowResize","_e","remove","isActive","_iterator","_createForOfIteratorHelper","_step","n","done","value","material","setValues","opacity","err","e","f","cursorX","cursorY","canvas","canvasRect","getBoundingClientRect","_v2_1","setX","lookAt","target","updateMatrix","_fov0","_cameraMatrixState0","matrix","_cameraProjectionState","projectionMatrix","_zoom0","_zoomState","_initialNear","near","_nearPos0","_nearPos","_initialFar","far","_farPos0","_farPos","_up0","up","_upState","updateProjectionMatrix","makeGizmos","tbCenter","curveMaterialX","LineBasicMaterial","fog","transparent","curveMaterialY","curveMaterialZ","gizmoX","Line","gizmoY","gizmoZ","rotation","_gizmoMatrixState0","identity","setPosition","_scaleMatrix","makeScale","clear","time","cameraMatrix","gizmoMatrix","animTime","focusAnimationTime","easeOutCubic","w0","dampingFactor","adjust","distanceFactor","set","setTransformationMatrices","axis","makeRotationAxis","multiply","JSON","stringify","arcballState","cameraFar","cameraNear","cameraUp","cameraZoom","cameraFov","navigator","clipboard","writeText","readText","then","resolved","setStateFromJSON","scaleGizmos","sizeInverse","maxZoom","minZoom","_m4_2","pos","applyAxisAngle","cursor","raycaster","Raycaster","setFromCamera","intersect","intersectObjects","object","uuid","face","getCursorPosition","x2","y2","r2","setZ","applyMatrix4","projectionMatrixInverse","cameraGizmoDistance","radius2","h","l","m","q","a","b","c","delta","rayLength2","rayLength","initialDistance","newState","updateMatrices","updateMatrixState","EPS","equals","_currentTarget","newZoom","oldRadius","json","parse","fromArray","elements","gizmoTmp","Vector2","Quaternion","Group","adjustNearFar","Infinity","setCamera","devicePixelRatio","initializeMouseActions","connect","_createClass","transformation","cameraDistance","bb","Box3","setFromObject","sphere","Sphere","getBoundingSphere","adjustedNearPosition","radius","center","regularNearPosition","minNearPos","adjustedFarPosition","regularFarPosition","minFarPos","update","setGizmosVisible","visible","EventDispatcher"],"sources":["C:\\Users\\Nayyu\\Desktop\\skibidai-public-build\\node_modules\\src\\controls\\ArcballControls.ts"],"sourcesContent":["import {\n  GridHelper,\n  EllipseCurve,\n  BufferGeometry,\n  Line,\n  LineBasicMaterial,\n  Raycaster,\n  Group,\n  Box3,\n  Sphere,\n  Quaternion,\n  Vector2,\n  Vector3,\n  Matrix4,\n  MathUtils,\n  Scene,\n  PerspectiveCamera,\n  OrthographicCamera,\n  Mesh,\n  Material,\n  EventDispatcher,\n} from 'three'\n\ntype Camera = OrthographicCamera | PerspectiveCamera\ntype Operation = 'PAN' | 'ROTATE' | 'ZOOM' | 'FOV'\ntype MouseButtonType = number | 'WHEEL'\ntype ModifierKey = 'CTRL' | 'SHIFT'\ntype MouseAction = {\n  operation: Operation\n  mouse: MouseButtonType\n  key: ModifierKey | null\n}\n\ntype Transformation = {\n  camera: Matrix4 | null\n  gizmos: Matrix4 | null\n}\n\n//trackball state\nconst STATE = {\n  IDLE: Symbol(),\n  ROTATE: Symbol(),\n  PAN: Symbol(),\n  SCALE: Symbol(),\n  FOV: Symbol(),\n  FOCUS: Symbol(),\n  ZROTATE: Symbol(),\n  TOUCH_MULTI: Symbol(),\n  ANIMATION_FOCUS: Symbol(),\n  ANIMATION_ROTATE: Symbol(),\n}\n\nconst INPUT = {\n  NONE: Symbol(),\n  ONE_FINGER: Symbol(),\n  ONE_FINGER_SWITCHED: Symbol(),\n  TWO_FINGER: Symbol(),\n  MULT_FINGER: Symbol(),\n  CURSOR: Symbol(),\n}\n\n//cursor center coordinates\nconst _center = {\n  x: 0,\n  y: 0,\n}\n\n//transformation matrices for gizmos and camera\nconst _transformation: Transformation = {\n  camera: new Matrix4(),\n  gizmos: new Matrix4(),\n}\n\n//events\nconst _changeEvent = { type: 'change' }\nconst _startEvent = { type: 'start' }\nconst _endEvent = { type: 'end' }\n\n/**\n *\n * @param {CamOrthographicCamera | PerspectiveCameraera} camera Virtual camera used in the scene\n * @param {HTMLElement=null} domElement Renderer's dom element\n * @param {Scene=null} scene The scene to be rendered\n */\nclass ArcballControls extends EventDispatcher {\n  private camera: OrthographicCamera | PerspectiveCamera | null\n  private domElement: HTMLElement | null | undefined\n  private scene: Scene | null | undefined\n\n  private mouseActions: (MouseAction & { state: Symbol })[]\n  private _mouseOp: Operation | null\n\n  private _v2_1: Vector2\n  private _v3_1: Vector3\n  private _v3_2: Vector3\n\n  private _m4_1: Matrix4\n  private _m4_2: Matrix4\n\n  private _quat: Quaternion\n\n  private _translationMatrix: Matrix4\n  private _rotationMatrix: Matrix4\n  private _scaleMatrix: Matrix4\n\n  private _rotationAxis: Vector3\n\n  private _cameraMatrixState: Matrix4\n  private _cameraProjectionState: Matrix4\n\n  private _fovState: number\n  private _upState: Vector3\n  private _zoomState: number\n  private _nearPos: number\n  private _farPos: number\n\n  private _gizmoMatrixState: Matrix4\n\n  private _up0: Vector3\n  private _zoom0: number\n  private _fov0: number\n  private _initialNear: number\n  private _nearPos0: number\n  private _initialFar: number\n  private _farPos0: number\n  private _cameraMatrixState0: Matrix4\n  private _gizmoMatrixState0: Matrix4\n\n  private _button: MouseButtonType\n  private _touchStart: PointerEvent[]\n  private _touchCurrent: PointerEvent[]\n  private _input: Symbol\n\n  private _switchSensibility: number\n  private _startFingerDistance: number\n  private _currentFingerDistance: number\n  private _startFingerRotation: number\n  private _currentFingerRotation: number\n\n  private _devPxRatio: number\n  private _downValid: boolean\n  private _nclicks: number\n  private _downEvents: PointerEvent[]\n  private _clickStart: number\n  private _maxDownTime: number\n  private _maxInterval: number\n  private _posThreshold: number\n  private _movementThreshold: number\n\n  private _currentCursorPosition: Vector3\n  private _startCursorPosition: Vector3\n\n  private _grid: GridHelper | null\n  private _gridPosition: Vector3\n\n  private _gizmos: Group\n  private _curvePts: number\n\n  private _timeStart: number\n  private _animationId: number\n\n  public focusAnimationTime: number\n\n  private _timePrev: number\n  private _timeCurrent: number\n  private _anglePrev: number\n  private _angleCurrent: number\n  private _cursorPosPrev: Vector3\n  private _cursorPosCurr: Vector3\n  private _wPrev: number\n  private _wCurr: number\n\n  public adjustNearFar: boolean\n  public scaleFactor: number\n  public dampingFactor: number\n  public wMax: number\n  public enableAnimations: boolean\n  public enableGrid: boolean\n  public cursorZoom: boolean\n  public minFov: number\n  public maxFov: number\n\n  public enabled: boolean\n  public enablePan: boolean\n  public enableRotate: boolean\n  public enableZoom: boolean\n\n  public minDistance: number\n  public maxDistance: number\n  public minZoom: number\n  public maxZoom: number\n\n  readonly target: Vector3\n  private _currentTarget: Vector3\n\n  private _tbRadius: number\n\n  private _state: Symbol\n\n  constructor(\n    camera: Camera | null,\n    domElement: HTMLElement | null | undefined = null,\n    scene: Scene | null | undefined = null,\n  ) {\n    super()\n    this.camera = null\n    this.domElement = domElement\n    this.scene = scene\n\n    this.mouseActions = []\n    this._mouseOp = null\n\n    //global vectors and matrices that are used in some operations to avoid creating new objects every time (e.g. every time cursor moves)\n    this._v2_1 = new Vector2()\n    this._v3_1 = new Vector3()\n    this._v3_2 = new Vector3()\n\n    this._m4_1 = new Matrix4()\n    this._m4_2 = new Matrix4()\n\n    this._quat = new Quaternion()\n\n    //transformation matrices\n    this._translationMatrix = new Matrix4() //matrix for translation operation\n    this._rotationMatrix = new Matrix4() //matrix for rotation operation\n    this._scaleMatrix = new Matrix4() //matrix for scaling operation\n\n    this._rotationAxis = new Vector3() //axis for rotate operation\n\n    //camera state\n    this._cameraMatrixState = new Matrix4()\n    this._cameraProjectionState = new Matrix4()\n\n    this._fovState = 1\n    this._upState = new Vector3()\n    this._zoomState = 1\n    this._nearPos = 0\n    this._farPos = 0\n\n    this._gizmoMatrixState = new Matrix4()\n\n    //initial values\n    this._up0 = new Vector3()\n    this._zoom0 = 1\n    this._fov0 = 0\n    this._initialNear = 0\n    this._nearPos0 = 0\n    this._initialFar = 0\n    this._farPos0 = 0\n    this._cameraMatrixState0 = new Matrix4()\n    this._gizmoMatrixState0 = new Matrix4()\n\n    //pointers array\n    this._button = -1\n    this._touchStart = []\n    this._touchCurrent = []\n    this._input = INPUT.NONE\n\n    //two fingers touch interaction\n    this._switchSensibility = 32 //minimum movement to be performed to fire single pan start after the second finger has been released\n    this._startFingerDistance = 0 //distance between two fingers\n    this._currentFingerDistance = 0\n    this._startFingerRotation = 0 //amount of rotation performed with two fingers\n    this._currentFingerRotation = 0\n\n    //double tap\n    this._devPxRatio = 0\n    this._downValid = true\n    this._nclicks = 0\n    this._downEvents = []\n    this._clickStart = 0 //first click time\n    this._maxDownTime = 250\n    this._maxInterval = 300\n    this._posThreshold = 24\n    this._movementThreshold = 24\n\n    //cursor positions\n    this._currentCursorPosition = new Vector3()\n    this._startCursorPosition = new Vector3()\n\n    //grid\n    this._grid = null //grid to be visualized during pan operation\n    this._gridPosition = new Vector3()\n\n    //gizmos\n    this._gizmos = new Group()\n    this._curvePts = 128\n\n    //animations\n    this._timeStart = -1 //initial time\n    this._animationId = -1\n\n    //focus animation\n    this.focusAnimationTime = 500 //duration of focus animation in ms\n\n    //rotate animation\n    this._timePrev = 0 //time at which previous rotate operation has been detected\n    this._timeCurrent = 0 //time at which current rotate operation has been detected\n    this._anglePrev = 0 //angle of previous rotation\n    this._angleCurrent = 0 //angle of current rotation\n    this._cursorPosPrev = new Vector3() //cursor position when previous rotate operation has been detected\n    this._cursorPosCurr = new Vector3() //cursor position when current rotate operation has been detected\n    this._wPrev = 0 //angular velocity of the previous rotate operation\n    this._wCurr = 0 //angular velocity of the current rotate operation\n\n    //parameters\n    this.adjustNearFar = false\n    this.scaleFactor = 1.1 //zoom/distance multiplier\n    this.dampingFactor = 25\n    this.wMax = 20 //maximum angular velocity allowed\n    this.enableAnimations = true //if animations should be performed\n    this.enableGrid = false //if grid should be showed during pan operation\n    this.cursorZoom = false //if wheel zoom should be cursor centered\n    this.minFov = 5\n    this.maxFov = 90\n\n    this.enabled = true\n    this.enablePan = true\n    this.enableRotate = true\n    this.enableZoom = true\n\n    this.minDistance = 0\n    this.maxDistance = Infinity\n    this.minZoom = 0\n    this.maxZoom = Infinity\n\n    //trackball parameters\n    this.target = new Vector3(0, 0, 0)\n    this._currentTarget = new Vector3(0, 0, 0)\n\n    this._tbRadius = 1\n\n    //FSA\n    this._state = STATE.IDLE\n\n    this.setCamera(camera)\n\n    if (this.scene) {\n      this.scene.add(this._gizmos)\n    }\n\n    this._devPxRatio = window.devicePixelRatio\n\n    this.initializeMouseActions()\n\n    if (this.domElement) this.connect(this.domElement)\n\n    window.addEventListener('resize', this.onWindowResize)\n  }\n\n  //listeners\n\n  private onWindowResize = (): void => {\n    const scale = (this._gizmos.scale.x + this._gizmos.scale.y + this._gizmos.scale.z) / 3\n    if (this.camera) {\n      const tbRadius = this.calculateTbRadius(this.camera)\n      if (tbRadius !== undefined) {\n        this._tbRadius = tbRadius\n      }\n    }\n\n    const newRadius = this._tbRadius / scale\n    // @ts-ignore\n    const curve = new EllipseCurve(0, 0, newRadius, newRadius)\n    const points = curve.getPoints(this._curvePts)\n    const curveGeometry = new BufferGeometry().setFromPoints(points)\n\n    for (const gizmo in this._gizmos.children) {\n      const child = this._gizmos.children[gizmo] as Mesh\n      child.geometry = curveGeometry\n    }\n\n    // @ts-ignore\n    this.dispatchEvent(_changeEvent)\n  }\n\n  private onContextMenu = (event: MouseEvent): void => {\n    if (!this.enabled) {\n      return\n    }\n\n    for (let i = 0; i < this.mouseActions.length; i++) {\n      if (this.mouseActions[i].mouse == 2) {\n        //prevent only if button 2 is actually used\n        event.preventDefault()\n        break\n      }\n    }\n  }\n\n  private onPointerCancel = (): void => {\n    this._touchStart.splice(0, this._touchStart.length)\n    this._touchCurrent.splice(0, this._touchCurrent.length)\n    this._input = INPUT.NONE\n  }\n\n  private onPointerDown = (event: PointerEvent): void => {\n    if (event.button == 0 && event.isPrimary) {\n      this._downValid = true\n      this._downEvents.push(event)\n    } else {\n      this._downValid = false\n    }\n\n    if (event.pointerType == 'touch' && this._input != INPUT.CURSOR) {\n      this._touchStart.push(event)\n      this._touchCurrent.push(event)\n\n      switch (this._input) {\n        case INPUT.NONE:\n          //singleStart\n          this._input = INPUT.ONE_FINGER\n          this.onSinglePanStart(event, 'ROTATE')\n\n          window.addEventListener('pointermove', this.onPointerMove)\n          window.addEventListener('pointerup', this.onPointerUp)\n\n          break\n\n        case INPUT.ONE_FINGER:\n        case INPUT.ONE_FINGER_SWITCHED:\n          //doubleStart\n          this._input = INPUT.TWO_FINGER\n\n          this.onRotateStart()\n          this.onPinchStart()\n          this.onDoublePanStart()\n\n          break\n\n        case INPUT.TWO_FINGER:\n          //multipleStart\n          this._input = INPUT.MULT_FINGER\n          this.onTriplePanStart()\n          break\n      }\n    } else if (event.pointerType != 'touch' && this._input == INPUT.NONE) {\n      let modifier: ModifierKey | null = null\n\n      if (event.ctrlKey || event.metaKey) {\n        modifier = 'CTRL'\n      } else if (event.shiftKey) {\n        modifier = 'SHIFT'\n      }\n\n      this._mouseOp = this.getOpFromAction(event.button, modifier)\n      if (this._mouseOp) {\n        window.addEventListener('pointermove', this.onPointerMove)\n        window.addEventListener('pointerup', this.onPointerUp)\n\n        //singleStart\n        this._input = INPUT.CURSOR\n        this._button = event.button\n        this.onSinglePanStart(event, this._mouseOp)\n      }\n    }\n  }\n\n  private onPointerMove = (event: PointerEvent): void => {\n    if (event.pointerType == 'touch' && this._input != INPUT.CURSOR) {\n      switch (this._input) {\n        case INPUT.ONE_FINGER:\n          //singleMove\n          this.updateTouchEvent(event)\n\n          this.onSinglePanMove(event, STATE.ROTATE)\n          break\n\n        case INPUT.ONE_FINGER_SWITCHED:\n          const movement = this.calculatePointersDistance(this._touchCurrent[0], event) * this._devPxRatio\n\n          if (movement >= this._switchSensibility) {\n            //singleMove\n            this._input = INPUT.ONE_FINGER\n            this.updateTouchEvent(event)\n\n            this.onSinglePanStart(event, 'ROTATE')\n            break\n          }\n\n          break\n\n        case INPUT.TWO_FINGER:\n          //rotate/pan/pinchMove\n          this.updateTouchEvent(event)\n\n          this.onRotateMove()\n          this.onPinchMove()\n          this.onDoublePanMove()\n\n          break\n\n        case INPUT.MULT_FINGER:\n          //multMove\n          this.updateTouchEvent(event)\n\n          this.onTriplePanMove()\n          break\n      }\n    } else if (event.pointerType != 'touch' && this._input == INPUT.CURSOR) {\n      let modifier: ModifierKey | null = null\n\n      if (event.ctrlKey || event.metaKey) {\n        modifier = 'CTRL'\n      } else if (event.shiftKey) {\n        modifier = 'SHIFT'\n      }\n\n      const mouseOpState = this.getOpStateFromAction(this._button, modifier)\n\n      if (mouseOpState) {\n        this.onSinglePanMove(event, mouseOpState)\n      }\n    }\n\n    //checkDistance\n    if (this._downValid) {\n      const movement =\n        this.calculatePointersDistance(this._downEvents[this._downEvents.length - 1], event) * this._devPxRatio\n      if (movement > this._movementThreshold) {\n        this._downValid = false\n      }\n    }\n  }\n\n  private onPointerUp = (event: PointerEvent): void => {\n    if (event.pointerType == 'touch' && this._input != INPUT.CURSOR) {\n      const nTouch = this._touchCurrent.length\n\n      for (let i = 0; i < nTouch; i++) {\n        if (this._touchCurrent[i].pointerId == event.pointerId) {\n          this._touchCurrent.splice(i, 1)\n          this._touchStart.splice(i, 1)\n          break\n        }\n      }\n\n      switch (this._input) {\n        case INPUT.ONE_FINGER:\n        case INPUT.ONE_FINGER_SWITCHED:\n          //singleEnd\n          window.removeEventListener('pointermove', this.onPointerMove)\n          window.removeEventListener('pointerup', this.onPointerUp)\n\n          this._input = INPUT.NONE\n          this.onSinglePanEnd()\n\n          break\n\n        case INPUT.TWO_FINGER:\n          //doubleEnd\n          this.onDoublePanEnd()\n          this.onPinchEnd()\n          this.onRotateEnd()\n\n          //switching to singleStart\n          this._input = INPUT.ONE_FINGER_SWITCHED\n\n          break\n\n        case INPUT.MULT_FINGER:\n          if (this._touchCurrent.length == 0) {\n            window.removeEventListener('pointermove', this.onPointerMove)\n            window.removeEventListener('pointerup', this.onPointerUp)\n\n            //multCancel\n            this._input = INPUT.NONE\n            this.onTriplePanEnd()\n          }\n\n          break\n      }\n    } else if (event.pointerType != 'touch' && this._input == INPUT.CURSOR) {\n      window.removeEventListener('pointermove', this.onPointerMove)\n      window.removeEventListener('pointerup', this.onPointerUp)\n\n      this._input = INPUT.NONE\n      this.onSinglePanEnd()\n      this._button = -1\n    }\n\n    if (event.isPrimary) {\n      if (this._downValid) {\n        const downTime = event.timeStamp - this._downEvents[this._downEvents.length - 1].timeStamp\n\n        if (downTime <= this._maxDownTime) {\n          if (this._nclicks == 0) {\n            //first valid click detected\n            this._nclicks = 1\n            this._clickStart = performance.now()\n          } else {\n            const clickInterval = event.timeStamp - this._clickStart\n            const movement = this.calculatePointersDistance(this._downEvents[1], this._downEvents[0]) * this._devPxRatio\n\n            if (clickInterval <= this._maxInterval && movement <= this._posThreshold) {\n              //second valid click detected\n              //fire double tap and reset values\n              this._nclicks = 0\n              this._downEvents.splice(0, this._downEvents.length)\n              this.onDoubleTap(event)\n            } else {\n              //new 'first click'\n              this._nclicks = 1\n              this._downEvents.shift()\n              this._clickStart = performance.now()\n            }\n          }\n        } else {\n          this._downValid = false\n          this._nclicks = 0\n          this._downEvents.splice(0, this._downEvents.length)\n        }\n      } else {\n        this._nclicks = 0\n        this._downEvents.splice(0, this._downEvents.length)\n      }\n    }\n  }\n\n  private onWheel = (event: WheelEvent): void => {\n    if (this.enabled && this.enableZoom && this.domElement) {\n      let modifier: ModifierKey | null = null\n\n      if (event.ctrlKey || event.metaKey) {\n        modifier = 'CTRL'\n      } else if (event.shiftKey) {\n        modifier = 'SHIFT'\n      }\n\n      const mouseOp = this.getOpFromAction('WHEEL', modifier)\n\n      if (mouseOp) {\n        event.preventDefault()\n        // @ts-ignore\n        this.dispatchEvent(_startEvent)\n\n        const notchDeltaY = 125 //distance of one notch of mouse wheel\n        let sgn = event.deltaY / notchDeltaY\n\n        let size = 1\n\n        if (sgn > 0) {\n          size = 1 / this.scaleFactor\n        } else if (sgn < 0) {\n          size = this.scaleFactor\n        }\n\n        switch (mouseOp) {\n          case 'ZOOM':\n            this.updateTbState(STATE.SCALE, true)\n\n            if (sgn > 0) {\n              size = 1 / Math.pow(this.scaleFactor, sgn)\n            } else if (sgn < 0) {\n              size = Math.pow(this.scaleFactor, -sgn)\n            }\n\n            if (this.cursorZoom && this.enablePan) {\n              let scalePoint\n\n              if (this.camera instanceof OrthographicCamera) {\n                scalePoint = this.unprojectOnTbPlane(this.camera, event.clientX, event.clientY, this.domElement)\n                  ?.applyQuaternion(this.camera.quaternion)\n                  .multiplyScalar(1 / this.camera.zoom)\n                  .add(this._gizmos.position)\n              }\n\n              if (this.camera instanceof PerspectiveCamera) {\n                scalePoint = this.unprojectOnTbPlane(this.camera, event.clientX, event.clientY, this.domElement)\n                  ?.applyQuaternion(this.camera.quaternion)\n                  .add(this._gizmos.position)\n              }\n\n              if (scalePoint !== undefined) this.applyTransformMatrix(this.applyScale(size, scalePoint))\n            } else {\n              this.applyTransformMatrix(this.applyScale(size, this._gizmos.position))\n            }\n\n            if (this._grid) {\n              this.disposeGrid()\n              this.drawGrid()\n            }\n\n            this.updateTbState(STATE.IDLE, false)\n\n            // @ts-ignore\n            this.dispatchEvent(_changeEvent)\n            // @ts-ignore\n            this.dispatchEvent(_endEvent)\n\n            break\n\n          case 'FOV':\n            if (this.camera instanceof PerspectiveCamera) {\n              this.updateTbState(STATE.FOV, true)\n\n              //Vertigo effect\n\n              //\t  fov / 2\n              //\t\t|\\\n              //\t\t| \\\n              //\t\t|  \\\n              //\tx\t|\t\\\n              //\t\t| \t \\\n              //\t\t| \t  \\\n              //\t\t| _ _ _\\\n              //\t\t\ty\n\n              //check for iOs shift shortcut\n              if (event.deltaX != 0) {\n                sgn = event.deltaX / notchDeltaY\n\n                size = 1\n\n                if (sgn > 0) {\n                  size = 1 / Math.pow(this.scaleFactor, sgn)\n                } else if (sgn < 0) {\n                  size = Math.pow(this.scaleFactor, -sgn)\n                }\n              }\n\n              this._v3_1.setFromMatrixPosition(this._cameraMatrixState)\n              const x = this._v3_1.distanceTo(this._gizmos.position)\n              let xNew = x / size //distance between camera and gizmos if scale(size, scalepoint) would be performed\n\n              //check min and max distance\n              xNew = MathUtils.clamp(xNew, this.minDistance, this.maxDistance)\n\n              const y = x * Math.tan(MathUtils.DEG2RAD * this.camera.fov * 0.5)\n\n              //calculate new fov\n              let newFov = MathUtils.RAD2DEG * (Math.atan(y / xNew) * 2)\n\n              //check min and max fov\n              if (newFov > this.maxFov) {\n                newFov = this.maxFov\n              } else if (newFov < this.minFov) {\n                newFov = this.minFov\n              }\n\n              const newDistance = y / Math.tan(MathUtils.DEG2RAD * (newFov / 2))\n              size = x / newDistance\n\n              this.setFov(newFov)\n              this.applyTransformMatrix(this.applyScale(size, this._gizmos.position, false))\n            }\n\n            if (this._grid) {\n              this.disposeGrid()\n              this.drawGrid()\n            }\n\n            this.updateTbState(STATE.IDLE, false)\n\n            // @ts-ignore\n            this.dispatchEvent(_changeEvent)\n            // @ts-ignore\n            this.dispatchEvent(_endEvent)\n\n            break\n        }\n      }\n    }\n  }\n\n  private onSinglePanStart = (event: PointerEvent, operation: Operation): void => {\n    if (this.enabled && this.domElement) {\n      // @ts-ignore\n      this.dispatchEvent(_startEvent)\n\n      this.setCenter(event.clientX, event.clientY)\n\n      switch (operation) {\n        case 'PAN':\n          if (!this.enablePan) return\n\n          if (this._animationId != -1) {\n            cancelAnimationFrame(this._animationId)\n            this._animationId = -1\n            this._timeStart = -1\n\n            this.activateGizmos(false)\n            // @ts-ignore\n            this.dispatchEvent(_changeEvent)\n          }\n\n          if (this.camera) {\n            this.updateTbState(STATE.PAN, true)\n            const rayDir = this.unprojectOnTbPlane(this.camera, _center.x, _center.y, this.domElement)\n            if (rayDir !== undefined) {\n              this._startCursorPosition.copy(rayDir)\n            }\n            if (this.enableGrid) {\n              this.drawGrid()\n              // @ts-ignore\n              this.dispatchEvent(_changeEvent)\n            }\n          }\n\n          break\n\n        case 'ROTATE':\n          if (!this.enableRotate) return\n\n          if (this._animationId != -1) {\n            cancelAnimationFrame(this._animationId)\n            this._animationId = -1\n            this._timeStart = -1\n          }\n\n          if (this.camera) {\n            this.updateTbState(STATE.ROTATE, true)\n            const rayDir = this.unprojectOnTbSurface(this.camera, _center.x, _center.y, this.domElement, this._tbRadius)\n            if (rayDir !== undefined) {\n              this._startCursorPosition.copy(rayDir)\n            }\n            this.activateGizmos(true)\n            if (this.enableAnimations) {\n              this._timePrev = this._timeCurrent = performance.now()\n              this._angleCurrent = this._anglePrev = 0\n              this._cursorPosPrev.copy(this._startCursorPosition)\n              this._cursorPosCurr.copy(this._cursorPosPrev)\n              this._wCurr = 0\n              this._wPrev = this._wCurr\n            }\n          }\n\n          // @ts-ignore\n          this.dispatchEvent(_changeEvent)\n          break\n\n        case 'FOV':\n          if (!this.enableZoom) return\n\n          if (this.camera instanceof PerspectiveCamera) {\n            if (this._animationId != -1) {\n              cancelAnimationFrame(this._animationId)\n              this._animationId = -1\n              this._timeStart = -1\n\n              this.activateGizmos(false)\n              // @ts-ignore\n              this.dispatchEvent(_changeEvent)\n            }\n\n            this.updateTbState(STATE.FOV, true)\n            this._startCursorPosition.setY(this.getCursorNDC(_center.x, _center.y, this.domElement).y * 0.5)\n            this._currentCursorPosition.copy(this._startCursorPosition)\n          }\n          break\n\n        case 'ZOOM':\n          if (!this.enableZoom) return\n\n          if (this._animationId != -1) {\n            cancelAnimationFrame(this._animationId)\n            this._animationId = -1\n            this._timeStart = -1\n\n            this.activateGizmos(false)\n            // @ts-ignore\n            this.dispatchEvent(_changeEvent)\n          }\n\n          this.updateTbState(STATE.SCALE, true)\n          this._startCursorPosition.setY(this.getCursorNDC(_center.x, _center.y, this.domElement).y * 0.5)\n          this._currentCursorPosition.copy(this._startCursorPosition)\n          break\n      }\n    }\n  }\n\n  private onSinglePanMove = (event: PointerEvent, opState: Symbol): void => {\n    if (this.enabled && this.domElement) {\n      const restart = opState != this._state\n      this.setCenter(event.clientX, event.clientY)\n\n      switch (opState) {\n        case STATE.PAN:\n          if (this.enablePan && this.camera) {\n            if (restart) {\n              //switch to pan operation\n\n              // @ts-ignore\n              this.dispatchEvent(_endEvent)\n              // @ts-ignore\n              this.dispatchEvent(_startEvent)\n\n              this.updateTbState(opState, true)\n              const rayDir = this.unprojectOnTbPlane(this.camera, _center.x, _center.y, this.domElement)\n              if (rayDir !== undefined) {\n                this._startCursorPosition.copy(rayDir)\n              }\n              if (this.enableGrid) {\n                this.drawGrid()\n              }\n\n              this.activateGizmos(false)\n            } else {\n              //continue with pan operation\n              const rayDir = this.unprojectOnTbPlane(this.camera, _center.x, _center.y, this.domElement)\n              if (rayDir !== undefined) {\n                this._currentCursorPosition.copy(rayDir)\n              }\n              this.applyTransformMatrix(this.pan(this._startCursorPosition, this._currentCursorPosition))\n            }\n          }\n\n          break\n\n        case STATE.ROTATE:\n          if (this.enableRotate && this.camera) {\n            if (restart) {\n              //switch to rotate operation\n\n              // @ts-ignore\n              this.dispatchEvent(_endEvent)\n              // @ts-ignore\n              this.dispatchEvent(_startEvent)\n\n              this.updateTbState(opState, true)\n              const rayDir = this.unprojectOnTbSurface(\n                this.camera,\n                _center.x,\n                _center.y,\n                this.domElement,\n                this._tbRadius,\n              )\n              if (rayDir !== undefined) {\n                this._startCursorPosition.copy(rayDir)\n              }\n\n              if (this.enableGrid) {\n                this.disposeGrid()\n              }\n\n              this.activateGizmos(true)\n            } else {\n              //continue with rotate operation\n              const rayDir = this.unprojectOnTbSurface(\n                this.camera,\n                _center.x,\n                _center.y,\n                this.domElement,\n                this._tbRadius,\n              )\n              if (rayDir !== undefined) {\n                this._currentCursorPosition.copy(rayDir)\n              }\n\n              const distance = this._startCursorPosition.distanceTo(this._currentCursorPosition)\n              const angle = this._startCursorPosition.angleTo(this._currentCursorPosition)\n              const amount = Math.max(distance / this._tbRadius, angle) //effective rotation angle\n\n              this.applyTransformMatrix(\n                this.rotate(this.calculateRotationAxis(this._startCursorPosition, this._currentCursorPosition), amount),\n              )\n\n              if (this.enableAnimations) {\n                this._timePrev = this._timeCurrent\n                this._timeCurrent = performance.now()\n                this._anglePrev = this._angleCurrent\n                this._angleCurrent = amount\n                this._cursorPosPrev.copy(this._cursorPosCurr)\n                this._cursorPosCurr.copy(this._currentCursorPosition)\n                this._wPrev = this._wCurr\n                this._wCurr = this.calculateAngularSpeed(\n                  this._anglePrev,\n                  this._angleCurrent,\n                  this._timePrev,\n                  this._timeCurrent,\n                )\n              }\n            }\n          }\n\n          break\n\n        case STATE.SCALE:\n          if (this.enableZoom) {\n            if (restart) {\n              //switch to zoom operation\n\n              // @ts-ignore\n              this.dispatchEvent(_endEvent)\n              // @ts-ignore\n              this.dispatchEvent(_startEvent)\n\n              this.updateTbState(opState, true)\n              this._startCursorPosition.setY(this.getCursorNDC(_center.x, _center.y, this.domElement).y * 0.5)\n              this._currentCursorPosition.copy(this._startCursorPosition)\n\n              if (this.enableGrid) {\n                this.disposeGrid()\n              }\n\n              this.activateGizmos(false)\n            } else {\n              //continue with zoom operation\n              const screenNotches = 8 //how many wheel notches corresponds to a full screen pan\n              this._currentCursorPosition.setY(this.getCursorNDC(_center.x, _center.y, this.domElement).y * 0.5)\n\n              const movement = this._currentCursorPosition.y - this._startCursorPosition.y\n\n              let size = 1\n\n              if (movement < 0) {\n                size = 1 / Math.pow(this.scaleFactor, -movement * screenNotches)\n              } else if (movement > 0) {\n                size = Math.pow(this.scaleFactor, movement * screenNotches)\n              }\n\n              this.applyTransformMatrix(this.applyScale(size, this._gizmos.position))\n            }\n          }\n\n          break\n\n        case STATE.FOV:\n          if (this.enableZoom && this.camera instanceof PerspectiveCamera) {\n            if (restart) {\n              //switch to fov operation\n\n              // @ts-ignore\n              this.dispatchEvent(_endEvent)\n              // @ts-ignore\n              this.dispatchEvent(_startEvent)\n\n              this.updateTbState(opState, true)\n              this._startCursorPosition.setY(this.getCursorNDC(_center.x, _center.y, this.domElement).y * 0.5)\n              this._currentCursorPosition.copy(this._startCursorPosition)\n\n              if (this.enableGrid) {\n                this.disposeGrid()\n              }\n\n              this.activateGizmos(false)\n            } else {\n              //continue with fov operation\n              const screenNotches = 8 //how many wheel notches corresponds to a full screen pan\n              this._currentCursorPosition.setY(this.getCursorNDC(_center.x, _center.y, this.domElement).y * 0.5)\n\n              const movement = this._currentCursorPosition.y - this._startCursorPosition.y\n\n              let size = 1\n\n              if (movement < 0) {\n                size = 1 / Math.pow(this.scaleFactor, -movement * screenNotches)\n              } else if (movement > 0) {\n                size = Math.pow(this.scaleFactor, movement * screenNotches)\n              }\n\n              this._v3_1.setFromMatrixPosition(this._cameraMatrixState)\n              const x = this._v3_1.distanceTo(this._gizmos.position)\n              let xNew = x / size //distance between camera and gizmos if scale(size, scalepoint) would be performed\n\n              //check min and max distance\n              xNew = MathUtils.clamp(xNew, this.minDistance, this.maxDistance)\n\n              const y = x * Math.tan(MathUtils.DEG2RAD * this._fovState * 0.5)\n\n              //calculate new fov\n              let newFov = MathUtils.RAD2DEG * (Math.atan(y / xNew) * 2)\n\n              //check min and max fov\n              newFov = MathUtils.clamp(newFov, this.minFov, this.maxFov)\n\n              const newDistance = y / Math.tan(MathUtils.DEG2RAD * (newFov / 2))\n              size = x / newDistance\n              this._v3_2.setFromMatrixPosition(this._gizmoMatrixState)\n\n              this.setFov(newFov)\n              this.applyTransformMatrix(this.applyScale(size, this._v3_2, false))\n\n              //adjusting distance\n              const direction = this._gizmos.position\n                .clone()\n                .sub(this.camera.position)\n                .normalize()\n                .multiplyScalar(newDistance / x)\n              this._m4_1.makeTranslation(direction.x, direction.y, direction.z)\n            }\n          }\n\n          break\n      }\n\n      // @ts-ignore\n      this.dispatchEvent(_changeEvent)\n    }\n  }\n\n  private onSinglePanEnd = (): void => {\n    if (this._state == STATE.ROTATE) {\n      if (!this.enableRotate) {\n        return\n      }\n\n      if (this.enableAnimations) {\n        //perform rotation animation\n        const deltaTime = performance.now() - this._timeCurrent\n        if (deltaTime < 120) {\n          const w = Math.abs((this._wPrev + this._wCurr) / 2)\n\n          const self = this\n          this._animationId = window.requestAnimationFrame(function (t) {\n            self.updateTbState(STATE.ANIMATION_ROTATE, true)\n            const rotationAxis = self.calculateRotationAxis(self._cursorPosPrev, self._cursorPosCurr)\n\n            self.onRotationAnim(t, rotationAxis, Math.min(w, self.wMax))\n          })\n        } else {\n          //cursor has been standing still for over 120 ms since last movement\n          this.updateTbState(STATE.IDLE, false)\n          this.activateGizmos(false)\n          // @ts-ignore\n          this.dispatchEvent(_changeEvent)\n        }\n      } else {\n        this.updateTbState(STATE.IDLE, false)\n        this.activateGizmos(false)\n        // @ts-ignore\n        this.dispatchEvent(_changeEvent)\n      }\n    } else if (this._state == STATE.PAN || this._state == STATE.IDLE) {\n      this.updateTbState(STATE.IDLE, false)\n\n      if (this.enableGrid) {\n        this.disposeGrid()\n      }\n\n      this.activateGizmos(false)\n      // @ts-ignore\n      this.dispatchEvent(_changeEvent)\n    }\n\n    // @ts-ignore\n    this.dispatchEvent(_endEvent)\n  }\n\n  private onDoubleTap = (event: PointerEvent): void => {\n    if (this.enabled && this.enablePan && this.scene && this.camera && this.domElement) {\n      // @ts-ignore\n      this.dispatchEvent(_startEvent)\n\n      this.setCenter(event.clientX, event.clientY)\n      const hitP = this.unprojectOnObj(this.getCursorNDC(_center.x, _center.y, this.domElement), this.camera)\n\n      if (hitP && this.enableAnimations) {\n        const self = this\n        if (this._animationId != -1) {\n          window.cancelAnimationFrame(this._animationId)\n        }\n\n        this._timeStart = -1\n        this._animationId = window.requestAnimationFrame(function (t) {\n          self.updateTbState(STATE.ANIMATION_FOCUS, true)\n          self.onFocusAnim(t, hitP, self._cameraMatrixState, self._gizmoMatrixState)\n        })\n      } else if (hitP && !this.enableAnimations) {\n        this.updateTbState(STATE.FOCUS, true)\n        this.focus(hitP, this.scaleFactor)\n        this.updateTbState(STATE.IDLE, false)\n        // @ts-ignore\n        this.dispatchEvent(_changeEvent)\n      }\n    }\n\n    // @ts-ignore\n    this.dispatchEvent(_endEvent)\n  }\n\n  private onDoublePanStart = (): void => {\n    if (this.enabled && this.enablePan && this.camera && this.domElement) {\n      // @ts-ignore\n      this.dispatchEvent(_startEvent)\n\n      this.updateTbState(STATE.PAN, true)\n\n      this.setCenter(\n        (this._touchCurrent[0].clientX + this._touchCurrent[1].clientX) / 2,\n        (this._touchCurrent[0].clientY + this._touchCurrent[1].clientY) / 2,\n      )\n\n      const rayDir = this.unprojectOnTbPlane(this.camera, _center.x, _center.y, this.domElement, true)\n      if (rayDir !== undefined) {\n        this._startCursorPosition.copy(rayDir)\n      }\n      this._currentCursorPosition.copy(this._startCursorPosition)\n\n      this.activateGizmos(false)\n    }\n  }\n\n  private onDoublePanMove = (): void => {\n    if (this.enabled && this.enablePan && this.camera && this.domElement) {\n      this.setCenter(\n        (this._touchCurrent[0].clientX + this._touchCurrent[1].clientX) / 2,\n        (this._touchCurrent[0].clientY + this._touchCurrent[1].clientY) / 2,\n      )\n\n      if (this._state != STATE.PAN) {\n        this.updateTbState(STATE.PAN, true)\n        this._startCursorPosition.copy(this._currentCursorPosition)\n      }\n\n      const rayDir = this.unprojectOnTbPlane(this.camera, _center.x, _center.y, this.domElement, true)\n      if (rayDir !== undefined) this._currentCursorPosition.copy(rayDir)\n      this.applyTransformMatrix(this.pan(this._startCursorPosition, this._currentCursorPosition, true))\n      // @ts-ignore\n      this.dispatchEvent(_changeEvent)\n    }\n  }\n\n  private onDoublePanEnd = (): void => {\n    this.updateTbState(STATE.IDLE, false)\n    // @ts-ignore\n    this.dispatchEvent(_endEvent)\n  }\n\n  private onRotateStart = (): void => {\n    if (this.enabled && this.enableRotate) {\n      // @ts-ignore\n      this.dispatchEvent(_startEvent)\n\n      this.updateTbState(STATE.ZROTATE, true)\n\n      //this._startFingerRotation = event.rotation;\n\n      this._startFingerRotation =\n        this.getAngle(this._touchCurrent[1], this._touchCurrent[0]) +\n        this.getAngle(this._touchStart[1], this._touchStart[0])\n      this._currentFingerRotation = this._startFingerRotation\n\n      this.camera?.getWorldDirection(this._rotationAxis) //rotation axis\n\n      if (!this.enablePan && !this.enableZoom) {\n        this.activateGizmos(true)\n      }\n    }\n  }\n\n  private onRotateMove = (): void => {\n    if (this.enabled && this.enableRotate && this.camera && this.domElement) {\n      this.setCenter(\n        (this._touchCurrent[0].clientX + this._touchCurrent[1].clientX) / 2,\n        (this._touchCurrent[0].clientY + this._touchCurrent[1].clientY) / 2,\n      )\n      let rotationPoint\n\n      if (this._state != STATE.ZROTATE) {\n        this.updateTbState(STATE.ZROTATE, true)\n        this._startFingerRotation = this._currentFingerRotation\n      }\n\n      //this._currentFingerRotation = event.rotation;\n      this._currentFingerRotation =\n        this.getAngle(this._touchCurrent[1], this._touchCurrent[0]) +\n        this.getAngle(this._touchStart[1], this._touchStart[0])\n\n      if (!this.enablePan) {\n        rotationPoint = new Vector3().setFromMatrixPosition(this._gizmoMatrixState)\n      } else if (this.camera) {\n        this._v3_2.setFromMatrixPosition(this._gizmoMatrixState)\n        rotationPoint = this.unprojectOnTbPlane(this.camera, _center.x, _center.y, this.domElement)\n          ?.applyQuaternion(this.camera.quaternion)\n          .multiplyScalar(1 / this.camera.zoom)\n          .add(this._v3_2)\n      }\n\n      const amount = MathUtils.DEG2RAD * (this._startFingerRotation - this._currentFingerRotation)\n\n      if (rotationPoint !== undefined) {\n        this.applyTransformMatrix(this.zRotate(rotationPoint, amount))\n      }\n      // @ts-ignore\n      this.dispatchEvent(_changeEvent)\n    }\n  }\n\n  private onRotateEnd = (): void => {\n    this.updateTbState(STATE.IDLE, false)\n    this.activateGizmos(false)\n    // @ts-ignore\n    this.dispatchEvent(_endEvent)\n  }\n\n  private onPinchStart = (): void => {\n    if (this.enabled && this.enableZoom) {\n      // @ts-ignore\n      this.dispatchEvent(_startEvent)\n      this.updateTbState(STATE.SCALE, true)\n\n      this._startFingerDistance = this.calculatePointersDistance(this._touchCurrent[0], this._touchCurrent[1])\n      this._currentFingerDistance = this._startFingerDistance\n\n      this.activateGizmos(false)\n    }\n  }\n\n  private onPinchMove = (): void => {\n    if (this.enabled && this.enableZoom && this.domElement) {\n      this.setCenter(\n        (this._touchCurrent[0].clientX + this._touchCurrent[1].clientX) / 2,\n        (this._touchCurrent[0].clientY + this._touchCurrent[1].clientY) / 2,\n      )\n      const minDistance = 12 //minimum distance between fingers (in css pixels)\n\n      if (this._state != STATE.SCALE) {\n        this._startFingerDistance = this._currentFingerDistance\n        this.updateTbState(STATE.SCALE, true)\n      }\n\n      this._currentFingerDistance = Math.max(\n        this.calculatePointersDistance(this._touchCurrent[0], this._touchCurrent[1]),\n        minDistance * this._devPxRatio,\n      )\n      const amount = this._currentFingerDistance / this._startFingerDistance\n\n      let scalePoint\n\n      if (!this.enablePan) {\n        scalePoint = this._gizmos.position\n      } else {\n        if (this.camera instanceof OrthographicCamera) {\n          scalePoint = this.unprojectOnTbPlane(this.camera, _center.x, _center.y, this.domElement)\n            ?.applyQuaternion(this.camera.quaternion)\n            .multiplyScalar(1 / this.camera.zoom)\n            .add(this._gizmos.position)\n        } else if (this.camera instanceof PerspectiveCamera) {\n          scalePoint = this.unprojectOnTbPlane(this.camera, _center.x, _center.y, this.domElement)\n            ?.applyQuaternion(this.camera.quaternion)\n            .add(this._gizmos.position)\n        }\n      }\n\n      if (scalePoint !== undefined) {\n        this.applyTransformMatrix(this.applyScale(amount, scalePoint))\n      }\n      // @ts-ignore\n      this.dispatchEvent(_changeEvent)\n    }\n  }\n\n  private onPinchEnd = (): void => {\n    this.updateTbState(STATE.IDLE, false)\n    // @ts-ignore\n    this.dispatchEvent(_endEvent)\n  }\n\n  private onTriplePanStart = (): void => {\n    if (this.enabled && this.enableZoom && this.domElement) {\n      // @ts-ignore\n      this.dispatchEvent(_startEvent)\n\n      this.updateTbState(STATE.SCALE, true)\n\n      //const center = event.center;\n      let clientX = 0\n      let clientY = 0\n      const nFingers = this._touchCurrent.length\n\n      for (let i = 0; i < nFingers; i++) {\n        clientX += this._touchCurrent[i].clientX\n        clientY += this._touchCurrent[i].clientY\n      }\n\n      this.setCenter(clientX / nFingers, clientY / nFingers)\n\n      this._startCursorPosition.setY(this.getCursorNDC(_center.x, _center.y, this.domElement).y * 0.5)\n      this._currentCursorPosition.copy(this._startCursorPosition)\n    }\n  }\n\n  private onTriplePanMove = (): void => {\n    if (this.enabled && this.enableZoom && this.camera && this.domElement) {\n      //\t  fov / 2\n      //\t\t|\\\n      //\t\t| \\\n      //\t\t|  \\\n      //\tx\t|\t\\\n      //\t\t| \t \\\n      //\t\t| \t  \\\n      //\t\t| _ _ _\\\n      //\t\t\ty\n\n      //const center = event.center;\n      let clientX = 0\n      let clientY = 0\n      const nFingers = this._touchCurrent.length\n\n      for (let i = 0; i < nFingers; i++) {\n        clientX += this._touchCurrent[i].clientX\n        clientY += this._touchCurrent[i].clientY\n      }\n\n      this.setCenter(clientX / nFingers, clientY / nFingers)\n\n      const screenNotches = 8 //how many wheel notches corresponds to a full screen pan\n      this._currentCursorPosition.setY(this.getCursorNDC(_center.x, _center.y, this.domElement).y * 0.5)\n\n      const movement = this._currentCursorPosition.y - this._startCursorPosition.y\n\n      let size = 1\n\n      if (movement < 0) {\n        size = 1 / Math.pow(this.scaleFactor, -movement * screenNotches)\n      } else if (movement > 0) {\n        size = Math.pow(this.scaleFactor, movement * screenNotches)\n      }\n\n      this._v3_1.setFromMatrixPosition(this._cameraMatrixState)\n      const x = this._v3_1.distanceTo(this._gizmos.position)\n      let xNew = x / size //distance between camera and gizmos if scale(size, scalepoint) would be performed\n\n      //check min and max distance\n      xNew = MathUtils.clamp(xNew, this.minDistance, this.maxDistance)\n\n      const y = x * Math.tan(MathUtils.DEG2RAD * this._fovState * 0.5)\n\n      //calculate new fov\n      let newFov = MathUtils.RAD2DEG * (Math.atan(y / xNew) * 2)\n\n      //check min and max fov\n      newFov = MathUtils.clamp(newFov, this.minFov, this.maxFov)\n\n      const newDistance = y / Math.tan(MathUtils.DEG2RAD * (newFov / 2))\n      size = x / newDistance\n      this._v3_2.setFromMatrixPosition(this._gizmoMatrixState)\n\n      this.setFov(newFov)\n      this.applyTransformMatrix(this.applyScale(size, this._v3_2, false))\n\n      //adjusting distance\n      const direction = this._gizmos.position\n        .clone()\n        .sub(this.camera.position)\n        .normalize()\n        .multiplyScalar(newDistance / x)\n      this._m4_1.makeTranslation(direction.x, direction.y, direction.z)\n\n      // @ts-ignore\n      this.dispatchEvent(_changeEvent)\n    }\n  }\n\n  private onTriplePanEnd = (): void => {\n    this.updateTbState(STATE.IDLE, false)\n    // @ts-ignore\n    this.dispatchEvent(_endEvent)\n    //this.dispatchEvent( _changeEvent );\n  }\n\n  /**\n   * Set _center's x/y coordinates\n   * @param {Number} clientX\n   * @param {Number} clientY\n   */\n  private setCenter = (clientX: number, clientY: number): void => {\n    _center.x = clientX\n    _center.y = clientY\n  }\n\n  /**\n   * Set default mouse actions\n   */\n  private initializeMouseActions = (): void => {\n    this.setMouseAction('PAN', 0, 'CTRL')\n    this.setMouseAction('PAN', 2)\n\n    this.setMouseAction('ROTATE', 0)\n\n    this.setMouseAction('ZOOM', 'WHEEL')\n    this.setMouseAction('ZOOM', 1)\n\n    this.setMouseAction('FOV', 'WHEEL', 'SHIFT')\n    this.setMouseAction('FOV', 1, 'SHIFT')\n  }\n\n  /**\n   * Set a new mouse action by specifying the operation to be performed and a mouse/key combination. In case of conflict, replaces the existing one\n   * @param {String} operation The operation to be performed ('PAN', 'ROTATE', 'ZOOM', 'FOV)\n   * @param {*} mouse A mouse button (0, 1, 2) or 'WHEEL' for wheel notches\n   * @param {*} key The keyboard modifier ('CTRL', 'SHIFT') or null if key is not needed\n   * @returns {Boolean} True if the mouse action has been successfully added, false otherwise\n   */\n  private setMouseAction = (operation: Operation, mouse: MouseButtonType, key: ModifierKey | null = null): boolean => {\n    const operationInput = ['PAN', 'ROTATE', 'ZOOM', 'FOV']\n    const mouseInput = [0, 1, 2, 'WHEEL']\n    const keyInput = ['CTRL', 'SHIFT', null]\n    let state\n\n    if (!operationInput.includes(operation) || !mouseInput.includes(mouse) || !keyInput.includes(key)) {\n      //invalid parameters\n      return false\n    }\n\n    if (mouse == 'WHEEL') {\n      if (operation != 'ZOOM' && operation != 'FOV') {\n        //cannot associate 2D operation to 1D input\n        return false\n      }\n    }\n\n    switch (operation) {\n      case 'PAN':\n        state = STATE.PAN\n        break\n\n      case 'ROTATE':\n        state = STATE.ROTATE\n        break\n\n      case 'ZOOM':\n        state = STATE.SCALE\n        break\n\n      case 'FOV':\n        state = STATE.FOV\n        break\n    }\n\n    const action = {\n      operation: operation,\n      mouse: mouse,\n      key: key,\n      state: state,\n    }\n\n    for (let i = 0; i < this.mouseActions.length; i++) {\n      if (this.mouseActions[i].mouse == action.mouse && this.mouseActions[i].key == action.key) {\n        this.mouseActions.splice(i, 1, action)\n        return true\n      }\n    }\n\n    this.mouseActions.push(action)\n    return true\n  }\n\n  /**\n   * Return the operation associated to a mouse/keyboard combination\n   * @param {*} mouse A mouse button (0, 1, 2) or 'WHEEL' for wheel notches\n   * @param {*} key The keyboard modifier ('CTRL', 'SHIFT') or null if key is not needed\n   * @returns The operation if it has been found, null otherwise\n   */\n  private getOpFromAction = (mouse: MouseButtonType, key: ModifierKey | null): Operation | null => {\n    let action\n\n    for (let i = 0; i < this.mouseActions.length; i++) {\n      action = this.mouseActions[i]\n      if (action.mouse == mouse && action.key == key) {\n        return action.operation\n      }\n    }\n\n    if (key) {\n      for (let i = 0; i < this.mouseActions.length; i++) {\n        action = this.mouseActions[i]\n        if (action.mouse == mouse && action.key == null) {\n          return action.operation\n        }\n      }\n    }\n\n    return null\n  }\n\n  /**\n   * Get the operation associated to mouse and key combination and returns the corresponding FSA state\n   * @param {Number} mouse Mouse button\n   * @param {String} key Keyboard modifier\n   * @returns The FSA state obtained from the operation associated to mouse/keyboard combination\n   */\n  private getOpStateFromAction = (mouse: MouseButtonType, key: ModifierKey | null): Symbol | null => {\n    let action\n\n    for (let i = 0; i < this.mouseActions.length; i++) {\n      action = this.mouseActions[i]\n      if (action.mouse == mouse && action.key == key) {\n        return action.state\n      }\n    }\n\n    if (key) {\n      for (let i = 0; i < this.mouseActions.length; i++) {\n        action = this.mouseActions[i]\n        if (action.mouse == mouse && action.key == null) {\n          return action.state\n        }\n      }\n    }\n\n    return null\n  }\n\n  /**\n   * Calculate the angle between two pointers\n   * @param {PointerEvent} p1\n   * @param {PointerEvent} p2\n   * @returns {Number} The angle between two pointers in degrees\n   */\n  private getAngle = (p1: PointerEvent, p2: PointerEvent): number => {\n    return (Math.atan2(p2.clientY - p1.clientY, p2.clientX - p1.clientX) * 180) / Math.PI\n  }\n\n  /**\n   * Update a PointerEvent inside current pointerevents array\n   * @param {PointerEvent} event\n   */\n  private updateTouchEvent = (event: PointerEvent): void => {\n    for (let i = 0; i < this._touchCurrent.length; i++) {\n      if (this._touchCurrent[i].pointerId == event.pointerId) {\n        this._touchCurrent.splice(i, 1, event)\n        break\n      }\n    }\n  }\n\n  /**\n   * Apply a transformation matrix, to the camera and gizmos\n   * @param {Object} transformation Object containing matrices to apply to camera and gizmos\n   */\n  private applyTransformMatrix(transformation: Transformation | undefined): void {\n    if (transformation?.camera && this.camera) {\n      this._m4_1.copy(this._cameraMatrixState).premultiply(transformation.camera)\n      this._m4_1.decompose(this.camera.position, this.camera.quaternion, this.camera.scale)\n      this.camera.updateMatrix()\n\n      //update camera up vector\n      if (this._state == STATE.ROTATE || this._state == STATE.ZROTATE || this._state == STATE.ANIMATION_ROTATE) {\n        this.camera.up.copy(this._upState).applyQuaternion(this.camera.quaternion)\n      }\n    }\n\n    if (transformation?.gizmos) {\n      this._m4_1.copy(this._gizmoMatrixState).premultiply(transformation.gizmos)\n      this._m4_1.decompose(this._gizmos.position, this._gizmos.quaternion, this._gizmos.scale)\n      this._gizmos.updateMatrix()\n    }\n\n    if (\n      (this._state == STATE.SCALE || this._state == STATE.FOCUS || this._state == STATE.ANIMATION_FOCUS) &&\n      this.camera\n    ) {\n      const tbRadius = this.calculateTbRadius(this.camera)\n      if (tbRadius !== undefined) {\n        this._tbRadius = tbRadius\n      }\n\n      if (this.adjustNearFar) {\n        const cameraDistance = this.camera.position.distanceTo(this._gizmos.position)\n\n        const bb = new Box3()\n        bb.setFromObject(this._gizmos)\n        const sphere = new Sphere()\n        bb.getBoundingSphere(sphere)\n\n        const adjustedNearPosition = Math.max(this._nearPos0, sphere.radius + sphere.center.length())\n        const regularNearPosition = cameraDistance - this._initialNear\n\n        const minNearPos = Math.min(adjustedNearPosition, regularNearPosition)\n        this.camera.near = cameraDistance - minNearPos\n\n        const adjustedFarPosition = Math.min(this._farPos0, -sphere.radius + sphere.center.length())\n        const regularFarPosition = cameraDistance - this._initialFar\n\n        const minFarPos = Math.min(adjustedFarPosition, regularFarPosition)\n        this.camera.far = cameraDistance - minFarPos\n\n        this.camera.updateProjectionMatrix()\n      } else {\n        let update = false\n\n        if (this.camera.near != this._initialNear) {\n          this.camera.near = this._initialNear\n          update = true\n        }\n\n        if (this.camera.far != this._initialFar) {\n          this.camera.far = this._initialFar\n          update = true\n        }\n\n        if (update) {\n          this.camera.updateProjectionMatrix()\n        }\n      }\n    }\n  }\n\n  /**\n   * Calculate the angular speed\n   * @param {Number} p0 Position at t0\n   * @param {Number} p1 Position at t1\n   * @param {Number} t0 Initial time in milliseconds\n   * @param {Number} t1 Ending time in milliseconds\n   */\n  private calculateAngularSpeed = (p0: number, p1: number, t0: number, t1: number): number => {\n    const s = p1 - p0\n    const t = (t1 - t0) / 1000\n    if (t == 0) {\n      return 0\n    }\n\n    return s / t\n  }\n\n  /**\n   * Calculate the distance between two pointers\n   * @param {PointerEvent} p0 The first pointer\n   * @param {PointerEvent} p1 The second pointer\n   * @returns {number} The distance between the two pointers\n   */\n  private calculatePointersDistance = (p0: PointerEvent, p1: PointerEvent): number => {\n    return Math.sqrt(Math.pow(p1.clientX - p0.clientX, 2) + Math.pow(p1.clientY - p0.clientY, 2))\n  }\n\n  /**\n   * Calculate the rotation axis as the vector perpendicular between two vectors\n   * @param {Vector3} vec1 The first vector\n   * @param {Vector3} vec2 The second vector\n   * @returns {Vector3} The normalized rotation axis\n   */\n  private calculateRotationAxis = (vec1: Vector3, vec2: Vector3): Vector3 => {\n    this._rotationMatrix.extractRotation(this._cameraMatrixState)\n    this._quat.setFromRotationMatrix(this._rotationMatrix)\n\n    this._rotationAxis.crossVectors(vec1, vec2).applyQuaternion(this._quat)\n    return this._rotationAxis.normalize().clone()\n  }\n\n  /**\n   * Calculate the trackball radius so that gizmo's diamater will be 2/3 of the minimum side of the camera frustum\n   * @param {Camera} camera\n   * @returns {Number} The trackball radius\n   */\n  private calculateTbRadius = (camera: Camera): number | undefined => {\n    const factor = 0.67\n    const distance = camera.position.distanceTo(this._gizmos.position)\n\n    if (camera instanceof PerspectiveCamera) {\n      const halfFovV = MathUtils.DEG2RAD * camera.fov * 0.5 //vertical fov/2 in radians\n      const halfFovH = Math.atan(camera.aspect * Math.tan(halfFovV)) //horizontal fov/2 in radians\n      return Math.tan(Math.min(halfFovV, halfFovH)) * distance * factor\n    } else if (camera instanceof OrthographicCamera) {\n      return Math.min(camera.top, camera.right) * factor\n    }\n  }\n\n  /**\n   * Focus operation consist of positioning the point of interest in front of the camera and a slightly zoom in\n   * @param {Vector3} point The point of interest\n   * @param {Number} size Scale factor\n   * @param {Number} amount Amount of operation to be completed (used for focus animations, default is complete full operation)\n   */\n  private focus = (point: Vector3, size: number, amount = 1): void => {\n    if (this.camera) {\n      const focusPoint = point.clone()\n\n      //move center of camera (along with gizmos) towards point of interest\n      focusPoint.sub(this._gizmos.position).multiplyScalar(amount)\n      this._translationMatrix.makeTranslation(focusPoint.x, focusPoint.y, focusPoint.z)\n\n      const gizmoStateTemp = this._gizmoMatrixState.clone()\n      this._gizmoMatrixState.premultiply(this._translationMatrix)\n      this._gizmoMatrixState.decompose(this._gizmos.position, this._gizmos.quaternion, this._gizmos.scale)\n\n      const cameraStateTemp = this._cameraMatrixState.clone()\n      this._cameraMatrixState.premultiply(this._translationMatrix)\n      this._cameraMatrixState.decompose(this.camera.position, this.camera.quaternion, this.camera.scale)\n\n      //apply zoom\n      if (this.enableZoom) {\n        this.applyTransformMatrix(this.applyScale(size, this._gizmos.position))\n      }\n\n      this._gizmoMatrixState.copy(gizmoStateTemp)\n      this._cameraMatrixState.copy(cameraStateTemp)\n    }\n  }\n\n  /**\n   * Draw a grid and add it to the scene\n   */\n  private drawGrid = (): void => {\n    if (this.scene) {\n      const color = 0x888888\n      const multiplier = 3\n      let size, divisions, maxLength, tick\n\n      if (this.camera instanceof OrthographicCamera) {\n        const width = this.camera.right - this.camera.left\n        const height = this.camera.bottom - this.camera.top\n\n        maxLength = Math.max(width, height)\n        tick = maxLength / 20\n\n        size = (maxLength / this.camera.zoom) * multiplier\n        divisions = (size / tick) * this.camera.zoom\n      } else if (this.camera instanceof PerspectiveCamera) {\n        const distance = this.camera.position.distanceTo(this._gizmos.position)\n        const halfFovV = MathUtils.DEG2RAD * this.camera.fov * 0.5\n        const halfFovH = Math.atan(this.camera.aspect * Math.tan(halfFovV))\n\n        maxLength = Math.tan(Math.max(halfFovV, halfFovH)) * distance * 2\n        tick = maxLength / 20\n\n        size = maxLength * multiplier\n        divisions = size / tick\n      }\n\n      if (this._grid == null && this.camera) {\n        this._grid = new GridHelper(size, divisions, color, color)\n        this._grid.position.copy(this._gizmos.position)\n        this._gridPosition.copy(this._grid.position)\n        this._grid.quaternion.copy(this.camera.quaternion)\n        this._grid.rotateX(Math.PI * 0.5)\n\n        this.scene.add(this._grid)\n      }\n    }\n  }\n\n  public connect = (domElement: HTMLElement): void => {\n    // https://github.com/mrdoob/three.js/issues/20575\n\n    if ((domElement as any) === document) {\n      console.error(\n        'THREE.ArcballControls: \"document\" should not be used as the target \"domElement\". Please use \"renderer.domElement\" instead.',\n      )\n    }\n    this.domElement = domElement\n    // disables touch scroll\n    // touch-action needs to be defined for pointer events to work on mobile\n    // https://stackoverflow.com/a/48254578\n    this.domElement.style.touchAction = 'none'\n    this.domElement.addEventListener('contextmenu', this.onContextMenu)\n    this.domElement.addEventListener('pointerdown', this.onPointerDown)\n    this.domElement.addEventListener('pointercancel', this.onPointerCancel)\n    this.domElement.addEventListener('wheel', this.onWheel)\n  }\n\n  /**\n   * Remove all listeners, stop animations and clean scene\n   */\n  public dispose = (): void => {\n    if (this._animationId != -1) {\n      window.cancelAnimationFrame(this._animationId)\n    }\n\n    this.domElement?.removeEventListener('pointerdown', this.onPointerDown)\n    this.domElement?.removeEventListener('pointercancel', this.onPointerCancel)\n    this.domElement?.removeEventListener('wheel', this.onWheel)\n    this.domElement?.removeEventListener('contextmenu', this.onContextMenu)\n\n    window.removeEventListener('pointermove', this.onPointerMove)\n    window.removeEventListener('pointerup', this.onPointerUp)\n\n    window.removeEventListener('resize', this.onWindowResize)\n\n    this.scene?.remove(this._gizmos)\n    this.disposeGrid()\n  }\n\n  /**\n   * remove the grid from the scene\n   */\n  private disposeGrid = (): void => {\n    if (this._grid && this.scene) {\n      this.scene.remove(this._grid)\n      this._grid = null\n    }\n  }\n\n  /**\n   * Compute the easing out cubic function for ease out effect in animation\n   * @param {Number} t The absolute progress of the animation in the bound of 0 (beginning of the) and 1 (ending of animation)\n   * @returns {Number} Result of easing out cubic at time t\n   */\n  private easeOutCubic = (t: number): number => {\n    return 1 - Math.pow(1 - t, 3)\n  }\n\n  /**\n   * Make rotation gizmos more or less visible\n   * @param {Boolean} isActive If true, make gizmos more visible\n   */\n  private activateGizmos = (isActive: boolean): void => {\n    for (const gizmo of this._gizmos.children) {\n      ;(gizmo as Mesh<BufferGeometry, Material>).material.setValues({ opacity: isActive ? 1 : 0.6 })\n    }\n  }\n\n  /**\n   * Calculate the cursor position in NDC\n   * @param {number} x Cursor horizontal coordinate within the canvas\n   * @param {number} y Cursor vertical coordinate within the canvas\n   * @param {HTMLElement} canvas The canvas where the renderer draws its output\n   * @returns {Vector2} Cursor normalized position inside the canvas\n   */\n  private getCursorNDC = (cursorX: number, cursorY: number, canvas: HTMLElement): Vector2 => {\n    const canvasRect = canvas.getBoundingClientRect()\n    this._v2_1.setX(((cursorX - canvasRect.left) / canvasRect.width) * 2 - 1)\n    this._v2_1.setY(((canvasRect.bottom - cursorY) / canvasRect.height) * 2 - 1)\n    return this._v2_1.clone()\n  }\n\n  /**\n   * Calculate the cursor position inside the canvas x/y coordinates with the origin being in the center of the canvas\n   * @param {Number} x Cursor horizontal coordinate within the canvas\n   * @param {Number} y Cursor vertical coordinate within the canvas\n   * @param {HTMLElement} canvas The canvas where the renderer draws its output\n   * @returns {Vector2} Cursor position inside the canvas\n   */\n  private getCursorPosition = (cursorX: number, cursorY: number, canvas: HTMLElement): Vector2 => {\n    this._v2_1.copy(this.getCursorNDC(cursorX, cursorY, canvas))\n    if (this.camera instanceof OrthographicCamera) {\n      this._v2_1.x *= (this.camera.right - this.camera.left) * 0.5\n      this._v2_1.y *= (this.camera.top - this.camera.bottom) * 0.5\n    }\n    return this._v2_1.clone()\n  }\n\n  /**\n   * Set the camera to be controlled\n   * @param {Camera} camera The virtual camera to be controlled\n   */\n  private setCamera = (camera: Camera | null): void => {\n    if (camera) {\n      camera.lookAt(this.target)\n      camera.updateMatrix()\n\n      //setting state\n      if (camera instanceof PerspectiveCamera) {\n        this._fov0 = camera.fov\n        this._fovState = camera.fov\n      }\n\n      this._cameraMatrixState0.copy(camera.matrix)\n      this._cameraMatrixState.copy(this._cameraMatrixState0)\n      this._cameraProjectionState.copy(camera.projectionMatrix)\n      this._zoom0 = camera.zoom\n      this._zoomState = this._zoom0\n\n      this._initialNear = camera.near\n      this._nearPos0 = camera.position.distanceTo(this.target) - camera.near\n      this._nearPos = this._initialNear\n\n      this._initialFar = camera.far\n      this._farPos0 = camera.position.distanceTo(this.target) - camera.far\n      this._farPos = this._initialFar\n\n      this._up0.copy(camera.up)\n      this._upState.copy(camera.up)\n\n      this.camera = camera\n\n      this.camera.updateProjectionMatrix()\n\n      //making gizmos\n      const tbRadius = this.calculateTbRadius(camera)\n      if (tbRadius !== undefined) {\n        this._tbRadius = tbRadius\n      }\n      this.makeGizmos(this.target, this._tbRadius)\n    }\n  }\n\n  /**\n   * Set gizmos visibility\n   * @param {Boolean} value Value of gizmos visibility\n   */\n  public setGizmosVisible(value: boolean): void {\n    this._gizmos.visible = value\n    // @ts-ignore\n    this.dispatchEvent(_changeEvent)\n  }\n\n  /**\n   * Creates the rotation gizmos matching trackball center and radius\n   * @param {Vector3} tbCenter The trackball center\n   * @param {number} tbRadius The trackball radius\n   */\n  private makeGizmos = (tbCenter: Vector3, tbRadius: number): void => {\n    // @ts-ignore\n    const curve = new EllipseCurve(0, 0, tbRadius, tbRadius)\n    const points = curve.getPoints(this._curvePts)\n\n    //geometry\n    const curveGeometry = new BufferGeometry().setFromPoints(points)\n\n    //material\n    const curveMaterialX = new LineBasicMaterial({ color: 0xff8080, fog: false, transparent: true, opacity: 0.6 })\n    const curveMaterialY = new LineBasicMaterial({ color: 0x80ff80, fog: false, transparent: true, opacity: 0.6 })\n    const curveMaterialZ = new LineBasicMaterial({ color: 0x8080ff, fog: false, transparent: true, opacity: 0.6 })\n\n    //line\n    const gizmoX = new Line(curveGeometry, curveMaterialX)\n    const gizmoY = new Line(curveGeometry, curveMaterialY)\n    const gizmoZ = new Line(curveGeometry, curveMaterialZ)\n\n    const rotation = Math.PI * 0.5\n    gizmoX.rotation.x = rotation\n    gizmoY.rotation.y = rotation\n\n    //setting state\n    this._gizmoMatrixState0.identity().setPosition(tbCenter)\n    this._gizmoMatrixState.copy(this._gizmoMatrixState0)\n\n    if (this.camera && this.camera.zoom != 1) {\n      //adapt gizmos size to camera zoom\n      const size = 1 / this.camera.zoom\n      this._scaleMatrix.makeScale(size, size, size)\n      this._translationMatrix.makeTranslation(-tbCenter.x, -tbCenter.y, -tbCenter.z)\n\n      this._gizmoMatrixState.premultiply(this._translationMatrix).premultiply(this._scaleMatrix)\n      this._translationMatrix.makeTranslation(tbCenter.x, tbCenter.y, tbCenter.z)\n      this._gizmoMatrixState.premultiply(this._translationMatrix)\n    }\n\n    this._gizmoMatrixState.decompose(this._gizmos.position, this._gizmos.quaternion, this._gizmos.scale)\n\n    this._gizmos.clear()\n\n    this._gizmos.add(gizmoX)\n    this._gizmos.add(gizmoY)\n    this._gizmos.add(gizmoZ)\n  }\n\n  /**\n   * Perform animation for focus operation\n   * @param {Number} time Instant in which this function is called as performance.now()\n   * @param {Vector3} point Point of interest for focus operation\n   * @param {Matrix4} cameraMatrix Camera matrix\n   * @param {Matrix4} gizmoMatrix Gizmos matrix\n   */\n  private onFocusAnim = (time: number, point: Vector3, cameraMatrix: Matrix4, gizmoMatrix: Matrix4): void => {\n    if (this._timeStart == -1) {\n      //animation start\n      this._timeStart = time\n    }\n\n    if (this._state == STATE.ANIMATION_FOCUS) {\n      const deltaTime = time - this._timeStart\n      const animTime = deltaTime / this.focusAnimationTime\n\n      this._gizmoMatrixState.copy(gizmoMatrix)\n\n      if (animTime >= 1) {\n        //animation end\n\n        this._gizmoMatrixState.decompose(this._gizmos.position, this._gizmos.quaternion, this._gizmos.scale)\n\n        this.focus(point, this.scaleFactor)\n\n        this._timeStart = -1\n        this.updateTbState(STATE.IDLE, false)\n        this.activateGizmos(false)\n\n        // @ts-ignore\n        this.dispatchEvent(_changeEvent)\n      } else {\n        const amount = this.easeOutCubic(animTime)\n        const size = 1 - amount + this.scaleFactor * amount\n\n        this._gizmoMatrixState.decompose(this._gizmos.position, this._gizmos.quaternion, this._gizmos.scale)\n        this.focus(point, size, amount)\n\n        // @ts-ignore\n        this.dispatchEvent(_changeEvent)\n        const self = this\n        this._animationId = window.requestAnimationFrame(function (t) {\n          self.onFocusAnim(t, point, cameraMatrix, gizmoMatrix.clone())\n        })\n      }\n    } else {\n      //interrupt animation\n\n      this._animationId = -1\n      this._timeStart = -1\n    }\n  }\n\n  /**\n   * Perform animation for rotation operation\n   * @param {Number} time Instant in which this function is called as performance.now()\n   * @param {Vector3} rotationAxis Rotation axis\n   * @param {number} w0 Initial angular velocity\n   */\n  private onRotationAnim = (time: number, rotationAxis: Vector3, w0: number): void => {\n    if (this._timeStart == -1) {\n      //animation start\n      this._anglePrev = 0\n      this._angleCurrent = 0\n      this._timeStart = time\n    }\n\n    if (this._state == STATE.ANIMATION_ROTATE) {\n      //w = w0 + alpha * t\n      const deltaTime = (time - this._timeStart) / 1000\n      const w = w0 + -this.dampingFactor * deltaTime\n\n      if (w > 0) {\n        //tetha = 0.5 * alpha * t^2 + w0 * t + tetha0\n        this._angleCurrent = 0.5 * -this.dampingFactor * Math.pow(deltaTime, 2) + w0 * deltaTime + 0\n        this.applyTransformMatrix(this.rotate(rotationAxis, this._angleCurrent))\n        // @ts-ignore\n        this.dispatchEvent(_changeEvent)\n        const self = this\n        this._animationId = window.requestAnimationFrame(function (t) {\n          self.onRotationAnim(t, rotationAxis, w0)\n        })\n      } else {\n        this._animationId = -1\n        this._timeStart = -1\n\n        this.updateTbState(STATE.IDLE, false)\n        this.activateGizmos(false)\n\n        // @ts-ignore\n        this.dispatchEvent(_changeEvent)\n      }\n    } else {\n      //interrupt animation\n\n      this._animationId = -1\n      this._timeStart = -1\n\n      if (this._state != STATE.ROTATE) {\n        this.activateGizmos(false)\n        // @ts-ignore\n        this.dispatchEvent(_changeEvent)\n      }\n    }\n  }\n\n  /**\n   * Perform pan operation moving camera between two points\n   * @param {Vector3} p0 Initial point\n   * @param {Vector3} p1 Ending point\n   * @param {Boolean} adjust If movement should be adjusted considering camera distance (Perspective only)\n   */\n  private pan = (p0: Vector3, p1: Vector3, adjust = false): Transformation => {\n    if (this.camera) {\n      const movement = p0.clone().sub(p1)\n\n      if (this.camera instanceof OrthographicCamera) {\n        //adjust movement amount\n        movement.multiplyScalar(1 / this.camera.zoom)\n      }\n\n      if (this.camera instanceof PerspectiveCamera && adjust) {\n        //adjust movement amount\n        this._v3_1.setFromMatrixPosition(this._cameraMatrixState0) //camera's initial position\n        this._v3_2.setFromMatrixPosition(this._gizmoMatrixState0) //gizmo's initial position\n        const distanceFactor =\n          this._v3_1.distanceTo(this._v3_2) / this.camera.position.distanceTo(this._gizmos.position)\n        movement.multiplyScalar(1 / distanceFactor)\n      }\n\n      this._v3_1.set(movement.x, movement.y, 0).applyQuaternion(this.camera.quaternion)\n\n      this._m4_1.makeTranslation(this._v3_1.x, this._v3_1.y, this._v3_1.z)\n\n      this.setTransformationMatrices(this._m4_1, this._m4_1)\n    }\n    return _transformation\n  }\n\n  /**\n   * Reset trackball\n   */\n  public reset = (): void => {\n    if (this.camera) {\n      this.camera.zoom = this._zoom0\n\n      if (this.camera instanceof PerspectiveCamera) {\n        this.camera.fov = this._fov0\n      }\n\n      this.camera.near = this._nearPos\n      this.camera.far = this._farPos\n      this._cameraMatrixState.copy(this._cameraMatrixState0)\n      this._cameraMatrixState.decompose(this.camera.position, this.camera.quaternion, this.camera.scale)\n      this.camera.up.copy(this._up0)\n\n      this.camera.updateMatrix()\n      this.camera.updateProjectionMatrix()\n\n      this._gizmoMatrixState.copy(this._gizmoMatrixState0)\n      this._gizmoMatrixState0.decompose(this._gizmos.position, this._gizmos.quaternion, this._gizmos.scale)\n      this._gizmos.updateMatrix()\n\n      const tbRadius = this.calculateTbRadius(this.camera)\n      if (tbRadius !== undefined) {\n        this._tbRadius = tbRadius\n      }\n      this.makeGizmos(this._gizmos.position, this._tbRadius)\n\n      this.camera.lookAt(this._gizmos.position)\n\n      this.updateTbState(STATE.IDLE, false)\n\n      // @ts-ignore\n      this.dispatchEvent(_changeEvent)\n    }\n  }\n\n  /**\n   * Rotate the camera around an axis passing by trackball's center\n   * @param {Vector3} axis Rotation axis\n   * @param {number} angle Angle in radians\n   * @returns {Object} Object with 'camera' field containing transformation matrix resulting from the operation to be applied to the camera\n   */\n  private rotate = (axis: Vector3, angle: number): Transformation => {\n    const point = this._gizmos.position //rotation center\n    this._translationMatrix.makeTranslation(-point.x, -point.y, -point.z)\n    this._rotationMatrix.makeRotationAxis(axis, -angle)\n\n    //rotate camera\n    this._m4_1.makeTranslation(point.x, point.y, point.z)\n    this._m4_1.multiply(this._rotationMatrix)\n    this._m4_1.multiply(this._translationMatrix)\n\n    this.setTransformationMatrices(this._m4_1)\n\n    return _transformation\n  }\n\n  public copyState = (): void => {\n    if (this.camera) {\n      const state = JSON.stringify(\n        this.camera instanceof OrthographicCamera\n          ? {\n              arcballState: {\n                cameraFar: this.camera.far,\n                cameraMatrix: this.camera.matrix,\n                cameraNear: this.camera.near,\n                cameraUp: this.camera.up,\n                cameraZoom: this.camera.zoom,\n                gizmoMatrix: this._gizmos.matrix,\n              },\n            }\n          : {\n              arcballState: {\n                cameraFar: this.camera.far,\n                cameraFov: this.camera.fov,\n                cameraMatrix: this.camera.matrix,\n                cameraNear: this.camera.near,\n                cameraUp: this.camera.up,\n                cameraZoom: this.camera.zoom,\n                gizmoMatrix: this._gizmos.matrix,\n              },\n            },\n      )\n\n      navigator.clipboard.writeText(state)\n    }\n  }\n\n  public pasteState = (): void => {\n    const self = this\n    navigator.clipboard.readText().then(function resolved(value) {\n      self.setStateFromJSON(value)\n    })\n  }\n\n  /**\n   * Save the current state of the control. This can later be recovered with .reset\n   */\n  public saveState = (): void => {\n    if (!this.camera) return\n\n    this._cameraMatrixState0.copy(this.camera.matrix)\n    this._gizmoMatrixState0.copy(this._gizmos.matrix)\n    this._nearPos = this.camera.near\n    this._farPos = this.camera.far\n    this._zoom0 = this.camera.zoom\n    this._up0.copy(this.camera.up)\n\n    if (this.camera instanceof PerspectiveCamera) {\n      this._fov0 = this.camera.fov\n    }\n  }\n\n  /**\n   * Perform uniform scale operation around a given point\n   * @param {Number} size Scale factor\n   * @param {Vector3} point Point around which scale\n   * @param {Boolean} scaleGizmos If gizmos should be scaled (Perspective only)\n   * @returns {Object} Object with 'camera' and 'gizmo' fields containing transformation matrices resulting from the operation to be applied to the camera and gizmos\n   */\n  private applyScale = (size: number, point: Vector3, scaleGizmos = true): Transformation | undefined => {\n    if (!this.camera) return\n\n    const scalePoint = point.clone()\n    let sizeInverse = 1 / size\n\n    if (this.camera instanceof OrthographicCamera) {\n      //camera zoom\n      this.camera.zoom = this._zoomState\n      this.camera.zoom *= size\n\n      //check min and max zoom\n      if (this.camera.zoom > this.maxZoom) {\n        this.camera.zoom = this.maxZoom\n        sizeInverse = this._zoomState / this.maxZoom\n      } else if (this.camera.zoom < this.minZoom) {\n        this.camera.zoom = this.minZoom\n        sizeInverse = this._zoomState / this.minZoom\n      }\n\n      this.camera.updateProjectionMatrix()\n\n      this._v3_1.setFromMatrixPosition(this._gizmoMatrixState) //gizmos position\n\n      //scale gizmos so they appear in the same spot having the same dimension\n      this._scaleMatrix.makeScale(sizeInverse, sizeInverse, sizeInverse)\n      this._translationMatrix.makeTranslation(-this._v3_1.x, -this._v3_1.y, -this._v3_1.z)\n\n      this._m4_2.makeTranslation(this._v3_1.x, this._v3_1.y, this._v3_1.z).multiply(this._scaleMatrix)\n      this._m4_2.multiply(this._translationMatrix)\n\n      //move camera and gizmos to obtain pinch effect\n      scalePoint.sub(this._v3_1)\n\n      const amount = scalePoint.clone().multiplyScalar(sizeInverse)\n      scalePoint.sub(amount)\n\n      this._m4_1.makeTranslation(scalePoint.x, scalePoint.y, scalePoint.z)\n      this._m4_2.premultiply(this._m4_1)\n\n      this.setTransformationMatrices(this._m4_1, this._m4_2)\n      return _transformation\n    }\n\n    if (this.camera instanceof PerspectiveCamera) {\n      this._v3_1.setFromMatrixPosition(this._cameraMatrixState)\n      this._v3_2.setFromMatrixPosition(this._gizmoMatrixState)\n\n      //move camera\n      let distance = this._v3_1.distanceTo(scalePoint)\n      let amount = distance - distance * sizeInverse\n\n      //check min and max distance\n      const newDistance = distance - amount\n      if (newDistance < this.minDistance) {\n        sizeInverse = this.minDistance / distance\n        amount = distance - distance * sizeInverse\n      } else if (newDistance > this.maxDistance) {\n        sizeInverse = this.maxDistance / distance\n        amount = distance - distance * sizeInverse\n      }\n\n      let direction = scalePoint.clone().sub(this._v3_1).normalize().multiplyScalar(amount)\n\n      this._m4_1.makeTranslation(direction.x, direction.y, direction.z)\n\n      if (scaleGizmos) {\n        //scale gizmos so they appear in the same spot having the same dimension\n        const pos = this._v3_2\n\n        distance = pos.distanceTo(scalePoint)\n        amount = distance - distance * sizeInverse\n        direction = scalePoint.clone().sub(this._v3_2).normalize().multiplyScalar(amount)\n\n        this._translationMatrix.makeTranslation(pos.x, pos.y, pos.z)\n        this._scaleMatrix.makeScale(sizeInverse, sizeInverse, sizeInverse)\n\n        this._m4_2.makeTranslation(direction.x, direction.y, direction.z).multiply(this._translationMatrix)\n        this._m4_2.multiply(this._scaleMatrix)\n\n        this._translationMatrix.makeTranslation(-pos.x, -pos.y, -pos.z)\n\n        this._m4_2.multiply(this._translationMatrix)\n        this.setTransformationMatrices(this._m4_1, this._m4_2)\n      } else {\n        this.setTransformationMatrices(this._m4_1)\n      }\n\n      return _transformation\n    }\n  }\n\n  /**\n   * Set camera fov\n   * @param {Number} value fov to be setted\n   */\n  private setFov = (value: number): void => {\n    if (this.camera instanceof PerspectiveCamera) {\n      this.camera.fov = MathUtils.clamp(value, this.minFov, this.maxFov)\n      this.camera.updateProjectionMatrix()\n    }\n  }\n\n  /**\n   * Set the trackball's center point\n   * @param {Number} x X coordinate\n   * @param {Number} y Y coordinate\n   * @param {Number} z Z coordinate\n   */\n  public setTarget = (x: number, y: number, z: number): void => {\n    if (this.camera) {\n      this.target.set(x, y, z)\n      this._gizmos.position.set(x, y, z) //for correct radius calculation\n      const tbRadius = this.calculateTbRadius(this.camera)\n      if (tbRadius !== undefined) {\n        this._tbRadius = tbRadius\n      }\n      this.makeGizmos(this.target, this._tbRadius)\n      this.camera.lookAt(this.target)\n    }\n  }\n\n  /**\n   * Set values in transformation object\n   * @param {Matrix4} camera Transformation to be applied to the camera\n   * @param {Matrix4} gizmos Transformation to be applied to gizmos\n   */\n  private setTransformationMatrices(camera: Matrix4 | null = null, gizmos: Matrix4 | null = null): void {\n    if (camera) {\n      if (_transformation.camera) {\n        _transformation.camera.copy(camera)\n      } else {\n        _transformation.camera = camera.clone()\n      }\n    } else {\n      _transformation.camera = null\n    }\n\n    if (gizmos) {\n      if (_transformation.gizmos) {\n        _transformation.gizmos.copy(gizmos)\n      } else {\n        _transformation.gizmos = gizmos.clone()\n      }\n    } else {\n      _transformation.gizmos = null\n    }\n  }\n\n  /**\n   * Rotate camera around its direction axis passing by a given point by a given angle\n   * @param {Vector3} point The point where the rotation axis is passing trough\n   * @param {Number} angle Angle in radians\n   * @returns The computed transormation matix\n   */\n  private zRotate = (point: Vector3, angle: number): Transformation => {\n    this._rotationMatrix.makeRotationAxis(this._rotationAxis, angle)\n    this._translationMatrix.makeTranslation(-point.x, -point.y, -point.z)\n\n    this._m4_1.makeTranslation(point.x, point.y, point.z)\n    this._m4_1.multiply(this._rotationMatrix)\n    this._m4_1.multiply(this._translationMatrix)\n\n    this._v3_1.setFromMatrixPosition(this._gizmoMatrixState).sub(point) //vector from rotation center to gizmos position\n    this._v3_2.copy(this._v3_1).applyAxisAngle(this._rotationAxis, angle) //apply rotation\n    this._v3_2.sub(this._v3_1)\n\n    this._m4_2.makeTranslation(this._v3_2.x, this._v3_2.y, this._v3_2.z)\n\n    this.setTransformationMatrices(this._m4_1, this._m4_2)\n    return _transformation\n  }\n\n  /**\n   * Unproject the cursor on the 3D object surface\n   * @param {Vector2} cursor Cursor coordinates in NDC\n   * @param {Camera} camera Virtual camera\n   * @returns {Vector3} The point of intersection with the model, if exist, null otherwise\n   */\n  private unprojectOnObj = (cursor: Vector2, camera: Camera): Vector3 | null => {\n    if (!this.scene) return null\n\n    const raycaster = new Raycaster()\n    raycaster.near = camera.near\n    raycaster.far = camera.far\n    raycaster.setFromCamera(cursor, camera)\n\n    const intersect = raycaster.intersectObjects(this.scene.children, true)\n    for (let i = 0; i < intersect.length; i++) {\n      if (intersect[i].object.uuid != this._gizmos.uuid && intersect[i].face) {\n        return intersect[i].point.clone()\n      }\n    }\n\n    return null\n  }\n\n  /**\n   * Unproject the cursor on the trackball surface\n   * @param {Camera} camera The virtual camera\n   * @param {Number} cursorX Cursor horizontal coordinate on screen\n   * @param {Number} cursorY Cursor vertical coordinate on screen\n   * @param {HTMLElement} canvas The canvas where the renderer draws its output\n   * @param {number} tbRadius The trackball radius\n   * @returns {Vector3} The unprojected point on the trackball surface\n   */\n  private unprojectOnTbSurface = (\n    camera: Camera,\n    cursorX: number,\n    cursorY: number,\n    canvas: HTMLElement,\n    tbRadius: number,\n  ): Vector3 | undefined => {\n    if (camera instanceof OrthographicCamera) {\n      this._v2_1.copy(this.getCursorPosition(cursorX, cursorY, canvas))\n      this._v3_1.set(this._v2_1.x, this._v2_1.y, 0)\n\n      const x2 = Math.pow(this._v2_1.x, 2)\n      const y2 = Math.pow(this._v2_1.y, 2)\n      const r2 = Math.pow(this._tbRadius, 2)\n\n      if (x2 + y2 <= r2 * 0.5) {\n        //intersection with sphere\n        this._v3_1.setZ(Math.sqrt(r2 - (x2 + y2)))\n      } else {\n        //intersection with hyperboloid\n        this._v3_1.setZ((r2 * 0.5) / Math.sqrt(x2 + y2))\n      }\n\n      return this._v3_1\n    }\n\n    if (camera instanceof PerspectiveCamera) {\n      //unproject cursor on the near plane\n      this._v2_1.copy(this.getCursorNDC(cursorX, cursorY, canvas))\n\n      this._v3_1.set(this._v2_1.x, this._v2_1.y, -1)\n      this._v3_1.applyMatrix4(camera.projectionMatrixInverse)\n\n      const rayDir = this._v3_1.clone().normalize() //unprojected ray direction\n      const cameraGizmoDistance = camera.position.distanceTo(this._gizmos.position)\n      const radius2 = Math.pow(tbRadius, 2)\n\n      //\t  camera\n      //\t\t|\\\n      //\t\t| \\\n      //\t\t|  \\\n      //\th\t|\t\\\n      //\t\t| \t \\\n      //\t\t| \t  \\\n      //\t_ _ | _ _ _\\ _ _  near plane\n      //\t\t\tl\n\n      const h = this._v3_1.z\n      const l = Math.sqrt(Math.pow(this._v3_1.x, 2) + Math.pow(this._v3_1.y, 2))\n\n      if (l == 0) {\n        //ray aligned with camera\n        rayDir.set(this._v3_1.x, this._v3_1.y, tbRadius)\n        return rayDir\n      }\n\n      const m = h / l\n      const q = cameraGizmoDistance\n\n      /*\n       * calculate intersection point between unprojected ray and trackball surface\n       *|y = m * x + q\n       *|x^2 + y^2 = r^2\n       *\n       * (m^2 + 1) * x^2 + (2 * m * q) * x + q^2 - r^2 = 0\n       */\n      let a = Math.pow(m, 2) + 1\n      let b = 2 * m * q\n      let c = Math.pow(q, 2) - radius2\n      let delta = Math.pow(b, 2) - 4 * a * c\n\n      if (delta >= 0) {\n        //intersection with sphere\n        this._v2_1.setX((-b - Math.sqrt(delta)) / (2 * a))\n        this._v2_1.setY(m * this._v2_1.x + q)\n\n        const angle = MathUtils.RAD2DEG * this._v2_1.angle()\n\n        if (angle >= 45) {\n          //if angle between intersection point and X' axis is >= 45, return that point\n          //otherwise, calculate intersection point with hyperboloid\n\n          const rayLength = Math.sqrt(Math.pow(this._v2_1.x, 2) + Math.pow(cameraGizmoDistance - this._v2_1.y, 2))\n          rayDir.multiplyScalar(rayLength)\n          rayDir.z += cameraGizmoDistance\n          return rayDir\n        }\n      }\n\n      //intersection with hyperboloid\n      /*\n       *|y = m * x + q\n       *|y = (1 / x) * (r^2 / 2)\n       *\n       * m * x^2 + q * x - r^2 / 2 = 0\n       */\n\n      a = m\n      b = q\n      c = -radius2 * 0.5\n      delta = Math.pow(b, 2) - 4 * a * c\n      this._v2_1.setX((-b - Math.sqrt(delta)) / (2 * a))\n      this._v2_1.setY(m * this._v2_1.x + q)\n\n      const rayLength = Math.sqrt(Math.pow(this._v2_1.x, 2) + Math.pow(cameraGizmoDistance - this._v2_1.y, 2))\n\n      rayDir.multiplyScalar(rayLength)\n      rayDir.z += cameraGizmoDistance\n      return rayDir\n    }\n  }\n\n  /**\n   * Unproject the cursor on the plane passing through the center of the trackball orthogonal to the camera\n   * @param {Camera} camera The virtual camera\n   * @param {Number} cursorX Cursor horizontal coordinate on screen\n   * @param {Number} cursorY Cursor vertical coordinate on screen\n   * @param {HTMLElement} canvas The canvas where the renderer draws its output\n   * @param {Boolean} initialDistance If initial distance between camera and gizmos should be used for calculations instead of current (Perspective only)\n   * @returns {Vector3} The unprojected point on the trackball plane\n   */\n  private unprojectOnTbPlane = (\n    camera: Camera,\n    cursorX: number,\n    cursorY: number,\n    canvas: HTMLElement,\n    initialDistance = false,\n  ): Vector3 | undefined => {\n    if (camera instanceof OrthographicCamera) {\n      this._v2_1.copy(this.getCursorPosition(cursorX, cursorY, canvas))\n      this._v3_1.set(this._v2_1.x, this._v2_1.y, 0)\n\n      return this._v3_1.clone()\n    }\n\n    if (camera instanceof PerspectiveCamera) {\n      this._v2_1.copy(this.getCursorNDC(cursorX, cursorY, canvas))\n\n      //unproject cursor on the near plane\n      this._v3_1.set(this._v2_1.x, this._v2_1.y, -1)\n      this._v3_1.applyMatrix4(camera.projectionMatrixInverse)\n\n      const rayDir = this._v3_1.clone().normalize() //unprojected ray direction\n\n      //\t  camera\n      //\t\t|\\\n      //\t\t| \\\n      //\t\t|  \\\n      //\th\t|\t\\\n      //\t\t| \t \\\n      //\t\t| \t  \\\n      //\t_ _ | _ _ _\\ _ _  near plane\n      //\t\t\tl\n\n      const h = this._v3_1.z\n      const l = Math.sqrt(Math.pow(this._v3_1.x, 2) + Math.pow(this._v3_1.y, 2))\n      let cameraGizmoDistance\n\n      if (initialDistance) {\n        cameraGizmoDistance = this._v3_1\n          .setFromMatrixPosition(this._cameraMatrixState0)\n          .distanceTo(this._v3_2.setFromMatrixPosition(this._gizmoMatrixState0))\n      } else {\n        cameraGizmoDistance = camera.position.distanceTo(this._gizmos.position)\n      }\n\n      /*\n       * calculate intersection point between unprojected ray and the plane\n       *|y = mx + q\n       *|y = 0\n       *\n       * x = -q/m\n       */\n      if (l == 0) {\n        //ray aligned with camera\n        rayDir.set(0, 0, 0)\n        return rayDir\n      }\n\n      const m = h / l\n      const q = cameraGizmoDistance\n      const x = -q / m\n\n      const rayLength = Math.sqrt(Math.pow(q, 2) + Math.pow(x, 2))\n      rayDir.multiplyScalar(rayLength)\n      rayDir.z = 0\n      return rayDir\n    }\n  }\n\n  /**\n   * Update camera and gizmos state\n   */\n  private updateMatrixState = (): void => {\n    if (!this.camera) return\n\n    //update camera and gizmos state\n    this._cameraMatrixState.copy(this.camera.matrix)\n    this._gizmoMatrixState.copy(this._gizmos.matrix)\n\n    if (this.camera instanceof OrthographicCamera) {\n      this._cameraProjectionState.copy(this.camera.projectionMatrix)\n      this.camera.updateProjectionMatrix()\n      this._zoomState = this.camera.zoom\n    }\n\n    if (this.camera instanceof PerspectiveCamera) {\n      this._fovState = this.camera.fov\n    }\n  }\n\n  /**\n   * Update the trackball FSA\n   * @param {STATE} newState New state of the FSA\n   * @param {Boolean} updateMatrices If matriices state should be updated\n   */\n  private updateTbState = (newState: Symbol, updateMatrices: boolean): void => {\n    this._state = newState\n    if (updateMatrices) {\n      this.updateMatrixState()\n    }\n  }\n\n  public update = (): void => {\n    const EPS = 0.000001\n\n    // Update target and gizmos state\n    if (!this.target.equals(this._currentTarget) && this.camera) {\n      this._gizmos.position.set(this.target.x, this.target.y, this.target.z) //for correct radius calculation\n      const tbRadius = this.calculateTbRadius(this.camera)\n      if (tbRadius !== undefined) {\n        this._tbRadius = tbRadius\n      }\n      this.makeGizmos(this.target, this._tbRadius)\n      this._currentTarget.copy(this.target)\n    }\n\n    if (!this.camera) return\n\n    //check min/max parameters\n    if (this.camera instanceof OrthographicCamera) {\n      //check zoom\n      if (this.camera.zoom > this.maxZoom || this.camera.zoom < this.minZoom) {\n        const newZoom = MathUtils.clamp(this.camera.zoom, this.minZoom, this.maxZoom)\n        this.applyTransformMatrix(this.applyScale(newZoom / this.camera.zoom, this._gizmos.position, true))\n      }\n    }\n\n    if (this.camera instanceof PerspectiveCamera) {\n      //check distance\n      const distance = this.camera.position.distanceTo(this._gizmos.position)\n\n      if (distance > this.maxDistance + EPS || distance < this.minDistance - EPS) {\n        const newDistance = MathUtils.clamp(distance, this.minDistance, this.maxDistance)\n        this.applyTransformMatrix(this.applyScale(newDistance / distance, this._gizmos.position))\n        this.updateMatrixState()\n      }\n\n      //check fov\n      if (this.camera.fov < this.minFov || this.camera.fov > this.maxFov) {\n        this.camera.fov = MathUtils.clamp(this.camera.fov, this.minFov, this.maxFov)\n        this.camera.updateProjectionMatrix()\n      }\n\n      const oldRadius = this._tbRadius\n      const tbRadius = this.calculateTbRadius(this.camera)\n      if (tbRadius !== undefined) {\n        this._tbRadius = tbRadius\n      }\n\n      if (oldRadius < this._tbRadius - EPS || oldRadius > this._tbRadius + EPS) {\n        const scale = (this._gizmos.scale.x + this._gizmos.scale.y + this._gizmos.scale.z) / 3\n        const newRadius = this._tbRadius / scale\n        // @ts-ignore\n        const curve = new EllipseCurve(0, 0, newRadius, newRadius)\n        const points = curve.getPoints(this._curvePts)\n        const curveGeometry = new BufferGeometry().setFromPoints(points)\n\n        for (const gizmo in this._gizmos.children) {\n          const child = this._gizmos.children[gizmo] as Mesh\n          child.geometry = curveGeometry\n        }\n      }\n    }\n\n    this.camera.lookAt(this._gizmos.position)\n  }\n\n  private setStateFromJSON = (json: string): void => {\n    const state = JSON.parse(json)\n\n    if (state.arcballState && this.camera) {\n      this._cameraMatrixState.fromArray(state.arcballState.cameraMatrix.elements)\n      this._cameraMatrixState.decompose(this.camera.position, this.camera.quaternion, this.camera.scale)\n\n      this.camera.up.copy(state.arcballState.cameraUp)\n      this.camera.near = state.arcballState.cameraNear\n      this.camera.far = state.arcballState.cameraFar\n\n      this.camera.zoom = state.arcballState.cameraZoom\n\n      if (this.camera instanceof PerspectiveCamera) {\n        this.camera.fov = state.arcballState.cameraFov\n      }\n\n      this._gizmoMatrixState.fromArray(state.arcballState.gizmoMatrix.elements)\n      this._gizmoMatrixState.decompose(this._gizmos.position, this._gizmos.quaternion, this._gizmos.scale)\n\n      this.camera.updateMatrix()\n      this.camera.updateProjectionMatrix()\n\n      this._gizmos.updateMatrix()\n\n      const tbRadius = this.calculateTbRadius(this.camera)\n      if (tbRadius !== undefined) {\n        this._tbRadius = tbRadius\n      }\n      const gizmoTmp = new Matrix4().copy(this._gizmoMatrixState0)\n      this.makeGizmos(this._gizmos.position, this._tbRadius)\n      this._gizmoMatrixState0.copy(gizmoTmp)\n\n      this.camera.lookAt(this._gizmos.position)\n      this.updateTbState(STATE.IDLE, false)\n\n      // @ts-ignore\n      this.dispatchEvent(_changeEvent)\n    }\n  }\n}\n\nexport { ArcballControls }\n"],"mappings":";;;;;;;;;;;;;;;;;;;;AAuCA,IAAMA,KAAA,GAAQ;EACZC,IAAA,EAAMC,MAAA,CAAO;EACbC,MAAA,EAAQD,MAAA,CAAO;EACfE,GAAA,EAAKF,MAAA,CAAO;EACZG,KAAA,EAAOH,MAAA,CAAO;EACdI,GAAA,EAAKJ,MAAA,CAAO;EACZK,KAAA,EAAOL,MAAA,CAAO;EACdM,OAAA,EAASN,MAAA,CAAO;EAChBO,WAAA,EAAaP,MAAA,CAAO;EACpBQ,eAAA,EAAiBR,MAAA,CAAO;EACxBS,gBAAA,EAAkBT,MAAA,CAAO;AAC3B;AAEA,IAAMU,KAAA,GAAQ;EACZC,IAAA,EAAMX,MAAA,CAAO;EACbY,UAAA,EAAYZ,MAAA,CAAO;EACnBa,mBAAA,EAAqBb,MAAA,CAAO;EAC5Bc,UAAA,EAAYd,MAAA,CAAO;EACnBe,WAAA,EAAaf,MAAA,CAAO;EACpBgB,MAAA,EAAQhB,MAAA,CAAO;AACjB;AAGA,IAAMiB,OAAA,GAAU;EACdC,CAAA,EAAG;EACHC,CAAA,EAAG;AACL;AAGA,IAAMC,eAAA,GAAkC;EACtCC,MAAA,EAAQ,IAAIC,OAAA,CAAQ;EACpBC,MAAA,EAAQ,IAAID,OAAA,CAAQ;AACtB;AAGA,IAAME,YAAA,GAAe;EAAEC,IAAA,EAAM;AAAA;AAC7B,IAAMC,WAAA,GAAc;EAAED,IAAA,EAAM;AAAA;AAC5B,IAAME,SAAA,GAAY;EAAEF,IAAA,EAAM;AAAA;AAAA,IAQpBG,eAAA,0BAAAC,gBAAA;EAAAC,SAAA,CAAAF,eAAA,EAAAC,gBAAA;EAAA,IAAAE,MAAA,GAAAC,YAAA,CAAAJ,eAAA;EAmHJ,SAAAA,gBACEP,MAAA,EAGA;IAAA,IAAAY,KAAA;IAAA,IAFAC,UAAA,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAA6C;IAAA,IAC7CG,KAAA,GAAAH,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAkC;IAAAI,eAAA,OAAAX,eAAA;IAE5BK,KAAA,GAAAF,MAAA,CAAAS,IAAA;IAvHAC,aAAA,CAAAC,sBAAA,CAAAT,KAAA;IACAQ,aAAA,CAAAC,sBAAA,CAAAT,KAAA;IACAQ,aAAA,CAAAC,sBAAA,CAAAT,KAAA;IAEAQ,aAAA,CAAAC,sBAAA,CAAAT,KAAA;IACAQ,aAAA,CAAAC,sBAAA,CAAAT,KAAA;IAEAQ,aAAA,CAAAC,sBAAA,CAAAT,KAAA;IACAQ,aAAA,CAAAC,sBAAA,CAAAT,KAAA;IACAQ,aAAA,CAAAC,sBAAA,CAAAT,KAAA;IAEAQ,aAAA,CAAAC,sBAAA,CAAAT,KAAA;IACAQ,aAAA,CAAAC,sBAAA,CAAAT,KAAA;IAEAQ,aAAA,CAAAC,sBAAA,CAAAT,KAAA;IAEAQ,aAAA,CAAAC,sBAAA,CAAAT,KAAA;IACAQ,aAAA,CAAAC,sBAAA,CAAAT,KAAA;IACAQ,aAAA,CAAAC,sBAAA,CAAAT,KAAA;IAEAQ,aAAA,CAAAC,sBAAA,CAAAT,KAAA;IAEAQ,aAAA,CAAAC,sBAAA,CAAAT,KAAA;IACAQ,aAAA,CAAAC,sBAAA,CAAAT,KAAA;IAEAQ,aAAA,CAAAC,sBAAA,CAAAT,KAAA;IACAQ,aAAA,CAAAC,sBAAA,CAAAT,KAAA;IACAQ,aAAA,CAAAC,sBAAA,CAAAT,KAAA;IACAQ,aAAA,CAAAC,sBAAA,CAAAT,KAAA;IACAQ,aAAA,CAAAC,sBAAA,CAAAT,KAAA;IAEAQ,aAAA,CAAAC,sBAAA,CAAAT,KAAA;IAEAQ,aAAA,CAAAC,sBAAA,CAAAT,KAAA;IACAQ,aAAA,CAAAC,sBAAA,CAAAT,KAAA;IACAQ,aAAA,CAAAC,sBAAA,CAAAT,KAAA;IACAQ,aAAA,CAAAC,sBAAA,CAAAT,KAAA;IACAQ,aAAA,CAAAC,sBAAA,CAAAT,KAAA;IACAQ,aAAA,CAAAC,sBAAA,CAAAT,KAAA;IACAQ,aAAA,CAAAC,sBAAA,CAAAT,KAAA;IACAQ,aAAA,CAAAC,sBAAA,CAAAT,KAAA;IACAQ,aAAA,CAAAC,sBAAA,CAAAT,KAAA;IAEAQ,aAAA,CAAAC,sBAAA,CAAAT,KAAA;IACAQ,aAAA,CAAAC,sBAAA,CAAAT,KAAA;IACAQ,aAAA,CAAAC,sBAAA,CAAAT,KAAA;IACAQ,aAAA,CAAAC,sBAAA,CAAAT,KAAA;IAEAQ,aAAA,CAAAC,sBAAA,CAAAT,KAAA;IACAQ,aAAA,CAAAC,sBAAA,CAAAT,KAAA;IACAQ,aAAA,CAAAC,sBAAA,CAAAT,KAAA;IACAQ,aAAA,CAAAC,sBAAA,CAAAT,KAAA;IACAQ,aAAA,CAAAC,sBAAA,CAAAT,KAAA;IAEAQ,aAAA,CAAAC,sBAAA,CAAAT,KAAA;IACAQ,aAAA,CAAAC,sBAAA,CAAAT,KAAA;IACAQ,aAAA,CAAAC,sBAAA,CAAAT,KAAA;IACAQ,aAAA,CAAAC,sBAAA,CAAAT,KAAA;IACAQ,aAAA,CAAAC,sBAAA,CAAAT,KAAA;IACAQ,aAAA,CAAAC,sBAAA,CAAAT,KAAA;IACAQ,aAAA,CAAAC,sBAAA,CAAAT,KAAA;IACAQ,aAAA,CAAAC,sBAAA,CAAAT,KAAA;IACAQ,aAAA,CAAAC,sBAAA,CAAAT,KAAA;IAEAQ,aAAA,CAAAC,sBAAA,CAAAT,KAAA;IACAQ,aAAA,CAAAC,sBAAA,CAAAT,KAAA;IAEAQ,aAAA,CAAAC,sBAAA,CAAAT,KAAA;IACAQ,aAAA,CAAAC,sBAAA,CAAAT,KAAA;IAEAQ,aAAA,CAAAC,sBAAA,CAAAT,KAAA;IACAQ,aAAA,CAAAC,sBAAA,CAAAT,KAAA;IAEAQ,aAAA,CAAAC,sBAAA,CAAAT,KAAA;IACAQ,aAAA,CAAAC,sBAAA,CAAAT,KAAA;IAEDQ,aAAA,CAAAC,sBAAA,CAAAT,KAAA;IAECQ,aAAA,CAAAC,sBAAA,CAAAT,KAAA;IACAQ,aAAA,CAAAC,sBAAA,CAAAT,KAAA;IACAQ,aAAA,CAAAC,sBAAA,CAAAT,KAAA;IACAQ,aAAA,CAAAC,sBAAA,CAAAT,KAAA;IACAQ,aAAA,CAAAC,sBAAA,CAAAT,KAAA;IACAQ,aAAA,CAAAC,sBAAA,CAAAT,KAAA;IACAQ,aAAA,CAAAC,sBAAA,CAAAT,KAAA;IACAQ,aAAA,CAAAC,sBAAA,CAAAT,KAAA;IAEDQ,aAAA,CAAAC,sBAAA,CAAAT,KAAA;IACAQ,aAAA,CAAAC,sBAAA,CAAAT,KAAA;IACAQ,aAAA,CAAAC,sBAAA,CAAAT,KAAA;IACAQ,aAAA,CAAAC,sBAAA,CAAAT,KAAA;IACAQ,aAAA,CAAAC,sBAAA,CA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"},"metadata":{},"sourceType":"module","externalDependencies":[]}