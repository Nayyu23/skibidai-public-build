{"ast":null,"code":"import _classCallCheck from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/Nayyu/Desktop/skibidai-public-build/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport { Matrix4, Vector3 } from \"three\";\nvar inverseProjectionMatrix = new Matrix4();\nvar CSMFrustum = /*#__PURE__*/function () {\n  function CSMFrustum(data) {\n    _classCallCheck(this, CSMFrustum);\n    data = data || {};\n    this.vertices = {\n      near: [new Vector3(), new Vector3(), new Vector3(), new Vector3()],\n      far: [new Vector3(), new Vector3(), new Vector3(), new Vector3()]\n    };\n    if (data.projectionMatrix !== void 0) {\n      this.setFromProjectionMatrix(data.projectionMatrix, data.maxFar || 1e4);\n    }\n  }\n  _createClass(CSMFrustum, [{\n    key: \"setFromProjectionMatrix\",\n    value: function setFromProjectionMatrix(projectionMatrix, maxFar) {\n      var isOrthographic = projectionMatrix.elements[2 * 4 + 3] === 0;\n      inverseProjectionMatrix.copy(projectionMatrix).invert();\n      this.vertices.near[0].set(1, 1, -1);\n      this.vertices.near[1].set(1, -1, -1);\n      this.vertices.near[2].set(-1, -1, -1);\n      this.vertices.near[3].set(-1, 1, -1);\n      this.vertices.near.forEach(function (v) {\n        v.applyMatrix4(inverseProjectionMatrix);\n      });\n      this.vertices.far[0].set(1, 1, 1);\n      this.vertices.far[1].set(1, -1, 1);\n      this.vertices.far[2].set(-1, -1, 1);\n      this.vertices.far[3].set(-1, 1, 1);\n      this.vertices.far.forEach(function (v) {\n        v.applyMatrix4(inverseProjectionMatrix);\n        var absZ = Math.abs(v.z);\n        if (isOrthographic) {\n          v.z *= Math.min(maxFar / absZ, 1);\n        } else {\n          v.multiplyScalar(Math.min(maxFar / absZ, 1));\n        }\n      });\n      return this.vertices;\n    }\n  }, {\n    key: \"split\",\n    value: function split(breaks, target) {\n      while (breaks.length > target.length) {\n        target.push(new CSMFrustum());\n      }\n      target.length = breaks.length;\n      for (var i = 0; i < breaks.length; i++) {\n        var cascade = target[i];\n        if (i === 0) {\n          for (var j = 0; j < 4; j++) {\n            cascade.vertices.near[j].copy(this.vertices.near[j]);\n          }\n        } else {\n          for (var _j = 0; _j < 4; _j++) {\n            cascade.vertices.near[_j].lerpVectors(this.vertices.near[_j], this.vertices.far[_j], breaks[i - 1]);\n          }\n        }\n        if (i === breaks.length - 1) {\n          for (var _j2 = 0; _j2 < 4; _j2++) {\n            cascade.vertices.far[_j2].copy(this.vertices.far[_j2]);\n          }\n        } else {\n          for (var _j3 = 0; _j3 < 4; _j3++) {\n            cascade.vertices.far[_j3].lerpVectors(this.vertices.near[_j3], this.vertices.far[_j3], breaks[i]);\n          }\n        }\n      }\n    }\n  }, {\n    key: \"toSpace\",\n    value: function toSpace(cameraMatrix, target) {\n      for (var i = 0; i < 4; i++) {\n        target.vertices.near[i].copy(this.vertices.near[i]).applyMatrix4(cameraMatrix);\n        target.vertices.far[i].copy(this.vertices.far[i]).applyMatrix4(cameraMatrix);\n      }\n    }\n  }]);\n  return CSMFrustum;\n}();\nexport { CSMFrustum };","map":{"version":3,"names":["inverseProjectionMatrix","Matrix4","CSMFrustum","data","_classCallCheck","vertices","near","Vector3","far","projectionMatrix","setFromProjectionMatrix","maxFar","_createClass","key","value","isOrthographic","elements","copy","invert","set","forEach","v","applyMatrix4","absZ","Math","abs","z","min","multiplyScalar","split","breaks","target","length","push","i","cascade","j","lerpVectors","toSpace","cameraMatrix"],"sources":["C:\\Users\\Nayyu\\Desktop\\skibidai-public-build\\node_modules\\src\\csm\\CSMFrustum.js"],"sourcesContent":["import { Vector3, Matrix4 } from 'three'\n\nconst inverseProjectionMatrix = new Matrix4()\n\nclass CSMFrustum {\n  constructor(data) {\n    data = data || {}\n\n    this.vertices = {\n      near: [new Vector3(), new Vector3(), new Vector3(), new Vector3()],\n      far: [new Vector3(), new Vector3(), new Vector3(), new Vector3()],\n    }\n\n    if (data.projectionMatrix !== undefined) {\n      this.setFromProjectionMatrix(data.projectionMatrix, data.maxFar || 10000)\n    }\n  }\n\n  setFromProjectionMatrix(projectionMatrix, maxFar) {\n    const isOrthographic = projectionMatrix.elements[2 * 4 + 3] === 0\n\n    inverseProjectionMatrix.copy(projectionMatrix).invert()\n\n    // 3 --- 0  vertices.near/far order\n    // |     |\n    // 2 --- 1\n    // clip space spans from [-1, 1]\n\n    this.vertices.near[0].set(1, 1, -1)\n    this.vertices.near[1].set(1, -1, -1)\n    this.vertices.near[2].set(-1, -1, -1)\n    this.vertices.near[3].set(-1, 1, -1)\n    this.vertices.near.forEach(function (v) {\n      v.applyMatrix4(inverseProjectionMatrix)\n    })\n\n    this.vertices.far[0].set(1, 1, 1)\n    this.vertices.far[1].set(1, -1, 1)\n    this.vertices.far[2].set(-1, -1, 1)\n    this.vertices.far[3].set(-1, 1, 1)\n    this.vertices.far.forEach(function (v) {\n      v.applyMatrix4(inverseProjectionMatrix)\n\n      const absZ = Math.abs(v.z)\n      if (isOrthographic) {\n        v.z *= Math.min(maxFar / absZ, 1.0)\n      } else {\n        v.multiplyScalar(Math.min(maxFar / absZ, 1.0))\n      }\n    })\n\n    return this.vertices\n  }\n\n  split(breaks, target) {\n    while (breaks.length > target.length) {\n      target.push(new CSMFrustum())\n    }\n\n    target.length = breaks.length\n\n    for (let i = 0; i < breaks.length; i++) {\n      const cascade = target[i]\n\n      if (i === 0) {\n        for (let j = 0; j < 4; j++) {\n          cascade.vertices.near[j].copy(this.vertices.near[j])\n        }\n      } else {\n        for (let j = 0; j < 4; j++) {\n          cascade.vertices.near[j].lerpVectors(this.vertices.near[j], this.vertices.far[j], breaks[i - 1])\n        }\n      }\n\n      if (i === breaks.length - 1) {\n        for (let j = 0; j < 4; j++) {\n          cascade.vertices.far[j].copy(this.vertices.far[j])\n        }\n      } else {\n        for (let j = 0; j < 4; j++) {\n          cascade.vertices.far[j].lerpVectors(this.vertices.near[j], this.vertices.far[j], breaks[i])\n        }\n      }\n    }\n  }\n\n  toSpace(cameraMatrix, target) {\n    for (let i = 0; i < 4; i++) {\n      target.vertices.near[i].copy(this.vertices.near[i]).applyMatrix4(cameraMatrix)\n\n      target.vertices.far[i].copy(this.vertices.far[i]).applyMatrix4(cameraMatrix)\n    }\n  }\n}\n\nexport { CSMFrustum }\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}